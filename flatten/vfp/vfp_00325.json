{
    "vfp_id": "vfp_00325",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Mix-up between list and vector types in the SSZ library",
            "description": "The SSZ library incorrectly implements length handling for Merkleization, mixing up the behavior between lists and vectors.\n\nThe root cause is that intoVector() incorrectly increments length by one, while intoList() does not, contrary to the Ethereum consensus specification. According to the SSZ spec, lists must include their length in the Merkle root (mix_in_length), whereas vectors do not.\n\nThis leads to inconsistent and incorrect Merkle proofs in BeaconStateVerifier, where list types like validators and historical_summaries use intoVector(), and vector types like block_roots use intoList(). This mismatch causes verification failures or acceptance of invalid proofs.\n\nThe impact is potential consensus bugs in beacon chain state verification, leading to incorrect reward calculations, failed withdrawals, or security vulnerabilities in proof-of-stake operations.\n",
            "severity": "Low",
            "location": [
                "SSZ.sol::intoVector#27-35",
                "BeaconStateVerifier.sol::pathBeaconStateToValidator#127",
                "BeaconStateVerifier.sol::pathHistoricalSummaries#137",
                "BeaconStateVerifier.sol::pathBlockRoots#142",
                "BeaconStateVerifier.sol::pathBlockToWithdrawal#151"
            ],
            "files": [
                "rocketpool/contracts/contract/util/SSZ.sol"
            ]
        },
        {
            "id": 52,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Improvements for BeaconStateVerifier and the SSZ library",
            "description": "Multiple low-risk issues were identified in the SSZ and BeaconStateVerifier components: (1) concat() may overflow if lenA + lenB > 248; (2) intoList() and intoVector() should use uint248 for index to prevent overflow; (3) effectiveBalance in Validator struct should be uint64 per Ethereum consensus specs; (4) isHistoricalProof() should enforce proofSlot > targetSlot for stricter validation.\nThe causes are minor type and logic oversights in low-level serialization and verification code.\nExploitation would require crafting inputs that trigger overflow or bypass validation, but no direct exploit path is evident.\nThe impact is potential runtime errors, incorrect deserialization, or non-compliance with Ethereum specs, which could affect beacon chain integration reliability.\n",
            "severity": "Low",
            "location": [
                "SSZ.sol#L41-L46",
                "SSZ.sol#L27-L35",
                "BeaconStateVerifierInterface.sol#L18-L22",
                "BeaconStateVerifier.sol#L85-L88"
            ],
            "files": [
                "rocketpool/contracts/contract/util/SSZ.sol",
                "rocketpool/contracts/contract/util/BeaconStateVerifier.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Allowing extra upper bits for indexes allows invalid proofs to pass in BeaconStateVerifier",
            "description": "The vulnerability stems from using uint256 for index parameters in BeaconStateVerifier functions when smaller types (uint40 and uint16) should be used, given the fixed sizes of the underlying data structures.\n\nThe root cause is improper type enforcement in pathBeaconStateToValidator() and pathBlockToWithdrawal(), where _validatorIndex and _withdrawalNum are declared as uint256 instead of being restricted to 40 and 4 bits respectively. This allows attackers to craft indices with extra upper bits that overflow into the gIndex calculation.\n\nAn attacker can manipulate the gIndex to point to unintended fields in the BeaconState, effectively forging invalid Merkle proofs. For example, by setting _validatorIndex > 2^40, the attacker can shift the path from the validators list to another field, bypassing validation checks.\n\nThe impact is the acceptance of invalid beacon chain state proofs, which could lead to incorrect reward distributions, false validator exits, or theft of user funds through fraudulent state transitions.\n",
            "severity": "High",
            "location": [
                "BeaconStateVerifier.sol::pathBeaconStateToValidator#125-129",
                "BeaconStateVerifier.sol::pathBlockToWithdrawal#147-153"
            ],
            "files": [
                "rocketpool/contracts/contract/util/BeaconStateVerifier.sol"
            ]
        },
        {
            "id": 56,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Avoid hardcoding the gas amount passed to the sha256 precompile",
            "description": "The gas amount for sha256 precompile calls is hardcoded to 84, which may break if EVM gas costs change in future upgrades.\nThe cause is static gas specification instead of using gas() to forward all available gas.\nFuture hard forks that alter precompile costs could cause these calls to fail, breaking protocol functionality.\nThe impact is potential denial of service in the event of EVM changes, though currently no issue exists.\n",
            "severity": "Informational",
            "location": [
                "SSZ.sol#L72",
                "SSZ.sol#L87",
                "RocketMegapoolDelegate.sol#L753-L818"
            ],
            "files": [
                "rocketpool/contracts/contract/util/SSZ.sol"
            ]
        }
    ],
    "affected_files": {
        "BeaconStateVerifier.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {SSZ} from \"./SSZ.sol\";\nimport {BlockRootsInterface} from \"../../interface/util/BlockRootsInterface.sol\";\nimport {BeaconStateVerifierInterface, ValidatorProof, Validator, WithdrawalProof, Withdrawal} from \"../../interface/util/BeaconStateVerifierInterface.sol\";\n\ncontract BeaconStateVerifier is RocketBase, BeaconStateVerifierInterface {\n    // Immutables\n    uint256 internal immutable slotsPerHistoricalRoot;\n    uint256 internal immutable historicalSummaryOffset;\n    uint64 internal immutable slotPhase0;\n    uint64 internal immutable slotAltair;\n    uint64 internal immutable slotBellatrix;\n    uint64 internal immutable slotCapella;\n    uint64 internal immutable slotDeneb;\n    uint64 internal immutable slotElectra;\n\n    // Enums\n    enum Fork {\n        PHASE_0,\n        ALTAIR,\n        BELLATRIX,\n        CAPELLA,\n        DENEB,\n        ELECTRA\n    }\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress, uint256 _slotsPerHistoricalRoot, uint64[5] memory _forkSlots) RocketBase(_rocketStorageAddress) {\n        version = 1;\n        slotsPerHistoricalRoot = _slotsPerHistoricalRoot;\n        // Set fork slots\n        slotPhase0 = 0;\n        slotAltair = _forkSlots[0];\n        slotBellatrix = _forkSlots[1];\n        slotCapella = _forkSlots[2];\n        slotDeneb = _forkSlots[3];\n        slotElectra = _forkSlots[4];\n        // Historical summaries started being appended from Capella onwards, depending on the chain we might need an offset\n        historicalSummaryOffset = slotCapella / slotsPerHistoricalRoot;\n    }\n\n    /// @notice Verifies a proof about a validator on the beacon chain\n    function verifyValidator(ValidatorProof calldata _proof) override external view returns(bool) {\n        // Only support post-electra state proofs\n        require(_proof.slot >= slotElectra, \"Invalid proof\");\n        // Construct gindex\n        SSZ.Path memory path = pathBeaconBlockHeaderToStateRoot();\n        path = SSZ.concat(path, pathBeaconStateToValidator(_proof.validatorIndex));\n        // Restore the block root for the supplied slot\n        bytes32 computedRoot = SSZ.restoreMerkleRoot(merkleiseValidator(_proof.validator), SSZ.toIndex(path), _proof.witnesses);\n        // Retrieve and compare the root with what we determined it should be from the given proof\n        bytes32 root = getBlockRoot(_proof.slot);\n        return computedRoot == root;\n    }\n\n    /// @notice Verifies a proof about the existence of a withdrawal on the beacon chain\n    function verifyWithdrawal(WithdrawalProof calldata _proof) override external view returns(bool) {\n        // Only support post-electra state proofs\n        require(_proof.slot >= slotElectra, \"Invalid proof\");\n        require(_proof.withdrawalSlot >= slotElectra, \"Invalid proof\");\n        // Construct gindex\n        SSZ.Path memory path = pathBeaconBlockHeaderToStateRoot();\n        path = SSZ.concat(path, pathBeaconStateToPastBlockRoot(_proof.slot, _proof.withdrawalSlot));\n        path = SSZ.concat(path, pathBlockToWithdrawal(_proof.withdrawalNum));\n        // Merkleise the withdrawal struct\n        bytes32 leaf = merkleiseWithdrawal(_proof.withdrawal);\n        // Restore the block root for the supplied slot\n        bytes32 computedRoot = SSZ.restoreMerkleRoot(leaf, SSZ.toIndex(path), _proof.witnesses);\n        // Retrieve and compare the root with what we determined it should be from the given proof\n        bytes32 root = getBlockRoot(_proof.slot);\n        return computedRoot == root;\n    }\n\n    /// @dev Gets the block root for a given slot\n    function getBlockRoot(uint64 _slot) internal view returns (bytes32) {\n        BlockRootsInterface blockRoots = BlockRootsInterface(getContractAddress(\"blockRoots\"));\n        return blockRoots.getBlockRoot(_slot);\n    }\n\n    /// @dev Returns whether the target slot is older than SLOTS_PER_HISTORICAL_ROOT indicating a proof must be for an older slot\n    function isHistoricalProof(uint64 proofSlot, uint64 targetSlot) internal view returns (bool) {\n        require(proofSlot >= targetSlot, \"Invalid slot for proof\");\n        return targetSlot + slotsPerHistoricalRoot < proofSlot;\n    }\n\n    /// @dev Returns the SSZ merkle root of a given withdrawal container\n    function merkleiseWithdrawal(Withdrawal calldata withdrawal) internal view returns (bytes32) {\n        bytes32 left = SSZ.efficientSha256(SSZ.toLittleEndian(withdrawal.index), SSZ.toLittleEndian(withdrawal.validatorIndex));\n        bytes32 right = SSZ.efficientSha256(withdrawal.withdrawalCredentials, SSZ.toLittleEndian(withdrawal.amountInGwei));\n        return SSZ.efficientSha256(left, right);\n    }\n\n    /// @dev Returns the SSZ merkle root of a given validator\n    function merkleiseValidator(Validator calldata validator) internal view returns (bytes32) {\n        bytes32 a = SSZ.efficientSha256(SSZ.merkleisePubkey(validator.pubkey), validator.withdrawalCredentials);\n        bytes32 b = SSZ.efficientSha256(SSZ.toLittleEndian(validator.effectiveBalance), SSZ.toLittleEndian(validator.slashed ? 1 : 0));\n        bytes32 c = SSZ.efficientSha256(SSZ.toLittleEndian(uint256(validator.activationEligibilityEpoch)), SSZ.toLittleEndian(uint256(validator.activationEpoch)));\n        bytes32 d = SSZ.efficientSha256(SSZ.toLittleEndian(uint256(validator.exitEpoch)), SSZ.toLittleEndian(uint256(validator.withdrawableEpoch)));\n        a = SSZ.efficientSha256(a, b);\n        b = SSZ.efficientSha256(c, d);\n        return SSZ.efficientSha256(a,b);\n    }\n\n    /// @dev Returns the fork at a given slot\n    function slotToFork(uint64 _slot) internal view returns (Fork) {\n        if (_slot >= slotElectra) return Fork.ELECTRA;\n        if (_slot >= slotDeneb) return Fork.DENEB;\n        if (_slot >= slotCapella) return Fork.CAPELLA;\n        if (_slot >= slotBellatrix) return Fork.BELLATRIX;\n        if (_slot >= slotAltair) return Fork.ALTAIR;\n        return Fork.PHASE_0;\n    }\n\n    /// @dev Returns a partial gindex from a BeaconBlockHeader -> state_root\n    function pathBeaconBlockHeaderToStateRoot() internal view returns (SSZ.Path memory) {\n        SSZ.Path memory path = SSZ.from(3, 3); // 0b011 (BeaconBlockHeader -> state_root)\n        return path;\n    }\n\n    /// @dev Returns a partial gindex from a BeaconState -> validators[n]\n    function pathBeaconStateToValidator(uint256 _validatorIndex) internal view returns (SSZ.Path memory) {\n        SSZ.Path memory path = SSZ.from(11, 6); // 0b001011 (BeaconState -> validators)\n        path = SSZ.concat(path, SSZ.intoVector(_validatorIndex, 40)); // validators -> validators[n]\n        return path;\n    }\n\n    /// @dev Returns a partial gindex from BeaconState -> block_roots[n] (via historical_summaries if required)\n    function pathBeaconStateToPastBlockRoot(uint64 _slot, uint64 _pastSlot) internal view returns (SSZ.Path memory) {\n        bool isHistorical = isHistoricalProof(_slot, _pastSlot);\n        SSZ.Path memory path;\n        if (isHistorical) {\n            path = SSZ.concat(path, SSZ.from(27, 6)); // 0b001011 (BeaconState -> historical_summaries)\n            path = SSZ.concat(path, SSZ.intoVector(uint256(_pastSlot) / slotsPerHistoricalRoot - historicalSummaryOffset, 24)); // historical_summaries -> historical_summaries[n]\n            path = SSZ.concat(path, SSZ.from(0, 1)); // 0b0 (HistoricalSummary -> block_summary_root)\n        } else {\n            path = SSZ.concat(path, SSZ.from(5, 6)); // 0b000101 (BeaconState -> block_roots)\n        }\n        path = SSZ.concat(path, SSZ.intoList(uint256(_pastSlot) % slotsPerHistoricalRoot, 13)); // block_roots -> block_roots[n]\n        return path;\n    }\n\n    /// @dev Returns a partial gindex from BeaconBlockHeader -> withdrwals[n]\n    function pathBlockToWithdrawal(uint256 _withdrawalNum) internal view returns (SSZ.Path memory) {\n        SSZ.Path memory path = SSZ.from(4, 3); // 0b100 (BeaconBlockHeader -> body_root)\n        path = SSZ.concat(path, SSZ.from(9, 4)); // 0b1001 (BeaconBlockBody -> execution_payload)\n        path = SSZ.concat(path, SSZ.from(14, 5)); // 0b01110 (ExecutionPayload -> withdrawals)\n        path = SSZ.concat(path, SSZ.intoList(_withdrawalNum, 5)); // withdrawals -> withdrawals[n]\n        return path;\n    }\n}\n",
        "SSZ.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/// @dev Set of utilities for working with SSZ serialisation and merkleisation\nlibrary SSZ {\n    struct Path {\n        uint256 _data;\n    }\n\n    /// @dev Decodes a Path to a full gindex\n    function toIndex(Path memory _path) internal pure returns (uint256) {\n        uint256 pathLength = uint8(_path._data);\n        uint256 anchor = uint256(1) << pathLength;\n        return (_path._data >> 8) | anchor;\n    }\n\n    /// @dev Extracts the length component from a Path\n    function length(Path memory _path) internal pure returns (uint8) {\n        return uint8(_path._data);\n    }\n\n    /// @dev Constructs a Path from a given gindex and length\n    function from(uint248 _gindex, uint8 _length) internal pure returns (Path memory) {\n        return Path((uint256(_gindex) << 8) | uint256(_length));\n    }\n\n    /// @dev Constructs a Path into a vector field\n    function intoVector(uint256 _index, uint8 _log2Length) internal pure returns (Path memory) {\n        return Path((uint256(_index) << 8) | uint256(_log2Length + 1));\n    }\n\n    /// @dev Constructs a Path into a list field\n    function intoList(uint256 index, uint8 log2Len) internal pure returns (Path memory) {\n        return Path((uint256(index) << 8) | uint256(log2Len));\n    }\n\n    /// @dev Concatenates two Paths\n    function concat(Path memory _left, Path memory _right) internal pure returns (Path memory) {\n        uint8 lenA = uint8(_left._data);\n        uint8 lenB = uint8(_right._data);\n        unchecked {\n            // Prevent overflow of length into path\n            require(uint256(lenA) + uint256(lenB) <= type(uint8).max, \"Path too long\");\n            _left._data = (_left._data - lenA) << lenB;\n            _left._data += _right._data + lenA;\n        }\n        return _left;\n    }\n\n    /// @dev Interprets a big-ending uint256 as a little-endian encodes bytes32 value\n    function toLittleEndian(uint256 v) internal pure returns (bytes32) {\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\n            | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\n            | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\n            | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\n            | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        v = (v >> 128) | (v << 128);\n        return bytes32(v);\n    }\n\n    /// @dev Performs SSZ merkleisation of a pubkey value\n    function merkleisePubkey(bytes memory pubkey) internal view returns (bytes32 ret) {\n        require(pubkey.length == 48, \"Invalid pubkey length\");\n        assembly {\n            mstore(0x00, mload(add(0x20, pubkey)))\n            let right := and(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000, mload(add(0x40, pubkey)))\n            mstore(0x20, right)\n\n            let result := staticcall(84, 0x02, 0x00, 0x40, 0x00, 0x20)\n            if iszero(result) {\n                revert(0,0)\n            }\n\n            ret := mload(0x00)\n        }\n    }\n\n    /// @dev Concatenates two bytes32 values and returns a SHA256 of the result\n    function efficientSha256(bytes32 _left, bytes32 _right) internal view returns (bytes32 ret) {\n        assembly {\n            mstore(0x00, _left)\n            mstore(0x20, _right)\n\n            let result := staticcall(84, 0x02, 0x00, 0x40, 0x00, 0x20)\n            if iszero(result) {\n                revert(0,0)\n            }\n\n            ret := mload(0x00)\n        }\n    }\n\n    /// @dev Restores a merkle root from a merkle proof\n    /// @param _leaf The SSZ merkleised leaf node\n    /// @param _gindex The gindex of the proof\n    /// @param _witnesses The proof witnesses\n    function restoreMerkleRoot(bytes32 _leaf, uint256 _gindex, bytes32[] memory _witnesses) internal view returns (bytes32) {\n        // Check for correct number of witnesses\n        require(2 ** (_witnesses.length + 1) > _gindex, \"Invalid witness length\");\n        bytes32 value = _leaf;\n        uint256 i = 0;\n        while (_gindex != 1) {\n            if (_gindex % 2 == 1) {\n                value = efficientSha256(_witnesses[i], value);\n            } else {\n                value = efficientSha256(value, _witnesses[i]);\n            }\n            _gindex /= 2;\n            unchecked {\n                i++;\n            }\n        }\n        return value;\n    }\n}\n\n\n"
    }
}