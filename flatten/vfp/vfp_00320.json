{
    "vfp_id": "vfp_00320",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "Megapool MEV theft penalties can be applied multiple times per block with different amounts",
            "description": "The penalty submission mechanism for Megapools includes the penalty amount in the submission key (nodeSubmissionKey), which allows the same oDAO member to submit multiple penalties for the same block with different amounts.\n\nThe root cause is the inclusion of _amount in the keccak256 hash used to prevent duplicate submissions. Since changing the amount produces a different key, the system does not recognize it as a duplicate.\n\nA malicious or buggy oDAO client could exploit this to apply multiple penalties in the same block, even though MEV theft can only occur once per block. This could lead to over-penalization.\n\nThe impact is potential over-penalization of Megapools, leading to unjust loss of funds for node operators, though the overall cap on weekly penalties limits the total exposure.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolPenalties.sol#L44-L47"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolPenalties.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Minipool MEV theft penalties will not be applied at 51% consensus threshold",
            "description": "The consensus check for applying Minipool MEV theft penalties uses a > operator instead of >=, meaning that a 51% vote threshold is not sufficient to apply the penalty when exactly 51% of oDAO members vote in favor.\n\nThe root cause is the incorrect use of a strict greater-than operator where a greater-than-or-equal operator is required by the specification.\n\nIn an edge case where exactly 51% of oDAO members approve a penalty, the penalty will not be applied, even though it meets the defined threshold.\n\nThe impact is a failure to penalize MEV theft in a narrow but possible scenario, undermining the reliability of the penalty system and potentially allowing malicious validators to avoid penalties.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L34",
                "RocketDAOProtocolSettingsNetwork.sol#L138-L141",
                "RocketNetworkPenalties.sol#L113"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 54,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Hardcoding consensus threshold for Megapool penalty enforcement prevents any required modification",
            "description": "RocketMegapoolPenalties uses a hardcoded 0.5 ether threshold for penalty enforcement, unlike RocketNetworkPenalties which uses a configurable setting. This prevents the pDAO from adjusting the threshold if needed.\nThe cause is the use of a magic number instead of a protocol setting.\nGovernance cannot adapt to changing network conditions or attack vectors that may require a different threshold.\nThe impact is reduced governance flexibility and potential misalignment with network security needs, though the current value may be appropriate.\n",
            "severity": "Informational",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L34",
                "RocketMegapoolPenalties.sol#L108-L114",
                "RocketNetworkPenalties.sol#L113"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolPenalties.sol",
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 55,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Specification of lower guardrail for Megapool MEV theft penalty is contradicting",
            "description": "RPIP-42 specifies a lower guardrail for Megapool penalties as > 300 ETH, but the implementation and text elsewhere state >= 300 ETH, creating a contradiction.\nThe root cause is inconsistent documentation and specification.\nThis could lead to confusion during governance decisions or audits about the actual enforceable minimum.\nThe impact is primarily on clarity and trust in specifications, with no direct security impact since the implementation is correct.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolPenalties.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for network.reth.collateral.target may affect redemptions and staking",
            "description": "The network.reth.collateral.target setting, initialized to 0.1 ether (10% collateralization), lacks both lower and upper guardrails. If set too low (e.g., 0), there will be insufficient ETH buffered in RocketTokenRETH for rETH redemptions, causing redemption failures when the deposit pool has no unborrowed ETH. Conversely, if set too high, less ETH is available for staking, reducing validator count and yield generation. The root cause is the lack of validation on parameter updates. A malicious or mistaken pDAO vote could exploit this by setting extreme values, disrupting protocol balance. The impact includes degraded user experience due to failed redemptions and reduced staking efficiency.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L33",
                "RocketDAOProtocolSettingsNetwork.sol#L49-L77",
                "RocketDepositPool.sol#L215-L224",
                "RocketDepositPool.sol#L232-L247",
                "RocketTokenRETH.sol#L106-L154"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for network.submit.balances.frequency may prevent timely network balance updates",
            "description": "The network.submit.balances.frequency parameter, which controls how often oDAO must update network balances, has a lower guardrail of >=1 hour per RPIP-33 but no upper guardrail. This allows the pDAO to set it to an arbitrarily large value, delaying balance updates. Combined with the max rETH delta enforcement (RPIP-61), this could lead to rETH-ETH depegging and accounting issues. The root cause is the omission of an upper bound in the specification. An attacker or misconfigured governance could exploit this by increasing the frequency interval, leading to stale balance data. The impact includes inaccurate protocol accounting and potential depegging of rETH.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L26",
                "RocketDAOProtocolSettingsNetwork.sol#L61-L62",
                "RocketNetworkBalances.sol#L134-L140"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "RPL price update frequency is never enforced on oDAO",
            "description": "Although network.submit.prices.frequency is set to 1 day, it is not enforced in RocketNetworkPrices.updatePrices(). This allows oDAO members to update RPL prices at any time, potentially affecting RPL staking and liquidation auctions. The root cause is the missing enforcement check in the updatePrices() function. An oDAO member could exploit this by submitting frequent price updates, possibly manipulating short-term staking rewards or auction dynamics. The impact is limited since price setting itself is already a powerful control, but lack of frequency enforcement reduces predictability.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L28",
                "RocketNetworkBalances.sol#L134-L140",
                "RocketNetworkPrices.sol#L118-L124"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketMegapoolPenalties.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketDAONodeTrustedInterface} from \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport {RocketDAOProtocolSettingsMegapoolInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMegapoolInterface.sol\";\nimport {RocketNetworkSnapshotsInterface} from \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\nimport {RocketMegapoolDelegateInterface} from \"../../interface/megapool/RocketMegapoolDelegateInterface.sol\";\nimport {RocketMegapoolPenaltiesInterface} from \"../../interface/megapool/RocketMegapoolPenaltiesInterface.sol\";\n\n/// @notice Applies penalties to megapools for MEV theft\ncontract RocketMegapoolPenalties is RocketBase, RocketMegapoolPenaltiesInterface {\n    // Constants\n    uint256 constant internal penaltyMaximumPeriod = 50400;\n    bytes32 constant internal penaltyKey = keccak256(abi.encodePacked(\"megapool.running.penalty\"));\n\n    // Events\n    event PenaltySubmitted(address indexed from, address megapool, uint256 block, uint256 amount, uint256 time);\n    event PenaltyApplied(address indexed megapool, uint256 block, uint256 amount, uint256 time);\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 1;\n    }\n\n    /// @notice Returns the number of votes in favour of the given penalty\n    /// @param _megapool Address of the accused megapool\n    /// @param _block Block that the theft occurred (used for uniqueness)\n    /// @param _amount Amount in ETH of the penalty\n    function getVoteCount(address _megapool, uint256 _block, uint256 _amount) override external view returns (uint256) {\n        bytes32 submissionCountKey = keccak256(abi.encodePacked(\"megapool.penalty.submission\", _megapool, _block, _amount));\n        return getUint(submissionCountKey);\n    }\n\n    /// @notice Votes to penalise a megapool for MEV theft (only callable by oDAO)\n    /// @param _megapool Address of the accused megapool\n    /// @param _block Block that the theft occurred (used for uniqueness)\n    /// @param _amount Amount in ETH of the penalty\n    function penalise(address _megapool, uint256 _block, uint256 _amount) override external onlyTrustedNode(msg.sender) onlyRegisteredMegapool(_megapool) {\n        require(_amount > 0, \"Invalid penalty amount\");\n        require(_block < block.number, \"Invalid block number\");\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(abi.encodePacked(\"megapool.penalty.submission\", msg.sender, _megapool, _block, _amount));\n        bytes32 submissionCountKey = keccak256(abi.encodePacked(\"megapool.penalty.submission\", _megapool, _block, _amount));\n        // Check & update node submission status\n        require(!getBool(nodeSubmissionKey), \"Duplicate submission from node\");\n        setBool(nodeSubmissionKey, true);\n        // Increment submission count\n        uint256 submissionCount = getUint(submissionCountKey) + 1;\n        setUint(submissionCountKey, submissionCount);\n        // Maybe execute\n        maybeApplyPenalty(_megapool, _block, _amount, submissionCount);\n        // Emit event\n        emit PenaltySubmitted(msg.sender, _megapool, _block, _amount, block.timestamp);\n    }\n\n    /// @notice Manually execute a penalty that has hit majority vote\n    /// @param _megapool Address of the accused megapool\n    /// @param _block Block that the theft occurred (used for uniqueness)\n    /// @param _amount Amount in ETH of the penalty\n    function executePenalty(address _megapool, uint256 _block, uint256 _amount) override external {\n        // Get submission count\n        bytes32 submissionCountKey = keccak256(abi.encodePacked(\"megapool.penalty.submission\", _megapool, _block, _amount));\n        uint256 submissionCount = getUint(submissionCountKey);\n        // Apply penalty if relevant conditions are met\n        maybeApplyPenalty(_megapool, _block, _amount, submissionCount);\n    }\n\n    /// @notice Returns the running total of penalties at a given block\n    /// @param _block The block to compute running total for\n    function getPenaltyRunningTotalAtBlock(uint32 _block) override external view returns (uint256) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        return rocketNetworkSnapshots.lookup(penaltyKey, _block);\n    }\n\n    /// @notice Returns the running total of penalties at the current block\n    function getCurrentPenaltyRunningTotal() override external view returns (uint256) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        (,,uint224 value) =  rocketNetworkSnapshots.latest(penaltyKey);\n        return uint256(value);\n    }\n\n    /// @notice Returns the current maximum penalty based on the running total limitation\n    function getCurrentMaxPenalty() override external view returns (uint256) {\n        // Get contracts\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        RocketDAOProtocolSettingsMegapoolInterface rocketDAOProtocolSettingsMegapool = RocketDAOProtocolSettingsMegapoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMegapool\"));\n        // Grab max weekly penalty\n        uint256 maxPenalty = rocketDAOProtocolSettingsMegapool.getMaximumEthPenalty();\n        // Get running total from 50400 slots ago\n        uint256 earlierBlock = 0;\n        if (block.number > penaltyMaximumPeriod) {\n            earlierBlock = block.number - penaltyMaximumPeriod;\n        }\n        uint256 earlierRunningTotal = uint256(rocketNetworkSnapshots.lookup(penaltyKey, uint32(earlierBlock)));\n        // Get current running total\n        (,, uint224 currentRunningTotal) = rocketNetworkSnapshots.latest(penaltyKey);\n        // Cap the penalty at the maximum amount based on past 50400 blocks\n        uint256 currentTotal = uint256(currentRunningTotal) - earlierRunningTotal;\n        if (currentTotal > maxPenalty) return 0;\n        return maxPenalty - currentTotal;\n    }\n\n    /// @dev If a penalty has not been applied and hit majority, execute the penalty\n    /// @param _megapool Address of the accused megapool\n    /// @param _block Block that the theft occurred (used for uniqueness)\n    /// @param _amount Amount in ETH of the penalty\n    function maybeApplyPenalty(address _megapool, uint256 _block, uint256 _amount, uint256 _submissionCount) internal {\n        // Check this penalty hasn't already reach majority and been applied\n        bytes32 penaltyAppliedKey = keccak256(abi.encodePacked(\"megapool.penalty.submission.applied\", _megapool, _block, _amount));\n        require(!getBool(penaltyAppliedKey), \"Penalty already applied\");\n        // Check for majority\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        if (calcBase * _submissionCount / rocketDAONodeTrusted.getMemberCount() > 0.5 ether) {\n            // Apply penalty and mark as applied\n            applyPenalty(_megapool, _amount);\n            setBool(penaltyAppliedKey, true);\n            // Emit event\n            emit PenaltyApplied(_megapool, _block, _amount, block.timestamp);\n        }\n    }\n\n    /// @dev Applies a penalty up to given amount, honouring the max penalty parameter\n    function applyPenalty(address _megapool, uint256 _amount) internal {\n        // Get contracts\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        RocketDAOProtocolSettingsMegapoolInterface rocketDAOProtocolSettingsMegapool = RocketDAOProtocolSettingsMegapoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMegapool\"));\n        // Grab max weekly penalty\n        uint256 maxPenalty = rocketDAOProtocolSettingsMegapool.getMaximumEthPenalty();\n        // Get running total from 50400 slots ago\n        uint256 earlierBlock = 0;\n        if (block.number > penaltyMaximumPeriod) {\n            earlierBlock = block.number - penaltyMaximumPeriod;\n        }\n        uint256 earlierRunningTotal = rocketNetworkSnapshots.lookup(penaltyKey, uint32(earlierBlock));\n        // Get current running total\n        (,, uint224 currentRunningTotal) = rocketNetworkSnapshots.latest(penaltyKey);\n        // Prevent the running penalty total from exceeding the maximum amount\n        uint256 currentTotal = uint256(currentRunningTotal) - earlierRunningTotal;\n        require(currentTotal < maxPenalty, \"Max penalty exceeded\");\n        uint256 currentMaxPenalty = maxPenalty - currentTotal;\n        require(_amount <= currentMaxPenalty, \"Max penalty exceeded\");\n        // Insert new running total\n        rocketNetworkSnapshots.push(penaltyKey, currentRunningTotal + uint224(_amount));\n        // Call megapool to increase debt\n        RocketMegapoolDelegateInterface(_megapool).applyPenalty(_amount);\n    }\n}\n",
        "RocketDAOProtocolSettingsNetwork.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../../../interface/RocketStorageInterface.sol\";\nimport {RocketDAOProtocolSettingsNetworkInterface} from \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport {RocketNetworkRevenuesInterface} from \"../../../../interface/network/RocketNetworkRevenuesInterface.sol\";\nimport {RocketBase} from \"../../../RocketBase.sol\";\nimport {RocketDAOProtocolSettings} from \"./RocketDAOProtocolSettings.sol\";\n\n/// @notice Network auction settings\ncontract RocketDAOProtocolSettingsNetwork is RocketDAOProtocolSettings, RocketDAOProtocolSettingsNetworkInterface {\n    // Modifiers\n    modifier onlyAllowListedController() {\n        require(isAllowListedController(msg.sender), \"Not on allow list\");\n        _;\n    }\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, \"network\") {\n        version = 4;\n        // Initialise settings on deployment\n        if (!rocketStorage.getDeployedStatus()) {\n            // Set defaults\n            _setSettingUint(\"network.consensus.threshold\", 0.51 ether);      // 51%\n            _setSettingBool(\"network.submit.balances.enabled\", true);\n            _setSettingUint(\"network.submit.balances.frequency\", 1 days);\n            _setSettingBool(\"network.submit.prices.enabled\", true);\n            _setSettingUint(\"network.submit.prices.frequency\", 1 days);\n            _setSettingUint(\"network.node.fee.minimum\", 0.15 ether);         // 15%\n            _setSettingUint(\"network.node.fee.target\", 0.15 ether);          // 15%\n            _setSettingUint(\"network.node.fee.maximum\", 0.15 ether);         // 15%\n            _setSettingUint(\"network.node.fee.demand.range\", 160 ether);\n            _setSettingUint(\"network.reth.collateral.target\", 0.1 ether);\n            _setSettingUint(\"network.penalty.threshold\", 0.51 ether);       // Consensus for penalties requires 51% vote\n            _setSettingUint(\"network.penalty.per.rate\", 0.1 ether);         // 10% per penalty\n            _setSettingBool(\"network.submit.rewards.enabled\", true);        // Enable reward submission\n            _setSettingUint(\"network.node.commission.share\", 0.05 ether);                        // 5% (RPIP-46)\n            _setSettingUint(\"network.node.commission.share.security.council.adder\", 0 ether);    // 0% (RPIP-46)\n            _setSettingUint(\"network.voter.share\", 0.09 ether);                                  // 9% (RPIP-46)\n            _setSettingUint(\"network.pdao.share\", 0.00 ether);                                   // 0% (RPIP-72)\n            _setSettingUint(\"network.max.node.commission.share.council.adder\", 0.01 ether);      // 1% (RPIP-46)\n            _setSettingUint(\"network.max.reth.balance.delta\", 0.02 ether);                       // 2% (RPIP-61)\n            // Set deploy flag\n            setBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")), true);\n        }\n    }\n\n    /// @notice Update a setting, overrides inherited setting method with extra checks for this contract\n    function setSettingUint(string memory _settingPath, uint256 _value) override public onlyDAOProtocolProposal {\n        if (getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            // Some safety guards for certain settings\n            bytes32 settingKey = keccak256(bytes(_settingPath));\n            if (settingKey == keccak256(bytes(\"network.consensus.threshold\"))) {\n                require(_value >= 0.51 ether, \"Consensus threshold must be 51% or higher\");\n            } else if (settingKey == keccak256(bytes(\"network.node.fee.minimum\"))) {\n                require(_value >= 0.05 ether && _value <= 0.2 ether, \"The node fee minimum must be a value between 5% and 20%\");\n            } else if (settingKey == keccak256(bytes(\"network.node.fee.target\"))) {\n                require(_value >= 0.05 ether && _value <= 0.2 ether, \"The node fee target must be a value between 5% and 20%\");\n            } else if (settingKey == keccak256(bytes(\"network.node.fee.maximum\"))) {\n                require(_value >= 0.05 ether && _value <= 0.2 ether, \"The node fee maximum must be a value between 5% and 20%\");\n            } else if (settingKey == keccak256(bytes(\"network.submit.balances.frequency\"))) {\n                require(_value >= 1 hours, \"The submit frequency must be >= 1 hour\");\n            } else if (settingKey == keccak256(bytes(\"network.max.reth.balance.delta\"))) {\n                // RPIP-61 guardrail\n                require(_value >= 0.01 ether, \"The max rETH balance delta must be >= 1%\");\n            } else if (settingKey == keccak256(bytes(\"network.node.commission.share.security.council.adder\"))) {\n                return _setNodeShareSecurityCouncilAdder(_value);\n            } else if (settingKey == keccak256(bytes(\"network.node.commission.share\"))) {\n                return _setNodeCommissionShare(_value);\n            } else if (settingKey == keccak256(bytes(\"network.voter.share\"))) {\n                return _setVoterShare(_value);\n            } else if (settingKey == keccak256(bytes(\"network.pdao.share\"))) {\n                return _setProtocolDAOShare(_value);\n            }\n            // Update setting now\n            _setSettingUint(_settingPath, _value);\n        } else {\n            // Update setting now\n            _setSettingUint(_settingPath, _value);\n        }\n    }\n\n    /// @dev Sets a namespaced uint value skipping any guardrails\n    function _setSettingUint(string memory _settingPath, uint256 _value) internal {\n        setUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    /// @dev Sets a namespaced bool value skipping any guardrails\n    function _setSettingBool(string memory _settingPath, bool _value) internal {\n        setBool(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    // @notice Returns the maximum value the security council can set the node share security council adder to\n    function getMaxNodeShareSecurityCouncilAdder() override public view returns (uint256) {\n        return getSettingUint(\"network.max.node.commission.share.council.adder\");\n    }\n\n    // @notice Returns the current voter share (excluding security council adder)\n    function getVoterShare() override public view returns (uint256) {\n        return getSettingUint(\"network.voter.share\");\n    }\n\n    // @notice Returns the current pdao share\n    function getProtocolDAOShare() override public view returns (uint256) {\n        return getSettingUint(\"network.pdao.share\");\n    }\n\n    // @notice Returns the current node share (excluding security council adder)\n    function getNodeShare() override public view returns (uint256) {\n        return getSettingUint(\"network.node.commission.share\");\n    }\n\n    // @notice Returns the current node share security council adder\n    function getNodeShareSecurityCouncilAdder() override public view returns (uint256) {\n        return getSettingUint(\"network.node.commission.share.security.council.adder\");\n    }\n\n    // @notice Returns the current rETH commission\n    function getRethCommission() override public view returns (uint256) {\n        return getNodeShare() + getVoterShare() + getProtocolDAOShare();\n    }\n\n    // @notice Returns the current voter share (taking into account the security council adder)\n    function getEffectiveVoterShare() override public view returns (uint256) {\n        return getVoterShare() - getNodeShareSecurityCouncilAdder();\n    }\n\n    // @notice Returns the current node share (taking into account the security council adder)\n    function getEffectiveNodeShare() override public view returns (uint256) {\n        return getNodeShare() + getNodeShareSecurityCouncilAdder();\n    }\n\n    /// @notice The threshold of trusted nodes that must reach consensus on oracle data to commit it\n    function getNodeConsensusThreshold() override external view returns (uint256) {\n        return getSettingUint(\"network.consensus.threshold\");\n    }\n\n    /// @notice The threshold of trusted nodes that must reach consensus on a penalty\n    function getNodePenaltyThreshold() override external view returns (uint256) {\n        return getSettingUint(\"network.penalty.threshold\");\n    }\n\n    /// @notice The amount to penalise a minipool for each feeDistributor infraction\n    function getPerPenaltyRate() override external view returns (uint256) {\n        return getSettingUint(\"network.penalty.per.rate\");\n    }\n\n    /// @notice Submit balances currently enabled (trusted nodes only)\n    function getSubmitBalancesEnabled() override external view returns (bool) {\n        return getSettingBool(\"network.submit.balances.enabled\");\n    }\n\n    /// @notice The frequency in seconds at which network balances should be submitted by trusted nodes\n    function getSubmitBalancesFrequency() override external view returns (uint256) {\n        return getSettingUint(\"network.submit.balances.frequency\");\n    }\n\n    /// @notice Submit prices currently enabled (trusted nodes only)\n    function getSubmitPricesEnabled() override external view returns (bool) {\n        return getSettingBool(\"network.submit.prices.enabled\");\n    }\n\n    /// @notice The frequency in seconds at which network prices should be submitted by trusted nodes\n    function getSubmitPricesFrequency() override external view returns (uint256) {\n        return getSettingUint(\"network.submit.prices.frequency\");\n    }\n\n    /// @notice The minimum node commission rate as a fraction of 1 ether\n    function getMinimumNodeFee() override external view returns (uint256) {\n        return getSettingUint(\"network.node.fee.minimum\");\n    }\n\n    /// @notice The target node commission rate as a fraction of 1 ether\n    function getTargetNodeFee() override external view returns (uint256) {\n        return getSettingUint(\"network.node.fee.target\");\n    }\n\n    /// @notice The maximum node commission rate as a fraction of 1 ether\n    function getMaximumNodeFee() override external view returns (uint256) {\n        return getSettingUint(\"network.node.fee.maximum\");\n    }\n\n    /// @notice The range of node demand values to base fee calculations on (from negative to positive value)\n    function getNodeFeeDemandRange() override external view returns (uint256) {\n        return getSettingUint(\"network.node.fee.demand.range\");\n    }\n\n    /// @notice Target rETH collateralisation rate as a fraction of 1 ether\n    function getTargetRethCollateralRate() override external view returns (uint256) {\n        return getSettingUint(\"network.reth.collateral.target\");\n    }\n\n    /// @notice rETH withdraw delay in blocks\n    function getRethDepositDelay() override external view returns (uint256) {\n        return getSettingUint(\"network.reth.deposit.delay\");\n    }\n\n    /// @notice Submit reward snapshots currently enabled (trusted nodes only)\n    function getSubmitRewardsEnabled() override external view returns (bool) {\n        return getSettingBool(\"network.submit.rewards.enabled\");\n    }\n\n    /// @notice Returns a list of addresses allowed to update commission share parameters\n    function getAllowListedControllers() override public view returns (address[] memory) {\n        return getSettingAddressList(\"network.allow.listed.controllers\");\n    }\n\n    /// @notice Returns the maximum amount rETH balance deltas can be changed per submission (as a percentage of 1e18)\n    function getMaxRethDelta() override external view returns (uint256) {\n        return getSettingUint(\"network.max.reth.balance.delta\");\n    }\n\n    /// @notice Returns true if the supplied address is one of the allow listed controllers\n    /// @param _address The address to check for on the allow list\n    function isAllowListedController(address _address) override public view returns (bool) {\n        address[] memory allowList = getAllowListedControllers();\n        for (uint256 i = 0; i < allowList.length; ++i) {\n            if (allowList[i] == _address) return true;\n        }\n        return false;\n    }\n\n    /// @notice Called by an explicitly allowed address to modify the security council adder parameter\n    /// @param _value New value for the parameter\n    function setNodeShareSecurityCouncilAdder(uint256 _value) override external onlyAllowListedController {\n        _setNodeShareSecurityCouncilAdder(_value);\n    }\n\n    /// @notice Called by an explicitly allowed address to modify the node commission share parameter\n    /// @param _value New value for the parameter\n    function setNodeCommissionShare(uint256 _value) override external onlyAllowListedController {\n        _setNodeCommissionShare(_value);\n    }\n\n    /// @notice Called by an explicitly allowed address to modify the voter share parameter\n    /// @param _value New value for the parameter\n    function setVoterShare(uint256 _value) override external onlyAllowListedController {\n        _setVoterShare(_value);\n    }\n\n    /// @notice Called by an explicitly allowed address to modify the pdao share parameter\n    /// @param _value New value for the parameter\n    function setProtocolDAOShare(uint256 _value) override external onlyAllowListedController {\n        _setProtocolDAOShare(_value);\n    }\n\n    /// @dev Internal implementation of setting the node share security council adder parameter\n    function _setNodeShareSecurityCouncilAdder(uint256 _value) internal {\n        // Validate input\n        uint256 maxAdderValue = getSettingUint(\"network.max.node.commission.share.council.adder\");\n        require(_value <= maxAdderValue, \"Value must be <= max value\");\n        uint256 maxVoterValue = getSettingUint(\"network.voter.share\");\n        require(_value <= maxVoterValue, \"Value must be <= voter share\");\n        // Make setting change\n        _setSettingUint(\"network.node.commission.share.security.council.adder\", _value);\n        // Sanity check value\n        require(getRethCommission() <= 1 ether, \"rETH Commission must be <= 100%\");\n        // Notify change of UARS parameter for snapshot\n        RocketNetworkRevenuesInterface rocketNetworkRevenues = RocketNetworkRevenuesInterface(getContractAddress(\"rocketNetworkRevenues\"));\n        rocketNetworkRevenues.setVoterShare(getEffectiveVoterShare());\n        rocketNetworkRevenues.setNodeShare(getEffectiveNodeShare());\n    }\n\n    /// @dev Internal implementation of setting the node commission share parameter\n    function _setNodeCommissionShare(uint256 _value) internal {\n        // Make setting change\n        _setSettingUint(\"network.node.commission.share\", _value);\n        // Sanity check value\n        require(getRethCommission() <= 1 ether, \"rETH Commission must be <= 100%\");\n        // Notify change of UARS parameter for snapshot\n        RocketNetworkRevenuesInterface rocketNetworkRevenues = RocketNetworkRevenuesInterface(getContractAddress(\"rocketNetworkRevenues\"));\n        rocketNetworkRevenues.setNodeShare(getEffectiveNodeShare());\n    }\n\n    /// @dev Internal implementation of setting the voter share parameter\n    function _setVoterShare(uint256 _value) internal {\n        // Make setting change\n        _setSettingUint(\"network.voter.share\", _value);\n        // Sanity check value\n        require(getRethCommission() <= 1 ether, \"rETH Commission must be <= 100%\");\n        // Notify change of UARS parameter for snapshot\n        RocketNetworkRevenuesInterface rocketNetworkRevenues = RocketNetworkRevenuesInterface(getContractAddress(\"rocketNetworkRevenues\"));\n        rocketNetworkRevenues.setVoterShare(getEffectiveVoterShare());\n    }\n\n    /// @dev Internal implementation of setting the pdao share parameter\n    function _setProtocolDAOShare(uint256 _value) internal {\n        // Make setting change\n        _setSettingUint(\"network.pdao.share\", _value);\n        // Sanity check value\n        require(getRethCommission() <= 1 ether, \"rETH Commission must be <= 100%\");\n        // Notify change of UARS parameter for snapshot\n        RocketNetworkRevenuesInterface rocketNetworkRevenues = RocketNetworkRevenuesInterface(getContractAddress(\"rocketNetworkRevenues\"));\n        rocketNetworkRevenues.setProtocolDAOShare(_value);\n    }\n}\n"
    }
}