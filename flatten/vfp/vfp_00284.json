{
    "vfp_id": "vfp_00284",
    "project_name": "EVM Universal Adapter Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Double Relay of a rootBundle Is Possible",
            "description": "The HubPool contract allows both its owner and any user to relay a rootBundle execution to a SpokePool via the Universal_Adapter. When the owner triggers a message, it uses a UUID-based nonce in HubPoolStore, while user-triggered relays use the challenge period end timestamp as the nonce. This difference in nonce generation allows the same rootBundle data to be stored twice in different storage slots within HubPoolStore if first triggered by a user and then by the owner (or vice versa). As a result, the rootBundle's actions can be executed twice on the same SpokePool, potentially leading to duplicate processing of relayer refunds or pool rebalancing operations. The root cause is the use of different nonce schemes for owner and non-owner message relays, which fails to prevent duplicate storage of identical rootBundle data. An attacker with ownership privileges could intentionally trigger a second relay of an already-executed rootBundle, exploiting this behavior. The impact includes potential economic imbalance due to duplicated state updates, although the actual risk is mitigated by the fact that only the HubPool owner can perform the second relay. This is considered a low-severity issue because it relies on privileged access and is acknowledged as by-design behavior.\n",
            "severity": "Low",
            "location": [
                "HubPool.sol::relaySpokePoolAdminFunction#249-252",
                "HubPool.sol::executeRootBundle#620",
                "Universal_Adapter.sol::relayMessage#44",
                "HubPoolStore.sol::uuid#60",
                "HubPoolStore.sol::challengePeriodEndTimestamp#72"
            ],
            "files": [
                "contracts/contracts/HubPool.sol",
                "contracts/contracts/chain-adapters/utilities/HubPoolStore.sol",
                "contracts/contracts/chain-adapters/Universal_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "Universal_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport { SpokePoolInterface } from \"../interfaces/SpokePoolInterface.sol\";\nimport { HubPoolStore } from \"./utilities/HubPoolStore.sol\";\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n\n/**\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\n * on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay\n * messages to multiple SpokePools on different chains.\n * @dev This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.\n * @dev This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data\n * can't get written to the store for some reason. The corresponding Universal_SpokePool contract will\n * also need to be redeployed to point to the new HubPoolStore.\n */\ncontract Universal_Adapter is AdapterInterface, CircleCCTPAdapter {\n    /// @notice Contract that stores calldata to be relayed to L2 via storage proofs.\n    HubPoolStore public immutable DATA_STORE;\n\n    error NotImplemented();\n\n    constructor(\n        HubPoolStore _store,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _cctpDestinationDomainId\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDestinationDomainId) {\n        DATA_STORE = _store;\n    }\n\n    /**\n     * @notice Saves calldata in a simple storage contract whose state can be proven and relayed to L2.\n     * @param target Contract on the destination that will receive the message. Unused if the message is created\n     * by the HubPool admin.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        // Admin messages are stored differently in the data store than non-admin messages, because admin\n        // messages must only be sent to a single target on a specific L2 chain. Non-admin messages are sent\n        // to any target on any L2 chain because the only type of an non-admin message is the result of a\n        // HubPool.executeRootBundle() call which attempts to relay a relayRootBundle() call to all SpokePools using\n        // this adapter. Therefore, non-admin messages are stored optimally in the data store\n        // by only storing the message once and allowing any SpokePool target to read it via storage proofs.\n\n        // We assume that the HubPool is delegatecall-ing into this function, therefore address(this) is the HubPool's\n        // address. As a result, we can determine whether this message is an admin function based on the msg.sender.\n        // If an admin sends a message that could have been relayed as a non-admin message (e.g. the admin\n        // calls executeRootBundle()), then the message won't be stored optimally in the data store, but the\n        // message can still be delivered to the target.\n        bool isAdminSender = msg.sender == IOwnable(address(this)).owner();\n        DATA_STORE.storeRelayMessageCalldata(target, message, isAdminSender);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Relays tokens from L1 to L2.\n     * @dev This function only uses the CircleCCTPAdapter to relay USDC tokens to CCTP enabled L2 chains.\n     * Relaying other tokens will cause this function to revert.\n     * @param l1Token Address of the token on L1.\n     * @param l2Token Address of the token on L2. Unused\n     * @param amount Amount of tokens to relay.\n     * @param to Address to receive the tokens on L2. Should be SpokePool address.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            revert NotImplemented();\n        }\n    }\n}\n",
        "HubPoolStore.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { HubPoolInterface } from \"../../interfaces/HubPoolInterface.sol\";\n\ninterface IHubPool {\n    function rootBundleProposal() external view returns (HubPoolInterface.RootBundle memory);\n}\n\n/**\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\n * on the L2 where the SpokePool is deployed. Only the HubPool can store data to this contract. Each data to be\n * relayed is written to a unique slot key and that slot key's value can never be modified.\n * @dev Designed to be used with Universal_Adapter and Universal_SpokePool.\n * @dev This contract DOES NOT prevent replay attacks of storage proofs on the L2 spoke pool if the\n * UniversalStorageProof_Adapters using this contract are mapped to spokepools with the same address on different\n * L2 chains. See comment in storeRelayAdminFunctionCalldata() for more details.\n */\ncontract HubPoolStore {\n    error NotHubPool();\n\n    /// @notice Maps nonce to hash of calldata.\n    mapping(uint256 => bytes32) public relayMessageCallData;\n\n    /// @notice Counter to ensure that each relay admin function calldata is unique.\n    uint256 private dataUuid;\n\n    /// @notice Address of the HubPool contract, the only contract that can store data to this contract.\n    address public immutable hubPool;\n\n    /// @notice Event designed to be queried off chain and relayed to Universal SpokePool.\n    event StoredCallData(address indexed target, bytes data, uint256 indexed nonce);\n\n    modifier onlyHubPool() {\n        if (msg.sender != hubPool) {\n            revert NotHubPool();\n        }\n        _;\n    }\n\n    constructor(address _hubPool) {\n        hubPool = _hubPool;\n    }\n\n    /**\n     * @notice To be called by HubPool to store calldata that will be relayed\n     * to the Universal_SpokePool via storage proofs.\n     * @dev Only callable by the HubPool contract.\n     * @param target Address of the contract on the destination that will receive the message. Unused if the\n     * data is NOT an admin function and can be relayed to any target.\n     * @param data Data to send to Universal SpokePool.\n     * @param isAdminSender True if the data is an admin function call, false otherwise.\n     */\n    function storeRelayMessageCalldata(\n        address target,\n        bytes calldata data,\n        bool isAdminSender\n    ) external onlyHubPool {\n        if (isAdminSender) {\n            _storeData(target, dataUuid++, data);\n        } else {\n            _storeRelayMessageCalldataForAnyTarget(data);\n        }\n    }\n\n    function _storeRelayMessageCalldataForAnyTarget(bytes calldata data) internal {\n        // When the data can be sent to any target, we assume that the data contains a relayRootBundleCall as\n        // constructed by an executeRootBundle() call, therefore this data will be identical for all spoke pools\n        // in this bundle. We can use the current hub pool's challengePeriodEndTimestamp as the nonce for this data\n        // so that all relayRootBundle calldata for this bundle gets stored to the same slot and we only write to\n        // this slot once.\n        _storeData(address(0), IHubPool(hubPool).rootBundleProposal().challengePeriodEndTimestamp, data);\n    }\n\n    function _storeData(\n        address target,\n        uint256 nonce,\n        bytes calldata data\n    ) internal {\n        if (relayMessageCallData[nonce] != bytes32(0)) {\n            // Data is already stored, do nothing.\n            return;\n        }\n        relayMessageCallData[nonce] = keccak256(abi.encode(target, data));\n        emit StoredCallData(target, data, nonce);\n    }\n}\n",
        "HubPool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./interfaces/HubPoolInterface.sol\";\nimport \"./Lockable.sol\";\n\nimport \"./interfaces/LpTokenFactoryInterface.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\n\nimport \"@uma/core/contracts/common/implementation/Testable.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol\";\n\nimport \"@uma/core/contracts/data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"@uma/core/contracts/data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"@uma/core/contracts/data-verification-mechanism/interfaces/StoreInterface.sol\";\nimport \"@uma/core/contracts/data-verification-mechanism/implementation/Constants.sol\";\n\nimport \"@uma/core/contracts/optimistic-oracle-v2/interfaces/SkinnyOptimisticOracleInterface.sol\";\nimport \"@uma/core/contracts/common/interfaces/ExpandedIERC20.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @notice Contract deployed on Ethereum that houses L1 token liquidity for all SpokePools. A dataworker can interact\n * with merkle roots stored in this contract via inclusion proofs to instruct this contract to send tokens to L2\n * SpokePools via \"pool rebalances\" that can be used to pay out relayers on those networks. This contract is also\n * responsible for publishing relayer refund and slow relay merkle roots to SpokePools.\n * @notice This contract is meant to act as the cross chain administrator and owner of all L2 spoke pools, so all\n * governance actions and pool rebalances originate from here and bridge instructions to L2s.\n * @dev This contract should be deprecated by the year 2106, at which point uint32 timestamps will roll over. This is\n * an issue for this contract because fee calculations will become bizarre when multiplying by negative time deltas.\n * Before this date, this contract should be paused from accepting new root bundles and all LP tokens should be\n * disabled by the admin.\n * @custom:security-contact bugs@across.to\n */\ncontract HubPool is HubPoolInterface, Testable, Lockable, MultiCaller, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // Only one root bundle can be stored at a time. Once all pool rebalance leaves are executed, a new proposal\n    // can be submitted.\n    RootBundle public rootBundleProposal;\n\n    // Mapping of L1 token addresses to the associated pool information.\n    mapping(address => PooledToken) public pooledTokens;\n\n    // Stores paths from L1 token + destination ID to destination token. Since different tokens on L1 might map to\n    // to the same address on different destinations, we hash (L1 token address, destination ID) to\n    // use as a key that maps to a destination token. This mapping is used to direct pool rebalances from\n    // HubPool to SpokePool, and also is designed to be used as a lookup for off-chain data workers to determine\n    // which L1 tokens to relay to SpokePools to refund relayers. The admin can set the \"destination token\"\n    // to 0x0 to disable a pool rebalance route and block executeRootBundle() from executing.\n    mapping(bytes32 => address) private poolRebalanceRoutes;\n\n    // Mapping of chainId to the associated adapter and spokePool contracts.\n    mapping(uint256 => CrossChainContract) public crossChainContracts;\n\n    mapping(address => uint256) public unclaimedAccumulatedProtocolFees;\n\n    // Whether the bundle proposal process is paused.\n    bool public paused;\n\n    // WETH contract for Ethereum.\n    WETH9Interface public immutable weth;\n\n    // Helper factory to deploy new LP tokens for enabled L1 tokens\n    LpTokenFactoryInterface public immutable lpTokenFactory;\n\n    // Finder contract for this network.\n    FinderInterface public immutable finder;\n\n    // Address that captures protocol fees. Accumulated protocol fees can be claimed by this address.\n    address public protocolFeeCaptureAddress;\n\n    // Token used to bond the data worker for proposing relayer refund bundles.\n    IERC20 public bondToken;\n\n    // Each root bundle proposal must stay in liveness for this period of time before it can be considered finalized.\n    // It can be disputed only during this period of time. Defaults to 2 hours, like the rest of the UMA ecosystem.\n    uint32 public liveness = 7200;\n\n    // When root bundles are disputed a price request is enqueued with the DVM to resolve the resolution.\n    bytes32 public identifier = \"ACROSS-V2\";\n\n    // Interest rate payment that scales the amount of pending fees per second paid to LPs. 0.0000015e18 will pay out\n    // the full amount of fees entitled to LPs in ~ 7.72 days assuming no contract interactions. If someone interacts\n    // with the contract then the LP rewards are smeared sublinearly over the window (i.e spread over the remaining\n    // period for each interaction which approximates a decreasing exponential function).\n    uint256 public lpFeeRatePerSecond = 1500000000000;\n\n    // Percentage of lpFees that are captured by the protocol and claimable by the protocolFeeCaptureAddress.\n    uint256 public protocolFeeCapturePct;\n\n    // The computed bond amount as the UMA Store's final fee multiplied by the bondTokenFinalFeeMultiplier.\n    uint256 public bondAmount;\n\n    event Paused(bool indexed isPaused);\n\n    event EmergencyRootBundleDeleted(\n        bytes32 indexed poolRebalanceRoot,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 slowRelayRoot,\n        address indexed proposer\n    );\n\n    event ProtocolFeeCaptureSet(address indexed newProtocolFeeCaptureAddress, uint256 indexed newProtocolFeeCapturePct);\n\n    event ProtocolFeesCapturedClaimed(address indexed l1Token, uint256 indexed accumulatedFees);\n\n    event BondSet(address indexed newBondToken, uint256 newBondAmount);\n\n    event LivenessSet(uint256 newLiveness);\n\n    event IdentifierSet(bytes32 newIdentifier);\n\n    event CrossChainContractsSet(uint256 l2ChainId, address adapter, address spokePool);\n\n    event L1TokenEnabledForLiquidityProvision(address l1Token, address lpToken);\n\n    event L2TokenDisabledForLiquidityProvision(address l1Token, address lpToken);\n\n    event LiquidityAdded(\n        address indexed l1Token,\n        uint256 amount,\n        uint256 lpTokensMinted,\n        address indexed liquidityProvider\n    );\n    event LiquidityRemoved(\n        address indexed l1Token,\n        uint256 amount,\n        uint256 lpTokensBurnt,\n        address indexed liquidityProvider\n    );\n    event SetPoolRebalanceRoute(\n        uint256 indexed destinationChainId,\n        address indexed l1Token,\n        address indexed destinationToken\n    );\n    event SetEnableDepositRoute(\n        uint256 indexed originChainId,\n        uint256 indexed destinationChainId,\n        address indexed originToken,\n        bool depositsEnabled\n    );\n    event ProposeRootBundle(\n        uint32 challengePeriodEndTimestamp,\n        uint8 poolRebalanceLeafCount,\n        uint256[] bundleEvaluationBlockNumbers,\n        bytes32 indexed poolRebalanceRoot,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 slowRelayRoot,\n        address indexed proposer\n    );\n    event RootBundleExecuted(\n        uint256 groupIndex,\n        uint256 indexed leafId,\n        uint256 indexed chainId,\n        address[] l1Tokens,\n        uint256[] bundleLpFees,\n        int256[] netSendAmounts,\n        int256[] runningBalances,\n        address indexed caller\n    );\n    event SpokePoolAdminFunctionTriggered(uint256 indexed chainId, bytes message);\n\n    event RootBundleDisputed(address indexed disputer, uint256 requestTime);\n\n    event RootBundleCanceled(address indexed disputer, uint256 requestTime);\n\n    modifier noActiveRequests() {\n        require(!_activeRequest(), \"Proposal has unclaimed leaves\");\n        _;\n    }\n\n    modifier unpaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    modifier zeroOptimisticOracleApproval() {\n        _;\n        bondToken.safeApprove(address(_getOptimisticOracle()), 0);\n    }\n\n    /**\n     * @notice Construct HubPool.\n     * @param _lpTokenFactory LP Token factory address used to deploy LP tokens for new collateral types.\n     * @param _finder Finder address.\n     * @param _weth WETH address.\n     * @param _timer Timer address.\n     */\n    constructor(\n        LpTokenFactoryInterface _lpTokenFactory,\n        FinderInterface _finder,\n        WETH9Interface _weth,\n        address _timer\n    ) Testable(_timer) {\n        lpTokenFactory = _lpTokenFactory;\n        finder = _finder;\n        weth = _weth;\n        protocolFeeCaptureAddress = owner();\n    }\n\n    /*************************************************\n     *                ADMIN FUNCTIONS                *\n     *************************************************/\n\n    /**\n     * @notice Pauses the bundle proposal and execution process. This is intended to be used during upgrades or when\n     * something goes awry.\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function setPaused(bool pause) public onlyOwner nonReentrant {\n        paused = pause;\n        emit Paused(pause);\n    }\n\n    /**\n     * @notice This allows for the deletion of the active proposal in case of emergency.\n     * @dev This is primarily intended to rectify situations where an unexecutable bundle gets through liveness in the\n     * case of a non-malicious bug in the proposal/dispute code. Without this function, the contract would be\n     * indefinitely blocked, migration would be required, and in-progress transfers would never be repaid.\n     */\n    function emergencyDeleteProposal() public onlyOwner nonReentrant {\n        RootBundle memory _rootBundleProposal = rootBundleProposal;\n        delete rootBundleProposal;\n        if (_rootBundleProposal.unclaimedPoolRebalanceLeafCount > 0)\n            bondToken.safeTransfer(_rootBundleProposal.proposer, bondAmount);\n        emit EmergencyRootBundleDeleted(\n            _rootBundleProposal.poolRebalanceRoot,\n            _rootBundleProposal.relayerRefundRoot,\n            _rootBundleProposal.slowRelayRoot,\n            _rootBundleProposal.proposer\n        );\n    }\n\n    /**\n     * @notice Sends message to SpokePool from this contract. Callable only by owner.\n     * @dev This function has permission to call onlyAdmin functions on the SpokePool, so it's imperative that this\n     * contract only allows the owner to call this method directly or indirectly.\n     * @param chainId Chain with SpokePool to send message to.\n     * @param functionData ABI encoded function call to send to SpokePool, but can be any arbitrary data technically.\n     */\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData)\n        public\n        override\n        onlyOwner\n        nonReentrant\n    {\n        _relaySpokePoolAdminFunction(chainId, functionData);\n    }\n\n    /**\n     * @notice Sets protocolFeeCaptureAddress and protocolFeeCapturePct. Callable only by owner.\n     * @param newProtocolFeeCaptureAddress New protocol fee capture address.\n     * @param newProtocolFeeCapturePct New protocol fee capture %.\n     */\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct)\n        public\n        override\n        onlyOwner\n        nonReentrant\n    {\n        require(newProtocolFeeCapturePct <= 1e18, \"Bad protocolFeeCapturePct\");\n        require(newProtocolFeeCaptureAddress != address(0), \"Bad protocolFeeCaptureAddress\");\n        protocolFeeCaptureAddress = newProtocolFeeCaptureAddress;\n        protocolFeeCapturePct = newProtocolFeeCapturePct;\n        emit ProtocolFeeCaptureSet(newProtocolFeeCaptureAddress, newProtocolFeeCapturePct);\n    }\n\n    /**\n     * @notice Sets bond token and amount. Callable only by owner.\n     * @param newBondToken New bond currency.\n     * @param newBondAmount New bond amount.\n     */\n    function setBond(IERC20 newBondToken, uint256 newBondAmount)\n        public\n        override\n        onlyOwner\n        noActiveRequests\n        nonReentrant\n    {\n        // Bond should not equal final fee otherwise every proposal will get cancelled in a dispute.\n        // In practice we expect that bond amounts are set >> final fees so this shouldn't be an inconvenience.\n        // The only way for the bond amount to be equal to the final fee is if the newBondAmount == 0.\n        require(newBondAmount != 0, \"bond equal to final fee\");\n\n        // Check that this token is on the whitelist.\n        AddressWhitelistInterface addressWhitelist = AddressWhitelistInterface(\n            finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)\n        );\n        require(addressWhitelist.isOnWhitelist(address(newBondToken)), \"Not on whitelist\");\n\n        // The bond should be the passed in bondAmount + the final fee.\n        bondToken = newBondToken;\n        uint256 _bondAmount = newBondAmount + _getBondTokenFinalFee();\n        bondAmount = _bondAmount;\n        emit BondSet(address(newBondToken), _bondAmount);\n    }\n\n    /**\n     * @notice Sets root bundle proposal liveness period. Callable only by owner.\n     * @param newLiveness New liveness period.\n     */\n    function setLiveness(uint32 newLiveness) public override onlyOwner nonReentrant {\n        require(newLiveness > 10 minutes, \"Liveness too short\");\n        liveness = newLiveness;\n        emit LivenessSet(newLiveness);\n    }\n\n    /**\n     * @notice Sets identifier for root bundle disputes. Callable only by owner.\n     * @param newIdentifier New identifier.\n     */\n    function setIdentifier(bytes32 newIdentifier) public override onlyOwner noActiveRequests nonReentrant {\n        IdentifierWhitelistInterface identifierWhitelist = IdentifierWhitelistInterface(\n            finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\n        );\n        require(identifierWhitelist.isIdentifierSupported(newIdentifier), \"Identifier not supported\");\n        identifier = newIdentifier;\n        emit IdentifierSet(newIdentifier);\n    }\n\n    /**\n     * @notice Sets cross chain relay helper contracts for L2 chain ID. Callable only by owner.\n     * @dev We do not block setting the adapter or SpokePool to invalid/zero addresses because we want to allow the\n     * admin to block relaying roots to the spoke pool for emergency recovery purposes.\n     * @param l2ChainId Chain to set contracts for.\n     * @param adapter Adapter used to relay messages and tokens to spoke pool. Deployed on current chain.\n     * @param spokePool Recipient of relayed messages and tokens on spoke pool. Deployed on l2ChainId.\n     */\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) public override onlyOwner nonReentrant {\n        crossChainContracts[l2ChainId] = CrossChainContract(adapter, spokePool);\n        emit CrossChainContractsSet(l2ChainId, adapter, spokePool);\n    }\n\n    /**\n     * @notice Store canonical destination token counterpart for l1 token. Callable only by owner.\n     * @dev Admin can set destinationToken to 0x0 to effectively disable executing any root bundles with leaves\n     * containing this l1 token + destination chain ID combination.\n     * @param destinationChainId Destination chain where destination token resides.\n     * @param l1Token Token enabled for liquidity in this pool, and the L1 counterpart to the destination token on the\n     * destination chain ID.\n     * @param destinationToken Destination chain counterpart of L1 token.\n     */\n    function setPoolRebalanceRoute(\n        uint256 destinationChainId,\n        address l1Token,\n        address destinationToken\n    ) public override onlyOwner nonReentrant {\n        poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, destinationChainId)] = destinationToken;\n        emit SetPoolRebalanceRoute(destinationChainId, l1Token, destinationToken);\n    }\n\n    /**\n     * @notice Sends cross-chain message to SpokePool on originChainId to enable or disable deposit route from that\n     * SpokePool to another one. Callable only by owner.\n     * @dev Admin is responsible for ensuring that `originToken` is linked to some L1 token on this contract, via\n     * poolRebalanceRoutes(), and that this L1 token also has a counterpart on the destination chain. If either\n     * condition fails, then the deposit will be unrelayable by off-chain relayers because they will not know which\n     * token to relay to recipients on the destination chain, and data workers wouldn't know which L1 token to send\n     * to the destination chain to refund the relayer.\n     * @param originChainId Chain where token deposit occurs.\n     * @param destinationChainId Chain where token depositor wants to receive funds.\n     * @param originToken Token sent in deposit.\n     * @param depositsEnabled Set to true to whitelist this route for deposits, set to false if caller just wants to\n     * map the origin token + destination ID to the destination token address on the origin chain's SpokePool.\n     */\n    function setDepositRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        bool depositsEnabled\n    ) public override nonReentrant onlyOwner {\n        _relaySpokePoolAdminFunction(\n            originChainId,\n            abi.encodeWithSignature(\n                \"setEnableRoute(address,uint256,bool)\",\n                originToken,\n                destinationChainId,\n                depositsEnabled\n            )\n        );\n        emit SetEnableDepositRoute(originChainId, destinationChainId, originToken, depositsEnabled);\n    }\n\n    /**\n     * @notice Enables LPs to provide liquidity for L1 token. Deploys new LP token for L1 token if appropriate.\n     * Callable only by owner.\n     * @param l1Token Token to provide liquidity for.\n     */\n    function enableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner nonReentrant {\n        // If token is being enabled for the first time, create a new LP token and set the timestamp once. We don't\n        // want to ever reset this timestamp otherwise fees that have accrued will be lost since the last update. This\n        // could happen for example if an L1 token is enabled, disabled, and then enabled again.\n        if (pooledTokens[l1Token].lpToken == address(0)) {\n            pooledTokens[l1Token].lpToken = lpTokenFactory.createLpToken(l1Token);\n            pooledTokens[l1Token].lastLpFeeUpdate = uint32(getCurrentTime());\n        }\n\n        pooledTokens[l1Token].isEnabled = true;\n\n        emit L1TokenEnabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);\n    }\n\n    /**\n     * @notice Disables LPs from providing liquidity for L1 token. Callable only by owner.\n     * @param l1Token Token to disable liquidity provision for.\n     */\n    function disableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner nonReentrant {\n        pooledTokens[l1Token].isEnabled = false;\n        emit L2TokenDisabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);\n    }\n\n    /**\n     * @notice Enables the owner of the protocol to haircut reserves in the event of an irrecoverable loss of funds on\n     * one of the L2s. Consider funds are lent out onto a L2 that dies irrecoverably. This value will offset the\n     * exchangeRateCurrent such that all LPs receive a pro rata loss of the reserves. Should be used in conjunction\n     * with pause logic to prevent LPs from adding/withdrawing liquidity during the haircut process.\n     * Callable only by owner.\n     * @param l1Token Token to execute the haircut on.\n     * @param haircutAmount The amount of reserves to haircut the LPs by.\n     */\n    function haircutReserves(address l1Token, int256 haircutAmount) public onlyOwner nonReentrant {\n        // Note that we do not call sync first in this method. The Owner should call this manually before haircutting.\n        // This is done in the event sync reverts due to too low balance in the contract relative to bond amount.\n        pooledTokens[l1Token].utilizedReserves -= haircutAmount;\n    }\n\n    /*************************************************\n     *          LIQUIDITY PROVIDER FUNCTIONS         *\n     *************************************************/\n\n    /**\n     * @notice Deposit liquidity into this contract to earn LP fees in exchange for funding relays on SpokePools.\n     * Caller is essentially loaning their funds to be sent from this contract to the SpokePool, where it will be used\n     * to repay a relayer, and ultimately receives their loan back after the tokens are bridged back to this contract\n     * via the canonical token bridge. Then, the caller's loans are used again. This loan cycle repeats continuously\n     * and the caller, or \"liquidity provider\" earns a continuous fee for their credit that they are extending relayers.\n     * @notice Caller will receive an LP token representing their share of this pool. The LP token's redemption value\n     * increments from the time that they enter the pool to reflect their accrued fees.\n     * @notice The caller of this function must approve this contract to spend l1TokenAmount of l1Token.\n     * @param l1Token Token to deposit into this contract.\n     * @param l1TokenAmount Amount of liquidity to provide.\n     */\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) public payable override nonReentrant unpaused {\n        require(pooledTokens[l1Token].isEnabled, \"Token not enabled\");\n        // If this is the weth pool and the caller sends msg.value then the msg.value must match the l1TokenAmount.\n        // Else, msg.value must be set to 0.\n        require(((address(weth) == l1Token) && msg.value == l1TokenAmount) || msg.value == 0, \"Bad msg.value\");\n\n        // Since _exchangeRateCurrent() reads this contract's balance and updates contract state using it, it must be\n        // first before transferring any tokens to this contract to ensure synchronization.\n        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent(l1Token);\n        pooledTokens[l1Token].liquidReserves += l1TokenAmount;\n        ExpandedIERC20(pooledTokens[l1Token].lpToken).mint(msg.sender, lpTokensToMint);\n\n        if (address(weth) == l1Token && msg.value > 0) WETH9Interface(address(l1Token)).deposit{ value: msg.value }();\n        else IERC20(l1Token).safeTransferFrom(msg.sender, address(this), l1TokenAmount);\n\n        emit LiquidityAdded(l1Token, l1TokenAmount, lpTokensToMint, msg.sender);\n    }\n\n    /**\n     * @notice Burns LP share to redeem for underlying l1Token original deposit amount plus fees.\n     * @param l1Token Token to redeem LP share for.\n     * @param lpTokenAmount Amount of LP tokens to burn. Exchange rate between L1 token and LP token can be queried\n     * via public exchangeRateCurrent method.\n     * @param sendEth Set to True if L1 token is WETH and user wants to receive ETH. Note that if caller\n     * is a contract, then the contract should have a way to receive ETH if this value is set to True. Similarly,\n     * if this value is set to False, then the calling contract should have a way to handle WETH.\n     */\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) public override nonReentrant unpaused {\n        require(address(weth) == l1Token || !sendEth, \"Cant send eth\");\n        uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent(l1Token)) / 1e18;\n\n        ExpandedIERC20(pooledTokens[l1Token].lpToken).burnFrom(msg.sender, lpTokenAmount);\n        // Note this method does not make any liquidity utilization checks before letting the LP redeem their LP tokens.\n        // If they try access more funds than available (i.e l1TokensToReturn > liquidReserves) this will underflow.\n        pooledTokens[l1Token].liquidReserves -= l1TokensToReturn;\n\n        if (sendEth) {\n            weth.withdraw(l1TokensToReturn);\n            Address.sendValue(payable(msg.sender), l1TokensToReturn); // This will revert if the caller is a contract that does not implement a fallback function.\n        } else {\n            IERC20(address(l1Token)).safeTransfer(msg.sender, l1TokensToReturn);\n        }\n        emit LiquidityRemoved(l1Token, l1TokensToReturn, lpTokenAmount, msg.sender);\n    }\n\n    /**\n     * @notice Returns exchange rate of L1 token to LP token.\n     * @param l1Token L1 token redeemable by burning LP token.\n     * @return Amount of L1 tokens redeemable for 1 unit LP token.\n     */\n    function exchangeRateCurrent(address l1Token) public override nonReentrant returns (uint256) {\n        return _exchangeRateCurrent(l1Token);\n    }\n\n    /**\n     * @notice Returns % of liquid reserves currently being \"used\" and sitting in SpokePools.\n     * @param l1Token L1 token to query utilization for.\n     * @return % of liquid reserves currently being \"used\" and sitting in SpokePools.\n     */\n    function liquidityUtilizationCurrent(address l1Token) public override nonReentrant returns (uint256) {\n        return _liquidityUtilizationPostRelay(l1Token, 0);\n    }\n\n    /**\n     * @notice Returns % of liquid reserves currently being \"used\" and sitting in SpokePools and accounting for\n     * relayedAmount of tokens to be withdrawn from the pool.\n     * @param l1Token L1 token to query utilization for.\n     * @param relayedAmount The higher this amount, the higher the utilization.\n     * @return % of liquid reserves currently being \"used\" and sitting in SpokePools plus the relayedAmount.\n     */\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount)\n        public\n        nonReentrant\n        returns (uint256)\n    {\n        return _liquidityUtilizationPostRelay(l1Token, relayedAmount);\n    }\n\n    /**\n     * @notice Synchronize any balance changes in this contract with the utilized & liquid reserves. This should be done\n     * at the conclusion of a L2->L1 token transfer via the canonical token bridge, when this contract's reserves do not\n     * reflect its true balance due to new tokens being dropped onto the contract at the conclusion of a bridging action.\n     */\n    function sync(address l1Token) public override nonReentrant {\n        _sync(l1Token);\n    }\n\n    /*************************************************\n     *             DATA WORKER FUNCTIONS             *\n     *************************************************/\n\n    /**\n     * @notice Publish a new root bundle along with all of the block numbers that the merkle roots are relevant for.\n     * This is used to aid off-chain validators in evaluating the correctness of this bundle. Caller stakes a bond that\n     * can be slashed if the root bundle proposal is invalid, and they will receive it back if accepted.\n     * @notice After proposeRootBundle is called, if the any props are wrong then this proposal can be challenged.\n     * Once the challenge period passes, then the roots are no longer disputable, and only executeRootBundle can be\n     * called; moreover, this method can't be called again until all leaves are executed.\n     * @param bundleEvaluationBlockNumbers should contain the latest block number for all chains, even if there are no\n     * relays contained on some of them. The usage of this variable should be defined in an off chain UMIP.\n     * @notice The caller of this function must approve this contract to spend bondAmount of bondToken.\n     * @param poolRebalanceLeafCount Number of leaves contained in pool rebalance root. Max is # of whitelisted chains.\n     * @param poolRebalanceRoot Pool rebalance root containing leaves that sends tokens from this contract to SpokePool.\n     * @param relayerRefundRoot Relayer refund root to publish to SpokePool where a data worker can execute leaves to\n     * refund relayers on their chosen refund chainId.\n     * @param slowRelayRoot Slow relay root to publish to Spoke Pool where a data worker can execute leaves to\n     * fulfill slow relays.\n     */\n    function proposeRootBundle(\n        uint256[] calldata bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) public override nonReentrant noActiveRequests unpaused {\n        // Note: this is to prevent \"empty block\" style attacks where someone can make empty proposals that are\n        // technically valid but not useful. This could also potentially be enforced at the UMIP-level.\n        require(poolRebalanceLeafCount > 0, \"Bundle must have at least 1 leaf\");\n\n        uint32 challengePeriodEndTimestamp = uint32(getCurrentTime()) + liveness;\n\n        delete rootBundleProposal; // Only one bundle of roots can be executed at a time. Delete the previous bundle.\n\n        rootBundleProposal.challengePeriodEndTimestamp = challengePeriodEndTimestamp;\n        rootBundleProposal.unclaimedPoolRebalanceLeafCount = poolRebalanceLeafCount;\n        rootBundleProposal.poolRebalanceRoot = poolRebalanceRoot;\n        rootBundleProposal.relayerRefundRoot = relayerRefundRoot;\n        rootBundleProposal.slowRelayRoot = slowRelayRoot;\n        rootBundleProposal.proposer = msg.sender;\n\n        // Pull bondAmount of bondToken from the caller.\n        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n\n        emit ProposeRootBundle(\n            challengePeriodEndTimestamp,\n            poolRebalanceLeafCount,\n            bundleEvaluationBlockNumbers,\n            poolRebalanceRoot,\n            relayerRefundRoot,\n            slowRelayRoot,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Executes a pool rebalance leaf as part of the currently published root bundle. Will bridge any tokens\n     * from this contract to the SpokePool designated in the leaf, and will also publish relayer refund and slow\n     * relay roots to the SpokePool on the network specified in the leaf.\n     * @dev In some cases, will instruct spokePool to send funds back to L1.\n     * @param chainId ChainId number of the target spoke pool on which the bundle is executed.\n     * @param groupIndex If set to 0, then relay roots to SpokePool via cross chain bridge. Used by off-chain validator\n     * to organize leaves with the same chain ID and also set which leaves should result in relayed messages.\n     * @param bundleLpFees Array representing the total LP fee amount per token in this bundle for all bundled relays.\n     * @param netSendAmounts Array representing the amount of tokens to send to the SpokePool on the target chainId.\n     * @param runningBalances Array used to track any unsent tokens that are not included in the netSendAmounts.\n     * @param leafId Index of this executed leaf within the poolRebalance tree.\n     * @param l1Tokens Array of all the tokens associated with the bundleLpFees, nedSendAmounts and runningBalances.\n     * @param proof Inclusion proof for this leaf in pool rebalance root in root bundle.\n     */\n\n    function executeRootBundle(\n        uint256 chainId,\n        uint256 groupIndex,\n        uint256[] memory bundleLpFees,\n        int256[] memory netSendAmounts,\n        int256[] memory runningBalances,\n        uint8 leafId,\n        address[] memory l1Tokens,\n        bytes32[] calldata proof\n    ) public nonReentrant unpaused {\n        require(getCurrentTime() > rootBundleProposal.challengePeriodEndTimestamp, \"Not passed liveness\");\n\n        // Verify the leafId in the poolRebalanceLeaf has not yet been claimed.\n        require(!MerkleLib.isClaimed1D(rootBundleProposal.claimedBitMap, leafId), \"Already claimed\");\n\n        // Verify the props provided generate a leaf that, along with the proof, are included in the merkle root.\n        require(\n            MerkleLib.verifyPoolRebalance(\n                rootBundleProposal.poolRebalanceRoot,\n                PoolRebalanceLeaf({\n                    chainId: chainId,\n                    groupIndex: groupIndex,\n                    bundleLpFees: bundleLpFees,\n                    netSendAmounts: netSendAmounts,\n                    runningBalances: runningBalances,\n                    leafId: leafId,\n                    l1Tokens: l1Tokens\n                }),\n                proof\n            ),\n            \"Bad Proof\"\n        );\n        // Grouping code that uses adapter and spokepool to avoid stack too deep warning.\n        // Get cross chain helpers for leaf's destination chain ID. This internal method will revert if either helper\n        // is set improperly.\n        (address adapter, address spokePool) = _getInitializedCrossChainContracts(chainId);\n\n        // Set the leafId in the claimed bitmap.\n        rootBundleProposal.claimedBitMap = MerkleLib.setClaimed1D(rootBundleProposal.claimedBitMap, leafId);\n\n        // Decrement the unclaimedPoolRebalanceLeafCount.\n        --rootBundleProposal.unclaimedPoolRebalanceLeafCount;\n\n        // Relay each L1 token to destination chain.\n        // Note: if any of the keccak256(l1Tokens, chainId) combinations are not mapped to a destination token address,\n        // then this internal method will revert. In this case the admin will have to associate a destination token\n        // with each l1 token. If the destination token mapping was missing at the time of the proposal, we assume\n        // that the root bundle would have been disputed because the off-chain data worker would have been unable to\n        // determine if the relayers used the correct destination token for a given origin token.\n        _sendTokensToChainAndUpdatePooledTokenTrackers(\n            adapter,\n            spokePool,\n            chainId,\n            l1Tokens,\n            netSendAmounts,\n            bundleLpFees\n        );\n\n        // Check bool used by data worker to prevent relaying redundant roots to SpokePool.\n        if (groupIndex == 0) {\n            // Relay root bundles to spoke pool on destination chain by\n            // performing delegatecall to use the adapter's code with this contract's context.\n\n            // We are ok with this low-level call since the adapter address is set by the admin and we've\n            // already checked that its not the zero address.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = adapter.delegatecall(\n                abi.encodeWithSignature(\n                    \"relayMessage(address,bytes)\",\n                    spokePool, // target. This should be the spokePool on the L2.\n                    abi.encodeWithSignature(\n                        \"relayRootBundle(bytes32,bytes32)\",\n                        rootBundleProposal.relayerRefundRoot,\n                        rootBundleProposal.slowRelayRoot\n                    ) // message\n                )\n            );\n            require(success, \"delegatecall failed\");\n        }\n\n        // Transfer the bondAmount back to the proposer, if this the last executed leaf. Only sending this once all\n        // leaves have been executed acts to force the data worker to execute all bundles or they won't receive their bond.\n        if (rootBundleProposal.unclaimedPoolRebalanceLeafCount == 0)\n            bondToken.safeTransfer(rootBundleProposal.proposer, bondAmount);\n\n        emit RootBundleExecuted(\n            groupIndex,\n            leafId,\n            chainId,\n            l1Tokens,\n            bundleLpFees,\n            netSendAmounts,\n            runningBalances,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Caller stakes a bond to dispute the current root bundle proposal assuming it has not passed liveness\n     * yet. The proposal is deleted, allowing a follow-up proposal to be submitted, and the dispute is sent to the\n     * optimistic oracle to be adjudicated. Can only be called within the liveness period of the current proposal.\n     * @notice The caller of this function must approve this contract to spend bondAmount of l1Token.\n     */\n    function disputeRootBundle() public nonReentrant zeroOptimisticOracleApproval {\n        uint32 currentTime = uint32(getCurrentTime());\n        require(currentTime <= rootBundleProposal.challengePeriodEndTimestamp, \"Request passed liveness\");\n\n        // Request price from OO and dispute it.\n        uint256 finalFee = _getBondTokenFinalFee();\n\n        // This method will request a price from the OO and dispute it. Note that we set the ancillary data to\n        // the empty string (\"\"). The root bundle that is being disputed was the most recently proposed one with a\n        // block number less than or equal to the dispute block time. All of this root bundle data can be found in\n        // the ProposeRootBundle event params. Moreover, the optimistic oracle will stamp the requester's address\n        // (i.e. this contract address) meaning that ancillary data for a dispute originating from another HubPool\n        // will always be distinct from a dispute originating from this HubPool. Moreover, since\n        // bundleEvaluationNumbers for a root bundle proposal are not stored in this contract, DVM voters will always\n        // have to look up the ProposeRootBundle event to evaluate a dispute, therefore there is no point emitting extra\n        // data in this ancillary data that is already included in the ProposeRootBundle event.\n\n        // If the finalFee is larger than the bond amount, the bond amount needs to be reset before a request can go\n        // through. Cancel to avoid a revert. Similarly, if the final fee == bond amount, then the proposer bond\n        // set in the optimistic oracle would be 0. The optimistic oracle would then default the bond to be equal\n        // to the final fee, which would mean that the allowance set to the bondAmount would be insufficient and the\n        // requestAndProposePriceFor() call would revert. Source: https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L321\n        if (finalFee >= bondAmount) {\n            _cancelBundle();\n            return;\n        }\n\n        SkinnyOptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Only approve exact tokens to avoid more tokens than expected being pulled into the OptimisticOracle.\n        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);\n        try\n            optimisticOracle.requestAndProposePriceFor(\n                identifier,\n                currentTime,\n                \"\",\n                bondToken,\n                // Set reward to 0, since we'll settle proposer reward payouts directly from this contract after a root\n                // proposal has passed the challenge period.\n                0,\n                // Set the Optimistic oracle proposer bond for the request. We can assume that bondAmount > finalFee.\n                bondAmount - finalFee,\n                // Set the Optimistic oracle liveness for the price request.\n                liveness,\n                rootBundleProposal.proposer,\n                // Canonical value representing \"True\"; i.e. the proposed relay is valid.\n                int256(1e18)\n            )\n        returns (uint256) {\n            // Ensure that approval == 0 after the call so the increaseAllowance call below doesn't allow more tokens\n            // to transfer than intended.\n            bondToken.safeApprove(address(optimisticOracle), 0);\n        } catch {\n            // Cancel the bundle since the proposal failed.\n            _cancelBundle();\n            return;\n        }\n\n        // Dispute the request that we just sent.\n        SkinnyOptimisticOracleInterface.Request memory ooPriceRequest = SkinnyOptimisticOracleInterface.Request({\n            proposer: rootBundleProposal.proposer,\n            disputer: address(0),\n            currency: bondToken,\n            settled: false,\n            proposedPrice: int256(1e18),\n            resolvedPrice: 0,\n            expirationTime: currentTime + liveness,\n            reward: 0,\n            finalFee: finalFee,\n            bond: bondAmount - finalFee,\n            customLiveness: liveness\n        });\n\n        // Finally, delete the state pertaining to the active proposal so that another proposer can submit a new bundle.\n        delete rootBundleProposal;\n\n        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);\n        optimisticOracle.disputePriceFor(identifier, currentTime, \"\", ooPriceRequest, msg.sender, address(this));\n\n        emit RootBundleDisputed(msg.sender, currentTime);\n    }\n\n    /**\n     * @notice Send unclaimed accumulated protocol fees to fee capture address.\n     * @param l1Token Token whose protocol fees the caller wants to disburse.\n     */\n    function claimProtocolFeesCaptured(address l1Token) public override nonReentrant {\n        uint256 _unclaimedAccumulatedProtocolFees = unclaimedAccumulatedProtocolFees[l1Token];\n        unclaimedAccumulatedProtocolFees[l1Token] = 0;\n        IERC20(l1Token).safeTransfer(protocolFeeCaptureAddress, _unclaimedAccumulatedProtocolFees);\n        emit ProtocolFeesCapturedClaimed(l1Token, _unclaimedAccumulatedProtocolFees);\n    }\n\n    /**\n     * @notice Conveniently queries which destination token is mapped to the hash of an l1 token + destination chain ID.\n     * @dev Admin must be considerate to the compatibility of originToken and destinationToken within the protocol. Some\n     * token implementations will not function correctly within the Across v2 system. For example ERC20s that charge\n     * fees will break internal accounting, ERC777 can cause some functions to revert and upgradable tokens can pose\n     * risks if the implementation is shifted between whitelisting and usage.\n     * @dev If the pool rebalance route is not whitelisted then this will return address(0).\n     * @param destinationChainId Where destination token is deployed.\n     * @param l1Token Ethereum version token.\n     * @return destinationToken address The destination token that is sent to spoke pools after this contract bridges\n     * the l1Token to the destination chain.\n     */\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\n        external\n        view\n        override\n        returns (address destinationToken)\n    {\n        return poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, destinationChainId)];\n    }\n\n    /**\n     * @notice This function allows a caller to load the contract with raw ETH to perform L2 calls. This is needed for\n     * Arbitrum calls, but may also be needed for others.\n     * @dev This function cannot be included in a multicall transaction call because it is payable. A realistic\n     * situation where this might be an issue is if the caller is executing a PoolRebalanceLeaf that needs to relay\n     * messages to Arbitrum. Relaying messages to Arbitrum requires that this contract has an ETH balance, so in this\n     * case the caller would need to pre-load this contract with ETH before multicall-executing the leaf.\n     */\n    function loadEthForL2Calls() public payable override {\n        /* solhint-disable-line no-empty-blocks */\n    }\n\n    /*************************************************\n     *              INTERNAL FUNCTIONS               *\n     *************************************************/\n\n    // Called when a dispute fails due to parameter changes. This effectively resets the state and cancels the request\n    // with no loss of funds, thereby enabling a new bundle to be added.\n    function _cancelBundle() internal {\n        bondToken.transfer(rootBundleProposal.proposer, bondAmount);\n        delete rootBundleProposal;\n        emit RootBundleCanceled(msg.sender, getCurrentTime());\n    }\n\n    function _getOptimisticOracle() internal view returns (SkinnyOptimisticOracleInterface) {\n        return\n            SkinnyOptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle));\n    }\n\n    function _getBondTokenFinalFee() internal view returns (uint256) {\n        return\n            StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store))\n                .computeFinalFee(address(bondToken))\n                .rawValue;\n    }\n\n    // Note this method does a lot and wraps together the sending of tokens and updating the pooled token trackers. This\n    // is done as a gas saving so we don't need to iterate over the l1Tokens multiple times.\n    function _sendTokensToChainAndUpdatePooledTokenTrackers(\n        address adapter,\n        address spokePool,\n        uint256 chainId,\n        address[] memory l1Tokens,\n        int256[] memory netSendAmounts,\n        uint256[] memory bundleLpFees\n    ) internal {\n        uint256 length = l1Tokens.length;\n        for (uint256 i = 0; i < length; ) {\n            address l1Token = l1Tokens[i];\n            // Validate the L1 -> L2 token route is stored. If it is not then the output of the bridging action\n            // could send tokens to the 0x0 address on the L2.\n            address l2Token = poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, chainId)];\n            require(l2Token != address(0), \"Route not whitelisted\");\n\n            // If the net send amount for this token is positive then: 1) send tokens from L1->L2 to facilitate the L2\n            // relayer refund, 2) Update the liquidity trackers for the associated pooled tokens.\n            if (netSendAmounts[i] > 0) {\n                // Perform delegatecall to use the adapter's code with this contract's context. Opt for delegatecall's\n                // complexity in exchange for lower gas costs.\n\n                // We are ok with this low-level call since the adapter address is set by the admin and we've\n                // already checked that its not the zero address.\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = adapter.delegatecall(\n                    abi.encodeWithSignature(\n                        \"relayTokens(address,address,uint256,address)\",\n                        l1Token, // l1Token.\n                        l2Token, // l2Token.\n                        uint256(netSendAmounts[i]), // amount.\n                        spokePool // to. This should be the spokePool.\n                    )\n                );\n                require(success, \"delegatecall failed\");\n\n                // Liquid reserves is decreased by the amount sent. utilizedReserves is increased by the amount sent.\n                pooledTokens[l1Token].utilizedReserves += netSendAmounts[i];\n                pooledTokens[l1Token].liquidReserves -= uint256(netSendAmounts[i]);\n            }\n\n            // Allocate LP fees and protocol fees from the bundle to the associated pooled token trackers.\n            _allocateLpAndProtocolFees(l1Token, bundleLpFees[i]);\n\n            // L1 tokens length won't be > types(uint256).length, so use unchecked block to save gas. Based on the\n            // stress test results in /test/gas-analytics/HubPool.RootExecution.ts, the UMIP should limit the L1 token\n            // count in valid proposals to be ~100 so any PoolRebalanceLeaves with > 100 l1Tokens should not make it\n            // to this stage.\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _exchangeRateCurrent(address l1Token) internal returns (uint256) {\n        PooledToken storage pooledToken = pooledTokens[l1Token]; // Note this is storage so the state can be modified.\n        uint256 lpTokenTotalSupply = IERC20(pooledToken.lpToken).totalSupply();\n        if (lpTokenTotalSupply == 0) return 1e18; // initial rate is 1:1 between LP tokens and collateral.\n\n        // First, update fee counters and local accounting of finalized transfers from L2 -> L1.\n        _updateAccumulatedLpFees(pooledToken); // Accumulate all allocated fees from the last time this method was called.\n        _sync(l1Token); // Fetch any balance changes due to token bridging finalization and factor them in.\n\n        // ExchangeRate := (liquidReserves + utilizedReserves - undistributedLpFees) / lpTokenSupply\n        // Both utilizedReserves and undistributedLpFees contain assigned LP fees. UndistributedLpFees is gradually\n        // decreased over the smear duration using _updateAccumulatedLpFees. This means that the exchange rate will\n        // gradually increase over time as undistributedLpFees goes to zero.\n        // utilizedReserves can be negative. If this is the case, then liquidReserves is offset by an equal\n        // and opposite size. LiquidReserves + utilizedReserves will always be larger than undistributedLpFees so this\n        // int will always be positive so there is no risk in underflow in type casting in the return line.\n        int256 numerator = int256(pooledToken.liquidReserves) +\n            pooledToken.utilizedReserves -\n            int256(pooledToken.undistributedLpFees);\n        return (uint256(numerator) * 1e18) / lpTokenTotalSupply;\n    }\n\n    // Update internal fee counters by adding in any accumulated fees from the last time this logic was called.\n    function _updateAccumulatedLpFees(PooledToken storage pooledToken) internal {\n        uint256 accumulatedFees = _getAccumulatedFees(pooledToken.undistributedLpFees, pooledToken.lastLpFeeUpdate);\n        pooledToken.undistributedLpFees -= accumulatedFees;\n        pooledToken.lastLpFeeUpdate = uint32(getCurrentTime());\n    }\n\n    // Calculate the unallocated accumulatedFees from the last time the contract was called.\n    function _getAccumulatedFees(uint256 undistributedLpFees, uint256 lastLpFeeUpdate) internal view returns (uint256) {\n        // accumulatedFees := min(undistributedLpFees * lpFeeRatePerSecond * timeFromLastInteraction, undistributedLpFees)\n        // The min acts to pay out all fees in the case the equation returns more than the remaining fees.\n        uint256 timeFromLastInteraction = getCurrentTime() - lastLpFeeUpdate;\n        uint256 maxUndistributedLpFees = (undistributedLpFees * lpFeeRatePerSecond * timeFromLastInteraction) / (1e18);\n        return maxUndistributedLpFees < undistributedLpFees ? maxUndistributedLpFees : undistributedLpFees;\n    }\n\n    function _sync(address l1Token) internal {\n        // Check if the l1Token balance of the contract is greater than the liquidReserves. If it is then the bridging\n        // action from L2 -> L1 has concluded and the local accounting can be updated.\n        // Note: this calculation must take into account the bond when it's acting on the bond token and there's an\n        // active request.\n        uint256 balance = IERC20(l1Token).balanceOf(address(this));\n        uint256 balanceSansBond = l1Token == address(bondToken) && _activeRequest() ? balance - bondAmount : balance;\n        if (balanceSansBond > pooledTokens[l1Token].liquidReserves) {\n            // Note the numerical operation below can send utilizedReserves to negative. This can occur when tokens are\n            // dropped onto the contract, exceeding the liquidReserves.\n            pooledTokens[l1Token].utilizedReserves -= int256(balanceSansBond - pooledTokens[l1Token].liquidReserves);\n            pooledTokens[l1Token].liquidReserves = balanceSansBond;\n        }\n    }\n\n    function _liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) internal returns (uint256) {\n        _sync(l1Token); // Fetch any balance changes due to token bridging finalization and factor them in.\n\n        // liquidityUtilizationRatio := (relayedAmount + max(utilizedReserves,0)) / (liquidReserves + max(utilizedReserves,0))\n        // UtilizedReserves has a dual meaning: if it's greater than zero then it represents funds pending in the bridge\n        // that will flow from L2 to L1. In this case, we can use it normally in the equation. However, if it is\n        // negative, then it is already counted in liquidReserves. This occurs if tokens are transferred directly to the\n        // contract. In this case, ignore it as it is captured in liquid reserves and has no meaning in the numerator.\n        PooledToken memory pooledL1Token = pooledTokens[l1Token];\n        uint256 flooredUtilizedReserves = pooledL1Token.utilizedReserves > 0\n            ? uint256(pooledL1Token.utilizedReserves) // If positive: take the uint256 cast utilizedReserves.\n            : 0; // Else, if negative, it is already captured in liquidReserves and should be ignored.\n        uint256 numerator = relayedAmount + flooredUtilizedReserves;\n        uint256 denominator = pooledL1Token.liquidReserves + flooredUtilizedReserves;\n\n        // If the denominator equals zero, return 1e18 (max utilization).\n        if (denominator == 0) return 1e18;\n\n        // In all other cases, return the utilization ratio.\n        return (numerator * 1e18) / denominator;\n    }\n\n    function _allocateLpAndProtocolFees(address l1Token, uint256 bundleLpFees) internal {\n        // Calculate the fraction of bundledLpFees that are allocated to the protocol and to the LPs.\n        uint256 protocolFeesCaptured = (bundleLpFees * protocolFeeCapturePct) / 1e18;\n        uint256 lpFeesCaptured = bundleLpFees - protocolFeesCaptured;\n\n        // Assign any LP fees included into the bundle to the pooled token. These LP fees are tracked in the\n        // undistributedLpFees and within the utilizedReserves. undistributedLpFees is gradually decreased\n        // over the smear duration to give the LPs their rewards over a period of time. Adding to utilizedReserves\n        // acts to track these rewards after the smear duration. See _exchangeRateCurrent for more details.\n        if (lpFeesCaptured > 0) {\n            pooledTokens[l1Token].undistributedLpFees += lpFeesCaptured;\n            pooledTokens[l1Token].utilizedReserves += int256(lpFeesCaptured);\n        }\n\n        // If there are any protocol fees, allocate them to the unclaimed protocol tracker amount.\n        if (protocolFeesCaptured > 0) unclaimedAccumulatedProtocolFees[l1Token] += protocolFeesCaptured;\n    }\n\n    function _relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) internal {\n        (address adapter, address spokePool) = _getInitializedCrossChainContracts(chainId);\n\n        // Perform delegatecall to use the adapter's code with this contract's context.\n\n        // We are ok with this low-level call since the adapter address is set by the admin and we've\n        // already checked that its not the zero address.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = adapter.delegatecall(\n            abi.encodeWithSignature(\n                \"relayMessage(address,bytes)\",\n                spokePool, // target. This should be the spokePool on the L2.\n                functionData\n            )\n        );\n        require(success, \"delegatecall failed\");\n        emit SpokePoolAdminFunctionTriggered(chainId, functionData);\n    }\n\n    function _poolRebalanceRouteKey(address l1Token, uint256 destinationChainId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(l1Token, destinationChainId));\n    }\n\n    function _getInitializedCrossChainContracts(uint256 chainId)\n        internal\n        view\n        returns (address adapter, address spokePool)\n    {\n        adapter = crossChainContracts[chainId].adapter;\n        spokePool = crossChainContracts[chainId].spokePool;\n        require(spokePool != address(0), \"SpokePool not initialized\");\n        require(adapter.isContract(), \"Adapter not initialized\");\n    }\n\n    function _activeRequest() internal view returns (bool) {\n        return rootBundleProposal.unclaimedPoolRebalanceLeafCount != 0;\n    }\n\n    // If functionCallStackOriginatesFromOutsideThisContract is true then this was called by the callback function\n    // by dropping ETH onto the contract. In this case, deposit the ETH into WETH. This would happen if ETH was sent\n    // over the optimism bridge, for example. If false then this was set as a result of unwinding LP tokens, with the\n    // intention of sending ETH to the LP. In this case, do nothing as we intend on sending the ETH to the LP.\n    function _depositEthToWeth() internal {\n        if (functionCallStackOriginatesFromOutsideThisContract()) weth.deposit{ value: msg.value }();\n    }\n\n    // Added to enable the HubPool to receive ETH. This will occur both when the HubPool unwraps WETH to send to LPs and\n    // when ETH is sent over the canonical Optimism bridge, which sends ETH.\n    fallback() external payable {\n        _depositEthToWeth();\n    }\n\n    receive() external payable {\n        _depositEthToWeth();\n    }\n}\n"
    }
}