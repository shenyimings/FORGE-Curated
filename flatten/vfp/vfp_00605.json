{
    "vfp_id": "vfp_00605",
    "project_name": "Lido V3 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Use a modifier Instead of a require/if Statement",
            "description": "The `PredepositGuarantee` contract uses inline `if` statements with `msg.sender` comparisons for access control instead of reusable modifiers. This leads to duplicated logic, inconsistent revert messages, and reduced auditability. The root cause is inconsistent coding patterns despite the existence of a `onlyGuarantorOf` modifier. While not directly exploitable, this increases the risk of future access control bugs due to copy-paste errors. The impact is reduced code clarity and maintainability, increasing the likelihood of introducing vulnerabilities during future development.\n",
            "severity": null,
            "location": [
                "contracts/0.8.25/vaults/predeposit_guarantee/PredepositGuarantee.sol:L361",
                "contracts/0.8.25/vaults/predeposit_guarantee/PredepositGuarantee.sol:L442-L443",
                "contracts/0.8.25/vaults/predeposit_guarantee/PredepositGuarantee.sol:L502",
                "contracts/0.8.25/vaults/predeposit_guarantee/PredepositGuarantee.sol:L568"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/predeposit_guarantee/PredepositGuarantee.sol"
            ]
        }
    ],
    "affected_files": {
        "PredepositGuarantee.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {GIndex} from \"contracts/common/lib/GIndex.sol\";\nimport {SSZ} from \"contracts/common/lib/SSZ.sol\";\nimport {BLS12_381} from \"contracts/common/lib/BLS.sol\";\nimport {PausableUntilWithRoles} from \"contracts/0.8.25/utils/PausableUntilWithRoles.sol\";\n\nimport {CLProofVerifier} from \"./CLProofVerifier.sol\";\nimport {MeIfNobodyElse} from \"./MeIfNobodyElse.sol\";\n\nimport {IStakingVault} from \"../interfaces/IStakingVault.sol\";\nimport {IPredepositGuarantee} from \"../interfaces/IPredepositGuarantee.sol\";\n\n/**\n * @title PredepositGuarantee\n * @author Lido\n * @notice This contract acts as permissionless deposit security layer for all compatible staking vaults.\n *         It allows Node Operators(NO) to provide ether to back up their validators' deposits.\n *         While only Staking Vault ether is used to deposit to the beacon chain, NO's ether is locked.\n *         And can only be unlocked if the validator is proven to have valid Withdrawal Credentials on Ethereum Consensus Layer.\n *         Merkle proofs against Beacon Block Root are used to prove either validator's validity or invalidity\n *         where invalid validators' ether can be compensated back to the staking vault owner.\n *         A system of NO's guarantors can be used to allow NOs to handle deposits and verifications\n *         while guarantors provide ether.\n *\n *     !NB:\n *         There is a mutual trust assumption between NO's and guarantors.\n *         Internal guards for NO<->Guarantor are used only to prevent mistakes and provide operational recovery paths.\n *         But can not be used to fully prevent misbehavior in this relationship where NO's can access guarantor provided ether.\n *\n *     !NB:\n *         There is a mutual trust assumption between NO's and the assigned depositor.\n *\n *     !NB:\n *         PDG is permissionless by design. Anyone can be an NO, provided there is a compatible staking vault\n *         that has `nodeOperator()` as NO and allows PDG to perform `depositToBeaconChain()` on it.\n *\n *          - Lido's VaultHub requires all connected vaults to use PDG to ensure security of the deposited ether\n *          - PDG can be used outside of Lido\n */\ncontract PredepositGuarantee is IPredepositGuarantee, CLProofVerifier, PausableUntilWithRoles {\n    using MeIfNobodyElse for mapping(address => address);\n\n    /**\n     * @notice represents validator stages in PDG flow\n     * @param NONE - initial stage\n     * @param PREDEPOSITED - PREDEPOSIT_AMOUNT is deposited with this validator by the vault\n     * @param PROVEN - validator is proven to be valid and can be used to deposit to beacon chain\n     * @param DISPROVEN - validator is proven to have wrong WC and its PREDEPOSIT_AMOUNT can be compensated to staking vault owner\n     * @param COMPENSATED - disproven validator has its PREDEPOSIT_AMOUNT ether compensated to staking vault owner and validator cannot be used in PDG anymore\n     */\n    enum ValidatorStage {\n        NONE,\n        PREDEPOSITED,\n        PROVEN,\n        DISPROVEN,\n        COMPENSATED\n    }\n\n    /**\n     * @notice represents NO balance in PDG\n     * @dev fits into single 32 bytes slot\n     * @param total total ether balance of the NO\n     * @param locked ether locked in not yet proven predeposits\n     */\n    struct NodeOperatorBalance {\n        uint128 total;\n        uint128 locked;\n    }\n    /**\n     * @notice represents status of the validator in PDG\n     * @dev is used to track validator from predeposit -> prove -> deposit\n     * @param stage represents validator stage in PDG flow\n     * @param stakingVault pins validator to specific StakingVault\n     * @param nodeOperator pins validator to specific NO\n     */\n    struct ValidatorStatus {\n        ValidatorStage stage;\n        IStakingVault stakingVault;\n        address nodeOperator;\n    }\n\n    /**\n     * @notice ERC-7201 storage struct\n     * @dev ERC-7201 namespace is used to prevent upgrade collisions\n     * @custom:storage-location erc7201:Lido.Vaults.PredepositGuarantee\n     * @param nodeOperatorBalance - balance of NO in PDG\n     * @param nodeOperatorGuarantor - mapping of NO to its' guarantor (zero address means NO is self-guarantor)\n     * @param guarantorClaimableEther - ether that guarantor can claim back if NO has changed guarantor with balance\n     * @param validatorStatus - status of the validators in PDG\n     */\n    struct ERC7201Storage {\n        mapping(address nodeOperator => NodeOperatorBalance balance) nodeOperatorBalance;\n        mapping(address nodeOperator => address guarantor) nodeOperatorGuarantor;\n        mapping(address guarantor => uint256 claimableEther) guarantorClaimableEther;\n        mapping(bytes validatorPubkey => ValidatorStatus validatorStatus) validatorStatus;\n        mapping(address nodeOperator => address depositor) nodeOperatorDepositor;\n    }\n\n    uint8 public constant MIN_SUPPORTED_WC_VERSION = 0x01;\n    uint8 public constant MAX_SUPPORTED_WC_VERSION = 0x02;\n\n    /// @notice amount of ether that is predeposited with each validator\n    uint128 public constant PREDEPOSIT_AMOUNT = 1 ether;\n\n    /**\n     * @notice computed DEPOSIT_DOMAIN for current chain\n     * @dev changes between chains and testnets depending on GENESIS_FORK_VERSION\n     * @dev per https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    bytes32 public immutable DEPOSIT_DOMAIN;\n\n    /**\n     * @notice Storage offset slot for ERC-7201 namespace\n     *         The storage namespace is used to prevent upgrade collisions\n     *         keccak256(abi.encode(uint256(keccak256(\"Lido.Vaults.PredepositGuarantee\")) - 1)) & ~bytes32(uint256(0xff))\n     */\n    bytes32 private constant ERC7201_STORAGE_LOCATION =\n        0xf66b5a365356c5798cc70e3ea6a236b181a826a69f730fc07cc548244bee5200;\n\n    /**\n     * @param _genesisForkVersion genesis fork version for the current chain\n     * @param _gIFirstValidator packed(general index + depth in tree, see GIndex.sol) GIndex of first validator in CL state tree\n     * @param _gIFirstValidatorAfterChange packed GIndex of first validator after fork changes tree structure\n     * @param _changeSlot slot of the fork that alters first validator GIndex\n     * @dev if no fork changes are known,  _gIFirstValidatorAfterChange = _gIFirstValidator and _changeSlot = 0\n     */\n    constructor(\n        bytes4 _genesisForkVersion,\n        GIndex _gIFirstValidator,\n        GIndex _gIFirstValidatorAfterChange,\n        uint64 _changeSlot\n    ) CLProofVerifier(_gIFirstValidator, _gIFirstValidatorAfterChange, _changeSlot) {\n        DEPOSIT_DOMAIN = BLS12_381.computeDepositDomain(_genesisForkVersion);\n        _disableInitializers();\n        _pauseUntil(PAUSE_INFINITELY);\n    }\n\n    function initialize(address _defaultAdmin) external initializer {\n        if (_defaultAdmin == address(0)) revert ZeroArgument(\"_defaultAdmin\");\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n    }\n\n    // * * * * * * * * * * * * * * * * * * * * * //\n    // * * * Node Operator Accounting Logic* * * //\n    // * * * * * * * * * * * * * * * * * * * * * //\n\n    /**\n     * @notice returns total & locked balances for the NO\n     * @param _nodeOperator to withdraw from\n     * @return balance object of the node operator\n     */\n    function nodeOperatorBalance(address _nodeOperator) external view returns (NodeOperatorBalance memory) {\n        return _getStorage().nodeOperatorBalance[_nodeOperator];\n    }\n\n    /**\n     * @notice returns the amount of ether that NO can lock for predeposit or withdraw\n     * @param _nodeOperator to check unlocked balance for\n     * @return unlocked amount\n     */\n    function unlockedBalance(address _nodeOperator) external view returns (uint256 unlocked) {\n        NodeOperatorBalance storage balance = _getStorage().nodeOperatorBalance[_nodeOperator];\n        unlocked = balance.total - balance.locked;\n    }\n\n    /**\n     * @notice returns address of the guarantor for the NO\n     * @param _nodeOperator to check guarantor for\n     * @return address of guarantor for the NO\n     * @dev will return _nodeOperator if NO has no external guarantor\n     */\n    function nodeOperatorGuarantor(address _nodeOperator) external view returns (address) {\n        return _guarantorOf(_nodeOperator);\n    }\n\n    /**\n     * @notice returns address of the depositor for the NO\n     * @param _nodeOperator to check depositor for\n     * @return address of depositor for the NO\n     */\n    function nodeOperatorDepositor(address _nodeOperator) external view returns (address) {\n        return _depositorOf(_nodeOperator);\n    }\n\n    /**\n     * @notice returns amount of ether refund that guarantor can claim\n     * @param _guarantor address of the guarantor\n     * @return amount of ether that guarantor can claim by calling `claimGuarantorRefund(amount)`\n     */\n    function claimableRefund(address _guarantor) external view returns (uint256) {\n        return _getStorage().guarantorClaimableEther[_guarantor];\n    }\n\n    /**\n     * @notice returns PDG status of the validator by pubkey\n     * @param _validatorPubkey to check status for\n     * @return struct of ValidatorStatus\n     */\n    function validatorStatus(bytes calldata _validatorPubkey) external view returns (ValidatorStatus memory) {\n        return _getStorage().validatorStatus[_validatorPubkey];\n    }\n\n    /**\n     * @notice tops up NO's balance with ether provided by a guarantor\n     * @param _nodeOperator address\n     */\n    function topUpNodeOperatorBalance(address _nodeOperator) external payable whenResumed {\n        _topUpNodeOperatorBalance(_nodeOperator);\n    }\n\n    /**\n     * @notice validates proof of validator in CL with withdrawalCredentials and pubkey against Beacon block root\n     * @param _witness object containing validator pubkey, Merkle proof and timestamp for Beacon Block root child block\n     * @param _withdrawalCredentials to verify proof with\n     * @dev reverts with `InvalidProof` when provided input cannot be proven to Beacon block root\n     */\n    function validatePubKeyWCProof(ValidatorWitness calldata _witness, bytes32 _withdrawalCredentials) public view {\n        _validatePubKeyWCProof(_witness, _withdrawalCredentials);\n    }\n\n    /**\n     * @notice verifies the deposit message signature using BLS12-381 pairing check\n     * @param _deposit staking vault deposit to verify\n     * @param _depositsY Y coordinates of the two BLS12-381 points (uncompressed pubkey and signature)\n     * @param _withdrawalCredentials withdrawal credentials of the deposit message to verify\n     * @dev reverts with `InvalidSignature` if the signature is invalid\n     * @dev reverts with `InputHasInfinityPoints` if the input contains infinity points(zero values)\n     */\n    function verifyDepositMessage(\n        IStakingVault.Deposit calldata _deposit,\n        BLS12_381.DepositY calldata _depositsY,\n        bytes32 _withdrawalCredentials\n    ) public view {\n        BLS12_381.verifyDepositMessage(_deposit.pubkey, _deposit.signature, _deposit.amount, _depositsY, _withdrawalCredentials, DEPOSIT_DOMAIN);\n    }\n\n    /**\n     * @notice withdraws unlocked NO's balance\n     * @param _nodeOperator to withdraw from\n     * @param _amount amount to withdraw\n     * @param _recipient address to send the funds to\n     * @dev only guarantor can withdraw\n     */\n    function withdrawNodeOperatorBalance(\n        address _nodeOperator,\n        uint256 _amount,\n        address _recipient\n    ) external onlyGuarantorOf(_nodeOperator) whenResumed {\n        // _nodeOperator != address(0) is enforced by onlyGuarantorOf()\n        if (_amount == 0) revert ZeroArgument(\"_amount\");\n        if (_recipient == address(0)) revert ZeroArgument(\"_recipient\");\n        if (_amount % PREDEPOSIT_AMOUNT != 0) revert ValueNotMultipleOfPredepositAmount(_amount);\n\n        NodeOperatorBalance storage balance = _getStorage().nodeOperatorBalance[_nodeOperator];\n\n        uint256 unlocked = balance.total - balance.locked;\n\n        if (unlocked < _amount) revert NotEnoughUnlocked(unlocked, _amount);\n\n        balance.total -= uint128(_amount);\n        (bool success, ) = _recipient.call{value: _amount}(\"\");\n        if (!success) revert WithdrawalFailed();\n\n        emit BalanceWithdrawn(_nodeOperator, _recipient, _amount);\n    }\n\n    /**\n     * @notice changes guarantor for the NO and provides refund to guarantor if NO has balance\n     * @param _newGuarantor address of the new guarantor\n     * @dev reverts if a NO has non-zero locked balance\n     * @dev refunded ether can be claimed by previous guarantor with `claimGuarantorRefund()`\n     */\n    function setNodeOperatorGuarantor(address _newGuarantor) external whenResumed {\n        ERC7201Storage storage $ = _getStorage();\n        NodeOperatorBalance storage balance = $.nodeOperatorBalance[msg.sender];\n\n        address prevGuarantor = _guarantorOf(msg.sender);\n\n        if (_newGuarantor == address(0)) revert ZeroArgument(\"_newGuarantor\");\n\n        if (prevGuarantor == _newGuarantor) revert SameGuarantor();\n\n        if (balance.locked != 0) revert LockedIsNotZero(balance.locked);\n\n        if (balance.total > 0) {\n            uint256 refund = balance.total;\n            balance.total = 0;\n\n            $.guarantorClaimableEther[prevGuarantor] += refund;\n\n            emit BalanceRefunded(msg.sender, _newGuarantor);\n            emit GuarantorRefundAdded(prevGuarantor, msg.sender, refund);\n        }\n\n        $.nodeOperatorGuarantor.setOrReset(msg.sender, _newGuarantor);\n\n        emit GuarantorSet(msg.sender, _newGuarantor, prevGuarantor);\n    }\n\n    /**\n     * @notice sets the depositor for the NO\n     * @param _newDepositor address of the depositor\n     */\n    function setNodeOperatorDepositor(address _newDepositor) external {\n        if (_newDepositor == address(0)) revert ZeroArgument(\"_newDepositor\");\n        address prevDepositor = _depositorOf(msg.sender);\n        if (_newDepositor == prevDepositor) revert SameDepositor();\n\n        _getStorage().nodeOperatorDepositor.setOrReset(msg.sender, _newDepositor);\n\n        emit DepositorSet(msg.sender, _newDepositor, prevDepositor);\n    }\n\n    /**\n     * @notice claims refund for the previous guarantor of the NO\n     * @param _recipient address to send the refund to\n     * @return claimedEther amount of refund\n     */\n    function claimGuarantorRefund(address _recipient) external whenResumed returns (uint256 claimedEther) {\n        ERC7201Storage storage $ = _getStorage();\n\n        claimedEther = $.guarantorClaimableEther[msg.sender];\n\n        if (claimedEther == 0) revert NothingToRefund();\n\n        $.guarantorClaimableEther[msg.sender] = 0;\n\n        (bool success, ) = _recipient.call{value: claimedEther}(\"\");\n\n        if (!success) revert RefundFailed();\n\n        emit GuarantorRefundClaimed(msg.sender, _recipient, claimedEther);\n    }\n\n    // * * * * * * * * * * * * * * * * * * * * //\n    // * * * * * Deposit Operations  * * * * * //\n    // * * * * * * * * * * * * * * * * * * * * //\n\n    /**\n     * @notice deposits NO's validators with PREDEPOSIT_AMOUNT ether from StakingVault and locks up NO's balance\n     * @dev optionally accepts multiples of`PREDEPOSIT_AMOUNT` in `msg.value` to top up NO balance if NO is self-guarantor\n     * @param _stakingVault to deposit validators to\n     * @param _deposits StakingVault deposit struct that has amount as PREDEPOSIT_AMOUNT\n     */\n    function predeposit(\n        IStakingVault _stakingVault,\n        IStakingVault.Deposit[] calldata _deposits,\n        BLS12_381.DepositY[] calldata _depositsY\n    ) external payable whenResumed {\n        if (_deposits.length == 0) revert EmptyDeposits();\n\n        address nodeOperator = _stakingVault.nodeOperator();\n        if (msg.sender != _depositorOf(nodeOperator)) revert NotDepositor();\n\n        if (msg.value != 0) {\n            // check that node operator is self-guarantor is inside\n            _topUpNodeOperatorBalance(nodeOperator);\n        }\n\n        bytes32 withdrawalCredentials = _stakingVault.withdrawalCredentials();\n\n        // sanity check that vault returns valid WC\n        _validateWC(_stakingVault, withdrawalCredentials);\n\n        ERC7201Storage storage $ = _getStorage();\n        NodeOperatorBalance storage balance = $.nodeOperatorBalance[nodeOperator];\n\n        uint128 totalDepositAmount = PREDEPOSIT_AMOUNT * uint128(_deposits.length);\n        uint128 unlocked = balance.total - balance.locked;\n\n        if (unlocked < totalDepositAmount) revert NotEnoughUnlocked(unlocked, totalDepositAmount);\n\n        for (uint256 i = 0; i < _deposits.length; i++) {\n            IStakingVault.Deposit calldata _deposit = _deposits[i];\n\n            // this check isn't needed in  `depositToBeaconChain` because\n            // Beacon Chain doesn't enforce the signature checks for existing validators and just top-ups to their balance\n            verifyDepositMessage(_deposit, _depositsY[i], withdrawalCredentials);\n\n            if ($.validatorStatus[_deposit.pubkey].stage != ValidatorStage.NONE) {\n                revert ValidatorNotNew(_deposit.pubkey, $.validatorStatus[_deposit.pubkey].stage);\n            }\n\n            if (_deposit.amount != PREDEPOSIT_AMOUNT) revert PredepositAmountInvalid(_deposit.pubkey, _deposit.amount);\n\n            $.validatorStatus[_deposit.pubkey] = ValidatorStatus({\n                stage: ValidatorStage.PREDEPOSITED,\n                stakingVault: _stakingVault,\n                nodeOperator: nodeOperator\n            });\n\n            emit ValidatorPreDeposited(_deposit.pubkey, nodeOperator, address(_stakingVault), withdrawalCredentials);\n        }\n\n        balance.locked += totalDepositAmount;\n        _stakingVault.depositToBeaconChain(_deposits);\n\n        emit BalanceLocked(nodeOperator, balance.total, balance.locked);\n    }\n\n    // * * * * * Positive Proof Flow  * * * * * //\n\n    /**\n     * @notice permissionless method to prove correct Withdrawal Credentials for the validator on CL\n     * @param _witness object containing validator pubkey, Merkle proof and timestamp for Beacon Block root child block\n     * @dev will revert if proof is invalid or misformed or validator is not predeposited\n     */\n    function proveValidatorWC(ValidatorWitness calldata _witness) public whenResumed {\n        ValidatorStatus storage validator = _getStorage().validatorStatus[_witness.pubkey];\n\n        // checking stage here prevents revert on call to zero address at `.stakingVault.withdrawalCredentials()`\n        if (validator.stage != ValidatorStage.PREDEPOSITED) {\n            revert ValidatorNotPreDeposited(_witness.pubkey, validator.stage);\n        }\n\n        // WC will be sanity checked in `_processPositiveProof()`\n        bytes32 withdrawalCredentials = validator.stakingVault.withdrawalCredentials();\n\n        validatePubKeyWCProof(_witness, withdrawalCredentials);\n\n        _processPositiveProof(_witness.pubkey, validator, withdrawalCredentials);\n    }\n\n    /**\n     * @notice deposits ether to proven validators from staking vault\n     * @param _stakingVault address\n     * @param _deposits array of StakingVault.Deposit structs\n     * @dev only callable by Node Operator of this staking vault\n     */\n    function depositToBeaconChain(\n        IStakingVault _stakingVault,\n        IStakingVault.Deposit[] calldata _deposits\n    ) public payable whenResumed {\n        if (msg.sender != _depositorOf(_stakingVault.nodeOperator())) {\n            revert NotDepositor();\n        }\n        ERC7201Storage storage $ = _getStorage();\n\n        for (uint256 i = 0; i < _deposits.length; i++) {\n            IStakingVault.Deposit calldata _deposit = _deposits[i];\n\n            ValidatorStatus storage validator = $.validatorStatus[_deposit.pubkey];\n\n            if (validator.stage != ValidatorStage.PROVEN) {\n                revert DepositToUnprovenValidator(_deposit.pubkey, $.validatorStatus[_deposit.pubkey].stage);\n            }\n\n            // sanity check because first check relies on external contract\n            if (_depositorOf(validator.nodeOperator) != msg.sender) {\n                revert NotDepositor();\n            }\n\n            if (validator.stakingVault != _stakingVault) {\n                revert DepositToWrongVault(_deposit.pubkey, address(_stakingVault));\n            }\n        }\n\n        _stakingVault.depositToBeaconChain(_deposits);\n    }\n\n    /**\n     * @notice happy path shortcut for the node operator that allows:\n     * - prove validators to unlock NO balance\n     * - optionally top up NO balance\n     * - trigger deposit to proven validators via vault\n     * @param _witnesses array of ValidatorWitness structs to prove validators WCs\n     * @param _deposits array of StakingVault.Deposit structs with deposit data for provided _stakingVault\n     * @param _stakingVault address\n     * @param _deposits array of StakingVault.Deposit structs\n     * @dev proven validators and  staking vault + deposited validators don't have to match\n     */\n    function proveAndDeposit(\n        ValidatorWitness[] calldata _witnesses,\n        IStakingVault.Deposit[] calldata _deposits,\n        IStakingVault _stakingVault\n    ) external payable {\n        for (uint256 i = 0; i < _witnesses.length; i++) {\n            proveValidatorWC(_witnesses[i]);\n        }\n\n        depositToBeaconChain(_stakingVault, _deposits);\n    }\n\n    /**\n     * @notice shortcut if validator already has valid WC setup\n     * @param _witness  ValidatorWitness struct proving validator WC belong to staking vault\n     * @param _stakingVault address\n     * @dev only callable by staking vault owner & only if validator stage is NONE\n     */\n    function proveUnknownValidator(\n        ValidatorWitness calldata _witness,\n        IStakingVault _stakingVault\n    ) external whenResumed {\n        if (_stakingVault.owner() != msg.sender) revert NotStakingVaultOwner();\n\n        ERC7201Storage storage $ = _getStorage();\n\n        if ($.validatorStatus[_witness.pubkey].stage != ValidatorStage.NONE) {\n            revert ValidatorNotNew(_witness.pubkey, $.validatorStatus[_witness.pubkey].stage);\n        }\n\n        bytes32 withdrawalCredentials = _stakingVault.withdrawalCredentials();\n\n        // sanity check that vault returns valid WC\n        _validateWC(_stakingVault, withdrawalCredentials);\n\n        validatePubKeyWCProof(_witness, withdrawalCredentials);\n\n        $.validatorStatus[_witness.pubkey] = ValidatorStatus({\n            stage: ValidatorStage.PROVEN,\n            stakingVault: _stakingVault,\n            nodeOperator: _stakingVault.nodeOperator()\n        });\n\n        emit ValidatorProven(\n            _witness.pubkey,\n            $.validatorStatus[_witness.pubkey].nodeOperator,\n            address(_stakingVault),\n            withdrawalCredentials\n        );\n    }\n\n    // * * * * * Negative Proof Flow  * * * * * //\n\n    /**\n     * @notice permissionless method to prove incorrect Withdrawal Credentials for the validator on CL\n     * @param _witness object containing validator pubkey, Merkle proof and timestamp for Beacon Block root child block\n     * @param _invalidWithdrawalCredentials with which validator was deposited before PDG's predeposit\n     * @dev will revert if proof is invalid, validator is not predeposited or withdrawal credentials belong to correct vault\n     * @dev validator WC versions mismatch (e.g 0x01 vs 0x02) will be treated as invalid WC\n     */\n    function proveInvalidValidatorWC(\n        ValidatorWitness calldata _witness,\n        bytes32 _invalidWithdrawalCredentials\n    ) public whenResumed {\n        validatePubKeyWCProof(_witness, _invalidWithdrawalCredentials);\n\n        // validator state and WC incorrectness are enforced inside\n        _processNegativeProof(_witness.pubkey, _invalidWithdrawalCredentials);\n    }\n\n    /**\n     * @notice returns locked ether to the staking vault owner if validator's WC were proven invalid\n     * @param _validatorPubkey to take locked PREDEPOSIT_AMOUNT ether from\n     * @param _recipient address to transfer PREDEPOSIT_AMOUNT ether to\n     * @dev can only be called by owner of vault that had deposited to disproven validator\n     */\n    function compensateDisprovenPredeposit(\n        bytes calldata _validatorPubkey,\n        address _recipient\n    ) public whenResumed returns (uint256) {\n        ValidatorStatus storage validator = _getStorage().validatorStatus[_validatorPubkey];\n\n        IStakingVault stakingVault = validator.stakingVault;\n        address nodeOperator = validator.nodeOperator;\n\n        if (_recipient == address(0)) revert ZeroArgument(\"_recipient\");\n        if (_recipient == address(stakingVault)) revert CompensateToVaultNotAllowed();\n        if (validator.stage != ValidatorStage.DISPROVEN) revert ValidatorNotDisproven(validator.stage);\n        if (msg.sender != stakingVault.owner()) revert NotStakingVaultOwner();\n\n        validator.stage = ValidatorStage.COMPENSATED;\n\n        // reduces total&locked NO balance\n        NodeOperatorBalance storage balance = _getStorage().nodeOperatorBalance[nodeOperator];\n        balance.total -= PREDEPOSIT_AMOUNT;\n        balance.locked -= PREDEPOSIT_AMOUNT;\n\n        (bool success, ) = _recipient.call{value: PREDEPOSIT_AMOUNT}(\"\");\n        if (!success) revert CompensateFailed();\n\n        emit BalanceCompensated(nodeOperator, _recipient, balance.total, balance.locked);\n        emit ValidatorCompensated(_validatorPubkey, nodeOperator, address(stakingVault), _recipient);\n        return PREDEPOSIT_AMOUNT;\n    }\n\n    // * * * * * * * * * * * * * * * * * * * * //\n    // * * * * * Internal Functions * * * * *  //\n    // * * * * * * * * * * * * * * * * * * * * //\n\n    function _processPositiveProof(\n        bytes calldata _pubkey,\n        ValidatorStatus storage validator,\n        bytes32 _withdrawalCredentials\n    ) internal {\n        // sanity check that vault returns valid WC\n        _validateWC(validator.stakingVault, _withdrawalCredentials);\n\n        validator.stage = ValidatorStage.PROVEN;\n        NodeOperatorBalance storage balance = _getStorage().nodeOperatorBalance[validator.nodeOperator];\n        balance.locked -= PREDEPOSIT_AMOUNT;\n\n        emit BalanceUnlocked(validator.nodeOperator, balance.total, balance.locked);\n        emit ValidatorProven(_pubkey, validator.nodeOperator, address(validator.stakingVault), _withdrawalCredentials);\n    }\n\n    function _processNegativeProof(bytes calldata _pubkey, bytes32 _invalidWithdrawalCredentials) internal {\n        ERC7201Storage storage $ = _getStorage();\n        ValidatorStatus storage validator = $.validatorStatus[_pubkey];\n\n        if (validator.stage != ValidatorStage.PREDEPOSITED) {\n            revert ValidatorNotPreDeposited(_pubkey, validator.stage);\n        }\n\n        bytes32 vaultWithdrawalCredentials = validator.stakingVault.withdrawalCredentials();\n\n        // sanity check that vault returns valid WC\n        _validateWC(validator.stakingVault, vaultWithdrawalCredentials);\n\n        // this check prevents negative proving for legit deposits\n        if (_invalidWithdrawalCredentials == vaultWithdrawalCredentials) {\n            revert WithdrawalCredentialsMatch();\n        }\n\n        validator.stage = ValidatorStage.DISPROVEN;\n\n        emit ValidatorDisproven(\n            _pubkey,\n            validator.nodeOperator,\n            address(validator.stakingVault),\n            _invalidWithdrawalCredentials\n        );\n    }\n\n    function _topUpNodeOperatorBalance(address _nodeOperator) internal onlyGuarantorOf(_nodeOperator) {\n        uint128 amount = uint128(msg.value);\n\n        // _nodeOperator != address(0) is enforced by onlyGuarantorOf()\n        if (amount == 0) revert ZeroArgument(\"msg.value\");\n        if (amount % PREDEPOSIT_AMOUNT != 0) revert ValueNotMultipleOfPredepositAmount(amount);\n\n        _getStorage().nodeOperatorBalance[_nodeOperator].total += uint128(amount);\n\n        emit BalanceToppedUp(_nodeOperator, msg.sender, amount);\n    }\n\n    /// @notice returns guarantor of the NO\n    /// @dev if guarantor is not set, returns NO address\n    function _guarantorOf(address _nodeOperator) internal view returns (address) {\n        return _getStorage().nodeOperatorGuarantor.getValueOrKey(_nodeOperator);\n    }\n\n    /// @notice enforces that only NO's guarantor can call the function\n    modifier onlyGuarantorOf(address _nodeOperator) {\n        if (_guarantorOf(_nodeOperator) != msg.sender) {\n            revert NotGuarantor();\n        }\n        _;\n    }\n\n    /// @notice returns depositor of the NO\n    /// @dev if depositor is not set, returns NO address\n    function _depositorOf(address _nodeOperator) internal view returns (address) {\n        return _getStorage().nodeOperatorDepositor.getValueOrKey(_nodeOperator);\n    }\n\n    /// @notice validates that WC belong to the vault\n    function _validateWC(IStakingVault _stakingVault, bytes32 _withdrawalCredentials) internal pure {\n        uint8 version = uint8(_withdrawalCredentials[0]);\n        address wcAddress = address(uint160(uint256(_withdrawalCredentials)));\n\n        if (version < MIN_SUPPORTED_WC_VERSION || version > MAX_SUPPORTED_WC_VERSION) {\n            revert WithdrawalCredentialsInvalidVersion(version);\n        }\n\n        // extract zero bytes between version and address in WC\n        if (((_withdrawalCredentials << 8) >> 168) != bytes32(0))\n            revert WithdrawalCredentialsMisformed(_withdrawalCredentials);\n\n        if (address(_stakingVault) != wcAddress) {\n            revert WithdrawalCredentialsMismatch(address(_stakingVault), wcAddress);\n        }\n    }\n\n    function _getStorage() private pure returns (ERC7201Storage storage $) {\n        assembly {\n            $.slot := ERC7201_STORAGE_LOCATION\n        }\n    }\n\n    // * * * * * Events  * * * * * //\n\n    /// NO balance change events\n\n    event BalanceToppedUp(address indexed nodeOperator, address indexed sender, uint256 amount);\n    event BalanceWithdrawn(address indexed nodeOperator, address indexed recipient, uint256 amount);\n    event BalanceLocked(address indexed nodeOperator, uint128 total, uint128 locked);\n    event BalanceUnlocked(address indexed nodeOperator, uint128 total, uint128 locked);\n    event BalanceCompensated(address indexed nodeOperator, address indexed to, uint128 total, uint128 locked);\n    event BalanceRefunded(address indexed nodeOperator, address indexed to);\n\n    /// NO delegate events\n\n    event GuarantorSet(address indexed nodeOperator, address indexed newGuarantor, address indexed prevGuarantor);\n    event DepositorSet(address indexed nodeOperator, address indexed newDepositor, address indexed prevDepositor);\n\n    event GuarantorRefundAdded(address indexed guarantor, address indexed nodeOperator, uint256 amount);\n    event GuarantorRefundClaimed(address indexed guarantor, address indexed recipient, uint256 amount);\n\n    /// Validator lifecycle events\n\n    event ValidatorPreDeposited(\n        bytes indexed validatorPubkey,\n        address indexed nodeOperator,\n        address indexed stakingVault,\n        bytes32 withdrawalCredentials\n    );\n    event ValidatorProven(\n        bytes indexed validatorPubkey,\n        address indexed nodeOperator,\n        address indexed stakingVault,\n        bytes32 withdrawalCredentials\n    );\n    event ValidatorDisproven(\n        bytes indexed validatorPubkey,\n        address indexed nodeOperator,\n        address indexed stakingVault,\n        bytes32 invalidWithdrawalCredentials\n    );\n    event ValidatorCompensated(\n        bytes indexed validatorPubkey,\n        address indexed nodeOperator,\n        address indexed stakingVault,\n        address recipient\n    );\n\n    // * * * * * Errors  * * * * * //\n\n    // node operator accounting\n    error LockedIsNotZero(uint256 locked);\n    error ValueNotMultipleOfPredepositAmount(uint256 value);\n    error NothingToRefund();\n    error WithdrawalFailed();\n    error SameGuarantor();\n    error SameDepositor();\n    error RefundFailed();\n\n    // predeposit errors\n    error EmptyDeposits();\n    error PredepositAmountInvalid(bytes validatorPubkey, uint256 depositAmount);\n    error ValidatorNotNew(bytes validatorPubkey, ValidatorStage stage);\n    error NotEnoughUnlocked(uint256 unlocked, uint256 amount);\n    error WithdrawalCredentialsMismatch(address stakingVault, address withdrawalCredentialsAddress);\n\n    // depositing errors\n    error DepositToUnprovenValidator(bytes validatorPubkey, ValidatorStage stage);\n    error DepositToWrongVault(bytes validatorPubkey, address stakingVault);\n\n    // prove\n    error ValidatorNotPreDeposited(bytes validatorPubkey, ValidatorStage stage);\n    error WithdrawalCredentialsMatch();\n    error WithdrawalCredentialsMisformed(bytes32 withdrawalCredentials);\n    error WithdrawalCredentialsInvalidVersion(uint8 version);\n\n    // compensate\n    error ValidatorNotDisproven(ValidatorStage stage);\n    error CompensateFailed();\n    error CompensateToVaultNotAllowed();\n\n    // auth\n    error NotStakingVaultOwner();\n    error NotGuarantor();\n    error NotDepositor();\n\n    // general\n    error ZeroArgument(string argument);\n}\n"
    }
}