{
    "vfp_id": "vfp_00118",
    "project_name": "cantina_byzantine_sep2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Anyone can overwrite factory mapping",
            "description": "The CompoundV3AdapterFactory stores deployed adapter addresses in a mapping keyed only by parentVault and comet, excluding the cometRewards parameter. This allows any user to deploy a new adapter with the same parentVault and comet but a different cometRewards address, overwriting the existing mapping entry. The root cause is the insufficient key structure in the mapping, which fails to account for all configuration parameters. An attacker could exploit this by deploying a malicious adapter with altered reward logic, causing downstream systems relying on the mapping to interact with the wrong or malicious contract. While the contract is not directly used by other audited contracts, external integrators may be misled, potentially leading to fund loss. Due to the uncertain scope of impact, it is classified as medium risk despite high exploit likelihood.\n",
            "severity": "Medium",
            "location": [
                "CompoundV3AdapterFactory.sol#L23"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3AdapterFactory.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Inconsistent skim protection between adapters",
            "description": "The CompoundV3Adapter's skim() function lacks validation to prevent the withdrawal of underlying protocol tokens (cTokens), unlike the secure implementation in ERC4626MerklAdapter. The root cause is the absence of a safeguard that checks whether the token being skimmed is the underlying asset of the vault. A malicious or compromised skimRecipient could call skim() with the cToken address, draining the adapter's entire asset balance and potentially causing the parent vault to become insolvent. This creates a critical financial risk, though the likelihood is reduced due to the protected role of skimRecipient. The impact is high due to potential insolvency, but the overall severity is medium due to lower exploit likelihood.\n",
            "severity": "Medium",
            "location": [
                "CompoundV3Adapter.sol#L55-L60"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing slippage protection in claim functions",
            "description": "Both CompoundV3Adapter and ERC4626MerklAdapter perform token swaps in their claim functions without enforcing minimum output amounts, leaving users exposed to MEV and sandwich attacks. The root cause is the lack of slippage controls during swap execution, where only a minimal check (receiving at least 1 wei) is performed. An attacker could exploit this by frontrunning or backrunning claim transactions to manipulate swap prices and extract value. This could result in significant loss of reward value during liquidation, especially for large claims. The impact ranges from medium to high depending on the value involved, and the likelihood is medium due to partial mitigation via private mempools, leading to a medium severity rating.\n",
            "severity": "Medium",
            "location": [
                "CompoundV3Adapter.sol#L94"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol",
                "debt-fund-vault-v2/src/adapters/ERC4626MerklAdapter.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-184"
                ]
            },
            "title": "Adapters should protect from resetting approval to parent vault",
            "description": "The adapters currently prevent interaction with underlying vaults in claim functions but do not block calls to the parentVault. The root cause is the missing validation that the swapper address is not the parentVault. If a claim function were to call the parentVault directly, it could trigger a reset of the approval between the adapter and the parentVault, potentially disrupting normal operations. While this scenario is unlikely and requires specific conditions, it represents a potential logic flaw. The impact is low as it does not lead to direct fund loss, but it could cause operational issues. The recommendation is to add a require statement to block such calls, hence the low severity.\n",
            "severity": "Low",
            "location": [
                "CompoundV3Adapter.sol#L101",
                "ERC4626MerklAdapter.sol#L125"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1093"
                ]
            },
            "title": "Inefficient data encoding in ERC4626MerklAdapter.claim()",
            "description": "The claim() function in ERC4626MerklAdapter uses an unnecessary wrapper struct (ClaimParams) that combines MerklParams and SwapParams[], leading to extra encoding and decoding overhead. The root cause is suboptimal data structuring, which increases gas consumption during function execution. While this does not pose a security risk, it results in inefficient gas usage, which can raise transaction costs for users. The issue can be exploited by anyone paying higher gas fees, but the intent is not maliciousâ€”rather, it reflects poor optimization. The impact is limited to increased operational costs, making this an informational finding focused on code quality and efficiency.\n",
            "severity": "Informational",
            "location": [
                "ERC4626MerklAdapter.sol#L106",
                "ERC4626MerklAdapter.sol#L109-L112"
            ],
            "files": [
                "debt-fund-vault-v2/src/adapters/ERC4626MerklAdapter.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Increase test coverage",
            "description": "The audit identifies insufficient test coverage for key contracts, specifically CompoundV3Adapter and ERC4626MerklAdapter. The root cause is a lack of comprehensive test cases covering all execution paths, which increases the risk of undetected bugs or regressions after code changes. While no immediate exploit exists, this weakens the project's long-term reliability and security assurance. An attacker could potentially discover and exploit edge cases not covered by tests. The impact is indirect but significant over time, as untested code paths may lead to vulnerabilities in future upgrades. This is classified as informational because it does not represent a direct flaw in the current logic, but rather a process improvement.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol",
                "debt-fund-vault-v2/src/adapters/CompoundV3AdapterFactory.sol",
                "debt-fund-vault-v2/test/integration/CompoundV3IntegrationTest.sol",
                "debt-fund-vault-v2/test/integration/CompoundV3IntegrationClaimTest.sol",
                "debt-fund-vault-v2/src/adapters/ERC4626MerklAdapter.sol",
                "debt-fund-vault-v2/src/adapters/ERC4626MerklAdapterFactory.sol",
                "debt-fund-vault-v2/test/integration/ERC4626MerklAdapterIntegrationTest.sol",
                "debt-fund-vault-v2/test/integration/ERC4626MerklAdapterIntegrationClaimTest.sol",
                "debt-fund-vault-v2/test/integration/ERC4626MerklAdapterIntegrationStataTest.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Dust accumulation due to time delay between swap data generation and execution",
            "description": "Due to the accrual of reward tokens every second on CompoundV3, a time gap between off-chain data generation and on-chain execution can result in small amounts of \"dust\" tokens accumulating in the adapter. The root cause is the delay in execution, during which additional rewards accrue that are not accounted for in the original swap data. These dust tokens remain locked unless manually handled, leading to inefficient capital use. The fix involved approving the swapper for the full token balance instead of just the claimed amount, allowing it to handle donated or leftover tokens. While this does not lead to direct loss, it affects operational efficiency and token management, hence classified as informational.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "debt-fund-vault-v2/src/adapters/CompoundV3Adapter.sol",
                "debt-fund-vault-v2/src/adapters/CompoundV3AdapterFactory.sol"
            ]
        }
    ],
    "affected_files": {
        "CompoundV3IntegrationTest.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity ^0.8.0;\n\nimport {VaultV2Factory, IVaultV2Factory} from \"../../src/VaultV2Factory.sol\";\nimport {IVaultV2, IERC20} from \"../../src/interfaces/IVaultV2.sol\";\nimport \"../../src/libraries/ConstantsLib.sol\";\n\nimport {CompoundV3Adapter} from \"../../src/adapters/CompoundV3Adapter.sol\";\nimport {CompoundV3AdapterFactory} from \"../../src/adapters/CompoundV3AdapterFactory.sol\";\nimport {ICompoundV3AdapterFactory} from \"../../src/adapters/interfaces/ICompoundV3AdapterFactory.sol\";\nimport {ICompoundV3Adapter} from \"../../src/adapters/interfaces/ICompoundV3Adapter.sol\";\n\nimport {CometInterface} from \"../../src/interfaces/CometInterface.sol\";\nimport {CometRewardsInterface} from \"../../src/interfaces/CometRewardsInterface.sol\";\n\nimport {Test, console2} from \"../../lib/forge-std/src/Test.sol\";\n\ncontract CompoundV3IntegrationTest is Test {\n    uint256 constant MAX_TEST_ASSETS = 1e18;\n\n    // Fork variables\n    string internal rpcUrl;\n    uint256 internal forkId;\n    uint256 internal forkBlock = 23175417;\n    bool internal skipMainnetFork;\n\n    // Addresses of Comet USDC and USDC on Ethereum Mainnet\n    CometInterface internal comet = CometInterface(0xc3d688B66703497DAA19211EEdff47f25384cdc3);\n    CometRewardsInterface internal cometRewards = CometRewardsInterface(0x1B0e765F6224C21223AeA2af16c1C46E38885a40);\n    IERC20 internal usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 internal cbBTC = IERC20(0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf);\n    IERC20 internal wstETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n\n    // Test accounts\n    address immutable owner = makeAddr(\"owner\");\n    address immutable curator = makeAddr(\"curator\");\n    address immutable allocator = makeAddr(\"allocator\");\n    address immutable sentinel = makeAddr(\"sentinel\");\n    address internal immutable receiver = makeAddr(\"receiver\");\n    address internal immutable borrower = makeAddr(\"borrower\");\n\n    // Expected data\n    bytes32 internal expectedAdapterId;\n    bytes internal expectedAdapterIdData;\n\n    // Contracts\n    IVaultV2Factory internal vaultFactory;\n    IVaultV2 internal vault;\n    ICompoundV3AdapterFactory internal compoundAdapterFactory;\n    ICompoundV3Adapter internal compoundAdapter;\n\n    function setUp() public virtual {\n        // Create mainnet fork (is skipping not asked)\n        if (!skipMainnetFork) {\n            rpcUrl = vm.envString(\"MAINNET_RPC_URL\");\n            forkId = vm.createFork(rpcUrl, forkBlock);\n            vm.selectFork(forkId);\n        }\n\n        vm.label(address(this), \"testContract\");\n        vm.label(address(usdc), \"usdc\");\n        vm.label(address(comet), \"comet\");\n        vm.label(address(cometRewards), \"cometRewards\");\n\n        /* VAULT SETUP */\n\n        vaultFactory = IVaultV2Factory(address(new VaultV2Factory()));\n        vault = IVaultV2(vaultFactory.createVaultV2(owner, address(usdc), bytes32(0)));\n        vm.label(address(vault), \"vault\");\n\n        compoundAdapterFactory = ICompoundV3AdapterFactory(address(new CompoundV3AdapterFactory()));\n        compoundAdapter = ICompoundV3Adapter(\n            compoundAdapterFactory.createCompoundV3Adapter(address(vault), address(comet), address(cometRewards))\n        );\n        expectedAdapterIdData = abi.encode(\"this\", address(compoundAdapter));\n        expectedAdapterId = keccak256(expectedAdapterIdData);\n        vm.label(address(compoundAdapter), \"compoundAdapter\");\n\n        vm.startPrank(owner);\n        vault.setCurator(curator);\n        vault.setIsSentinel(sentinel, true);\n        vm.stopPrank();\n\n        vm.startPrank(curator);\n\n        vault.submit(abi.encodeCall(IVaultV2.setIsAllocator, (allocator, true)));\n        vault.setIsAllocator(allocator, true);\n\n        vault.submit(abi.encodeCall(IVaultV2.addAdapter, address(compoundAdapter)));\n        vault.addAdapter(address(compoundAdapter));\n\n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (expectedAdapterIdData, type(uint128).max)));\n        vault.increaseAbsoluteCap(expectedAdapterIdData, type(uint128).max);\n\n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (expectedAdapterIdData, WAD)));\n        vault.increaseRelativeCap(expectedAdapterIdData, WAD);\n\n        vm.stopPrank();\n\n        // Set max rate for interest accrual\n        vm.prank(allocator);\n        vault.setMaxRate(MAX_MAX_RATE);\n\n        // Fund user with USDC for testing\n        deal(address(usdc), address(this), MAX_TEST_ASSETS);\n        usdc.approve(address(vault), type(uint256).max);\n    }\n}\n",
        "ERC4626MerklAdapter.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity 0.8.28;\n\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport {IERC4626} from \"../interfaces/IERC4626.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC4626MerklAdapter} from \"./interfaces/IERC4626MerklAdapter.sol\";\nimport {IMerklDistributor} from \"../interfaces/IMerklDistributor.sol\";\nimport {SafeERC20Lib} from \"../libraries/SafeERC20Lib.sol\";\n\n/// @dev Generic ERC4626 adapter with Merkl rewards claiming functionality\n/// @dev Designed for integration with ERC4626-compliant vaults like Stata (AAVE wrapper)\n/// @dev This adapter must be used with ERC4626 vaults that are protected against inflation attacks\n/// @dev Must not be used with an ERC4626 vault which can re-enter the parent vault\ncontract ERC4626MerklAdapter is IERC4626MerklAdapter {\n    /* IMMUTABLES */\n\n    address public immutable factory;\n    address public immutable parentVault;\n    address public immutable erc4626Vault;\n    bytes32 public immutable adapterId;\n\n    /* CONSTANTS */\n\n    /// @dev Merkl distributor address on the vast majority of chains\n    address public constant MERKL_DISTRIBUTOR = 0x3Ef3D8bA38EBe18DB133cEc108f4D14CE00Dd9Ae;\n\n    /* STORAGE */\n\n    address public skimRecipient;\n    address public claimer;\n\n    /* FUNCTIONS */\n\n    constructor(address _parentVault, address _erc4626Vault) {\n        factory = msg.sender;\n        parentVault = _parentVault;\n        erc4626Vault = _erc4626Vault;\n        adapterId = keccak256(abi.encode(\"this\", address(this)));\n        address asset = IVaultV2(_parentVault).asset();\n        require(asset == IERC4626(_erc4626Vault).asset(), AssetMismatch());\n        SafeERC20Lib.safeApprove(asset, _parentVault, type(uint256).max);\n        SafeERC20Lib.safeApprove(asset, _erc4626Vault, type(uint256).max);\n    }\n\n    function setClaimer(address newClaimer) external {\n        if (msg.sender != IVaultV2(parentVault).curator()) revert NotAuthorized();\n        claimer = newClaimer;\n        emit SetClaimer(newClaimer);\n    }\n\n    function setSkimRecipient(address newSkimRecipient) external {\n        require(msg.sender == IVaultV2(parentVault).owner(), NotAuthorized());\n        skimRecipient = newSkimRecipient;\n        emit SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @dev Skims the adapter's balance of `token` and sends it to `skimRecipient`.\n    /// @dev This is useful to handle rewards that the adapter has earned.\n    function skim(address token) external {\n        require(msg.sender == skimRecipient, NotAuthorized());\n        require(token != erc4626Vault, CannotSkimERC4626Shares());\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        SafeERC20Lib.safeTransfer(token, skimRecipient, balance);\n        emit Skim(token, balance);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the allocation and the change in allocation.\n    function allocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(erc4626Vault).deposit(assets, address(this));\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = IERC4626(erc4626Vault).previewRedeem(IERC4626(erc4626Vault).balanceOf(address(this)));\n\n        // Safe casts because ERC4626 vaults bound the total supply, and allocation is less than the\n        // max total assets of the vault.\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the deallocation and the change in allocation.\n    function deallocate(bytes memory data, uint256 assets, bytes4, address)\n        external\n        returns (bytes32[] memory, int256)\n    {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(erc4626Vault).withdraw(assets, address(this), address(this));\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = IERC4626(erc4626Vault).previewRedeem(IERC4626(erc4626Vault).balanceOf(address(this)));\n\n        // Safe casts because ERC4626 vaults bound the total supply, and allocation is less than the\n        // max total assets of the vault.\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Claims rewards from Merkl distributor contract and swap it to parent vault's asset\n    /// @dev Only the claimer can call this function\n    /// @param data Encoded ClaimParams struct containing merkl params and swap params\n    function claim(bytes calldata data) external {\n        require(msg.sender == claimer, NotAuthorized());\n\n        // Decode the claim data\n        ClaimParams memory claimParams = abi.decode(data, (ClaimParams));\n        MerklParams memory merklParams = claimParams.merklParams;\n        SwapParams[] memory swapParams = claimParams.swapParams;\n\n        // Claim data checks\n        require(swapParams.length == merklParams.tokens.length, InvalidData());\n\n        // Call the Merkl distributor\n        IMerklDistributor(MERKL_DISTRIBUTOR).claim(\n            merklParams.users, merklParams.tokens, merklParams.amounts, merklParams.proofs\n        );\n\n        IERC20 parentVaultAsset = IERC20(IVaultV2(parentVault).asset());\n        for (uint256 i; i < swapParams.length; ++i) {\n            // Check the swapper contract isn't the erc4626Vault\n            require(swapParams[i].swapper != erc4626Vault, SwapperCannotBeUnderlyingVault());\n\n            // Snapshot for sanity check\n            uint256 parentVaultBalanceBefore = parentVaultAsset.balanceOf(parentVault);\n            uint256 rewardTokenBalanceBefore = IERC20(merklParams.tokens[i]).balanceOf(address(this));\n\n            // Swap the rewards\n            SafeERC20Lib.safeApprove(merklParams.tokens[i], swapParams[i].swapper, merklParams.amounts[i]);\n            (bool success,) = swapParams[i].swapper.call(swapParams[i].swapData);\n            require(success, SwapReverted());\n            uint256 swappedAmount = rewardTokenBalanceBefore - IERC20(merklParams.tokens[i]).balanceOf(address(this));\n\n            // Check if the parent vault received them\n            uint256 parentVaultBalanceAfter = parentVaultAsset.balanceOf(parentVault);\n            require(parentVaultBalanceAfter > parentVaultBalanceBefore, RewardsNotReceived());\n\n            emit ClaimRewards(merklParams.tokens[i], merklParams.amounts[i]);\n            emit SwapRewards(swapParams[i].swapper, merklParams.tokens[i], swappedAmount, swapParams[i].swapData);\n        }\n    }\n\n    /// @dev Returns adapter's ids.\n    function ids() public view returns (bytes32[] memory) {\n        bytes32[] memory ids_ = new bytes32[](1);\n        ids_[0] = adapterId;\n        return ids_;\n    }\n\n    function allocation() public view returns (uint256) {\n        return IVaultV2(parentVault).allocation(adapterId);\n    }\n\n    function realAssets() external view returns (uint256) {\n        return allocation() != 0\n            ? IERC4626(erc4626Vault).previewRedeem(IERC4626(erc4626Vault).balanceOf(address(this)))\n            : 0;\n    }\n}\n",
        "ERC4626MerklAdapterFactory.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity 0.8.28;\n\nimport {ERC4626MerklAdapter} from \"./ERC4626MerklAdapter.sol\";\nimport {IERC4626MerklAdapterFactory} from \"./interfaces/IERC4626MerklAdapterFactory.sol\";\n\ncontract ERC4626MerklAdapterFactory is IERC4626MerklAdapterFactory {\n    /* STORAGE */\n\n    mapping(address parentVault => mapping(address erc4626Vault => address)) public erc4626MerklAdapter;\n    mapping(address account => bool) public isERC4626MerklAdapter;\n\n    /* FUNCTIONS */\n\n    /// @dev Returns the address of the deployed ERC4626MerklAdapter.\n    function createERC4626MerklAdapter(address parentVault, address erc4626Vault) external returns (address) {\n        address _erc4626Adapter = address(new ERC4626MerklAdapter{salt: bytes32(0)}(parentVault, erc4626Vault));\n        erc4626MerklAdapter[parentVault][erc4626Vault] = _erc4626Adapter;\n        isERC4626MerklAdapter[_erc4626Adapter] = true;\n        emit CreateERC4626MerklAdapter(parentVault, erc4626Vault, _erc4626Adapter);\n        return _erc4626Adapter;\n    }\n}\n",
        "CompoundV3IntegrationClaimTest.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity ^0.8.0;\n\nimport {stdJson} from \"../../lib/forge-std/src/StdJson.sol\";\nimport \"./CompoundV3IntegrationTest.sol\";\n\ncontract CompoundV3IntegrationClaimTest is CompoundV3IntegrationTest {\n    CometInterface constant baseComet = CometInterface(0xb125E6687d4313864e53df431d5425969c15Eb2F);\n    CometRewardsInterface constant baseCometRewards = CometRewardsInterface(0x123964802e6ABabBE1Bc9547D72Ef1B69B00A6b1);\n    IERC20 constant baseUSDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);\n    uint256 constant elapsedTime = 300 days; // Used to boost the rewards accrual\n\n    // Claiming data (bot generated)\n    uint256 internal baseForkBlock;\n    address internal vaultAddr;\n    address internal adapterAddr;\n    address internal rewardToken;\n    uint256 internal rewardAmount;\n    address internal lifiDiamond;\n    uint256 internal usdcMinAmountReceived;\n    bytes internal swapData;\n    bytes internal claimData;\n\n    // Load quote data from JSON file\n    string internal root = vm.projectRoot();\n    string internal path = string.concat(root, \"/test/data/claim_data_compound_base.json\");\n\n    // Test accounts\n    address immutable claimer = makeAddr(\"claimer\");\n\n    function setUp() public virtual override {\n        _loadClaimData(path);\n\n        // Create a fork with a specific block number\n        rpcUrl = vm.envString(\"BASE_RPC_URL\");\n        forkId = vm.createFork(rpcUrl, baseForkBlock);\n        vm.selectFork(forkId);\n        skipMainnetFork = true;\n\n        // Set base contracts\n        comet = baseComet;\n        cometRewards = baseCometRewards;\n        usdc = baseUSDC;\n\n        super.setUp();\n\n        // Deploy an apdater with parent vault being `vaultAddr` and etch code to `adapterAddr`\n        compoundAdapter = ICompoundV3Adapter(\n            compoundAdapterFactory.createCompoundV3Adapter(vaultAddr, address(comet), address(cometRewards))\n        );\n        vm.etch(adapterAddr, address(compoundAdapter).code);\n\n        vm.expectEmit();\n        emit ICompoundV3Adapter.SetClaimer(claimer);\n\n        vm.prank(IVaultV2(vaultAddr).curator());\n        ICompoundV3Adapter(adapterAddr).setClaimer(claimer);\n        assertEq(ICompoundV3Adapter(adapterAddr).claimer(), claimer);\n    }\n\n    function testClaimRewards() public {\n        // Get the reward token\n        address compToken = cometRewards.getRewardOwed(address(comet), address(adapterAddr)).token;\n        assertEq(compToken, rewardToken, \"Bad reward token in test data file\");\n\n        skip(elapsedTime);\n\n        uint256 rewardsOwed = cometRewards.getRewardOwed(address(comet), address(adapterAddr)).owed;\n        assertEq(rewardsOwed, rewardAmount, \"Bad reward amount in test data file\");\n\n        uint256 vaultAssetBalanceBefore = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);\n\n        vm.expectEmit();\n        emit ICompoundV3Adapter.Claim(rewardToken, rewardAmount);\n\n        vm.expectEmit();\n        emit ICompoundV3Adapter.SwapRewards(lifiDiamond, rewardToken, rewardAmount, swapData);\n\n        // Claim and swap COMP rewards\n        vm.prank(claimer);\n        ICompoundV3Adapter(adapterAddr).claim(claimData);\n\n        uint256 vaultAssetBalanceAfter = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);\n        uint256 rewardsInUSDC = vaultAssetBalanceAfter - vaultAssetBalanceBefore;\n\n        assertGe(rewardsInUSDC, usdcMinAmountReceived);\n\n        assertEq(cometRewards.rewardsClaimed(address(comet), address(adapterAddr)), rewardAmount);\n        assertEq(cometRewards.getRewardOwed(address(comet), address(adapterAddr)).owed, 0);\n    }\n\n    function _loadClaimData(string memory _path) internal {\n        string memory json = vm.readFile(_path);\n\n        baseForkBlock = stdJson.readUint(json, \".blockNumber\");\n        vaultAddr = stdJson.readAddress(json, \".vaultAddr\");\n        adapterAddr = stdJson.readAddress(json, \".adapterAddr\");\n        rewardToken = stdJson.readAddress(json, \".rewardToken\");\n        rewardAmount = stdJson.readUint(json, \".rewardAmount\");\n        lifiDiamond = stdJson.readAddress(json, \".lifiDiamond\");\n        usdcMinAmountReceived = stdJson.readUint(json, \".toAmountMin\");\n        swapData = stdJson.readBytes(json, \".swapCalldata\");\n        claimData = stdJson.readBytes(json, \".claimCalldata\");\n\n        vm.label(adapterAddr, \"baseRealAdapter\");\n        vm.label(rewardToken, \"rewardToken\");\n    }\n}\n",
        "ERC4626MerklAdapterIntegrationStataTest.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity ^0.8.0;\n\nimport \"./ERC4626MerklAdapterIntegrationTest.sol\";\n\n// AAVE V3 Pool interface\ninterface IPool {\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n\n/// @title StataIntegrationTest\n/// @notice Integration test for VaultV2 with Stata (AAVE ERC4626 wrapper) as liquidity adapter\n/// @dev This test uses a mainnet fork at block 23027397 with USDC as the underlying asset\ncontract StataIntegrationTest is ERC4626MerklAdapterIntegrationTest {\n    // Constants\n    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2; // AAVE V3 Pool\n    uint256 constant FORK_BLOCK = 23027397;\n\n    // Test accounts\n    address immutable user = makeAddr(\"user\");\n\n    // Contracts\n    IERC4626MerklAdapter stataAdapter;\n    IPool aavePool;\n\n    function setUp() public override {\n        // Create mainnet fork\n        rpcUrl = vm.envString(\"MAINNET_RPC_URL\");\n        forkId = vm.createFork(rpcUrl, FORK_BLOCK);\n        vm.selectFork(forkId);\n        skipMainnetFork = true;\n\n        // Initialize token contracts\n        aavePool = IPool(AAVE_POOL);\n\n        // Verify Stata is ERC4626 compliant and uses USDC as asset\n        require(stataUSDC.asset() == address(usdc), \"Stata asset mismatch\");\n\n        super.setUp();\n\n        // Set up vault names and symbols\n        vm.startPrank(owner);\n        vault.setName(\"USDC Stata Vault\");\n        vault.setSymbol(\"vUSDC-STATA\");\n        vm.stopPrank();\n\n        // Create Stata adapter\n        stataAdapter = erc4626MerklAdapter;\n\n        // Set up adapter\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.addAdapter, address(stataAdapter)));\n        vault.addAdapter(address(stataAdapter));\n\n        // Set max rate for interest accrual\n        vm.prank(allocator);\n        vault.setMaxRate(MAX_MAX_RATE);\n\n        // Set up caps for the adapter manually (since we have our own vault)\n        bytes memory idData = abi.encode(\"this\", address(stataAdapter));\n\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (idData, type(uint128).max)));\n        vault.increaseAbsoluteCap(idData, type(uint128).max);\n\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (idData, 1e18))); // 100%\n        vault.increaseRelativeCap(idData, 1e18);\n\n        // Set Stata as liquidity adapter\n        vm.prank(allocator);\n        vault.setLiquidityAdapterAndData(address(stataAdapter), \"\");\n\n        // Fund user with USDC for testing\n        deal(address(usdc), user, 1000000e6); // 1M USDC\n\n        // User approves vault\n        vm.prank(user);\n        usdc.approve(address(vault), type(uint256).max);\n\n        // Label contracts for easier debugging\n        vm.label(AAVE_POOL, \"AAVE Pool\");\n        vm.label(address(vault), \"VaultV2\");\n        vm.label(address(stataAdapter), \"StataAdapter\");\n        vm.label(user, \"User\");\n    }\n\n    function testVaultDeployment() public view {\n        // Test basic vault properties\n        assertEq(vault.asset(), address(usdc));\n        assertEq(vault.owner(), owner);\n        assertEq(vault.curator(), curator);\n        assertEq(vault.name(), \"USDC Stata Vault\");\n        assertEq(vault.symbol(), \"vUSDC-STATA\");\n\n        // Test adapter setup\n        assertTrue(vault.isAdapter(address(stataAdapter)));\n        assertEq(vault.liquidityAdapter(), address(stataAdapter));\n\n        // Test caps\n        bytes32 adapterId = keccak256(abi.encode(\"this\", address(stataAdapter)));\n        assertEq(vault.absoluteCap(adapterId), type(uint128).max);\n        assertEq(vault.relativeCap(adapterId), 1e18);\n    }\n\n    function testStataAdapterProperties() public view {\n        // Test adapter properties\n        assertEq(stataAdapter.parentVault(), address(vault));\n        assertEq(stataAdapter.erc4626Vault(), address(stataUSDC));\n\n        // Test initial state\n        assertEq(stataAdapter.allocation(), 0);\n        assertEq(stataAdapter.realAssets(), 0);\n\n        // Test IDs\n        bytes32[] memory ids = stataAdapter.ids();\n        assertEq(ids.length, 1);\n        assertEq(ids[0], keccak256(abi.encode(\"this\", address(stataAdapter))));\n    }\n\n    function testDepositAndMint() public {\n        uint256 depositAmount = 10000e6; // 10,000 USDC\n\n        // Test deposit\n        vm.prank(user);\n        uint256 shares = vault.deposit(depositAmount, user);\n\n        assertGt(shares, 0, \"No shares minted\");\n        assertEq(vault.balanceOf(user), shares);\n        assertEq(vault.totalSupply(), shares);\n\n        // Check that funds were allocated to Stata\n        assertGt(stataAdapter.allocation(), 0, \"No allocation to Stata\");\n        assertGt(stataUSDC.balanceOf(address(stataAdapter)), 0, \"No Stata shares\");\n\n        // Test mint\n        uint256 mintShares = shares / 2;\n        vm.prank(user);\n        uint256 assets = vault.mint(mintShares, user);\n\n        assertGt(assets, 0, \"No assets for mint\");\n        assertEq(vault.balanceOf(user), shares + mintShares);\n    }\n\n    function testWithdrawAndRedeem() public {\n        uint256 depositAmount = 10000e6; // 10,000 USDC\n\n        // First deposit\n        vm.prank(user);\n        uint256 shares = vault.deposit(depositAmount, user);\n\n        // Wait for some time to potentially accrue interest\n        vm.warp(block.timestamp + 1 days);\n\n        // Test withdraw\n        uint256 withdrawAmount = 5000e6; // 5,000 USDC\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        vm.prank(user);\n        uint256 sharesRedeemed = vault.withdraw(withdrawAmount, user, user);\n\n        assertGt(sharesRedeemed, 0, \"No shares redeemed\");\n        assertEq(usdc.balanceOf(user) - userBalanceBefore, withdrawAmount);\n        assertEq(vault.balanceOf(user), shares - sharesRedeemed);\n\n        // Test redeem\n        uint256 remainingShares = vault.balanceOf(user);\n        vm.prank(user);\n        uint256 assetsReceived = vault.redeem(remainingShares, user, user);\n\n        assertGt(assetsReceived, 0, \"No assets received\");\n        assertEq(vault.balanceOf(user), 0);\n    }\n\n    function testAllocation() public {\n        uint256 depositAmount = 10000e6; // 10,000 USDC\n\n        // Deposit to vault\n        vm.prank(user);\n        vault.deposit(depositAmount, user);\n\n        // Check initial allocation (should be automatic via liquidity adapter)\n        uint256 initialAllocation = stataAdapter.allocation();\n        assertGt(initialAllocation, 0, \"No initial allocation\");\n\n        // Manual allocation test\n        uint256 additionalAmount = 5000e6;\n        deal(address(usdc), address(vault), additionalAmount);\n\n        vm.prank(allocator);\n        vault.allocate(address(stataAdapter), \"\", additionalAmount);\n\n        // Check allocation increased\n        assertGt(stataAdapter.allocation(), initialAllocation, \"Allocation didn't increase\");\n\n        // Test deallocation\n        vm.prank(allocator);\n        vault.deallocate(address(stataAdapter), \"\", additionalAmount);\n\n        // Check allocation decreased (allow for small rounding differences)\n        assertApproxEqAbs(stataAdapter.allocation(), initialAllocation, 2, \"Deallocation failed\");\n    }\n\n    function testPreviewFunctions() public {\n        uint256 depositAmount = 10000e6; // 10,000 USDC\n\n        // Test preview functions before any deposits\n        uint256 previewShares = vault.previewDeposit(depositAmount);\n        uint256 previewAssets = vault.previewMint(previewShares);\n\n        assertGt(previewShares, 0, \"Preview deposit failed\");\n        assertApproxEqAbs(previewAssets, depositAmount, 1, \"Preview mint mismatch\");\n\n        // Make actual deposit\n        vm.prank(user);\n        uint256 actualShares = vault.deposit(depositAmount, user);\n\n        // Preview functions should be consistent\n        assertApproxEqAbs(actualShares, previewShares, 1, \"Actual shares mismatch\");\n\n        // Test withdraw/redeem previews\n        uint256 previewWithdrawShares = vault.previewWithdraw(depositAmount / 2);\n        uint256 previewRedeemAssets = vault.previewRedeem(actualShares / 2);\n\n        assertGt(previewWithdrawShares, 0, \"Preview withdraw failed\");\n        assertGt(previewRedeemAssets, 0, \"Preview redeem failed\");\n    }\n\n    function testMaxFunctions() public view {\n        // Max functions should return 0 as per vault specification\n        assertEq(vault.maxDeposit(user), 0);\n        assertEq(vault.maxMint(user), 0);\n        assertEq(vault.maxWithdraw(user), 0);\n        assertEq(vault.maxRedeem(user), 0);\n    }\n\n    function testConversionFunctions() public {\n        uint256 depositAmount = 10000e6; // 10,000 USDC\n\n        // Make a deposit to establish exchange rate\n        vm.prank(user);\n        uint256 shares = vault.deposit(depositAmount, user);\n\n        // Test conversion functions\n        uint256 convertedShares = vault.convertToShares(depositAmount);\n        uint256 convertedAssets = vault.convertToAssets(shares);\n\n        assertApproxEqAbs(convertedShares, shares, 1, \"Share conversion mismatch\");\n        assertApproxEqAbs(convertedAssets, depositAmount, 1, \"Asset conversion mismatch\");\n    }\n\n    function testStataIntegration() public {\n        uint256 depositAmount = 50000e6; // 50,000 USDC\n\n        // Record initial Stata state\n        uint256 initialStataShares = stataUSDC.balanceOf(address(stataAdapter));\n\n        // Deposit to vault\n        vm.prank(user);\n        vault.deposit(depositAmount, user);\n\n        // Check Stata integration\n        uint256 finalStataShares = stataUSDC.balanceOf(address(stataAdapter));\n        assertGt(finalStataShares, initialStataShares, \"No Stata shares acquired\");\n\n        // Check that adapter reports correct real assets\n        uint256 reportedAssets = stataAdapter.realAssets();\n        uint256 expectedAssets = stataUSDC.previewRedeem(finalStataShares);\n        assertApproxEqAbs(reportedAssets, expectedAssets, 1, \"Real assets mismatch\");\n\n        // Test that we can withdraw from Stata\n        vm.prank(user);\n        vault.withdraw(depositAmount / 2, user, user);\n\n        // Stata shares should have decreased\n        assertLt(stataUSDC.balanceOf(address(stataAdapter)), finalStataShares, \"Stata shares didn't decrease\");\n    }\n\n    /// forge-config: default.isolate = true\n    function testStataYieldCaptureFixed() public {\n        uint256 depositAmount = 100000e6; // 100,000 USDC\n\n        // Step 1: Initial deposit\n        vm.prank(user);\n        vault.deposit(depositAmount, user);\n\n        // Record initial state\n        uint256 initialStataShares = stataUSDC.balanceOf(address(stataAdapter));\n        uint256 initialStataAssets = stataUSDC.previewRedeem(initialStataShares);\n        uint256 initialVaultAssets = vault.totalAssets();\n\n        // Verify initial setup\n        assertGt(initialStataShares, 0, \"Should have Stata shares after deposit\");\n        assertApproxEqAbs(initialStataAssets, depositAmount, 1, \"Initial Stata assets should match deposit\");\n        assertApproxEqAbs(initialVaultAssets, depositAmount, 1, \"Initial vault assets should match deposit\");\n\n        // Step 2: Generate AAVE yield by increasing utilization\n        uint256 yieldGeneratingDeposit = 10000000e6; // 10M USDC to generate meaningful yield\n        address yieldGenerator = makeAddr(\"yieldGenerator\");\n        deal(address(usdc), yieldGenerator, yieldGeneratingDeposit);\n\n        vm.startPrank(yieldGenerator);\n        usdc.approve(AAVE_POOL, yieldGeneratingDeposit);\n        aavePool.supply(address(usdc), yieldGeneratingDeposit, yieldGenerator, 0);\n        vm.stopPrank();\n\n        // Step 3: Fast forward time to allow yield accrual\n        uint256 timeAdvance = 30 days;\n        skip(timeAdvance);\n\n        // Step 4: Verify Stata captured AAVE yield\n        uint256 stataAssetsAfterYield = stataUSDC.previewRedeem(initialStataShares);\n        uint256 stataYieldGenerated = stataAssetsAfterYield - initialStataAssets;\n\n        assertGe(stataAssetsAfterYield, initialStataAssets, \"Stata assets should not decrease\");\n\n        // Step 5: Verify vault captures Stata yield\n        uint256 vaultAssetsAfterYield = vault.totalAssets();\n        uint256 vaultYieldCaptured = vaultAssetsAfterYield - initialVaultAssets;\n\n        // Core assertions\n        if (stataYieldGenerated > 0) {\n            assertGt(stataYieldGenerated, 0, \"AAVE should generate yield over 30 days with high utilization\");\n            assertGt(vaultYieldCaptured, 0, \"Vault should capture Stata yield\");\n            assertApproxEqAbs(vaultYieldCaptured, stataYieldGenerated, 2, \"Vault should capture nearly all Stata yield\");\n\n            // Verify adapter reports correct assets\n            uint256 adapterRealAssets = stataAdapter.realAssets();\n            assertApproxEqAbs(adapterRealAssets, stataAssetsAfterYield, 2, \"Adapter should report correct real assets\");\n        }\n\n        // Verify system integrity regardless of yield\n        assertGe(vaultAssetsAfterYield, initialVaultAssets, \"Vault assets should not decrease significantly\");\n\n        // User should still have the same number of shares (shares don't change, just their value)\n        uint256 userShares = vault.balanceOf(user);\n        assertGt(userShares, 0, \"User should have shares\");\n\n        // The share value should have increased if yield was captured\n        uint256 shareValue = vault.previewRedeem(userShares);\n        assertGe(shareValue, depositAmount, \"Share value should not decrease\");\n    }\n\n    /// forge-config: default.isolate = true\n    function testStataYieldGenerationWithAAVE() public {\n        uint256 depositAmount = 100000e6; // 100,000 USDC\n\n        // Initial deposit\n        vm.prank(user);\n        vault.deposit(depositAmount, user);\n\n        uint256 initialStataShares = stataUSDC.balanceOf(address(stataAdapter));\n        uint256 initialStataAssets = stataUSDC.previewRedeem(initialStataShares);\n        uint256 initialVaultAssets = vault.totalAssets();\n\n        // Generate AAVE yield by increasing utilization\n        uint256 yieldGeneratingDeposit = 10000000e6; // 10M USDC\n        address yieldGenerator = makeAddr(\"yieldGenerator\");\n        deal(address(usdc), yieldGenerator, yieldGeneratingDeposit);\n\n        vm.startPrank(yieldGenerator);\n        usdc.approve(AAVE_POOL, yieldGeneratingDeposit);\n        aavePool.supply(address(usdc), yieldGeneratingDeposit, yieldGenerator, 0);\n        vm.stopPrank();\n\n        // Fast forward time to accrue interest\n        skip(7 days);\n\n        // Check Stata yield generation\n        uint256 stataAssetsAfterYield = stataUSDC.previewRedeem(initialStataShares);\n        uint256 stataYieldGenerated = stataAssetsAfterYield - initialStataAssets;\n\n        // Check vault yield capture\n        uint256 vaultAssetsAfterYield = vault.totalAssets();\n        uint256 vaultYieldCaptured = vaultAssetsAfterYield - initialVaultAssets;\n\n        // Verify adapter reports correct assets\n        uint256 adapterRealAssets = stataAdapter.realAssets();\n\n        // Assertions\n        assertGe(stataAssetsAfterYield, initialStataAssets, \"Stata assets should not decrease\");\n\n        if (stataYieldGenerated > 0) {\n            assertGt(stataYieldGenerated, 0, \"AAVE should generate yield with high utilization\");\n            assertApproxEqAbs(adapterRealAssets, stataAssetsAfterYield, 2, \"Adapter should report correct real assets\");\n            assertGt(vaultYieldCaptured, 0, \"Vault should capture Stata yield\");\n            assertApproxEqAbs(vaultYieldCaptured, stataYieldGenerated, 2, \"Vault should capture nearly all Stata yield\");\n        }\n\n        // System integrity checks\n        assertGe(vaultAssetsAfterYield, initialVaultAssets, \"Vault assets should not decrease\");\n    }\n\n    function testLargeDepositsAndWithdrawals() public {\n        uint256 largeAmount = 50000000e6; // 500,000 USDC\n\n        // Fund user with large amount\n        deal(address(usdc), user, largeAmount);\n\n        // Large deposit\n        vm.prank(user);\n        uint256 shares = vault.deposit(largeAmount, user);\n\n        assertGt(shares, 0, \"No shares for large deposit\");\n        assertEq(vault.balanceOf(user), shares);\n\n        // Check allocation\n        assertGt(stataAdapter.allocation(), 0, \"No allocation for large deposit\");\n\n        // Large withdrawal (withdraw most of the deposit)\n        uint256 withdrawAmount = largeAmount - 1000e6; // Leave 1000 USDC\n        vm.prank(user);\n        uint256 sharesToRedeem = vault.withdraw(withdrawAmount, user, user);\n\n        assertGt(sharesToRedeem, 0, \"No shares redeemed for large withdrawal\");\n        uint256 remainingShares = vault.balanceOf(user);\n        assertLt(remainingShares, shares / 10, \"Should have withdrawn most shares\"); // Should have < 10% remaining\n    }\n}\n",
        "CompoundV3AdapterFactory.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity 0.8.28;\n\nimport {CompoundV3Adapter} from \"./CompoundV3Adapter.sol\";\nimport {ICompoundV3AdapterFactory} from \"./interfaces/ICompoundV3AdapterFactory.sol\";\n\ncontract CompoundV3AdapterFactory is ICompoundV3AdapterFactory {\n    /* STORAGE */\n\n    mapping(address => mapping(address => address)) public compoundV3Adapter;\n    mapping(address => bool) public isCompoundV3Adapter;\n\n    /* FUNCTIONS */\n\n    /// @dev Returns the address of the deployed CompoundV3Adapter.\n    function createCompoundV3Adapter(address parentVault, address comet, address cometRewards)\n        external\n        returns (address)\n    {\n        address _compoundV3Adapter = address(new CompoundV3Adapter{salt: bytes32(0)}(parentVault, comet, cometRewards));\n        compoundV3Adapter[parentVault][comet] = _compoundV3Adapter;\n        isCompoundV3Adapter[_compoundV3Adapter] = true;\n        emit CreateCompoundV3Adapter(parentVault, comet, cometRewards, _compoundV3Adapter);\n        return _compoundV3Adapter;\n    }\n}\n",
        "ERC4626MerklAdapterIntegrationClaimTest.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity ^0.8.0;\n\nimport {stdJson} from \"../../lib/forge-std/src/StdJson.sol\";\nimport \"./ERC4626MerklAdapterIntegrationTest.sol\";\n\n/// @dev This test uses claim data generated by the claimer bot on base fork\ncontract ERC4626MerklAdapterIntegrationClaimTest is ERC4626MerklAdapterIntegrationTest {\n    // Base contracts and fork block\n    IERC20 constant baseUSDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);\n    IERC4626 constant baseStataUSDC = IERC4626(0xC768c589647798a6EE01A91FdE98EF2ed046DBD6);\n\n    // Claiming data (bot generated)\n    uint256 internal baseForkBlock;\n    address internal vaultAddr;\n    address internal adapterAddr;\n    address internal rewardToken;\n    uint256 internal rewardAmount;\n    address internal lifiDiamond;\n    uint256 internal usdcMinAmountReceived;\n    bytes internal swapData;\n    bytes internal claimData;\n\n    // Load claim data from JSON file\n    string internal root = vm.projectRoot();\n    string internal path = string.concat(root, \"/test/data/claim_data_merkl_base.json\");\n\n    function setUp() public virtual override {\n        _loadClaimData(path);\n\n        // Create base fork\n        rpcUrl = vm.envString(\"BASE_RPC_URL\");\n        forkId = vm.createFork(rpcUrl, baseForkBlock);\n        vm.selectFork(forkId);\n        skipMainnetFork = true;\n\n        // Set base contracts\n        usdc = baseUSDC;\n        stataUSDC = baseStataUSDC;\n\n        super.setUp();\n\n        // Deploy an apdater with parent vault being `vaultAddr` and etch code to `adapterAddr`\n        erc4626MerklAdapter =\n            IERC4626MerklAdapter(erc4626MerklAdapterFactory.createERC4626MerklAdapter(vaultAddr, address(stataUSDC)));\n        vm.etch(adapterAddr, address(erc4626MerklAdapter).code);\n\n        // Set claimer role in etched adapter\n        vm.prank(IVaultV2(vaultAddr).curator());\n        IERC4626MerklAdapter(adapterAddr).setClaimer(rewardClaimer);\n    }\n\n    function testClaim() public {\n        uint256 vaultAssetBalanceBefore = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);\n\n        vm.expectEmit();\n        emit IERC4626MerklAdapter.ClaimRewards(rewardToken, rewardAmount);\n\n        vm.expectEmit();\n        emit IERC4626MerklAdapter.SwapRewards(lifiDiamond, rewardToken, rewardAmount, swapData);\n\n        // Claim and swap Merkl rewards\n        vm.prank(rewardClaimer);\n        IERC4626MerklAdapter(adapterAddr).claim(claimData);\n\n        uint256 vaultAssetBalanceAfter = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);\n        uint256 rewardsInUSDC = vaultAssetBalanceAfter - vaultAssetBalanceBefore;\n\n        assertGe(rewardsInUSDC, usdcMinAmountReceived);\n    }\n\n    function _loadClaimData(string memory _path) internal {\n        string memory json = vm.readFile(_path);\n\n        baseForkBlock = stdJson.readUint(json, \".blockNumber\");\n        vaultAddr = stdJson.readAddress(json, \".vaultAddr\");\n        adapterAddr = stdJson.readAddress(json, \".adapterAddr\");\n        rewardToken = stdJson.readAddress(json, \".rewardToken\");\n        rewardAmount = stdJson.readUint(json, \".rewardAmount\");\n        lifiDiamond = stdJson.readAddress(json, \".lifiDiamond\");\n        usdcMinAmountReceived = stdJson.readUint(json, \".toAmountMin\");\n        swapData = stdJson.readBytes(json, \".swapCalldata\");\n        claimData = stdJson.readBytes(json, \".claimCalldata\");\n\n        vm.label(adapterAddr, \"baseRealAdapter\");\n        vm.label(rewardToken, \"rewardToken\");\n    }\n}\n",
        "ERC4626MerklAdapterIntegrationTest.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity ^0.8.0;\n\nimport {VaultV2Factory, IVaultV2Factory} from \"../../src/VaultV2Factory.sol\";\nimport {IVaultV2, IERC4626, IERC20} from \"../../src/interfaces/IVaultV2.sol\";\nimport \"../../src/libraries/ConstantsLib.sol\";\n\nimport {\n    ERC4626MerklAdapterFactory, IERC4626MerklAdapterFactory\n} from \"../../src/adapters/ERC4626MerklAdapterFactory.sol\";\nimport {IERC4626MerklAdapter} from \"../../src/adapters/interfaces/IERC4626MerklAdapter.sol\";\n\nimport {Test, console2} from \"../../lib/forge-std/src/Test.sol\";\n\ncontract ERC4626MerklAdapterIntegrationTest is Test {\n    uint256 constant MAX_TEST_ASSETS = 1e18;\n\n    // Fork variables\n    string internal rpcUrl;\n    uint256 internal forkId;\n    uint256 internal forkBlock;\n    bool internal skipMainnetFork;\n\n    // Addresses of USDC, Stata USDC, and Merkl Distributor on Ethereum Mainnet\n    IERC20 internal usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC4626 internal stataUSDC = IERC4626(0xD4fa2D31b7968E448877f69A96DE69f5de8cD23E); // Stata USDC contract\n    address internal merklDistributor = 0x3Ef3D8bA38EBe18DB133cEc108f4D14CE00Dd9Ae; // Merkl Distributor\n\n    // Test accounts\n    address immutable owner = makeAddr(\"owner\");\n    address immutable curator = makeAddr(\"curator\");\n    address immutable allocator = makeAddr(\"allocator\");\n    address immutable sentinel = makeAddr(\"sentinel\");\n    address internal immutable receiver = makeAddr(\"receiver\");\n    address internal immutable borrower = makeAddr(\"borrower\");\n    address immutable rewardClaimer = makeAddr(\"rewardClaimer\");\n\n    // Expected data\n    bytes32 internal expectedAdapterId;\n    bytes internal expectedAdapterIdData;\n\n    // Contracts\n    IVaultV2Factory internal vaultFactory;\n    IVaultV2 internal vault;\n    IERC4626MerklAdapterFactory internal erc4626MerklAdapterFactory;\n    IERC4626MerklAdapter internal erc4626MerklAdapter;\n\n    function setUp() public virtual {\n        // Create mainnet fork (is skipping not asked)\n        if (!skipMainnetFork) {\n            rpcUrl = vm.envString(\"MAINNET_RPC_URL\");\n            forkId = vm.createFork(rpcUrl);\n            vm.selectFork(forkId);\n        }\n\n        vm.label(address(this), \"testContract\");\n        vm.label(address(usdc), \"usdc\");\n        vm.label(address(stataUSDC), \"stataUSDC\");\n        vm.label(merklDistributor, \"merklDistributor\");\n\n        // Create a new vault for USDC\n        vaultFactory = IVaultV2Factory(address(new VaultV2Factory()));\n        vault = IVaultV2(vaultFactory.createVaultV2(owner, address(usdc), bytes32(0)));\n        vm.label(address(vault), \"vault\");\n\n        // Deploy adapter factory and create adapter\n        erc4626MerklAdapterFactory = new ERC4626MerklAdapterFactory();\n        erc4626MerklAdapter = IERC4626MerklAdapter(\n            erc4626MerklAdapterFactory.createERC4626MerklAdapter(address(vault), address(stataUSDC))\n        );\n        expectedAdapterIdData = abi.encode(\"this\", address(erc4626MerklAdapter));\n        expectedAdapterId = keccak256(expectedAdapterIdData);\n        vm.label(address(erc4626MerklAdapter), \"erc4626MerklAdapter\");\n\n        // Set up vault roles\n        vm.startPrank(owner);\n        vault.setCurator(curator);\n        vault.setIsSentinel(sentinel, true);\n        vm.stopPrank();\n\n        vm.startPrank(curator);\n\n        // Set up allocator\n        vault.submit(abi.encodeCall(IVaultV2.setIsAllocator, (allocator, true)));\n        vault.setIsAllocator(allocator, true);\n\n        // Set up adapter in vault\n        vault.submit(abi.encodeCall(IVaultV2.addAdapter, address(erc4626MerklAdapter)));\n        vault.addAdapter(address(erc4626MerklAdapter));\n\n        // Set up absolute cap for the adapter\n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (expectedAdapterIdData, type(uint128).max)));\n        vault.increaseAbsoluteCap(expectedAdapterIdData, type(uint128).max);\n\n        // Set up relative cap for the adapter\n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (expectedAdapterIdData, WAD)));\n        vault.increaseRelativeCap(expectedAdapterIdData, WAD);\n\n        // Set claimer role\n        erc4626MerklAdapter.setClaimer(rewardClaimer);\n\n        vm.stopPrank();\n\n        // Set max rate for interest accrual\n        vm.prank(allocator);\n        vault.setMaxRate(MAX_MAX_RATE);\n\n        // Fund user with USDC for testing\n        deal(address(usdc), address(this), MAX_TEST_ASSETS);\n        usdc.approve(address(vault), type(uint256).max);\n    }\n\n    function _addAdapter(address adapter) internal {\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.addAdapter, adapter));\n        vault.addAdapter(adapter);\n    }\n\n    function _setAdapterAbsoluteCap(bytes memory idData, uint256 newCap) internal {\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (idData, newCap)));\n        vault.increaseAbsoluteCap(idData, newCap);\n    }\n\n    function _setAdapterRelativeCap(bytes memory idData, uint256 newCap) internal {\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (idData, newCap)));\n        vault.increaseRelativeCap(idData, newCap);\n    }\n}\n",
        "CompoundV3Adapter.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 [Byzantine Finance]\n// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.\npragma solidity 0.8.28;\n\nimport {CometInterface} from \"../interfaces/CometInterface.sol\";\nimport {CometRewardsInterface} from \"../interfaces/CometRewardsInterface.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {ICompoundV3Adapter} from \"./interfaces/ICompoundV3Adapter.sol\";\nimport {SafeERC20Lib} from \"../libraries/SafeERC20Lib.sol\";\n\ncontract CompoundV3Adapter is ICompoundV3Adapter {\n    /* IMMUTABLES */\n\n    address public immutable factory;\n    address public immutable parentVault;\n    address public immutable asset;\n    address public immutable comet;\n    address public immutable cometRewards;\n    bytes32 public immutable adapterId;\n\n    /* STORAGE */\n\n    address public skimRecipient;\n    address public claimer;\n\n    /* FUNCTIONS */\n\n    constructor(address _parentVault, address _comet, address _cometRewards) {\n        factory = msg.sender;\n        parentVault = _parentVault;\n        comet = _comet;\n        cometRewards = _cometRewards;\n        adapterId = keccak256(abi.encode(\"this\", address(this)));\n        asset = IVaultV2(_parentVault).asset();\n        SafeERC20Lib.safeApprove(asset, _comet, type(uint256).max);\n        SafeERC20Lib.safeApprove(asset, _parentVault, type(uint256).max);\n    }\n\n    function setClaimer(address newClaimer) external {\n        if (msg.sender != IVaultV2(parentVault).curator()) revert NotAuthorized();\n        claimer = newClaimer;\n        emit SetClaimer(newClaimer);\n    }\n\n    function setSkimRecipient(address newSkimRecipient) external {\n        if (msg.sender != IVaultV2(parentVault).owner()) revert NotAuthorized();\n        skimRecipient = newSkimRecipient;\n        emit SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @dev Skims the adapter's balance of `token` and sends it to `skimRecipient`.\n    /// @dev This is useful to handle rewards that the adapter has earned.\n    function skim(address token) external {\n        if (msg.sender != skimRecipient) revert NotAuthorized();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        SafeERC20Lib.safeTransfer(token, skimRecipient, balance);\n        emit Skim(token, balance);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the allocation and the change in allocation.\n    function allocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        if (data.length != 0) revert InvalidData();\n        if (msg.sender != parentVault) revert NotAuthorized();\n\n        if (assets > 0) CometInterface(comet).supply(asset, assets);\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = CometInterface(comet).balanceOf(address(this));\n\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the deallocation and the change in allocation.\n    function deallocate(bytes memory data, uint256 assets, bytes4, address)\n        external\n        returns (bytes32[] memory, int256)\n    {\n        if (data.length != 0) revert InvalidData();\n        if (msg.sender != parentVault) revert NotAuthorized();\n\n        if (assets > 0) CometInterface(comet).withdraw(asset, assets);\n        uint256 oldAllocation = allocation();\n        uint256 newAllocation = CometInterface(comet).balanceOf(address(this));\n\n        return (ids(), int256(newAllocation) - int256(oldAllocation));\n    }\n\n    /// @dev Claims COMP rewards accumulated by the adapter and swap it to parent vault's asset\n    /// @dev Only the claimer can call this function\n    /// @param data Encoded SwapParams struct containing swapper and swap data\n    function claim(bytes calldata data) external {\n        if (msg.sender != claimer) revert NotAuthorized();\n\n        // Decode the data\n        (address swapper, bytes memory swapData) = abi.decode(data, (address, bytes));\n\n        // Check the swapper contract isn't the comet contract\n        if (swapper == comet) revert SwapperCannotBeComet();\n\n        // Get assets\n        IERC20 rewardToken = IERC20(CometRewardsInterface(cometRewards).rewardConfig(comet).token);\n        IERC20 parentVaultAsset = IERC20(IVaultV2(parentVault).asset());\n\n        // Claim the rewards\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        CometRewardsInterface(cometRewards).claim(comet, address(this), true);\n        uint256 balanceAfter = rewardToken.balanceOf(address(this));\n        uint256 claimedAmount = balanceAfter - balanceBefore;\n\n        // Snapshot for sanity check\n        balanceBefore = parentVaultAsset.balanceOf(parentVault);\n\n        // Swap the rewards\n        SafeERC20Lib.safeApprove(address(rewardToken), swapper, claimedAmount);\n        (bool success,) = swapper.call(swapData);\n        require(success, SwapReverted());\n        uint256 swappedAmount = balanceAfter - rewardToken.balanceOf(address(this));\n\n        // Check if the parent vault received them\n        balanceAfter = parentVaultAsset.balanceOf(parentVault);\n        require(balanceAfter > balanceBefore, RewardsNotReceived());\n\n        emit Claim(address(rewardToken), claimedAmount);\n        emit SwapRewards(swapper, address(rewardToken), swappedAmount, swapData);\n    }\n\n    /// @dev Returns adapter's ids.\n    function ids() public view returns (bytes32[] memory) {\n        bytes32[] memory ids_ = new bytes32[](1);\n        ids_[0] = adapterId;\n        return ids_;\n    }\n\n    function allocation() public view returns (uint256) {\n        return IVaultV2(parentVault).allocation(adapterId);\n    }\n\n    function realAssets() external view returns (uint256) {\n        return allocation() != 0 ? CometInterface(comet).balanceOf(address(this)) : 0;\n    }\n}\n"
    }
}