{
    "vfp_id": "vfp_00319",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Missing Synchronization Between BondManager and PreconfWhitelist Allows Low-Bond 'Zombie' Proposers",
            "description": "The `BondManager` and `PreconfWhitelist` contracts are not synchronized, allowing operators who are no longer properly bonded to remain whitelisted and eligible for selection as proposers. When a proposer is slashed below `minBond` or requests withdrawal, `BondManager` marks them as low-bond, but this state change is not propagated to `PreconfWhitelist`. The operator remains whitelisted until manually removed, even though they are economically invalid.\n\nThe root cause is the absence of event-driven synchronization between the two components. The current ejector monitor does not subscribe to `BondManager` events, so it fails to detect when a proposer becomes low-bond. If such a \"zombie\" proposer is selected, their proposal is replaced with an empty manifest, leading to wasted L1 gas, reduced liveness, and poor user experience due to delayed transaction inclusion.\n\nThe impact includes degraded network liveness, increased operational costs, and silent erosion of system reliability. Since all components behave as designed, this issue may go undetected by standard monitoring, making it a stealthy liveness risk.\n",
            "severity": "High",
            "location": [
                "BondManager.sol::",
                "PreconfWhitelist.sol::",
                "ejector monitor"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/BondManager.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Deposits After Withdrawal Keep Proposer in Permanent Low-Bond “Zombie” State",
            "description": "After calling `requestWithdrawal()`, a proposer who later deposits sufficient funds to meet the minimum bond requirement remains permanently classified as low-bond because the `withdrawalRequestedAt` flag is not reset by the `deposit()` function. The `hasSufficientBond` check requires both sufficient balance and `withdrawalRequestedAt == 0`, so even fully funded proposers are treated as low-bond until they explicitly call `cancelWithdrawal()`.\n\nThe root cause is the lack of state synchronization in the `deposit()` function, which updates the balance but fails to clear the withdrawal request flag when the bond is restored. This leads to a \"zombie\" state where the proposer can still be elected and submit blocks, but all proposals are downgraded to default manifests due to low-bond classification.\n\nAn attacker could exploit this by entering and maintaining this state to disrupt block finalization or cause confusion. Honest proposers may unknowingly operate in this degraded mode, leading to dropped transactions and poor user experience. The impact includes loss of user transactions, reduced protocol reliability, and potential confusion in operator status.\n\nA fix would require `deposit()` to reset `withdrawalRequestedAt` when the bond is sufficient, or at minimum, clear documentation and client-side warnings.\n",
            "severity": "High",
            "location": [
                "BondManager.sol::requestWithdrawal#130",
                "BondManager.sol::deposit",
                "Anchor.sol::hasSufficientBond"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/BondManager.sol"
            ]
        }
    ],
    "affected_files": {
        "BondManager.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IBondManager } from \"./IBondManager.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { EssentialContract } from \"src/shared/common/EssentialContract.sol\";\n\n/// @title BondManager\n/// @notice L1 implementation of BondManager with time-based withdrawal mechanism\n/// @custom:security-contact security@taiko.xyz\ncontract BondManager is EssentialContract, IBondManager {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------\n    // State Variables\n    // ---------------------------------------------------------------\n\n    /// @notice The address of the inbox contract that is allowed to call debitBond and creditBond\n    address public immutable authorized;\n\n    /// @notice ERC20 token used as bond.\n    IERC20 public immutable bondToken;\n\n    /// @notice Minimum bond required\n    uint256 public immutable minBond;\n\n    /// @notice Time delay required before withdrawal after request\n    /// @dev WARNING: In theory operations can remain unfinalized indefinitely, but in practice\n    /// after\n    ///      the `extendedProvingWindow` the incentives are very strong for finalization.\n    ///      A safe value for this is `extendedProvingWindow` + buffer, for example, 2 weeks.\n    uint48 public immutable withdrawalDelay;\n\n    /// @notice Per-account bond state\n    mapping(address account => Bond bond) public bond;\n\n    uint256[49] private __gap;\n\n    // ---------------------------------------------------------------\n    // Constructor and Initialization\n    // ---------------------------------------------------------------\n\n    /// @notice Constructor disables initializers for upgradeable pattern\n    /// @param _authorized The address of the authorized contract (Inbox)\n    /// @param _bondToken The ERC20 bond token address\n    /// @param _minBond The minimum bond required\n    /// @param _withdrawalDelay The delay period for withdrawals (e.g., 7 days)\n    constructor(\n        address _authorized,\n        address _bondToken,\n        uint256 _minBond,\n        uint48 _withdrawalDelay\n    ) {\n        authorized = _authorized;\n        bondToken = IERC20(_bondToken);\n        minBond = _minBond;\n        withdrawalDelay = _withdrawalDelay;\n    }\n\n    /// @notice Initializes the BondManager contract\n    /// @param _owner The owner of this contract\n    function init(address _owner) external initializer {\n        __Essential_init(_owner);\n    }\n\n    // ---------------------------------------------------------------\n    // External Functions\n    // ---------------------------------------------------------------\n\n    /// @inheritdoc IBondManager\n    function debitBond(\n        address _address,\n        uint256 _bond\n    )\n        external\n        onlyFrom(authorized)\n        returns (uint256 amountDebited_)\n    {\n        amountDebited_ = _debitBond(_address, _bond);\n        if (amountDebited_ > 0) {\n            emit BondDebited(_address, amountDebited_);\n        }\n    }\n\n    /// @inheritdoc IBondManager\n    function creditBond(address _address, uint256 _bond) external onlyFrom(authorized) {\n        _creditBond(_address, _bond);\n    }\n\n    /// @inheritdoc IBondManager\n    function getBondBalance(address _address) external view returns (uint256) {\n        return _getBondBalance(_address);\n    }\n\n    /// @inheritdoc IBondManager\n    function deposit(uint256 _amount) external nonReentrant {\n        bondToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        _creditBond(msg.sender, _amount);\n\n        emit BondDeposited(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IBondManager\n    function depositTo(address _recipient, uint256 _amount) external nonReentrant {\n        require(_recipient != address(0), InvalidRecipient());\n\n        bondToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        _creditBond(_recipient, _amount);\n\n        emit BondDepositedFor(msg.sender, _recipient, _amount);\n    }\n\n    /// @inheritdoc IBondManager\n    function hasSufficientBond(\n        address _address,\n        uint256 _additionalBond\n    )\n        external\n        view\n        returns (bool)\n    {\n        Bond storage bond_ = bond[_address];\n        return bond_.balance >= minBond + _additionalBond && bond_.withdrawalRequestedAt == 0;\n    }\n\n    /// @inheritdoc IBondManager\n    function requestWithdrawal() external nonReentrant {\n        Bond storage bond_ = bond[msg.sender];\n        require(bond_.balance > 0, NoBondToWithdraw());\n        require(bond_.withdrawalRequestedAt == 0, WithdrawalAlreadyRequested());\n\n        bond_.withdrawalRequestedAt = uint48(block.timestamp);\n        emit WithdrawalRequested(msg.sender, block.timestamp + withdrawalDelay);\n    }\n\n    /// @inheritdoc IBondManager\n    function cancelWithdrawal() external nonReentrant {\n        Bond storage bond_ = bond[msg.sender];\n        require(bond_.withdrawalRequestedAt > 0, NoWithdrawalRequested());\n\n        bond_.withdrawalRequestedAt = 0;\n        emit WithdrawalCancelled(msg.sender);\n    }\n\n    /// @inheritdoc IBondManager\n    function withdraw(address _to, uint256 _amount) external nonReentrant {\n        Bond storage bond_ = bond[msg.sender];\n\n        if (\n            bond_.withdrawalRequestedAt == 0\n                || block.timestamp < bond_.withdrawalRequestedAt + withdrawalDelay\n        ) {\n            // Active account or withdrawal delay not passed yet, can only withdraw excess above\n            // minBond\n            require(bond_.balance - _amount >= minBond, MustMaintainMinBond());\n        }\n\n        _withdraw(msg.sender, _to, _amount);\n    }\n\n    // ---------------------------------------------------------------\n    // Internal Functions\n    // ---------------------------------------------------------------\n\n    /// @dev Internal implementation for debiting a bond\n    /// @param _address The address to debit the bond from\n    /// @param _bond The amount of bond to debit in gwei\n    /// @return bondDebited_ The actual amount debited in gwei\n    function _debitBond(\n        address _address,\n        uint256 _bond\n    )\n        internal\n        returns (uint256 bondDebited_)\n    {\n        Bond storage bond_ = bond[_address];\n\n        if (bond_.balance <= _bond) {\n            bondDebited_ = bond_.balance;\n            bond_.balance = 0;\n        } else {\n            bondDebited_ = _bond;\n            bond_.balance = bond_.balance - _bond;\n        }\n    }\n\n    /// @dev Internal implementation for crediting a bond\n    /// @param _address The address to credit the bond to\n    /// @param _bond The amount of bond to credit in gwei\n    function _creditBond(address _address, uint256 _bond) internal {\n        Bond storage bond_ = bond[_address];\n        bond_.balance = bond_.balance + _bond;\n        emit BondCredited(_address, _bond);\n    }\n\n    /// @dev Internal implementation for withdrawing funds from a user's bond balance\n    /// @param _from The address whose balance will be reduced\n    /// @param _to The recipient address\n    /// @param _amount The amount to withdraw\n    function _withdraw(address _from, address _to, uint256 _amount) internal {\n        uint256 debited = _debitBond(_from, _amount);\n        bondToken.safeTransfer(_to, debited);\n        emit BondWithdrawn(_from, debited);\n    }\n\n    /// @dev Internal implementation for getting the bond balance\n    /// @param _address The address to get the bond balance for\n    /// @return The bond balance of the address\n    function _getBondBalance(address _address) internal view returns (uint256) {\n        return bond[_address].balance;\n    }\n\n    // ---------------------------------------------------------------\n    // Errors\n    // ---------------------------------------------------------------\n\n    error InsufficientBond();\n    error InvalidRecipient();\n    error MustMaintainMinBond();\n    error NoBondToWithdraw();\n    error NoWithdrawalRequested();\n    error WithdrawalAlreadyRequested();\n}\n"
    }
}