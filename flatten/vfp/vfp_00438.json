{
    "vfp_id": "vfp_00438",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-346"
                ],
                "3": [
                    "CWE-940"
                ]
            },
            "title": "Locked tokens possibility",
            "description": "The TokenCallbackHandler contract does not validate that its functions are only called as fallbacks from a Safe contract. As a result, if users directly send ERC-721 or ERC-1155 tokens to the contract address, those tokens become permanently locked because the contract lacks withdrawal functionality. The root cause is the absence of a sender validation check (e.g., ensuring msg.sender is a contract with specific storage layout). This creates a risk of irreversible fund loss for users who mistakenly send tokens directly. An attacker could not directly exploit this for gain, but users may lose assets due to this configuration oversight. The impact is a warning due to the potential for user fund loss through accidental interactions.\n",
            "severity": "Informational",
            "location": [
                "TokenCallbackHandler.sol"
            ],
            "files": [
                "safe-smart-account/contracts/handler/TokenCallbackHandler.sol"
            ]
        }
    ],
    "affected_files": {
        "TokenCallbackHandler.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ERC1155TokenReceiver} from \"../interfaces/ERC1155TokenReceiver.sol\";\nimport {ERC721TokenReceiver} from \"../interfaces/ERC721TokenReceiver.sol\";\nimport {ERC777TokensRecipient} from \"../interfaces/ERC777TokensRecipient.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\n\n/**\n * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes to receive these tokens.\n * @author Richard Meissner - @rmeissner\n */\ncontract TokenCallbackHandler is ERC1155TokenReceiver, ERC777TokensRecipient, ERC721TokenReceiver, IERC165 {\n    /**\n     * @notice Handles ERC1155 Token callback.\n     * @return Standardized onERC1155Received return value.\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0xf23a6e61;\n    }\n\n    /**\n     * @notice Handles ERC1155 Token batch callback.\n     * @return Standardized onERC1155BatchReceived return value.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xbc197c81;\n    }\n\n    /**\n     * @notice Handles ERC721 Token callback.\n     * @return Standardized onERC721Received return value.\n     */\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    /**\n     * @notice Handles ERC777 Token callback.\n     * @dev Account that wishes to receive the tokens also needs to register the implementer (this contract) via the ERC-1820 interface registry.\n     *      From the standard: \"This is done by calling the setInterfaceImplementer function on the ERC-1820 registry with the holder address as\n     *      the address, the keccak256 hash of ERC777TokensSender (0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895) as the\n     *      interface hash, and the address of the contract implementing the ERC777TokensSender as the implementer.\"\n     */\n    function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure override {\n        // We implement this for completeness, doesn't really have any value\n    }\n\n    /**\n     * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n     * @param interfaceId Id of the interface.\n     * @return if the interface is supported.\n     */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n            interfaceId == type(ERC721TokenReceiver).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    }
}