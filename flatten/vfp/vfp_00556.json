{
    "vfp_id": "vfp_00556",
    "project_name": "cantina_seamless_sep2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Public function with internal variant, should just be set to external",
            "description": "1. **Description:** The convertCollateralToShares function is marked public but is only used externally or via its internal counterpart, indicating a likely oversight in visibility.\n2. **Cause:** Incorrect visibility setting; public functions are accessible internally and externally, but if only external access is intended, external is more efficient.\n3. **Exploitation:** No direct exploit, but internal calls could bypass external checks if added in the future.\n4. **Impact:** Slight gas inefficiency and potential for future logic errors if internal behavior diverges.\n",
            "severity": "Informational",
            "location": [
                "LeverageManager.sol#L134"
            ],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "New mints are possible post complete liquidation",
            "description": "1. **Description:** After a complete liquidation (totalSupply != 0 and totalCollateral == 0), it is still possible to deposit collateral directly via the lending adapter, making both non-zero and allowing new mints.\n2. **Cause:** The protocol does not enforce a permanent shutdown state post-liquidation, allowing deposits to restart the system.\n3. **Exploitation:** A user could manipulate the exchange rate by depositing a small amount, though shares are effectively worthless post-liquidation.\n4. **Impact:** Undermines assumptions in comments and documentation, though no major financial impact due to zero-value shares.\n",
            "severity": "Informational",
            "location": [
                "LeverageManager.sol#L642-L647"
            ],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        }
    ],
    "affected_files": {
        "LeverageManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\n// Dependency imports\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardTransientUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Internal imports\nimport {IRebalanceAdapterBase} from \"src/interfaces/IRebalanceAdapterBase.sol\";\nimport {IBeaconProxyFactory} from \"src/interfaces/IBeaconProxyFactory.sol\";\nimport {ILendingAdapter} from \"src/interfaces/ILendingAdapter.sol\";\nimport {ILeverageManager} from \"src/interfaces/ILeverageManager.sol\";\nimport {ILeverageToken} from \"src/interfaces/ILeverageToken.sol\";\nimport {FeeManager} from \"src/FeeManager.sol\";\nimport {LeverageTokenState} from \"src/types/DataTypes.sol\";\nimport {LeverageToken} from \"src/LeverageToken.sol\";\nimport {\n    ActionData,\n    ActionType,\n    ExternalAction,\n    LeverageTokenConfig,\n    BaseLeverageTokenConfig,\n    RebalanceAction\n} from \"src/types/DataTypes.sol\";\n\n/**\n * @dev The LeverageManager contract is an upgradeable core contract that is responsible for managing the creation of LeverageTokens.\n * It also acts as an entry point for users to mint and redeem LeverageTokens (shares), and for\n * rebalancers to rebalance LeverageTokens.\n *\n * LeverageTokens are ERC20 tokens that are akin to shares in an ERC-4626 vault - they represent a claim on the equity held by\n * the LeverageToken. They can be created on this contract by calling `createNewLeverageToken`, and their configuration on the\n * LeverageManager is immutable.\n * Note: Although the LeverageToken configuration saved on the LeverageManager is immutable, the configured LendingAdapter and\n *       RebalanceAdapter for the LeverageToken may be upgradeable contracts.\n *\n * The LeverageManager also inherits the `FeeManager` contract, which is used to manage LeverageToken fees (which accrue to\n * the share value of the LeverageToken) and the treasury fees.\n *\n * For mints of LeverageTokens (shares), the collateral and debt required is calculated by using the LeverageToken's\n * current collateral ratio. As such, the collateral ratio after a mint must be equal to the collateral ratio before a\n * mint, within some rounding error.\n *\n * [CAUTION]\n * ====\n * - LeverageTokens are susceptible to inflation attacks like ERC-4626 vaults:\n *   \"In empty (or nearly empty) ERC-4626 vaults, mints are at high risk of being stolen through frontrunning\n *   with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n *   attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n *   mint of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Redeems may\n *   similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n *   verifying the amount received is as expected, using a wrapper that performs these checks such as\n *   https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\"\n *\n *   As such it is highly recommended that LeverageToken creators make an initial mint of a non-trivial amount of equity.\n *   It is also recommended to use a router that performs slippage checks when minting and redeeming.\n *\n * - LeverageToken creation is permissionless and can be configured with arbitrary lending adapters, rebalance adapters, and\n *   underlying collateral and debt assets. As such, the adapters and tokens used by a LeverageToken are part of the risk\n *   profile of the LeverageToken, and should be carefully considered by users before using a LeverageToken.\n *\n * - LeverageTokens can be configured with arbitrary lending adapters, thus LeverageTokens are directly affected by the\n *   specific mechanisms of the underlying lending market that their lending adapter integrates with. As mentioned above,\n *   it is highly recommended that users research and understand the lending adapter used by the LeverageToken they are\n *   considering using. Some examples:\n *   - Morpho: Users should be aware that Morpho market creation is permissionless, and that the price oracle used by\n *     by the market may be manipulatable.\n *   - Aave v3: Allows rehypothecation of collateral, which may lead to reverts when trying to remove collateral from the\n *     market during redeems and rebalances.\n *\n * @custom:contact security@seamlessprotocol.com\n */\ncontract LeverageManager is\n    ILeverageManager,\n    AccessControlUpgradeable,\n    ReentrancyGuardTransientUpgradeable,\n    FeeManager,\n    UUPSUpgradeable\n{\n    // Base collateral ratio constant, 1e18 means that collateral / debt ratio is 1:1\n    uint256 public constant BASE_RATIO = 1e18;\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    /// @dev Struct containing all state for the LeverageManager contract\n    /// @custom:storage-location erc7201:seamless.contracts.storage.LeverageManager\n    struct LeverageManagerStorage {\n        /// @dev Factory for deploying new LeverageTokens\n        IBeaconProxyFactory tokenFactory;\n        /// @dev LeverageToken address => Base config for LeverageToken\n        mapping(ILeverageToken token => BaseLeverageTokenConfig) config;\n    }\n\n    function _getLeverageManagerStorage() internal pure returns (LeverageManagerStorage storage $) {\n        // slither-disable-next-line assembly\n        assembly {\n            // keccak256(abi.encode(uint256(keccak256(\"seamless.contracts.storage.LeverageManager\")) - 1)) & ~bytes32(uint256(0xff));\n            $.slot := 0x326e20d598a681eb69bc11b5176604d340fccf9864170f09484f3c317edf3600\n        }\n    }\n\n    function initialize(address initialAdmin, address treasury, IBeaconProxyFactory leverageTokenFactory)\n        external\n        initializer\n    {\n        __FeeManager_init(initialAdmin, treasury);\n        __ReentrancyGuardTransient_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n        _getLeverageManagerStorage().tokenFactory = leverageTokenFactory;\n        emit LeverageManagerInitialized(leverageTokenFactory);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n    /// @inheritdoc ILeverageManager\n    function convertCollateralToDebt(ILeverageToken token, uint256 collateral, Math.Rounding rounding)\n        external\n        view\n        returns (uint256 debt)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalCollateral = lendingAdapter.getCollateral();\n        uint256 totalDebt = lendingAdapter.getDebt();\n\n        return _convertCollateralToDebt(token, lendingAdapter, collateral, totalCollateral, totalDebt, rounding);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function convertCollateralToShares(ILeverageToken token, uint256 collateral, Math.Rounding rounding)\n        public\n        view\n        returns (uint256 shares)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalSupply = getFeeAdjustedTotalSupply(token);\n        return _convertCollateralToShares(token, lendingAdapter, collateral, totalSupply, rounding);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function convertDebtToCollateral(ILeverageToken token, uint256 debt, Math.Rounding rounding)\n        external\n        view\n        returns (uint256 collateral)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalCollateral = lendingAdapter.getCollateral();\n        uint256 totalDebt = lendingAdapter.getDebt();\n\n        if (totalDebt == 0) {\n            if (totalCollateral == 0) {\n                // Initial state: no collateral or debt, use initial collateral ratio\n                uint256 initialCollateralRatio = getLeverageTokenInitialCollateralRatio(token);\n                return lendingAdapter.convertDebtToCollateralAsset(\n                    Math.mulDiv(debt, initialCollateralRatio, BASE_RATIO, rounding)\n                );\n            }\n            // Liquidated state: no debt but collateral exists, cannot convert\n            return 0;\n        }\n\n        return Math.mulDiv(debt, totalCollateral, totalDebt, rounding);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function convertSharesToCollateral(ILeverageToken token, uint256 shares, Math.Rounding rounding)\n        external\n        view\n        returns (uint256 collateral)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalCollateral = lendingAdapter.getCollateral();\n        uint256 totalSupply = getFeeAdjustedTotalSupply(token);\n        return _convertSharesToCollateral(token, lendingAdapter, shares, totalCollateral, totalSupply, rounding);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function convertSharesToDebt(ILeverageToken token, uint256 shares, Math.Rounding rounding)\n        external\n        view\n        returns (uint256 debt)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalDebt = lendingAdapter.getDebt();\n        uint256 totalSupply = getFeeAdjustedTotalSupply(token);\n        return _convertSharesToDebt(token, lendingAdapter, shares, totalDebt, totalSupply, rounding);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function convertToAssets(ILeverageToken token, uint256 shares)\n        external\n        view\n        returns (uint256 equityInCollateralAsset)\n    {\n        uint256 totalEquityInCollateralAsset = getLeverageTokenLendingAdapter(token).getEquityInCollateralAsset();\n        uint256 totalSupply = getFeeAdjustedTotalSupply(token);\n\n        // slither-disable-next-line incorrect-equality,timestamp\n        if (totalSupply == 0) {\n            return 0;\n        }\n\n        return Math.mulDiv(shares, totalEquityInCollateralAsset, totalSupply, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function convertToShares(ILeverageToken token, uint256 equityInCollateralAsset)\n        external\n        view\n        returns (uint256 shares)\n    {\n        uint256 totalEquityInCollateralAsset = getLeverageTokenLendingAdapter(token).getEquityInCollateralAsset();\n        uint256 totalSupply = getFeeAdjustedTotalSupply(token);\n\n        if (totalEquityInCollateralAsset == 0) {\n            return 0;\n        }\n\n        return Math.mulDiv(equityInCollateralAsset, totalSupply, totalEquityInCollateralAsset, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenFactory() public view returns (IBeaconProxyFactory factory) {\n        return _getLeverageManagerStorage().tokenFactory;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenCollateralAsset(ILeverageToken token) public view returns (IERC20 collateralAsset) {\n        return getLeverageTokenLendingAdapter(token).getCollateralAsset();\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenDebtAsset(ILeverageToken token) public view returns (IERC20 debtAsset) {\n        return getLeverageTokenLendingAdapter(token).getDebtAsset();\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenRebalanceAdapter(ILeverageToken token)\n        public\n        view\n        returns (IRebalanceAdapterBase module)\n    {\n        return _getLeverageManagerStorage().config[token].rebalanceAdapter;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenConfig(ILeverageToken token) external view returns (LeverageTokenConfig memory config) {\n        BaseLeverageTokenConfig memory baseConfig = _getLeverageManagerStorage().config[token];\n        uint256 mintTokenFee = getLeverageTokenActionFee(token, ExternalAction.Mint);\n        uint256 redeemTokenFee = getLeverageTokenActionFee(token, ExternalAction.Redeem);\n\n        return LeverageTokenConfig({\n            lendingAdapter: baseConfig.lendingAdapter,\n            rebalanceAdapter: baseConfig.rebalanceAdapter,\n            mintTokenFee: mintTokenFee,\n            redeemTokenFee: redeemTokenFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenLendingAdapter(ILeverageToken token) public view returns (ILendingAdapter adapter) {\n        return _getLeverageManagerStorage().config[token].lendingAdapter;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenInitialCollateralRatio(ILeverageToken token) public view returns (uint256) {\n        uint256 initialCollateralRatio =\n            getLeverageTokenRebalanceAdapter(token).getLeverageTokenInitialCollateralRatio(token);\n\n        if (initialCollateralRatio <= BASE_RATIO) {\n            revert InvalidLeverageTokenInitialCollateralRatio(initialCollateralRatio);\n        }\n\n        return initialCollateralRatio;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenState(ILeverageToken token) external view returns (LeverageTokenState memory state) {\n        return _getLeverageTokenState(getLeverageTokenLendingAdapter(token));\n    }\n\n    /// @inheritdoc ILeverageManager\n    function createNewLeverageToken(LeverageTokenConfig calldata tokenConfig, string memory name, string memory symbol)\n        external\n        nonReentrant\n        returns (ILeverageToken token)\n    {\n        IBeaconProxyFactory tokenFactory = getLeverageTokenFactory();\n\n        // slither-disable-next-line reentrancy-events\n        token = ILeverageToken(\n            tokenFactory.createProxy(\n                abi.encodeWithSelector(LeverageToken.initialize.selector, address(this), name, symbol),\n                bytes32(tokenFactory.numProxies())\n            )\n        );\n\n        _getLeverageManagerStorage().config[token] = BaseLeverageTokenConfig({\n            lendingAdapter: tokenConfig.lendingAdapter,\n            rebalanceAdapter: tokenConfig.rebalanceAdapter\n        });\n        _setLeverageTokenActionFee(token, ExternalAction.Mint, tokenConfig.mintTokenFee);\n        _setLeverageTokenActionFee(token, ExternalAction.Redeem, tokenConfig.redeemTokenFee);\n        _setNewLeverageTokenManagementFee(token);\n\n        tokenConfig.lendingAdapter.postLeverageTokenCreation(msg.sender, address(token));\n        tokenConfig.rebalanceAdapter.postLeverageTokenCreation(msg.sender, address(token));\n\n        emit LeverageTokenCreated(\n            token,\n            tokenConfig.lendingAdapter.getCollateralAsset(),\n            tokenConfig.lendingAdapter.getDebtAsset(),\n            tokenConfig\n        );\n        return token;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewDeposit(ILeverageToken token, uint256 collateral) public view returns (ActionData memory) {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 feeAdjustedTotalSupply = getFeeAdjustedTotalSupply(token);\n\n        uint256 debt = _convertCollateralToDebt(\n            token,\n            lendingAdapter,\n            collateral,\n            lendingAdapter.getCollateral(),\n            lendingAdapter.getDebt(),\n            Math.Rounding.Floor\n        );\n\n        uint256 shares =\n            _convertCollateralToShares(token, lendingAdapter, collateral, feeAdjustedTotalSupply, Math.Rounding.Floor);\n        (uint256 sharesAfterFee, uint256 sharesFee, uint256 treasuryFee) =\n            _computeFeesForGrossShares(token, shares, ExternalAction.Mint);\n\n        return ActionData({\n            collateral: collateral,\n            debt: debt,\n            shares: sharesAfterFee,\n            tokenFee: sharesFee,\n            treasuryFee: treasuryFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewMint(ILeverageToken token, uint256 shares) public view returns (ActionData memory) {\n        (uint256 grossShares, uint256 sharesFee, uint256 treasuryFee) =\n            _computeFeesForNetShares(token, shares, ExternalAction.Mint);\n\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 feeAdjustedTotalSupply = getFeeAdjustedTotalSupply(token);\n        uint256 collateral = _convertSharesToCollateral(\n            token,\n            lendingAdapter,\n            grossShares,\n            lendingAdapter.getCollateral(),\n            feeAdjustedTotalSupply,\n            Math.Rounding.Ceil\n        );\n        uint256 debt = _convertCollateralToDebt(\n            token,\n            lendingAdapter,\n            collateral,\n            lendingAdapter.getCollateral(),\n            lendingAdapter.getDebt(),\n            Math.Rounding.Floor\n        );\n\n        return ActionData({\n            collateral: collateral,\n            debt: debt,\n            shares: shares,\n            tokenFee: sharesFee,\n            treasuryFee: treasuryFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewRedeem(ILeverageToken token, uint256 shares) public view returns (ActionData memory) {\n        (uint256 sharesAfterFees, uint256 sharesFee, uint256 treasuryFee) =\n            _computeFeesForGrossShares(token, shares, ExternalAction.Redeem);\n\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 feeAdjustedTotalSupply = getFeeAdjustedTotalSupply(token);\n\n        // The redeemer receives collateral and repays debt for the net shares after fees are subtracted. The amount of\n        // shares their balance is decreased by is that net share amount (which is burned) plus the fees.\n        // - the treasury fee shares are given to the treasury\n        // - the token fee shares are burned to increase share value\n        uint256 collateral = _convertSharesToCollateral(\n            token,\n            lendingAdapter,\n            sharesAfterFees,\n            lendingAdapter.getCollateral(),\n            feeAdjustedTotalSupply,\n            Math.Rounding.Floor\n        );\n        uint256 debt = _convertSharesToDebt(\n            token, lendingAdapter, sharesAfterFees, lendingAdapter.getDebt(), feeAdjustedTotalSupply, Math.Rounding.Ceil\n        );\n\n        return ActionData({\n            collateral: collateral,\n            debt: debt,\n            shares: shares,\n            tokenFee: sharesFee,\n            treasuryFee: treasuryFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewWithdraw(ILeverageToken token, uint256 collateral) public view returns (ActionData memory) {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 feeAdjustedTotalSupply = getFeeAdjustedTotalSupply(token);\n\n        // The withdrawer receives their specified collateral amount and pays debt for the shares that can be exchanged\n        // for the collateral amount. The amount of shares their balance is decreased by is that share amount (which is\n        // burned) plus the fees.\n        // - the treasury fee shares are given to the treasury\n        // - the token fee shares are burned to increase share value\n        uint256 shares =\n            _convertCollateralToShares(token, lendingAdapter, collateral, feeAdjustedTotalSupply, Math.Rounding.Ceil);\n        uint256 debt = _convertCollateralToDebt(\n            token,\n            lendingAdapter,\n            collateral,\n            lendingAdapter.getCollateral(),\n            lendingAdapter.getDebt(),\n            Math.Rounding.Ceil\n        );\n\n        (uint256 sharesAfterFees, uint256 sharesFee, uint256 treasuryFee) =\n            _computeFeesForNetShares(token, shares, ExternalAction.Redeem);\n\n        return ActionData({\n            collateral: collateral,\n            debt: debt,\n            shares: sharesAfterFees,\n            tokenFee: sharesFee,\n            treasuryFee: treasuryFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function deposit(ILeverageToken token, uint256 collateral, uint256 minShares)\n        external\n        nonReentrant\n        returns (ActionData memory actionData)\n    {\n        // Management fee is calculated from the total supply of the LeverageToken, so we need to charge it first\n        // before total supply is updated due to the mint\n        chargeManagementFee(token);\n\n        ActionData memory depositData = previewDeposit(token, collateral);\n\n        // slither-disable-next-line timestamp\n        if (depositData.shares < minShares) {\n            revert SlippageTooHigh(depositData.shares, minShares); // TODO: check if this is correct\n        }\n\n        _mint(token, depositData);\n\n        return depositData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function mint(ILeverageToken token, uint256 shares, uint256 maxCollateral)\n        external\n        nonReentrant\n        returns (ActionData memory actionData)\n    {\n        // Management fee is calculated from the total supply of the LeverageToken, so we need to charge it first\n        // before total supply is updated due to the mint\n        chargeManagementFee(token);\n\n        ActionData memory mintData = previewMint(token, shares);\n\n        // slither-disable-next-line timestamp\n        if (mintData.collateral > maxCollateral) {\n            revert SlippageTooHigh(mintData.collateral, maxCollateral);\n        }\n\n        _mint(token, mintData);\n\n        return mintData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function rebalance(\n        ILeverageToken leverageToken,\n        RebalanceAction[] calldata actions,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    ) external nonReentrant {\n        _transferTokens(tokenIn, msg.sender, address(this), amountIn);\n\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(leverageToken);\n\n        // Check if the LeverageToken is eligible for rebalance\n        LeverageTokenState memory stateBefore = _getLeverageTokenState(lendingAdapter);\n\n        IRebalanceAdapterBase rebalanceAdapter = getLeverageTokenRebalanceAdapter(leverageToken);\n        if (!rebalanceAdapter.isEligibleForRebalance(leverageToken, stateBefore, msg.sender)) {\n            revert LeverageTokenNotEligibleForRebalance();\n        }\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            _executeLendingAdapterAction(leverageToken, actions[i].actionType, actions[i].amount);\n        }\n\n        // Validate the LeverageToken state after rebalancing\n        if (!rebalanceAdapter.isStateAfterRebalanceValid(leverageToken, stateBefore)) {\n            revert InvalidLeverageTokenStateAfterRebalance(leverageToken);\n        }\n\n        _transferTokens(tokenOut, address(this), msg.sender, amountOut);\n\n        LeverageTokenState memory stateAfter = _getLeverageTokenState(lendingAdapter);\n\n        emit Rebalance(leverageToken, msg.sender, stateBefore, stateAfter, actions);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function redeem(ILeverageToken token, uint256 shares, uint256 minCollateral)\n        external\n        nonReentrant\n        returns (ActionData memory actionData)\n    {\n        // Management fee is calculated from the total supply of the LeverageToken, so we need to claim it first\n        // before total supply is updated due to the redeem\n        chargeManagementFee(token);\n\n        ActionData memory redeemData = previewRedeem(token, shares);\n\n        // slither-disable-next-line timestamp\n        if (redeemData.collateral < minCollateral) {\n            revert SlippageTooHigh(redeemData.collateral, minCollateral);\n        }\n\n        _redeem(token, redeemData);\n\n        return redeemData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function withdraw(ILeverageToken token, uint256 collateral, uint256 maxShares)\n        external\n        nonReentrant\n        returns (ActionData memory actionData)\n    {\n        // Management fee is calculated from the total supply of the LeverageToken, so we need to claim it first\n        // before total supply is updated due to the redeem\n        chargeManagementFee(token);\n\n        ActionData memory withdrawData = previewWithdraw(token, collateral);\n\n        // slither-disable-next-line timestamp\n        if (withdrawData.shares > maxShares) {\n            revert SlippageTooHigh(withdrawData.shares, maxShares);\n        }\n\n        _redeem(token, withdrawData);\n\n        return withdrawData;\n    }\n\n    /// @notice Converts collateral to debt given the state of the LeverageToken\n    /// @param token LeverageToken to convert collateral for\n    /// @param lendingAdapter Lending adapter of the LeverageToken\n    /// @param collateral Collateral to convert to debt\n    /// @param totalCollateral Total collateral of the LeverageToken\n    /// @param totalDebt Total debt of the LeverageToken\n    /// @param rounding Rounding mode\n    /// @return debt Debt\n    function _convertCollateralToDebt(\n        ILeverageToken token,\n        ILendingAdapter lendingAdapter,\n        uint256 collateral,\n        uint256 totalCollateral,\n        uint256 totalDebt,\n        Math.Rounding rounding\n    ) internal view returns (uint256 debt) {\n        if (totalCollateral == 0) {\n            if (totalDebt == 0) {\n                // Initial state: no collateral or debt, use initial collateral ratio\n                uint256 initialCollateralRatio = getLeverageTokenInitialCollateralRatio(token);\n                return lendingAdapter.convertCollateralToDebtAsset(\n                    Math.mulDiv(collateral, BASE_RATIO, initialCollateralRatio, rounding)\n                );\n            }\n            // Liquidated state: no collateral but debt exists, cannot convert\n            return 0;\n        }\n\n        return Math.mulDiv(collateral, totalDebt, totalCollateral, rounding);\n    }\n\n    /// @notice Converts collateral to shares given the state of the LeverageToken\n    /// @param token LeverageToken to convert collateral for\n    /// @param lendingAdapter Lending adapter of the LeverageToken\n    /// @param collateral Collateral to convert to shares\n    /// @param totalSupply Total supply of shares of the LeverageToken\n    /// @param rounding Rounding mode\n    /// @return shares Shares\n    function _convertCollateralToShares(\n        ILeverageToken token,\n        ILendingAdapter lendingAdapter,\n        uint256 collateral,\n        uint256 totalSupply,\n        Math.Rounding rounding\n    ) internal view returns (uint256 shares) {\n        uint256 totalCollateral = lendingAdapter.getCollateral();\n\n        // slither-disable-next-line incorrect-equality,timestamp\n        if (totalSupply == 0) {\n            uint256 initialCollateralRatio = getLeverageTokenInitialCollateralRatio(token);\n\n            uint256 equityInCollateralAsset =\n                Math.mulDiv(collateral, initialCollateralRatio - BASE_RATIO, initialCollateralRatio, rounding);\n\n            uint256 leverageTokenDecimals = IERC20Metadata(address(token)).decimals();\n            uint256 collateralDecimals = IERC20Metadata(address(lendingAdapter.getCollateralAsset())).decimals();\n\n            // If collateral asset has more decimals than leverage token, we scale down the equity in collateral asset\n            // Otherwise we scale up the equity in collateral asset\n            if (collateralDecimals > leverageTokenDecimals) {\n                uint256 scalingFactor = 10 ** (collateralDecimals - leverageTokenDecimals);\n                return equityInCollateralAsset / scalingFactor;\n            } else {\n                uint256 scalingFactor = 10 ** (leverageTokenDecimals - collateralDecimals);\n                return equityInCollateralAsset * scalingFactor;\n            }\n        }\n\n        // If total supply != 0 and total collateral is zero, the LeverageToken was fully liquidated. In this case,\n        // no amount of collateral can be converted to shares. An implication of this is that new mints of shares\n        // will not be possible for the LeverageToken.\n        if (totalCollateral == 0) {\n            return 0;\n        }\n\n        return Math.mulDiv(collateral, totalSupply, totalCollateral, rounding);\n    }\n\n    /// @notice Converts shares to collateral given the state of the LeverageToken\n    /// @param token LeverageToken to convert shares for\n    /// @param lendingAdapter Lending adapter of the LeverageToken\n    /// @param shares Shares to convert to collateral\n    /// @param totalCollateral Total collateral of the LeverageToken\n    /// @param totalSupply Total supply of shares of the LeverageToken\n    /// @param rounding Rounding mode\n    function _convertSharesToCollateral(\n        ILeverageToken token,\n        ILendingAdapter lendingAdapter,\n        uint256 shares,\n        uint256 totalCollateral,\n        uint256 totalSupply,\n        Math.Rounding rounding\n    ) internal view returns (uint256 collateral) {\n        // slither-disable-next-line incorrect-equality,timestamp\n        if (totalSupply == 0) {\n            uint256 leverageTokenDecimals = IERC20Metadata(address(token)).decimals();\n            uint256 collateralDecimals = IERC20Metadata(address(lendingAdapter.getCollateralAsset())).decimals();\n\n            uint256 initialCollateralRatio = getLeverageTokenInitialCollateralRatio(token);\n\n            // If collateral asset has more decimals than leverage token, we scale down the equity in collateral asset\n            // Otherwise we scale up the equity in collateral asset\n            if (collateralDecimals > leverageTokenDecimals) {\n                uint256 scalingFactor = 10 ** (collateralDecimals - leverageTokenDecimals);\n                return Math.mulDiv(\n                    shares * scalingFactor, initialCollateralRatio, initialCollateralRatio - BASE_RATIO, rounding\n                );\n            } else {\n                uint256 scalingFactor = 10 ** (leverageTokenDecimals - collateralDecimals);\n                return Math.mulDiv(\n                    shares, initialCollateralRatio, (initialCollateralRatio - BASE_RATIO) * scalingFactor, rounding\n                );\n            }\n        }\n\n        return Math.mulDiv(shares, totalCollateral, totalSupply, rounding);\n    }\n\n    /// @notice Converts shares to debt given the state of the LeverageToken\n    /// @param token LeverageToken to convert shares for\n    /// @param lendingAdapter Lending adapter of the LeverageToken\n    /// @param shares Shares to convert to debt\n    /// @param totalDebt Total debt of the LeverageToken\n    /// @param totalSupply Total supply of shares of the LeverageToken\n    /// @param rounding Rounding mode\n    function _convertSharesToDebt(\n        ILeverageToken token,\n        ILendingAdapter lendingAdapter,\n        uint256 shares,\n        uint256 totalDebt,\n        uint256 totalSupply,\n        Math.Rounding rounding\n    ) internal view returns (uint256 debt) {\n        // slither-disable-next-line incorrect-equality,timestamp\n        if (totalSupply == 0) {\n            uint256 leverageTokenDecimals = IERC20Metadata(address(token)).decimals();\n            uint256 collateralDecimals = IERC20Metadata(address(lendingAdapter.getCollateralAsset())).decimals();\n\n            uint256 initialCollateralRatio = getLeverageTokenInitialCollateralRatio(token);\n\n            // If collateral asset has more decimals than leverage token, we scale down the equity in collateral asset\n            // Otherwise we scale up the equity in collateral asset\n            if (collateralDecimals > leverageTokenDecimals) {\n                uint256 scalingFactor = 10 ** (collateralDecimals - leverageTokenDecimals);\n                return lendingAdapter.convertCollateralToDebtAsset(\n                    Math.mulDiv(shares * scalingFactor, BASE_RATIO, initialCollateralRatio - BASE_RATIO, rounding)\n                );\n            } else {\n                uint256 scalingFactor = 10 ** (leverageTokenDecimals - collateralDecimals);\n                return lendingAdapter.convertCollateralToDebtAsset(\n                    Math.mulDiv(shares, BASE_RATIO, (initialCollateralRatio - BASE_RATIO) * scalingFactor, rounding)\n                );\n            }\n        }\n\n        return Math.mulDiv(shares, totalDebt, totalSupply, rounding);\n    }\n\n    /// @notice Executes actions on the LendingAdapter for a specific LeverageToken\n    /// @param token LeverageToken to execute action for\n    /// @param actionType Type of the action to execute\n    /// @param amount Amount to execute action with\n    function _executeLendingAdapterAction(ILeverageToken token, ActionType actionType, uint256 amount) internal {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        if (actionType == ActionType.AddCollateral) {\n            IERC20 collateralAsset = lendingAdapter.getCollateralAsset();\n            // slither-disable-next-line reentrancy-events\n            SafeERC20.forceApprove(collateralAsset, address(lendingAdapter), amount);\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.addCollateral(amount);\n        } else if (actionType == ActionType.RemoveCollateral) {\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.removeCollateral(amount);\n        } else if (actionType == ActionType.Borrow) {\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.borrow(amount);\n        } else if (actionType == ActionType.Repay) {\n            IERC20 debtAsset = lendingAdapter.getDebtAsset();\n            // slither-disable-next-line reentrancy-events\n            SafeERC20.forceApprove(debtAsset, address(lendingAdapter), amount);\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.repay(amount);\n        }\n    }\n\n    //// @notice Returns all data required to describe current LeverageToken state - collateral, debt, equity and collateral ratio\n    /// @param lendingAdapter LendingAdapter of the LeverageToken\n    /// @return state LeverageToken state\n    function _getLeverageTokenState(ILendingAdapter lendingAdapter)\n        internal\n        view\n        returns (LeverageTokenState memory state)\n    {\n        uint256 collateral = lendingAdapter.getCollateralInDebtAsset();\n        uint256 debt = lendingAdapter.getDebt();\n        uint256 equity = lendingAdapter.getEquityInDebtAsset();\n\n        uint256 collateralRatio =\n            debt > 0 ? Math.mulDiv(collateral, BASE_RATIO, debt, Math.Rounding.Floor) : type(uint256).max;\n\n        return LeverageTokenState({\n            collateralInDebtAsset: collateral,\n            debt: debt,\n            equity: equity,\n            collateralRatio: collateralRatio\n        });\n    }\n\n    /// @notice Helper function for executing a mint action on a LeverageToken\n    /// @param token LeverageToken to mint shares for\n    /// @param mintData Action data for the mint\n    function _mint(ILeverageToken token, ActionData memory mintData) internal {\n        // Take collateral asset from sender\n        IERC20 collateralAsset = getLeverageTokenCollateralAsset(token);\n        SafeERC20.safeTransferFrom(collateralAsset, msg.sender, address(this), mintData.collateral);\n\n        // Add collateral to LeverageToken\n        _executeLendingAdapterAction(token, ActionType.AddCollateral, mintData.collateral);\n\n        // Borrow and send debt assets to caller\n        _executeLendingAdapterAction(token, ActionType.Borrow, mintData.debt);\n        SafeERC20.safeTransfer(getLeverageTokenDebtAsset(token), msg.sender, mintData.debt);\n\n        // Charge treasury fee\n        _chargeTreasuryFee(token, mintData.treasuryFee);\n\n        // Mint shares to user\n        // slither-disable-next-line reentrancy-events\n        token.mint(msg.sender, mintData.shares);\n\n        // Emit event and explicit return statement\n        emit Mint(token, msg.sender, mintData);\n    }\n\n    /// @notice Helper function for executing a redeem action on a LeverageToken\n    /// @param token LeverageToken to redeem shares for\n    /// @param redeemData Action data for the redeem\n    function _redeem(ILeverageToken token, ActionData memory redeemData) internal {\n        // Burn shares from user and total supply\n        token.burn(msg.sender, redeemData.shares);\n\n        // Mint shares to treasury for the treasury action fee\n        _chargeTreasuryFee(token, redeemData.treasuryFee);\n\n        // Take assets from sender and repay the debt\n        SafeERC20.safeTransferFrom(getLeverageTokenDebtAsset(token), msg.sender, address(this), redeemData.debt);\n        _executeLendingAdapterAction(token, ActionType.Repay, redeemData.debt);\n\n        // Remove collateral from lending pool\n        _executeLendingAdapterAction(token, ActionType.RemoveCollateral, redeemData.collateral);\n\n        // Send collateral assets to sender\n        SafeERC20.safeTransfer(getLeverageTokenCollateralAsset(token), msg.sender, redeemData.collateral);\n\n        // Emit event and explicit return statement\n        emit Redeem(token, msg.sender, redeemData);\n    }\n\n    /// @notice Helper function for transferring tokens, or no-op if token is 0 address\n    /// @param token Token to transfer\n    /// @param from Address to transfer tokens from\n    /// @param to Address to transfer tokens to\n    /// @dev If from address is this smart contract it will use the regular transfer function otherwise it will use transferFrom\n    function _transferTokens(IERC20 token, address from, address to, uint256 amount) internal {\n        if (address(token) == address(0)) {\n            return;\n        }\n\n        if (from == address(this)) {\n            SafeERC20.safeTransfer(token, to, amount);\n        } else {\n            SafeERC20.safeTransferFrom(token, from, to, amount);\n        }\n    }\n}\n"
    }
}