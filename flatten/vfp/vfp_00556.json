{
    "vfp_id": "vfp_00556",
    "project_name": "Managed Optimistic Oracle Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Currencies Do Not Accept a Bond By Default",
            "description": "The ManagedOptimisticOracleV2 contract uses a mapping called `maximumBonds` to store per-currency maximum bond amounts. If no maximum bond is explicitly set for a given currency, the mapping returns zero by default, which causes any non-zero bond to fail validation in the `_validateBond` function. This behavior effectively prevents the usage of any currency that has not been explicitly configured with a maximum bond limit.\n\nThe root cause is the lack of a default \"unlimited\" or \"infinite\" bond setting for currencies. Instead, the system defaults to a maximum bond of zero, which is interpreted as no valid bond being allowed. This design choice may be intentional but is not clearly documented.\n\nAn attacker cannot directly exploit this, but a malicious or misconfigured admin could prevent certain currencies from being used by simply not setting a maximum bond. Alternatively, a legitimate user may be unable to use a desired currency if the admin has not pre-configured it.\n\nThe impact is a potential denial-of-service (DoS) for specific currency usage in price requests, reducing the flexibility and usability of the oracle system. Users may be unable to request prices in certain tokens unless the admin explicitly configures them.\n",
            "severity": "Low",
            "location": [
                "ManagedOptimisticOracleV2.sol::maximumBonds#107",
                "ManagedOptimisticOracleV2.sol::_validateBond#474-476",
                "ManagedOptimisticOracleV2.sol#initializer#132",
                "ManagedOptimisticOracleV2.sol::setMaximumBond#198-200"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ]
            },
            "title": "The `RequestManagerAdded` and `RequestManagerRemoved` Events Can Be Wrongfully Emitted",
            "description": "The `addRequestManager` and `removeRequestManager` functions in the ManagedOptimisticOracleV2 contract emit `RequestManagerAdded` and `RequestManagerRemoved` events unconditionally, regardless of whether the underlying role was actually granted or revoked. This can lead to misleading event logs when the functions are called redundantly (e.g., adding a role that already exists).\n\nThe cause is the direct emission of these events without first checking the current role status via `hasRole`. Since `grantRole` and `revokeRole` from `AccessControlUpgradeable` are idempotent, calling them multiple times does not change state, but the custom events are still emitted, creating false signals.\n\nAn off-chain service or indexer relying on these events to track role changes could misinterpret redundant events as actual state transitions, leading to incorrect state reconstruction or alerting.\n\nThe impact is degraded reliability of event-based monitoring systems and potential confusion for developers and users. While not directly exploitable for financial gain, it undermines trust in the event system and could lead to operational errors in dependent systems.\n",
            "severity": "Low",
            "location": [
                "ManagedOptimisticOracleV2.sol::addRequestManager#177-180",
                "ManagedOptimisticOracleV2.sol::removeRequestManager#187-190"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing Interface Validation for Whitelist Contracts",
            "description": "The ManagedOptimisticOracleV2 contract allows external contracts to be set as whitelist implementations via functions like `setDefaultProposerWhitelist`, `setRequesterWhitelist`, and `requestManagerSetProposerWhitelist`. However, these functions do not verify that the provided addresses actually implement the `DisableableAddressWhitelistInterface`.\n\nThe root cause is the absence of an ERC-165 interface check or any form of runtime validation (e.g., a function call to confirm interface compliance). This allows potentially invalid or malicious contracts to be set, which could lead to silent failures or unexpected behavior when the oracle attempts to query the whitelist.\n\nAn attacker could deploy a contract that lacks the required functions and trick the system into using it as a whitelist, resulting in access control bypass or runtime reverts during critical operations.\n\nThe impact includes potential denial-of-service or incorrect access control decisions, undermining the security model that relies on properly functioning whitelists. This could allow unauthorized parties to propose or dispute prices if the system fails to validate membership correctly.\n",
            "severity": "Low",
            "location": [
                "ManagedOptimisticOracleV2.sol::setDefaultProposerWhitelist#216",
                "ManagedOptimisticOracleV2.sol::setRequesterWhitelist#225",
                "ManagedOptimisticOracleV2.sol::requestManagerSetProposerWhitelist#304"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Missing Test Suite",
            "description": "The audited contracts, including OptimisticOracleV2 and ManagedOptimisticOracleV2, lack a dedicated test suite within the repository. This absence means there are no automated tests to verify the correctness of complex logic involving state transitions, bond handling, and access control.\n\nThe cause is the omission of test files or integration tests for the core functionality. Manual review alone is insufficient to ensure robustness, especially for upgradeable contracts and financial systems.\n\nWithout tests, future code changes could introduce regressions or critical bugs that go undetected until deployment, where they could lead to financial loss or system failure.\n\nThe impact is a significantly increased risk of undetected vulnerabilities and reduced confidence in the reliability and maintainability of the codebase. This undermines long-term security and developer productivity.\n",
            "severity": "Low",
            "location": [
                "OptimisticOracleV2.sol",
                "ManagedOptimisticOracleV2.sol"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/OptimisticOracleV2.sol",
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "Problematic Whitelist Implementation",
            "description": "The AddressWhitelist contract uses a soft-delete mechanism where removed addresses remain in the `whitelistIndices` array, causing it to grow indefinitely. The `getWhitelist` function iterates over this entire array twice, leading to increasing gas costs and potential out-of-gas errors for large lists.\n\nThe root cause is the inefficient data structure design: using a dynamic array for enumeration without removing entries upon deletion. Additionally, the three-state system (`None`, `Out`, `In`) introduces logical inconsistencies, such as an address being marked `In` without being in the array, thus not appearing in `getWhitelist`.\n\nAn attacker could exploit this by repeatedly adding and removing addresses to bloat the array, increasing gas costs for legitimate users calling `getWhitelist`, effectively causing a denial-of-service.\n\nThe impact includes high gas costs, potential DoS via gas exhaustion, and inconsistent state representation. This undermines the usability and reliability of the whitelist functionality.\n",
            "severity": "Low",
            "location": [
                "AddressWhitelist.sol::removeFromWhitelist#55",
                "AddressWhitelist.sol::getWhitelist#79",
                "AddressWhitelist.sol#73-76"
            ],
            "files": [
                "managed-oracle/src/common/implementation/AddressWhitelist.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Minimum Liveness Can Be Set Beyond Valid Bounds",
            "description": "The `setMinimumLiveness` function in ManagedOptimisticOracleV2 allows the admin to set a global minimum liveness value without validating it against the upper bounds enforced by the underlying OptimisticOracleV2 contract.\n\nThe cause is the lack of a validation check in `_setMinimumLiveness` to ensure the new value is within the acceptable range defined by the parent contract. This could result in a configuration that breaks functionality.\n\nIf the minimum liveness is set above the maximum allowed by OptimisticOracleV2, any attempt by a requester or request manager to set a custom liveness will fail, even if the value is otherwise valid.\n\nThe impact is a potential denial-of-service for custom liveness configuration, preventing users from setting appropriate dispute windows. While this requires admin error, it could still disrupt protocol operations.\n",
            "severity": "Low",
            "location": [
                "ManagedOptimisticOracleV2.sol::setMinimumLiveness#207",
                "OptimisticOracleV2.sol#244-256",
                "ManagedOptimisticOracleV2.sol#284-294"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ]
            },
            "title": "Use of Storage Gaps for Upgradeability",
            "description": "The OptimisticOracleV2 contract uses the `__gap` storage pattern to reserve space for future variables in upgradeable contracts. While functional, this approach is manual and opaque, making it difficult to reason about storage layout, especially in complex inheritance hierarchies.\n\nThe cause is reliance on a legacy pattern that does not provide structured or modular storage organization. This can lead to errors during upgrades if new variables are added without careful alignment.\n\nFuture upgrades may inadvertently cause storage collisions if developers miscount the gap or fail to account for changes in parent contracts.\n\nThe impact is reduced maintainability and increased risk of storage layout corruption during upgrades, which could lead to data loss or corruption. Adopting EIP-7201 would improve clarity and safety.\n",
            "severity": "Informational",
            "location": [
                "OptimisticOracleV2.sol#__gap#998"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/OptimisticOracleV2.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Inconsistent Use of Re-entrancy Guard on `view` Functions",
            "description": "The ManagedOptimisticOracleV2 contract introduces new `external view` functions (`getCustomProposerWhitelist` and `getProposerWhitelistWithEnforcementStatus`) that do not use the `nonReentrantView` modifier, unlike similar functions in the parent OptimisticOracleV2 contract.\n\nThe cause is a deviation from the established security pattern of protecting `view` functions against re-entrancy to prevent reading inconsistent state during state changes.\n\nWhile no direct exploit was found, this inconsistency increases the attack surface and could lead to vulnerabilities if future logic changes introduce state-dependent behavior in these functions.\n\nThe impact is a weakened security posture and reduced code consistency, making the system harder to audit and maintain. It represents a missed opportunity to enforce uniform protection.\n",
            "severity": "Low",
            "location": [
                "ManagedOptimisticOracleV2.sol::getCustomProposerWhitelist#362",
                "ManagedOptimisticOracleV2.sol::getProposerWhitelistWithEnforcementStatus#381"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Code Improvement Opportunities",
            "description": "Multiple code quality issues were identified, including redundant functions (`_getManagedRequestId` and `getManagedRequestId`), unnecessary casting of `msg.sender` and `requester` to `address`, unused parameter names (`newImplementation`), redundant boolean flags in structs (`isSet`), and lack of named mapping parameters.\n\nThe root causes are suboptimal coding practices that increase gas costs, reduce readability, and complicate maintenance.\n\nThese issues do not directly enable exploits but contribute to higher deployment and transaction costs, increased code size, and reduced developer clarity.\n\nThe impact is reduced efficiency, higher operational costs, and increased risk of bugs due to code complexity. Addressing these would improve gas efficiency, readability, and long-term maintainability.\n",
            "severity": "Informational",
            "location": [
                "ManagedOptimisticOracleV2.sol::_getManagedRequestId#460-467",
                "ManagedOptimisticOracleV2.sol::getManagedRequestId#402-409",
                "ManagedOptimisticOracleV2.sol#248",
                "OptimisticOracleV2.sol#366",
                "OptimisticOracleV2.sol#457",
                "OptimisticOracleV2.sol#652",
                "ManagedOptimisticOracleV2.sol#166",
                "ManagedOptimisticOracleV2.sol#65-73"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Naming Suggestions",
            "description": "The codebase uses the term \"whitelist\", which is being phased out in favor of more neutral terms like \"allowlist\". Additionally, role constants like `REGULAR_ADMIN` and `REQUEST_MANAGER` do not follow the `_ROLE` suffix convention, and the `liveness` field in `InitializeParams` could be more clearly named `defaultLiveness`.\n\nThe cause is inconsistent naming conventions and use of outdated terminology.\n\nWhile not a security risk, this reduces code clarity and may hinder adoption by teams preferring inclusive language.\n\nThe impact is reduced readability and potential friction in community or team adoption. Standardizing naming would improve consistency and professionalism.\n",
            "severity": "Informational",
            "location": [
                "ManagedOptimisticOracleV2.sol#88",
                "ManagedOptimisticOracleV2.sol#91",
                "ManagedOptimisticOracleV2.sol#76"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-477"
                ]
            },
            "title": "Use Custom Errors",
            "description": "The contracts use `require` and `revert` with string messages for error handling, which is more expensive in terms of gas and less efficient than using custom errors introduced in Solidity 0.8.4.\n\nThe cause is the use of older error handling patterns instead of modern, gas-optimized custom errors.\n\nThis increases the deployment and execution cost of the contracts, especially for frequently called functions that include revert strings.\n\nThe impact is higher gas consumption for users and increased contract size. Migrating to custom errors would reduce costs and improve error clarity in client applications.\n",
            "severity": "Informational",
            "location": [
                "OptimisticOracleV2.sol",
                "ManagedOptimisticOracleV2.sol"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/OptimisticOracleV2.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Missing Security Contact",
            "description": "The OptimisticOracleV2, ManagedOptimisticOracleV2, AddressWhitelist, and DisableableAddressWhitelist contracts do not include a designated security contact in their NatSpec comments. This omission makes it difficult for security researchers or third-party developers to responsibly disclose vulnerabilities, potentially leading to unreported or delayed reporting of critical issues. The root cause is the absence of a `@custom:security-contact` tag in the contract documentation. While this does not directly enable an exploit, it increases the risk of undiscovered vulnerabilities persisting in production. The impact is reduced security posture and slower response time to potential threats.\n",
            "severity": "Informational",
            "location": [
                "OptimisticOracleV2.sol",
                "ManagedOptimisticOracleV2.sol",
                "AddressWhitelist.sol",
                "DisableableAddressWhitelist.sol"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/OptimisticOracleV2.sol",
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol",
                "managed-oracle/src/common/implementation/AddressWhitelist.sol",
                "managed-oracle/src/common/implementation/DisableableAddressWhitelist.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1061"
                ]
            },
            "title": "Function Visibility Overly Permissive",
            "description": "Multiple internal functions in both ManagedOptimisticOracleV2 and OptimisticOracleV2 could be set to private instead of internal, as they are not intended to be accessed by derived contracts. This includes functions such as _setMaximumBond, _setMinimumLiveness, and others. The root cause is unnecessarily broad visibility settings, which expand the attack surface by allowing potential access from unintended child contracts. An attacker could exploit this in a maliciously extended contract to manipulate internal state or bypass intended access controls. While no immediate exploit is evident, this reduces code safety and increases risk in future extensions. The impact is a weakened defense-in-depth principle and potential for future vulnerabilities in derived contracts.\n",
            "severity": "Low",
            "location": [
                "ManagedOptimisticOracleV2.sol::_setMaximumBond#416-420",
                "ManagedOptimisticOracleV2.sol::_setMinimumLiveness#427-430",
                "ManagedOptimisticOracleV2.sol::_setDefaultProposerWhitelist#436-440",
                "ManagedOptimisticOracleV2.sol::_setRequesterWhitelist#446-450",
                "ManagedOptimisticOracleV2.sol::_getManagedRequestId#460-466",
                "ManagedOptimisticOracleV2.sol::_validateBond#474-476",
                "ManagedOptimisticOracleV2.sol::_getEffectiveProposerWhitelist#498-507",
                "OptimisticOracleV2.sol::_getId#591-597",
                "OptimisticOracleV2.sol::_getState#676-696",
                "OptimisticOracleV2.sol::_getOracle#698-700",
                "OptimisticOracleV2.sol::_getStore#706-708",
                "OptimisticOracleV2.sol::_getIdentifierWhitelist#710-712",
                "OptimisticOracleV2.sol::_getTimestampForDvmRequest#714-726",
                "OptimisticOracleV2.sol::_stampAncillaryData#733-737"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol",
                "managed-oracle/src/optimistic-oracle-v2/implementation/OptimisticOracleV2.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-1188"
                ],
                "5": [
                    "CWE-453"
                ]
            },
            "title": "DisableableAddressWhitelist Is Not Enforced By Default",
            "description": "The DisableableAddressWhitelist contract has an `isEnforced` flag that defaults to false, meaning the whitelist is inactive upon deployment unless explicitly enabled. This creates a risk that the owner may mistakenly believe the whitelist is active, allowing unauthorized addresses to pass checks. The root cause is the lack of explicit initialization of the `isEnforced` flag to true in the constructor. An attacker could exploit this by interacting with the system during the window when the contract is deployed but not yet enforced, potentially gaining unauthorized access or privileges. The impact is a potential security bypass due to misconfiguration, leading to loss of access control integrity.\n",
            "severity": "Medium",
            "location": [
                "DisableableAddressWhitelist.sol#12"
            ],
            "files": [
                "managed-oracle/src/common/implementation/DisableableAddressWhitelist.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading or Incomplete Documentation",
            "description": "Several instances of incorrect or outdated NatSpec documentation were found in the codebase. For example, the @return tag for getCustomProposerWhitelist incorrectly specifies the return type, and the @dev tag for getManagedRequestId contains inaccurate information. The root cause is failure to update documentation when code changes were made. This can mislead developers and auditors, increasing the likelihood of incorrect assumptions during integration or review. While not directly exploitable, this can lead to logic errors in external systems or missed vulnerabilities during audits. The impact is reduced code clarity and increased risk of human error in dependent projects or future development.\n",
            "severity": "Informational",
            "location": [
                "ManagedOptimisticOracleV2.sol#360",
                "ManagedOptimisticOracleV2.sol#395"
            ],
            "files": [
                "managed-oracle/src/optimistic-oracle-v2/implementation/ManagedOptimisticOracleV2.sol"
            ]
        }
    ],
    "affected_files": {
        "OptimisticOracleV2.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AddressLegacy} from \"../../common/implementation/AddressLegacy.sol\";\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {StoreInterface} from \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\nimport {OracleAncillaryInterface} from\n    \"@uma/contracts/data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\nimport {FinderInterface} from \"@uma/contracts/data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport {IdentifierWhitelistInterface} from\n    \"@uma/contracts/data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport {OracleInterfaces} from \"@uma/contracts/data-verification-mechanism/implementation/Constants.sol\";\n\nimport {OptimisticOracleV2Interface} from \"../interfaces/OptimisticOracleV2Interface.sol\";\n\nimport {Testable} from \"../../common/implementation/Testable.sol\";\nimport {Lockable} from \"../../common/implementation/Lockable.sol\";\nimport {FixedPoint} from \"../../common/implementation/FixedPoint.sol\";\nimport {AncillaryData} from \"@uma/contracts/common/implementation/AncillaryData.sol\";\nimport {AddressWhitelist} from \"../../common/implementation/AddressWhitelist.sol\";\n\n/**\n * @title Optimistic Requester.\n * @notice Optional interface that requesters can implement to receive callbacks.\n * @dev this contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\n * money themselves).\n */\ninterface OptimisticRequester {\n    /**\n     * @notice Callback for proposals.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function priceProposed(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData) external;\n\n    /**\n     * @notice Callback for disputes.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param refund refund received in the case that refundOnDispute was enabled.\n     */\n    function priceDisputed(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData, uint256 refund)\n        external;\n\n    /**\n     * @notice Callback for settlement.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param price price that was resolved by the escalation process.\n     */\n    function priceSettled(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData, int256 price) external;\n}\n\n/**\n * @title Optimistic Oracle.\n * @notice Pre-DVM escalation contract that allows faster settlement.\n */\ncontract OptimisticOracleV2 is OptimisticOracleV2Interface, UUPSUpgradeable, Testable, Lockable {\n    using SafeERC20 for IERC20;\n    using AddressLegacy for address;\n\n    // Finder to provide addresses for DVM contracts.\n    FinderInterface public override finder;\n\n    // Default liveness value for all price requests.\n    uint256 public override defaultLiveness;\n\n    // This is effectively the extra ancillary data to add \",ooRequester:0000000000000000000000000000000000000000\".\n    uint256 private constant MAX_ADDED_ANCILLARY_DATA = 53;\n    uint256 public constant OO_ANCILLARY_DATA_LIMIT = ancillaryBytesLimit - MAX_ADDED_ANCILLARY_DATA;\n    int256 public constant TOO_EARLY_RESPONSE = type(int256).min;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer (external).\n     * @dev Used only for standalone deployments of the OptimisticOracleV2Upgradeable contract.\n     * @param _liveness default liveness applied to each price request.\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\n     */\n    function initialize(uint256 _liveness, address _finderAddress, address _timerAddress) external initializer {\n        __OptimisticOracleV2_init(_liveness, _finderAddress, _timerAddress);\n    }\n\n    /**\n     * @notice Initializer (internal, main entry point).\n     * @param _liveness default liveness applied to each price request.\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\n     */\n    function __OptimisticOracleV2_init(uint256 _liveness, address _finderAddress, address _timerAddress)\n        internal\n        onlyInitializing\n    {\n        __UUPSUpgradeable_init();\n        __Testable_init(_timerAddress);\n        __Lockable_init();\n        __OptimisticOracleV2_init_unchained(_liveness, _finderAddress);\n    }\n\n    /**\n     * @notice Initializer (internal, unchained).\n     * @param _liveness default liveness applied to each price request.\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\n     */\n    function __OptimisticOracleV2_init_unchained(uint256 _liveness, address _finderAddress) internal onlyInitializing {\n        finder = FinderInterface(_finderAddress);\n        _validateLiveness(_liveness);\n        defaultLiveness = _liveness;\n    }\n\n    /**\n     * @notice Authorizes UUPS upgrade.\n     * @dev This contract does not support upgrades as it is not ownable, but children can override this method.\n     */\n    function _authorizeUpgrade(address) internal virtual override {\n        revert(\"Upgrade not supported\");\n    }\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) public virtual override nonReentrant returns (uint256 totalBond) {\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\n\n        // This ensures that the ancillary data is <= the OO limit, which is lower than the DVM limit because the\n        // OO adds some data before sending to the DVM.\n        require(ancillaryData.length <= OO_ANCILLARY_DATA_LIMIT, \"Ancillary Data too long\");\n\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\n            proposer: address(0),\n            disputer: address(0),\n            currency: currency,\n            settled: false,\n            requestSettings: RequestSettings({\n                eventBased: false,\n                refundOnDispute: false,\n                callbackOnPriceProposed: false,\n                callbackOnPriceDisputed: false,\n                callbackOnPriceSettled: false,\n                bond: finalFee,\n                customLiveness: 0\n            }),\n            proposedPrice: 0,\n            resolvedPrice: 0,\n            expirationTime: 0,\n            reward: reward,\n            finalFee: finalFee\n        });\n\n        if (reward > 0) {\n            currency.safeTransferFrom(msg.sender, address(this), reward);\n        }\n\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\n\n        // This function returns the initial proposal bond for this request, which can be customized by calling\n        // setBond() with the same identifier and timestamp.\n        return finalFee * 2;\n    }\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData, uint256 bond)\n        external\n        override\n        nonReentrant\n        returns (uint256 totalBond)\n    {\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\n        request.requestSettings.bond = bond;\n\n        // Total bond is the final fee + the newly set bond.\n        return bond + request.finalFee;\n    }\n\n    /**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setRefundOnDispute(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setRefundOnDispute: Requested\"\n        );\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).requestSettings.refundOnDispute = true;\n    }\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external override nonReentrant {\n        require(\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setCustomLiveness: Requested\"\n        );\n        _validateLiveness(customLiveness);\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).requestSettings.customLiveness = customLiveness;\n    }\n\n    /**\n     * @notice Sets the request to be an \"event-based\" request.\n     * @dev Calling this method has a few impacts on the request:\n     *\n     * 1. The timestamp at which the request is evaluated is the time of the proposal, not the timestamp associated\n     *    with the request.\n     *\n     * 2. The proposer cannot propose the \"too early\" value (TOO_EARLY_RESPONSE). This is to ensure that a proposer who\n     *    prematurely proposes a response loses their bond.\n     *\n     * 3. RefundoOnDispute is automatically set, meaning disputes trigger the reward to be automatically refunded to\n     *    the requesting contract.\n     *\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setEventBased(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setEventBased: Requested\"\n        );\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\n        request.requestSettings.eventBased = true;\n        request.requestSettings.refundOnDispute = true;\n    }\n\n    /**\n     * @notice Sets which callbacks should be enabled for the request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param callbackOnPriceProposed whether to enable the callback onPriceProposed.\n     * @param callbackOnPriceDisputed whether to enable the callback onPriceDisputed.\n     * @param callbackOnPriceSettled whether to enable the callback onPriceSettled.\n     */\n    function setCallbacks(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        bool callbackOnPriceProposed,\n        bool callbackOnPriceDisputed,\n        bool callbackOnPriceSettled\n    ) external override nonReentrant {\n        require(\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setCallbacks: Requested\"\n        );\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\n        request.requestSettings.callbackOnPriceProposed = callbackOnPriceProposed;\n        request.requestSettings.callbackOnPriceDisputed = callbackOnPriceDisputed;\n        request.requestSettings.callbackOnPriceSettled = callbackOnPriceSettled;\n    }\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public virtual override nonReentrant returns (uint256 totalBond) {\n        require(proposer != address(0), \"proposer address must be non 0\");\n        require(\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Requested, \"proposePriceFor: Requested\"\n        );\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n        if (request.requestSettings.eventBased) {\n            require(proposedPrice != TOO_EARLY_RESPONSE, \"Cannot propose 'too early'\");\n        }\n        request.proposer = proposer;\n        request.proposedPrice = proposedPrice;\n\n        // If a custom liveness has been set, use it instead of the default.\n        request.expirationTime = getCurrentTime()\n            + (request.requestSettings.customLiveness != 0 ? request.requestSettings.customLiveness : defaultLiveness);\n\n        totalBond = request.requestSettings.bond + request.finalFee;\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        emit ProposePrice(\n            requester,\n            proposer,\n            identifier,\n            timestamp,\n            ancillaryData,\n            proposedPrice,\n            request.expirationTime,\n            address(request.currency)\n        );\n\n        // End the re-entrancy guard early to allow the caller to potentially take OO-related actions inside this callback.\n        _startReentrantGuardDisabled();\n        // Callback.\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceProposed) {\n            OptimisticRequester(requester).priceProposed(identifier, timestamp, ancillaryData);\n        }\n        _endReentrantGuardDisabled();\n    }\n\n    /**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\n    }\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public override nonReentrant returns (uint256 totalBond) {\n        require(disputer != address(0), \"disputer address must be non 0\");\n        require(\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Proposed, \"disputePriceFor: Proposed\"\n        );\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n        request.disputer = disputer;\n\n        uint256 finalFee = request.finalFee;\n        uint256 bond = request.requestSettings.bond;\n        totalBond = bond + finalFee;\n        if (totalBond > 0) {\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n        }\n\n        StoreInterface store = _getStore();\n\n        // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\n        // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\n        // party.\n\n        // The total fee is the burned bond and the final fee added together.\n        uint256 totalFee = finalFee + _computeBurnedBond(request);\n        if (totalFee > 0) {\n            request.currency.safeIncreaseAllowance(address(store), totalFee);\n            _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\n        }\n\n        _getOracle().requestPrice(\n            identifier, _getTimestampForDvmRequest(request, timestamp), _stampAncillaryData(ancillaryData, requester)\n        );\n\n        // Compute refund.\n        uint256 refund = 0;\n        if (request.reward > 0 && request.requestSettings.refundOnDispute) {\n            refund = request.reward;\n            request.reward = 0;\n            request.currency.safeTransfer(requester, refund);\n        }\n\n        emit DisputePrice(\n            requester, request.proposer, disputer, identifier, timestamp, ancillaryData, request.proposedPrice\n        );\n\n        // End the re-entrancy guard early to allow the caller to potentially re-request inside this callback.\n        _startReentrantGuardDisabled();\n        // Callback.\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceDisputed) {\n            OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, refund);\n        }\n        _endReentrantGuardDisabled();\n    }\n\n    /**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        external\n        override\n        returns (uint256 totalBond)\n    {\n        // Note: re-entrancy guard is done in the inner call.\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\n    }\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function settleAndGetPrice(bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        external\n        override\n        nonReentrant\n        returns (int256)\n    {\n        if (_getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\n        }\n\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\n    }\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        external\n        override\n        nonReentrant\n        returns (uint256 payout)\n    {\n        return _settle(requester, identifier, timestamp, ancillaryData);\n    }\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        public\n        view\n        override\n        nonReentrantView\n        returns (Request memory)\n    {\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\n    }\n\n    /**\n     * @notice Computes the current state of a price request. See the State enum for more details.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State.\n     */\n    function getState(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        public\n        view\n        override\n        nonReentrantView\n        returns (State)\n    {\n        return _getState(requester, identifier, timestamp, ancillaryData);\n    }\n\n    /**\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return boolean indicating true if price exists and false if not.\n     */\n    function hasPrice(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        public\n        view\n        override\n        nonReentrantView\n        returns (bool)\n    {\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\n    }\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        pure\n        override\n        returns (bytes memory)\n    {\n        return _stampAncillaryData(ancillaryData, requester);\n    }\n\n    function _getId(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(requester, identifier, timestamp, ancillaryData));\n    }\n\n    function _settle(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        private\n        returns (uint256 payout)\n    {\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\n\n        // Set it to settled so this function can never be entered again.\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n        request.settled = true;\n\n        if (state == State.Expired) {\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\n            request.resolvedPrice = request.proposedPrice;\n            payout = request.requestSettings.bond + request.finalFee + request.reward;\n            request.currency.safeTransfer(request.proposer, payout);\n        } else if (state == State.Resolved) {\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\n            request.resolvedPrice = _getOracle().getPrice(\n                identifier,\n                _getTimestampForDvmRequest(request, timestamp),\n                _stampAncillaryData(ancillaryData, requester)\n            );\n            bool disputeSuccess = request.resolvedPrice != request.proposedPrice;\n            uint256 bond = request.requestSettings.bond;\n\n            // Unburned portion of the loser's bond = 1 - burned bond.\n            uint256 unburnedBond = bond - _computeBurnedBond(request);\n\n            // Winner gets:\n            // - Their bond back.\n            // - The unburned portion of the loser's bond.\n            // - Their final fee back.\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\n            payout = bond + unburnedBond + request.finalFee + request.reward;\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\n        } else {\n            revert(\"_settle: not settleable\");\n        }\n\n        emit Settle(\n            requester,\n            request.proposer,\n            request.disputer,\n            identifier,\n            timestamp,\n            ancillaryData,\n            request.resolvedPrice,\n            payout\n        );\n\n        // Temporarily disable the re-entrancy guard early to allow the caller to take an OO-related action inside this callback.\n        _startReentrantGuardDisabled();\n        // Callback.\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceSettled) {\n            OptimisticRequester(requester).priceSettled(identifier, timestamp, ancillaryData, request.resolvedPrice);\n        }\n        _endReentrantGuardDisabled();\n    }\n\n    function _getRequest(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        internal\n        view\n        returns (Request storage)\n    {\n        return requests[_getId(requester, identifier, timestamp, ancillaryData)];\n    }\n\n    function _computeBurnedBond(Request storage request) private view returns (uint256) {\n        // burnedBond = floor(bond / 2)\n        return request.requestSettings.bond / 2;\n    }\n\n    function _validateLiveness(uint256 _liveness) internal view virtual {\n        require(_liveness < 5200 weeks, \"Liveness too large\");\n        require(_liveness > 0, \"Liveness cannot be 0\");\n    }\n\n    function _getState(address requester, bytes32 identifier, uint256 timestamp, bytes memory ancillaryData)\n        internal\n        view\n        returns (State)\n    {\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n\n        if (address(request.currency) == address(0)) return State.Invalid;\n\n        if (request.proposer == address(0)) return State.Requested;\n\n        if (request.settled) return State.Settled;\n\n        if (request.disputer == address(0)) {\n            return request.expirationTime <= getCurrentTime() ? State.Expired : State.Proposed;\n        }\n\n        return _getOracle().hasPrice(\n            identifier, _getTimestampForDvmRequest(request, timestamp), _stampAncillaryData(ancillaryData, requester)\n        ) ? State.Resolved : State.Disputed;\n    }\n\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n    }\n\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    function _getTimestampForDvmRequest(Request storage request, uint256 requestTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (request.requestSettings.eventBased) {\n            uint256 liveness =\n                request.requestSettings.customLiveness != 0 ? request.requestSettings.customLiveness : defaultLiveness;\n            return request.expirationTime - liveness;\n        } else {\n            return requestTimestamp;\n        }\n    }\n\n    /**\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\n     * ancillary data that this contract stamps.\n     */\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\n        // the original requester was.\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\n    }\n\n    function getCurrentTime() public view override(Testable, OptimisticOracleV2Interface) returns (uint256) {\n        return Testable.getCurrentTime();\n    }\n\n    /**\n     * @dev Reserve storage slots for future versions of this base contract to add state variables without affecting the\n     * storage layout of child contracts. Decrement the size of __gap whenever state variables are added. This is at the\n     * bottom of contract to make sure its always at the end of storage.\n     * See https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable#storage-gaps\n     */\n    uint256[998] private __gap;\n}\n",
        "DisableableAddressWhitelist.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport {AddressWhitelistInterface} from \"../interfaces/AddressWhitelistInterface.sol\";\nimport {DisableableAddressWhitelistInterface} from \"../interfaces/DisableableAddressWhitelistInterface.sol\";\nimport {AddressWhitelist} from \"./AddressWhitelist.sol\";\n\n/**\n * @title A contract to track a whitelist of addresses with ability to toggle its enforcement.\n */\ncontract DisableableAddressWhitelist is AddressWhitelist, DisableableAddressWhitelistInterface {\n    bool public isEnforced;\n\n    event WhitelistEnforcementSet(bool enforced);\n\n    /**\n     * @notice Disables or enables the whitelist restrictions.\n     * @param enforced True to enforce the whitelist, False to disable it.\n     */\n    function setWhitelistEnforcement(bool enforced) external nonReentrant onlyOwner {\n        isEnforced = enforced;\n        emit WhitelistEnforcementSet(enforced);\n    }\n\n    /**\n     * @notice Checks whether an address is on the whitelist and if the whitelist is enabled.\n     * @param elementToCheck the address to check.\n     * @return True if whitelist enforcement is disabled, or if the address is whitelisted when enforcement is enabled.\n     */\n    function isOnWhitelist(address elementToCheck)\n        public\n        view\n        override(AddressWhitelist, AddressWhitelistInterface)\n        nonReentrantView\n        returns (bool)\n    {\n        return !isEnforced || super.isOnWhitelist(elementToCheck);\n    }\n}\n",
        "AddressWhitelist.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport {AddressWhitelistInterface} from \"../interfaces/AddressWhitelistInterface.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Lockable} from \"@uma/contracts/common/implementation/Lockable.sol\";\n\n/**\n * @title A contract to track a whitelist of addresses.\n */\ncontract AddressWhitelist is AddressWhitelistInterface, Ownable, Lockable {\n    enum Status {\n        None,\n        In,\n        Out\n    }\n\n    mapping(address => Status) public whitelist;\n\n    address[] public whitelistIndices;\n\n    event AddedToWhitelist(address indexed addedAddress);\n    event RemovedFromWhitelist(address indexed removedAddress);\n\n    /**\n     * @notice Constructor to initialize the contract.\n     * @dev This makes it compatible with v5.x of OpenZeppelin's Ownable contract.\n     */\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n    function addToWhitelist(address newElement) external override nonReentrant onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n    function removeFromWhitelist(address elementToRemove) external override nonReentrant onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }\n\n    /**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n    function isOnWhitelist(address elementToCheck) public view virtual override nonReentrantView returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }\n\n    /**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n    function getWhitelist() external view override nonReentrantView returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }\n}\n",
        "ManagedOptimisticOracleV2.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport {AccessControlDefaultAdminRulesUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {DisableableAddressWhitelistInterface} from \"../../common/interfaces/DisableableAddressWhitelistInterface.sol\";\nimport {MultiCaller} from \"../../common/implementation/MultiCaller.sol\";\n\nimport {OptimisticOracleV2} from \"./OptimisticOracleV2.sol\";\n\n/**\n * @title Events emitted by the ManagedOptimisticOracleV2 contract.\n * @notice Contains events for request manager management, bond and liveness updates, and whitelists.\n */\nabstract contract ManagedOptimisticOracleV2Events {\n    event RequestManagerAdded(address indexed requestManager);\n    event RequestManagerRemoved(address indexed requestManager);\n    event MaximumBondUpdated(IERC20 indexed currency, uint256 newMaximumBond);\n    event MinimumLivenessUpdated(uint256 newMinimumLiveness);\n    event DefaultProposerWhitelistUpdated(address indexed newWhitelist);\n    event RequesterWhitelistUpdated(address indexed newWhitelist);\n    event CustomBondSet(\n        bytes32 indexed managedRequestId,\n        address requester,\n        bytes32 indexed identifier,\n        bytes ancillaryData,\n        IERC20 indexed currency,\n        uint256 bond\n    );\n    event CustomLivenessSet(\n        bytes32 indexed managedRequestId,\n        address indexed requester,\n        bytes32 indexed identifier,\n        bytes ancillaryData,\n        uint256 customLiveness\n    );\n    event CustomProposerWhitelistSet(\n        bytes32 indexed managedRequestId,\n        address requester,\n        bytes32 indexed identifier,\n        bytes ancillaryData,\n        address indexed newWhitelist\n    );\n}\n\n/**\n * @title Managed Optimistic Oracle V2.\n * @notice Pre-DVM escalation contract that allows faster settlement and management of price requests.\n */\ncontract ManagedOptimisticOracleV2 is\n    UUPSUpgradeable,\n    ManagedOptimisticOracleV2Events,\n    OptimisticOracleV2,\n    AccessControlDefaultAdminRulesUpgradeable,\n    MultiCaller\n{\n    struct MaximumBond {\n        IERC20 currency;\n        uint256 amount;\n    }\n\n    struct CustomBond {\n        uint256 amount;\n        bool isSet;\n    }\n\n    struct CustomLiveness {\n        uint256 liveness;\n        bool isSet;\n    }\n\n    struct InitializeParams {\n        uint256 liveness; // default liveness applied to each price request.\n        address finderAddress; // finder to use to get addresses of DVM contracts.\n        address timerAddress; // address of the timer contract. Should be 0x0 in prod.\n        address defaultProposerWhitelist; // address of the default whitelist.\n        address requesterWhitelist; // address of the requester whitelist.\n        MaximumBond[] maximumBonds; // array of maximum bonds for different currencies.\n        uint256 minimumLiveness; // minimum liveness that can be overridden for a request.\n        address regularAdmin; // regular admin, which is used for managing request managers and contract parameters.\n        address upgradeAdmin; // contract upgrade admin, which also can manage the regular admin role.\n    }\n\n    // Regular admin role is used to manage request managers and set other default parameters.\n    bytes32 public constant REGULAR_ADMIN = keccak256(\"REGULAR_ADMIN\");\n\n    // Request manager role is used to manage proposer whitelists, bonds, and liveness for individual requests.\n    bytes32 public constant REQUEST_MANAGER = keccak256(\"REQUEST_MANAGER\");\n\n    // Default whitelist for proposers.\n    DisableableAddressWhitelistInterface public defaultProposerWhitelist;\n    DisableableAddressWhitelistInterface public requesterWhitelist;\n\n    // Custom bonds set by request managers for specific request and currency combinations.\n    mapping(bytes32 => mapping(IERC20 => CustomBond)) public customBonds;\n\n    // Custom liveness values set by request managers for specific requests.\n    mapping(bytes32 => CustomLiveness) public customLivenessValues;\n\n    // Custom proposer whitelists set by request managers for specific requests.\n    mapping(bytes32 => DisableableAddressWhitelistInterface) public customProposerWhitelists;\n\n    // Admin controlled bounds limiting the changes that can be made by request managers.\n    mapping(IERC20 => uint256) public maximumBonds; // Maximum bonds for a given currency.\n    uint256 public minimumLiveness;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer.\n     * @param params Initialization parameters, see InitializeParams struct for details.\n     * @dev Struct parameter is used to overcome the stack too deep limitations in Solidity.\n     */\n    function initialize(InitializeParams calldata params) external initializer {\n        __OptimisticOracleV2_init(params.liveness, params.finderAddress, params.timerAddress);\n        __AccessControlDefaultAdminRules_init(3 days, params.upgradeAdmin); // Initialize DEFAULT_ADMIN_ROLE\n\n        // Regular admin is managing the request manager role.\n        // Contract upgrade admin retains the default admin role that can also manage the regular admin role.\n        _grantRole(REGULAR_ADMIN, params.regularAdmin);\n        _setRoleAdmin(REQUEST_MANAGER, REGULAR_ADMIN);\n\n        _setDefaultProposerWhitelist(params.defaultProposerWhitelist);\n        _setRequesterWhitelist(params.requesterWhitelist);\n        for (uint256 i = 0; i < params.maximumBonds.length; i++) {\n            _setMaximumBond(params.maximumBonds[i].currency, params.maximumBonds[i].amount);\n        }\n        _setMinimumLiveness(params.minimumLiveness);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the upgrade admin.\n     */\n    modifier onlyUpgradeAdmin() {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the regular admin.\n     */\n    modifier onlyRegularAdmin() {\n        _checkRole(REGULAR_ADMIN);\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the request manager.\n     */\n    modifier onlyRequestManager() {\n        _checkRole(REQUEST_MANAGER);\n        _;\n    }\n\n    /**\n     * @notice Authorizes the upgrade of the contract.\n     * @dev This is required for UUPSUpgradeable. Only the upgrade admin can authorize upgrades.\n     * @param newImplementation address of the new implementation to upgrade to.\n     */\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override(OptimisticOracleV2, UUPSUpgradeable)\n        onlyUpgradeAdmin\n    {}\n\n    /**\n     * @notice Adds a request manager.\n     * @dev Only callable by the regular admin (checked in grantRole of AccessControlUpgradeable).\n     * @param requestManager address of the request manager to set.\n     */\n    function addRequestManager(address requestManager) external nonReentrant {\n        grantRole(REQUEST_MANAGER, requestManager);\n        emit RequestManagerAdded(requestManager);\n    }\n\n    /**\n     * @notice Removes a request manager.\n     * @dev Only callable by the regular admin (checked in revokeRole of AccessControlUpgradeable).\n     * @param requestManager address of the request manager to remove.\n     */\n    function removeRequestManager(address requestManager) external nonReentrant {\n        revokeRole(REQUEST_MANAGER, requestManager);\n        emit RequestManagerRemoved(requestManager);\n    }\n\n    /**\n     * @notice Sets the maximum bond that can be set for a request.\n     * @dev This can be used to limit the bond amount that can be set by request managers, callable by the regular admin.\n     * @param currency the ERC20 token used for bonding proposals and disputes. Must be approved for use with the DVM.\n     * @param maximumBond new maximum bond amount.\n     */\n    function setMaximumBond(IERC20 currency, uint256 maximumBond) external nonReentrant onlyRegularAdmin {\n        _setMaximumBond(currency, maximumBond);\n    }\n\n    /**\n     * @notice Sets the minimum liveness that can be set for a request.\n     * @dev This can be used to limit the liveness period that can be set by request managers, callable by the regular admin.\n     * @param _minimumLiveness new minimum liveness period.\n     */\n    function setMinimumLiveness(uint256 _minimumLiveness) external nonReentrant onlyRegularAdmin {\n        _setMinimumLiveness(_minimumLiveness);\n    }\n\n    /**\n     * @notice Sets the default proposer whitelist.\n     * @dev Only callable by the regular admin.\n     * @param whitelist address of the whitelist to set.\n     */\n    function setDefaultProposerWhitelist(address whitelist) external nonReentrant onlyRegularAdmin {\n        _setDefaultProposerWhitelist(whitelist);\n    }\n\n    /**\n     * @notice Sets the requester whitelist.\n     * @dev Only callable by the regular admin.\n     * @param whitelist address of the whitelist to set.\n     */\n    function setRequesterWhitelist(address whitelist) external nonReentrant onlyRegularAdmin {\n        _setRequesterWhitelist(whitelist);\n    }\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) public override returns (uint256 totalBond) {\n        require(requesterWhitelist.isOnWhitelist(address(msg.sender)), \"Requester not whitelisted\");\n        return super.requestPrice(identifier, timestamp, ancillaryData, currency, reward);\n    }\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @dev This would also override any subsequent calls to setBond() by the requester.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param bond custom bond amount to set.\n     */\n    function requestManagerSetBond(\n        address requester,\n        bytes32 identifier,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 bond\n    ) external nonReentrant onlyRequestManager {\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        _validateBond(currency, bond);\n        bytes32 managedRequestId = _getManagedRequestId(requester, identifier, ancillaryData);\n        customBonds[managedRequestId][currency] = CustomBond({amount: bond, isSet: true});\n        emit CustomBondSet(managedRequestId, requester, identifier, ancillaryData, currency, bond);\n    }\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @dev This would also override any subsequent calls to setLiveness() by the requester.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function requestManagerSetCustomLiveness(\n        address requester,\n        bytes32 identifier,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external nonReentrant onlyRequestManager {\n        _validateLiveness(customLiveness);\n        bytes32 managedRequestId = _getManagedRequestId(requester, identifier, ancillaryData);\n        customLivenessValues[managedRequestId] = CustomLiveness({liveness: customLiveness, isSet: true});\n        emit CustomLivenessSet(managedRequestId, requester, identifier, ancillaryData, customLiveness);\n    }\n\n    /**\n     * @notice Sets the proposer whitelist for a request.\n     * @dev This can also be set in advance of the request as the timestamp is omitted from the mapping key derivation.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param whitelist address of the whitelist to set.\n     */\n    function requestManagerSetProposerWhitelist(\n        address requester,\n        bytes32 identifier,\n        bytes memory ancillaryData,\n        address whitelist\n    ) external nonReentrant onlyRequestManager {\n        bytes32 managedRequestId = _getManagedRequestId(requester, identifier, ancillaryData);\n        customProposerWhitelists[managedRequestId] = DisableableAddressWhitelistInterface(whitelist);\n        emit CustomProposerWhitelistSet(managedRequestId, requester, identifier, ancillaryData, whitelist);\n    }\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public override returns (uint256 totalBond) {\n        // Apply the custom bond and liveness overrides if set.\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n        bytes32 managedRequestId = _getManagedRequestId(requester, identifier, ancillaryData);\n        if (customBonds[managedRequestId][request.currency].isSet) {\n            request.requestSettings.bond = customBonds[managedRequestId][request.currency].amount;\n        }\n        if (customLivenessValues[managedRequestId].isSet) {\n            request.requestSettings.customLiveness = customLivenessValues[managedRequestId].liveness;\n        }\n\n        DisableableAddressWhitelistInterface whitelist =\n            _getEffectiveProposerWhitelist(requester, identifier, ancillaryData);\n\n        require(whitelist.isOnWhitelist(proposer), \"Proposer not whitelisted\");\n        require(whitelist.isOnWhitelist(msg.sender), \"Sender not whitelisted\");\n        return super.proposePriceFor(proposer, requester, identifier, timestamp, ancillaryData, proposedPrice);\n    }\n\n    /**\n     * @notice Gets the custom proposer whitelist for a request.\n     * @dev This omits the timestamp from the key derivation, so the whitelist might have been set in advance of the\n     * request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return AddressWhitelistInterface the custom proposer whitelist for the request or zero address if not set.\n     */\n    function getCustomProposerWhitelist(address requester, bytes32 identifier, bytes memory ancillaryData)\n        external\n        view\n        returns (DisableableAddressWhitelistInterface)\n    {\n        return customProposerWhitelists[_getManagedRequestId(requester, identifier, ancillaryData)];\n    }\n\n    /**\n     * @notice Returns the proposer whitelist and enforcement status for a given request.\n     * @dev If no custom proposer whitelist is set for the request, the default proposer whitelist is used.\n     * If whitelist enforcement is disabled, the returned proposer list will be empty and isEnforced will be false,\n     * indicating that any address is allowed to propose.\n     * @param requester The address that made or will make the price request.\n     * @param identifier The identifier of the price request.\n     * @param ancillaryData Additional data used to uniquely identify the request.\n     * @return allowedProposers The list of addresses allowed to propose, if enforcement is enabled. Otherwise, an empty array.\n     * @return isEnforced A boolean indicating whether whitelist enforcement is active for this request.\n     */\n    function getProposerWhitelistWithEnforcementStatus(\n        address requester,\n        bytes32 identifier,\n        bytes memory ancillaryData\n    ) external view returns (address[] memory allowedProposers, bool isEnforced) {\n        DisableableAddressWhitelistInterface whitelist =\n            _getEffectiveProposerWhitelist(requester, identifier, ancillaryData);\n        isEnforced = whitelist.isEnforced();\n        allowedProposers = isEnforced ? whitelist.getWhitelist() : new address[](0);\n        return (allowedProposers, isEnforced);\n    }\n\n    /**\n     * @notice Gets the managed request ID for a price request (without timestamp).\n     * @dev This is just a helper function that offchain systems can use for tracking the indexed\n     * CustomProposerWhitelistSet events.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return bytes32 the request ID for the managed request.\n     */\n    function getManagedRequestId(address requester, bytes32 identifier, bytes memory ancillaryData)\n        external\n        pure\n        returns (bytes32)\n    {\n        return _getManagedRequestId(requester, identifier, ancillaryData);\n    }\n\n    /**\n     * @notice Sets the maximum bond that can be set for a request.\n     * @dev This can be used to limit the bond amount that can be set by request managers.\n     * @param currency the ERC20 token used for bonding proposals and disputes. Must be approved for use with the DVM.\n     * @param maximumBond new maximum bond amount for the given currency.\n     */\n    function _setMaximumBond(IERC20 currency, uint256 maximumBond) internal {\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        maximumBonds[currency] = maximumBond;\n        emit MaximumBondUpdated(currency, maximumBond);\n    }\n\n    /**\n     * @notice Sets the minimum liveness that can be set for a request.\n     * @dev This can be used to limit the liveness period that can be set by request managers.\n     * @param _minimumLiveness new minimum liveness period.\n     */\n    function _setMinimumLiveness(uint256 _minimumLiveness) internal {\n        minimumLiveness = _minimumLiveness;\n        emit MinimumLivenessUpdated(_minimumLiveness);\n    }\n\n    /**\n     * @notice Sets the default proposer whitelist.\n     * @param whitelist address of the whitelist to set.\n     */\n    function _setDefaultProposerWhitelist(address whitelist) internal {\n        require(whitelist != address(0), \"Whitelist cannot be zero address\");\n        defaultProposerWhitelist = DisableableAddressWhitelistInterface(whitelist);\n        emit DefaultProposerWhitelistUpdated(whitelist);\n    }\n\n    /**\n     * @notice Sets the requester whitelist.\n     * @param whitelist address of the whitelist to set.\n     */\n    function _setRequesterWhitelist(address whitelist) internal {\n        require(whitelist != address(0), \"Whitelist cannot be zero address\");\n        requesterWhitelist = DisableableAddressWhitelistInterface(whitelist);\n        emit RequesterWhitelistUpdated(whitelist);\n    }\n\n    /**\n     * @notice Gets the ID for a managed request.\n     * @dev This omits the timestamp from the key derivation, so it can be used for managed requests in advance.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return bytes32 the ID for the managed request.\n     */\n    function _getManagedRequestId(address requester, bytes32 identifier, bytes memory ancillaryData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(requester, identifier, ancillaryData));\n    }\n\n    /**\n     * @notice Validates the bond amount.\n     * @dev Reverts if the bond exceeds the maximum bond amount (controllable by the regular admin).\n     * @param currency the ERC20 token used for bonding proposals and disputes. Must be approved for use with the DVM.\n     * @param bond the bond amount to validate.\n     */\n    function _validateBond(IERC20 currency, uint256 bond) internal view {\n        require(bond <= maximumBonds[currency], \"Bond exceeds maximum bond\");\n    }\n\n    /**\n     * @notice Validates the liveness period.\n     * @dev Reverts if the liveness period is less than the minimum liveness (controllable by the regular admin) or\n     * above the maximum liveness (which is set in the parent contract).\n     * @param liveness the liveness period to validate.\n     */\n    function _validateLiveness(uint256 liveness) internal view override {\n        require(liveness >= minimumLiveness, \"Liveness is less than minimum\");\n        super._validateLiveness(liveness);\n    }\n\n    /**\n     * @notice Gets the effective proposer whitelist contract for a given request.\n     * @dev Returns the custom proposer whitelist if set; otherwise falls back to the default. Timestamp is omitted from\n     * the key derivation, so this can be used for checks before the request is made.\n     * @param requester The address that made or will make the price request.\n     * @param identifier The identifier of the price request.\n     * @param ancillaryData Additional data used to uniquely identify the request.\n     * @return whitelist The effective DisableableAddressWhitelistInterface for the request.\n     */\n    function _getEffectiveProposerWhitelist(address requester, bytes32 identifier, bytes memory ancillaryData)\n        internal\n        view\n        returns (DisableableAddressWhitelistInterface whitelist)\n    {\n        whitelist = customProposerWhitelists[_getManagedRequestId(requester, identifier, ancillaryData)];\n        if (address(whitelist) == address(0)) {\n            whitelist = defaultProposerWhitelist;\n        }\n    }\n}\n"
    }
}