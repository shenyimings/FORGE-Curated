{
    "vfp_id": "vfp_00059",
    "project_name": "cantina_centrifuge_may2025.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Gateway contract deployment fails when deployer != msg.sender",
            "description": "The Gateway contract fails to deploy when the deployer parameter differs from msg.sender because the constructor makes an internal call to setRefundAddress, which is protected by an auth modifier. The auth mechanism grants privileges only to the deployer argument, but the runtime msg.sender during construction is the actual transaction sender. If they differ, the internal call reverts. The root cause is a mismatch between the authorization model and constructor execution context. This could be exploited by a malicious deployment proxy or factory that manipulates the deployer parameter, preventing successful deployment. The impact is denial of deployment in proxy-based or forwarded deployment scenarios, limiting deployment flexibility.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Gateway repay and retry actions do not adhere to Checks-Effects-Interactions guidelines",
            "description": "The Gateway contract's repay and retry functions do not follow the Checks-Effects-Interactions (CEI) pattern. They perform external calls before updating internal state, which deviates from secure Solidity practices. While there is no immediate exploit because the state is eventually updated and the functions are permissioned, this pattern increases risk in case of unexpected reentrancy or future code changes. The root cause is improper function design. An attacker would need to compromise the Gateway contract first to exploit this, so the risk is low. The impact is reduced code safety and maintainability, making the system more vulnerable to future bugs.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        }
    ],
    "affected_files": {
        "Gateway.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {ArrayLib} from \"src/misc/libraries/ArrayLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {Recoverable, IRecoverable, ETH_ADDRESS} from \"src/misc/Recoverable.sol\";\nimport {TransientArrayLib} from \"src/misc/libraries/TransientArrayLib.sol\";\nimport {TransientBytesLib} from \"src/misc/libraries/TransientBytesLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {IGasService} from \"src/common/interfaces/IGasService.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {IMessageProcessor} from \"src/common/interfaces/IMessageProcessor.sol\";\nimport {IMessageSender} from \"src/common/interfaces/IMessageSender.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {IGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\n\n/// @title  Gateway\n/// @notice Routing contract that forwards outgoing messages to multiple adapters (1 full message, n-1 proofs)\n///         and validates that multiple adapters have confirmed a message.\n///\n///         Supports batching multiple messages, as well as paying for methods manually or through pool-level subsidies.\n///\n///         Supports processing multiple duplicate messages in parallel by storing counts of messages\n///         and proofs that have been received. Also implements a retry method for failed messages.\ncontract Gateway is Auth, Recoverable, IGateway {\n    using BytesLib for bytes;\n    using MathLib for uint256;\n    using MessageProofLib for *;\n    using ArrayLib for uint16[8];\n    using TransientStorageLib for bytes32;\n\n    uint8 public constant MAX_ADAPTER_COUNT = 8;\n    uint8 public constant PRIMARY_ADAPTER_ID = 1;\n    PoolId public constant GLOBAL_POT = PoolId.wrap(0);\n    uint256 public constant RECOVERY_CHALLENGE_PERIOD = 7 days;\n    bytes32 public constant BATCH_LOCATORS_SLOT = bytes32(uint256(keccak256(\"Centrifuge/batch-locators\")) - 1);\n\n    uint16 public immutable localCentrifugeId;\n\n    // Dependencies\n    IRoot public immutable root;\n    IGasService public gasService;\n    IMessageProcessor public processor;\n\n    // Outbound & payments\n    bool public transient isBatching;\n    uint256 public transient fuel;\n    address public transient transactionRefund;\n    mapping(PoolId => Funds) public subsidy;\n    mapping(uint16 centrifugeId => mapping(bytes32 batchHash => uint256)) public underpaid;\n\n    // Adapters\n    mapping(uint16 centrifugeId => IAdapter[]) public adapters;\n    mapping(uint16 centrifugeId => mapping(IAdapter adapter => Adapter)) internal _activeAdapters;\n\n    // Inbound & recoveries\n    mapping(uint16 centrifugeId => mapping(bytes32 messageHash => uint256)) public failedMessages;\n    mapping(uint16 centrifugeId => mapping(bytes32 batchHash => InboundBatch)) public inboundBatch;\n    mapping(uint16 centrifugeId => mapping(IAdapter adapter => mapping(bytes32 payloadHash => uint256 timestamp)))\n        public recoveries;\n\n    constructor(uint16 localCentrifugeId_, IRoot root_, IGasService gasService_, address deployer) Auth(deployer) {\n        localCentrifugeId = localCentrifugeId_;\n        root = root_;\n        gasService = gasService_;\n\n        setRefundAddress(GLOBAL_POT, IRecoverable(address(this)));\n    }\n\n    modifier pauseable() {\n        require(!root.paused(), Paused());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGateway\n    function file(bytes32 what, uint16 centrifugeId, IAdapter[] calldata addresses) external auth {\n        if (what == \"adapters\") {\n            uint8 quorum_ = addresses.length.toUint8();\n            require(quorum_ != 0, EmptyAdapterSet());\n            require(quorum_ <= MAX_ADAPTER_COUNT, ExceedsMax());\n\n            // Increment session id to reset pending votes\n            uint256 numAdapters = adapters[centrifugeId].length;\n            uint64 sessionId =\n                numAdapters > 0 ? _activeAdapters[centrifugeId][adapters[centrifugeId][0]].activeSessionId + 1 : 0;\n\n            // Disable old adapters\n            for (uint8 i; i < numAdapters; i++) {\n                delete _activeAdapters[centrifugeId][adapters[centrifugeId][i]];\n            }\n\n            // Enable new adapters, setting quorum to number of adapters\n            for (uint8 j; j < quorum_; j++) {\n                require(_activeAdapters[centrifugeId][addresses[j]].id == 0, NoDuplicatesAllowed());\n\n                // Ids are assigned sequentially starting at 1\n                _activeAdapters[centrifugeId][addresses[j]] = Adapter(j + 1, quorum_, sessionId);\n            }\n\n            adapters[centrifugeId] = addresses;\n        } else {\n            revert FileUnrecognizedParam();\n        }\n\n        emit File(what, centrifugeId, addresses);\n    }\n\n    /// @inheritdoc IGateway\n    function file(bytes32 what, address instance) external auth {\n        if (what == \"gasService\") gasService = IGasService(instance);\n        else if (what == \"processor\") processor = IMessageProcessor(instance);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, instance);\n    }\n\n    receive() external payable {\n        _subsidizePool(GLOBAL_POT, msg.sender, msg.value);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev Handle an inbound payload\n    function handle(uint16 centrifugeId, bytes calldata payload) external pauseable {\n        _handle(centrifugeId, payload, IAdapter(msg.sender), false);\n    }\n\n    function _handle(uint16 centrifugeId, bytes calldata payload, IAdapter adapter_, bool isRecovery) internal {\n        Adapter memory adapter = _activeAdapters[centrifugeId][adapter_];\n        require(adapter.id != 0, InvalidAdapter());\n\n        IMessageProcessor processor_ = processor;\n        if (processor_.isMessageRecovery(payload)) {\n            require(!isRecovery, RecoveryPayloadRecovered());\n            return processor_.handle(centrifugeId, payload);\n        }\n\n        bool isMessageProof = payload.toUint8(0) == MessageProofLib.MESSAGE_PROOF_ID;\n\n        // Verify adapter and parse message hash\n        bytes32 batchHash;\n        if (isMessageProof) {\n            require(adapter.id != PRIMARY_ADAPTER_ID, NonProofAdapter());\n\n            batchHash = payload.deserializeMessageProof();\n            bytes32 payloadId = keccak256(abi.encodePacked(centrifugeId, localCentrifugeId, batchHash));\n            emit HandleProof(centrifugeId, payloadId, batchHash, adapter_);\n        } else {\n            require(adapter.id == PRIMARY_ADAPTER_ID, NonBatchAdapter());\n\n            batchHash = keccak256(payload);\n            bytes32 payloadId = keccak256(abi.encodePacked(centrifugeId, localCentrifugeId, batchHash));\n            emit HandleBatch(centrifugeId, payloadId, payload, adapter_);\n        }\n\n        // Special case for gas efficiency\n        if (adapter.quorum == 1 && !isMessageProof) {\n            _handleBatch(centrifugeId, payload);\n            return;\n        }\n\n        InboundBatch storage state = inboundBatch[centrifugeId][batchHash];\n\n        if (adapter.activeSessionId != state.sessionId) {\n            // Clear votes from previous session\n            delete state.votes;\n            state.sessionId = adapter.activeSessionId;\n        }\n\n        // Increase vote\n        state.votes[adapter.id - 1]++;\n\n        if (state.votes.countNonZeroValues() >= adapter.quorum) {\n            // Reduce votes by quorum\n            state.votes.decreaseFirstNValues(adapter.quorum);\n\n            if (isMessageProof) {\n                _handleBatch(centrifugeId, state.pendingBatch);\n            } else {\n                _handleBatch(centrifugeId, payload);\n            }\n\n            // Only if there are no more pending messages, remove the pending message\n            if (state.votes.isEmpty()) {\n                delete state.pendingBatch;\n            }\n        } else if (!isMessageProof) {\n            state.pendingBatch = payload;\n        }\n    }\n\n    function _handleBatch(uint16 centrifugeId, bytes memory batch_) internal {\n        IMessageProcessor processor_ = processor;\n        bytes memory remaining = batch_;\n\n        while (remaining.length > 0) {\n            uint256 length = processor_.messageLength(remaining);\n            bytes memory message = remaining.slice(0, length);\n            remaining = remaining.slice(length, remaining.length - length);\n\n            try processor_.handle(centrifugeId, message) {\n                emit ExecuteMessage(centrifugeId, message);\n            } catch (bytes memory err) {\n                bytes32 messageHash = keccak256(message);\n                failedMessages[centrifugeId][messageHash]++;\n                emit FailMessage(centrifugeId, message, err);\n            }\n        }\n    }\n\n    function retry(uint16 centrifugeId, bytes memory message) external pauseable {\n        bytes32 messageHash = keccak256(message);\n        require(failedMessages[centrifugeId][messageHash] > 0, NotFailedMessage());\n\n        processor.handle(centrifugeId, message);\n        failedMessages[centrifugeId][messageHash]--;\n\n        emit ExecuteMessage(centrifugeId, message);\n    }\n\n    /// @inheritdoc IGatewayHandler\n    function initiateRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external auth {\n        require(_activeAdapters[centrifugeId][adapter].id != 0, InvalidAdapter());\n        recoveries[centrifugeId][adapter][payloadHash] = block.timestamp + RECOVERY_CHALLENGE_PERIOD;\n        emit InitiateRecovery(centrifugeId, payloadHash, adapter);\n    }\n\n    /// @inheritdoc IGatewayHandler\n    function disputeRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external auth {\n        delete recoveries[centrifugeId][adapter][payloadHash];\n        emit DisputeRecovery(centrifugeId, payloadHash, adapter);\n    }\n\n    /// @inheritdoc IGateway\n    function executeRecovery(uint16 centrifugeId, IAdapter adapter, bytes calldata payload) external {\n        bytes32 payloadHash = keccak256(payload);\n        uint256 recovery = recoveries[centrifugeId][adapter][payloadHash];\n\n        require(recovery != 0, RecoveryNotInitiated());\n        require(recovery <= block.timestamp, RecoveryChallengePeriodNotEnded());\n\n        delete recoveries[centrifugeId][adapter][payloadHash];\n        _handle(centrifugeId, payload, adapter, true);\n        emit ExecuteRecovery(centrifugeId, payload, adapter);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageSender\n    function send(uint16 centrifugeId, bytes calldata message) external pauseable auth {\n        require(message.length > 0, EmptyMessage());\n\n        PoolId poolId = processor.messagePoolId(message);\n\n        emit PrepareMessage(centrifugeId, poolId, message);\n\n        if (isBatching) {\n            bytes32 batchSlot = _outboundBatchSlot(centrifugeId, poolId);\n            bytes memory previousMessage = TransientBytesLib.get(batchSlot);\n\n            bytes32 gasLimitSlot = _gasLimitSlot(centrifugeId, poolId);\n            uint128 newGasLimit = gasLimitSlot.tloadUint128() + gasService.gasLimit(centrifugeId, message);\n            require(newGasLimit <= gasService.maxBatchSize(centrifugeId), ExceedsMaxBatchSize());\n            gasLimitSlot.tstore(uint256(newGasLimit));\n\n            if (previousMessage.length == 0) {\n                TransientArrayLib.push(BATCH_LOCATORS_SLOT, _encodeLocator(centrifugeId, poolId));\n            }\n\n            TransientBytesLib.append(batchSlot, message);\n        } else {\n            _send(centrifugeId, poolId, message);\n            _refundTransaction();\n        }\n    }\n\n    function _send(uint16 centrifugeId, PoolId poolId, bytes memory batch) internal returns (bool succeeded) {\n        IAdapter[] memory adapters_ = adapters[centrifugeId];\n        require(adapters[centrifugeId].length != 0, EmptyAdapterSet());\n\n        SendData memory data = SendData({\n            batchHash: keccak256(batch),\n            batchGasLimit: (isBatching)\n                ? _gasLimitSlot(centrifugeId, poolId).tloadUint128()\n                : gasService.gasLimit(centrifugeId, batch),\n            payloadId: bytes32(\"\"),\n            gasCost: new uint256[](MAX_ADAPTER_COUNT)\n        });\n        data.payloadId = keccak256(abi.encodePacked(localCentrifugeId, centrifugeId, data.batchHash));\n\n        // Estimate gas usage\n        uint256 total;\n        for (uint256 i; i < adapters_.length; i++) {\n            data.gasCost[i] = adapters_[i].estimate(\n                centrifugeId,\n                i == PRIMARY_ADAPTER_ID - 1 ? batch : data.batchHash.serializeMessageProof(),\n                data.batchGasLimit\n            );\n\n            total += data.gasCost[i];\n        }\n\n        // Ensure sufficient funds are available\n        if (transactionRefund != address(0)) {\n            require(total <= fuel, NotEnoughTransactionGas());\n            fuel -= total;\n        } else {\n            if (total > subsidy[poolId].value) {\n                _requestPoolFunding(poolId);\n            }\n\n            if (total <= subsidy[poolId].value) {\n                subsidy[poolId].value -= uint96(total);\n            } else {\n                underpaid[centrifugeId][data.batchHash]++;\n                emit UnderpaidBatch(centrifugeId, batch);\n                return false;\n            }\n        }\n\n        // Send batch and proofs\n        for (uint256 j; j < adapters_.length; j++) {\n            bytes32 adapterData = adapters_[j].send{value: data.gasCost[j]}(\n                centrifugeId,\n                j == PRIMARY_ADAPTER_ID - 1 ? batch : data.batchHash.serializeMessageProof(),\n                data.batchGasLimit,\n                transactionRefund != address(0) ? transactionRefund : address(subsidy[poolId].refund)\n            );\n\n            if (j == PRIMARY_ADAPTER_ID - 1) {\n                emit SendBatch(\n                    centrifugeId,\n                    data.payloadId,\n                    batch,\n                    adapters_[j],\n                    adapterData,\n                    transactionRefund != address(0) ? transactionRefund : address(subsidy[poolId].refund)\n                );\n            } else {\n                emit SendProof(\n                    centrifugeId,\n                    data.payloadId,\n                    data.batchHash,\n                    adapters_[j],\n                    adapterData\n                );\n            }\n        }\n\n        return true;\n    }\n\n    /// @inheritdoc IGateway\n    function repay(uint16 centrifugeId, bytes memory batch) external payable pauseable {\n        bytes32 batchHash = keccak256(batch);\n        require(underpaid[centrifugeId][batchHash] > 0, NotUnderpaidBatch());\n\n        PoolId poolId = processor.messagePoolId(batch);\n        if (msg.value > 0) subsidizePool(poolId);\n\n        require(_send(centrifugeId, poolId, batch), InsufficientFundsForRepayment());\n        underpaid[centrifugeId][batchHash]--;\n\n        emit RepayBatch(centrifugeId, batch);\n    }\n\n    function _refundTransaction() internal {\n        if (transactionRefund == address(0)) return;\n\n        // Reset before external call\n        uint256 fuel_ = fuel;\n        address transactionRefund_ = transactionRefund;\n        fuel = 0;\n        transactionRefund = address(0);\n\n        if (fuel_ > 0) {\n            (bool success,) = payable(transactionRefund_).call{value: fuel_}(new bytes(0));\n\n            if (!success) {\n                // If refund fails, move remaining fuel to global pot\n                _subsidizePool(GLOBAL_POT, transactionRefund_, fuel_);\n            }\n        }\n    }\n\n    function _requestPoolFunding(PoolId poolId) internal {\n        IRecoverable refund = subsidy[poolId].refund;\n        if (!poolId.isNull() && address(refund) != address(0)) {\n            uint256 refundBalance = address(refund).balance;\n            if (refundBalance == 0) return;\n\n            // Send to the gateway GLOBAL_POT\n            refund.recoverTokens(ETH_ADDRESS, address(this), refundBalance);\n\n            // Extract from the GLOBAL_POT\n            subsidy[GLOBAL_POT].value -= uint96(refundBalance);\n            _subsidizePool(poolId, address(refund), refundBalance);\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function setRefundAddress(PoolId poolId, IRecoverable refund) public auth {\n        subsidy[poolId].refund = refund;\n        emit SetRefundAddress(poolId, refund);\n    }\n\n    /// @inheritdoc IGateway\n    function subsidizePool(PoolId poolId) public payable {\n        require(address(subsidy[poolId].refund) != address(0), RefundAddressNotSet());\n        _subsidizePool(poolId, msg.sender, msg.value);\n    }\n\n    function _subsidizePool(PoolId poolId, address who, uint256 value) internal {\n        subsidy[poolId].value += uint96(value);\n        emit SubsidizePool(poolId, who, value);\n    }\n\n    /// @inheritdoc IGateway\n    function payTransaction(address payer) external payable auth {\n        transactionRefund = payer;\n        fuel += msg.value;\n    }\n\n    /// @inheritdoc IGateway\n    function startBatching() external auth {\n        isBatching = true;\n    }\n\n    /// @inheritdoc IGateway\n    function endBatching() external auth {\n        require(isBatching, NoBatched());\n\n        bytes32[] memory locators = TransientArrayLib.getBytes32(BATCH_LOCATORS_SLOT);\n        for (uint256 i; i < locators.length; i++) {\n            (uint16 centrifugeId, PoolId poolId) = _parseLocator(locators[i]);\n            bytes32 outboundBatchSlot = _outboundBatchSlot(centrifugeId, poolId);\n\n            _send(centrifugeId, poolId, TransientBytesLib.get(outboundBatchSlot));\n\n            TransientBytesLib.clear(outboundBatchSlot);\n            _gasLimitSlot(centrifugeId, poolId).tstore(uint256(0));\n        }\n\n        TransientArrayLib.clear(BATCH_LOCATORS_SLOT);\n        isBatching = false;\n\n        _refundTransaction();\n    }\n\n    function _encodeLocator(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return bytes32(abi.encodePacked(bytes2(centrifugeId), bytes8(poolId.raw())));\n    }\n\n    function _parseLocator(bytes32 locator) internal pure returns (uint16 centrifugeId, PoolId poolId) {\n        centrifugeId = uint16(bytes2(locator));\n        poolId = PoolId.wrap(uint64(bytes8(locator << 16)));\n    }\n\n    function _gasLimitSlot(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"batchGasLimit\", centrifugeId, poolId));\n    }\n\n    function _outboundBatchSlot(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"outboundBatch\", centrifugeId, poolId));\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGateway\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256 total) {\n        bytes memory proof = keccak256(payload).serializeMessageProof();\n\n        uint256 gasLimit = 0;\n        for (uint256 pos; pos < payload.length;) {\n            bytes calldata inner = payload[pos:payload.length];\n            gasLimit += gasService.gasLimit(centrifugeId, inner);\n            pos += processor.messageLength(inner);\n        }\n\n        uint256 adaptersCount = adapters[centrifugeId].length;\n        for (uint256 i; i < adaptersCount; i++) {\n            bytes memory message = i == PRIMARY_ADAPTER_ID - 1 ? payload : proof;\n            total += IAdapter(adapters[centrifugeId][i]).estimate(centrifugeId, message, gasLimit);\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function quorum(uint16 centrifugeId) external view returns (uint8) {\n        Adapter memory adapter = _activeAdapters[centrifugeId][adapters[centrifugeId][0]];\n        return adapter.quorum;\n    }\n\n    /// @inheritdoc IGateway\n    function activeSessionId(uint16 centrifugeId) external view returns (uint64) {\n        Adapter memory adapter = _activeAdapters[centrifugeId][adapters[centrifugeId][0]];\n        return adapter.activeSessionId;\n    }\n\n    /// @inheritdoc IGateway\n    function votes(uint16 centrifugeId, bytes32 batchHash) external view returns (uint16[MAX_ADAPTER_COUNT] memory) {\n        return inboundBatch[centrifugeId][batchHash].votes;\n    }\n}\n\n"
    }
}