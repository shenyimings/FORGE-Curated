{
    "vfp_id": "vfp_00232",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "MitosisVault._setCap() may underflow",
            "description": "The `_setCap` function in `MitosisVault` calculates `prevSpent` as `prevCap - assetInfo.availableCap`, which can underflow if `availableCap` exceeds `prevCap`. This can occur after a large withdrawal increases `availableCap` beyond the previous cap. When `setCap` is called afterward, the subtraction `prevCap - assetInfo.availableCap` will revert due to underflow. This prevents administrators from updating caps, disrupting liquidity management and potentially freezing deposit operations even when intended to be adjustable.\n",
            "severity": "Low",
            "location": [
                "MitosisVault.sol#L206-L216"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/MitosisVault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Interaction with entrypoints does not return excess native",
            "description": "Several functions that interact with the entrypoint, such as `deposit`, require users to send `msg.value` for cross-chain fees. However, the entrypoint does not return any excess native tokens after deducting the actual fee, causing the leftover ETH to remain stuck in the contract. This is particularly problematic for users of `MitosisVaultDepositProxy`, who expect unused funds to be refunded. The root cause is the direct use of `_Router_dispatch` without handling the difference between sent and used value. This leads to a loss of user funds and reduces trust in the system's reliability.\n",
            "severity": "Medium",
            "location": [
                "MitosisVault.sol#L123",
                "MitosisVaultDepositProxy.sol#L165",
                "MitosisVaultVLF.sol#L108"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/MitosisVault.sol"
            ]
        }
    ],
    "affected_files": {
        "MitosisVault.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { IERC20 } from '@oz/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@oz/token/ERC20/utils/SafeERC20.sol';\nimport { Address } from '@oz/utils/Address.sol';\nimport { Math } from '@oz/utils/math/Math.sol';\nimport { AccessControlEnumerableUpgradeable } from '@ozu/access/extensions/AccessControlEnumerableUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { AssetAction, IMitosisVault } from '../interfaces/branch/IMitosisVault.sol';\nimport { IMitosisVaultEntrypoint } from '../interfaces/branch/IMitosisVaultEntrypoint.sol';\nimport { ERC7201Utils } from '../lib/ERC7201Utils.sol';\nimport { Pausable } from '../lib/Pausable.sol';\nimport { StdError } from '../lib/StdError.sol';\nimport { Versioned } from '../lib/Versioned.sol';\nimport { MitosisVaultVLF } from './MitosisVaultVLF.sol';\n\ncontract MitosisVault is\n  IMitosisVault,\n  Pausable,\n  AccessControlEnumerableUpgradeable,\n  UUPSUpgradeable,\n  MitosisVaultVLF,\n  Versioned\n{\n  using SafeERC20 for IERC20;\n  using ERC7201Utils for string;\n\n  /// @dev Role for managing caps\n  bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256('LIQUIDITY_MANAGER_ROLE');\n\n  struct AssetInfo {\n    bool initialized;\n    uint256 maxCap;\n    uint256 availableCap;\n    mapping(AssetAction => bool) isHalted;\n  }\n\n  struct StorageV1 {\n    IMitosisVaultEntrypoint entrypoint;\n    mapping(address asset => AssetInfo) assets;\n  }\n\n  string private constant _NAMESPACE = 'mitosis.storage.MitosisVaultStorage.v1';\n  bytes32 private immutable _slot = _NAMESPACE.storageSlot();\n\n  function _getStorageV1() internal view returns (StorageV1 storage $) {\n    bytes32 slot = _slot;\n    // slither-disable-next-line assembly\n    assembly {\n      $.slot := slot\n    }\n  }\n\n  //=========== NOTE: INITIALIZATION FUNCTIONS ===========//\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    revert StdError.NotSupported();\n  }\n\n  receive() external payable {\n    revert StdError.NotSupported();\n  }\n\n  function initialize(address owner_) public initializer {\n    __Pausable_init();\n    __AccessControl_init();\n    __AccessControlEnumerable_init();\n    __UUPSUpgradeable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n  }\n\n  //=========== NOTE: VIEW FUNCTIONS ===========//\n\n  function maxCap(address asset) external view returns (uint256) {\n    return _getStorageV1().assets[asset].maxCap;\n  }\n\n  function availableCap(address asset) external view returns (uint256) {\n    return _getStorageV1().assets[asset].availableCap;\n  }\n\n  function isAssetActionHalted(address asset, AssetAction action) external view returns (bool) {\n    return _isHalted(_getStorageV1(), asset, action);\n  }\n\n  function isAssetInitialized(address asset) external view returns (bool) {\n    return _isAssetInitialized(_getStorageV1(), asset);\n  }\n\n  function entrypoint() external view override returns (address) {\n    return address(_getStorageV1().entrypoint);\n  }\n\n  function quoteDeposit(address asset, address to, uint256 amount) external view returns (uint256) {\n    return _getStorageV1().entrypoint.quoteDeposit(asset, to, amount);\n  }\n\n  //=========== NOTE: MUTATIVE - ASSET FUNCTIONS ===========//\n\n  function initializeAsset(address asset) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertAssetNotInitialized($, asset);\n\n    $.assets[asset].initialized = true;\n    emit AssetInitialized(asset);\n\n    // NOTE: we halt deposit and keep the cap at zero by default.\n    _haltAsset($, asset, AssetAction.Deposit);\n  }\n\n  function deposit(address asset, address to, uint256 amount) external payable whenNotPaused {\n    _deposit(asset, to, amount);\n\n    _entrypoint().deposit{ value: msg.value }(asset, to, amount, _msgSender());\n\n    emit Deposited(asset, to, amount);\n  }\n\n  function withdraw(address asset, address to, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertAssetInitialized(asset);\n\n    $.assets[asset].availableCap += amount;\n\n    IERC20(asset).safeTransfer(to, amount);\n\n    emit Withdrawn(asset, to, amount);\n  }\n\n  //=========== NOTE: MUTATIVE - ROLE BASED FUNCTIONS ===========//\n\n  function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }\n\n  function _authorizePause(address) internal view override onlyRole(DEFAULT_ADMIN_ROLE) { }\n\n  function setEntrypoint(address entrypoint_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _getStorageV1().entrypoint = IMitosisVaultEntrypoint(entrypoint_);\n    emit EntrypointSet(address(entrypoint_));\n  }\n\n  function setCap(address asset, uint256 newCap) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n    _assertAssetInitialized(asset);\n\n    _setCap($, asset, newCap);\n  }\n\n  function haltAsset(address asset, AssetAction action) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n    _assertAssetInitialized(asset);\n    return _haltAsset($, asset, action);\n  }\n\n  function resumeAsset(address asset, AssetAction action) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n    _assertAssetInitialized(asset);\n    return _resumeAsset($, asset, action);\n  }\n\n  //=========== NOTE: INTERNAL FUNCTIONS ===========//\n\n  function _entrypoint() internal view override returns (IMitosisVaultEntrypoint) {\n    return IMitosisVaultEntrypoint(_getStorageV1().entrypoint);\n  }\n\n  function _assertOnlyEntrypoint(StorageV1 storage $) internal view {\n    require(_msgSender() == address($.entrypoint), StdError.Unauthorized());\n  }\n\n  function _assertCapNotExceeded(StorageV1 storage $, address asset, uint256 amount) internal view {\n    uint256 available = $.assets[asset].availableCap;\n    require(available >= amount, IMitosisVault__ExceededCap(asset, amount, available));\n  }\n\n  function _assertAssetInitialized(address asset) internal view override {\n    require(_isAssetInitialized(_getStorageV1(), asset), IMitosisVault__AssetNotInitialized(asset));\n  }\n\n  function _assertAssetNotInitialized(StorageV1 storage $, address asset) internal view {\n    require(!_isAssetInitialized($, asset), IMitosisVault__AssetAlreadyInitialized(asset));\n  }\n\n  function _assertNotHalted(StorageV1 storage $, address asset, AssetAction action) internal view {\n    require(!_isHalted($, asset, action), StdError.Halted());\n  }\n\n  function _isHalted(StorageV1 storage $, address asset, AssetAction action) internal view returns (bool) {\n    return $.assets[asset].isHalted[action];\n  }\n\n  function _isAssetInitialized(StorageV1 storage $, address asset) internal view returns (bool) {\n    return $.assets[asset].initialized;\n  }\n\n  function _setCap(StorageV1 storage $, address asset, uint256 newCap) internal {\n    AssetInfo storage assetInfo = $.assets[asset];\n\n    uint256 prevCap = assetInfo.maxCap;\n    uint256 prevSpent = prevCap - assetInfo.availableCap;\n\n    assetInfo.maxCap = newCap;\n    assetInfo.availableCap = newCap - Math.min(prevSpent, newCap);\n\n    emit CapSet(_msgSender(), asset, prevCap, newCap);\n  }\n\n  function _haltAsset(StorageV1 storage $, address asset, AssetAction action) internal {\n    $.assets[asset].isHalted[action] = true;\n    emit AssetHalted(asset, action);\n  }\n\n  function _resumeAsset(StorageV1 storage $, address asset, AssetAction action) internal {\n    $.assets[asset].isHalted[action] = false;\n    emit AssetResumed(asset, action);\n  }\n\n  function _deposit(address asset, address to, uint256 amount) internal override {\n    StorageV1 storage $ = _getStorageV1();\n    require(to != address(0), StdError.ZeroAddress('to'));\n    require(amount != 0, StdError.ZeroAmount());\n\n    _assertAssetInitialized(asset);\n    _assertNotHalted($, asset, AssetAction.Deposit);\n    _assertCapNotExceeded($, asset, amount);\n\n    $.assets[asset].availableCap -= amount;\n    IERC20(asset).safeTransferFrom(_msgSender(), address(this), amount);\n  }\n}\n"
    }
}