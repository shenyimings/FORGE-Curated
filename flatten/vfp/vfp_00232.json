{
    "vfp_id": "vfp_00232",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "MitosisVaultEntrypoint._dispatchToMitosis() should call _GasRouter_dispatch() instead of _Router_dispatch()",
            "description": "The `_dispatchToMitosis` function uses `_GasRouter_quoteDispatch` to calculate the fee but then calls `_Router_dispatch` directly, bypassing the `_GasRouter_dispatch` wrapper. This is problematic because `_GasRouter_dispatch` applies specific `_hookMetadata` (such as gas limit overrides) that are necessary for correct cross-chain message execution. Using mismatched dispatch mechanisms can lead to incorrect gas estimation, failed message relays, or inconsistent behavior across chains. The inconsistency between quoting and dispatching introduces a reliability risk in cross-chain operations.\n",
            "severity": "Medium",
            "location": [
                "MitosisVaultEntrypoint.sol#L172-L186"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/MitosisVaultEntrypoint.sol"
            ]
        }
    ],
    "affected_files": {
        "MitosisVaultEntrypoint.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { StandardHookMetadata } from '@hpl/hooks/libs/StandardHookMetadata.sol';\nimport { IMessageRecipient } from '@hpl/interfaces/IMessageRecipient.sol';\n\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { GasRouter } from '../external/hyperlane/GasRouter.sol';\nimport { IMitosisVault } from '../interfaces/branch/IMitosisVault.sol';\nimport { IMitosisVaultEntrypoint } from '../interfaces/branch/IMitosisVaultEntrypoint.sol';\nimport { Conv } from '../lib/Conv.sol';\nimport { StdError } from '../lib/StdError.sol';\nimport { Versioned } from '../lib/Versioned.sol';\nimport '../message/Message.sol';\n\ncontract MitosisVaultEntrypoint is\n  IMitosisVaultEntrypoint,\n  IMessageRecipient,\n  Ownable2StepUpgradeable,\n  GasRouter,\n  UUPSUpgradeable,\n  Versioned\n{\n  using Message for *;\n  using Conv for *;\n\n  IMitosisVault internal immutable _vault;\n  uint32 internal immutable _mitosisDomain;\n  bytes32 internal immutable _mitosisAddr; // Hub.AssetManagerEntrypoint\n\n  modifier onlyVault() {\n    require(_msgSender() == address(_vault), StdError.InvalidAddress('vault'));\n    _;\n  }\n\n  constructor(address mailbox, address vault_, uint32 mitosisDomain_, bytes32 mitosisAddr_)\n    GasRouter(mailbox)\n    initializer\n  {\n    _vault = IMitosisVault(vault_);\n    _mitosisDomain = mitosisDomain_;\n    _mitosisAddr = mitosisAddr_;\n  }\n\n  function initialize(address owner_, address hook, address ism) public initializer {\n    __UUPSUpgradeable_init();\n\n    __Ownable_init(_msgSender());\n    __Ownable2Step_init();\n\n    _MailboxClient_initialize(hook, ism);\n    _transferOwnership(owner_);\n    _enrollRemoteRouter(_mitosisDomain, _mitosisAddr);\n  }\n\n  function vault() external view returns (IMitosisVault) {\n    return _vault;\n  }\n\n  function mitosisDomain() external view returns (uint32) {\n    return _mitosisDomain;\n  }\n\n  function mitosisAddr() external view returns (bytes32) {\n    return _mitosisAddr;\n  }\n\n  function quoteDeposit(address asset, address to, uint256 amount) external view returns (uint256) {\n    bytes memory enc = MsgDeposit({ asset: asset.toBytes32(), to: to.toBytes32(), amount: amount }).encode();\n    return _quoteToMitosis(enc, MsgType.MsgDeposit);\n  }\n\n  function quoteDepositWithSupplyVLF(address asset, address to, address hubVLFVault, uint256 amount)\n    external\n    view\n    returns (uint256)\n  {\n    bytes memory enc = MsgDepositWithSupplyVLF({\n      asset: asset.toBytes32(),\n      to: to.toBytes32(),\n      vlfVault: hubVLFVault.toBytes32(),\n      amount: amount\n    }).encode();\n    return _quoteToMitosis(enc, MsgType.MsgDepositWithSupplyVLF);\n  }\n\n  function quoteDeallocateVLF(address hubVLFVault, uint256 amount) external view returns (uint256) {\n    bytes memory enc = MsgDeallocateVLF({ vlfVault: hubVLFVault.toBytes32(), amount: amount }).encode();\n    return _quoteToMitosis(enc, MsgType.MsgDeallocateVLF);\n  }\n\n  function quoteSettleVLFYield(address hubVLFVault, uint256 amount) external view returns (uint256) {\n    bytes memory enc = MsgSettleVLFYield({ vlfVault: hubVLFVault.toBytes32(), amount: amount }).encode();\n    return _quoteToMitosis(enc, MsgType.MsgSettleVLFYield);\n  }\n\n  function quoteSettleVLFLoss(address hubVLFVault, uint256 amount) external view returns (uint256) {\n    bytes memory enc = MsgSettleVLFLoss({ vlfVault: hubVLFVault.toBytes32(), amount: amount }).encode();\n    return _quoteToMitosis(enc, MsgType.MsgSettleVLFLoss);\n  }\n\n  function quoteSettleVLFExtraRewards(address hubVLFVault, address reward, uint256 amount)\n    external\n    view\n    returns (uint256)\n  {\n    bytes memory enc = MsgSettleVLFExtraRewards({\n      vlfVault: hubVLFVault.toBytes32(),\n      reward: reward.toBytes32(),\n      amount: amount\n    }).encode();\n    return _quoteToMitosis(enc, MsgType.MsgSettleVLFExtraRewards);\n  }\n\n  function _quoteToMitosis(bytes memory enc, MsgType msgType) internal view returns (uint256) {\n    uint96 action = uint96(msgType);\n    uint256 fee = _GasRouter_quoteDispatch(_mitosisDomain, action, enc, address(hook()));\n    return fee;\n  }\n\n  //=========== NOTE: VAULT FUNCTIONS ===========//\n\n  function deposit(address asset, address to, uint256 amount, address refundTo) external payable onlyVault {\n    bytes memory enc = MsgDeposit({ asset: asset.toBytes32(), to: to.toBytes32(), amount: amount }).encode();\n    _dispatchToMitosis(enc, MsgType.MsgDeposit, refundTo);\n  }\n\n  function depositWithSupplyVLF(address asset, address to, address hubVLFVault, uint256 amount, address refundTo)\n    external\n    payable\n    onlyVault\n  {\n    bytes memory enc = MsgDepositWithSupplyVLF({\n      asset: asset.toBytes32(),\n      to: to.toBytes32(),\n      vlfVault: hubVLFVault.toBytes32(),\n      amount: amount\n    }).encode();\n    _dispatchToMitosis(enc, MsgType.MsgDepositWithSupplyVLF, refundTo);\n  }\n\n  function deallocateVLF(address hubVLFVault, uint256 amount, address refundTo) external payable onlyVault {\n    bytes memory enc = MsgDeallocateVLF({ vlfVault: hubVLFVault.toBytes32(), amount: amount }).encode();\n    _dispatchToMitosis(enc, MsgType.MsgDeallocateVLF, refundTo);\n  }\n\n  function settleVLFYield(address hubVLFVault, uint256 amount, address refundTo) external payable onlyVault {\n    bytes memory enc = MsgSettleVLFYield({ vlfVault: hubVLFVault.toBytes32(), amount: amount }).encode();\n    _dispatchToMitosis(enc, MsgType.MsgSettleVLFYield, refundTo);\n  }\n\n  function settleVLFLoss(address hubVLFVault, uint256 amount, address refundTo) external payable onlyVault {\n    bytes memory enc = MsgSettleVLFLoss({ vlfVault: hubVLFVault.toBytes32(), amount: amount }).encode();\n    _dispatchToMitosis(enc, MsgType.MsgSettleVLFLoss, refundTo);\n  }\n\n  function settleVLFExtraRewards(address hubVLFVault, address reward, uint256 amount, address refundTo)\n    external\n    payable\n    onlyVault\n  {\n    bytes memory enc = MsgSettleVLFExtraRewards({\n      vlfVault: hubVLFVault.toBytes32(),\n      reward: reward.toBytes32(),\n      amount: amount\n    }).encode();\n    _dispatchToMitosis(enc, MsgType.MsgSettleVLFExtraRewards, refundTo);\n  }\n\n  function _dispatchToMitosis(bytes memory enc, MsgType msgType, address refundTo) internal {\n    uint96 action = uint96(msgType);\n\n    uint256 gasLimit = _getHplGasRouterStorage().destinationGas[_mitosisDomain][action];\n    require(gasLimit > 0, GasRouter__GasLimitNotSet(_mitosisDomain, action));\n\n    uint256 fee = _GasRouter_quoteDispatch(_mitosisDomain, action, enc, address(hook()));\n    _Router_dispatch(\n      _mitosisDomain,\n      fee,\n      enc,\n      StandardHookMetadata.formatMetadata(uint256(0), gasLimit, refundTo, bytes('')),\n      address(hook())\n    );\n  }\n\n  //=========== NOTE: HANDLER FUNCTIONS ===========//\n\n  function _handle(uint32 origin, bytes32 sender, bytes calldata msg_) internal override {\n    require(origin == _mitosisDomain && sender == _mitosisAddr, StdError.Unauthorized());\n\n    MsgType msgType = msg_.msgType();\n\n    if (msgType == MsgType.MsgInitializeAsset) {\n      MsgInitializeAsset memory decoded = msg_.decodeInitializeAsset();\n      _vault.initializeAsset(decoded.asset.toAddress());\n    }\n\n    if (msgType == MsgType.MsgWithdraw) {\n      MsgWithdraw memory decoded = msg_.decodeWithdraw();\n      _vault.withdraw(decoded.asset.toAddress(), decoded.to.toAddress(), decoded.amount);\n    }\n\n    if (msgType == MsgType.MsgInitializeVLF) {\n      MsgInitializeVLF memory decoded = msg_.decodeInitializeVLF();\n      _vault.initializeVLF(decoded.vlfVault.toAddress(), decoded.asset.toAddress());\n    }\n\n    if (msgType == MsgType.MsgAllocateVLF) {\n      MsgAllocateVLF memory decoded = msg_.decodeAllocateVLF();\n      _vault.allocateVLF(decoded.vlfVault.toAddress(), decoded.amount);\n    }\n  }\n\n  //=========== NOTE: OWNABLE FUNCTIONS ===========//\n\n  function _authorizeUpgrade(address) internal override onlyOwner { }\n\n  function _authorizeConfigureGas(address) internal override onlyOwner { }\n\n  function _authorizeConfigureRoute(address) internal override onlyOwner { }\n\n  function _authorizeManageMailbox(address) internal override onlyOwner { }\n}\n"
    }
}