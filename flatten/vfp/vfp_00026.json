{
    "vfp_id": "vfp_00026",
    "project_name": "cantina_uniswap_nov2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Unchecked Fee Parameter in setDefaultFeeByFeeTier() Causes Downstream Pool Reverts and Protocol Fee Update DoS",
            "description": "1. **Description:** The `setDefaultFeeByFeeTier()` function in `V3FeeAdapter.sol` accepts an unvalidated `uint8` value for `defaultFeeValue`, which is later decomposed into two 4-bit components used to set protocol fees in Uniswap V3 pools. If the value leads to invalid fee components, it causes downstream pool reverts.\n2. **Cause:** The function lacks input validation to ensure the decomposed fee values (from `defaultFeeValue % 16` and `defaultFeeValue >> 4`) comply with the Uniswap V3 pool's requirement that each must be 0 or in the range [4,10].\n3. **Exploitation:** A malicious or mistaken caller could set an invalid `defaultFeeValue` (e.g., 255), causing all subsequent `_setProtocolFee()` calls for that fee tier to revert.\n4. **Impact:** This results in a denial of service for protocol fee updates on affected fee tiers until the value is corrected, potentially delaying critical fee adjustments.\n",
            "severity": "Low",
            "location": [
                "V3FeeAdapter.sol::setDefaultFeeByFeeTier#98"
            ],
            "files": [
                "protocol-fees/src/feeAdapters/V3FeeAdapter.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Unnecessary Type Casting in collect() Function",
            "description": "1. **Description:** The `collect()` function in `V3FeeAdapter.sol` unnecessarily casts the return values of `collectProtocol()` from `uint128` to `uint256` and back to `uint128`, increasing gas consumption.\n2. **Cause:** Poor type handling in variable declaration, where `uint256` is used instead of the correct `uint128` type matching the return values.\n3. **Exploitation:** This is not exploitable in a malicious sense but represents inefficient code.\n4. **Impact:** Increased gas costs for users calling the `collect()` function, leading to higher transaction fees and reduced efficiency.\n",
            "severity": "Informational",
            "location": [
                "V3FeeAdapter.sol::collect#83-87"
            ],
            "files": [
                "protocol-fees/src/feeAdapters/V3FeeAdapter.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Missing Docstrings",
            "description": "1. **Description:** Multiple contracts and functions across the codebase lack proper NatSpec documentation (docstrings), including `ArrayLib.sol`, `Deployer.sol`, `Nonce.sol`, and `V3FeeAdapter.sol`.\n2. **Cause:** Incomplete or missing documentation during development.\n3. **Exploitation:** This cannot be exploited maliciously but reduces code readability and maintainability.\n4. **Impact:** Makes it harder for developers, auditors, and users to understand the intended behavior of functions and contracts, increasing the risk of future errors or misinterpretations.\n",
            "severity": "Informational",
            "location": [
                "Nonce.sol#6",
                "Deployer.sol#13",
                "V3FeeAdapter.sol#71",
                "ArrayLib.sol#4"
            ],
            "files": [
                "protocol-fees/src/libraries/ArrayLib.sol",
                "protocol-fees/src/Deployer.sol",
                "protocol-fees/src/base/Nonce.sol",
                "protocol-fees/src/feeAdapters/V3FeeAdapter.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emission for key storage changes",
            "description": "1. **Description:** Key state-changing functions such as `setMerkleRoot`, `setDefaultFeeByFeeTier`, `setReleaser`, and `setThreshold` do not emit events, making it difficult to track changes off-chain.\n2. **Cause:** Lack of event emission in state-modifying functions.\n3. **Exploitation:** This cannot be exploited directly but reduces transparency.\n4. **Impact:** External systems and users cannot reliably monitor critical configuration changes, potentially leading to delayed responses or incorrect assumptions about contract state.\n",
            "severity": "Informational",
            "location": [
                "V3FeeAdapter.sol::setMerkleRoot#94",
                "V3FeeAdapter.sol::setFeeSetter#100",
                "V3FeeAdapter.sol::setDefaultFeeByFeeTier#105",
                "TokenJar.sol::setReleaser#41"
            ],
            "files": [
                "protocol-fees/src/feeAdapters/V3FeeAdapter.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ],
                "4": [
                    "CWE-1188"
                ],
                "5": [
                    "CWE-453"
                ]
            },
            "title": "Unconfigured default fee values for fee tiers",
            "description": "1. **Description:** The `Deployer.sol` contract sets up fee tiers in `V3FeeAdapter` but fails to initialize default fee values, leaving protocol fees disabled by default.\n2. **Cause:** Omission in the deployment logic to configure default fees before transferring ownership to the DAO.\n3. **Exploitation:** No active exploitation, but the protocol starts in a suboptimal state.\n4. **Impact:** Protocol fees remain at 0% until a governance proposal is passed, delaying revenue generation and requiring unnecessary governance overhead.\n",
            "severity": "Informational",
            "location": [
                "Deployer.sol#60"
            ],
            "files": [
                "protocol-fees/src/Deployer.sol"
            ]
        }
    ],
    "affected_files": {
        "V3FeeAdapter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {\n  IUniswapV3PoolOwnerActions\n} from \"v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\";\nimport {MerkleProof} from \"openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\nimport {IV3FeeAdapter} from \"../interfaces/IV3FeeAdapter.sol\";\nimport {ArrayLib} from \"../libraries/ArrayLib.sol\";\n\n/// @title V3FeeAdapter\n/// @notice A contract that allows the setting and collecting of protocol fees per pool, and adding\n/// new fee tiers to the Uniswap V3 Factory.\n/// @dev This contract is ownable. The owner can set the merkle root for proving protocol fee\n/// amounts per pool, set new fee tiers on Uniswap V3, and change the owner of this contract.\n/// Note that this contract will be the set owner on the Uniswap V3 Factory.\n/// @custom:security-contact security@uniswap.org\ncontract V3FeeAdapter is IV3FeeAdapter, Owned {\n  using ArrayLib for uint24[];\n\n  /// @inheritdoc IV3FeeAdapter\n  IUniswapV3Factory public immutable FACTORY;\n  /// @inheritdoc IV3FeeAdapter\n  address public immutable TOKEN_JAR;\n\n  /// @inheritdoc IV3FeeAdapter\n  bytes32 public merkleRoot;\n\n  /// @inheritdoc IV3FeeAdapter\n  address public feeSetter;\n\n  /// @inheritdoc IV3FeeAdapter\n  mapping(uint24 feeTier => uint8 defaultFeeValue) public defaultFees;\n\n  /// @return The fee tiers that are enabled on the factory. Iterable so that the protocol fee for\n  /// pools of the same pair can be activated with the same merkle proof.\n  /// @dev Returns four enabled fee tiers: 100, 500, 3000, 10000. May return more if more are\n  /// enabled.\n  uint24[] public feeTiers;\n\n  /// @notice Ensures only the fee setter can call the setMerkleRoot and setDefaultFeeByFeeTier\n  /// functions\n  modifier onlyFeeSetter() {\n    require(msg.sender == feeSetter, Unauthorized());\n    _;\n  }\n\n  /// @dev At construction, the fee setter defaults to 0 and its on the owner to set.\n  constructor(address _factory, address _tokenJar) Owned(msg.sender) {\n    FACTORY = IUniswapV3Factory(_factory);\n    TOKEN_JAR = _tokenJar;\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function storeFeeTier(uint24 feeTier) public {\n    require(_feeTierExists(feeTier), InvalidFeeTier());\n    require(!feeTiers.includes(feeTier), TierAlreadyStored());\n    feeTiers.push(feeTier);\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function enableFeeAmount(uint24 fee, int24 tickSpacing) external onlyOwner {\n    FACTORY.enableFeeAmount(fee, tickSpacing);\n\n    storeFeeTier(fee);\n  }\n\n  function setFactoryOwner(address newOwner) external onlyOwner {\n    FACTORY.setOwner(newOwner);\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function collect(CollectParams[] calldata collectParams)\n    external\n    returns (Collected[] memory amountsCollected)\n  {\n    amountsCollected = new Collected[](collectParams.length);\n    for (uint256 i = 0; i < collectParams.length; i++) {\n      CollectParams calldata params = collectParams[i];\n      (uint256 amount0Collected, uint256 amount1Collected) = IUniswapV3PoolOwnerActions(params.pool)\n        .collectProtocol(TOKEN_JAR, params.amount0Requested, params.amount1Requested);\n\n      amountsCollected[i] = Collected({\n        amount0Collected: uint128(amount0Collected), amount1Collected: uint128(amount1Collected)\n      });\n    }\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyFeeSetter {\n    merkleRoot = _merkleRoot;\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function setDefaultFeeByFeeTier(uint24 feeTier, uint8 defaultFeeValue) external onlyFeeSetter {\n    require(_feeTierExists(feeTier), InvalidFeeTier());\n    defaultFees[feeTier] = defaultFeeValue;\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function setFeeSetter(address newFeeSetter) external onlyOwner {\n    feeSetter = newFeeSetter;\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function triggerFeeUpdate(address pool, bytes32[] calldata proof) external {\n    bytes32 node = _doubleHash(IUniswapV3Pool(pool).token0(), IUniswapV3Pool(pool).token1());\n    if (!MerkleProof.verify(proof, merkleRoot, node)) revert InvalidProof();\n\n    _setProtocolFee(pool, IUniswapV3Pool(pool).fee());\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function triggerFeeUpdate(address token0, address token1, bytes32[] calldata proof) external {\n    bytes32 node = _doubleHash(token0, token1);\n    if (!MerkleProof.verify(proof, merkleRoot, node)) revert InvalidProof();\n\n    _setProtocolFeesForPair(token0, token1);\n  }\n\n  /// @inheritdoc IV3FeeAdapter\n  function batchTriggerFeeUpdate(\n    Pair[] calldata pairs,\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags\n  ) external {\n    bytes32[] memory leaves = new bytes32[](pairs.length);\n    Pair memory pair;\n    for (uint256 i; i < pairs.length; i++) {\n      pair = pairs[i];\n      leaves[i] = _doubleHash(pair.token0, pair.token1);\n      _setProtocolFeesForPair(pair.token0, pair.token1);\n    }\n    require(MerkleProof.multiProofVerify(proof, proofFlags, merkleRoot, leaves), InvalidProof());\n  }\n\n  function _setProtocolFeesForPair(address token0, address token1) internal {\n    uint24 feeTier;\n    address pool;\n    uint256 length = feeTiers.length;\n    for (uint256 i; i < length; i++) {\n      feeTier = feeTiers[i];\n      pool = FACTORY.getPool(token0, token1, feeTier);\n      if (pool != address(0)) _setProtocolFee(pool, feeTier);\n    }\n  }\n\n  function _setProtocolFee(address pool, uint24 feeTier) internal {\n    // Check if pool is initialized by verifying sqrtPriceX96 is non-zero\n    (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();\n    if (sqrtPriceX96 == 0) return; // Pool exists but not initialized, skip\n\n    uint8 feeValue = defaultFees[feeTier];\n    IUniswapV3PoolOwnerActions(pool).setFeeProtocol(feeValue % 16, feeValue >> 4);\n  }\n\n  function _doubleHash(address token0, address token1) internal pure returns (bytes32 poolHash) {\n    // keccak256(abi.encode(keccak256(abi.encode(token0, token1))));\n    assembly (\"memory-safe\") {\n      mstore(0x00, and(token0, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(0x20, and(token1, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(0x00, keccak256(0x00, 0x40))\n      poolHash := keccak256(0x00, 0x20)\n    }\n  }\n\n  function _feeTierExists(uint24 feeTier) internal view returns (bool) {\n    if (FACTORY.feeAmountTickSpacing(feeTier) == 0) return false;\n    return true;\n  }\n}\n",
        "ArrayLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary ArrayLib {\n  function includes(uint24[] storage array, uint24 value) internal view returns (bool) {\n    uint256 length = array.length;\n    for (uint256 i; i < length; i++) {\n      if (array[i] == value) return true;\n    }\n    return false;\n  }\n}\n",
        "Nonce.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {INonce} from \"../interfaces/base/INonce.sol\";\n\nabstract contract Nonce is INonce {\n  /// @inheritdoc INonce\n  uint256 public nonce;\n\n  modifier handleNonce(uint256 _nonce) {\n    require(_nonce == nonce, InvalidNonce());\n    unchecked {\n      ++nonce;\n    }\n    _;\n  }\n}\n",
        "Deployer.sol": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {V3FeeAdapter} from \"./feeAdapters/V3FeeAdapter.sol\";\nimport {ITokenJar} from \"./interfaces/ITokenJar.sol\";\nimport {TokenJar} from \"./TokenJar.sol\";\nimport {Firepit} from \"./releasers/Firepit.sol\";\nimport {IReleaser} from \"./interfaces/IReleaser.sol\";\nimport {IV3FeeAdapter} from \"./interfaces/IV3FeeAdapter.sol\";\nimport {IOwned} from \"./interfaces/base/IOwned.sol\";\nimport {IUniswapV3Factory} from \"v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\ncontract Deployer {\n  ITokenJar public immutable TOKEN_JAR;\n  IReleaser public immutable RELEASER;\n  IV3FeeAdapter public immutable FEE_ADAPTER;\n\n  address public constant RESOURCE = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n  uint256 public constant THRESHOLD = 69_420;\n  IUniswapV3Factory public constant V3_FACTORY =\n    IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n  bytes32 constant SALT_TOKEN_JAR = 0;\n  bytes32 constant SALT_RELEASER = 0;\n  bytes32 constant SALT_FEE_ADAPTER = 0;\n\n  //// TOKEN JAR:\n  /// 1. Deploy the TokenJar\n  /// 3. Set the releaser on the token jar.\n  /// 4. Update the owner on the token jar.\n\n  /// RELEASER:\n  /// 2. Deploy the Releaser.\n  /// 5. Update the thresholdSetter on the releaser to the owner.\n  /// 6. Update the owner on the releaser.\n\n  /// FEE_ADAPTER:\n  /// 7. Deploy the FeeAdapter.\n  /// 8. Update the feeSetter to the owner.\n  /// 9. Store fee tiers.\n  /// 10. Update the owner on the fee adapter.\n  constructor() {\n    address owner = V3_FACTORY.owner();\n    /// 1. Deploy the TokenJar.\n    TOKEN_JAR = new TokenJar{salt: SALT_TOKEN_JAR}();\n    /// 2. Deploy the Releaser.\n    RELEASER = new Firepit{salt: SALT_RELEASER}(RESOURCE, THRESHOLD, address(TOKEN_JAR));\n    /// 3. Set the releaser on the token jar.\n    TOKEN_JAR.setReleaser(address(RELEASER));\n    /// 4. Update the owner on the token jar.\n    IOwned(address(TOKEN_JAR)).transferOwnership(owner);\n\n    /// 5. Update the thresholdSetter on the releaser to the owner.\n    RELEASER.setThresholdSetter(owner);\n    /// 6. Update the owner on the releaser.\n    IOwned(address(RELEASER)).transferOwnership(owner);\n\n    /// 7. Deploy the FeeAdapter.\n    FEE_ADAPTER = new V3FeeAdapter{salt: SALT_FEE_ADAPTER}(address(V3_FACTORY), address(TOKEN_JAR));\n\n    /// 8. Update the feeSetter to the owner.\n    FEE_ADAPTER.setFeeSetter(owner);\n\n    /// 9. Store fee tiers.\n    FEE_ADAPTER.storeFeeTier(100);\n    FEE_ADAPTER.storeFeeTier(500);\n    FEE_ADAPTER.storeFeeTier(3000);\n    FEE_ADAPTER.storeFeeTier(10_000);\n\n    /// 10. Update the owner on the fee adapter.\n    IOwned(address(FEE_ADAPTER)).transferOwnership(owner);\n  }\n}\n"
    }
}