{
    "vfp_id": "vfp_00355",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-778"
                ]
            },
            "title": "Misleading and Non-Authoritative Whitelist Events in `PermissionedMulticallHandler`",
            "description": "The `PermissionedMulticallHandler` contract emits custom events `CallerWhitelisted` and `CallerRemovedFromWhitelist` via wrapper functions `whitelistCaller` and `removeCallerFromWhitelist`. However, these events are emitted unconditionally, regardless of whether the underlying role state actually changed, leading to false positives. Additionally, direct calls to `grantRole` and `revokeRole` bypass these custom events entirely, resulting in false negatives. \nThe root cause is the lack of state checks before emitting events and the existence of alternative paths to modify roles without triggering the custom events. \nAn attacker or misconfigured off-chain system could exploit this by relying on these events for state synchronization, leading to an incorrect view of the whitelist. \nThe impact is that off-chain monitoring tools may maintain an inaccurate state of authorized callers, potentially leading to incorrect access decisions or missed security alerts.\n",
            "severity": "Medium",
            "location": [
                "PermissionedMulticallHandler.sol::whitelistCaller#60-63",
                "PermissionedMulticallHandler.sol::removeCallerFromWhitelist#69-72",
                "PermissionedMulticallHandler.sol::CallerWhitelisted#18",
                "PermissionedMulticallHandler.sol::CallerRemovedFromWhitelist#21"
            ],
            "files": [
                "contracts/contracts/handlers/PermissionedMulticallHandler.sol"
            ]
        }
    ],
    "affected_files": {
        "PermissionedMulticallHandler.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { MulticallHandler } from \"./MulticallHandler.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title PermissionedMulticallHandler\n * @notice Extension of MulticallHandler that restricts access to whitelisted callers\n * @dev Uses OpenZeppelin's AccessControl for caller permission management.\n * Only addresses with the WHITELISTED_CALLER_ROLE can call handleV3AcrossMessage.\n */\ncontract PermissionedMulticallHandler is MulticallHandler, AccessControl {\n    /// @notice Role identifier for whitelisted callers\n    bytes32 public constant WHITELISTED_CALLER_ROLE = keccak256(\"WHITELISTED_CALLER_ROLE\");\n\n    /// @notice Emitted when a caller is whitelisted\n    event CallerWhitelisted(address indexed caller);\n\n    /// @notice Emitted when a caller is removed from whitelist\n    event CallerRemovedFromWhitelist(address indexed caller);\n\n    /// @notice Error thrown when caller is not whitelisted\n    error CallerNotWhitelisted(address caller);\n\n    /**\n     * @notice Constructor that sets up the initial admin\n     * @param admin Address that will have DEFAULT_ADMIN_ROLE\n     */\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /**\n     * @notice Overrides handleV3AcrossMessage to add caller whitelist check\n     * @dev Only addresses with WHITELISTED_CALLER_ROLE can call this function\n     * @param token The token being transferred\n     * @param amount The amount of tokens\n     * @param relayer The relayer address\n     * @param message The encoded Instructions struct\n     */\n    function handleV3AcrossMessage(\n        address token,\n        uint256 amount,\n        address relayer,\n        bytes memory message\n    ) public override {\n        if (!hasRole(WHITELISTED_CALLER_ROLE, msg.sender)) {\n            revert CallerNotWhitelisted(msg.sender);\n        }\n\n        // Call parent implementation\n        super.handleV3AcrossMessage(token, amount, relayer, message);\n    }\n\n    /**\n     * @notice Add a caller to the whitelist\n     * @param caller Address to whitelist\n     */\n    function whitelistCaller(address caller) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        grantRole(WHITELISTED_CALLER_ROLE, caller);\n        emit CallerWhitelisted(caller);\n    }\n\n    /**\n     * @notice Remove a caller from the whitelist\n     * @param caller Address to remove from whitelist\n     */\n    function removeCallerFromWhitelist(address caller) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        revokeRole(WHITELISTED_CALLER_ROLE, caller);\n        emit CallerRemovedFromWhitelist(caller);\n    }\n}\n"
    }
}