{
    "vfp_id": "vfp_00403",
    "project_name": "OIF Contracts Diff Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Compact Format Signatures (64 bytes) Are No Longer Supported",
            "description": "The system migrated signature verification from Solady's `SignatureCheckerLib` to OpenZeppelin's `SignatureChecker`, which only supports 65-byte ECDSA signatures and rejects 64-byte compact signatures. This change breaks backward compatibility with existing integrations or users relying on the compact format. The root cause is the stricter enforcement in OpenZeppelin's implementation, which does not include logic to handle the 64-byte format that Solady previously supported. An attacker could potentially exploit this by submitting a valid 64-byte signature that gets rejected, leading to a denial of service for legitimate users who are unaware of the format change. The impact is functional disruption rather than direct fund loss, but it may prevent certain users or systems from interacting with the contract if they continue to use compact signatures. While the team deemed this change intentional, it represents a compatibility risk for integrators.\n",
            "severity": "Low",
            "location": [
                "InputSettlerBase.sol::L179",
                "InputSettlerPurchase.sol::L150"
            ],
            "files": [
                "oif-contracts/src/input/InputSettlerBase.sol"
            ]
        }
    ],
    "affected_files": {
        "InputSettlerBase.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { LibAddress } from \"../libs/LibAddress.sol\";\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\nimport { EfficiencyLib } from \"the-compact/src/lib/EfficiencyLib.sol\";\n\nimport { IInputCallback } from \"../interfaces/IInputCallback.sol\";\nimport { IInputOracle } from \"../interfaces/IInputOracle.sol\";\n\nimport { AllowOpenType } from \"./types/AllowOpenType.sol\";\nimport { MandateOutput } from \"./types/MandateOutputType.sol\";\n\nimport { MandateOutputEncodingLib } from \"../libs/MandateOutputEncodingLib.sol\";\nimport { MandateOutput } from \"./types/MandateOutputType.sol\";\n\n/**\n * @title Base Input Settler\n * @notice Defines common logic that can be reused by other input settlers to support a variety of asset management\n * schemes.\n */\nabstract contract InputSettlerBase is EIP712 {\n    using LibAddress for address;\n    using LibAddress for bytes32;\n\n    error TimestampPassed();\n    error TimestampNotPassed();\n    error WrongChain(uint256 expected, uint256 actual);\n    error InvalidSigner();\n    error FilledTooLate(uint32 expected, uint32 actual);\n    error InvalidTimestampLength();\n    error NoDestination();\n\n    event Finalised(bytes32 indexed orderId, bytes32 solver, bytes32 destination);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // --- Validation --- //\n\n    /**\n     * @notice Checks that a timestamp has not expired.\n     * @param timestamp The timestamp to validate that it is at least equal to block.timestamp\n     */\n    function _validateTimestampHasNotPassed(\n        uint32 timestamp\n    ) internal view {\n        if (block.timestamp >= timestamp) revert TimestampPassed();\n    }\n\n    /**\n     * @notice Checks that a timestamp has passed.\n     * @param timestamp The timestamp to validate that it is not less than block.timestamp\n     */\n    function _validateTimestampHasPassed(\n        uint32 timestamp\n    ) internal view {\n        if (block.timestamp <= timestamp) revert TimestampNotPassed();\n    }\n\n    /**\n     * @notice Checks that this is the right chain for the order.\n     * @param chainId Expected chainId for order. Will be checked against block.chainid\n     */\n    function _validateInputChain(\n        uint256 chainId\n    ) internal view {\n        if (chainId != block.chainid) revert WrongChain(chainId, block.chainid);\n    }\n\n    /**\n     * @notice Validates that the rightmost 20 bytes are not 0.\n     * @param destination Destination of the funds\n     */\n    function _validateDestination(\n        bytes32 destination\n    ) internal pure {\n        bool isZero;\n        // Check if the rightmost 20 bytes are not all 0. That is a stronger check than the entire 32 bytes.\n        assembly (\"memory-safe\") {\n            isZero := iszero(shl(96, destination))\n        }\n        if (isZero) revert NoDestination();\n    }\n\n    // --- Timestamp Helpers --- //\n\n    /**\n     * @param timestamps Array of uint32s.\n     * @return timestamp Largest element of timestamps.\n     */\n    function _maxTimestamp(\n        uint32[] calldata timestamps\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = timestamps[0];\n\n        uint256 numTimestamps = timestamps.length;\n        for (uint256 i = 1; i < numTimestamps; ++i) {\n            uint32 nextTimestamp = timestamps[i];\n            if (timestamp < nextTimestamp) timestamp = nextTimestamp;\n        }\n    }\n\n    /**\n     * @param timestamps Array of uint32s.\n     * @return timestamp Smallest element of timestamps.\n     */\n    function _minTimestamp(\n        uint32[] calldata timestamps\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = timestamps[0];\n\n        uint256 numTimestamps = timestamps.length;\n        for (uint256 i = 1; i < numTimestamps; ++i) {\n            uint32 nextTimestamp = timestamps[i];\n            if (timestamp > nextTimestamp) timestamp = nextTimestamp;\n        }\n    }\n\n    // --- External Claimant --- //\n\n    /**\n     * @notice Check for a signed message by an order owner to allow someone else to redeem an order.\n     * @dev See AllowOpenType.sol\n     * @param orderId A unique identifier for an order.\n     * @param orderOwner Owner of the order, and signer of orderOwnerSignature.\n     * @param nextDestination New destination.\n     * @param call An external call required by orderOwner.\n     * @param orderOwnerSignature EIP712 Signature of AllowOpen by orderOwner.\n     */\n    function _allowExternalClaimant(\n        bytes32 orderId,\n        address orderOwner,\n        bytes32 nextDestination,\n        bytes calldata call,\n        bytes calldata orderOwnerSignature\n    ) internal view {\n        bytes32 digest = _hashTypedData(AllowOpenType.hashAllowOpen(orderId, nextDestination, call));\n        bool isValid = SignatureCheckerLib.isValidSignatureNowCalldata(orderOwner, digest, orderOwnerSignature);\n        if (!isValid) revert InvalidSigner();\n    }\n\n    function _proofPayloadHash(\n        bytes32 orderId,\n        bytes32 solver,\n        uint32 timestamp,\n        MandateOutput calldata output\n    ) internal pure returns (bytes32 outputHash) {\n        return keccak256(MandateOutputEncodingLib.encodeFillDescription(solver, orderId, timestamp, output));\n    }\n\n    /**\n     * @notice Check if a series of outputs has been proven.\n     * @dev Can take a list of solvers. Should be used as a secure alternative to _validateFills\n     * if someone filled one of the outputs.\n     */\n    function _validateFills(\n        uint32 fillDeadline,\n        address inputOracle,\n        MandateOutput[] calldata outputs,\n        bytes32 orderId,\n        uint32[] calldata timestamps,\n        bytes32[] memory solvers // TODO: calldata\n    ) internal view {\n        uint256 numOutputs = outputs.length;\n        uint256 numTimestamps = timestamps.length;\n        if (numTimestamps != numOutputs) revert InvalidTimestampLength();\n\n        bytes memory proofSeries = new bytes(32 * 4 * numOutputs);\n        for (uint256 i; i < numOutputs; ++i) {\n            uint32 outputFilledAt = timestamps[i];\n            if (fillDeadline < outputFilledAt) revert FilledTooLate(fillDeadline, outputFilledAt);\n            MandateOutput calldata output = outputs[i];\n            bytes32 payloadHash = _proofPayloadHash(orderId, solvers[i], outputFilledAt, output);\n\n            uint256 chainId = output.chainId;\n            bytes32 outputOracle = output.oracle;\n            bytes32 outputSettler = output.settler;\n            assembly (\"memory-safe\") {\n                let offset := add(add(proofSeries, 0x20), mul(i, 0x80))\n                mstore(offset, chainId)\n                mstore(add(offset, 0x20), outputOracle)\n                mstore(add(offset, 0x40), outputSettler)\n                mstore(add(offset, 0x60), payloadHash)\n            }\n        }\n        IInputOracle(inputOracle).efficientRequireProven(proofSeries);\n    }\n}\n"
    }
}