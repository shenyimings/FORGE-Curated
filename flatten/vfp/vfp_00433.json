{
    "vfp_id": "vfp_00433",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "CompatibilityFallbackHandler does not provide full compatibility",
            "description": "The CompatibilityFallbackHandler contract fails to implement the encodeTransactionData function, which is expected by older integrations with previous versions of the Safe contract. This omission breaks backward compatibility for read-only operations that depend on this function. The root cause is an incomplete implementation of legacy interface support in the fallback handler. An attacker or malicious actor is not required for exploitation; instead, any legitimate integration relying on encodeTransactionData will fail when interacting with a Safe using this handler. This leads to a loss of interoperability and potential disruption in dApps or tooling expecting full backward compatibility. The impact is low because it does not lead to fund loss or direct security compromise, but it affects system usability and integration reliability.\n",
            "severity": "Low",
            "location": [
                "CompatibilityFallbackHandler.sol"
            ],
            "files": [
                "safe-smart-account/contracts/handler/CompatibilityFallbackHandler.sol"
            ]
        }
    ],
    "affected_files": {
        "CompatibilityFallbackHandler.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ISafe} from \"./../interfaces/ISafe.sol\";\nimport {ISignatureValidator} from \"./../interfaces/ISignatureValidator.sol\";\nimport {HandlerContext} from \"./HandlerContext.sol\";\nimport {TokenCallbackHandler} from \"./TokenCallbackHandler.sol\";\n\n/**\n * @title Compatibility Fallback Handler\n * @notice Provides compatibility between pre 1.3.0 and 1.3.0+ Safe smart account contracts.\n * @dev ⚠️⚠️⚠️ This contract is only intended for being used as a fallback handler for a {Safe}.\n *      Using it in other ways may cause undefined behavior. ⚠️⚠️⚠️\n * @author Richard Meissner - @rmeissner\n */\ncontract CompatibilityFallbackHandler is TokenCallbackHandler, ISignatureValidator, HandlerContext {\n    /**\n     * @dev The precomputed EIP-712 type hash for the Safe message type.\n     *      Precomputed value of: `keccak256(\"SafeMessage(bytes message)\")`.\n     */\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n\n    /**\n     * @dev The sentinel module value in the {ModuleManager.modules} linked list.\n     *      See {ModuleManager.SENTINEL_MODULES} for more information.\n     */\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    /**\n     * @notice Returns the hash of a message to be signed by owners.\n     * @dev This function assumes that the caller is a Safe contract.\n     * @param message Raw message bytes.\n     * @return Message hash.\n     */\n    function getMessageHash(bytes memory message) public view returns (bytes32) {\n        return getMessageHashForSafe(ISafe(payable(msg.sender)), message);\n    }\n\n    /**\n     * @dev Returns the pre-image of the message hash (see {getMessageHashForSafe}).\n     * @param safe Safe to which the message is targeted.\n     * @param message Message that should be encoded.\n     * @return Encoded message.\n     */\n    function encodeMessageDataForSafe(ISafe safe, bytes memory message) public view returns (bytes memory) {\n        bytes32 safeMessageHash = keccak256(abi.encode(SAFE_MSG_TYPEHASH, keccak256(message)));\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), safe.domainSeparator(), safeMessageHash);\n    }\n\n    /**\n     * @dev Returns the hash of a message that can be signed by owners.\n     * @param safe Safe to which the message is targeted.\n     * @param message Message that should be hashed.\n     * @return Message hash.\n     */\n    function getMessageHashForSafe(ISafe safe, bytes memory message) public view returns (bytes32) {\n        return keccak256(encodeMessageDataForSafe(safe, message));\n    }\n\n    /**\n     * @notice Implementation of the EIP-1271 signature validation method.\n     * @dev This implementation verifies signatures for a `ISafe(msg.sender)`.\n     * @param _dataHash Hash of the data signed.\n     * @param _signature Signature data.\n     * @return The EIP-1271 magic value if the signature is valid, reverts otherwise.\n     */\n    function isValidSignature(bytes32 _dataHash, bytes calldata _signature) public view override returns (bytes4) {\n        // Caller should be a Safe.\n        ISafe safe = ISafe(payable(msg.sender));\n        bytes memory messageData = encodeMessageDataForSafe(safe, abi.encode(_dataHash));\n        bytes32 messageHash = keccak256(messageData);\n        if (_signature.length == 0) {\n            require(safe.signedMessages(messageHash) != 0, \"Hash not approved\");\n        } else {\n            // We explicitly do not allow caller approved signatures for EIP-1271 to prevent unexpected behaviour. This\n            // is done by setting the executor address to `0` which can never be an owner of the Safe.\n            safe.checkSignatures(address(0), messageHash, _signature);\n        }\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /**\n     * @dev Returns array of first 10 modules.\n     * @return Array of modules.\n     */\n    function getModules() external view returns (address[] memory) {\n        // Caller should be a Safe.\n        ISafe safe = ISafe(payable(msg.sender));\n        (address[] memory array, ) = safe.getModulesPaginated(SENTINEL_MODULES, 10);\n        return array;\n    }\n\n    /**\n     * @notice Performs a `DELEGATECALL` to a `targetContract` in the context of self.\n     * @dev Internally reverts execution to avoid side effects (making it effectively static).\n     *      Catches the internal revert and returns encoded result as bytes.\n     *      Inspired by <https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol>.\n     *      ⚠️⚠️⚠️ This function assumes the caller is a Safe contract is only intended for being used as a fallback handler for a {Safe}.\n     *      Using it in other ways may cause undefined behavior. ⚠️⚠️⚠️\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulate(address targetContract, bytes calldata calldataPayload) external returns (bytes memory response) {\n        // Suppress compiler warnings about not using parameters, while allowing\n        // parameters to keep names for documentation purposes. This does not\n        // generate code.\n        targetContract;\n        calldataPayload;\n\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // Store `simulateAndRevert.selector`.\n            // String representation is used to force right padding.\n            mstore(ptr, \"\\xb4\\xfa\\xba\\x09\")\n\n            // Abuse the fact that both this and the internal methods have the\n            // same signature, and differ only in symbol name (and therefore,\n            // selector) and copy calldata directly. This saves us approximately\n            // 250 bytes of code and 300 gas at runtime over the\n            // `abi.encodeWithSelector` builtin.\n            calldatacopy(add(ptr, 0x04), 0x04, sub(calldatasize(), 0x04))\n\n            let success := call(\n                gas(),\n                // `address()` has been changed to `caller()` to use the\n                // implementation of the calling Safe.\n                caller(),\n                0,\n                ptr,\n                calldatasize(),\n                // The `simulateAndRevert` call should always reverts, and\n                // instead encodes whether or not it was successful in the\n                // return data. The first 32-byte word of the return data\n                // contains the `success` value, and the second 32-byte word\n                // contains the response bytes length, so write them to memory\n                // address 0x00 (Solidity scratch which is OK to use).\n                0x00,\n                0x40\n            )\n\n            // Double check that the call reverted as expected, and that the\n            // `returndata` is long enough to hold the encoded success boolean\n            // and response bytes length (64 bytes total). This will always be\n            // the case if the caller is a Safe, but check anyway to make sure\n            // this function does not make unexpected state changes when\n            // called by other contracts.\n            if or(success, lt(returndatasize(), 0x40)) {\n                revert(0, 0)\n            }\n\n            // Allocate and copy the response bytes, making sure to increment\n            // the free memory pointer accordingly (in case this method is\n            // called as an internal function). The remaining `returndata[0x20:]`\n            // contains the ABI encoded response bytes, so we can just copy it\n            // as is to memory. Note that `returndatacopy` will revert if we\n            // try to copy past the `returndatasize` bounds, so we don't need an\n            // additional check here. However, do note that this will consume\n            // all remaining gas. This is fine (since we don't aim to support\n            // other callers that aren't Safes with the compatibility fallback\n            // handler).\n            let responseEncodedSize := add(mload(0x20), 0x20)\n            response := mload(0x40)\n            mstore(0x40, add(response, responseEncodedSize))\n            returndatacopy(response, 0x20, responseEncodedSize)\n\n            if iszero(mload(0x00)) {\n                revert(add(response, 0x20), responseEncodedSize)\n            }\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    }
}