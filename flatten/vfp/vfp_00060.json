{
    "vfp_id": "vfp_00060",
    "project_name": "2025-01-bacon-labs-bunniv2-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "BunniToken permit cannot be revoked",
            "description": "The BunniToken contract inherits the permit function from ERC20, allowing users to sign a payload to authorize token spending by another party. However, there is no mechanism to revoke a permit signature once it has been signed and shared.\n\nThe root cause is the lack of a function to invalidate or revoke existing permit signatures. Since the permit function relies on nonces, and only one nonce is valid at a time, a user cannot invalidate a previously signed permit without consuming it. An attacker who obtains a signed permit could front-run the original user's transaction, preventing revocation via nonce increment.\n\nAn attacker could exploit this by obtaining a signed permit (e.g., through phishing or interception) and using it at any time before the deadline. This could allow unauthorized token transfers if the spender address is compromised or malicious.\n\nThe impact is limited because the permit expires at a deadline and only applies to a specific amount. However, it still represents a loss of control for the user over their authorization, potentially leading to unexpected token movements if the spender acts maliciously.\n",
            "severity": "Informational",
            "location": [
                "src/BunniToken.sol",
                "src/base/ERC20.sol#L291-L355"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/BunniToken.sol",
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/base/ERC20.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Insufficient event generation",
            "description": "The system fails to emit events for certain critical state changes, particularly in the rebalance and hook execution flows. This is due to missing event emissions in specific functions. The lack of events reduces transparency and hinders off-chain monitoring, making it difficult for users and bots to track important actions. This could delay detection of malicious activity and complicate incident response.\n\nThe root cause is the absence of event emissions in functions that modify state or perform sensitive actions. Without events, external systems such as blockchain explorers, monitoring tools, and user dashboards cannot track these actions in real time.\n\nAn attacker could exploit this lack of transparency by performing malicious actions that go unnoticed. For example, unauthorized fee claims or manipulation of rebalance logic would not be easily detectable without event logs.\n\nThe impact is reduced observability and auditability of the system. This increases the risk of undetected exploits, hampers debugging, and reduces trust in the system’s integrity. While no direct fund loss occurs, the lack of logging makes incident response and forensic analysis significantly harder.\n",
            "severity": "Informational",
            "location": [
                "bunni-v2/src/BunniToken.sol#L155-L196",
                "bunni-v2/src/BunniToken.sol#L132-L152",
                "bunni-v2/src/BunniHook.sol#L244-L246",
                "bunni-v2/src/BunniHook.sol#L429-L462",
                "bunni-v2/src/BunniHook.sol#L465-L511",
                "bunni-v2/src/lib/BunniHookLogic.sol#L532-L550",
                "biddog/src/AmAmm.sol#L432-L434",
                "src/lib/BunniHookLogic.sol"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/BunniToken.sol"
            ]
        }
    ],
    "affected_files": {
        "BunniToken.sol": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.15;\n\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\n\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"@uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol\";\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./base/Errors.sol\";\nimport \"./base/Constants.sol\";\nimport {ERC20} from \"./base/ERC20.sol\";\nimport {Ownable} from \"./base/Ownable.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IBunniHub} from \"./interfaces/IBunniHub.sol\";\nimport {IBunniToken} from \"./interfaces/IBunniToken.sol\";\nimport {ERC20Referrer} from \"./base/ERC20Referrer.sol\";\n\n/// @title BunniToken\n/// @author zefram.eth\n/// @notice ERC20 token that represents a user's LP position\ncontract BunniToken is IBunniToken, ERC20Referrer, Clone, Ownable {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n    using CurrencyLibrary for Currency;\n\n    /// -----------------------------------------------------------------------\n    /// Storage\n    /// -----------------------------------------------------------------------\n\n    string public metadataURI;\n\n    /// @notice The latest referrer reward per token0\n    uint256 public referrerRewardPerToken0;\n\n    /// @notice The referrer reward per token0 paid\n    mapping(uint24 => uint256) public referrerRewardPerTokenPaid0;\n\n    /// @notice The referrer reward in token0 unclaimed\n    mapping(uint24 => uint256) public referrerRewardUnclaimed0;\n\n    /// @notice The referrer reward per token1 stored\n    uint256 public referrerRewardPerToken1;\n\n    /// @notice The referrer reward per token1 paid\n    mapping(uint24 => uint256) public referrerRewardPerTokenPaid1;\n\n    /// @notice The referrer reward in token1 unclaimed\n    mapping(uint24 => uint256) public referrerRewardUnclaimed1;\n\n    /// -----------------------------------------------------------------------\n    /// Immutable params\n    /// -----------------------------------------------------------------------\n\n    function hub() public pure override returns (IBunniHub) {\n        return IBunniHub(_getArgAddress(0));\n    }\n\n    function token0() public pure override returns (Currency) {\n        return Currency.wrap(_getArgAddress(20));\n    }\n\n    function token1() public pure override returns (Currency) {\n        return Currency.wrap(_getArgAddress(40));\n    }\n\n    function name() public pure override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_getArgUint256(60)));\n    }\n\n    function symbol() public pure override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_getArgUint256(92)));\n    }\n\n    function poolManager() public pure override returns (IPoolManager) {\n        return IPoolManager(_getArgAddress(124));\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Initialization\n    /// -----------------------------------------------------------------------\n\n    function initialize(address owner_, string calldata metadataURI_) external override {\n        if (msg.sender != address(hub())) revert BunniToken__NotBunniHub();\n        _initializeOwner(owner_);\n        metadataURI = metadataURI_;\n        emit SetMetadataURI(metadataURI_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Minting & burning\n    /// -----------------------------------------------------------------------\n\n    function mint(address to, uint256 amount, uint24 referrer) external override {\n        if (msg.sender != address(hub())) revert BunniToken__NotBunniHub();\n\n        _mint(to, amount, referrer);\n    }\n\n    function burn(address from, uint256 amount) external override {\n        if (msg.sender != address(hub())) revert BunniToken__NotBunniHub();\n\n        _burn(from, amount);\n    }\n\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Metadata\n    /// -----------------------------------------------------------------------\n\n    function setMetadataURI(string calldata metadataURI_) external override onlyOwner {\n        metadataURI = metadataURI_;\n        emit SetMetadataURI(metadataURI_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Referral\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniToken\n    function distributeReferralRewards(bool isToken0, uint256 amount) external override {\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        Currency token;\n        if (isToken0) {\n            token = token0();\n            referrerRewardPerToken0 += amount.fullMulDiv(REFERRAL_REWARD_PER_TOKEN_PRECISION, totalSupply());\n        } else {\n            token = token1();\n            referrerRewardPerToken1 += amount.fullMulDiv(REFERRAL_REWARD_PER_TOKEN_PRECISION, totalSupply());\n        }\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // pull PoolManager claims tokens from msg.sender\n        poolManager().transferFrom(msg.sender, address(this), token.toId(), amount);\n    }\n\n    /// @inheritdoc IBunniToken\n    function claimReferralRewards(uint24 referrer) external override returns (uint256 reward0, uint256 reward1) {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        // ensure the referrer has been registered in the hub\n        address referrerAddress = hub().getReferrerAddress(referrer);\n        if (referrerAddress == address(0)) revert BunniToken__ReferrerAddressIsZero();\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 rewardPerToken0 = referrerRewardPerToken0;\n        uint256 rewardPerToken1 = referrerRewardPerToken1;\n        uint256 referrerScore = scoreOf(referrer);\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // compute unclaimed reward 0\n        reward0 = _updatedUnclaimedReward(\n            referrerScore, rewardPerToken0, referrerRewardPerTokenPaid0[referrer], referrerRewardUnclaimed0[referrer]\n        );\n        referrerRewardPerTokenPaid0[referrer] = rewardPerToken0;\n        delete referrerRewardUnclaimed0[referrer];\n\n        // compute unclaimed reward 1\n        reward1 = _updatedUnclaimedReward(\n            referrerScore, rewardPerToken1, referrerRewardPerTokenPaid1[referrer], referrerRewardUnclaimed1[referrer]\n        );\n        referrerRewardPerTokenPaid1[referrer] = rewardPerToken1;\n        delete referrerRewardUnclaimed1[referrer];\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // call PoolManager to convert claim tokens into underlying tokens\n        poolManager().unlock(abi.encode(referrerAddress, reward0, reward1));\n    }\n\n    /// @inheritdoc IBunniToken\n    function getClaimableReferralRewards(uint24 referrer)\n        external\n        view\n        override\n        returns (uint256 reward0, uint256 reward1)\n    {\n        reward0 = _updatedUnclaimedReward(\n            scoreOf(referrer),\n            referrerRewardPerToken0,\n            referrerRewardPerTokenPaid0[referrer],\n            referrerRewardUnclaimed0[referrer]\n        );\n        reward1 = _updatedUnclaimedReward(\n            scoreOf(referrer),\n            referrerRewardPerToken1,\n            referrerRewardPerTokenPaid1[referrer],\n            referrerRewardUnclaimed1[referrer]\n        );\n    }\n\n    /// @inheritdoc IUnlockCallback\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        // verify sender\n        IPoolManager manager = poolManager();\n        if (msg.sender != address(manager)) revert BunniToken__NotPoolManager();\n\n        // decode input\n        (address referrerAddress, uint256 reward0, uint256 reward1) = abi.decode(data, (address, uint256, uint256));\n\n        // burn claim tokens and take underlying tokens for referrer\n        if (reward0 != 0) {\n            Currency token = token0();\n            manager.burn(address(this), token.toId(), reward0);\n            manager.take(token, referrerAddress, reward0);\n        }\n        if (reward1 != 0) {\n            Currency token = token1();\n            manager.burn(address(this), token.toId(), reward1);\n            manager.take(token, referrerAddress, reward1);\n        }\n\n        // fallback\n        return bytes(\"\");\n    }\n\n    /// @dev Should accrue rewards for the referrers of `from` and `to` in both token0 and token1\n    function _beforeTokenTransfer(address from, address to, uint256) internal override {\n        uint256 rewardPerToken0 = referrerRewardPerToken0;\n        uint256 rewardPerToken1 = referrerRewardPerToken1;\n\n        uint24 fromReferrer;\n        uint24 toReferrer;\n\n        if (from != address(0)) {\n            fromReferrer = referrerOf(from);\n            uint256 fromReferrerScore = scoreOf(fromReferrer);\n\n            // accrue token0 rewards\n            referrerRewardUnclaimed0[fromReferrer] = _updatedUnclaimedReward(\n                fromReferrerScore,\n                rewardPerToken0,\n                referrerRewardPerTokenPaid0[fromReferrer],\n                referrerRewardUnclaimed0[fromReferrer]\n            );\n            referrerRewardPerTokenPaid0[fromReferrer] = rewardPerToken0;\n\n            // accrue token1 rewards\n            referrerRewardUnclaimed1[fromReferrer] = _updatedUnclaimedReward(\n                fromReferrerScore,\n                rewardPerToken1,\n                referrerRewardPerTokenPaid1[fromReferrer],\n                referrerRewardUnclaimed1[fromReferrer]\n            );\n            referrerRewardPerTokenPaid1[fromReferrer] = rewardPerToken1;\n        }\n\n        if (to != address(0)) {\n            toReferrer = referrerOf(to);\n\n            // no need to accrue rewards again if from and to have the same referrer\n            if (!(from != address(0) && fromReferrer == toReferrer)) {\n                uint256 toReferrerScore = scoreOf(toReferrer);\n\n                // accrue token0 rewards\n                referrerRewardUnclaimed0[toReferrer] = _updatedUnclaimedReward(\n                    toReferrerScore,\n                    rewardPerToken0,\n                    referrerRewardPerTokenPaid0[toReferrer],\n                    referrerRewardUnclaimed0[toReferrer]\n                );\n                referrerRewardPerTokenPaid0[toReferrer] = rewardPerToken0;\n\n                // accrue token1 rewards\n                referrerRewardUnclaimed1[toReferrer] = _updatedUnclaimedReward(\n                    toReferrerScore,\n                    rewardPerToken1,\n                    referrerRewardPerTokenPaid1[toReferrer],\n                    referrerRewardUnclaimed1[toReferrer]\n                );\n                referrerRewardPerTokenPaid1[toReferrer] = rewardPerToken1;\n            }\n        }\n    }\n\n    /// @dev Compute the updated unclaimed reward of a referrer\n    function _updatedUnclaimedReward(\n        uint256 referrerScore,\n        uint256 rewardPerToken,\n        uint256 rewardPerTokenPaid,\n        uint256 rewardUnclaimed\n    ) internal pure returns (uint256) {\n        return referrerScore.fullMulDiv(rewardPerToken - rewardPerTokenPaid, REFERRAL_REWARD_PER_TOKEN_PRECISION)\n            + rewardUnclaimed;\n    }\n}\n",
        "ERC20.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 is IERC20 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 internal constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 internal constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 internal constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 internal constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 internal constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 internal constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 internal constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    bytes32 internal constant _VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 internal constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC20                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the allowance slot and load its value.\n            mstore(0x20, caller())\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          EIP-2612                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n        virtual\n    {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    }
}