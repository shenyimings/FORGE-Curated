{
    "vfp_id": "vfp_00577",
    "project_name": "cantina_virtuals_may2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ]
            },
            "title": "Inheritance of non-upgradable contracts",
            "description": "1. **Description:** Some contracts inherit from a mix of upgradable and non-upgradable base contracts, which can lead to constructor conflicts or unexpected behavior in upgradeable contexts.\n2. **Cause:** AgentFactoryV5 inherits AccessControlUpgradeable but also non-upgradable ReentrancyGuard; Genesis inherits AccessControlUpgradeable but not Initializable explicitly.\n3. **Exploitation:** If the contract were to be used in a proxy pattern, constructor logic might not behave as expected.\n4. **Impact:** Potential for incorrect initialization in upgradeable proxy patterns, leading to security risks or broken functionality in future upgrades.\n",
            "severity": "Informational",
            "location": [
                "Genesis.sol#L13",
                "AgentFactoryV5.sol#L22"
            ],
            "files": [
                "protocol-contracts/contracts/genesis/Genesis.sol"
            ]
        }
    ],
    "affected_files": {
        "Genesis.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./FGenesis.sol\";\nimport \"../virtualPersona/IAgentFactoryV5.sol\";\n// import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./GenesisTypes.sol\";\n\ncontract Genesis is ReentrancyGuard, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant FACTORY_ROLE = keccak256(\"FACTORY_ROLE\");\n\n    mapping(address => uint256) public mapAddrToVirtuals;\n    mapping(address => uint256) public claimableAgentTokens;\n    address[] public participants;\n    uint256 public refundUserCountForFailed;\n\n    uint256 public genesisId;\n    FGenesis public factory;\n\n    // Genesis-related variables\n    uint256 public startTime;\n    uint256 public endTime;\n    string public genesisName;\n    string public genesisTicker;\n    uint8[] public genesisCores;\n\n    // TBA and DAO parameters\n    bytes32 public tbaSalt;\n    address public tbaImplementation;\n    uint32 public daoVotingPeriod;\n    uint256 public daoThreshold;\n    address public agentFactoryAddress;\n    address public virtualTokenAddress;\n    uint256 public reserveAmount;\n    uint256 public maxContributionVirtualAmount;\n    uint256 public agentTokenTotalSupply;\n    uint256 public agentTokenLpSupply;\n\n    address public agentTokenAddress;\n    bool public isFailed;\n    bool public isCancelled;\n    bool public noLpStake;\n    uint256 public totalClaimableAgentTokensLeft;\n\n    event AssetsWithdrawn(\n        uint256 indexed genesisID,\n        address indexed to,\n        address token,\n        uint256 amount\n    );\n\n    event TimeReset(\n        uint256 oldStartTime,\n        uint256 oldEndTime,\n        uint256 newStartTime,\n        uint256 newEndTime\n    );\n\n    event GenesisCancelled(uint256 indexed genesisID);\n    event GenesisSucceeded(uint256 indexed genesisID);\n    event GenesisFailed(uint256 indexed genesisID);\n\n    event Participated(\n        uint256 indexed genesisID,\n        address indexed user,\n        uint256 point,\n        uint256 virtuals\n    );\n    event RefundClaimed(\n        uint256 indexed genesisID,\n        address indexed user,\n        uint256 amount\n    );\n    event AgentTokenClaimed(\n        uint256 indexed genesisID,\n        address indexed user,\n        uint256 amount\n    );\n    event VirtualsWithdrawn(\n        uint256 indexed genesisID,\n        address indexed to,\n        address token,\n        uint256 amount\n    );\n\n    string private constant ERR_NOT_STARTED = \"Genesis not started yet\";\n    string private constant ERR_ALREADY_STARTED = \"Genesis already started\";\n    string private constant ERR_NOT_ENDED = \"Genesis not ended yet\";\n    string private constant ERR_ALREADY_ENDED = \"Genesis already ended\";\n    string private constant ERR_ALREADY_FAILED = \"Genesis already failed\";\n    string private constant ERR_ALREADY_CANCELLED = \"Genesis already cancelled\";\n    string private constant ERR_START_TIME_FUTURE =\n        \"Start time must be in the future\";\n    string private constant ERR_END_AFTER_START =\n        \"End time must be after start time\";\n    string private constant ERR_TOKEN_LAUNCHED = \"Agent token already launched\";\n    string private constant ERR_TOKEN_NOT_LAUNCHED = \"Agent token not launched\";\n    string private constant ERR_ZERO_ADD = \"Address cannot be empty\";\n    string private constant ERR_INVALID_PARAM = \"Invalid value for parameter\";\n\n    // Common validation modifiers\n    modifier whenNotStarted() {\n        require(!isStarted(), ERR_ALREADY_STARTED);\n        _;\n    }\n\n    modifier whenStarted() {\n        require(isStarted(), ERR_NOT_STARTED);\n        _;\n    }\n\n    modifier whenNotEnded() {\n        require(!isEnded(), ERR_ALREADY_ENDED);\n        _;\n    }\n\n    modifier whenEnded() {\n        require(isEnded(), ERR_NOT_ENDED);\n        _;\n    }\n\n    modifier whenNotFailed() {\n        require(!isFailed, ERR_ALREADY_FAILED);\n        _;\n    }\n\n    modifier whenNotCancelled() {\n        require(!isCancelled, ERR_ALREADY_CANCELLED);\n        _;\n    }\n\n    modifier whenTokenNotLaunched() {\n        require(agentTokenAddress == address(0), ERR_TOKEN_LAUNCHED);\n        _;\n    }\n\n    modifier whenTokenLaunched() {\n        require(agentTokenAddress != address(0), ERR_TOKEN_NOT_LAUNCHED);\n        _;\n    }\n\n    // Combined state checks\n    modifier whenActive() {\n        require(isStarted(), ERR_NOT_STARTED);\n        require(!isEnded(), ERR_ALREADY_ENDED);\n        require(!isFailed, ERR_ALREADY_FAILED);\n        require(!isCancelled, ERR_ALREADY_CANCELLED);\n        _;\n    }\n\n    modifier whenFinalized() {\n        require(isEnded(), ERR_NOT_ENDED);\n        require(\n            isFailed || isCancelled || agentTokenAddress != address(0),\n            \"Genesis not finalized yet\"\n        );\n        _;\n    }\n\n    function _validateTime(uint256 _startTime, uint256 _endTime) internal view {\n        require(_startTime > block.timestamp, ERR_START_TIME_FUTURE);\n        require(_endTime > _startTime, ERR_END_AFTER_START);\n    }\n\n    function initialize(\n        GenesisInitParams calldata params\n    ) external initializer {\n        __AccessControl_init();\n\n        require(params.genesisID > 0, \"Invalid ID\");\n        require(params.factory != address(0) && params.tbaImplementation != address(0) \n            && params.agentFactoryAddress != address(0) && params.virtualTokenAddress != address(0), ERR_ZERO_ADD);\n        _validateTime(params.startTime, params.endTime);\n        require(bytes(params.genesisName).length > 0, \"Invalid name\");\n        require(\n            bytes(params.genesisTicker).length > 0,\n            \"Invalid ticker\"\n        );\n        require(params.genesisCores.length > 0, \"Invalid cores\");\n        require(\n            params.reserveAmount > 0 && params.maxContributionVirtualAmount > 0\n            && params.agentTokenTotalSupply > 0 && params.agentTokenLpSupply > 0,\n           ERR_INVALID_PARAM\n        );\n        require(\n            params.agentTokenTotalSupply >= params.agentTokenLpSupply,\n            \"Agent token total supply must be > agent token lp supply\"\n        );\n\n        genesisId = params.genesisID;\n        factory = FGenesis(params.factory); // the FGenesis Proxy\n        startTime = params.startTime;\n        endTime = params.endTime;\n        genesisName = params.genesisName;\n        genesisTicker = params.genesisTicker;\n        genesisCores = params.genesisCores;\n        tbaSalt = params.tbaSalt;\n        tbaImplementation = params.tbaImplementation;\n        daoVotingPeriod = params.daoVotingPeriod;\n        daoThreshold = params.daoThreshold;\n        agentFactoryAddress = params.agentFactoryAddress;\n        virtualTokenAddress = params.virtualTokenAddress;\n        reserveAmount = params.reserveAmount;\n        maxContributionVirtualAmount = params.maxContributionVirtualAmount;\n        agentTokenTotalSupply = params.agentTokenTotalSupply;\n        agentTokenLpSupply = params.agentTokenLpSupply;\n        noLpStake = params.noLpStake;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, params.factory);\n        _grantRole(FACTORY_ROLE, params.factory);\n    }\n\n    function participate(\n        uint256 pointAmt,\n        uint256 virtualsAmt\n    ) external nonReentrant whenActive {\n        require(pointAmt > 0, \"Point amount must be > 0\");\n        require(virtualsAmt > 0, \"Virtuals must be > 0\");\n\n        // Check single submission upper limit\n        require(\n            virtualsAmt <= maxContributionVirtualAmount,\n            \"Exceeds maximum virtuals per contribution\"\n        );\n\n        // Update participant list\n        if (mapAddrToVirtuals[msg.sender] == 0) {\n            participants.push(msg.sender);\n        }\n\n        // Update state\n        mapAddrToVirtuals[msg.sender] += virtualsAmt;\n\n        IERC20(virtualTokenAddress).safeTransferFrom(\n            msg.sender,\n            address(this),\n            virtualsAmt\n        );\n\n        emit Participated(genesisId, msg.sender, pointAmt, virtualsAmt);\n    }\n\n    function onGenesisSuccessSalt(\n        address[] calldata refundVirtualsTokenUserAddresses,\n        uint256[] calldata refundVirtualsTokenUserAmounts,\n        address[] calldata distributeAgentTokenUserAddresses,\n        uint256[] calldata distributeAgentTokenUserAmounts,\n        address creator,\n        bytes32 salt\n    )\n        external\n        onlyRole(FACTORY_ROLE)\n        nonReentrant\n        whenNotCancelled\n        whenEnded\n        returns (address)\n    {\n        return _onGenesisSuccessSalt(\n            refundVirtualsTokenUserAddresses,\n            refundVirtualsTokenUserAmounts,\n            distributeAgentTokenUserAddresses,\n            distributeAgentTokenUserAmounts,\n            creator,\n            salt\n        );\n    }\n\n    function _onGenesisSuccessSalt(\n        address[] calldata refundVirtualsTokenUserAddresses,\n        uint256[] calldata refundVirtualsTokenUserAmounts,\n        address[] calldata distributeAgentTokenUserAddresses,\n        uint256[] calldata distributeAgentTokenUserAmounts,\n        address creator,\n        bytes32 salt\n    ) internal returns (address) {\n        require(\n            refundUserCountForFailed == 0,\n            \"OnGenesisFailed already called\"\n        );\n\n        // Calculate total refund amount\n        uint256 totalRefundAmount = 0;\n        for (uint256 i = 0; i < refundVirtualsTokenUserAmounts.length; i++) {\n            // check if the user has enough virtuals committed\n            require(\n                mapAddrToVirtuals[refundVirtualsTokenUserAddresses[i]] >=\n                    refundVirtualsTokenUserAmounts[i],\n                \"Insufficient Virtual Token committed\"\n            );\n            totalRefundAmount += refundVirtualsTokenUserAmounts[i];\n        }\n\n        // Check if launch has been called before\n        bool isFirstLaunch = agentTokenAddress == address(0);\n\n        // Only do launch related operations if this is first launch\n        if (isFirstLaunch) {\n            // grant allowance to agentFactoryAddress for launch\n            IERC20(virtualTokenAddress).approve(\n                agentFactoryAddress,\n                reserveAmount\n            );\n\n            // Call initFromBondingCurve and executeBondingCurveApplication\n            uint256 id = IAgentFactoryV5(agentFactoryAddress)\n                .initFromBondingCurve(\n                    string.concat(genesisName, \" by Virtuals\"),\n                    genesisTicker,\n                    genesisCores,\n                    tbaSalt,\n                    tbaImplementation,\n                    daoVotingPeriod,\n                    daoThreshold,\n                    reserveAmount,\n                    creator\n                );\n\n            address agentToken = IAgentFactoryV5(agentFactoryAddress)\n                .executeBondingCurveApplicationSalt(\n                    id,\n                    agentTokenTotalSupply,\n                    agentTokenLpSupply,\n                    address(this), // vault\n                    salt,\n                    noLpStake\n                );\n\n            require(agentToken != address(0), ERR_ZERO_ADD);\n\n            // Store the created agent token address\n            agentTokenAddress = agentToken;\n        }\n\n        // Calculate total distribution amount\n        uint256 totalDistributionAmount = 0;\n        for (uint256 i = 0; i < distributeAgentTokenUserAmounts.length; i++) {\n            totalDistributionAmount += distributeAgentTokenUserAmounts[i];\n        }\n        // Check if contract has enough agent token balance only after agentTokenAddress be set\n        require(\n            IERC20(agentTokenAddress).balanceOf(address(this)) >=\n                totalDistributionAmount,\n            \"Insufficient Agent Token balance\"\n        );\n\n        // Directly transfer Virtual Token refunds\n        for (uint256 i = 0; i < refundVirtualsTokenUserAddresses.length; i++) {\n            // first decrease the virtuals mapping of the user to prevent reentrancy attacks\n            mapAddrToVirtuals[\n                refundVirtualsTokenUserAddresses[i]\n            ] -= refundVirtualsTokenUserAmounts[i];\n            // then transfer the virtuals\n            IERC20(virtualTokenAddress).safeTransfer(\n                refundVirtualsTokenUserAddresses[i],\n                refundVirtualsTokenUserAmounts[i]\n            );\n            emit RefundClaimed(\n                genesisId,\n                refundVirtualsTokenUserAddresses[i],\n                refundVirtualsTokenUserAmounts[i]\n            );\n        }\n\n        // save the amount of agent tokens to claim\n        for (uint256 i = 0; i < distributeAgentTokenUserAddresses.length; i++) {\n            totalClaimableAgentTokensLeft -= claimableAgentTokens[\n                distributeAgentTokenUserAddresses[i]\n            ]; // because here is replace update, so we need to minus the old amount\n            claimableAgentTokens[\n                distributeAgentTokenUserAddresses[i]\n            ] = distributeAgentTokenUserAmounts[i];\n            totalClaimableAgentTokensLeft += distributeAgentTokenUserAmounts[i];\n        }\n\n        emit GenesisSucceeded(genesisId);\n        return agentTokenAddress;\n    }\n\n    // can try to claim at any time\n    function claimAgentToken(address userAddress) external nonReentrant {\n        uint256 amount = claimableAgentTokens[userAddress];\n        require(amount > 0, \"No tokens to claim\");\n\n        // set the amount of claimable agent tokens to 0, to prevent duplicate claims\n        totalClaimableAgentTokensLeft -= amount;\n        claimableAgentTokens[userAddress] = 0;\n\n        // transfer the agent token\n        IERC20(agentTokenAddress).safeTransfer(userAddress, amount);\n\n        emit AgentTokenClaimed(genesisId, userAddress, amount);\n    }\n\n    function getClaimableAgentToken(\n        address userAddress\n    ) external view returns (uint256) {\n        return claimableAgentTokens[userAddress];\n    }\n\n    function onGenesisFailed(\n        uint256[] calldata participantIndexes\n    )\n        external\n        onlyRole(FACTORY_ROLE)\n        nonReentrant\n        whenNotCancelled\n        whenNotFailed\n        whenTokenNotLaunched\n        whenEnded\n    {\n        for (uint256 i = 0; i < participantIndexes.length; i++) {\n            require(\n                participantIndexes[i] < participants.length,\n                \"Index out of bounds\"\n            );\n            address participant = participants[participantIndexes[i]];\n            uint256 virtualsAmt = mapAddrToVirtuals[participant];\n            if (virtualsAmt > 0) {\n                // increase the refund user count for failed, only increase once\n                refundUserCountForFailed++;\n                // first clear the virtuals mapping of the user to prevent reentrancy attacks\n                mapAddrToVirtuals[participant] = 0;\n                // then transfer the virtuals\n                IERC20(virtualTokenAddress).safeTransfer(\n                    participant,\n                    virtualsAmt\n                );\n                emit RefundClaimed(genesisId, participant, virtualsAmt);\n            }\n        }\n\n        // when all participants have been refunded, set the genesis to failed\n        if (refundUserCountForFailed == participants.length) {\n            isFailed = true;\n            emit GenesisFailed(genesisId);\n        }\n    }\n\n    function isEnded() public view returns (bool) {\n        return block.timestamp >= endTime;\n    }\n\n    function isStarted() public view returns (bool) {\n        return block.timestamp >= startTime;\n    }\n\n    function getParticipantCount() external view returns (uint256) {\n        return participants.length;\n    }\n\n    function getParticipantsPaginated(\n        uint256 startIndex,\n        uint256 pageSize\n    ) external view returns (address[] memory) {\n        require(startIndex < participants.length, \"Start index out of bounds\");\n\n        uint256 actualPageSize = pageSize;\n        if (startIndex + pageSize > participants.length) {\n            actualPageSize = participants.length - startIndex;\n        }\n\n        address[] memory page = new address[](actualPageSize);\n        for (uint256 i = 0; i < actualPageSize; i++) {\n            page[i] = participants[startIndex + i];\n        }\n\n        return page;\n    }\n\n    struct ParticipantInfo {\n        address userAddress;\n        uint256 virtuals;\n    }\n\n    function getParticipantsInfo(\n        uint256[] calldata participantIndexes\n    ) external view returns (ParticipantInfo[] memory) {\n        uint256 length = participantIndexes.length;\n        ParticipantInfo[] memory result = new ParticipantInfo[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            // check if the index is out of bounds\n            require(\n                participantIndexes[i] < participants.length,\n                \"Index out of bounds\"\n            );\n\n            address userAddress = participants[participantIndexes[i]];\n            result[i] = ParticipantInfo({\n                userAddress: userAddress,\n                virtuals: mapAddrToVirtuals[userAddress]\n            });\n        }\n\n        return result;\n    }\n\n    struct GenesisInfo {\n        uint256 genesisId;\n        address factory;\n        uint256 startTime;\n        uint256 endTime;\n        string genesisName;\n        string genesisTicker;\n        uint8[] genesisCores;\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n        address agentFactoryAddress;\n        address virtualTokenAddress;\n        uint256 reserveAmount;\n        uint256 maxContributionVirtualAmount;\n        uint256 agentTokenTotalSupply;\n        uint256 agentTokenLpSupply;\n        address agentTokenAddress;\n        bool isFailed;\n        bool isCancelled;\n    }\n\n    function getGenesisInfo() public view returns (GenesisInfo memory) {\n        return\n            GenesisInfo({\n                genesisId: genesisId,\n                factory: address(factory),\n                startTime: startTime,\n                endTime: endTime,\n                genesisName: genesisName,\n                genesisTicker: genesisTicker,\n                genesisCores: genesisCores,\n                tbaSalt: tbaSalt,\n                tbaImplementation: tbaImplementation,\n                daoVotingPeriod: daoVotingPeriod,\n                daoThreshold: daoThreshold,\n                agentFactoryAddress: agentFactoryAddress,\n                virtualTokenAddress: virtualTokenAddress,\n                reserveAmount: reserveAmount,\n                maxContributionVirtualAmount: maxContributionVirtualAmount,\n                agentTokenTotalSupply: agentTokenTotalSupply,\n                agentTokenLpSupply: agentTokenLpSupply,\n                agentTokenAddress: agentTokenAddress,\n                isFailed: isFailed,\n                isCancelled: isCancelled\n            });\n    }\n\n    function withdrawLeftAssetsAfterFinalized(\n        address to,\n        address token,\n        uint256 amount\n    )\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        nonReentrant\n        whenEnded\n        whenFinalized\n    {\n        require(token != address(0), ERR_ZERO_ADD);\n        require(\n            amount <= IERC20(token).balanceOf(address(this)),\n            \"Insufficient balance to withdraw\"\n        );\n\n        IERC20(token).safeTransfer(to, amount);\n\n        // emit an event to record the withdrawal\n        emit AssetsWithdrawn(genesisId, to, token, amount);\n    }\n\n    function resetTime(\n        uint256 newStartTime,\n        uint256 newEndTime\n    )\n        external\n        onlyRole(FACTORY_ROLE)\n        nonReentrant\n        whenNotCancelled\n        whenNotFailed\n        whenNotStarted\n        whenNotEnded\n    {\n        _validateTime(newStartTime, newEndTime);\n\n        uint256 oldStartTime = startTime;\n        uint256 oldEndTime = endTime;\n\n        startTime = newStartTime;\n        endTime = newEndTime;\n\n        emit TimeReset(oldStartTime, oldEndTime, newStartTime, newEndTime);\n    }\n\n    function cancelGenesis()\n        external\n        onlyRole(FACTORY_ROLE)\n        nonReentrant\n        whenNotCancelled\n        whenNotFailed\n        whenNotStarted\n        whenNotEnded\n    {\n        isCancelled = true;\n        emit GenesisCancelled(genesisId);\n    }\n}\n"
    }
}