{
    "vfp_id": "vfp_00577",
    "project_name": "Lido V3 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "unguaranteedDepositToBeaconChain Lets Vault Owner Bypass Fees",
            "description": "The `unguaranteedDepositToBeaconChain` function in the `Dashboard` contract increases the `rewardsAdjustment.amount` by the full deposit amount, even though these deposits are not reflected in the oracle’s total value reporting. Since the fee calculation subtracts this adjustment from the vault’s growth, the vault owner can artificially inflate the adjustment to offset or eliminate fee payments entirely. This creates a privilege escalation where the vault owner can avoid paying node operator fees by making arbitrary deposits to the Beacon Chain using validators outside the oracle’s tracking scope, leading to unfair economic advantages and reduced protocol revenue.\n",
            "severity": "Medium",
            "location": [
                "Dashboard.sol::L427-L432",
                "NodeOperatorFee.sol::L157-L166"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/dashboard/Dashboard.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Fees Should Be Paid Before Abandoning the Dashboard or Transferring Ownership",
            "description": "The `abandonDashboard` and `_transferVaultOwnership` functions do not enforce the settlement of accrued node operator (NO) fees before transferring ownership or control of a vault. This creates a risk where the new owner inherits unresolved fee obligations, leading to inconsistencies in fee distribution.\n\nThe root cause is the lack of a call to `disburseNodeOperatorFee()` in these functions, unlike `voluntaryDisconnect`, which explicitly settles fees. This creates an asymmetry in how fees are handled across different ownership transfer paths.\n\nAn attacker could exploit this by transferring ownership of a vault with accrued but unpaid NO fees, leaving the new owner responsible for settling them or facing disputes over fee entitlement.\n\nThe impact is potential financial loss or disputes between old and new owners regarding unpaid NO fees, undermining trust in the ownership transfer mechanism.\n",
            "severity": "Medium",
            "location": [
                "Dashboard.sol::abandonDashboard#L260-L272",
                "Permissions::_transferVaultOwnership"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/dashboard/Dashboard.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "reconnectToVaultHub Cannot Accept ETH Prohibiting Funding During Reconnect",
            "description": "The `reconnectToVaultHub` function is non-payable, but it calls `connectToVaultHub`, which is payable and forwards `msg.value` to `_stakingVault().fund(...)`. This inconsistency prevents users from sending ETH during reconnection, unlike the initial connection flow. The root cause is a missing `payable` modifier on `reconnectToVaultHub`. An attacker cannot directly exploit this, but legitimate users are blocked from funding during reconnect, leading to inconsistent behavior. The impact is reduced functionality and potential user confusion or failed transactions when attempting to fund during reconnect.\n",
            "severity": null,
            "location": [
                "contracts/0.8.25/vaults/dashboard/Dashboard.sol:L275-L290"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/dashboard/Dashboard.sol"
            ]
        }
    ],
    "affected_files": {
        "Dashboard.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {SafeERC20} from \"@openzeppelin/contracts-v5.2/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-v5.2/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts-v5.2/token/ERC721/IERC721.sol\";\n\nimport {Math256} from \"contracts/common/lib/Math256.sol\";\nimport {ILido as IStETH} from \"contracts/common/interfaces/ILido.sol\";\nimport {IDepositContract} from \"contracts/common/interfaces/IDepositContract.sol\";\n\nimport {IStakingVault} from \"../interfaces/IStakingVault.sol\";\nimport {IPredepositGuarantee} from \"../interfaces/IPredepositGuarantee.sol\";\nimport {NodeOperatorFee} from \"./NodeOperatorFee.sol\";\nimport {VaultHub} from \"../VaultHub.sol\";\n\ninterface IWstETH is IERC20 {\n    function wrap(uint256) external returns (uint256);\n\n    function unwrap(uint256) external returns (uint256);\n}\n\n/**\n * @title Dashboard\n * @notice This contract is a UX-layer for StakingVault and meant to be used as its owner.\n * This contract improves the vault UX by bundling all functions from the StakingVault and VaultHub\n * in this single contract. It provides administrative functions for managing the StakingVault,\n * including funding, withdrawing, minting, burning, and rebalancing operations.\n */\ncontract Dashboard is NodeOperatorFee {\n    bytes32 public constant RECOVER_ASSETS_ROLE = keccak256(\"vaults.Dashboard.RecoverAssets\");\n\n    /**\n     * @notice The stETH token contract\n     */\n    IStETH public immutable STETH;\n\n    /**\n     * @notice The wstETH token contract\n     */\n    IWstETH public immutable WSTETH;\n\n    /**\n     * @notice ETH address convention per EIP-7528\n     */\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /**\n     * @notice Slot for the fund-on-receive flag\n     *         keccak256(\"vaults.Dashboard.fundOnReceive\")\n     */\n    bytes32 public constant FUND_ON_RECEIVE_FLAG_SLOT =\n        0x7408b7b034fda7051615c19182918ecb91d753231cffd86f81a45d996d63e038;\n\n    /**\n     * @notice Constructor sets the stETH, and WSTETH token addresses,\n     * and passes the address of the vault hub up the inheritance chain.\n     * @param _stETH Address of the stETH token contract.\n     * @param _wstETH Address of the wstETH token contract.\n     * @param _vaultHub Address of the vault hub contract.\n     * @param _lidoLocator Address of the Lido locator contract.\n     */\n    constructor(\n        address _stETH,\n        address _wstETH,\n        address _vaultHub,\n        address _lidoLocator\n    ) NodeOperatorFee(_vaultHub, _lidoLocator) {\n        _requireNotZero(_stETH);\n        _requireNotZero(_wstETH);\n\n        // stETH and wstETH are cached as immutable to save gas for main operations\n        STETH = IStETH(_stETH);\n        WSTETH = IWstETH(_wstETH);\n    }\n\n    /**\n     * @notice Calls the parent's initializer and approves the max allowance for WSTETH for gas savings\n     * @param _defaultAdmin The address of the default admin\n     * @param _nodeOperatorManager The address of the node operator manager\n     * @param _nodeOperatorFeeBP The node operator fee in basis points\n     * @param _confirmExpiry The confirmation expiry time in seconds\n     */\n    function initialize(\n        address _defaultAdmin,\n        address _nodeOperatorManager,\n        uint256 _nodeOperatorFeeBP,\n        uint256 _confirmExpiry\n    ) external {\n        super._initialize(_defaultAdmin, _nodeOperatorManager, _nodeOperatorFeeBP, _confirmExpiry);\n\n        // reduces gas cost for `mintWsteth`\n        // invariant: dashboard does not hold stETH on its balance\n        STETH.approve(address(WSTETH), type(uint256).max);\n    }\n\n    // ==================== View Functions ====================\n\n    /**\n     * @notice Returns the vault connection data for the staking vault.\n     * @return VaultConnection struct containing vault data\n     */\n    function vaultConnection() public view returns (VaultHub.VaultConnection memory) {\n        return VAULT_HUB.vaultConnection(address(_stakingVault()));\n    }\n\n    /**\n     * @notice Returns the stETH share limit of the vault\n     */\n    function shareLimit() external view returns (uint256) {\n        return vaultConnection().shareLimit;\n    }\n\n    /**\n     * @notice Returns the number of stETH shares minted\n     */\n    function liabilityShares() public view returns (uint256) {\n        return VAULT_HUB.liabilityShares(address(_stakingVault()));\n    }\n\n    /**\n     * @notice Returns the reserve ratio of the vault in basis points\n     */\n    function reserveRatioBP() public view returns (uint16) {\n        return vaultConnection().reserveRatioBP;\n    }\n\n    /**\n     * @notice Returns the rebalance threshold of the vault in basis points.\n     */\n    function forcedRebalanceThresholdBP() external view returns (uint16) {\n        return vaultConnection().forcedRebalanceThresholdBP;\n    }\n\n    /**\n     * @notice Returns the infra fee basis points.\n     */\n    function infraFeeBP() external view returns (uint16) {\n        return vaultConnection().infraFeeBP;\n    }\n\n    /**\n     * @notice Returns the liquidity fee basis points.\n     */\n    function liquidityFeeBP() external view returns (uint16) {\n        return vaultConnection().liquidityFeeBP;\n    }\n\n    /**\n     * @notice Returns the reservation fee basis points.\n     */\n    function reservationFeeBP() external view returns (uint16) {\n        return vaultConnection().reservationFeeBP;\n    }\n\n    /**\n     * @notice Returns the total value of the vault in ether.\n     */\n    function totalValue() public view returns (uint256) {\n        return VAULT_HUB.totalValue(address(_stakingVault()));\n    }\n\n    /**\n     * @notice Returns the overall unsettled obligations of the vault in ether\n     * @dev includes the node operator fee\n     */\n    function unsettledObligations() external view returns (uint256) {\n        VaultHub.VaultObligations memory obligations = VAULT_HUB.vaultObligations(address(_stakingVault()));\n        return uint256(obligations.unsettledLidoFees) + uint256(obligations.redemptions) + nodeOperatorDisbursableFee();\n    }\n\n    /**\n     * @notice Returns the locked amount of ether for the vault\n     */\n    function locked() public view returns (uint256) {\n        return VAULT_HUB.locked(address(_stakingVault()));\n    }\n\n    /**\n     * @notice Returns the max total lockable amount of ether for the vault (excluding the Lido and node operator fees)\n     */\n    function maxLockableValue() public view returns (uint256) {\n        uint256 maxLockableValue_ = VAULT_HUB.maxLockableValue(address(_stakingVault()));\n        uint256 nodeOperatorFee = nodeOperatorDisbursableFee();\n        return maxLockableValue_ > nodeOperatorFee ? maxLockableValue_ - nodeOperatorFee : 0;\n    }\n\n    /**\n     * @notice Returns the overall capacity for stETH shares that can be minted by the vault\n     */\n    function totalMintingCapacityShares() public view returns (uint256) {\n        uint256 effectiveShareLimit = _operatorGrid().effectiveShareLimit(address(_stakingVault()));\n\n        return Math256.min(effectiveShareLimit, _mintableShares(maxLockableValue()));\n    }\n\n    /**\n     * @notice Returns the remaining capacity for stETH shares that can be minted\n     *         by the vault if additional ether is funded\n     * @param _etherToFund the amount of ether to be funded, can be zero\n     * @return the number of shares that can be minted using additional ether\n     */\n    function remainingMintingCapacityShares(uint256 _etherToFund) public view returns (uint256) {\n        uint256 effectiveShareLimit = _operatorGrid().effectiveShareLimit(address(_stakingVault()));\n        uint256 vaultMintableSharesByRR = _mintableShares(maxLockableValue() + _etherToFund);\n        uint256 vaultLiabilityShares = liabilityShares();\n\n        return Math256.min(\n            effectiveShareLimit > vaultLiabilityShares ? effectiveShareLimit - vaultLiabilityShares : 0,\n            vaultMintableSharesByRR > vaultLiabilityShares ? vaultMintableSharesByRR - vaultLiabilityShares : 0\n        );\n    }\n\n    /**\n     * @notice Returns the amount of ether that can be instantly withdrawn from the staking vault.\n     * @dev This is the amount of ether that is not locked in the StakingVault and not reserved for fees and obligations.\n     */\n    function withdrawableValue() public view returns (uint256) {\n        // On pending disconnect, the vault does not allow any withdrawals, so need to return 0 here\n        if (VAULT_HUB.vaultConnection(address(_stakingVault())).pendingDisconnect) return 0;\n\n        uint256 withdrawable = VAULT_HUB.withdrawableValue(address(_stakingVault()));\n        uint256 nodeOperatorFee = nodeOperatorDisbursableFee();\n\n        return withdrawable > nodeOperatorFee ? withdrawable - nodeOperatorFee : 0;\n    }\n\n    // ==================== Vault Management Functions ====================\n\n    /**\n     * @dev Automatically funds the staking vault with ether\n     */\n    receive() external payable {\n        if (_shouldFundOnReceive()) _fund(msg.value);\n    }\n\n    /**\n     * @notice Transfers the ownership of the underlying StakingVault from this contract to a new owner\n     *         without disconnecting it from the hub\n     * @param _newOwner Address of the new owner.\n     */\n    function transferVaultOwnership(address _newOwner) external {\n        _transferVaultOwnership(_newOwner);\n    }\n\n    /**\n     * @notice Disconnects the underlying StakingVault from the hub and passing its ownership to Dashboard.\n     *         After receiving the final report, one can call reconnectToVaultHub() to reconnect to the hub\n     *         or abandonDashboard() to transfer the ownership to a new owner.\n     */\n    function voluntaryDisconnect() external {\n        disburseNodeOperatorFee();\n\n        _voluntaryDisconnect();\n    }\n\n    /**\n     * @notice Accepts the ownership over the StakingVault transferred from VaultHub on disconnect\n     * and immediately transfers it to a new pending owner. This new owner will have to accept the ownership\n     * on the StakingVault contract.\n     * @param _newOwner The address to transfer the StakingVault ownership to.\n     */\n    function abandonDashboard(address _newOwner) external {\n        if (VAULT_HUB.isVaultConnected(address(_stakingVault()))) revert ConnectedToVaultHub();\n        if (_newOwner == address(this)) revert DashboardNotAllowed();\n\n        _acceptOwnership();\n        _transferOwnership(_newOwner);\n    }\n\n    /**\n     * @notice Accepts the ownership over the StakingVault and connects to VaultHub. Can be called to reconnect\n     *         to the hub after voluntaryDisconnect()\n     */\n    function reconnectToVaultHub() external {\n        _acceptOwnership();\n        connectToVaultHub();\n    }\n\n    /**\n     * @notice Connects to VaultHub, transferring ownership to VaultHub.\n     */\n    function connectToVaultHub() public payable {\n        if (msg.value > 0) _stakingVault().fund{value: msg.value}();\n        _transferOwnership(address(VAULT_HUB));\n        VAULT_HUB.connectVault(address(_stakingVault()));\n    }\n\n    /**\n     * @notice Changes the tier of the vault and connects to VaultHub\n     * @param _tierId The tier to change to\n     * @param _requestedShareLimit The requested share limit\n     */\n    function connectAndAcceptTier(uint256 _tierId, uint256 _requestedShareLimit) external payable {\n        connectToVaultHub();\n        if (!_changeTier(_tierId, _requestedShareLimit)) {\n            revert TierChangeNotConfirmed();\n        }\n    }\n\n    /**\n     * @notice Funds the staking vault with ether\n     */\n    function fund() external payable {\n        _fund(msg.value);\n    }\n\n    /**\n     * @notice Withdraws ether from the staking vault to a recipient\n     * @param _recipient Address of the recipient\n     * @param _ether Amount of ether to withdraw\n     */\n    function withdraw(address _recipient, uint256 _ether) external {\n        uint256 withdrawableEther = withdrawableValue();\n        if (_ether > withdrawableEther) {\n            revert ExceedsWithdrawable(_ether, withdrawableEther);\n        }\n\n        _withdraw(_recipient, _ether);\n    }\n\n    /**\n     * @notice Mints stETH shares backed by the vault to the recipient.\n     * @param _recipient Address of the recipient\n     * @param _amountOfShares Amount of stETH shares to mint\n     */\n    function mintShares(address _recipient, uint256 _amountOfShares) external payable fundable {\n        _mintSharesWithinMintingCapacity(_recipient, _amountOfShares);\n    }\n\n    /**\n     * @notice Mints stETH tokens backed by the vault to the recipient.\n     * !NB: this will revert with`VaultHub.ZeroArgument(\"_amountOfShares\")` if the amount of stETH is less than 1 share\n     * @param _recipient Address of the recipient\n     * @param _amountOfStETH Amount of stETH to mint\n     */\n    function mintStETH(address _recipient, uint256 _amountOfStETH) external payable fundable {\n        _mintSharesWithinMintingCapacity(_recipient, _getSharesByPooledEth(_amountOfStETH));\n    }\n\n    /**\n     * @notice Mints wstETH tokens backed by the vault to a recipient.\n     * @param _recipient Address of the recipient\n     * @param _amountOfWstETH Amount of tokens to mint\n     */\n    function mintWstETH(address _recipient, uint256 _amountOfWstETH) external payable fundable {\n        _mintSharesWithinMintingCapacity(address(this), _amountOfWstETH);\n\n        uint256 mintedStETH = STETH.getPooledEthBySharesRoundUp(_amountOfWstETH);\n\n        uint256 wrappedWstETH = WSTETH.wrap(mintedStETH);\n        SafeERC20.safeTransfer(WSTETH, _recipient, wrappedWstETH);\n    }\n\n    /**\n     * @notice Burns stETH shares from the sender backed by the vault.\n     *         Expects corresponding amount of stETH approved to this contract.\n     * @param _amountOfShares Amount of stETH shares to burn\n     */\n    function burnShares(uint256 _amountOfShares) external {\n        STETH.transferSharesFrom(msg.sender, address(VAULT_HUB), _amountOfShares);\n        _burnShares(_amountOfShares);\n    }\n\n    /**\n     * @notice Burns stETH tokens from the sender backed by the vault. Expects stETH amount approved to this contract.\n     * !NB: this will revert with `VaultHub.ZeroArgument(\"_amountOfShares\")` if the amount of stETH is less than 1 share\n     * @param _amountOfStETH Amount of stETH tokens to burn\n     */\n    function burnStETH(uint256 _amountOfStETH) external {\n        _burnStETH(_amountOfStETH);\n    }\n\n    /**\n     * @notice Burns wstETH tokens from the sender backed by the vault. Expects wstETH amount approved to this contract.\n     * !NB: this will revert with `VaultHub.ZeroArgument(\"_amountOfShares\")` on 1 wei of wstETH due to rounding inside wstETH unwrap method\n     * @param _amountOfWstETH Amount of wstETH tokens to burn\n\n     */\n    function burnWstETH(uint256 _amountOfWstETH) external {\n        _burnWstETH(_amountOfWstETH);\n    }\n\n    /**\n     * @notice Rebalances StakingVault by withdrawing ether to VaultHub corresponding to shares amount provided\n     * @param _shares amount of shares to rebalance\n     */\n    function rebalanceVaultWithShares(uint256 _shares) external {\n        _rebalanceVault(_shares);\n    }\n\n    /**\n     * @notice Rebalances the vault by transferring ether given the shares amount\n     * @param _ether amount of ether to rebalance\n     */\n    function rebalanceVaultWithEther(uint256 _ether) external payable fundable {\n        _rebalanceVault(_getSharesByPooledEth(_ether));\n    }\n\n    /**\n     * @notice Withdraws ether from vault and deposits directly to provided validators bypassing the default PDG process,\n     *          allowing validators to be proven post-factum via `proveUnknownValidatorsToPDG`\n     *          clearing them for future deposits via `PDG.depositToBeaconChain`\n     * @param _deposits array of IStakingVault.Deposit structs containing deposit data\n     * @return totalAmount total amount of ether deposited to beacon chain\n     * @dev requires the caller to have the `UNGUARANTEED_BEACON_CHAIN_DEPOSIT_ROLE`\n     * @dev can be used as PDG shortcut if the node operator is trusted to not frontrun provided deposits\n     */\n    function unguaranteedDepositToBeaconChain(\n        IStakingVault.Deposit[] calldata _deposits\n    ) external returns (uint256 totalAmount) {\n        IStakingVault stakingVault_ = _stakingVault();\n        IDepositContract depositContract = stakingVault_.DEPOSIT_CONTRACT();\n\n        for (uint256 i = 0; i < _deposits.length; i++) {\n            totalAmount += _deposits[i].amount;\n        }\n\n        uint256 withdrawableEther = withdrawableValue();\n        if (totalAmount > withdrawableEther) {\n            revert ExceedsWithdrawable(totalAmount, withdrawableEther);\n        }\n\n        _disableFundOnReceive();\n        _withdrawForUnguaranteedDepositToBeaconChain(totalAmount);\n        // Instead of relying on auto-reset at the end of the transaction,\n        // re-enable fund-on-receive manually to restore the default receive() behavior in the same transaction\n        _enableFundOnReceive();\n        _setRewardsAdjustment(rewardsAdjustment.amount + totalAmount);\n\n        bytes memory withdrawalCredentials = bytes.concat(stakingVault_.withdrawalCredentials());\n\n        IStakingVault.Deposit calldata deposit;\n        for (uint256 i = 0; i < _deposits.length; i++) {\n            deposit = _deposits[i];\n            depositContract.deposit{value: deposit.amount}(\n                deposit.pubkey,\n                withdrawalCredentials,\n                deposit.signature,\n                deposit.depositDataRoot\n            );\n        }\n\n        emit UnguaranteedDeposits(address(stakingVault_), _deposits.length, totalAmount);\n    }\n\n    /**\n     * @notice Proves validators with correct vault WC if they are unknown to PDG\n     * @param _witnesses array of IPredepositGuarantee.ValidatorWitness structs containing proof data for validators\n     * @dev requires the caller to have the `PDG_PROVE_VALIDATOR_ROLE`\n     */\n    function proveUnknownValidatorsToPDG(IPredepositGuarantee.ValidatorWitness[] calldata _witnesses) external {\n        _proveUnknownValidatorsToPDG(_witnesses);\n    }\n\n    /**\n     * @notice Compensates ether of disproven validator's predeposit from PDG to the recipient.\n     *         Can be called if validator which was predeposited via `PDG.predeposit` with vault funds\n     *         was frontrun by NO's with non-vault WC (effectively NO's stealing the predeposit) and then\n     *         proof of the validator's invalidity has been provided via `PDG.proveInvalidValidatorWC`.\n     * @param _pubkey of validator that was proven invalid in PDG\n     * @param _recipient address to receive the `PDG.PREDEPOSIT_AMOUNT`\n     * @dev PDG will revert if _recipient is vault address, use fund() instead to return ether to vault\n     * @dev requires the caller to have the `PDG_COMPENSATE_PREDEPOSIT_ROLE`\n     */\n    function compensateDisprovenPredepositFromPDG(bytes calldata _pubkey, address _recipient) external {\n        _compensateDisprovenPredepositFromPDG(_pubkey, _recipient);\n    }\n\n    /**\n     * @notice Recovers ERC20 tokens or ether from the dashboard contract to sender\n     * @param _token Address of the token to recover or 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee for ether\n     * @param _recipient Address of the recovery recipient\n     */\n    function recoverERC20(\n        address _token,\n        address _recipient,\n        uint256 _amount\n    ) external onlyRoleMemberOrAdmin(RECOVER_ASSETS_ROLE) {\n        _requireNotZero(_token);\n        _requireNotZero(_recipient);\n        _requireNotZero(_amount);\n\n        if (_token == ETH) {\n            (bool success,) = payable(_recipient).call{value: _amount}(\"\");\n            if (!success) revert EthTransferFailed(_recipient, _amount);\n        } else {\n            SafeERC20.safeTransfer(IERC20(_token), _recipient, _amount);\n        }\n\n        emit ERC20Recovered(_recipient, _token, _amount);\n    }\n\n    /**\n     * @notice Transfers a given token_id of an ERC721-compatible NFT (defined by the token contract address)\n     * from the dashboard contract to sender\n     *\n     * @param _token an ERC721-compatible token\n     * @param _tokenId token id to recover\n     * @param _recipient Address of the recovery recipient\n     */\n    function recoverERC721(\n        address _token,\n        uint256 _tokenId,\n        address _recipient\n    ) external onlyRoleMemberOrAdmin(RECOVER_ASSETS_ROLE) {\n        _requireNotZero(_token);\n        _requireNotZero(_recipient);\n\n        IERC721(_token).safeTransferFrom(address(this), _recipient, _tokenId);\n\n        emit ERC721Recovered(_recipient, _token, _tokenId);\n    }\n\n    /**\n     * @notice Pauses beacon chain deposits on the StakingVault.\n     */\n    function pauseBeaconChainDeposits() external {\n        _pauseBeaconChainDeposits();\n    }\n\n    /**\n     * @notice Resumes beacon chain deposits on the StakingVault.\n     */\n    function resumeBeaconChainDeposits() external {\n        _resumeBeaconChainDeposits();\n    }\n\n    /**\n     * @notice Signals to node operators that specific validators should exit from the beacon chain. It DOES NOT\n     *         directly trigger the exit - node operators must monitor for request events and handle the exits.\n     * @param _pubkeys Concatenated validator public keys (48 bytes each).\n     * @dev    Emits `ValidatorExitRequested` event for each validator public key through the `StakingVault`.\n     *         This is a voluntary exit request - node operators can choose whether to act on it or not.\n     */\n    function requestValidatorExit(bytes calldata _pubkeys) external {\n        _requestValidatorExit(_pubkeys);\n    }\n\n    /**\n     * @notice Initiates a withdrawal from validator(s) on the beacon chain using EIP-7002 triggerable withdrawals\n     *         Both partial withdrawals (disabled for if vault is unhealthy) and full validator exits are supported.\n     * @param _pubkeys Concatenated validator public keys (48 bytes each).\n     * @param _amounts Withdrawal amounts in wei for each validator key and must match _pubkeys length.\n     *         Set amount to 0 for a full validator exit.\n     *         For partial withdrawals, amounts will be trimmed to keep MIN_ACTIVATION_BALANCE on the validator to avoid deactivation\n     * @param _refundRecipient Address to receive any fee refunds, if zero, refunds go to msg.sender.\n     * @dev    A withdrawal fee must be paid via msg.value.\n     *         Use `StakingVault.calculateValidatorWithdrawalFee()` to determine the required fee for the current block.\n     */\n    function triggerValidatorWithdrawals(\n        bytes calldata _pubkeys,\n        uint64[] calldata _amounts,\n        address _refundRecipient\n    ) external payable {\n        _triggerValidatorWithdrawals(_pubkeys, _amounts, _refundRecipient);\n    }\n\n    /**\n     * @notice Requests a change of tier on the OperatorGrid.\n     * @param _tierId The tier to change to.\n     * @param _requestedShareLimit The requested share limit.\n     * @return bool Whether the tier change was confirmed.\n     */\n    function changeTier(uint256 _tierId, uint256 _requestedShareLimit) external returns (bool) {\n        return _changeTier(_tierId, _requestedShareLimit);\n    }\n\n    // ==================== Internal Functions ====================\n\n    /**\n     * @dev Modifier to fund the staking vault if msg.value > 0\n     */\n    modifier fundable() {\n        if (msg.value > 0) {\n            _fund(msg.value);\n        }\n        _;\n    }\n\n    /**\n     * @notice Mints shares within the mintable capacity,\n     *         and reverts if the resulting backing is greater than the mintable capacity.\n     * @param _recipient The address of the recipient.\n     * @param _amountOfShares The amount of shares to mint.\n     */\n    function _mintSharesWithinMintingCapacity(address _recipient, uint256 _amountOfShares) internal {\n        uint256 remainingShares = remainingMintingCapacityShares(0);\n        if (_amountOfShares > remainingShares) revert ExceedsMintingCapacity(_amountOfShares, remainingShares);\n\n        _mintShares(_recipient, _amountOfShares);\n    }\n\n    /**\n     * @dev Burns stETH tokens from the sender backed by the vault\n     * @param _amountOfStETH Amount of tokens to burn\n     */\n    function _burnStETH(uint256 _amountOfStETH) internal {\n        uint256 _amountOfShares = _getSharesByPooledEth(_amountOfStETH);\n        STETH.transferSharesFrom(msg.sender, address(VAULT_HUB), _amountOfShares);\n        _burnShares(_amountOfShares);\n    }\n\n    /**\n     * @dev Burns wstETH tokens from the sender backed by the vault\n     * @param _amountOfWstETH Amount of tokens to burn\n     */\n    function _burnWstETH(uint256 _amountOfWstETH) internal {\n        SafeERC20.safeTransferFrom(WSTETH, msg.sender, address(this), _amountOfWstETH);\n        uint256 unwrappedStETH = WSTETH.unwrap(_amountOfWstETH);\n        uint256 unwrappedShares = _getSharesByPooledEth(unwrappedStETH);\n\n        STETH.transferShares(address(VAULT_HUB), unwrappedShares);\n        _burnShares(unwrappedShares);\n    }\n\n    /// @notice Calculates the total number of shares that can be minted by the vault\n    /// @param _ether The amount of ether to consider for minting\n    function _mintableShares(uint256 _ether) internal view returns (uint256) {\n        uint256 mintableStETH = (_ether * (TOTAL_BASIS_POINTS - reserveRatioBP())) / TOTAL_BASIS_POINTS;\n        return _getSharesByPooledEth(mintableStETH);\n    }\n\n    /// @notice Converts the given amount of stETH to shares\n    function _getSharesByPooledEth(uint256 _amountOfStETH) internal view returns (uint256) {\n        return STETH.getSharesByPooledEth(_amountOfStETH);\n    }\n\n    // @dev The logic is inverted, 0 means fund-on-receive is enabled,\n    // so that fund-on-receive is enabled by default\n    function _shouldFundOnReceive() internal view returns (bool shouldFund) {\n        assembly {\n            shouldFund := iszero(tload(FUND_ON_RECEIVE_FLAG_SLOT))\n        }\n    }\n\n    function _enableFundOnReceive() internal {\n        assembly {\n            tstore(FUND_ON_RECEIVE_FLAG_SLOT, 0)\n        }\n    }\n\n    function _disableFundOnReceive() internal {\n        assembly {\n            tstore(FUND_ON_RECEIVE_FLAG_SLOT, 1)\n        }\n    }\n\n    // ==================== Events ====================\n\n    /**\n     * @notice Emitted when ether was withdrawn from the staking vault and deposited to validators directly bypassing PDG\n     * @param stakingVault the address of owned staking vault\n     * @param deposits the number of deposits\n     * @param totalAmount the total amount of ether deposited to beacon chain\n     */\n    event UnguaranteedDeposits(address indexed stakingVault, uint256 deposits, uint256 totalAmount);\n\n    /**\n     * @notice Emitted when the ERC20 `token` or ether is recovered (i.e. transferred)\n     * @param to The address of the recovery recipient\n     * @param token The address of the recovered ERC20 token (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee for ether)\n     * @param amount The amount of the token recovered\n     */\n    event ERC20Recovered(address indexed to, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when the ERC721-compatible `token` (NFT) recovered (i.e. transferred)\n     * @param to The address of the recovery recipient\n     * @param token The address of the recovered ERC721 token\n     * @param tokenId id of token recovered\n     */\n    event ERC721Recovered(address indexed to, address indexed token, uint256 tokenId);\n\n    // ==================== Errors ====================\n\n    /**\n     * @notice Emitted when the withdrawable amount of ether is exceeded\n     * @param amount The amount of ether that was attempted to be withdrawn\n     * @param withdrawableValue The amount of withdrawable ether available\n     */\n    error ExceedsWithdrawable(uint256 amount, uint256 withdrawableValue);\n\n    /**\n     * @notice Error thrown when minting capacity is exceeded\n     */\n    error ExceedsMintingCapacity(uint256 requestedShares, uint256 remainingShares);\n\n    /**\n     * @notice Error thrown when recovery of ETH fails on transfer to recipient\n     */\n    error EthTransferFailed(address recipient, uint256 amount);\n\n    /**\n     * @notice Error when the StakingVault is still connected to the VaultHub.\n     */\n    error ConnectedToVaultHub();\n\n    /**\n     * @notice Error thrown when attempting to connect to VaultHub without confirmed tier change\n     */\n    error TierChangeNotConfirmed();\n\n    /**\n     * @notice Error when attempting to abandon the Dashboard contract itself.\n     */\n    error DashboardNotAllowed();\n}\n"
    }
}