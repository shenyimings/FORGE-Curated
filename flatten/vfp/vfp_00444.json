{
    "vfp_id": "vfp_00444",
    "project_name": "cantina_sky_lockstake_aug2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Mixed usage of DAI and USDS in comments",
            "description": "1. **Description:** The codebase, particularly in `LockstakeClipper.sol`, contains inconsistent naming in comments, referencing both DAI and USDS, which may confuse developers.\n2. **Cause:** The comments were retained from MakerDAO's original codebase, where DAI was used, but were not fully updated to reflect the use of USDS in Sky's implementation.\n3. **Exploitation:** This is not directly exploitable by attackers but increases the risk of developer error during maintenance or upgrades due to misleading context.\n4. **Impact:** Could lead to misunderstandings during code reviews or future development, potentially introducing bugs if assumptions based on incorrect token references are made.\n",
            "severity": "Informational",
            "location": [
                "LockstakeClipper.sol"
            ],
            "files": [
                "lockstake/src/LockstakeClipper.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading comment in LockstakeClipper.kick about triggering bad debt accounting",
            "description": "1. **Description:** The comment in `LockstakeClipper.kick` suggests that bad debt accounting is triggered during the kick function, which starts a liquidation auction.\n2. **Cause:** The term \"bad debt\" is inaccurately used, as the actual determination of bad debt occurs later during `clipper.take`, not at the time of auction initiation.\n3. **Exploitation:** This is not exploitable by attackers but may mislead developers into thinking that financial loss is assessed at auction start.\n4. **Impact:** Could result in incorrect assumptions about the liquidation flow, potentially affecting the design of dependent systems or future modifications.\n",
            "severity": "Informational",
            "location": [
                "LockstakeClipper.sol#L279"
            ],
            "files": [
                "lockstake/src/LockstakeClipper.sol"
            ]
        }
    ],
    "affected_files": {
        "LockstakeClipper.sol": "// SPDX-FileCopyrightText: Â© 2021 Dai Foundation <www.daifoundation.org>\n// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.21;\n\ninterface VatLike {\n    function suck(address, address, uint256) external;\n    function move(address, address, uint256) external;\n    function flux(bytes32, address, address, uint256) external;\n    function slip(bytes32, address, int256) external;\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\n}\n\ninterface PipLike {\n    function peek() external returns (bytes32, bool);\n}\n\ninterface SpotterLike {\n    function par() external returns (uint256);\n    function ilks(bytes32) external returns (PipLike, uint256);\n}\n\ninterface DogLike {\n    function chop(bytes32) external returns (uint256);\n    function digs(bytes32, uint256) external;\n}\n\ninterface ClipperCallee {\n    function clipperCall(address, uint256, uint256, bytes calldata) external;\n}\n\ninterface AbacusLike {\n    function price(uint256, uint256) external view returns (uint256);\n}\n\ninterface CutteeLike {\n    function cut(uint256) external;\n    function drip() external;\n}\n\ninterface LockstakeEngineLike {\n    function ilk() external view returns (bytes32);\n    function onKick(address, uint256) external;\n    function onTake(address, address, uint256) external;\n    function onRemove(address, uint256, uint256) external;\n}\n\n// Clipper for use with the Lockstake Engine\ncontract LockstakeClipper {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"LockstakeClipper/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    bytes32             immutable public ilk;    // Collateral type of this LockstakeClipper\n    VatLike             immutable public vat;    // Core CDP Engine\n    LockstakeEngineLike immutable public engine; // Lockstake Engine\n\n    DogLike     public dog;      // Liquidation module\n    address     public vow;      // Recipient of dai raised in auctions\n    SpotterLike public spotter;  // Collateral price module\n    AbacusLike  public calc;     // Current price calculator\n    address     public cuttee;   // Contract for accounting bad debt (if not set, callback won't be executed)\n\n    uint256 public buf;    // Multiplicative factor to increase starting price                  [ray]\n    uint256 public tail;   // Time elapsed before auction reset                                 [seconds]\n    uint256 public cusp;   // Percentage drop before auction reset                              [ray]\n    uint64  public chip;   // Percentage of tab to suck from vow to incentivize keepers         [wad]\n    uint192 public tip;    // Flat fee to suck from vow to incentivize keepers                  [rad]\n    uint256 public chost;  // Cache the ilk dust times the ilk chop to prevent excessive SLOADs [rad]\n\n    uint256   public kicks;   // Total auctions\n    uint256[] public active;  // Array of active auction ids\n    uint256   public Due;     // Total due amount from active auctions\n\n    struct Sale {\n        uint256 pos;  // Index in active array\n        uint256 tab;  // Usds to raise      [rad]\n        uint256 due;  // Usds debt          [rad]\n        uint256 lot;  // collateral to sell [wad]\n        uint256 tot;  // static registry of total collateral to sell [wad]\n        address usr;  // Liquidated CDP\n        uint96  tic;  // Auction start time\n        uint256 top;  // Starting price     [ray]\n    }\n    mapping(uint256 => Sale) public sales;\n\n    uint256 internal locked;\n\n    // Levels for circuit breaker\n    // 0: no breaker\n    // 1: no new kick()\n    // 2: no new kick() or redo()\n    // 3: no new kick(), redo(), or take()\n    uint256 public stopped = 0;\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed what, address data);\n\n    event Kick(\n        uint256 indexed id,\n        uint256 top,\n        uint256 tab,\n        uint256 lot,\n        address indexed usr,\n        address indexed kpr,\n        uint256 coin\n    );\n    event Take(\n        uint256 indexed id,\n        uint256 max,\n        uint256 price,\n        uint256 owe,\n        uint256 tab,\n        uint256 lot,\n        address indexed usr\n    );\n    event Redo(\n        uint256 indexed id,\n        uint256 top,\n        uint256 tab,\n        uint256 lot,\n        address indexed usr,\n        address indexed kpr,\n        uint256 coin\n    );\n\n    event Yank(uint256 id);\n\n    // --- Init ---\n    constructor(address vat_, address spotter_, address dog_, address engine_) {\n        vat       = VatLike(vat_);\n        spotter   = SpotterLike(spotter_);\n        dog       = DogLike(dog_);\n        engine    = LockstakeEngineLike(engine_);\n        ilk       = engine.ilk();\n        buf       = RAY;\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Synchronization ---\n    modifier lock {\n        require(locked == 0, \"LockstakeClipper/system-locked\");\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    modifier isStopped(uint256 level) {\n        require(stopped < level, \"LockstakeClipper/stopped-incorrect\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external auth lock {\n        if      (what == \"buf\")         buf = data;\n        else if (what == \"tail\")       tail = data;           // Time elapsed before auction reset\n        else if (what == \"cusp\")       cusp = data;           // Percentage drop before auction reset\n        else if (what == \"chip\")       chip = uint64(data);   // Percentage of tab to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\n        else if (what == \"tip\")         tip = uint192(data);  // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T RAD)\n        else if (what == \"stopped\") stopped = data;           // Set breaker (0, 1, 2, or 3)\n        else revert(\"LockstakeClipper/file-unrecognized-param\");\n        emit File(what, data);\n    }\n    function file(bytes32 what, address data) external auth lock {\n        if (what == \"spotter\") spotter = SpotterLike(data);\n        else if (what == \"dog\")       dog = DogLike(data);\n        else if (what == \"vow\")       vow = data;\n        else if (what == \"calc\")     calc = AbacusLike(data);\n        else if (what == \"cuttee\") cuttee = data;\n        else revert(\"LockstakeClipper/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Math ---\n    uint256 constant BLN = 10 **  9;\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y / WAD;\n    }\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y / RAY;\n    }\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * RAY / y;\n    }\n\n    // --- Auction ---\n\n    // get the price directly from the pip\n    // Could get this from rmul(Vat.ilks(ilk).spot, Spotter.mat()) instead, but\n    // if mat has changed since the last poke, the resulting value will be\n    // incorrect.\n    function getFeedPrice() internal returns (uint256 feedPrice) {\n        (PipLike pip, ) = spotter.ilks(ilk);\n        (bytes32 val, bool has) = pip.peek();\n        require(has, \"LockstakeClipper/invalid-price\");\n        feedPrice = rdiv(uint256(val) * BLN, spotter.par());\n    }\n\n    // start an auction\n    // note: trusts the caller to transfer collateral to the contract\n    // The starting price `top` is obtained as follows:\n    //\n    //     top = val * buf / par\n    //\n    // Where `val` is the collateral's unitary value in USD, `buf` is a\n    // multiplicative factor to increase the starting price, and `par` is a\n    // reference per DAI.\n    function kick(\n        uint256 tab,  // Debt                   [rad]\n        uint256 lot,  // Collateral             [wad]\n        address usr,  // Address that will receive any leftover collateral; additionally assumed here to be the liquidated Vault.\n        address kpr   // Address that will receive incentives\n    ) external auth lock isStopped(1) returns (uint256 id) {\n        // Input validation\n        require(tab  >                         0, \"LockstakeClipper/zero-tab\");\n        require(lot  >                         0, \"LockstakeClipper/zero-lot\");\n        require(lot <= uint256(type(int256).max), \"LockstakeClipper/over-maxint-lot\"); // This is ensured by the dog but we still prefer to be explicit\n        require(usr !=                address(0), \"LockstakeClipper/zero-usr\");\n        unchecked { id = ++kicks; }\n        require(id   >                         0, \"LockstakeClipper/overflow\");\n\n        active.push(id);\n\n        sales[id].pos = active.length - 1;\n\n        sales[id].tab = tab;\n        Due += sales[id].due = tab * WAD / dog.chop(ilk); // Under approximation is not a problem for this\n        sales[id].lot = lot;\n        sales[id].tot = lot;\n        sales[id].usr = usr;\n        sales[id].tic = uint96(block.timestamp);\n\n        uint256 top;\n        top = rmul(getFeedPrice(), buf);\n        require(top > 0, \"LockstakeClipper/zero-top-price\");\n        sales[id].top = top;\n\n        // incentive to kick auction\n        uint256 _tip  = tip;\n        uint256 _chip = chip;\n        uint256 coin;\n        if (_tip > 0 || _chip > 0) {\n            coin = _tip + wmul(tab, _chip);\n            vat.suck(vow, kpr, coin);\n        }\n\n        // Trigger engine liquidation call-back\n        engine.onKick(usr, lot);\n        // Trigger cuttee accounting (will update line accordingly)\n        if (cuttee != address(0)) { CutteeLike(cuttee).drip(); }\n\n        emit Kick(id, top, tab, lot, usr, kpr, coin);\n    }\n\n    // Reset an auction\n    // See `kick` above for an explanation of the computation of `top`.\n    function redo(\n        uint256 id,  // id of the auction to reset\n        address kpr  // Address that will receive incentives\n    ) external lock isStopped(2) {\n        // Read auction data\n        address usr = sales[id].usr;\n        uint96  tic = sales[id].tic;\n        uint256 top = sales[id].top;\n\n        require(usr != address(0), \"LockstakeClipper/not-running-auction\");\n\n        // Check that auction needs reset\n        // and compute current price [ray]\n        (bool done,) = status(tic, top);\n        require(done, \"LockstakeClipper/cannot-reset\");\n\n        uint256 tab   = sales[id].tab;\n        uint256 lot   = sales[id].lot;\n        sales[id].tic = uint96(block.timestamp);\n\n        uint256 feedPrice = getFeedPrice();\n        top = rmul(feedPrice, buf);\n        require(top > 0, \"LockstakeClipper/zero-top-price\");\n        sales[id].top = top;\n\n        // incentive to redo auction\n        uint256 _tip  = tip;\n        uint256 _chip = chip;\n        uint256 coin;\n        if (_tip > 0 || _chip > 0) {\n            uint256 _chost = chost;\n            if (tab >= _chost && lot * feedPrice >= _chost) {\n                coin = _tip + wmul(tab, _chip);\n                vat.suck(vow, kpr, coin);\n            }\n        }\n\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\n    }\n\n    // Buy up to `amt` of collateral from the auction indexed by `id`.\n    // \n    // Auctions will not collect more DAI than their assigned DAI target,`tab`;\n    // thus, if `amt` would cost more DAI than `tab` at the current price, the\n    // amount of collateral purchased will instead be just enough to collect `tab` DAI.\n    //\n    // To avoid partial purchases resulting in very small leftover auctions that will\n    // never be cleared, any partial purchase must leave at least `LockstakeClipper.chost`\n    // remaining DAI target. `chost` is an asynchronously updated value equal to\n    // (Vat.dust * Dog.chop(ilk) / WAD) where the values are understood to be determined\n    // by whatever they were when LockstakeClipper.upchost() was last called. Purchase amounts\n    // will be minimally decreased when necessary to respect this limit; i.e., if the\n    // specified `amt` would leave `tab < chost` but `tab > 0`, the amount actually\n    // purchased will be such that `tab == chost`.\n    //\n    // If `tab <= chost`, partial purchases are no longer possible; that is, the remaining\n    // collateral can only be purchased entirely, or not at all.\n    function take(\n        uint256 id,           // Auction id\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\n        address who,          // Receiver of collateral and external call address\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\n    ) external lock isStopped(3) {\n\n        Sale memory sale;\n        sale.usr = sales[id].usr;\n        sale.tic = sales[id].tic;\n\n        require(sale.usr != address(0), \"LockstakeClipper/not-running-auction\");\n\n        uint256 price;\n        {\n            bool done;\n            (done, price) = status(sale.tic, sales[id].top);\n\n            // Check that auction doesn't need reset\n            require(!done, \"LockstakeClipper/needs-reset\");\n        }\n\n        // Ensure price is acceptable to buyer\n        require(max >= price, \"LockstakeClipper/too-expensive\");\n\n        sale.lot = sales[id].lot;\n        sale.tab = sales[id].tab;\n        uint256 owe;\n\n        {\n            // Purchase as much as possible, up to amt\n            uint256 slice = min(sale.lot, amt);  // slice <= sale.lot\n\n            // DAI needed to buy a slice of this sale\n            owe = slice * price;\n\n            // Don't collect more than tab of DAI\n            if (owe > sale.tab) {\n                // Total debt will be paid\n                owe = sale.tab;                  // owe' <= owe\n                // Adjust slice\n                slice = owe / price;             // slice' = owe' / price <= owe / price == slice <= lot\n            } else if (owe < sale.tab && slice < sale.lot) {\n                // If slice == lot => auction completed => dust doesn't matter\n                uint256 _chost = chost;\n                if (sale.tab - owe < _chost) {   // safe as owe < tab\n                    // If tab <= chost, buyers have to take the entire lot.\n                    require(sale.tab > _chost, \"LockstakeClipper/no-partial-purchase\");\n                    // Adjust amount to pay\n                    owe = sale.tab - _chost;     // owe' <= owe\n                    // Adjust slice\n                    slice = owe / price;         // slice' = owe' / price < owe / price == slice < lot\n                }\n            }\n\n            // Calculate remaining tab after operation\n            sale.tab = sale.tab - owe;  // safe since owe <= tab\n            // Calculate remaining lot after operation\n            sale.lot = sale.lot - slice;\n\n            // Send collateral to who\n            vat.slip(ilk, address(this), -int256(slice));\n            engine.onTake(sale.usr, who, slice);\n\n            // Do external call (if data is defined) but to be\n            // extremely careful we don't allow to do it to the four\n            // contracts which the LockstakeClipper needs to be authorized\n            DogLike dog_ = dog;\n            if (\n                data.length > 0 &&\n                who != address(vat) &&\n                who != address(dog_) &&\n                who != address(engine) &&\n                (who != cuttee || cuttee == address(0)) // Keep consistency executing with address(0) to revert\n            ) {\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\n            }\n\n            // Get DAI from caller\n            vat.move(msg.sender, vow, owe);\n\n            // Removes Dai out for liquidation from accumulator\n            dog_.digs(ilk, sale.lot == 0 ? sale.tab + owe : owe);\n        }\n\n        if (sale.lot == 0) {\n            engine.onRemove(sale.usr, sales[id].tot, 0);\n            uint256 due = sales[id].due;\n            Due -= due;\n            if (due > owe && cuttee != address(0)) {\n                CutteeLike(cuttee).cut(due - owe);\n            }\n            _remove(id);\n        } else if (sale.tab == 0) {\n            vat.slip(ilk, address(this), -int256(sale.lot));\n            engine.onRemove(sale.usr, sales[id].tot - sale.lot, sale.lot);\n            Due -= sales[id].due;\n            _remove(id);\n        } else {\n            sales[id].tab = sale.tab;\n            sales[id].lot = sale.lot;\n            uint256 sub = min(sales[id].due, owe);\n            sales[id].due -= sub;\n            Due -= sub;\n        }\n\n        // Note: In any case but the cut scenario, the line won't be updated accordingly, leaving a lower number than it should be (Due decrement is not accounted for).\n        // This can be updated with a permissionless call to cuttee.drip and not penalize every take with the extra gas cost.\n\n        emit Take(id, max, price, owe, sale.tab, sale.lot, sale.usr);\n    }\n\n    function _remove(uint256 id) internal {\n        uint256 _move    = active[active.length - 1];\n        if (id != _move) {\n            uint256 _index   = sales[id].pos;\n            active[_index]   = _move;\n            sales[_move].pos = _index;\n        }\n        active.pop();\n        delete sales[id];\n    }\n\n    // The number of active auctions\n    function count() external view returns (uint256) {\n        return active.length;\n    }\n\n    // Return the entire array of active auctions\n    function list() external view returns (uint256[] memory) {\n        return active;\n    }\n\n    // Externally returns boolean for if an auction needs a redo and also the current price\n    function getStatus(uint256 id) external view returns (bool needsRedo, uint256 price, uint256 lot, uint256 tab) {\n        // Read auction data\n        address usr = sales[id].usr;\n        uint96  tic = sales[id].tic;\n\n        bool done;\n        (done, price) = status(tic, sales[id].top);\n\n        needsRedo = usr != address(0) && done;\n        lot = sales[id].lot;\n        tab = sales[id].tab;\n    }\n\n    // Internally returns boolean for if an auction needs a redo\n    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\n        price = calc.price(top, block.timestamp - tic);\n        done  = (block.timestamp - tic > tail || rdiv(price, top) < cusp);\n    }\n\n    // Public function to update the cached dust*chop value.\n    function upchost() external {\n        (,,,, uint256 _dust) = VatLike(vat).ilks(ilk);\n        chost = wmul(_dust, dog.chop(ilk));\n    }\n\n    // Cancel an auction during End.cage or via other governance action.\n    // It is up to governance to define if cuttee.cut(sales[id].due) and cuttee.drip() needs to be called whenever yank is executed\n    function yank(uint256 id) external auth lock {\n        require(sales[id].usr != address(0), \"LockstakeClipper/not-running-auction\");\n        dog.digs(ilk, sales[id].tab);\n        uint256 lot = sales[id].lot;\n        vat.flux(ilk, address(this), msg.sender, lot);\n        engine.onRemove(sales[id].usr, 0, 0);\n        Due -= sales[id].due;\n        _remove(id);\n        emit Yank(id);\n    }\n}\n"
    }
}