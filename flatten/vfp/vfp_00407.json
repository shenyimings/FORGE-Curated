{
    "vfp_id": "vfp_00407",
    "project_name": "Periphery Changes Audit.md",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Integer Overflow in `_swapAndBridge`",
            "description": "In the `_swapAndBridge` function, the adjusted output amount is calculated as `depositData.outputAmount * returnAmount / minExpectedInputTokenAmount`. The multiplication occurs first, which can result in an intermediate integer overflow if the product exceeds 2^256-1, causing the transaction to revert without a descriptive error message. The root cause is the lack of overflow-safe arithmetic in the calculation. An attacker could exploit this by crafting a swap with large output values that trigger the overflow, leading to a failed transaction that appears as a generic revert to the user. The impact is a poor user experience and potential loss of gas fees due to undiagnosable transaction failures, even when the final result would have been within valid bounds.\n",
            "severity": "Low",
            "location": [
                "SpokePoolPeriphery.sol::_swapAndBridge#575",
                "SpokePoolPeriphery.sol#604-606"
            ],
            "files": [
                "contracts/contracts/SpokePoolPeriphery.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused Code",
            "description": "The codebase contains several instances of unused code elements, such as an unused error definition and an unused import statement. These elements do not serve any functional purpose in the current implementation. The presence of unused code increases code complexity and reduces readability, making audits and future maintenance more difficult. There is no direct exploitation path, but it can lead to confusion or accidental reintroduction of deprecated logic. The impact is limited to maintainability and code clarity.\n",
            "severity": "Informational",
            "location": [
                "SpokePoolPeriphery.sol::InvalidSignatureLength#165",
                "SpokePoolPeripheryInterface.sol#6"
            ],
            "files": [
                "contracts/contracts/SpokePoolPeriphery.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Documentation",
            "description": "Multiple instances of misleading or outdated documentation were found in the codebase. For example, certain functions are documented to fail under specific conditions (e.g., missing permit support), but the actual implementation uses try/catch blocks to silently handle such failures. Additionally, some comments reference non-existent or incorrect function names, and others contain outdated explanations about immutability. This discrepancy between documentation and implementation can mislead developers and auditors, potentially leading to incorrect assumptions about security behavior. The root cause is lack of synchronization between code changes and documentation updates. While there is no direct financial impact, the risk of incorrect integration or misinterpretation is elevated. The impact is primarily on code clarity and developer trust.\n",
            "severity": "Informational",
            "location": [
                "SpokePoolPeriphery.sol::swapAndBridgeWithPermit#267",
                "SpokePoolPeriphery.sol::depositWithPermit#375",
                "SpokePoolPeripheryInterface.sol#154",
                "SpokePoolPeriphery.sol#325",
                "SpokePoolPeriphery.sol#140",
                "SpokePoolPeripheryInterface.sol#16",
                "SpokePoolPeriphery.sol#136-L137"
            ],
            "files": [
                "contracts/contracts/SpokePoolPeriphery.sol"
            ]
        }
    ],
    "affected_files": {
        "SpokePoolPeriphery.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { MultiCaller } from \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport { Lockable } from \"./Lockable.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { V3SpokePoolInterface } from \"./interfaces/V3SpokePoolInterface.sol\";\nimport { IERC20Auth } from \"./external/interfaces/IERC20Auth.sol\";\nimport { WETH9Interface } from \"./external/interfaces/WETH9Interface.sol\";\nimport { IPermit2 } from \"./external/interfaces/IPermit2.sol\";\nimport { PeripherySigningLib } from \"./libraries/PeripherySigningLib.sol\";\nimport { SpokePoolPeripheryInterface } from \"./interfaces/SpokePoolPeripheryInterface.sol\";\nimport { AddressToBytes32 } from \"./libraries/AddressConverters.sol\";\n\n/**\n * @title SwapProxy\n * @notice A dedicated proxy contract that isolates swap execution to mitigate frontrunning vulnerabilities.\n * The SpokePoolPeriphery transfers tokens to this contract, which performs the swap and returns tokens back to the periphery.\n * @custom:security-contact bugs@across.to\n */\ncontract SwapProxy is Lockable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // Canonical Permit2 contract address\n    IPermit2 public immutable permit2;\n\n    // EIP 1271 magic bytes indicating a valid signature.\n    bytes4 private constant EIP1271_VALID_SIGNATURE = 0x1626ba7e;\n\n    // EIP 1271 bytes indicating an invalid signature.\n    bytes4 private constant EIP1271_INVALID_SIGNATURE = 0xffffffff;\n\n    // Nonce for this contract to use for EIP1271 \"signatures\".\n    uint48 private eip1271Nonce;\n\n    // Slot for checking whether this contract is expecting a callback from permit2. Used to confirm whether it should return a valid signature response.\n    bool private expectingPermit2Callback;\n\n    // Errors\n    error SwapFailed();\n    error UnsupportedTransferType();\n\n    /**\n     * @notice Constructs a new SwapProxy.\n     * @param _permit2 Address of the canonical permit2 contract.\n     */\n    constructor(address _permit2) {\n        permit2 = IPermit2(_permit2);\n    }\n\n    /**\n     * @notice Executes a swap on the given exchange with the provided calldata.\n     * @param inputToken The token to swap from\n     * @param outputToken The token to swap to\n     * @param inputAmount The amount of input tokens to swap\n     * @param exchange The exchange to perform the swap\n     * @param transferType The method of transferring tokens to the exchange\n     * @param routerCalldata The calldata to execute on the exchange\n     * @return outputAmount The actual amount of output tokens received from the swap\n     */\n    function performSwap(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        address exchange,\n        SpokePoolPeripheryInterface.TransferType transferType,\n        bytes calldata routerCalldata\n    ) external nonReentrant returns (uint256 outputAmount) {\n        // We'll return the final balance of output tokens\n\n        // The exchange will either receive funds from this contract via:\n        // 1. A direct approval to spend funds on this contract (TransferType.Approval),\n        // 2. A direct transfer of funds to the exchange (TransferType.Transfer), or\n        // 3. A permit2 approval (TransferType.Permit2Approval)\n        if (transferType == SpokePoolPeripheryInterface.TransferType.Approval) {\n            IERC20(inputToken).forceApprove(exchange, inputAmount);\n        } else if (transferType == SpokePoolPeripheryInterface.TransferType.Transfer) {\n            IERC20(inputToken).safeTransfer(exchange, inputAmount);\n        } else if (transferType == SpokePoolPeripheryInterface.TransferType.Permit2Approval) {\n            IERC20(inputToken).forceApprove(address(permit2), inputAmount);\n            expectingPermit2Callback = true;\n            permit2.permit(\n                address(this), // owner\n                IPermit2.PermitSingle({\n                    details: IPermit2.PermitDetails({\n                        token: inputToken,\n                        amount: uint160(inputAmount),\n                        expiration: uint48(block.timestamp),\n                        nonce: eip1271Nonce++\n                    }),\n                    spender: exchange,\n                    sigDeadline: block.timestamp\n                }), // permitSingle\n                \"0x\" // signature is unused. The only verification for a valid signature is if we are at this code block.\n            );\n            expectingPermit2Callback = false;\n        } else {\n            revert UnsupportedTransferType();\n        }\n\n        // Execute the swap\n        (bool success, ) = exchange.call(routerCalldata);\n        if (!success) revert SwapFailed();\n\n        // Get the final output token balance\n        uint256 outputBalance = IERC20(outputToken).balanceOf(address(this));\n\n        // Transfer all output tokens back to the periphery\n        IERC20(outputToken).safeTransfer(msg.sender, outputBalance);\n\n        // Return the net amount received from the swap\n        return outputBalance;\n    }\n\n    /**\n     * @notice Verifies that the signer is the owner of the signing contract.\n     * @dev This function is called by Permit2 during the permit process\n     * and we need to return a valid signature result to allow permit2 to succeed.\n     */\n    function isValidSignature(bytes32, bytes calldata) external view returns (bytes4 magicBytes) {\n        magicBytes = (msg.sender == address(permit2) && expectingPermit2Callback)\n            ? EIP1271_VALID_SIGNATURE\n            : EIP1271_INVALID_SIGNATURE;\n    }\n}\n\n/**\n * @title SpokePoolPeriphery\n * @notice Contract for performing more complex interactions with an Across spoke pool deployment.\n * @dev Variables which may be immutable are not marked as immutable, nor defined in the constructor, so that this\n * contract may be deployed deterministically at the same address across different networks.\n * @custom:security-contact bugs@across.to\n */\ncontract SpokePoolPeriphery is SpokePoolPeripheryInterface, Lockable, MultiCaller, EIP712 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using AddressToBytes32 for address;\n\n    // Canonical Permit2 contract address.\n    IPermit2 public immutable permit2;\n\n    // Swap proxy used for isolating all swap operations\n    SwapProxy public immutable swapProxy;\n\n    event SwapBeforeBridge(\n        address exchange,\n        bytes exchangeCalldata,\n        address indexed swapToken,\n        address indexed acrossInputToken,\n        uint256 swapTokenAmount,\n        uint256 acrossInputAmount,\n        bytes32 indexed acrossOutputToken,\n        uint256 acrossOutputAmount\n    );\n\n    /****************************************\n     *                ERRORS                *\n     ****************************************/\n    error InvalidSignatureLength();\n    error MinimumExpectedInputAmount();\n    error InvalidMsgValue();\n    error InvalidSpokePool();\n    error InvalidSwapToken();\n    error InvalidSignature();\n    error InvalidMinExpectedInputAmount();\n\n    /**\n     * @notice Construct a new Periphery contract.\n     * @param _permit2 Address of the canonical permit2 contract.\n     */\n    constructor(IPermit2 _permit2) EIP712(\"ACROSS-PERIPHERY\", \"1.0.0\") {\n        require(address(_permit2) != address(0), \"Permit2 cannot be zero address\");\n        require(_isContract(address(_permit2)), \"Permit2 must be a contract\");\n        permit2 = _permit2;\n\n        // Deploy the swap proxy with reference to the permit2 address\n        swapProxy = new SwapProxy(address(_permit2));\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function deposit(\n        address spokePool,\n        address recipient,\n        address inputToken,\n        uint256 inputAmount,\n        bytes32 outputToken,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes memory message\n    ) external payable override nonReentrant {\n        if (msg.value != inputAmount) revert InvalidMsgValue();\n        if (!_isContract(spokePool)) revert InvalidSpokePool();\n\n        // Set msg.sender as the depositor so that msg.sender can speed up the deposit.\n        V3SpokePoolInterface(spokePool).deposit{ value: msg.value }(\n            msg.sender.toBytes32(),\n            recipient.toBytes32(),\n            inputToken.toBytes32(),\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer.toBytes32(),\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function swapAndBridge(SwapAndDepositData calldata swapAndDepositData) external payable override nonReentrant {\n        // If a user performs a swapAndBridge with the swap token as the native token, wrap the value and treat the rest of transaction\n        // as though the user deposited a wrapped native token.\n        if (msg.value != 0) {\n            if (msg.value != swapAndDepositData.swapTokenAmount) revert InvalidMsgValue();\n            if (!_isContract(address(swapAndDepositData.swapToken))) revert InvalidSwapToken();\n            // Assume swapToken implements WETH9 interface if sending value\n            WETH9Interface(swapAndDepositData.swapToken).deposit{ value: msg.value }();\n        } else {\n            // Transfer ERC20 tokens from sender to this contract\n            IERC20(swapAndDepositData.swapToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                swapAndDepositData.swapTokenAmount\n            );\n        }\n\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function swapAndBridgeWithPermit(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external override nonReentrant {\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(permitSignature);\n        // Load variables used in this function onto the stack.\n        address _swapToken = swapAndDepositData.swapToken;\n        uint256 _swapTokenAmount = swapAndDepositData.swapTokenAmount;\n        uint256 _submissionFeeAmount = swapAndDepositData.submissionFees.amount;\n        address _submissionFeeRecipient = swapAndDepositData.submissionFees.recipient;\n        uint256 _pullAmount = _submissionFeeAmount + _swapTokenAmount;\n\n        // For permit transactions, we wrap the call in a try/catch block so that the transaction will continue even if the call to\n        // permit fails. For example, this may be useful if the permit signature, which can be redeemed by anyone, is executed by somebody\n        // other than this contract.\n        try IERC20Permit(_swapToken).permit(signatureOwner, address(this), _pullAmount, deadline, v, r, s) {} catch {}\n        IERC20(_swapToken).safeTransferFrom(signatureOwner, address(this), _pullAmount);\n        _paySubmissionFees(_swapToken, _submissionFeeRecipient, _submissionFeeAmount);\n        // Verify that the signatureOwner signed the input swapAndDepositData.\n        _validateSignature(\n            signatureOwner,\n            PeripherySigningLib.hashSwapAndDepositData(swapAndDepositData),\n            swapAndDepositDataSignature\n        );\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function swapAndBridgeWithPermit2(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external override nonReentrant {\n        bytes32 witness = PeripherySigningLib.hashSwapAndDepositData(swapAndDepositData);\n        uint256 _submissionFeeAmount = swapAndDepositData.submissionFees.amount;\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: swapAndDepositData.swapTokenAmount + _submissionFeeAmount\n        });\n\n        permit2.permitWitnessTransferFrom(\n            permit,\n            transferDetails,\n            signatureOwner,\n            witness,\n            PeripherySigningLib.EIP712_SWAP_AND_DEPOSIT_TYPE_STRING,\n            signature\n        );\n        _paySubmissionFees(\n            swapAndDepositData.swapToken,\n            swapAndDepositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function swapAndBridgeWithAuthorization(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external override nonReentrant {\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(receiveWithAuthSignature);\n        uint256 _submissionFeeAmount = swapAndDepositData.submissionFees.amount;\n        // While any contract can vacuously implement `transferWithAuthorization` (or just have a fallback),\n        // if tokens were not sent to this contract, by this call to swapData.swapToken, this function will revert\n        // when attempting to swap tokens it does not own.\n        IERC20Auth(address(swapAndDepositData.swapToken)).receiveWithAuthorization(\n            signatureOwner,\n            address(this),\n            swapAndDepositData.swapTokenAmount + _submissionFeeAmount,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n        _paySubmissionFees(\n            swapAndDepositData.swapToken,\n            swapAndDepositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n\n        // Verify that the signatureOwner signed the input swapAndDepositData.\n        _validateSignature(\n            signatureOwner,\n            PeripherySigningLib.hashSwapAndDepositData(swapAndDepositData),\n            swapAndDepositDataSignature\n        );\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositWithPermit(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata depositDataSignature\n    ) external override nonReentrant {\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(permitSignature);\n        // Load variables used in this function onto the stack.\n        address _inputToken = depositData.baseDepositData.inputToken;\n        uint256 _inputAmount = depositData.inputAmount;\n        uint256 _submissionFeeAmount = depositData.submissionFees.amount;\n        address _submissionFeeRecipient = depositData.submissionFees.recipient;\n        uint256 _pullAmount = _submissionFeeAmount + _inputAmount;\n\n        // For permit transactions, we wrap the call in a try/catch block so that the transaction will continue even if the call to\n        // permit fails. For example, this may be useful if the permit signature, which can be redeemed by anyone, is executed by somebody\n        // other than this contract.\n        try IERC20Permit(_inputToken).permit(signatureOwner, address(this), _pullAmount, deadline, v, r, s) {} catch {}\n        IERC20(_inputToken).safeTransferFrom(signatureOwner, address(this), _pullAmount);\n        _paySubmissionFees(_inputToken, _submissionFeeRecipient, _submissionFeeAmount);\n\n        // Verify that the signatureOwner signed the input depositData.\n        _validateSignature(signatureOwner, PeripherySigningLib.hashDepositData(depositData), depositDataSignature);\n        _deposit(\n            depositData.spokePool,\n            depositData.baseDepositData.depositor,\n            depositData.baseDepositData.recipient,\n            _inputToken,\n            depositData.baseDepositData.outputToken,\n            _inputAmount,\n            depositData.baseDepositData.outputAmount,\n            depositData.baseDepositData.destinationChainId,\n            depositData.baseDepositData.exclusiveRelayer,\n            depositData.baseDepositData.quoteTimestamp,\n            depositData.baseDepositData.fillDeadline,\n            depositData.baseDepositData.exclusivityParameter,\n            depositData.baseDepositData.message\n        );\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositWithPermit2(\n        address signatureOwner,\n        DepositData calldata depositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external override nonReentrant {\n        bytes32 witness = PeripherySigningLib.hashDepositData(depositData);\n        uint256 _submissionFeeAmount = depositData.submissionFees.amount;\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: depositData.inputAmount + _submissionFeeAmount\n        });\n\n        permit2.permitWitnessTransferFrom(\n            permit,\n            transferDetails,\n            signatureOwner,\n            witness,\n            PeripherySigningLib.EIP712_DEPOSIT_TYPE_STRING,\n            signature\n        );\n        _paySubmissionFees(\n            depositData.baseDepositData.inputToken,\n            depositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n\n        _deposit(\n            depositData.spokePool,\n            depositData.baseDepositData.depositor,\n            depositData.baseDepositData.recipient,\n            depositData.baseDepositData.inputToken,\n            depositData.baseDepositData.outputToken,\n            depositData.inputAmount,\n            depositData.baseDepositData.outputAmount,\n            depositData.baseDepositData.destinationChainId,\n            depositData.baseDepositData.exclusiveRelayer,\n            depositData.baseDepositData.quoteTimestamp,\n            depositData.baseDepositData.fillDeadline,\n            depositData.baseDepositData.exclusivityParameter,\n            depositData.baseDepositData.message\n        );\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositWithAuthorization(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata depositDataSignature\n    ) external override nonReentrant {\n        // Load variables used multiple times onto the stack.\n        uint256 _inputAmount = depositData.inputAmount;\n        uint256 _submissionFeeAmount = depositData.submissionFees.amount;\n\n        // Redeem the receiveWithAuthSignature.\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(receiveWithAuthSignature);\n        IERC20Auth(depositData.baseDepositData.inputToken).receiveWithAuthorization(\n            signatureOwner,\n            address(this),\n            _inputAmount + _submissionFeeAmount,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n        _paySubmissionFees(\n            depositData.baseDepositData.inputToken,\n            depositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n\n        // Verify that the signatureOwner signed the input depositData.\n        _validateSignature(signatureOwner, PeripherySigningLib.hashDepositData(depositData), depositDataSignature);\n        _deposit(\n            depositData.spokePool,\n            depositData.baseDepositData.depositor,\n            depositData.baseDepositData.recipient,\n            depositData.baseDepositData.inputToken,\n            depositData.baseDepositData.outputToken,\n            _inputAmount,\n            depositData.baseDepositData.outputAmount,\n            depositData.baseDepositData.destinationChainId,\n            depositData.baseDepositData.exclusiveRelayer,\n            depositData.baseDepositData.quoteTimestamp,\n            depositData.baseDepositData.fillDeadline,\n            depositData.baseDepositData.exclusivityParameter,\n            depositData.baseDepositData.message\n        );\n    }\n\n    /**\n     * @notice Returns the contract's EIP712 domain separator, used to sign hashed depositData/swapAndDepositData types.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Validates that the typed data hash corresponds to the input signature owner and corresponding signature.\n     * @param signatureOwner The alledged signer of the input hash.\n     * @param typedDataHash The EIP712 data hash to check the signature against.\n     * @param signature The signature to validate.\n     */\n    function _validateSignature(\n        address signatureOwner,\n        bytes32 typedDataHash,\n        bytes calldata signature\n    ) private view {\n        if (!SignatureChecker.isValidSignatureNow(signatureOwner, _hashTypedDataV4(typedDataHash), signature)) {\n            revert InvalidSignature();\n        }\n    }\n\n    /**\n     * @notice Approves the spoke pool and calls `depositV3` function with the specified input parameters.\n     * @param depositor The address on the origin chain which should be treated as the depositor by Across, and will therefore receive refunds if this deposit\n     * is unfilled.\n     * @param recipient The address on the destination chain which should receive outputAmount of outputToken.\n     * @param inputToken The token to deposit on the origin chain.\n     * @param outputToken The token to receive on the destination chain.\n     * @param inputAmount The amount of the input token to deposit.\n     * @param outputAmount The amount of the output token to receive.\n     * @param destinationChainId The network ID for the destination chain.\n     * @param exclusiveRelayer The optional address for an Across relayer which may fill the deposit exclusively.\n     * @param quoteTimestamp The timestamp at which the relay and LP fee was calculated.\n     * @param fillDeadline The timestamp at which the deposit must be filled before it will be refunded by Across.\n     * @param exclusivityParameter The deadline or offset during which the exclusive relayer has rights to fill the deposit without contention.\n     * @param message The message to execute on the destination chain.\n     */\n    function _deposit(\n        address spokePool,\n        address depositor,\n        bytes32 recipient,\n        address inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) private {\n        if (!_isContract(spokePool)) revert InvalidSpokePool();\n        IERC20(inputToken).forceApprove(spokePool, inputAmount);\n        V3SpokePoolInterface(spokePool).deposit(\n            depositor.toBytes32(),\n            recipient,\n            inputToken.toBytes32(),\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice Swaps a token on the origin chain before depositing into the Across spoke pool atomically.\n     * @param swapAndDepositData The parameters to use when calling both the swap on an exchange and bridging via an Across spoke pool.\n     */\n    function _swapAndBridge(SwapAndDepositData calldata swapAndDepositData) private {\n        // Load variables we use multiple times onto the stack.\n        IERC20 _swapToken = IERC20(swapAndDepositData.swapToken);\n        IERC20 _acrossInputToken = IERC20(swapAndDepositData.depositData.inputToken);\n        address _exchange = swapAndDepositData.exchange;\n        uint256 _swapTokenAmount = swapAndDepositData.swapTokenAmount;\n\n        // Transfer tokens to the swap proxy for executing the swap\n        _swapToken.safeTransfer(address(swapProxy), _swapTokenAmount);\n\n        // Execute the swap via the swap proxy using the appropriate transfer type\n        // This function will swap _swapToken for _acrossInputToken and return the amount of _acrossInputToken received\n        uint256 returnAmount = swapProxy.performSwap(\n            address(_swapToken),\n            address(_acrossInputToken),\n            _swapTokenAmount,\n            _exchange,\n            swapAndDepositData.transferType,\n            swapAndDepositData.routerCalldata\n        );\n\n        // Sanity check that received amount from swap is enough to submit Across deposit with.\n        if (returnAmount < swapAndDepositData.minExpectedInputTokenAmount) revert MinimumExpectedInputAmount();\n\n        // Calculate adjusted output amount based on whether proportional adjustment is enabled\n        if (swapAndDepositData.minExpectedInputTokenAmount == 0) revert InvalidMinExpectedInputAmount();\n        uint256 adjustedOutputAmount;\n        if (swapAndDepositData.enableProportionalAdjustment) {\n            // Adjust the output amount proportionally based on the returned input amount\n            adjustedOutputAmount =\n                (swapAndDepositData.depositData.outputAmount * returnAmount) /\n                swapAndDepositData.minExpectedInputTokenAmount;\n        } else {\n            // Use the fixed output amount without adjustment\n            adjustedOutputAmount = swapAndDepositData.depositData.outputAmount;\n        }\n\n        emit SwapBeforeBridge(\n            _exchange,\n            swapAndDepositData.routerCalldata,\n            address(_swapToken),\n            address(_acrossInputToken),\n            _swapTokenAmount,\n            returnAmount,\n            swapAndDepositData.depositData.outputToken,\n            adjustedOutputAmount\n        );\n\n        // Deposit the swapped tokens into Across and bridge them using remainder of input params.\n        _deposit(\n            swapAndDepositData.spokePool,\n            swapAndDepositData.depositData.depositor,\n            swapAndDepositData.depositData.recipient,\n            address(_acrossInputToken),\n            swapAndDepositData.depositData.outputToken,\n            returnAmount,\n            adjustedOutputAmount,\n            swapAndDepositData.depositData.destinationChainId,\n            swapAndDepositData.depositData.exclusiveRelayer,\n            swapAndDepositData.depositData.quoteTimestamp,\n            swapAndDepositData.depositData.fillDeadline,\n            swapAndDepositData.depositData.exclusivityParameter,\n            swapAndDepositData.depositData.message\n        );\n    }\n\n    function _paySubmissionFees(\n        address feeToken,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (amount > 0) {\n            IERC20(feeToken).safeTransfer(recipient, amount);\n        }\n    }\n\n    /**\n     * @notice Internal function to check if an address is a contract\n     * @dev This is a replacement for OpenZeppelin's isContract function which is deprecated\n     * @param addr The address to check\n     * @return True if the address is a contract, false otherwise\n     */\n    function _isContract(address addr) private view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n"
    }
}