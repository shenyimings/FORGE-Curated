{
    "vfp_id": "vfp_00246",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ]
            },
            "title": "Inconsistent Sanity Check for Versioning",
            "description": "Different components perform inconsistent version validationâ€”BytecodeRepository checks versions between 100 and 999, while AddressProvider only checks if above 100.\nCause: Lack of standardized version validation logic across contracts.\nExploitation: Could allow deployment of contracts with unexpectedly high version numbers if only AddressProvider validation is used.\nImpact: Inconsistent behavior and potential for version confusion across the system.\n",
            "severity": "Informational",
            "location": [
                "BytecodeRepository::_validateVersion",
                "AddressProvider::_validateVersion"
            ],
            "files": [
                "permissionless/contracts/global/BytecodeRepository.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-193"
                ]
            },
            "title": "Redundant Chunk",
            "description": "The _writeInitCode function in BytecodeRepository may create an empty final chunk when the initCode length is a multiple of chunkSize.\nCause: The chunk count is calculated using division with ceiling, which can result in one extra empty chunk.\nExploitation: No direct security impact, but wastes storage and gas.\nImpact: Inefficient use of storage and increased deployment cost.\n",
            "severity": "Informational",
            "location": [
                "BytecodeRepository::_writeInitCode"
            ],
            "files": [
                "permissionless/contracts/global/BytecodeRepository.sol"
            ]
        }
    ],
    "affected_files": {
        "BytecodeRepository.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {IBytecodeRepository} from \"../interfaces/IBytecodeRepository.sol\";\nimport {AP_BYTECODE_REPOSITORY} from \"../libraries/ContractLiterals.sol\";\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\nimport {SanityCheckTrait} from \"@gearbox-protocol/core-v3/contracts/traits/SanityCheckTrait.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\nimport \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {Bytecode, BytecodePointer, AuditorSignature} from \"../interfaces/Types.sol\";\nimport {EIP712Mainnet} from \"../helpers/EIP712Mainnet.sol\";\nimport {Domain} from \"../libraries/Domain.sol\";\nimport {ImmutableOwnableTrait} from \"../traits/ImmutableOwnableTrait.sol\";\nimport {SSTORE2} from \"@solady/utils/SSTORE2.sol\";\n/**\n * @title BytecodeRepository\n *\n * @notice\n * The `BytecodeRepository` is a singleton contract responsible for deploying all contracts in the system for risk curators.\n *\n * Each contract is identified by two parameters:\n * - ContractType: bytes32. Can be further split into two parts:\n *   - Domain: Represents the fundamental category or name of the smart contract. For example,\n *     contracts like `Pools` or `CreditManagers` use the contract name as the domain.\n *   - Postfix: For contracts that offer different implementations under the same interface\n *     (such as interest rate models, adapters, or price feeds), the domain remains fixed.\n *     Variations are distinguished using a postfix. This is established by convention.\n * - Version: uint256: Specifies the version of the contract in semver. (example: 3_10)\n *\n * ContractType Convention:\n *  - The contract type follows a capitalized snake_case naming convention\n *    without any version information (example: \"POOL\", \"CREDIT_MANAGER\")\n *  - List of domains:\n *    RK_ - rate keepers. Supports IRateKeeperBase interface.\n *    IRM_ - interest rate models\n *\n * This structure ensures consistency and clarity when deploying and managing contracts within the system.\n */\n\ncontract BytecodeRepository is ImmutableOwnableTrait, SanityCheckTrait, IBytecodeRepository, EIP712Mainnet {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using ECDSA for bytes32;\n    using LibString for bytes32;\n    using LibString for string;\n    using LibString for uint256;\n    using Domain for string;\n    using SSTORE2 for bytes;\n    //\n    // CONSTANTS\n    //\n\n    /// @notice Meta info about contract type & version\n    uint256 public constant override version = 3_10;\n    bytes32 public constant override contractType = AP_BYTECODE_REPOSITORY;\n\n    bytes32 public constant BYTECODE_TYPEHASH =\n        keccak256(\"Bytecode(bytes32 contractType,uint256 version,bytes initCode,address author,string source)\");\n\n    bytes32 public constant AUDITOR_SIGNATURE_TYPEHASH =\n        keccak256(\"SignBytecodeHash(bytes32 bytecodeHash,string reportUrl)\");\n\n    //\n    // STORAGE\n    //\n\n    // bytecodeHash =>  Bytecode\n    mapping(bytes32 => BytecodePointer) internal _bytecodeByHash;\n\n    // bytecodeHash => array of AuditorSignature\n    mapping(bytes32 => AuditorSignature[]) internal _auditorSignaturesByHash;\n\n    EnumerableSet.Bytes32Set internal _bytecodeHashes;\n\n    // contractType => version => bytecodeHash\n    mapping(bytes32 => mapping(uint256 => bytes32)) public approvedBytecodeHash;\n\n    // address => bytecodeHash\n    mapping(address => bytes32) public deployedContracts;\n\n    // Forbidden initCodes\n    mapping(bytes32 => bool) public forbiddenInitCode;\n\n    // Allowed system contracts\n    mapping(bytes32 => bool) public allowedSystemContracts;\n\n    // Distinguish system vs. public domains\n    EnumerableSet.Bytes32Set private _publicDomains;\n\n    // if contractType is public\n    mapping(bytes32 => address) public contractTypeOwner;\n\n    // Auditors\n    EnumerableSet.AddressSet private _auditors;\n\n    // Auditor => name\n    mapping(address => string) public auditorName;\n\n    // Postfixes are used to deploy unique contract versions inherited from\n    // the base contract but differ when used with specific tokens.\n    // For example, the USDT pool, which supports fee computation without errors\n    mapping(address => bytes32) public tokenSpecificPostfixes;\n\n    // Version control\n    mapping(bytes32 => uint256) public latestVersion;\n    mapping(bytes32 => mapping(uint256 => uint256)) public latestMinorVersion;\n    mapping(bytes32 => mapping(uint256 => uint256)) public latestPatchVersion;\n\n    constructor(address _owner)\n        EIP712Mainnet(contractType.fromSmallString(), version.toString())\n        ImmutableOwnableTrait(_owner)\n    {}\n\n    /// @notice Computes a unique hash for _bytecode metadata\n    /// @param _bytecode Bytecode metadata including contract type, version, _bytecode, author and source\n    /// @return bytes32 Hash of the metadata\n    function computeBytecodeHash(Bytecode memory _bytecode) public pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                BYTECODE_TYPEHASH,\n                _bytecode.contractType,\n                _bytecode.version,\n                keccak256(_bytecode.initCode),\n                _bytecode.author,\n                keccak256(bytes(_bytecode.source))\n            )\n        );\n    }\n\n    /// @notice Uploads new _bytecode to the repository\n    /// @param _bytecode Bytecode metadata to upload\n    /// @dev Only the author can upload on mainnet\n    function uploadBytecode(Bytecode memory _bytecode) external nonZeroAddress(_bytecode.author) {\n        if (block.chainid == 1 && msg.sender != _bytecode.author) {\n            revert OnlyAuthorCanSyncException();\n        }\n        // Check if _bytecode is already uploaded\n        bytes32 bytecodeHash = computeBytecodeHash(_bytecode);\n\n        if (isBytecodeUploaded(bytecodeHash)) {\n            revert BytecodeAlreadyExistsException();\n        }\n\n        // Verify author's signature of the _bytecode metadata\n        address recoveredAuthor = ECDSA.recover(_hashTypedDataV4(bytecodeHash), _bytecode.authorSignature);\n        if (recoveredAuthor != _bytecode.author) {\n            revert InvalidAuthorSignatureException();\n        }\n\n        // Revert if the initCode is forbidden\n        revertIfInitCodeForbidden(_bytecode.initCode);\n\n        // Check if the contract name and version already exists\n        if (approvedBytecodeHash[_bytecode.contractType][_bytecode.version] != 0) {\n            revert ContractTypeVersionAlreadyExistsException();\n        }\n\n        address initCodePointer = _bytecode.initCode.write();\n\n        _bytecodeByHash[bytecodeHash] = BytecodePointer({\n            contractType: _bytecode.contractType,\n            version: _bytecode.version,\n            initCodePointer: initCodePointer,\n            author: _bytecode.author,\n            source: _bytecode.source,\n            authorSignature: _bytecode.authorSignature\n        });\n\n        _bytecodeHashes.add(bytecodeHash);\n\n        emit UploadBytecode(\n            bytecodeHash,\n            _bytecode.contractType.fromSmallString(),\n            _bytecode.version,\n            _bytecode.author,\n            _bytecode.source\n        );\n    }\n\n    /// @notice Deploys a contract using stored _bytecode\n    /// @param _contractType Type identifier of the contract\n    /// @param _version Version of the contract to deploy\n    /// @param constructorParams Constructor parameters for deployment\n    /// @param salt Unique salt for CREATE2 deployment\n    /// @return newContract Address of the deployed contract\n    function deploy(bytes32 _contractType, uint256 _version, bytes memory constructorParams, bytes32 salt)\n        external\n        returns (address newContract)\n    {\n        // Retrieve bytecodeHash\n        bytes32 bytecodeHash = approvedBytecodeHash[_contractType][_version];\n        if (bytecodeHash == 0) {\n            revert BytecodeIsNotApprovedException(_contractType, _version);\n        }\n\n        if (!isAuditBytecode(bytecodeHash)) {\n            revert BytecodeIsNotAuditedException();\n        }\n\n        BytecodePointer storage _bytecode = _bytecodeByHash[bytecodeHash];\n\n        bytes memory initCode = SSTORE2.read(_bytecode.initCodePointer);\n\n        // Revert if the initCode is forbidden\n        revertIfInitCodeForbidden(initCode);\n\n        // Combine code + constructor params\n        bytes memory bytecodeWithParams = abi.encodePacked(initCode, constructorParams);\n\n        bytes32 saltUnique = keccak256(abi.encode(salt, msg.sender));\n\n        // Compute CREATE2 address\n        newContract = Create2.computeAddress(saltUnique, keccak256(bytecodeWithParams));\n\n        // Check if the contract already deployed\n        if (newContract.code.length != 0) {\n            revert BytecodeAlreadyExistsAtAddressException(newContract);\n        }\n\n        // Deploy\n        Create2.deploy(0, saltUnique, bytecodeWithParams);\n\n        // Verify IVersion\n        if (IVersion(newContract).contractType() != _contractType || IVersion(newContract).version() != _version) {\n            revert IncorrectBytecodeException(bytecodeHash);\n        }\n\n        // add to deployedContracts\n        deployedContracts[newContract] = bytecodeHash;\n\n        emit DeployContract(newContract, bytecodeHash, _contractType.fromSmallString(), _version);\n\n        // Auto-transfer ownership if IOwnable\n        try Ownable(newContract).transferOwnership(msg.sender) {} catch {}\n    }\n\n    /// @notice Computes the address where a contract would be deployed\n    /// @param _contractType Type identifier of the contract\n    /// @param _version Version of the contract\n    /// @param constructorParams Constructor parameters\n    /// @param salt Unique salt for CREATE2 deployment\n    /// @return Address where the contract would be deployed\n    function computeAddress(\n        bytes32 _contractType,\n        uint256 _version,\n        bytes memory constructorParams,\n        bytes32 salt,\n        address deployer\n    ) external view returns (address) {\n        // Retrieve bytecodeHash\n        bytes32 bytecodeHash = approvedBytecodeHash[_contractType][_version];\n        if (bytecodeHash == 0) {\n            revert BytecodeIsNotApprovedException(_contractType, _version);\n        }\n        BytecodePointer storage _bytecode = _bytecodeByHash[bytecodeHash];\n\n        bytes memory initCode = SSTORE2.read(_bytecode.initCodePointer);\n\n        // Combine code + constructor params\n        bytes memory bytecodeWithParams = abi.encodePacked(initCode, constructorParams);\n\n        bytes32 saltUnique = keccak256(abi.encode(salt, deployer));\n\n        // Return CREATE2 address\n        return Create2.computeAddress(saltUnique, keccak256(bytecodeWithParams));\n    }\n\n    /// @notice Allows auditors to sign _bytecode metadata\n    /// @param bytecodeHash Hash of the _bytecode metadata to sign\n    /// @param reportUrl URL of the audit report\n    /// @param signature Cryptographic signature of the auditor\n    function signBytecodeHash(bytes32 bytecodeHash, string calldata reportUrl, bytes memory signature) external {\n        // Must point to existing metadata\n        if (!isBytecodeUploaded(bytecodeHash)) {\n            revert BytecodeIsNotUploadedException(bytecodeHash);\n        }\n\n        // Re-create typed data\n        bytes32 structHash =\n            keccak256(abi.encode(AUDITOR_SIGNATURE_TYPEHASH, bytecodeHash, keccak256(bytes(reportUrl))));\n        // Hash with our pinned domain\n        address signer = ECDSA.recover(_hashTypedDataV4(structHash), signature);\n\n        // Must match msg.sender and be an approved auditor\n        if (!_auditors.contains(signer)) {\n            revert SignerIsNotAuditorException(signer);\n        }\n\n        // do not allow duplicates\n        uint256 len = _auditorSignaturesByHash[bytecodeHash].length;\n        for (uint256 i = 0; i < len; ++i) {\n            if (keccak256(_auditorSignaturesByHash[bytecodeHash][i].signature) == keccak256(signature)) {\n                revert AuditorAlreadySignedException();\n            }\n        }\n        _auditorSignaturesByHash[bytecodeHash].push(\n            AuditorSignature({reportUrl: reportUrl, auditor: signer, signature: signature})\n        );\n\n        emit AuditBytecode(bytecodeHash, signer, reportUrl, signature);\n\n        BytecodePointer storage _bytecode = _bytecodeByHash[bytecodeHash];\n\n        bytes32 _contractType = _bytecode.contractType;\n        address author = _bytecode.author;\n\n        bool isSystemContract = allowedSystemContracts[bytecodeHash];\n\n        address currentOwner = contractTypeOwner[_contractType];\n        bool isContractTypeInPublicDomain = isInPublicDomain(_contractType);\n\n        if (currentOwner == address(0) || isSystemContract) {\n            contractTypeOwner[_contractType] = author;\n        } else if (isContractTypeInPublicDomain && (currentOwner != author)) {\n            revert NotDomainOwnerException();\n        }\n\n        if (isSystemContract || isContractTypeInPublicDomain) {\n            _approveContract(_contractType, _bytecode.version, bytecodeHash);\n        }\n    }\n\n    /// @notice Allows owner to mark contracts as system contracts\n    /// @param bytecodeHash Hash of the _bytecode metadata to allow\n    function allowSystemContract(bytes32 bytecodeHash) external onlyOwner {\n        allowedSystemContracts[bytecodeHash] = true;\n\n        if (isBytecodeUploaded(bytecodeHash) && isAuditBytecode(bytecodeHash)) {\n            BytecodePointer storage _bytecode = _bytecodeByHash[bytecodeHash];\n            contractTypeOwner[_bytecode.contractType] = _bytecode.author;\n            _approveContract(_bytecode.contractType, _bytecode.version, bytecodeHash);\n        }\n    }\n\n    /// @notice Internal function to approve contract _bytecode\n    /// @param bytecodeHash Hash of the _bytecode metadata to approve\n    function _approveContract(bytes32 _contractType, uint256 _version, bytes32 bytecodeHash) internal {\n        if (approvedBytecodeHash[_contractType][_version] == 0) {\n            approvedBytecodeHash[_contractType][_version] = bytecodeHash;\n\n            uint256 majorVersion = (_version / 100) * 100;\n            uint256 minorVersion = ((_version / 10) % 10) * 10 + majorVersion;\n\n            if (latestVersion[_contractType] < _version) {\n                latestVersion[_contractType] = _version;\n            }\n            if (latestMinorVersion[_contractType][majorVersion] < _version) {\n                latestMinorVersion[_contractType][majorVersion] = _version;\n            }\n            if (latestPatchVersion[_contractType][minorVersion] < _version) {\n                latestPatchVersion[_contractType][minorVersion] = _version;\n            }\n\n            emit ApproveContract(bytecodeHash, _contractType, _version);\n        }\n    }\n\n    //\n    // Auditor management\n    //\n    /// @notice Adds a new auditor\n    /// @param auditor Address of the auditor\n    /// @param name Name of the auditor\n    function addAuditor(address auditor, string memory name) external onlyOwner nonZeroAddress(auditor) {\n        bool added = _auditors.add(auditor);\n        if (added) {\n            auditorName[auditor] = name;\n            emit AddAuditor(auditor, name);\n        }\n    }\n\n    /// @notice Removes an auditor\n    /// @param auditor Address of the auditor to remove\n    function removeAuditor(address auditor) external onlyOwner {\n        bool removed = _auditors.remove(auditor);\n        if (removed) {\n            emit RemoveAuditor(auditor);\n        }\n    }\n\n    /// @notice Checks if an address is an approved auditor\n    /// @param auditor Address to check\n    /// @return bool True if address is an approved auditor\n    function isAuditor(address auditor) public view returns (bool) {\n        return _auditors.contains(auditor);\n    }\n\n    /// @notice Returns list of all approved auditors\n    /// @return Array of auditor addresses\n    function getAuditors() external view returns (address[] memory) {\n        return _auditors.values();\n    }\n\n    //\n    // DOMAIN MANAGEMENT\n    //\n\n    /// @notice Adds a new public domain\n    /// @param domain Domain identifier to add\n    /// @dev Non-revertable to avoid blocking InstanceManager\n    function addPublicDomain(bytes32 domain) external onlyOwner {\n        if (domain == bytes32(0)) {\n            return;\n        }\n\n        if (LibString.fromSmallString(domain).contains(\"::\")) {\n            return;\n        }\n\n        if (_publicDomains.add(domain)) {\n            emit AddPublicDomain(domain);\n        }\n    }\n\n    /// @notice Removes a public domain\n    /// @param domain Domain identifier to remove\n    function removePublicDomain(bytes32 domain) external onlyOwner {\n        if (_publicDomains.remove(domain)) {\n            emit RemovePublicDomain(domain);\n        }\n    }\n\n    /// @notice Marks initCode as forbidden\n    /// @param initCodeHash Hash of initCode to forbid\n    function forbidInitCode(bytes32 initCodeHash) external onlyOwner {\n        forbiddenInitCode[initCodeHash] = true;\n        emit ForbidBytecode(initCodeHash);\n    }\n\n    /// @notice Sets token-specific postfix\n    /// @param token Token address\n    /// @param postfix Postfix to associate with token\n    function setTokenSpecificPostfix(address token, bytes32 postfix) external onlyOwner {\n        tokenSpecificPostfixes[token] = postfix;\n        emit SetTokenSpecificPostfix(token, postfix);\n    }\n\n    /// @notice Removes contract type owner\n    /// @param _contractType Contract type to remove owner from\n    /// @dev Used to remove malicious auditors and cybersquatters\n    function removeContractTypeOwner(bytes32 _contractType) external onlyOwner {\n        if (contractTypeOwner[_contractType] != address(0)) {\n            contractTypeOwner[_contractType] = address(0);\n            emit RemoveContractTypeOwner(_contractType);\n        }\n    }\n\n    function revokeApproval(bytes32 _contractType, uint256 _version, bytes32 _bytecodeHash) external onlyOwner {\n        if (approvedBytecodeHash[_contractType][_version] == _bytecodeHash) {\n            approvedBytecodeHash[_contractType][_version] = bytes32(0);\n            emit RevokeApproval(_bytecodeHash, _contractType, _version);\n        }\n    }\n\n    // GETTERS\n\n    /// @notice Checks if a contract name belongs to public domain\n    /// @param _contractType Contract type to check\n    /// @return bool True if contract is in public domain\n    function isInPublicDomain(bytes32 _contractType) public view returns (bool) {\n        string memory contractTypeStr = _contractType.fromSmallString();\n        return isPublicDomain(contractTypeStr.extractDomain().toSmallString());\n    }\n\n    /// @notice Checks if a domain is public\n    /// @param domain Domain to check\n    /// @return bool True if domain is public\n    function isPublicDomain(bytes32 domain) public view returns (bool) {\n        return _publicDomains.contains(domain);\n    }\n\n    /// @notice Returns list of all public domains\n    /// @return Array of public domain identifiers\n    function listPublicDomains() external view returns (bytes32[] memory) {\n        return _publicDomains.values();\n    }\n\n    /// @notice Gets token-specific postfix\n    /// @param token Token address to query\n    /// @return bytes32 Postfix associated with token\n    function getTokenSpecificPostfix(address token) external view returns (bytes32) {\n        return tokenSpecificPostfixes[token];\n    }\n\n    /// @notice Gets latest version for a contract type\n    /// @param _contractType Contract type to query\n    /// @return uint256 Latest version number (0 if none exists)\n    function getLatestVersion(bytes32 _contractType) external view returns (uint256) {\n        return latestVersion[_contractType];\n    }\n\n    /// @notice Gets latest minor version for a major version\n    /// @param _contractType Contract type to query\n    /// @param majorVersion Major version number\n    /// @return uint256 Latest minor version number\n    function getLatestMinorVersion(bytes32 _contractType, uint256 majorVersion) external view returns (uint256) {\n        return latestMinorVersion[_contractType][majorVersion];\n    }\n\n    /// @notice Gets latest patch version for a minor version\n    /// @param _contractType Contract type to query\n    /// @param minorVersion Minor version number\n    /// @return uint256 Latest patch version number\n    function getLatestPatchVersion(bytes32 _contractType, uint256 minorVersion) external view returns (uint256) {\n        return latestPatchVersion[_contractType][minorVersion];\n    }\n\n    function auditorSignaturesByHash(bytes32 bytecodeHash) external view returns (AuditorSignature[] memory) {\n        return _auditorSignaturesByHash[bytecodeHash];\n    }\n\n    function auditorSignaturesByHash(bytes32 bytecodeHash, uint256 index)\n        external\n        view\n        returns (AuditorSignature memory)\n    {\n        return _auditorSignaturesByHash[bytecodeHash][index];\n    }\n\n    //\n    // HELPERS\n    //\n    function isBytecodeUploaded(bytes32 bytecodeHash) public view returns (bool) {\n        return _bytecodeByHash[bytecodeHash].author != address(0);\n    }\n\n    function revertIfInitCodeForbidden(bytes memory initCode) public view {\n        bytes32 initCodeHash = keccak256(initCode);\n        if (forbiddenInitCode[initCodeHash]) {\n            revert BytecodeForbiddenException(initCodeHash);\n        }\n    }\n\n    function isAuditBytecode(bytes32 bytecodeHash) public view returns (bool) {\n        uint256 len = _auditorSignaturesByHash[bytecodeHash].length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            AuditorSignature memory sig = _auditorSignaturesByHash[bytecodeHash][i];\n            if (isAuditor(sig.auditor)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function bytecodeByHash(bytes32 bytecodeHash) external view returns (Bytecode memory) {\n        BytecodePointer memory _bytecode = _bytecodeByHash[bytecodeHash];\n        return Bytecode({\n            contractType: _bytecode.contractType,\n            version: _bytecode.version,\n            initCode: SSTORE2.read(_bytecode.initCodePointer),\n            author: _bytecode.author,\n            source: _bytecode.source,\n            authorSignature: _bytecode.authorSignature\n        });\n    }\n\n    function domainSeparatorV4() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    }
}