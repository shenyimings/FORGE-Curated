{
    "vfp_id": "vfp_00214",
    "project_name": "ackee-blockchain-lido-triggerable-withdrawals-report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Missing interface inheritance",
            "description": "Contracts in the codebase do not inherit from their corresponding interfaces, which can lead to ABI mismatches and potential integration issues.\nThis is a code quality and design issue where the implementation does not explicitly declare conformance to the interface, increasing the risk of function signature mismatches.\nWhile not directly exploitable, this could allow deployment of contracts with incorrect function selectors, especially in upgradeable systems.\nThe impact is Warning, as it does not pose an immediate security threat but could become critical if interface compatibility is assumed elsewhere.\nSpecifically, several contracts in the codebase do not inherit from their corresponding interfaces, including IStakingRouter, IWithdrawalVault, ITriggerableWithdrawalsGateway, IConsensusContract, IValidatorsExitBus, and IStakingModule. This omission is a code quality issue that reduces code clarity, complicates static analysis, and increases the risk of interface-contract mismatches. The root cause is architectural decisions that avoid inheritance for bytecode stability. While not directly exploitable, this practice can lead to runtime errors such as silent failures or reverts when external calls assume interface compliance. The impact is reduced code maintainability and increased risk of integration errors, especially in complex multi-contract systems.\n",
            "severity": "Informational",
            "location": [
                "**/*.sol"
            ],
            "files": [
                "core/contracts/0.8.25/interfaces/IStakingRouter.sol",
                "core/contracts/0.4.24/Lido.sol",
                "core/contracts/0.8.9/TriggerableWithdrawalsGateway.sol",
                "core/contracts/0.8.9/oracle/ValidatorsExitBus.sol",
                "core/contracts/0.8.9/oracle/BaseOracle.sol",
                "core/contracts/0.8.25/interfaces/IValidatorsExitBus.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Outdated IConsensusContract interface",
            "description": "The IConsensusContract interface used in the codebase is outdated and does not reflect the current specification or expected behavior.\nThis discrepancy may lead to incorrect assumptions about the consensus layer's functionality, especially in cross-contract interactions.\nIf the actual consensus contract evolves, the outdated interface could result in failed calls or misinterpretation of return data.\nThe impact is Warning, as it currently does not lead to exploitability but represents a technical debt and future compatibility risk.\nSpecifically, the IConsensusContract interface in BaseOracle.sol defines a getFrameConfig function that returns two values, but the actual implementation in HashConsensus returns three values, including an additional fastLaneLengthSlots parameter. This discrepancy causes the AccountingOracle._checkOracleMigration function to fail when calling getFrameConfig via the outdated interface. The cause is a lack of interface synchronization after implementation changes. An attacker cannot directly exploit this, but it can lead to failed oracle migrations or incorrect state assumptions during upgrades. The impact is potential disruption in oracle-related functionality and failure of critical migration checks, undermining system reliability.\n",
            "severity": "Informational",
            "location": [
                "BaseOracle.sol::getFrameConfig#28",
                "HashConsensus.sol::getFrameConfig#288-292",
                "AccountingOracle.sol::_checkOracleMigration#511-512"
            ],
            "files": [
                "core/contracts/0.8.9/oracle/BaseOracle.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Lack of event emission",
            "description": "Certain critical state changes do not emit events, making it difficult for off-chain systems to track changes.\nThe absence of events reduces transparency and can hinder monitoring, indexing, and bot-based automation.\nThis could be exploited indirectly by obscuring malicious activity from detection systems.\nThe impact is informational, as it does not directly compromise security but affects observability.\nSpecifically, the ValidatorsExitBus._setMaxValidatorsPerReport function modifies the MAX_VALIDATORS_PER_REPORT_POSITION storage variable but does not emit an event to log this change. The absence of an event makes it difficult for off-chain services and monitoring tools to detect and react to configuration updates. The root cause is incomplete state change logging. While not directly exploitable, this omission reduces transparency and auditability. The impact is degraded observability, making it harder to track administrative actions and potentially delaying incident response.\n",
            "severity": "Informational",
            "location": [
                "ValidatorsExitBus.sol::_setMaxValidatorsPerReport#519-522"
            ],
            "files": [
                "core/contracts/0.8.9/oracle/ValidatorsExitBus.sol"
            ]
        }
    ],
    "affected_files": {
        "IValidatorsExitBus.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\ninterface IValidatorsExitBus {\n    function getDeliveryTimestamp(bytes32 exitRequestsHash) external view returns (uint256 timestamp);\n\n    function unpackExitRequest(\n        bytes calldata exitRequests,\n        uint256 dataFormat,\n        uint256 index\n    ) external view returns (bytes memory pubkey, uint256 nodeOpId, uint256 moduleId, uint256 valIndex);\n}\n",
        "Lido.sol": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\n\nimport \"../common/interfaces/ILidoLocator.sol\";\nimport \"../common/interfaces/IBurner.sol\";\n\nimport \"./lib/StakeLimitUtils.sol\";\nimport \"../common/lib/Math256.sol\";\n\nimport \"./StETHPermit.sol\";\n\nimport \"./utils/Versioned.sol\";\n\ninterface IPostTokenRebaseReceiver {\n    function handlePostTokenRebase(\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        uint256 _preTotalShares,\n        uint256 _preTotalEther,\n        uint256 _postTotalShares,\n        uint256 _postTotalEther,\n        uint256 _sharesMintedAsFees\n    ) external;\n}\n\ninterface IOracleReportSanityChecker {\n    function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;\n\n    function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );\n\n    function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;\n\n    function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;\n}\n\ninterface ILidoExecutionLayerRewardsVault {\n    function withdrawRewards(uint256 _maxAmount) external returns (uint256 amount);\n}\n\ninterface IWithdrawalVault {\n    function withdrawWithdrawals(uint256 _amount) external;\n}\n\ninterface IStakingRouter {\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}\n\ninterface IWithdrawalQueue {\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}\n\n/**\n* @title Liquid staking pool implementation\n*\n* Lido is an Ethereum liquid staking protocol solving the problem of frozen staked ether on Consensus Layer\n* being unavailable for transfers and DeFi on Execution Layer.\n*\n* Since balances of all token holders change when the amount of total pooled Ether\n* changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n* events upon explicit transfer between holders. In contrast, when Lido oracle reports\n* rewards, no Transfer events are generated: doing so would require emitting an event\n* for each token holder and thus running an unbounded loop.\n*\n* ---\n* NB: Order of inheritance must preserve the structured storage layout of the previous versions.\n*\n* @dev Lido is derived from `StETHPermit` that has a structured storage:\n* SLOT 0: mapping (address => uint256) private shares (`StETH`)\n* SLOT 1: mapping (address => mapping (address => uint256)) private allowances (`StETH`)\n* SLOT 2: mapping(address => uint256) internal noncesByAddress (`StETHPermit`)\n*\n* `Versioned` and `AragonApp` both don't have the pre-allocated structured storage.\n*/\ncontract Lido is Versioned, StETHPermit, AragonApp {\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256(\"RESUME_ROLE\");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256(\"STAKING_PAUSE_ROLE\")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256(\"STAKING_CONTROL_ROLE\")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256(\"UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE\")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256(\"lido.Lido.lidoLocator\")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256(\"lido.Lido.stakeLimit\");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256(\"lido.Lido.bufferedEther\");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256(\"lido.Lido.depositedValidators\");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // \"beacon\" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256(\"lido.Lido.beaconBalance\");\n    /// @dev number of Lido's validators available in the Consensus Layer state\n    // \"beacon\" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256(\"lido.Lido.beaconValidators\");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256(\"lido.Lido.totalELRewardsCollected\");\n\n    // Staking was paused (don't accept user's ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user's ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user's submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract's balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version \"2\"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value \"1\" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), \"NOT_INITIALIZED\");\n\n        require(_lidoLocator != address(0), \"LIDO_LOCATOR_ZERO_ADDRESS\");\n        require(_eip712StETH != address(0), \"EIP712_STETH_ZERO_ADDRESS\");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, \"INITIAL_HOLDER_EXISTS\");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), \"NOT_INITIALIZED\");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     * ▲ Stake limit\n     * │.....  .....   ........ ...            ....     ... Stake limit = max\n     * │      .       .        .   .   .      .    . . .\n     * │     .       .              . .  . . .      . .\n     * │            .                .  . . .\n     * │──────────────────────────────────────────────────> Time\n     * │     ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it's paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, \"NON_EMPTY_DATA\");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert(\"NOT_SUPPORTED\");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract's balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol's pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), \"APP_AUTH_DSM_FAILED\");\n        require(canDeposit(), \"CAN_NOT_DEPOSIT\");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can't deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, \"REPORTED_MORE_DEPOSITED\");\n        require(_postClValidators >= _preClValidators, \"REPORTED_LESS_VALIDATORS\");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Don’t mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, \"ZERO_DEPOSIT\");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), \"STAKING_PAUSED\");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, \"STAKE_LIMIT\");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, \"WRONG_RECIPIENTS_INPUT\");\n        require(ret.moduleIds.length == ret.modulesFees.length, \"WRONG_MODULE_IDS_INPUT\");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), \"APP_AUTH_FAILED\");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome 'stack too deep' issue.\n     *\n     * The method updates the protocol's accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, \"APP_AUTH_FAILED\");\n        require(_reportedData.reportTimestamp <= block.timestamp, \"INVALID_REPORT_TIMESTAMP\");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract's balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract's balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract's balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}\n",
        "TriggerableWithdrawalsGateway.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {AccessControlEnumerable} from \"./utils/access/AccessControlEnumerable.sol\";\nimport {ILidoLocator} from \"../common/interfaces/ILidoLocator.sol\";\nimport {ExitRequestLimitData, ExitLimitUtilsStorage, ExitLimitUtils} from \"./lib/ExitLimitUtils.sol\";\nimport {PausableUntil} from \"./utils/PausableUntil.sol\";\n\nstruct ValidatorData {\n    uint256 stakingModuleId;\n    uint256 nodeOperatorId;\n    bytes pubkey;\n}\n\ninterface IWithdrawalVault {\n    function addWithdrawalRequests(bytes[] calldata pubkeys, uint64[] calldata amounts) external payable;\n\n    function getWithdrawalRequestFee() external view returns (uint256);\n}\n\ninterface IStakingRouter {\n    function onValidatorExitTriggered(\n        ValidatorData[] calldata validatorData,\n        uint256 _withdrawalRequestPaidFee,\n        uint256 _exitType\n    ) external;\n}\n\n/**\n * @title TriggerableWithdrawalsGateway\n * @notice TriggerableWithdrawalsGateway contract is one entrypoint for all triggerable withdrawal requests (TWRs) in protocol.\n * This contract is responsible for limiting TWRs, checking ADD_FULL_WITHDRAWAL_REQUEST_ROLE role before it gets to Withdrawal Vault.\n */\ncontract TriggerableWithdrawalsGateway is AccessControlEnumerable, PausableUntil {\n    using ExitLimitUtilsStorage for bytes32;\n    using ExitLimitUtils for ExitRequestLimitData;\n\n    /**\n     * @notice Thrown when an invalid zero value is passed\n     * @param name Name of the argument that was zero\n     */\n    error ZeroArgument(string name);\n\n    /**\n     * @notice Thrown when attempting to set the admin address to zero\n     */\n    error AdminCannotBeZero();\n\n    /**\n     * @notice Thrown when exit request has wrong length\n     */\n    error InvalidRequestsDataLength();\n\n    /**\n     * @notice Thrown when a withdrawal fee insufficient\n     * @param feeRequired Amount of fee required to cover withdrawal request\n     * @param passedValue Amount of fee sent to cover withdrawal request\n     */\n    error InsufficientFee(uint256 feeRequired, uint256 passedValue);\n\n    /**\n     * @notice Thrown when a withdrawal fee refund failed\n     */\n    error FeeRefundFailed();\n\n    /**\n     * @notice Thrown when remaining exit requests limit is not enough to cover sender requests\n     * @param requestsCount Amount of requests that were sent for processing\n     * @param remainingLimit Amount of requests that still can be processed at current day\n     */\n    error ExitRequestsLimitExceeded(uint256 requestsCount, uint256 remainingLimit);\n\n    /**\n     * @notice Emitted when limits configs are set.\n     * @param maxExitRequestsLimit The maximum number of exit requests.\n     * @param exitsPerFrame The number of exits that can be restored per frame.\n     * @param frameDurationInSec The duration of each frame, in seconds, after which `exitsPerFrame` exits can be restored.\n     */\n    event ExitRequestsLimitSet(uint256 maxExitRequestsLimit, uint256 exitsPerFrame, uint256 frameDurationInSec);\n\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n    bytes32 public constant ADD_FULL_WITHDRAWAL_REQUEST_ROLE = keccak256(\"ADD_FULL_WITHDRAWAL_REQUEST_ROLE\");\n    bytes32 public constant TW_EXIT_LIMIT_MANAGER_ROLE = keccak256(\"TW_EXIT_LIMIT_MANAGER_ROLE\");\n\n    bytes32 public constant TWR_LIMIT_POSITION = keccak256(\"lido.TriggerableWithdrawalsGateway.maxExitRequestLimit\");\n\n    /// Length in bytes of packed triggerable exit request\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n\n    uint256 public constant VERSION = 1;\n\n    ILidoLocator internal immutable LOCATOR;\n\n    /// @dev Ensures the contract’s ETH balance is unchanged.\n    modifier preservesEthBalance() {\n        uint256 balanceBeforeCall = address(this).balance - msg.value;\n        _;\n        assert(address(this).balance == balanceBeforeCall);\n    }\n\n    constructor(\n        address admin,\n        address lidoLocator,\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) {\n        if (admin == address(0)) revert AdminCannotBeZero();\n        LOCATOR = ILidoLocator(lidoLocator);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n        _setExitRequestLimit(maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    /**\n     * @dev Resumes the triggerable withdrawals requests.\n     * @notice Reverts if:\n     *         - The contract is not paused.\n     *         - The sender does not have the `RESUME_ROLE`.\n     */\n    function resume() external onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /**\n     * @notice Pauses the triggerable withdrawals requests placement for a specified duration.\n     * @param _duration The pause duration in seconds (use `PAUSE_INFINITELY` for unlimited).\n     * @dev Reverts if:\n     *         - The contract is already paused.\n     *         - The sender does not have the `PAUSE_ROLE`.\n     *         - A zero duration is passed.\n     */\n    function pauseFor(uint256 _duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(_duration);\n    }\n\n    /**\n     * @notice Pauses the triggerable withdrawals requests placement until a specified timestamp.\n     * @param _pauseUntilInclusive The last second to pause until (inclusive).\n     * @dev Reverts if:\n     *         - The timestamp is in the past.\n     *         - The sender does not have the `PAUSE_ROLE`.\n     *         - The contract is already paused.\n     */\n    function pauseUntil(uint256 _pauseUntilInclusive) external onlyRole(PAUSE_ROLE) {\n        _pauseUntil(_pauseUntilInclusive);\n    }\n\n    /**\n     * @dev Submits Triggerable Withdrawal Requests to the Withdrawal Vault as full withdrawal requests\n     *      for the specified validator public keys.\n     *\n     * @param validatorsData An array of `ValidatorData` structs, each representing a validator\n     * for which a withdrawal request will be submitted. Each entry includes:\n     *   - `stakingModuleId`: ID of the staking module.\n     *   - `nodeOperatorId`: ID of the node operator.\n     *   - `pubkey`: Validator public key, 48 bytes length.\n     * @param refundRecipient The address that will receive any excess ETH sent for fees.\n     * @param exitType A parameter indicating the type of exit, passed to the Staking Module.\n     *\n     * @notice Reverts if:\n     *     - The caller does not have the `ADD_FULL_WITHDRAWAL_REQUEST_ROLE`\n     *     - The total fee value sent is insufficient to cover all provided TW requests.\n     *     - There is not enough limit quota left in the current frame to process all requests.\n     */\n    function triggerFullWithdrawals(\n        ValidatorData[] calldata validatorsData,\n        address refundRecipient,\n        uint256 exitType\n    ) external payable onlyRole(ADD_FULL_WITHDRAWAL_REQUEST_ROLE) preservesEthBalance whenResumed {\n        if (msg.value == 0) revert ZeroArgument(\"msg.value\");\n        uint256 requestsCount = validatorsData.length;\n        if (requestsCount == 0) revert ZeroArgument(\"validatorsData\");\n\n        _consumeExitRequestLimit(requestsCount);\n\n        IWithdrawalVault withdrawalVault = IWithdrawalVault(LOCATOR.withdrawalVault());\n        uint256 fee = withdrawalVault.getWithdrawalRequestFee();\n        uint256 totalFee = requestsCount * fee;\n        uint256 refund = _checkFee(totalFee);\n\n        bytes[] memory pubkeys = new bytes[](requestsCount);\n        for (uint256 i = 0; i < requestsCount; ++i) {\n            pubkeys[i] = validatorsData[i].pubkey;\n        }\n\n        withdrawalVault.addWithdrawalRequests{value: totalFee}(pubkeys, new uint64[](requestsCount));\n\n        _notifyStakingModules(validatorsData, fee, exitType);\n        _refundFee(refund, refundRecipient);\n    }\n\n    /**\n     * @notice Sets the maximum exit request limit and the frame during which a portion of the limit can be restored.\n     * @param maxExitRequestsLimit The maximum number of exit requests.\n     * @param exitsPerFrame The number of exits that can be restored per frame.\n     * @param frameDurationInSec The duration of each frame, in seconds, after which `exitsPerFrame` exits can be restored.\n     */\n    function setExitRequestLimit(\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) external onlyRole(TW_EXIT_LIMIT_MANAGER_ROLE) {\n        _setExitRequestLimit(maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    /**\n     * @notice Returns information about current limits data\n     * @return maxExitRequestsLimit Maximum exit requests limit\n     * @return exitsPerFrame The number of exits that can be restored per frame.\n     * @return frameDurationInSec The duration of each frame, in seconds, after which `exitsPerFrame` exits can be restored.\n     * @return prevExitRequestsLimit Limit left after previous requests\n     * @return currentExitRequestsLimit Current exit requests limit\n     */\n    function getExitRequestLimitFullInfo()\n        external\n        view\n        returns (\n            uint256 maxExitRequestsLimit,\n            uint256 exitsPerFrame,\n            uint256 frameDurationInSec,\n            uint256 prevExitRequestsLimit,\n            uint256 currentExitRequestsLimit\n        )\n    {\n        ExitRequestLimitData memory exitRequestLimitData = TWR_LIMIT_POSITION.getStorageExitRequestLimit();\n        maxExitRequestsLimit = exitRequestLimitData.maxExitRequestsLimit;\n        exitsPerFrame = exitRequestLimitData.exitsPerFrame;\n        frameDurationInSec = exitRequestLimitData.frameDurationInSec;\n        prevExitRequestsLimit = exitRequestLimitData.prevExitRequestsLimit;\n\n        currentExitRequestsLimit = exitRequestLimitData.isExitLimitSet()\n            ? exitRequestLimitData.calculateCurrentExitLimit(_getTimestamp())\n            : type(uint256).max;\n    }\n\n    /// Internal functions\n\n    function _checkFee(uint256 fee) internal returns (uint256 refund) {\n        if (msg.value < fee) {\n            revert InsufficientFee(fee, msg.value);\n        }\n        unchecked {\n            refund = msg.value - fee;\n        }\n    }\n\n    function _notifyStakingModules(\n        ValidatorData[] calldata validatorsData,\n        uint256 withdrawalRequestPaidFee,\n        uint256 exitType\n    ) internal {\n        IStakingRouter stakingRouter = IStakingRouter(LOCATOR.stakingRouter());\n        stakingRouter.onValidatorExitTriggered(validatorsData, withdrawalRequestPaidFee, exitType);\n    }\n\n    function _refundFee(uint256 refund, address recipient) internal {\n        if (refund > 0) {\n            // If the refund recipient is not set, use the sender as the refund recipient\n            if (recipient == address(0)) {\n                recipient = msg.sender;\n            }\n\n            (bool success, ) = recipient.call{value: refund}(\"\");\n            if (!success) {\n                revert FeeRefundFailed();\n            }\n        }\n    }\n\n    function _getTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    function _setExitRequestLimit(\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) internal {\n        uint256 timestamp = _getTimestamp();\n\n        TWR_LIMIT_POSITION.setStorageExitRequestLimit(\n            TWR_LIMIT_POSITION.getStorageExitRequestLimit().setExitLimits(\n                maxExitRequestsLimit,\n                exitsPerFrame,\n                frameDurationInSec,\n                timestamp\n            )\n        );\n\n        emit ExitRequestsLimitSet(maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    function _consumeExitRequestLimit(uint256 requestsCount) internal {\n        ExitRequestLimitData memory twrLimitData = TWR_LIMIT_POSITION.getStorageExitRequestLimit();\n        if (!twrLimitData.isExitLimitSet()) {\n            return;\n        }\n\n        uint256 limit = twrLimitData.calculateCurrentExitLimit(_getTimestamp());\n\n        if (limit < requestsCount) {\n            revert ExitRequestsLimitExceeded(requestsCount, limit);\n        }\n\n        TWR_LIMIT_POSITION.setStorageExitRequestLimit(\n            twrLimitData.updatePrevExitLimit(limit - requestsCount, _getTimestamp())\n        );\n    }\n}\n",
        "ValidatorsExitBus.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {AccessControlEnumerable} from \"../utils/access/AccessControlEnumerable.sol\";\nimport {UnstructuredStorage} from \"../lib/UnstructuredStorage.sol\";\nimport {ILidoLocator} from \"../../common/interfaces/ILidoLocator.sol\";\nimport {Versioned} from \"../utils/Versioned.sol\";\nimport {ExitRequestLimitData, ExitLimitUtilsStorage, ExitLimitUtils} from \"../lib/ExitLimitUtils.sol\";\nimport {PausableUntil} from \"../utils/PausableUntil.sol\";\n\ninterface ITriggerableWithdrawalsGateway {\n    struct ValidatorData {\n        uint256 stakingModuleId;\n        uint256 nodeOperatorId;\n        bytes pubkey;\n    }\n\n    function triggerFullWithdrawals(\n        ValidatorData[] calldata triggerableExitData,\n        address refundRecipient,\n        uint256 exitType\n    ) external payable;\n}\n\n/**\n * @title ValidatorsExitBus\n * @notice Сontract that serves as the central infrastructure for managing validator exit requests.\n * It stores report hashes, emits exit events, and maintains data and tools that enables anyone to prove a validator was requested to exit.\n */\nabstract contract ValidatorsExitBus is AccessControlEnumerable, PausableUntil, Versioned {\n    using UnstructuredStorage for bytes32;\n    using ExitLimitUtilsStorage for bytes32;\n    using ExitLimitUtils for ExitRequestLimitData;\n\n    /**\n     * @notice Thrown when an invalid zero value is passed\n     * @param name Name of the argument that was zero\n     */\n    error ZeroArgument(string name);\n\n    /**\n     * @notice Thrown when exit request passed to method contain wrong DATA_FORMAT\n     * @param format code of format, currently only DATA_FORMAT=1 is supported in the contract\n     */\n    error UnsupportedRequestsDataFormat(uint256 format);\n\n    /**\n     * @notice Thrown when exit request has wrong length\n     */\n    error InvalidRequestsDataLength();\n\n    /**\n     * @notice Thrown when module id equal to zero\n     */\n    error InvalidModuleId();\n\n    /**\n     * @notice Thrown when data submitted for exit requests was not sorted in ascending order or contains duplicates\n     */\n    error InvalidRequestsDataSortOrder();\n\n    /**\n     * Thrown when there are attempt to send exit events for request that was not submitted earlier by trusted entities\n     */\n    error ExitHashNotSubmitted();\n\n    /**\n     * Thrown when there are attempt to store exit hash that was already submitted\n     */\n    error ExitHashAlreadySubmitted();\n\n    /**\n     * @notice Throw when in submitExitRequestsData all requests were already delivered\n     */\n    error RequestsAlreadyDelivered();\n\n    /**\n     * @notice Thrown when index of request in submitted data for triggerable withdrawal is out of range\n     * @param exitDataIndex Index of request\n     * @param requestsCount Amount of requests that were sent for processing\n     */\n    error ExitDataIndexOutOfRange(uint256 exitDataIndex, uint256 requestsCount);\n\n    /**\n     * @notice Thrown when array of indexes of requests in submitted data for triggerable withdrawal is not is not strictly increasing array\n     */\n    error InvalidExitDataIndexSortOrder();\n\n    /**\n     * @notice Thrown when remaining exit requests limit is not enough to cover sender requests\n     * @param requestsCount Amount of requests that were sent for processing\n     * @param remainingLimit Amount of requests that still can be processed at current day\n     */\n    error ExitRequestsLimitExceeded(uint256 requestsCount, uint256 remainingLimit);\n\n    /**\n     * @notice Thrown when submitting was not started for request\n     */\n    error RequestsNotDelivered();\n\n    /**\n     * @notice Thrown when exit requests in report exceed the maximum allowed number of requests per report.\n     * @param requestsCount  Amount of requests that were sent for processing\n     */\n    error TooManyExitRequestsInReport(uint256 requestsCount, uint256 maxRequestsPerReport);\n\n    /**\n     * @notice Emitted when an entity with the SUBMIT_REPORT_HASH_ROLE role submits a hash of the exit requests data.\n     * @param exitRequestsHash keccak256 hash of the encoded validators list\n     */\n    event RequestsHashSubmitted(bytes32 exitRequestsHash);\n\n    /**\n     * @notice Emitted when validator exit requested.\n     * @param stakingModuleId Id of staking module.\n     * @param nodeOperatorId Id of node operator.\n     * @param validatorIndex Validator index.\n     * @param validatorPubkey Public key of validator.\n     * @param timestamp Block timestamp\n     */\n    event ValidatorExitRequest(\n        uint256 indexed stakingModuleId,\n        uint256 indexed nodeOperatorId,\n        uint256 indexed validatorIndex,\n        bytes validatorPubkey,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when limits configs are set.\n     * @param maxExitRequestsLimit The maximum number of exit requests.\n     * @param exitsPerFrame The number of exits that can be restored per frame.\n     * @param frameDurationInSec The duration of each frame, in seconds, after which `exitsPerFrame` exits can be restored.\n     */\n    event ExitRequestsLimitSet(uint256 maxExitRequestsLimit, uint256 exitsPerFrame, uint256 frameDurationInSec);\n\n    /**\n     * @notice Emitted when exit requests were delivered\n     * @param exitRequestsHash keccak256 hash of the encoded validators list\n     */\n    event ExitDataProcessing(bytes32 exitRequestsHash);\n\n    struct ExitRequestsData {\n        bytes data;\n        uint256 dataFormat;\n    }\n\n    struct ValidatorData {\n        uint256 nodeOpId;\n        uint256 moduleId;\n        uint256 valIndex;\n        bytes pubkey;\n    }\n\n    // RequestStatus stores timestamp of delivery, and contract version.\n    struct RequestStatus {\n        uint32 contractVersion;\n        uint32 deliveredExitDataTimestamp;\n    }\n\n    /// @notice An ACL role granting the permission to submit a hash of the exit requests data\n    bytes32 public constant SUBMIT_REPORT_HASH_ROLE = keccak256(\"SUBMIT_REPORT_HASH_ROLE\");\n    /// @notice An ACL role granting the permission to set limits configs and MAX_VALIDATORS_PER_REPORT value\n    bytes32 public constant EXIT_REQUEST_LIMIT_MANAGER_ROLE = keccak256(\"EXIT_REQUEST_LIMIT_MANAGER_ROLE\");\n    /// @notice An ACL role granting the permission to pause accepting validator exit requests\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    /// @notice An ACL role granting the permission to resume accepting validator exit requests\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n\n    /// Length in bytes of packed request\n    uint256 internal constant PACKED_REQUEST_LENGTH = 64;\n\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n\n    /// @notice The list format of the validator exit requests data. Used when all\n    /// requests fit into a single transaction.\n    ///\n    /// Each validator exit request is described by the following 64-byte array:\n    ///\n    /// MSB <------------------------------------------------------- LSB\n    /// |  3 bytes   |  5 bytes   |     8 bytes      |    48 bytes     |\n    /// |  moduleId  |  nodeOpId  |  validatorIndex  | validatorPubkey |\n    ///\n    /// All requests are tightly packed into a byte array where requests follow\n    /// one another without any separator or padding, and passed to the `data`\n    /// field of the report structure.\n    ///\n    /// Requests must be sorted in the ascending order by the following compound\n    /// key: (moduleId, nodeOpId, validatorIndex).\n    ///\n    uint256 public constant DATA_FORMAT_LIST = 1;\n\n    ILidoLocator internal immutable LOCATOR;\n\n    // Storage slot for exit request limit configuration and current quota tracking\n    bytes32 internal constant EXIT_REQUEST_LIMIT_POSITION = keccak256(\"lido.ValidatorsExitBus.maxExitRequestLimit\");\n    // Storage slot for the maximum number of validator exit requests allowed per processing report\n    bytes32 internal constant MAX_VALIDATORS_PER_REPORT_POSITION =\n        keccak256(\"lido.ValidatorsExitBus.maxValidatorsPerReport\");\n\n    // Storage slot for mapping(bytes32 => RequestStatus), keyed by exitRequestsHash\n    bytes32 internal constant REQUEST_STATUS_POSITION = keccak256(\"lido.ValidatorsExitBus.requestStatus\");\n\n    uint256 public constant EXIT_TYPE = 2;\n\n    /// @dev Ensures the contract’s ETH balance is unchanged.\n    modifier preservesEthBalance() {\n        uint256 balanceBeforeCall = address(this).balance - msg.value;\n        _;\n        assert(address(this).balance == balanceBeforeCall);\n    }\n\n    constructor(address lidoLocator) {\n        LOCATOR = ILidoLocator(lidoLocator);\n    }\n\n    /**\n     * @notice Submit a hash of the exit requests data.\n     *\n     * @dev Reverts if:\n     * - The contract is paused.\n     * - The caller does not have the `SUBMIT_REPORT_HASH_ROLE`.\n     * - The hash has already been submitted.\n     *\n     * Emits `RequestsHashSubmitted` event;\n     *\n     * @param exitRequestsHash - keccak256 hash of the encoded validators list\n     */\n    function submitExitRequestsHash(bytes32 exitRequestsHash) external whenResumed onlyRole(SUBMIT_REPORT_HASH_ROLE) {\n        uint256 contractVersion = getContractVersion();\n        _storeNewHashRequestStatus(exitRequestsHash, uint32(contractVersion), 0);\n    }\n\n    /**\n     * @notice Method for submitting exit requests data.\n     *\n     * @dev Reverts if:\n     * - The contract is paused.\n     * - The keccak256 hash of `requestsData` does not exist in storage (i.e., was not submitted).\n     * - The provided Exit Requests Data has already been submitted.\n     * - The contract version does not match the version at the time of hash submission.\n     * - The data format is not supported.\n     * - The data length exceeds the maximum number of requests allowed per payload.\n     * - There is no remaining quota available for the current limits.\n     *\n     * Emits `ValidatorExitRequest` events;\n     *\n     * @param request - The exit requests structure.\n     */\n    function submitExitRequestsData(ExitRequestsData calldata request) external whenResumed {\n        bytes32 exitRequestsHash = keccak256(abi.encode(request.data, request.dataFormat));\n        RequestStatus storage requestStatus = _storageRequestStatus()[exitRequestsHash];\n\n        _checkExitSubmitted(requestStatus);\n        _checkNotDelivered(requestStatus);\n        _checkExitRequestData(request.data, request.dataFormat);\n        _checkContractVersion(requestStatus.contractVersion);\n\n        uint256 requestsCount = request.data.length / PACKED_REQUEST_LENGTH;\n        uint256 maxRequestsPerReport = _getMaxValidatorsPerReport();\n\n        if (requestsCount > maxRequestsPerReport) {\n            revert TooManyExitRequestsInReport(requestsCount, maxRequestsPerReport);\n        }\n\n        _consumeLimit(requestsCount);\n\n        _processExitRequestsList(request.data);\n\n        _updateRequestStatus(requestStatus);\n\n        emit ExitDataProcessing(exitRequestsHash);\n    }\n\n    /**\n     * @notice Submits Triggerable Withdrawal Requests to the Triggerable Withdrawals Gateway.\n     *\n     * @param exitsData The report data previously submitted by the VEB.\n     * @param exitDataIndexes Array of sorted indexes pointing to validators in `exitsData.data`\n     * to be exited via TWR.\n     * @param refundRecipient Address to return extra fee on TW (eip-7002) exit.\n     *\n     * @dev Reverts if:\n     *     - The contract is paused.\n     *     - The keccak256 hash of `requestsData` does not exist in storage (i.e., was not submitted).\n     *     - The provided Exit Requests Data has not been previously submitted.\n     *     - Any of the provided `exitDataIndexes` refers to an index out of range.\n     *     - `exitDataIndexes` is not strictly increasing array\n     */\n    function triggerExits(\n        ExitRequestsData calldata exitsData,\n        uint256[] calldata exitDataIndexes,\n        address refundRecipient\n    ) external payable whenResumed preservesEthBalance {\n        if (msg.value == 0) revert ZeroArgument(\"msg.value\");\n        if (exitDataIndexes.length == 0) revert ZeroArgument(\"exitDataIndexes\");\n\n        // If the refund recipient is not set, use the sender as the refund recipient\n        if (refundRecipient == address(0)) {\n            refundRecipient = msg.sender;\n        }\n\n        RequestStatus storage requestStatus = _storageRequestStatus()[\n            keccak256(abi.encode(exitsData.data, exitsData.dataFormat))\n        ];\n\n        _checkExitSubmitted(requestStatus);\n        _checkDelivered(requestStatus);\n        _checkExitRequestData(exitsData.data, exitsData.dataFormat);\n        _checkContractVersion(requestStatus.contractVersion);\n\n        ITriggerableWithdrawalsGateway.ValidatorData[]\n            memory triggerableExitData = new ITriggerableWithdrawalsGateway.ValidatorData[](exitDataIndexes.length);\n\n        uint256 lastExitDataIndex = type(uint256).max;\n        uint256 requestsCount = exitsData.data.length / PACKED_REQUEST_LENGTH;\n\n        for (uint256 i = 0; i < exitDataIndexes.length; i++) {\n            if (exitDataIndexes[i] >= requestsCount) {\n                revert ExitDataIndexOutOfRange(exitDataIndexes[i], requestsCount);\n            }\n\n            if (i > 0 && exitDataIndexes[i] <= lastExitDataIndex) {\n                revert InvalidExitDataIndexSortOrder();\n            }\n\n            lastExitDataIndex = exitDataIndexes[i];\n\n            ValidatorData memory validatorData = _getValidatorData(exitsData.data, exitDataIndexes[i]);\n\n            if (validatorData.moduleId == 0) revert InvalidModuleId();\n\n            triggerableExitData[i] = ITriggerableWithdrawalsGateway.ValidatorData(\n                validatorData.moduleId,\n                validatorData.nodeOpId,\n                validatorData.pubkey\n            );\n        }\n\n        ITriggerableWithdrawalsGateway(LOCATOR.triggerableWithdrawalsGateway()).triggerFullWithdrawals{\n            value: msg.value\n        }(triggerableExitData, refundRecipient, EXIT_TYPE);\n    }\n\n    /**\n     * @notice Sets the limits config\n     * @param maxExitRequestsLimit The maximum number of exit requests.\n     * @param exitsPerFrame The number of exits that can be restored per frame.\n     * @param frameDurationInSec The duration of each frame, in seconds, after which `exitsPerFrame` exits can be restored.\n     */\n    function setExitRequestLimit(\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) external onlyRole(EXIT_REQUEST_LIMIT_MANAGER_ROLE) {\n        _setExitRequestLimit(maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    /**\n     * @notice Returns information about current limits data\n     * @return maxExitRequestsLimit Maximum exit requests limit\n     * @return exitsPerFrame The number of exits that can be restored per frame.\n     * @return frameDurationInSec The duration of each frame, in seconds, after which `exitsPerFrame` exits can be restored.\n     * @return prevExitRequestsLimit Limit left after previous requests\n     * @return currentExitRequestsLimit Current exit requests limit\n     */\n    function getExitRequestLimitFullInfo()\n        external\n        view\n        returns (\n            uint256 maxExitRequestsLimit,\n            uint256 exitsPerFrame,\n            uint256 frameDurationInSec,\n            uint256 prevExitRequestsLimit,\n            uint256 currentExitRequestsLimit\n        )\n    {\n        ExitRequestLimitData memory exitRequestLimitData = EXIT_REQUEST_LIMIT_POSITION.getStorageExitRequestLimit();\n        maxExitRequestsLimit = exitRequestLimitData.maxExitRequestsLimit;\n        exitsPerFrame = exitRequestLimitData.exitsPerFrame;\n        frameDurationInSec = exitRequestLimitData.frameDurationInSec;\n        prevExitRequestsLimit = exitRequestLimitData.prevExitRequestsLimit;\n\n        currentExitRequestsLimit = exitRequestLimitData.isExitLimitSet()\n            ? exitRequestLimitData.calculateCurrentExitLimit(_getTimestamp())\n            : type(uint256).max;\n    }\n\n    /**\n     * @notice Sets the maximum allowed number of validator exit requests to process in a single report.\n     * @param maxRequests The new maximum number of exit requests allowed per report.\n     */\n    function setMaxValidatorsPerReport(uint256 maxRequests) external onlyRole(EXIT_REQUEST_LIMIT_MANAGER_ROLE) {\n        _setMaxValidatorsPerReport(maxRequests);\n    }\n\n    /**\n     * @notice Returns information about allowed number of validator exit requests to process in a single report.\n     * @return The new maximum number of exit requests allowed per report\n     */\n    function getMaxValidatorsPerReport() external view returns (uint256) {\n        return _getMaxValidatorsPerReport();\n    }\n\n    /**\n     * @notice Returns the timestamp when the exit request was delivered.\n     *\n     * @param exitRequestsHash - The exit requests hash.\n     *\n     * @dev Reverts if:\n     *     - exitRequestsHash was not submitted\n     *     - Request was not submitted\n     */\n    function getDeliveryTimestamp(bytes32 exitRequestsHash) external view returns (uint256 deliveryDateTimestamp) {\n        mapping(bytes32 => RequestStatus) storage requestStatusMap = _storageRequestStatus();\n        RequestStatus storage storedRequest = requestStatusMap[exitRequestsHash];\n\n        _checkExitSubmitted(storedRequest);\n        _checkDelivered(storedRequest);\n\n        return storedRequest.deliveredExitDataTimestamp;\n    }\n\n    /**\n     * @notice Returns validator exit request data by index.\n     * @param exitRequests Encoded list of validator exit requests.\n     * @param dataFormat Format of the encoded exit request data. Currently, only DATA_FORMAT_LIST = 1 is supported.\n     * @param index Index of the exit request within the `exitRequests` list.\n     * @return pubkey Public key of the validator.\n     * @return nodeOpId ID of the node operator.\n     * @return moduleId ID of the staking module.\n     * @return valIndex Index of the validator.\n     */\n    function unpackExitRequest(\n        bytes calldata exitRequests,\n        uint256 dataFormat,\n        uint256 index\n    ) external pure returns (bytes memory pubkey, uint256 nodeOpId, uint256 moduleId, uint256 valIndex) {\n        _checkExitRequestData(exitRequests, dataFormat);\n\n        if (index >= exitRequests.length / PACKED_REQUEST_LENGTH) {\n            revert ExitDataIndexOutOfRange(index, exitRequests.length / PACKED_REQUEST_LENGTH);\n        }\n\n        ValidatorData memory validatorData = _getValidatorData(exitRequests, index);\n\n        valIndex = validatorData.valIndex;\n        nodeOpId = validatorData.nodeOpId;\n        moduleId = validatorData.moduleId;\n        pubkey = validatorData.pubkey;\n\n        return (pubkey, nodeOpId, moduleId, valIndex);\n    }\n\n    /// @notice Resume accepting validator exit requests\n    ///\n    /// @dev Reverts with `PausedExpected()` if contract is already resumed\n    /// @dev Reverts with `AccessControl:...` reason if sender has no `RESUME_ROLE`\n    ///\n    function resume() external whenPaused onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /// @notice Pause accepting validator exit requests util in after duration.\n    ///\n    /// @param _duration Pause duration, seconds (use `PAUSE_INFINITELY` for unlimited).\n    /// @dev Reverts with `ResumedExpected()` if contract is already paused.\n    /// @dev Reverts with `AccessControl:...` reason if sender has no `PAUSE_ROLE`.\n    /// @dev Reverts with `ZeroPauseDuration()` if zero duration is passed.\n    ///\n    function pauseFor(uint256 _duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(_duration);\n    }\n\n    /// @notice Pause accepting report data.\n    /// @param _pauseUntilInclusive The last second to pause until.\n    /// @dev Reverts with `ResumeSinceInPast()` if the timestamp is in the past.\n    /// @dev Reverts with `AccessControl:...` reason if sender has no `PAUSE_ROLE`.\n    /// @dev Reverts with `ResumedExpected()` if contract is already paused.\n    function pauseUntil(uint256 _pauseUntilInclusive) external onlyRole(PAUSE_ROLE) {\n        _pauseUntil(_pauseUntilInclusive);\n    }\n\n    /// Internal functions\n\n    function _checkExitRequestData(bytes calldata requests, uint256 dataFormat) internal pure {\n        if (dataFormat != DATA_FORMAT_LIST) {\n            revert UnsupportedRequestsDataFormat(dataFormat);\n        }\n\n        if (requests.length == 0 || requests.length % PACKED_REQUEST_LENGTH != 0) {\n            revert InvalidRequestsDataLength();\n        }\n    }\n\n    function _checkExitSubmitted(RequestStatus storage requestStatus) internal view {\n        if (requestStatus.contractVersion == 0) {\n            revert ExitHashNotSubmitted();\n        }\n    }\n\n    function _checkNotDelivered(RequestStatus storage status) internal view {\n        if (status.deliveredExitDataTimestamp != 0) {\n            revert RequestsAlreadyDelivered();\n        }\n    }\n\n    function _checkDelivered(RequestStatus storage status) internal view {\n        if (status.deliveredExitDataTimestamp == 0) {\n            revert RequestsNotDelivered();\n        }\n    }\n\n    function _getTimestamp() internal view virtual returns (uint32) {\n        return uint32(block.timestamp); // solhint-disable-line not-rely-on-time\n    }\n\n    function _setMaxValidatorsPerReport(uint256 maxValidatorsPerReport) internal {\n        if (maxValidatorsPerReport == 0) revert ZeroArgument(\"maxValidatorsPerReport\");\n\n        MAX_VALIDATORS_PER_REPORT_POSITION.setStorageUint256(maxValidatorsPerReport);\n    }\n\n    function _getMaxValidatorsPerReport() internal view returns (uint256) {\n        return MAX_VALIDATORS_PER_REPORT_POSITION.getStorageUint256();\n    }\n\n    function _setExitRequestLimit(\n        uint256 maxExitRequestsLimit,\n        uint256 exitsPerFrame,\n        uint256 frameDurationInSec\n    ) internal {\n        uint256 timestamp = _getTimestamp();\n\n        EXIT_REQUEST_LIMIT_POSITION.setStorageExitRequestLimit(\n            EXIT_REQUEST_LIMIT_POSITION.getStorageExitRequestLimit().setExitLimits(\n                maxExitRequestsLimit,\n                exitsPerFrame,\n                frameDurationInSec,\n                timestamp\n            )\n        );\n\n        emit ExitRequestsLimitSet(maxExitRequestsLimit, exitsPerFrame, frameDurationInSec);\n    }\n\n    function _consumeLimit(uint256 requestsCount) internal {\n        ExitRequestLimitData memory exitRequestLimitData = EXIT_REQUEST_LIMIT_POSITION.getStorageExitRequestLimit();\n        if (!exitRequestLimitData.isExitLimitSet()) {\n            return;\n        }\n\n        uint256 limit = exitRequestLimitData.calculateCurrentExitLimit(_getTimestamp());\n\n        if (requestsCount > limit) {\n            revert ExitRequestsLimitExceeded(requestsCount, limit);\n        }\n\n        EXIT_REQUEST_LIMIT_POSITION.setStorageExitRequestLimit(\n            exitRequestLimitData.updatePrevExitLimit(limit - requestsCount, _getTimestamp())\n        );\n    }\n\n    function _storeOracleNewHashRequestStatus(\n        bytes32 exitRequestsHash,\n        uint32 contractVersion,\n        uint32 deliveredExitDataTimestamp\n    ) internal {\n        mapping(bytes32 => RequestStatus) storage requestStatusMap = _storageRequestStatus();\n\n        if (requestStatusMap[exitRequestsHash].deliveredExitDataTimestamp != 0) {\n            return;\n        }\n\n        requestStatusMap[exitRequestsHash] = RequestStatus({\n            contractVersion: contractVersion,\n            deliveredExitDataTimestamp: deliveredExitDataTimestamp\n        });\n\n        emit RequestsHashSubmitted(exitRequestsHash);\n    }\n\n    function _storeNewHashRequestStatus(\n        bytes32 exitRequestsHash,\n        uint32 contractVersion,\n        uint32 deliveredExitDataTimestamp\n    ) internal {\n        mapping(bytes32 => RequestStatus) storage requestStatusMap = _storageRequestStatus();\n\n        if (requestStatusMap[exitRequestsHash].contractVersion != 0) {\n            revert ExitHashAlreadySubmitted();\n        }\n\n        requestStatusMap[exitRequestsHash] = RequestStatus({\n            contractVersion: contractVersion,\n            deliveredExitDataTimestamp: deliveredExitDataTimestamp\n        });\n\n        emit RequestsHashSubmitted(exitRequestsHash);\n    }\n\n    function _updateRequestStatus(RequestStatus storage requestStatus) internal {\n        requestStatus.deliveredExitDataTimestamp = _getTimestamp();\n    }\n\n    /// Methods for reading data from tightly packed validator exit requests\n    /// Format DATA_FORMAT_LIST = 1;\n\n    /**\n     * @notice Method for reading node operator id, module id and validator index from validator exit request data\n     * @param exitRequestData Validator exit requests data. DATA_FORMAT = 1\n     * @param index index of request in array above\n     * @return validatorData Validator data including node operator id, module id, validator index\n     */\n    function _getValidatorData(\n        bytes calldata exitRequestData,\n        uint256 index\n    ) internal pure returns (ValidatorData memory validatorData) {\n        uint256 itemOffset;\n        uint256 dataWithoutPubkey;\n\n        assembly {\n            // Compute the start of this packed request (item)\n            itemOffset := add(exitRequestData.offset, mul(PACKED_REQUEST_LENGTH, index))\n\n            // Load the first 16 bytes which contain moduleId (24 bits),\n            // nodeOpId (40 bits), and valIndex (64 bits).\n            dataWithoutPubkey := shr(128, calldataload(itemOffset))\n        }\n\n        // dataWithoutPubkey format (128 bits total):\n        // MSB <-------------------- 128 bits --------------------> LSB\n        // |   128 bits: zeros  | 24 bits: moduleId | 40 bits: nodeOpId | 64 bits: valIndex |\n\n        validatorData.valIndex = uint64(dataWithoutPubkey);\n        validatorData.nodeOpId = uint40(dataWithoutPubkey >> 64);\n        validatorData.moduleId = uint24(dataWithoutPubkey >> (64 + 40));\n\n        bytes memory pubkey = new bytes(PUBLIC_KEY_LENGTH);\n        assembly {\n            itemOffset := add(exitRequestData.offset, mul(PACKED_REQUEST_LENGTH, index))\n            let pubkeyCalldataOffset := add(itemOffset, 16)\n            let pubkeyMemPtr := add(pubkey, 32)\n            calldatacopy(pubkeyMemPtr, pubkeyCalldataOffset, PUBLIC_KEY_LENGTH)\n        }\n\n        validatorData.pubkey = pubkey;\n    }\n\n    /**\n     * This method read report data (DATA_FORMAT=1) within a range\n     * Check dataWithoutPubkey <= lastDataWithoutPubkey needs to prevent duplicates\n     */\n    function _processExitRequestsList(bytes calldata data) internal {\n        uint256 offset;\n        uint256 offsetPastEnd;\n        uint256 lastDataWithoutPubkey = 0;\n        uint256 timestamp = _getTimestamp();\n\n        assembly {\n            offset := data.offset\n            offsetPastEnd := add(offset, data.length)\n        }\n\n        bytes calldata pubkey;\n        uint256 dataWithoutPubkey;\n        uint256 moduleId;\n        uint256 nodeOpId;\n        uint64 valIndex;\n\n        assembly {\n            pubkey.length := 48\n        }\n\n        while (offset < offsetPastEnd) {\n            assembly {\n                // 16 most significant bytes are taken by module id, node op id, and val index\n                dataWithoutPubkey := shr(128, calldataload(offset))\n                // the next 48 bytes are taken by the pubkey\n                pubkey.offset := add(offset, 16)\n                // totalling to 64 bytes\n                offset := add(offset, 64)\n            }\n\n            moduleId = uint24(dataWithoutPubkey >> (64 + 40));\n\n            if (moduleId == 0) {\n                revert InvalidModuleId();\n            }\n\n            //                              dataWithoutPubkey\n            // MSB <---------------------------------------------------------------------- LSB\n            // | 128 bits: zeros | 24 bits: moduleId | 40 bits: nodeOpId | 64 bits: valIndex |\n            if (dataWithoutPubkey <= lastDataWithoutPubkey) {\n                revert InvalidRequestsDataSortOrder();\n            }\n\n            valIndex = uint64(dataWithoutPubkey);\n            nodeOpId = uint40(dataWithoutPubkey >> 64);\n\n            lastDataWithoutPubkey = dataWithoutPubkey;\n            emit ValidatorExitRequest(moduleId, nodeOpId, valIndex, pubkey, timestamp);\n        }\n    }\n\n    /// Storage helpers\n\n    function _storageRequestStatus() internal pure returns (mapping(bytes32 => RequestStatus) storage r) {\n        bytes32 position = REQUEST_STATUS_POSITION;\n        assembly {\n            r.slot := position\n        }\n    }\n}\n",
        "IStakingRouter.sol": "// SPDX-FileCopyrightText: 2024 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\ninterface IStakingRouter {\n    function reportValidatorExitDelay(\n        uint256 _moduleId,\n        uint256 _nodeOperatorId,\n        uint256 _proofSlotTimestamp,\n        bytes calldata _publicKey,\n        uint256 _eligibleToExitInSec\n    ) external;\n}\n",
        "BaseOracle.sol": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts-v4.4/utils/math/SafeCast.sol\";\n\nimport { UnstructuredStorage } from \"../lib/UnstructuredStorage.sol\";\nimport { Versioned } from \"../utils/Versioned.sol\";\nimport { AccessControlEnumerable } from \"../utils/access/AccessControlEnumerable.sol\";\n\nimport { IReportAsyncProcessor } from \"./HashConsensus.sol\";\n\n\ninterface IConsensusContract {\n    function getIsMember(address addr) external view returns (bool);\n\n    function getCurrentFrame() external view returns (\n        uint256 refSlot,\n        uint256 reportProcessingDeadlineSlot\n    );\n\n    function getChainConfig() external view returns (\n        uint256 slotsPerEpoch,\n        uint256 secondsPerSlot,\n        uint256 genesisTime\n    );\n\n    function getFrameConfig() external view returns (uint256 initialEpoch, uint256 epochsPerFrame);\n\n    function getInitialRefSlot() external view returns (uint256);\n}\n\n\nabstract contract BaseOracle is IReportAsyncProcessor, AccessControlEnumerable, Versioned {\n    using UnstructuredStorage for bytes32;\n    using SafeCast for uint256;\n\n    error AddressCannotBeZero();\n    error AddressCannotBeSame();\n    error VersionCannotBeSame();\n    error UnexpectedChainConfig();\n    error SenderIsNotTheConsensusContract();\n    error InitialRefSlotCannotBeLessThanProcessingOne(uint256 initialRefSlot, uint256 processingRefSlot);\n    error RefSlotMustBeGreaterThanProcessingOne(uint256 refSlot, uint256 processingRefSlot);\n    error RefSlotCannotDecrease(uint256 refSlot, uint256 prevRefSlot);\n    error NoConsensusReportToProcess();\n    error ProcessingDeadlineMissed(uint256 deadline);\n    error RefSlotAlreadyProcessing();\n    error UnexpectedRefSlot(uint256 consensusRefSlot, uint256 dataRefSlot);\n    error UnexpectedConsensusVersion(uint256 expectedVersion, uint256 receivedVersion);\n    error HashCannotBeZero();\n    error UnexpectedDataHash(bytes32 consensusHash, bytes32 receivedHash);\n    error SecondsPerSlotCannotBeZero();\n\n    event ConsensusHashContractSet(address indexed addr, address indexed prevAddr);\n    event ConsensusVersionSet(uint256 indexed version, uint256 indexed prevVersion);\n    event ReportSubmitted(uint256 indexed refSlot, bytes32 hash, uint256 processingDeadlineTime);\n    event ReportDiscarded(uint256 indexed refSlot, bytes32 hash);\n    event ProcessingStarted(uint256 indexed refSlot, bytes32 hash);\n    event WarnProcessingMissed(uint256 indexed refSlot);\n\n    struct ConsensusReport {\n        bytes32 hash;\n        uint64 refSlot;\n        uint64 processingDeadlineTime;\n    }\n\n    /// @notice An ACL role granting the permission to set the consensus\n    /// contract address by calling setConsensusContract.\n    bytes32 public constant MANAGE_CONSENSUS_CONTRACT_ROLE =\n        keccak256(\"MANAGE_CONSENSUS_CONTRACT_ROLE\");\n\n    /// @notice An ACL role granting the permission to set the consensus\n    /// version by calling setConsensusVersion.\n    bytes32 public constant MANAGE_CONSENSUS_VERSION_ROLE =\n        keccak256(\"MANAGE_CONSENSUS_VERSION_ROLE\");\n\n\n    /// @dev Storage slot: address consensusContract\n    bytes32 internal constant CONSENSUS_CONTRACT_POSITION =\n        keccak256(\"lido.BaseOracle.consensusContract\");\n\n    /// @dev Storage slot: uint256 consensusVersion\n    bytes32 internal constant CONSENSUS_VERSION_POSITION =\n        keccak256(\"lido.BaseOracle.consensusVersion\");\n\n    /// @dev Storage slot: uint256 lastProcessingRefSlot\n    bytes32 internal constant LAST_PROCESSING_REF_SLOT_POSITION =\n        keccak256(\"lido.BaseOracle.lastProcessingRefSlot\");\n\n    /// @dev Storage slot: ConsensusReport consensusReport\n    bytes32 internal constant CONSENSUS_REPORT_POSITION =\n        keccak256(\"lido.BaseOracle.consensusReport\");\n\n\n    uint256 public immutable SECONDS_PER_SLOT;\n    uint256 public immutable GENESIS_TIME;\n\n    ///\n    /// Initialization & admin functions\n    ///\n\n    constructor(uint256 secondsPerSlot, uint256 genesisTime) {\n        if (secondsPerSlot == 0) revert SecondsPerSlotCannotBeZero();\n        SECONDS_PER_SLOT = secondsPerSlot;\n        GENESIS_TIME = genesisTime;\n    }\n\n    /// @notice Returns the address of the HashConsensus contract.\n    ///\n    function getConsensusContract() external view returns (address) {\n        return CONSENSUS_CONTRACT_POSITION.getStorageAddress();\n    }\n\n    /// @notice Sets the address of the HashConsensus contract.\n    ///\n    function setConsensusContract(address addr) external onlyRole(MANAGE_CONSENSUS_CONTRACT_ROLE) {\n        _setConsensusContract(addr, LAST_PROCESSING_REF_SLOT_POSITION.getStorageUint256());\n    }\n\n    /// @notice Returns the current consensus version expected by the oracle contract.\n    ///\n    /// Consensus version must change every time consensus rules change, meaning that\n    /// an oracle looking at the same reference slot would calculate a different hash.\n    ///\n    function getConsensusVersion() external view returns (uint256) {\n        return CONSENSUS_VERSION_POSITION.getStorageUint256();\n    }\n\n    /// @notice Sets the consensus version expected by the oracle contract.\n    ///\n    function setConsensusVersion(uint256 version) external onlyRole(MANAGE_CONSENSUS_VERSION_ROLE) {\n        _setConsensusVersion(version);\n    }\n\n    ///\n    /// Data provider interface\n    ///\n\n    /// @notice Returns the last consensus report hash and metadata.\n    ///\n    function getConsensusReport() external view returns (\n        bytes32 hash,\n        uint256 refSlot,\n        uint256 processingDeadlineTime,\n        bool processingStarted\n    ) {\n        ConsensusReport memory report = _storageConsensusReport().value;\n        uint256 processingRefSlot = LAST_PROCESSING_REF_SLOT_POSITION.getStorageUint256();\n        return (\n            report.hash,\n            report.refSlot,\n            report.processingDeadlineTime,\n            report.hash != bytes32(0) && report.refSlot == processingRefSlot\n        );\n    }\n\n    ///\n    /// Consensus contract interface\n    ///\n\n    /// @notice Called by HashConsensus contract to push a consensus report for processing.\n    ///\n    /// Note that submitting the report doesn't require the processor to start processing it right\n    /// away, this can happen later (see `getLastProcessingRefSlot`). Until processing is started,\n    /// HashConsensus is free to reach consensus on another report for the same reporting frame an\n    /// submit it using this same function, or to lose the consensus on the submitted report,\n    /// notifying the processor via `discardConsensusReport`.\n    ///\n    function submitConsensusReport(bytes32 reportHash, uint256 refSlot, uint256 deadline) external {\n        _checkSenderIsConsensusContract();\n\n        uint256 prevSubmittedRefSlot = _storageConsensusReport().value.refSlot;\n        if (refSlot < prevSubmittedRefSlot) {\n            revert RefSlotCannotDecrease(refSlot, prevSubmittedRefSlot);\n        }\n\n        uint256 prevProcessingRefSlot = LAST_PROCESSING_REF_SLOT_POSITION.getStorageUint256();\n        if (refSlot <= prevProcessingRefSlot) {\n            revert RefSlotMustBeGreaterThanProcessingOne(refSlot, prevProcessingRefSlot);\n        }\n\n        if (_getTime() > deadline) {\n            revert ProcessingDeadlineMissed(deadline);\n        }\n\n        if (refSlot != prevSubmittedRefSlot && prevProcessingRefSlot != prevSubmittedRefSlot) {\n            emit WarnProcessingMissed(prevSubmittedRefSlot);\n        }\n\n        if (reportHash == bytes32(0)) {\n            revert HashCannotBeZero();\n        }\n\n        emit ReportSubmitted(refSlot, reportHash, deadline);\n\n        ConsensusReport memory report = ConsensusReport({\n            hash: reportHash,\n            refSlot: refSlot.toUint64(),\n            processingDeadlineTime: deadline.toUint64()\n        });\n\n        _storageConsensusReport().value = report;\n        _handleConsensusReport(report, prevSubmittedRefSlot, prevProcessingRefSlot);\n    }\n\n    /// @notice Called by HashConsensus contract to notify that the report for the given ref. slot\n    /// is not a conensus report anymore and should be discarded. This can happen when a member\n    /// changes their report, is removed from the set, or when the quorum value gets increased.\n    ///\n    /// Only called when, for the given reference slot:\n    ///\n    ///   1. there previously was a consensus report; AND\n    ///   1. processing of the consensus report hasn't started yet; AND\n    ///   2. report processing deadline is not expired yet; AND\n    ///   3. there's no consensus report now (otherwise, `submitConsensusReport` is called instead).\n    ///\n    /// Can be called even when there's no submitted non-discarded consensus report for the current\n    /// reference slot, i.e. can be called multiple times in succession.\n    ///\n    function discardConsensusReport(uint256 refSlot) external {\n        _checkSenderIsConsensusContract();\n\n        ConsensusReport memory submittedReport = _storageConsensusReport().value;\n        if (refSlot < submittedReport.refSlot) {\n            revert RefSlotCannotDecrease(refSlot, submittedReport.refSlot);\n        } else if (refSlot > submittedReport.refSlot) {\n            return;\n        }\n\n        uint256 lastProcessingRefSlot = LAST_PROCESSING_REF_SLOT_POSITION.getStorageUint256();\n        if (refSlot <= lastProcessingRefSlot) {\n            revert RefSlotAlreadyProcessing();\n        }\n\n        _storageConsensusReport().value.hash = bytes32(0);\n        _handleConsensusReportDiscarded(submittedReport);\n\n        emit ReportDiscarded(submittedReport.refSlot, submittedReport.hash);\n    }\n\n    /// @notice Returns the last reference slot for which processing of the report was started.\n    ///\n    function getLastProcessingRefSlot() external view returns (uint256) {\n        return LAST_PROCESSING_REF_SLOT_POSITION.getStorageUint256();\n    }\n\n    ///\n    /// Descendant contract interface\n    ///\n\n    /// @notice Initializes the contract storage. Must be called by a descendant\n    /// contract as part of its initialization.\n    ///\n    function _initialize(\n        address consensusContract,\n        uint256 consensusVersion,\n        uint256 lastProcessingRefSlot\n    ) internal virtual {\n        _initializeContractVersionTo(1);\n        _setConsensusContract(consensusContract, lastProcessingRefSlot);\n        _setConsensusVersion(consensusVersion);\n        LAST_PROCESSING_REF_SLOT_POSITION.setStorageUint256(lastProcessingRefSlot);\n        _storageConsensusReport().value.refSlot = lastProcessingRefSlot.toUint64();\n    }\n\n    /// @notice Returns whether the given address is a member of the oracle committee.\n    ///\n    function _isConsensusMember(address addr) internal view returns (bool) {\n        address consensus = CONSENSUS_CONTRACT_POSITION.getStorageAddress();\n        return IConsensusContract(consensus).getIsMember(addr);\n    }\n\n    /// @notice Called when the oracle gets a new consensus report from the HashConsensus contract.\n    ///\n    /// Keep in mind that, until you call `_startProcessing`, the oracle committee is free to\n    /// reach consensus on another report for the same reporting frame and re-submit it using\n    /// this function, or lose consensus on the report and ask to discard it by calling the\n    /// `_handleConsensusReportDiscarded` function.\n    ///\n    function _handleConsensusReport(\n        ConsensusReport memory report,\n        uint256 prevSubmittedRefSlot,\n        uint256 prevProcessingRefSlot\n    ) internal virtual;\n\n    /// @notice Called when the HashConsensus contract loses consensus on a previously submitted\n    /// report that is not processing yet and asks to discard this report. Only called if there is\n    /// no new consensus report at the moment; otherwise, `_handleConsensusReport` is called instead.\n    ///\n    function _handleConsensusReportDiscarded(ConsensusReport memory report) internal virtual {}\n\n    /// @notice May be called by a descendant contract to check if the received data matches\n    /// the currently submitted consensus report. Reverts otherwise.\n    ///\n    function _checkConsensusData(uint256 refSlot, uint256 consensusVersion, bytes32 hash)\n        internal view\n    {\n        ConsensusReport memory report = _storageConsensusReport().value;\n        if (refSlot != report.refSlot) {\n            revert UnexpectedRefSlot(report.refSlot, refSlot);\n        }\n\n        uint256 expectedConsensusVersion = CONSENSUS_VERSION_POSITION.getStorageUint256();\n        if (consensusVersion != expectedConsensusVersion) {\n            revert UnexpectedConsensusVersion(expectedConsensusVersion, consensusVersion);\n        }\n\n        if (hash != report.hash) {\n            revert UnexpectedDataHash(report.hash, hash);\n        }\n    }\n\n    /// @notice Called by a descendant contract to mark the current consensus report\n    /// as being processed. Returns the last ref. slot which processing was started\n    /// before the call.\n    ///\n    /// Before this function is called, the oracle committee is free to reach consensus\n    /// on another report for the same reporting frame. After this function is called,\n    /// the consensus report for the current frame is guaranteed to remain the same.\n    ///\n    function _startProcessing() internal returns (uint256) {\n        ConsensusReport memory report = _storageConsensusReport().value;\n        if (report.hash == bytes32(0)) {\n            revert NoConsensusReportToProcess();\n        }\n\n        _checkProcessingDeadline(report.processingDeadlineTime);\n\n        uint256 prevProcessingRefSlot = LAST_PROCESSING_REF_SLOT_POSITION.getStorageUint256();\n        if (prevProcessingRefSlot == report.refSlot) {\n            revert RefSlotAlreadyProcessing();\n        }\n\n        LAST_PROCESSING_REF_SLOT_POSITION.setStorageUint256(report.refSlot);\n\n        emit ProcessingStarted(report.refSlot, report.hash);\n        return prevProcessingRefSlot;\n    }\n\n    /// @notice Reverts if the processing deadline for the current consensus report is missed.\n    ///\n    function _checkProcessingDeadline() internal view {\n        _checkProcessingDeadline(_storageConsensusReport().value.processingDeadlineTime);\n    }\n\n    function _checkProcessingDeadline(uint256 deadlineTime) internal view {\n        if (_getTime() > deadlineTime) revert ProcessingDeadlineMissed(deadlineTime);\n    }\n\n    /// @notice Returns the reference slot for the current frame.\n    ///\n    function _getCurrentRefSlot() internal view returns (uint256) {\n        address consensusContract = CONSENSUS_CONTRACT_POSITION.getStorageAddress();\n        (uint256 refSlot, ) = IConsensusContract(consensusContract).getCurrentFrame();\n        return refSlot;\n    }\n\n    ///\n    /// Implementation & helpers\n    ///\n\n    function _setConsensusVersion(uint256 version) internal {\n        uint256 prevVersion = CONSENSUS_VERSION_POSITION.getStorageUint256();\n        if (version == prevVersion) revert VersionCannotBeSame();\n        CONSENSUS_VERSION_POSITION.setStorageUint256(version);\n        emit ConsensusVersionSet(version, prevVersion);\n    }\n\n    function _setConsensusContract(address addr, uint256 lastProcessingRefSlot) internal {\n        if (addr == address(0)) revert AddressCannotBeZero();\n\n        address prevAddr = CONSENSUS_CONTRACT_POSITION.getStorageAddress();\n        if (addr == prevAddr) revert AddressCannotBeSame();\n\n        (, uint256 secondsPerSlot, uint256 genesisTime) = IConsensusContract(addr).getChainConfig();\n        if (secondsPerSlot != SECONDS_PER_SLOT || genesisTime != GENESIS_TIME) {\n            revert UnexpectedChainConfig();\n        }\n\n        uint256 initialRefSlot = IConsensusContract(addr).getInitialRefSlot();\n        if (initialRefSlot < lastProcessingRefSlot) {\n            revert InitialRefSlotCannotBeLessThanProcessingOne(initialRefSlot, lastProcessingRefSlot);\n        }\n\n        CONSENSUS_CONTRACT_POSITION.setStorageAddress(addr);\n        emit ConsensusHashContractSet(addr, prevAddr);\n    }\n\n    function _checkSenderIsConsensusContract() internal view {\n        if (_msgSender() != CONSENSUS_CONTRACT_POSITION.getStorageAddress()) {\n            revert SenderIsNotTheConsensusContract();\n        }\n    }\n\n    function _getTime() internal virtual view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    ///\n    /// Storage helpers\n    ///\n\n    struct StorageConsensusReport {\n        ConsensusReport value;\n    }\n\n    function _storageConsensusReport() internal pure returns (StorageConsensusReport storage r) {\n        bytes32 position = CONSENSUS_REPORT_POSITION;\n        assembly { r.slot := position }\n    }\n}\n"
    }
}