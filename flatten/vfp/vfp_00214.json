{
    "vfp_id": "vfp_00214",
    "project_name": "ackee-blockchain-lido-triggerable-withdrawals-report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Lack of context in deprecated function NatSpec",
            "description": "Deprecated functions contain incomplete or missing NatSpec documentation, reducing clarity for developers and auditors.\nThis is a documentation issue where the purpose and deprecation rationale are not clearly communicated.\nWhile not a direct security flaw, poor documentation can lead to misuse or incorrect assumptions.\nThe impact is informational, serving as a recommendation for better code maintenance.\nSpecifically, the deprecated updateTargetValidatorsLimits function in NodeOperatorsRegistry.sol lacks sufficient NatSpec documentation to explain the differences from its replacement. Specifically, it does not clarify that the new function uses a numeric _targetLimitMode parameter instead of a boolean _isTargetLimitActive, supporting additional operational modes. The root cause is incomplete documentation during refactoring. This can mislead developers into incorrect usage or assumptions about backward compatibility. The impact is increased risk of integration errors and confusion during maintenance, reducing code safety and developer experience.\n",
            "severity": "Informational",
            "location": [
                "NodeOperatorsRegistry.sol::updateTargetValidatorsLimits#589-595"
            ],
            "files": [
                "core/contracts/0.4.24/nos/NodeOperatorsRegistry.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "_setExitDeadlineThreshold underflow",
            "description": "The _setExitDeadlineThreshold function is susceptible to an underflow condition if a very small or zero value is provided for the threshold parameter.\nThe cause is insufficient input validation or arithmetic safeguards when updating the deadline threshold, which could allow arithmetic underflow in dependent calculations.\nAn attacker could exploit this by setting an extremely low threshold, potentially causing arithmetic errors or reverting critical operations.\nThe impact is Warning, as the issue is not currently exploitable under normal configuration but could become a vulnerability if access controls are relaxed.\nSpecifically, the NodeOperatorsRegistry._setExitDeadlineThreshold function computes currentCutoffTimestamp as block.timestamp - _threshold - _lateReportingWindow but does not check for underflow. If the sum of _threshold and _lateReportingWindow exceeds block.timestamp, the result underflows, producing a large incorrect timestamp. Although the Packed64x4 library may revert on uint64 overflow, certain underflowed values may still fit within uint64 and be stored, corrupting the state. Once corrupted, the require condition prevents correction. The root cause is missing arithmetic safety checks. A privileged user with the ability to call this function could inadvertently or maliciously set an invalid timestamp, leading to permanent state corruption. The impact is loss of control over exit penalty timing, potentially freezing certain protocol functions.\n",
            "severity": "Informational",
            "location": [
                "NodeOperatorsRegistry.sol::_setExitDeadlineThreshold#1076-1082"
            ],
            "files": [
                "core/contracts/0.4.24/nos/NodeOperatorsRegistry.sol"
            ]
        }
    ],
    "affected_files": {
        "NodeOperatorsRegistry.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.4.24;\n\nimport {AragonApp} from \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport {SafeMath} from \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport {UnstructuredStorage} from \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\n\nimport {Math256} from \"../../common/lib/Math256.sol\";\nimport {MinFirstAllocationStrategy} from \"../../common/lib/MinFirstAllocationStrategy.sol\";\nimport {ILidoLocator} from \"../../common/interfaces/ILidoLocator.sol\";\nimport {SigningKeys} from \"../lib/SigningKeys.sol\";\nimport {Packed64x4} from \"../lib/Packed64x4.sol\";\nimport {Versioned} from \"../utils/Versioned.sol\";\n\ninterface IStETH {\n    function sharesOf(address _account) external view returns (uint256);\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);\n    function approve(address _spender, uint256 _amount) external returns (bool);\n}\n\n/// @title Node Operator registry\n/// @notice Node Operator registry manages signing keys and other node operator data.\n/// @dev Must implement the full version of IStakingModule interface, not only the one declared locally.\n///      It's also responsible for distributing rewards to node operators.\n/// NOTE: the code below assumes moderate amount of node operators, i.e. up to `MAX_NODE_OPERATORS_COUNT`.\ncontract NodeOperatorsRegistry is AragonApp, Versioned {\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using SigningKeys for bytes32;\n    using Packed64x4 for Packed64x4.Packed;\n\n    //\n    // EVENTS\n    //\n    event NodeOperatorAdded(uint256 nodeOperatorId, string name, address rewardAddress, uint64 stakingLimit);\n    event NodeOperatorActiveSet(uint256 indexed nodeOperatorId, bool active);\n    event NodeOperatorNameSet(uint256 indexed nodeOperatorId, string name);\n    event NodeOperatorRewardAddressSet(uint256 indexed nodeOperatorId, address rewardAddress);\n    event NodeOperatorTotalKeysTrimmed(uint256 indexed nodeOperatorId, uint64 totalKeysTrimmed);\n    event KeysOpIndexSet(uint256 keysOpIndex);\n    event StakingModuleTypeSet(bytes32 moduleType);\n    event RewardsDistributed(address indexed rewardAddress, uint256 sharesAmount);\n    event RewardDistributionStateChanged(RewardDistributionState state);\n    event LocatorContractSet(address locatorAddress);\n    event VettedSigningKeysCountChanged(uint256 indexed nodeOperatorId, uint256 approvedValidatorsCount);\n    event DepositedSigningKeysCountChanged(uint256 indexed nodeOperatorId, uint256 depositedValidatorsCount);\n    event ExitedSigningKeysCountChanged(uint256 indexed nodeOperatorId, uint256 exitedValidatorsCount);\n    event TotalSigningKeysCountChanged(uint256 indexed nodeOperatorId, uint256 totalValidatorsCount);\n\n    event NonceChanged(uint256 nonce);\n    event TargetValidatorsCountChanged(uint256 indexed nodeOperatorId, uint256 targetValidatorsCount, uint256 targetLimitMode);\n\n    event ValidatorExitStatusUpdated(\n        uint256 indexed nodeOperatorId,\n        bytes publicKey,\n        uint256 eligibleToExitInSec,\n        uint256 proofSlotTimestamp\n    );\n    event ValidatorExitTriggered(\n        uint256 indexed nodeOperatorId,\n        bytes publicKey,\n        uint256 withdrawalRequestPaidFee,\n        uint256 exitType\n    );\n    event ExitDeadlineThresholdChanged(uint256 threshold, uint256 reportingWindow);\n\n    // Enum to represent the state of the reward distribution process\n    enum RewardDistributionState {\n        TransferredToModule,      // New reward portion minted and transferred to the module\n        ReadyForDistribution,     // Operators' statistics updated, reward ready for distribution\n        Distributed               // Reward distributed among operators\n    }\n\n    //\n    // ACL\n    //\n    // bytes32 public constant MANAGE_SIGNING_KEYS = keccak256(\"MANAGE_SIGNING_KEYS\");\n    bytes32 public constant MANAGE_SIGNING_KEYS = 0x75abc64490e17b40ea1e66691c3eb493647b24430b358bd87ec3e5127f1621ee;\n    // bytes32 public constant SET_NODE_OPERATOR_LIMIT_ROLE = keccak256(\"SET_NODE_OPERATOR_LIMIT_ROLE\");\n    bytes32 public constant SET_NODE_OPERATOR_LIMIT_ROLE = 0x07b39e0faf2521001ae4e58cb9ffd3840a63e205d288dc9c93c3774f0d794754;\n    // bytes32 public constant MANAGE_NODE_OPERATOR_ROLE = keccak256(\"MANAGE_NODE_OPERATOR_ROLE\");\n    bytes32 public constant MANAGE_NODE_OPERATOR_ROLE = 0x78523850fdd761612f46e844cf5a16bda6b3151d6ae961fd7e8e7b92bfbca7f8;\n    // bytes32 public constant STAKING_ROUTER_ROLE = keccak256(\"STAKING_ROUTER_ROLE\");\n    bytes32 public constant STAKING_ROUTER_ROLE = 0xbb75b874360e0bfd87f964eadd8276d8efb7c942134fc329b513032d0803e0c6;\n\n    //\n    // CONSTANTS\n    //\n    uint256 public constant MAX_NODE_OPERATORS_COUNT = 200;\n    uint256 public constant MAX_NODE_OPERATOR_NAME_LENGTH = 255;\n    uint256 public constant MAX_STUCK_PENALTY_DELAY = 365 days;\n\n    uint256 internal constant UINT64_MAX = 0xFFFFFFFFFFFFFFFF;\n\n    // SigningKeysStats\n    /// @dev Operator's max validator keys count approved for deposit by the DAO\n    uint8 internal constant TOTAL_VETTED_KEYS_COUNT_OFFSET = 0;\n    /// @dev Number of keys in the EXITED state of this operator for all time\n    uint8 internal constant TOTAL_EXITED_KEYS_COUNT_OFFSET = 1;\n    /// @dev Total number of keys of this operator for all time\n    uint8 internal constant TOTAL_KEYS_COUNT_OFFSET = 2;\n    /// @dev Number of keys of this operator which were in DEPOSITED state for all time\n    uint8 internal constant TOTAL_DEPOSITED_KEYS_COUNT_OFFSET = 3;\n\n    // TargetValidatorsStats\n    /// @dev Target limit mode, allows limiting target active validators count for operator (0 = disabled, 1 = soft mode, 2 = boosted mode)\n    uint8 internal constant TARGET_LIMIT_MODE_OFFSET = 0;\n    /// @dev relative target active validators limit for operator, set by DAO\n    /// @notice used to check how many keys should go to exit, 0 - means all deposited keys would be exited\n    uint8 internal constant TARGET_VALIDATORS_COUNT_OFFSET = 1;\n    /// @dev actual operators's number of keys which could be deposited\n    uint8 internal constant MAX_VALIDATORS_COUNT_OFFSET = 2;\n\n    // Summary SigningKeysStats\n    uint8 internal constant SUMMARY_MAX_VALIDATORS_COUNT_OFFSET = 0;\n    /// @dev Number of keys of all operators which were in the EXITED state for all time\n    uint8 internal constant SUMMARY_EXITED_KEYS_COUNT_OFFSET = 1;\n    /// @dev [deprecated] Total number of keys of all operators for all time\n    uint8 internal constant SUMMARY_TOTAL_KEYS_COUNT_OFFSET = 2;\n    /// @dev Number of keys of all operators which were in the DEPOSITED state for all time\n    uint8 internal constant SUMMARY_DEPOSITED_KEYS_COUNT_OFFSET = 3;\n\n    //\n    // UNSTRUCTURED STORAGE POSITIONS\n    //\n    // bytes32 internal constant SIGNING_KEYS_MAPPING_NAME = keccak256(\"lido.NodeOperatorsRegistry.signingKeysMappingName\");\n    bytes32 internal constant SIGNING_KEYS_MAPPING_NAME = 0xeb2b7ad4d8ce5610cfb46470f03b14c197c2b751077c70209c5d0139f7c79ee9;\n\n    // bytes32 internal constant LIDO_LOCATOR_POSITION = keccak256(\"lido.NodeOperatorsRegistry.lidoLocator\");\n    bytes32 internal constant LIDO_LOCATOR_POSITION = 0xfb2059fd4b64256b64068a0f57046c6d40b9f0e592ba8bcfdf5b941910d03537;\n\n    /// @dev Total number of operators\n    // bytes32 internal constant TOTAL_OPERATORS_COUNT_POSITION = keccak256(\"lido.NodeOperatorsRegistry.totalOperatorsCount\");\n    bytes32 internal constant TOTAL_OPERATORS_COUNT_POSITION =\n        0xe2a589ae0816b289a9d29b7c085f8eba4b5525accca9fa8ff4dba3f5a41287e8;\n\n    /// @dev Cached number of active operators\n    // bytes32 internal constant ACTIVE_OPERATORS_COUNT_POSITION = keccak256(\"lido.NodeOperatorsRegistry.activeOperatorsCount\");\n    bytes32 internal constant ACTIVE_OPERATORS_COUNT_POSITION =\n        0x6f5220989faafdc182d508d697678366f4e831f5f56166ad69bfc253fc548fb1;\n\n    /// @dev link to the index of operations with keys\n    // bytes32 internal constant KEYS_OP_INDEX_POSITION = keccak256(\"lido.NodeOperatorsRegistry.keysOpIndex\");\n    bytes32 internal constant KEYS_OP_INDEX_POSITION = 0xcd91478ac3f2620f0776eacb9c24123a214bcb23c32ae7d28278aa846c8c380e;\n\n    /// @dev module type\n    // bytes32 internal constant TYPE_POSITION = keccak256(\"lido.NodeOperatorsRegistry.type\");\n    bytes32 internal constant TYPE_POSITION = 0xbacf4236659a602d72c631ba0b0d67ec320aaf523f3ae3590d7faee4f42351d0;\n\n    // bytes32 internal constant REWARD_DISTRIBUTION_STATE = keccak256(\"lido.NodeOperatorsRegistry.rewardDistributionState\");\n    bytes32 internal constant REWARD_DISTRIBUTION_STATE = 0x4ddbb0dcdc5f7692e494c15a7fca1f9eb65f31da0b5ce1c3381f6a1a1fd579b6;\n\n    // bytes32 internal constant EXIT_DELAY_STATS = keccak256(\"lido.NodeOperatorsRegistry.exitDelayStats\");\n    bytes32 internal constant EXIT_DELAY_STATS = 0x9fe52a88cbf7bfbe5e42abc45469ad27b2231a10bcbcd0a227c7ca0835cecbd8;\n    /// @dev Exit delay stats offsets in Packed64x4:\n    /// @dev The delay threshold in seconds after which a validator exit is considered late\n    uint8 internal constant EXIT_DELAY_THRESHOLD_OFFSET = 0;\n    /// @dev Timestamp before which validators reported as late will not result in penalties for their Node Operators.\n    uint8 internal constant EXIT_PENALTY_CUTOFF_TIMESTAMP_OFFSET = 1;\n\n\n    //\n    // DATA TYPES\n    //\n\n    /// @dev Node Operator parameters and internal state\n    struct NodeOperator {\n        /// @dev Flag indicating if the operator can participate in further staking and reward distribution\n        bool active;\n        /// @dev Ethereum address on Execution Layer which receives stETH rewards for this operator\n        address rewardAddress;\n        /// @dev Human-readable name\n        string name;\n        /// @dev The below variables store the signing keys info of the node operator.\n        ///     signingKeysStats - contains packed variables: uint64 exitedSigningKeysCount, uint64 depositedSigningKeysCount,\n        ///                        uint64 vettedSigningKeysCount, uint64 totalSigningKeysCount\n        ///\n        ///     These variables can take values in the following ranges:\n        ///\n        ///                0             <=  exitedSigningKeysCount   <= depositedSigningKeysCount\n        ///     exitedSigningKeysCount   <= depositedSigningKeysCount <=  vettedSigningKeysCount\n        ///    depositedSigningKeysCount <=   vettedSigningKeysCount  <=   totalSigningKeysCount\n        ///    depositedSigningKeysCount <=   totalSigningKeysCount   <=        UINT64_MAX\n        ///\n        /// Additionally, the exitedSigningKeysCount and depositedSigningKeysCount values are monotonically increasing:\n        /// :                              :         :         :         :\n        /// [....exitedSigningKeysCount....]-------->:         :         :\n        /// [....depositedSigningKeysCount :.........]-------->:         :\n        /// [....vettedSigningKeysCount....:.........:<--------]-------->:\n        /// [....totalSigningKeysCount.....:.........:<--------:---------]------->\n        /// :                              :         :         :         :\n        Packed64x4.Packed signingKeysStats;\n        Packed64x4.Packed stuckPenaltyStats;\n        Packed64x4.Packed targetValidatorsStats;\n    }\n\n    struct NodeOperatorSummary {\n        Packed64x4.Packed summarySigningKeysStats;\n    }\n\n    //\n    // STORAGE VARIABLES\n    //\n\n    /// @dev Mapping of all node operators. Mapping is used to be able to extend the struct.\n    mapping(uint256 => NodeOperator) internal _nodeOperators;\n    NodeOperatorSummary internal _nodeOperatorSummary;\n\n    /// @dev Mapping of Node Operator exit delay keys\n    mapping(bytes32 => bool) internal _validatorProcessedLateKeys;\n\n    //\n    // METHODS\n    //\n    function initialize(\n        address _locator,\n        bytes32 _type,\n        uint256 _exitDeadlineThresholdInSeconds\n    ) public onlyInit {\n        // Initializations for v1 --> v2\n        _initialize_v2(_locator, _type);\n\n        // Initializations for v2 --> v3\n        _initialize_v3();\n\n        // Initializations for v3 --> v4\n        _initialize_v4(_exitDeadlineThresholdInSeconds);\n\n        initialized();\n    }\n\n    function _initialize_v2(address _locator, bytes32 _type) internal {\n        _onlyNonZeroAddress(_locator);\n        LIDO_LOCATOR_POSITION.setStorageAddress(_locator);\n        TYPE_POSITION.setStorageBytes32(_type);\n\n        _setContractVersion(2);\n\n        emit LocatorContractSet(_locator);\n        emit StakingModuleTypeSet(_type);\n    }\n\n    function _initialize_v3() internal {\n        _setContractVersion(3);\n        _updateRewardDistributionState(RewardDistributionState.Distributed);\n    }\n\n    function _initialize_v4(uint256 _exitDeadlineThresholdInSeconds) internal {\n        _setContractVersion(4);\n        /// @dev The reportingWindowThreshold is set to 0 because it is not required during cold start.\n        ///      This parameter is only relevant when changing _exitDeadlineThresholdInSeconds in future upgrades.\n        _setExitDeadlineThreshold(_exitDeadlineThresholdInSeconds, 0);\n    }\n\n    /// @notice A function to finalize upgrade to v2 (from v1). Removed and no longer used.\n    /// For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n    /// See historical usage in commit: https://github.com/lidofinance/core/blob/c19480aa3366b26aa6eac17f85a6efae8b9f4f72/contracts/0.4.24/nos/NodeOperatorsRegistry.sol#L230\n    /// function finalizeUpgrade_v2(address _locator, bytes32 _type, uint256 _stuckPenaltyDelay) external\n\n    /// @notice A function to finalize upgrade to v3 (from v2). Removed and no longer used.\n    /// See historical usage in commit: https://github.com/lidofinance/core/blob/c19480aa3366b26aa6eac17f85a6efae8b9f4f72/contracts/0.4.24/nos/NodeOperatorsRegistry.sol#L298\n    /// function finalizeUpgrade_v3() external\n\n    /// @notice Finalizes upgrade to version 4 by initializing new exit-related parameters.\n    /// @param _exitDeadlineThresholdInSeconds Exit deadline threshold in seconds for validator exits.\n    function finalizeUpgrade_v4(uint256 _exitDeadlineThresholdInSeconds) external {\n        require(hasInitialized(), \"CONTRACT_NOT_INITIALIZED\");\n        _checkContractVersion(3);\n\n        // Set allowance to 0 since the stuck keys logic has been removed and burning shares is no longer needed\n        IStETH(getLocator().lido()).approve(getLocator().burner(), 0);\n        _initialize_v4(_exitDeadlineThresholdInSeconds);\n    }\n\n    /// @notice Add node operator named `name` with reward address `rewardAddress` and staking limit = 0 validators\n    /// @param _name Human-readable name\n    /// @param _rewardAddress Ethereum 1 address which receives stETH rewards for this operator\n    /// @return id a unique key of the added operator\n    function addNodeOperator(string _name, address _rewardAddress) external returns (uint256 id) {\n        _onlyValidNodeOperatorName(_name);\n        _onlyValidRewardAddress(_rewardAddress);\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n\n        id = getNodeOperatorsCount();\n        require(id < MAX_NODE_OPERATORS_COUNT, \"MAX_OPERATORS_COUNT_EXCEEDED\");\n\n        TOTAL_OPERATORS_COUNT_POSITION.setStorageUint256(id + 1);\n\n        NodeOperator storage operator = _nodeOperators[id];\n\n        uint256 activeOperatorsCount = getActiveNodeOperatorsCount();\n        ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(activeOperatorsCount + 1);\n\n        operator.active = true;\n        operator.name = _name;\n        operator.rewardAddress = _rewardAddress;\n\n        emit NodeOperatorAdded(id, _name, _rewardAddress, 0);\n    }\n\n    /// @notice Activates deactivated node operator with given id\n    /// @param _nodeOperatorId Node operator id to activate\n    function activateNodeOperator(uint256 _nodeOperatorId) external {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n\n        _onlyCorrectNodeOperatorState(!getNodeOperatorIsActive(_nodeOperatorId));\n\n        ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(getActiveNodeOperatorsCount() + 1);\n\n        _nodeOperators[_nodeOperatorId].active = true;\n\n        emit NodeOperatorActiveSet(_nodeOperatorId, true);\n        _increaseValidatorsKeysNonce();\n    }\n\n    /// @notice Deactivates active node operator with given id\n    /// @param _nodeOperatorId Node operator id to deactivate\n    function deactivateNodeOperator(uint256 _nodeOperatorId) external {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n\n        _onlyCorrectNodeOperatorState(getNodeOperatorIsActive(_nodeOperatorId));\n\n        uint256 activeOperatorsCount = getActiveNodeOperatorsCount();\n        ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(activeOperatorsCount.sub(1));\n\n        _nodeOperators[_nodeOperatorId].active = false;\n\n        emit NodeOperatorActiveSet(_nodeOperatorId, false);\n\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        uint256 vettedSigningKeysCount = signingKeysStats.get(TOTAL_VETTED_KEYS_COUNT_OFFSET);\n        uint256 depositedSigningKeysCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n\n        // reset vetted keys count to the deposited validators count\n        if (vettedSigningKeysCount > depositedSigningKeysCount) {\n            signingKeysStats.set(TOTAL_VETTED_KEYS_COUNT_OFFSET, depositedSigningKeysCount);\n            _saveOperatorSigningKeysStats(_nodeOperatorId, signingKeysStats);\n\n            emit VettedSigningKeysCountChanged(_nodeOperatorId, depositedSigningKeysCount);\n\n            _updateSummaryMaxValidatorsCount(_nodeOperatorId);\n        }\n        _increaseValidatorsKeysNonce();\n    }\n\n    /// @notice Change human-readable name of the node operator with given id\n    /// @param _nodeOperatorId Node operator id to set name for\n    /// @param _name New human-readable name of the node operator\n    function setNodeOperatorName(uint256 _nodeOperatorId, string _name) external {\n        _onlyValidNodeOperatorName(_name);\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n\n        _requireNotSameValue(keccak256(bytes(_nodeOperators[_nodeOperatorId].name)) != keccak256(bytes(_name)));\n        _nodeOperators[_nodeOperatorId].name = _name;\n        emit NodeOperatorNameSet(_nodeOperatorId, _name);\n    }\n\n    /// @notice Change reward address of the node operator with given id\n    /// @param _nodeOperatorId Node operator id to set reward address for\n    /// @param _rewardAddress Execution layer Ethereum address to set as reward address\n    function setNodeOperatorRewardAddress(uint256 _nodeOperatorId, address _rewardAddress) external {\n        _onlyValidRewardAddress(_rewardAddress);\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n\n        _requireNotSameValue(_nodeOperators[_nodeOperatorId].rewardAddress != _rewardAddress);\n        _nodeOperators[_nodeOperatorId].rewardAddress = _rewardAddress;\n        emit NodeOperatorRewardAddressSet(_nodeOperatorId, _rewardAddress);\n    }\n\n    /// @notice Set the maximum number of validators to stake for the node operator with given id\n    /// @dev Current implementation preserves invariant: depositedSigningKeysCount <= vettedSigningKeysCount <= totalSigningKeysCount.\n    ///     If _vettedSigningKeysCount out of range [depositedSigningKeysCount, totalSigningKeysCount], the new vettedSigningKeysCount\n    ///     value will be set to the nearest range border.\n    /// @param _nodeOperatorId Node operator id to set staking limit for\n    /// @param _vettedSigningKeysCount New staking limit of the node operator\n    function setNodeOperatorStakingLimit(uint256 _nodeOperatorId, uint64 _vettedSigningKeysCount) external {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _authP(SET_NODE_OPERATOR_LIMIT_ROLE, arr(uint256(_nodeOperatorId), uint256(_vettedSigningKeysCount)));\n        _onlyCorrectNodeOperatorState(getNodeOperatorIsActive(_nodeOperatorId));\n\n        _updateVettedSigningKeysCount(_nodeOperatorId, _vettedSigningKeysCount, true /* _allowIncrease */);\n        _increaseValidatorsKeysNonce();\n    }\n\n    /// @notice Called by StakingRouter to decrease the number of vetted keys for node operator with given id\n    /// @param _nodeOperatorIds bytes packed array of the node operators id\n    /// @param _vettedSigningKeysCounts bytes packed array of the new number of vetted keys for the node operators\n    function decreaseVettedSigningKeysCount(\n        bytes _nodeOperatorIds,\n        bytes _vettedSigningKeysCounts\n    ) external {\n        _auth(STAKING_ROUTER_ROLE);\n        uint256 nodeOperatorsCount = _checkReportPayload(_nodeOperatorIds.length, _vettedSigningKeysCounts.length);\n        uint256 totalNodeOperatorsCount = getNodeOperatorsCount();\n\n        uint256 nodeOperatorId;\n        uint256 vettedKeysCount;\n        uint256 _nodeOperatorIdsOffset;\n        uint256 _vettedKeysCountsOffset;\n\n        /// @dev calldata layout:\n        /// | func sig (4 bytes) | ABI-enc data |\n        ///\n        /// ABI-enc data:\n        ///\n        /// |    32 bytes    |     32 bytes      |  32 bytes  | ... |  32 bytes  | ...... |\n        /// | ids len offset | counts len offset |  ids len   | ids | counts len | counts |\n        assembly {\n            _nodeOperatorIdsOffset := add(calldataload(4), 36) // arg1 calldata offset + 4 (signature len) + 32 (length slot)\n            _vettedKeysCountsOffset := add(calldataload(36), 36) // arg2 calldata offset + 4 (signature len) + 32 (length slot))\n        }\n        for (uint256 i; i < nodeOperatorsCount;) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                nodeOperatorId := shr(192, calldataload(add(_nodeOperatorIdsOffset, mul(i, 8))))\n                vettedKeysCount := shr(128, calldataload(add(_vettedKeysCountsOffset, mul(i, 16))))\n                i := add(i, 1)\n            }\n            _requireValidRange(nodeOperatorId < totalNodeOperatorsCount);\n            _updateVettedSigningKeysCount(nodeOperatorId, vettedKeysCount, false /* only decrease */);\n        }\n        _increaseValidatorsKeysNonce();\n    }\n\n    function _updateVettedSigningKeysCount(\n        uint256 _nodeOperatorId,\n        uint256 _vettedSigningKeysCount,\n        bool _allowIncrease\n    ) internal {\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        uint256 vettedSigningKeysCountBefore = signingKeysStats.get(TOTAL_VETTED_KEYS_COUNT_OFFSET);\n        uint256 depositedSigningKeysCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n        uint256 totalSigningKeysCount = signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET);\n\n        uint256 vettedSigningKeysCountAfter = Math256.min(\n            totalSigningKeysCount, Math256.max(_vettedSigningKeysCount, depositedSigningKeysCount)\n        );\n\n        if (vettedSigningKeysCountAfter == vettedSigningKeysCountBefore) return;\n\n        require(\n            _allowIncrease || vettedSigningKeysCountAfter < vettedSigningKeysCountBefore,\n            \"VETTED_KEYS_COUNT_INCREASED\"\n        );\n\n        signingKeysStats.set(TOTAL_VETTED_KEYS_COUNT_OFFSET, vettedSigningKeysCountAfter);\n        _saveOperatorSigningKeysStats(_nodeOperatorId, signingKeysStats);\n\n        emit VettedSigningKeysCountChanged(_nodeOperatorId, vettedSigningKeysCountAfter);\n\n        _updateSummaryMaxValidatorsCount(_nodeOperatorId);\n    }\n\n    /// @notice Called by StakingRouter to signal that stETH rewards were minted for this module.\n    function onRewardsMinted(uint256 /* _totalShares */) external {\n        _auth(STAKING_ROUTER_ROLE);\n        _updateRewardDistributionState(RewardDistributionState.TransferredToModule);\n    }\n\n    function _checkReportPayload(uint256 idsLength, uint256 countsLength) internal pure returns (uint256 count) {\n        count = idsLength / 8;\n        require(countsLength / 16 == count && idsLength % 8 == 0 && countsLength % 16 == 0, \"INVALID_REPORT_DATA\");\n    }\n\n    /// @notice Called by StakingRouter to update the number of the validators in the EXITED state\n    /// for node operator with given id\n    ///\n    /// @param _nodeOperatorIds bytes packed array of the node operators id\n    /// @param _exitedValidatorsCounts bytes packed array of the new number of EXITED validators for the node operators\n    function updateExitedValidatorsCount(\n        bytes _nodeOperatorIds,\n        bytes _exitedValidatorsCounts\n    )\n        external\n    {\n        _auth(STAKING_ROUTER_ROLE);\n        uint256 nodeOperatorsCount = _checkReportPayload(_nodeOperatorIds.length, _exitedValidatorsCounts.length);\n        uint256 totalNodeOperatorsCount = getNodeOperatorsCount();\n\n        uint256 nodeOperatorId;\n        uint256 validatorsCount;\n        uint256 _nodeOperatorIdsOffset;\n        uint256 _exitedValidatorsCountsOffset;\n\n        assembly {\n            _nodeOperatorIdsOffset := add(calldataload(4), 36) // arg1 calldata offset + 4 (signature len) + 32 (length slot)\n            _exitedValidatorsCountsOffset := add(calldataload(36), 36) // arg2 calldata offset + 4 (signature len) + 32 (length slot))\n        }\n        for (uint256 i; i < nodeOperatorsCount;) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                nodeOperatorId := shr(192, calldataload(add(_nodeOperatorIdsOffset, mul(i, 8))))\n                validatorsCount := shr(128, calldataload(add(_exitedValidatorsCountsOffset, mul(i, 16))))\n                i := add(i, 1)\n            }\n            _requireValidRange(nodeOperatorId < totalNodeOperatorsCount);\n            _updateExitedValidatorsCount(nodeOperatorId, validatorsCount, false);\n        }\n        _increaseValidatorsKeysNonce();\n    }\n\n    /// @notice Permissionless method for distributing all accumulated module rewards among node operators\n    /// based on the latest accounting report.\n    ///\n    /// @dev Rewards can be distributed after all necessary data required to distribute rewards among operators\n    /// has been delivered, including exited and stuck keys.\n    ///\n    /// The reward distribution lifecycle:\n    ///\n    /// 1. TransferredToModule: Rewards are transferred to the module during an oracle main report.\n    /// 2. ReadyForDistribution: All necessary data required to distribute rewards among operators has been delivered.\n    /// 3. Distributed: Rewards have been successfully distributed.\n    ///\n    /// The function can only be called when the state is ReadyForDistribution.\n    ///\n    /// @dev Rewards can be distributed after node operators' statistics are updated until the next reward\n    /// is transferred to the module during the next oracle frame.\n    function distributeReward() external {\n        require(getRewardDistributionState() == RewardDistributionState.ReadyForDistribution, \"DISTRIBUTION_NOT_READY\");\n        _updateRewardDistributionState(RewardDistributionState.Distributed);\n        _distributeRewards();\n    }\n\n    /// @notice Called by StakingRouter after it finishes updating exited and stuck validators\n    /// counts for this module's node operators.\n    ///\n    /// Guaranteed to be called after an oracle report is applied, regardless of whether any node\n    /// operator in this module has actually received any updated counts as a result of the report\n    /// but given that the total number of exited validators returned from getStakingModuleSummary\n    /// is the same as StakingRouter expects based on the total count received from the oracle.\n    function onExitedAndStuckValidatorsCountsUpdated() external {\n        _auth(STAKING_ROUTER_ROLE);\n        _updateRewardDistributionState(RewardDistributionState.ReadyForDistribution);\n    }\n\n    /// @notice Unsafely updates the number of validators in the EXITED/STUCK states for node operator with given id.\n    /// @param _nodeOperatorId Id of the node operator\n    /// @param _exitedValidatorsCount New number of EXITED validators for the node operator\n    function unsafeUpdateValidatorsCount(\n        uint256 _nodeOperatorId,\n        uint256 _exitedValidatorsCount\n    ) external {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _auth(STAKING_ROUTER_ROLE);\n\n        _updateExitedValidatorsCount(_nodeOperatorId, _exitedValidatorsCount, true /* _allowDecrease */ );\n        _increaseValidatorsKeysNonce();\n    }\n\n    function _updateExitedValidatorsCount(uint256 _nodeOperatorId, uint256 _exitedValidatorsCount, bool _allowDecrease)\n        internal\n    {\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        uint256 oldExitedValidatorsCount = signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET);\n        if (_exitedValidatorsCount == oldExitedValidatorsCount) return;\n        require(\n            _allowDecrease || _exitedValidatorsCount > oldExitedValidatorsCount,\n            \"EXITED_VALIDATORS_COUNT_DECREASED\"\n        );\n\n        uint256 depositedValidatorsCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n\n        // sustain invariant exited <= deposited\n        _requireValidRange(_exitedValidatorsCount <= depositedValidatorsCount);\n\n        signingKeysStats.set(TOTAL_EXITED_KEYS_COUNT_OFFSET, _exitedValidatorsCount);\n        _saveOperatorSigningKeysStats(_nodeOperatorId, signingKeysStats);\n        emit ExitedSigningKeysCountChanged(_nodeOperatorId, _exitedValidatorsCount);\n\n        Packed64x4.Packed memory summarySigningKeysStats = _loadSummarySigningKeysStats();\n        uint256 exitedValidatorsAbsDiff = Math256.absDiff(_exitedValidatorsCount, oldExitedValidatorsCount);\n        if (_exitedValidatorsCount > oldExitedValidatorsCount) {\n            summarySigningKeysStats.add(SUMMARY_EXITED_KEYS_COUNT_OFFSET, exitedValidatorsAbsDiff);\n        } else {\n            summarySigningKeysStats.sub(SUMMARY_EXITED_KEYS_COUNT_OFFSET, exitedValidatorsAbsDiff);\n        }\n        _saveSummarySigningKeysStats(summarySigningKeysStats);\n        _updateSummaryMaxValidatorsCount(_nodeOperatorId);\n    }\n\n    /// @notice Updates the limit of the validators that can be used for deposit by DAO\n    /// @param _nodeOperatorId Id of the node operator\n    /// @param _isTargetLimitActive Flag indicating if the soft target limit is active\n    /// @param _targetLimit Target limit of the node operator\n    /// @dev This function is deprecated, use updateTargetValidatorsLimits instead\n    function updateTargetValidatorsLimits(uint256 _nodeOperatorId, bool _isTargetLimitActive, uint256 _targetLimit) public {\n        updateTargetValidatorsLimits(_nodeOperatorId, _isTargetLimitActive ? 1 : 0, _targetLimit);\n    }\n\n    /// @notice Updates the limit of the validators that can be used for deposit by DAO\n    /// @param _nodeOperatorId Id of the node operator\n    /// @param _targetLimitMode target limit mode (0 = disabled, 1 = soft mode, 2 = boosted mode)\n    /// @param _targetLimit Target limit of the node operator\n    function updateTargetValidatorsLimits(uint256 _nodeOperatorId, uint256 _targetLimitMode, uint256 _targetLimit) public {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _auth(STAKING_ROUTER_ROLE);\n        _requireValidRange(_targetLimit <= UINT64_MAX);\n\n        Packed64x4.Packed memory operatorTargetStats = _loadOperatorTargetValidatorsStats(_nodeOperatorId);\n        operatorTargetStats.set(TARGET_LIMIT_MODE_OFFSET, _targetLimitMode);\n        if (_targetLimitMode == 0) {\n            _targetLimit = 0;\n        }\n        operatorTargetStats.set(TARGET_VALIDATORS_COUNT_OFFSET, _targetLimit);\n        _saveOperatorTargetValidatorsStats(_nodeOperatorId, operatorTargetStats);\n\n        emit TargetValidatorsCountChanged(_nodeOperatorId, _targetLimit, _targetLimitMode);\n\n        _updateSummaryMaxValidatorsCount(_nodeOperatorId);\n        _increaseValidatorsKeysNonce();\n    }\n\n    // @dev Recalculate and update the max validator count for operator and summary stats\n    function _updateSummaryMaxValidatorsCount(uint256 _nodeOperatorId) internal {\n        (uint256 oldMaxSigningKeysCount, uint256 newMaxSigningKeysCount) = _applyNodeOperatorLimits(_nodeOperatorId);\n\n        if (newMaxSigningKeysCount == oldMaxSigningKeysCount) return;\n\n        Packed64x4.Packed memory summarySigningKeysStats = _loadSummarySigningKeysStats();\n\n        uint256 maxSigningKeysCountAbsDiff = Math256.absDiff(newMaxSigningKeysCount, oldMaxSigningKeysCount);\n        if (newMaxSigningKeysCount > oldMaxSigningKeysCount) {\n            summarySigningKeysStats.add(SUMMARY_MAX_VALIDATORS_COUNT_OFFSET, maxSigningKeysCountAbsDiff);\n        } else {\n            summarySigningKeysStats.sub(SUMMARY_MAX_VALIDATORS_COUNT_OFFSET, maxSigningKeysCountAbsDiff);\n        }\n        _saveSummarySigningKeysStats(summarySigningKeysStats);\n    }\n\n    /// @notice Invalidates all unused deposit data for all node operators\n    function onWithdrawalCredentialsChanged() external {\n        _auth(STAKING_ROUTER_ROLE);\n        uint256 operatorsCount = getNodeOperatorsCount();\n        if (operatorsCount > 0) {\n            _invalidateReadyToDepositKeysRange(0, operatorsCount - 1);\n        }\n    }\n\n    /// @notice Invalidates all unused validators keys for node operators in the given range\n    /// @param _indexFrom the first index (inclusive) of the node operator to invalidate keys for\n    /// @param _indexTo the last index (inclusive) of the node operator to invalidate keys for\n    function invalidateReadyToDepositKeysRange(uint256 _indexFrom, uint256 _indexTo) external {\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n        _invalidateReadyToDepositKeysRange(_indexFrom, _indexTo);\n    }\n\n    function _invalidateReadyToDepositKeysRange(uint256 _indexFrom, uint256 _indexTo) internal {\n        _requireValidRange(_indexFrom <= _indexTo && _indexTo < getNodeOperatorsCount());\n\n        uint256 trimmedKeysCount;\n        uint256 totalTrimmedKeysCount;\n        uint256 totalSigningKeysCount;\n        uint256 depositedSigningKeysCount;\n        Packed64x4.Packed memory signingKeysStats;\n        for (uint256 nodeOperatorId = _indexFrom; nodeOperatorId <= _indexTo; ++nodeOperatorId) {\n            signingKeysStats = _loadOperatorSigningKeysStats(nodeOperatorId);\n\n            totalSigningKeysCount = signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET);\n            depositedSigningKeysCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n\n            if (totalSigningKeysCount == depositedSigningKeysCount) continue;\n            assert(totalSigningKeysCount > depositedSigningKeysCount);\n\n            trimmedKeysCount = totalSigningKeysCount - depositedSigningKeysCount;\n            totalTrimmedKeysCount += trimmedKeysCount;\n\n            signingKeysStats.set(TOTAL_KEYS_COUNT_OFFSET, depositedSigningKeysCount);\n            signingKeysStats.set(TOTAL_VETTED_KEYS_COUNT_OFFSET, depositedSigningKeysCount);\n            _saveOperatorSigningKeysStats(nodeOperatorId, signingKeysStats);\n\n            _updateSummaryMaxValidatorsCount(nodeOperatorId);\n\n            emit TotalSigningKeysCountChanged(nodeOperatorId, depositedSigningKeysCount);\n            emit VettedSigningKeysCountChanged(nodeOperatorId, depositedSigningKeysCount);\n            emit NodeOperatorTotalKeysTrimmed(nodeOperatorId, uint64(trimmedKeysCount));\n        }\n\n        if (totalTrimmedKeysCount > 0) {\n            _increaseValidatorsKeysNonce();\n        }\n    }\n\n    /// @notice Obtains deposit data to be used by StakingRouter to deposit to the Ethereum Deposit\n    ///     contract\n    /// @param _depositsCount Number of deposits to be done\n    /// @return publicKeys Batch of the concatenated public validators keys\n    /// @return signatures Batch of the concatenated deposit signatures for returned public keys\n    function obtainDepositData(\n        uint256 _depositsCount,\n        bytes /* _depositCalldata */\n    ) external returns (bytes memory publicKeys, bytes memory signatures) {\n        _auth(STAKING_ROUTER_ROLE);\n\n        if (_depositsCount == 0) return (new bytes(0), new bytes(0));\n\n        (\n            uint256 allocatedKeysCount,\n            uint256[] memory nodeOperatorIds,\n            uint256[] memory activeKeysCountAfterAllocation\n        ) = _getSigningKeysAllocationData(_depositsCount);\n\n        require(allocatedKeysCount == _depositsCount, \"INVALID_ALLOCATED_KEYS_COUNT\");\n\n        (publicKeys, signatures) = _loadAllocatedSigningKeys(\n            allocatedKeysCount,\n            nodeOperatorIds,\n            activeKeysCountAfterAllocation\n        );\n        _increaseValidatorsKeysNonce();\n    }\n\n    function _getNodeOperator(uint256 _nodeOperatorId)\n        internal\n        view\n        returns (uint256 exitedSigningKeysCount, uint256 depositedSigningKeysCount, uint256 maxSigningKeysCount)\n    {\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        Packed64x4.Packed memory operatorTargetStats = _loadOperatorTargetValidatorsStats(_nodeOperatorId);\n\n        exitedSigningKeysCount = signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET);\n        depositedSigningKeysCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n        maxSigningKeysCount = operatorTargetStats.get(MAX_VALIDATORS_COUNT_OFFSET);\n\n        // Validate data boundaries invariants here to not use SafeMath in caller methods\n        assert(maxSigningKeysCount >= depositedSigningKeysCount && depositedSigningKeysCount >= exitedSigningKeysCount);\n    }\n\n    function _applyNodeOperatorLimits(uint256 _nodeOperatorId)\n        internal\n        returns (uint256 oldMaxSigningKeysCount, uint256 newMaxSigningKeysCount)\n    {\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        Packed64x4.Packed memory operatorTargetStats = _loadOperatorTargetValidatorsStats(_nodeOperatorId);\n\n        uint256 depositedSigningKeysCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n\n        // It's expected that validators don't suffer from penalties most of the time,\n        // so optimistically, set the count of max validators equal to the vetted validators count.\n        newMaxSigningKeysCount = signingKeysStats.get(TOTAL_VETTED_KEYS_COUNT_OFFSET);\n\n        if (operatorTargetStats.get(TARGET_LIMIT_MODE_OFFSET) != 0) {\n            // apply target limit when it's active and the node operator is not penalized\n            newMaxSigningKeysCount = Math256.max(\n                // max validators count can't be less than the deposited validators count\n                // even when the target limit is less than the current active validators count\n                depositedSigningKeysCount,\n                Math256.min(\n                    // max validators count can't be greater than the vetted validators count\n                    newMaxSigningKeysCount,\n                    // SafeMath.add() isn't used below because the sum is always\n                    // less or equal to 2 * UINT64_MAX\n                    signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET)\n                        + operatorTargetStats.get(TARGET_VALIDATORS_COUNT_OFFSET)\n                )\n            );\n        }\n\n        oldMaxSigningKeysCount = operatorTargetStats.get(MAX_VALIDATORS_COUNT_OFFSET);\n        if (oldMaxSigningKeysCount != newMaxSigningKeysCount) {\n            operatorTargetStats.set(MAX_VALIDATORS_COUNT_OFFSET, newMaxSigningKeysCount);\n            _saveOperatorTargetValidatorsStats(_nodeOperatorId, operatorTargetStats);\n        }\n    }\n\n    function _getSigningKeysAllocationData(uint256 _keysCount)\n        internal\n        view\n        returns (uint256 allocatedKeysCount, uint256[] memory nodeOperatorIds, uint256[] memory activeKeyCountsAfterAllocation)\n    {\n        uint256 activeNodeOperatorsCount = getActiveNodeOperatorsCount();\n        nodeOperatorIds = new uint256[](activeNodeOperatorsCount);\n        activeKeyCountsAfterAllocation = new uint256[](activeNodeOperatorsCount);\n        uint256[] memory activeKeysCapacities = new uint256[](activeNodeOperatorsCount);\n\n        uint256 activeNodeOperatorIndex;\n        uint256 nodeOperatorsCount = getNodeOperatorsCount();\n        uint256 maxSigningKeysCount;\n        uint256 depositedSigningKeysCount;\n        uint256 exitedSigningKeysCount;\n\n        for (uint256 nodeOperatorId; nodeOperatorId < nodeOperatorsCount; ++nodeOperatorId) {\n            (exitedSigningKeysCount, depositedSigningKeysCount, maxSigningKeysCount)\n                = _getNodeOperator(nodeOperatorId);\n\n            // the node operator has no available signing keys\n            if (depositedSigningKeysCount == maxSigningKeysCount) continue;\n\n            nodeOperatorIds[activeNodeOperatorIndex] = nodeOperatorId;\n            activeKeyCountsAfterAllocation[activeNodeOperatorIndex] = depositedSigningKeysCount - exitedSigningKeysCount;\n            activeKeysCapacities[activeNodeOperatorIndex] = maxSigningKeysCount - exitedSigningKeysCount;\n            ++activeNodeOperatorIndex;\n        }\n\n        if (activeNodeOperatorIndex == 0) return (0, new uint256[](0), new uint256[](0));\n\n        /// @dev shrink the length of the resulting arrays if some active node operators have no available keys to be deposited\n        if (activeNodeOperatorIndex < activeNodeOperatorsCount) {\n            assembly {\n                mstore(nodeOperatorIds, activeNodeOperatorIndex)\n                mstore(activeKeyCountsAfterAllocation, activeNodeOperatorIndex)\n                mstore(activeKeysCapacities, activeNodeOperatorIndex)\n            }\n        }\n\n        (allocatedKeysCount, activeKeyCountsAfterAllocation) =\n            MinFirstAllocationStrategy.allocate(activeKeyCountsAfterAllocation, activeKeysCapacities, _keysCount);\n\n        /// @dev method NEVER allocates more keys than was requested\n        assert(_keysCount >= allocatedKeysCount);\n    }\n\n    function _loadAllocatedSigningKeys(\n        uint256 _keysCountToLoad,\n        uint256[] memory _nodeOperatorIds,\n        uint256[] memory _activeKeyCountsAfterAllocation\n    ) internal returns (bytes memory pubkeys, bytes memory signatures) {\n        (pubkeys, signatures) = SigningKeys.initKeysSigsBuf(_keysCountToLoad);\n\n        uint256 loadedKeysCount = 0;\n        uint256 depositedSigningKeysCountBefore;\n        uint256 depositedSigningKeysCountAfter;\n        uint256 keysCount;\n        Packed64x4.Packed memory signingKeysStats;\n        for (uint256 i; i < _nodeOperatorIds.length; ++i) {\n            signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorIds[i]);\n            depositedSigningKeysCountBefore = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n            depositedSigningKeysCountAfter =\n                signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET) + _activeKeyCountsAfterAllocation[i];\n\n            if (depositedSigningKeysCountAfter == depositedSigningKeysCountBefore) continue;\n\n            // For gas savings SafeMath.add() wasn't used on depositedSigningKeysCountAfter\n            // calculation, so below we check that operation finished without overflow\n            // In case of overflow:\n            //   depositedSigningKeysCountAfter < signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET)\n            // what violates invariant:\n            //   depositedSigningKeysCount >= exitedSigningKeysCount\n            assert(depositedSigningKeysCountAfter > depositedSigningKeysCountBefore);\n\n            keysCount = depositedSigningKeysCountAfter - depositedSigningKeysCountBefore;\n            SIGNING_KEYS_MAPPING_NAME.loadKeysSigs(\n                _nodeOperatorIds[i], depositedSigningKeysCountBefore, keysCount, pubkeys, signatures, loadedKeysCount\n            );\n            loadedKeysCount += keysCount;\n\n            emit DepositedSigningKeysCountChanged(_nodeOperatorIds[i], depositedSigningKeysCountAfter);\n            signingKeysStats.set(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET, depositedSigningKeysCountAfter);\n            _saveOperatorSigningKeysStats(_nodeOperatorIds[i], signingKeysStats);\n            _updateSummaryMaxValidatorsCount(_nodeOperatorIds[i]);\n        }\n\n        assert(loadedKeysCount == _keysCountToLoad);\n\n        Packed64x4.Packed memory summarySigningKeysStats = _loadSummarySigningKeysStats();\n        summarySigningKeysStats.add(SUMMARY_DEPOSITED_KEYS_COUNT_OFFSET, loadedKeysCount);\n        _saveSummarySigningKeysStats(summarySigningKeysStats);\n    }\n\n    /// @notice Returns the node operator by id\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _fullInfo If true, name will be returned as well\n    function getNodeOperator(uint256 _nodeOperatorId, bool _fullInfo)\n        external\n        view\n        returns (\n            bool active,\n            string name,\n            address rewardAddress,\n            uint64 totalVettedValidators,\n            uint64 totalExitedValidators,\n            uint64 totalAddedValidators,\n            uint64 totalDepositedValidators\n        )\n    {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n\n        NodeOperator storage nodeOperator = _nodeOperators[_nodeOperatorId];\n\n        active = nodeOperator.active;\n        rewardAddress = nodeOperator.rewardAddress;\n        name = _fullInfo ? nodeOperator.name : \"\"; // reading name is 2+ SLOADs\n\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n\n        totalVettedValidators = uint64(signingKeysStats.get(TOTAL_VETTED_KEYS_COUNT_OFFSET));\n        totalExitedValidators = uint64(signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET));\n        totalAddedValidators = uint64(signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET));\n        totalDepositedValidators = uint64(signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET));\n    }\n\n    /// @notice Returns the rewards distribution proportional to the effective stake for each node operator.\n    /// @notice [DEPRECATED] The `penalized` array is no longer relevant and always contains only `false`.\n    /// @param _totalRewardShares Total amount of reward shares to distribute.\n    function getRewardsDistribution(uint256 _totalRewardShares)\n        public\n        view\n        returns (address[] memory recipients, uint256[] memory shares, bool[] memory penalized)\n    {\n        uint256 nodeOperatorCount = getNodeOperatorsCount();\n\n        uint256 activeCount = getActiveNodeOperatorsCount();\n        recipients = new address[](activeCount);\n        shares = new uint256[](activeCount);\n        penalized = new bool[](activeCount);\n        uint256 idx = 0;\n\n        uint256 totalActiveValidatorsCount = 0;\n        Packed64x4.Packed memory signingKeysStats;\n        for (uint256 operatorId; operatorId < nodeOperatorCount; ++operatorId) {\n            if (!getNodeOperatorIsActive(operatorId)) continue;\n\n            signingKeysStats = _loadOperatorSigningKeysStats(operatorId);\n            uint256 totalExitedValidators = signingKeysStats.get(TOTAL_EXITED_KEYS_COUNT_OFFSET);\n            uint256 totalDepositedValidators = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n\n            // validate invariant to not use SafeMath.sub()\n            assert(totalDepositedValidators >= totalExitedValidators);\n            uint256 activeValidatorsCount = totalDepositedValidators - totalExitedValidators;\n\n            // SafeMath.add() isn't used below because the following is always true:\n            // totalActiveValidatorsCount <= MAX_NODE_OPERATORS_COUNT * UINT64_MAX\n            totalActiveValidatorsCount += activeValidatorsCount;\n\n            recipients[idx] = _nodeOperators[operatorId].rewardAddress;\n            // prefill shares array with 'key share' for recipient, see below\n            shares[idx] = activeValidatorsCount;\n\n            // [DEPRECATED] Penalized flag is no longer relevant. Always false.\n            // penalized[idx] = false;\n\n            ++idx;\n        }\n\n        if (totalActiveValidatorsCount == 0) return (recipients, shares, penalized);\n\n        for (idx = 0; idx < activeCount; ++idx) {\n            /// @dev unsafe division used below for gas savings. It's safe in the current case\n            ///     because SafeMath.div() only validates that the divider isn't equal to zero.\n            ///     totalActiveValidatorsCount guaranteed greater than zero.\n            shares[idx] = shares[idx].mul(_totalRewardShares) / totalActiveValidatorsCount;\n        }\n\n        return (recipients, shares, penalized);\n    }\n\n    /// @notice Add `_quantity` validator signing keys to the keys of the node operator #`_nodeOperatorId`. Concatenated keys are: `_pubkeys`\n    /// @dev Along with each key the DAO has to provide a signatures for the\n    ///      (pubkey, withdrawal_credentials, 32000000000) message.\n    ///      Given that information, the contract'll be able to call\n    ///      deposit_contract.deposit on-chain.\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _keysCount Number of signing keys provided\n    /// @param _publicKeys Several concatenated validator signing keys\n    /// @param _signatures Several concatenated signatures for (pubkey, withdrawal_credentials, 32000000000) messages\n    function addSigningKeys(uint256 _nodeOperatorId, uint256 _keysCount, bytes _publicKeys, bytes _signatures) external {\n        _addSigningKeys(_nodeOperatorId, _keysCount, _publicKeys, _signatures);\n    }\n\n    /// @notice Add `_quantity` validator signing keys of operator #`_id` to the set of usable keys. Concatenated keys are: `_pubkeys`. Can be done by node operator in question by using the designated rewards address.\n    /// @dev Along with each key the DAO has to provide a signatures for the\n    ///      (pubkey, withdrawal_credentials, 32000000000) message.\n    ///      Given that information, the contract'll be able to call\n    ///      deposit_contract.deposit on-chain.\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _keysCount Number of signing keys provided\n    /// @param _publicKeys Several concatenated validator signing keys\n    /// @param _signatures Several concatenated signatures for (pubkey, withdrawal_credentials, 32000000000) messages\n    /// @dev DEPRECATED use addSigningKeys instead\n    function addSigningKeysOperatorBH(uint256 _nodeOperatorId, uint256 _keysCount, bytes _publicKeys, bytes _signatures)\n        external\n    {\n        _addSigningKeys(_nodeOperatorId, _keysCount, _publicKeys, _signatures);\n    }\n\n    function _addSigningKeys(uint256 _nodeOperatorId, uint256 _keysCount, bytes _publicKeys, bytes _signatures) internal {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _onlyNodeOperatorManager(msg.sender, _nodeOperatorId);\n\n        _requireValidRange(_keysCount != 0 && _keysCount <= UINT64_MAX);\n\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        uint256 totalSigningKeysCount = signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET);\n\n        _requireValidRange(totalSigningKeysCount.add(_keysCount) <= UINT64_MAX);\n\n        totalSigningKeysCount =\n            SIGNING_KEYS_MAPPING_NAME.saveKeysSigs(_nodeOperatorId, totalSigningKeysCount, _keysCount, _publicKeys, _signatures);\n\n        emit TotalSigningKeysCountChanged(_nodeOperatorId, totalSigningKeysCount);\n\n        signingKeysStats.set(TOTAL_KEYS_COUNT_OFFSET, totalSigningKeysCount);\n        _saveOperatorSigningKeysStats(_nodeOperatorId, signingKeysStats);\n\n        _increaseValidatorsKeysNonce();\n    }\n\n    /// @notice Removes a validator signing key #`_index` from the keys of the node operator #`_nodeOperatorId`\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _index Index of the key, starting with 0\n    /// @dev DEPRECATED use removeSigningKeys instead\n    function removeSigningKey(uint256 _nodeOperatorId, uint256 _index) external {\n        _removeUnusedSigningKeys(_nodeOperatorId, _index, 1);\n    }\n\n    /// @notice Removes an #`_keysCount` of validator signing keys starting from #`_index` of operator #`_id` usable keys. Executed on behalf of DAO.\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _fromIndex Index of the key, starting with 0\n    /// @param _keysCount Number of keys to remove\n    function removeSigningKeys(uint256 _nodeOperatorId, uint256 _fromIndex, uint256 _keysCount) external {\n        _removeUnusedSigningKeys(_nodeOperatorId, _fromIndex, _keysCount);\n    }\n\n    /// @notice Removes a validator signing key #`_index` of operator #`_id` from the set of usable keys. Executed on behalf of Node Operator.\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _index Index of the key, starting with 0\n    /// @dev DEPRECATED use removeSigningKeys instead\n    function removeSigningKeyOperatorBH(uint256 _nodeOperatorId, uint256 _index) external {\n        _removeUnusedSigningKeys(_nodeOperatorId, _index, 1);\n    }\n\n    /// @notice Removes an #`_keysCount` of validator signing keys starting from #`_index` of operator #`_id` usable keys. Executed on behalf of Node Operator.\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _fromIndex Index of the key, starting with 0\n    /// @param _keysCount Number of keys to remove\n    /// @dev DEPRECATED use removeSigningKeys instead\n    function removeSigningKeysOperatorBH(uint256 _nodeOperatorId, uint256 _fromIndex, uint256 _keysCount) external {\n        _removeUnusedSigningKeys(_nodeOperatorId, _fromIndex, _keysCount);\n    }\n\n    /// @notice Returns true if the given validator public key has already been reported as exiting.\n    /// @dev The function hashes the input public key using keccak256 and checks if it exists in the _validatorProcessedLateKeys mapping.\n    /// @param _publicKey The BLS public key of the validator (serialized as bytes).\n    /// @return True if the validator exit for the provided key has been reported, false otherwise.\n    function isValidatorExitingKeyReported(bytes _publicKey) public view returns (bool) {\n        bytes32 processedKeyHash = keccak256(_publicKey);\n        return _validatorProcessedLateKeys[processedKeyHash];\n    }\n\n    /// @notice Returns the number of seconds after which a validator is considered late for specified node operator.\n    /// @dev The operatorId argument is ignored and present only to comply with the IStakingModule interface.\n    /// @return uint256 The exit deadline threshold in seconds for all node operators.\n    function exitDeadlineThreshold(uint256 /* operatorId */) public view returns (uint256) {\n        return _exitDeadlineThreshold();\n    }\n\n    function _exitDeadlineThreshold() internal view returns (uint256) {\n        return Packed64x4.Packed(EXIT_DELAY_STATS.getStorageUint256()).get(EXIT_DELAY_THRESHOLD_OFFSET);\n    }\n\n    /// @notice Returns the Timestamp before which validators reported as late will not result in penalties for their Node Operators..\n    /// @return uint256 The cutoff timestamp used when evaluating late exits.\n    function exitPenaltyCutoffTimestamp() public view returns (uint256) {\n       return Packed64x4.Packed(EXIT_DELAY_STATS.getStorageUint256()).get(EXIT_PENALTY_CUTOFF_TIMESTAMP_OFFSET);\n    }\n\n    /// @notice Sets the validator exit deadline threshold and the reporting window for late exits.\n    /// @dev Updates the cutoff timestamp before which a validator that was requested to exit cannot be reported as late.\n    /// @param _threshold Number of seconds a validator has to exit after becoming eligible.\n    /// @param _lateReportingWindow Additional number of seconds during which a late exit can still be reported.\n    function setExitDeadlineThreshold(uint256 _threshold, uint256 _lateReportingWindow) external {\n        _auth(MANAGE_NODE_OPERATOR_ROLE);\n        _setExitDeadlineThreshold(_threshold, _lateReportingWindow);\n    }\n\n    function _setExitDeadlineThreshold(uint256 _threshold, uint256 _lateReportingWindow) internal {\n        require(_threshold > 0, \"INVALID_EXIT_DELAY_THRESHOLD\");\n\n        // Set the cutoff timestamp to the current time minus the threshold and reportingWindow period\n        uint256 currentCutoffTimestamp = block.timestamp - _threshold - _lateReportingWindow;\n        require(exitPenaltyCutoffTimestamp() <= currentCutoffTimestamp, \"INVALID_EXIT_PENALTY_CUTOFF_TIMESTAMP\");\n\n        Packed64x4.Packed memory stats = Packed64x4.Packed(0);\n        stats.set(EXIT_DELAY_THRESHOLD_OFFSET, _threshold);\n        stats.set(EXIT_PENALTY_CUTOFF_TIMESTAMP_OFFSET, currentCutoffTimestamp);\n        EXIT_DELAY_STATS.setStorageUint256(stats.v);\n\n        emit ExitDeadlineThresholdChanged(_threshold, _lateReportingWindow);\n    }\n\n    /// @notice Handles the triggerable exit event for a validator belonging to a specific node operator.\n    /// @dev This function is called by the StakingRouter when a validator is triggered to exit using the triggerable\n    ///      exit request on the Execution Layer (EL).\n    /// @param _nodeOperatorId The ID of the node operator.\n    /// @param _publicKey The public key of the validator being reported.\n    /// @param _withdrawalRequestPaidFee Fee amount paid to send a withdrawal request on the Execution Layer (EL).\n    /// @param _exitType The type of exit being performed.\n    function onValidatorExitTriggered(\n        uint256 _nodeOperatorId,\n        bytes _publicKey,\n        uint256 _withdrawalRequestPaidFee,\n        uint256 _exitType\n    ) external {\n        _auth(STAKING_ROUTER_ROLE);\n\n        emit ValidatorExitTriggered(_nodeOperatorId, _publicKey, _withdrawalRequestPaidFee, _exitType);\n    }\n\n    /// @notice Determines whether a validator's exit status should be updated and will have an effect on the Node Operator.\n    /// @param _publicKey The public key of the validator.\n    /// @param _proofSlotTimestamp The timestamp (slot time) when the validator was last known to be in an active ongoing state.\n    /// @param _eligibleToExitInSec The number of seconds the validator was eligible to exit but did not.\n    /// @return True if the validator has exceeded the exit deadline threshold and hasn't been reported yet.\n    function isValidatorExitDelayPenaltyApplicable(\n        uint256, // _nodeOperatorId\n        uint256 _proofSlotTimestamp,\n        bytes _publicKey,\n        uint256 _eligibleToExitInSec\n    ) external view returns (bool) {\n        // Check if the key is already reported\n        if (isValidatorExitingKeyReported(_publicKey)) {\n            return false;\n        }\n        return _eligibleToExitInSec >= _exitDeadlineThreshold()\n            && _proofSlotTimestamp - _eligibleToExitInSec >= exitPenaltyCutoffTimestamp();\n    }\n\n    /// @notice Handles tracking and penalization logic for a node operator who failed to exit their validator within the defined exit window.\n    /// @dev This function is called by the StakingRouter to report the current exit-related status of a validator\n    ///      belonging to a specific node operator. It marks the validator as processed to avoid duplicate reports.\n    /// @param _nodeOperatorId The ID of the node operator whose validator's status is being delivered.\n    /// @param _proofSlotTimestamp The timestamp (slot time) when the validator was last known to be in an active ongoing state.\n    /// @param _publicKey The public key of the validator being reported.\n    /// @param _eligibleToExitInSec The duration (in seconds) indicating how long the validator has been eligible to exit after request but has not exited.\n    function reportValidatorExitDelay(\n        uint256 _nodeOperatorId,\n        uint256 _proofSlotTimestamp,\n        bytes _publicKey,\n        uint256 _eligibleToExitInSec\n    ) external {\n        _auth(STAKING_ROUTER_ROLE);\n        require(_publicKey.length == 48, \"INVALID_PUBLIC_KEY\");\n\n        // Check if exit delay exceeds the threshold\n        require(_eligibleToExitInSec >= _exitDeadlineThreshold(), \"EXIT_DELAY_BELOW_THRESHOLD\");\n        // Check if the proof slot timestamp is within the allowed reporting window\n        require(_proofSlotTimestamp - _eligibleToExitInSec >= exitPenaltyCutoffTimestamp(), \"TOO_LATE_FOR_EXIT_DELAY_REPORT\");\n\n        bytes32 processedKeyHash = keccak256(_publicKey);\n        // Skip if key is already processed (i.e., not in NotProcessed state)\n        if (_validatorProcessedLateKeys[processedKeyHash]) {\n            return;\n        }\n        // Mark the validator exit key as processed\n        _validatorProcessedLateKeys[processedKeyHash] = true;\n\n        emit ValidatorExitStatusUpdated(_nodeOperatorId, _publicKey, _eligibleToExitInSec, _proofSlotTimestamp);\n    }\n\n    function _removeUnusedSigningKeys(uint256 _nodeOperatorId, uint256 _fromIndex, uint256 _keysCount) internal {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        _onlyNodeOperatorManager(msg.sender, _nodeOperatorId);\n\n        // preserve the previous behavior of the method here and just return earlier\n        if (_keysCount == 0) return;\n\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        uint256 totalSigningKeysCount = signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET);\n        // comparing _fromIndex.add(_keysCount) <= totalSigningKeysCount is enough as totalSigningKeysCount is always less than UINT64_MAX\n        _requireValidRange(\n            _fromIndex >= signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET)\n                && _fromIndex.add(_keysCount) <= totalSigningKeysCount\n        );\n\n        totalSigningKeysCount =\n            SIGNING_KEYS_MAPPING_NAME.removeKeysSigs(_nodeOperatorId, _fromIndex, _keysCount, totalSigningKeysCount);\n        signingKeysStats.set(TOTAL_KEYS_COUNT_OFFSET, totalSigningKeysCount);\n        emit TotalSigningKeysCountChanged(_nodeOperatorId, totalSigningKeysCount);\n\n        uint256 vettedSigningKeysCount = signingKeysStats.get(TOTAL_VETTED_KEYS_COUNT_OFFSET);\n        if (_fromIndex < vettedSigningKeysCount) {\n            // decreasing the staking limit so the key at _index can't be used anymore\n            signingKeysStats.set(TOTAL_VETTED_KEYS_COUNT_OFFSET, _fromIndex);\n            emit VettedSigningKeysCountChanged(_nodeOperatorId, _fromIndex);\n        }\n        _saveOperatorSigningKeysStats(_nodeOperatorId, signingKeysStats);\n\n        _updateSummaryMaxValidatorsCount(_nodeOperatorId);\n\n        _increaseValidatorsKeysNonce();\n    }\n\n    /// @notice Returns total number of signing keys of the node operator #`_nodeOperatorId`\n    function getTotalSigningKeyCount(uint256 _nodeOperatorId) external view returns (uint256) {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        return signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET);\n    }\n\n    /// @notice Returns number of usable signing keys of the node operator #`_nodeOperatorId`\n    function getUnusedSigningKeyCount(uint256 _nodeOperatorId) external view returns (uint256) {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        return signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET).sub(signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET));\n    }\n\n    /// @notice Returns n-th signing key of the node operator #`_nodeOperatorId`\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _index Index of the key, starting with 0\n    /// @return key Key\n    /// @return depositSignature Signature needed for a deposit_contract.deposit call\n    /// @return used Flag indication if the key was used in the staking\n    function getSigningKey(uint256 _nodeOperatorId, uint256 _index)\n        external\n        view\n        returns (bytes key, bytes depositSignature, bool used)\n    {\n        bool[] memory keyUses;\n        (key, depositSignature, keyUses) = getSigningKeys(_nodeOperatorId, _index, 1);\n        used = keyUses[0];\n    }\n\n    /// @notice Returns n signing keys of the node operator #`_nodeOperatorId`\n    /// @param _nodeOperatorId Node Operator id\n    /// @param _offset Offset of the key, starting with 0\n    /// @param _limit Number of keys to return\n    /// @return pubkeys Keys concatenated into the bytes batch\n    /// @return signatures Signatures concatenated into the bytes batch needed for a deposit_contract.deposit call\n    /// @return used Array of flags indicated if the key was used in the staking\n    function getSigningKeys(uint256 _nodeOperatorId, uint256 _offset, uint256 _limit)\n        public\n        view\n        returns (bytes memory pubkeys, bytes memory signatures, bool[] memory used)\n    {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n\n        Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);\n        _requireValidRange(_offset.add(_limit) <= signingKeysStats.get(TOTAL_KEYS_COUNT_OFFSET));\n\n        uint256 depositedSigningKeysCount = signingKeysStats.get(TOTAL_DEPOSITED_KEYS_COUNT_OFFSET);\n        (pubkeys, signatures) = SigningKeys.initKeysSigsBuf(_limit);\n        used = new bool[](_limit);\n\n        SIGNING_KEYS_MAPPING_NAME.loadKeysSigs(_nodeOperatorId, _offset, _limit, pubkeys, signatures, 0);\n        for (uint256 i; i < _limit; ++i) {\n            used[i] = (_offset + i) < depositedSigningKeysCount;\n        }\n    }\n\n    /// @notice Returns the type of the staking module\n    function getType() external view returns (bytes32) {\n        return TYPE_POSITION.getStorageBytes32();\n    }\n\n    function getStakingModuleSummary()\n        external\n        view\n        returns (uint256 totalExitedValidators, uint256 totalDepositedValidators, uint256 depositableValidatorsCount)\n    {\n        Packed64x4.Packed memory summarySigningKeysStats = _loadSummarySigningKeysStats();\n        totalExitedValidators = summarySigningKeysStats.get(SUMMARY_EXITED_KEYS_COUNT_OFFSET);\n        totalDepositedValidators = summarySigningKeysStats.get(SUMMARY_DEPOSITED_KEYS_COUNT_OFFSET);\n        depositableValidatorsCount = summarySigningKeysStats.get(SUMMARY_MAX_VALIDATORS_COUNT_OFFSET).sub(totalDepositedValidators);\n    }\n\n    function getNodeOperatorSummary(uint256 _nodeOperatorId)\n        external\n        view\n        returns (\n            uint256 targetLimitMode,\n            uint256 targetValidatorsCount,\n            uint256 stuckValidatorsCount,\n            uint256 refundedValidatorsCount,\n            uint256 stuckPenaltyEndTimestamp,\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n    ) {\n        _onlyExistedNodeOperator(_nodeOperatorId);\n\n        Packed64x4.Packed memory operatorTargetStats = _loadOperatorTargetValidatorsStats(_nodeOperatorId);\n\n        targetLimitMode = operatorTargetStats.get(TARGET_LIMIT_MODE_OFFSET);\n        targetValidatorsCount = operatorTargetStats.get(TARGET_VALIDATORS_COUNT_OFFSET);\n        stuckValidatorsCount = 0;\n        refundedValidatorsCount = 0;\n        stuckPenaltyEndTimestamp = 0;\n\n        (totalExitedValidators, totalDepositedValidators, depositableValidatorsCount) =\n            _getNodeOperatorValidatorsSummary(_nodeOperatorId);\n    }\n\n    function _getNodeOperatorValidatorsSummary(uint256 _nodeOperatorId) internal view returns (\n        uint256 totalExitedValidators,\n        uint256 totalDepositedValidators,\n        uint256 depositableValidatorsCount\n    ) {\n        uint256 totalMaxValidators;\n        (totalExitedValidators, totalDepositedValidators, totalMaxValidators) = _getNodeOperator(_nodeOperatorId);\n\n        depositableValidatorsCount = totalMaxValidators - totalDepositedValidators;\n    }\n\n    /// @notice [DEPRECATED] Penalty logic removed. Always returns `false`.\n    /// @dev _nodeOperatorId Ignored.\n    /// @return Always returns `false`.\n    function isOperatorPenalized(uint256 /* _nodeOperatorId */) public pure returns (bool) {\n        return false;\n    }\n\n    /// @notice [DEPRECATED] Penalty logic removed. Always returns `true`.\n    /// @dev _nodeOperatorId Ignored.\n    /// @return Always returns `true`.\n    function isOperatorPenaltyCleared(uint256 /* _nodeOperatorId */) public pure returns (bool) {\n        return true;\n    }\n\n    /// @notice Returns total number of node operators\n    function getNodeOperatorsCount() public view returns (uint256) {\n        return TOTAL_OPERATORS_COUNT_POSITION.getStorageUint256();\n    }\n\n    /// @notice Returns number of active node operators\n    function getActiveNodeOperatorsCount() public view returns (uint256) {\n        return ACTIVE_OPERATORS_COUNT_POSITION.getStorageUint256();\n    }\n\n    /// @notice Returns if the node operator with given id is active\n    function getNodeOperatorIsActive(uint256 _nodeOperatorId) public view returns (bool) {\n        return _nodeOperators[_nodeOperatorId].active;\n    }\n\n    /// @notice Returns up to `_limit` node operator ids starting from the `_offset`.\n    function getNodeOperatorIds(uint256 _offset, uint256 _limit)\n        external\n        view\n        returns (uint256[] memory nodeOperatorIds) {\n        uint256 nodeOperatorsCount = getNodeOperatorsCount();\n        if (_offset >= nodeOperatorsCount || _limit == 0) return;\n        nodeOperatorIds = new uint256[](Math256.min(_limit, nodeOperatorsCount - _offset));\n        for (uint256 i = 0; i < nodeOperatorIds.length; ++i) {\n            nodeOperatorIds[i] = _offset + i;\n        }\n    }\n\n    /// @notice Returns a counter that MUST change it's value when any of the following happens:\n    ///     1. a node operator's deposit data is added\n    ///     2. a node operator's deposit data is removed\n    ///     3. a node operator's ready-to-deposit data size is changed\n    ///     4. a node operator was activated/deactivated\n    ///     5. a node operator's deposit data is used for the deposit\n    function getNonce() external view returns (uint256) {\n        return KEYS_OP_INDEX_POSITION.getStorageUint256();\n    }\n\n    /// @notice Returns a counter that MUST change its value whenever the deposit data set changes.\n    ///     Below is the typical list of actions that requires an update of the nonce:\n    ///     1. a node operator's deposit data is added\n    ///     2. a node operator's deposit data is removed\n    ///     3. a node operator's ready-to-deposit data size is changed\n    ///     4. a node operator was activated/deactivated\n    ///     5. a node operator's deposit data is used for the deposit\n    ///     Note: Depending on the StakingModule implementation above list might be extended\n    /// @dev DEPRECATED use getNonce() instead\n    function getKeysOpIndex() external view returns (uint256) {\n        return KEYS_OP_INDEX_POSITION.getStorageUint256();\n    }\n\n    /// @notice distributes rewards among node operators\n    /// @return the amount of stETH shares distributed among node operators\n    function _distributeRewards() internal returns (uint256 distributed) {\n        IStETH stETH = IStETH(getLocator().lido());\n\n        uint256 sharesToDistribute = stETH.sharesOf(address(this));\n        if (sharesToDistribute == 0) {\n            return;\n        }\n\n        (address[] memory recipients, uint256[] memory shares,) =\n            getRewardsDistribution(sharesToDistribute);\n\n        for (uint256 idx; idx < recipients.length; ++idx) {\n            /// @dev skip ultra-low amounts processing to avoid transfer zero amount in case of a penalty\n            if (shares[idx] < 2) continue;\n            stETH.transferShares(recipients[idx], shares[idx]);\n            distributed = distributed.add(shares[idx]);\n            emit RewardsDistributed(recipients[idx], shares[idx]);\n        }\n    }\n\n    function getLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /// @notice [DEPRECATED] Stuck penalty delay logic removed. Always returns 0.\n    /// @return Always returns 0.\n    function getStuckPenaltyDelay() public pure returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Get the current reward distribution state, anyone can monitor this state\n    /// and distribute reward (call distributeReward method) among operators when it's `ReadyForDistribution`\n    function getRewardDistributionState() public view returns (RewardDistributionState) {\n        uint256 state = REWARD_DISTRIBUTION_STATE.getStorageUint256();\n        return RewardDistributionState(state);\n    }\n\n    function _updateRewardDistributionState(RewardDistributionState _state) internal {\n        REWARD_DISTRIBUTION_STATE.setStorageUint256(uint256(_state));\n        emit RewardDistributionStateChanged(_state);\n    }\n\n    function _increaseValidatorsKeysNonce() internal {\n        uint256 keysOpIndex = KEYS_OP_INDEX_POSITION.getStorageUint256() + 1;\n        KEYS_OP_INDEX_POSITION.setStorageUint256(keysOpIndex);\n        /// @dev [DEPRECATED] event preserved for tooling compatibility\n        emit KeysOpIndexSet(keysOpIndex);\n        emit NonceChanged(keysOpIndex);\n    }\n\n    function _loadSummarySigningKeysStats() internal view returns (Packed64x4.Packed memory) {\n        return _nodeOperatorSummary.summarySigningKeysStats;\n    }\n\n    function _saveSummarySigningKeysStats(Packed64x4.Packed memory _val) internal {\n        _nodeOperatorSummary.summarySigningKeysStats = _val;\n    }\n\n    function _loadOperatorTargetValidatorsStats(uint256 _nodeOperatorId) internal view returns (Packed64x4.Packed memory) {\n        return _nodeOperators[_nodeOperatorId].targetValidatorsStats;\n    }\n\n    function _saveOperatorTargetValidatorsStats(uint256 _nodeOperatorId, Packed64x4.Packed memory _val) internal {\n        _nodeOperators[_nodeOperatorId].targetValidatorsStats = _val;\n    }\n\n\n    function _loadOperatorSigningKeysStats(uint256 _nodeOperatorId) internal view returns (Packed64x4.Packed memory) {\n        return _nodeOperators[_nodeOperatorId].signingKeysStats;\n    }\n\n    function _saveOperatorSigningKeysStats(uint256 _nodeOperatorId, Packed64x4.Packed memory _val) internal {\n        _nodeOperators[_nodeOperatorId].signingKeysStats = _val;\n    }\n\n    function _requireAuth(bool _pass) internal pure {\n        require(_pass, \"APP_AUTH_FAILED\");\n    }\n\n    function _requireNotSameValue(bool _pass) internal pure {\n        require(_pass, \"VALUE_IS_THE_SAME\");\n    }\n\n    function _requireValidRange(bool _pass) internal pure {\n        require(_pass, \"OUT_OF_RANGE\");\n    }\n\n    function _onlyCorrectNodeOperatorState(bool _pass) internal pure {\n        require(_pass, \"WRONG_OPERATOR_ACTIVE_STATE\");\n    }\n\n    function _auth(bytes32 _role) internal view {\n        _requireAuth(canPerform(msg.sender, _role, new uint256[](0)));\n    }\n\n    function _authP(bytes32 _role, uint256[] _params) internal view {\n        _requireAuth(canPerform(msg.sender, _role, _params));\n    }\n\n    function _onlyNodeOperatorManager(address _sender, uint256 _nodeOperatorId) internal view {\n        bool isRewardAddress = _sender == _nodeOperators[_nodeOperatorId].rewardAddress;\n        bool isActive = _nodeOperators[_nodeOperatorId].active;\n        _requireAuth((isRewardAddress && isActive) || canPerform(_sender, MANAGE_SIGNING_KEYS, arr(_nodeOperatorId)));\n    }\n\n    function _onlyExistedNodeOperator(uint256 _nodeOperatorId) internal view {\n        _requireValidRange(_nodeOperatorId < getNodeOperatorsCount());\n    }\n\n    function _onlyValidNodeOperatorName(string _name) internal pure {\n        require(bytes(_name).length > 0 && bytes(_name).length <= MAX_NODE_OPERATOR_NAME_LENGTH, \"WRONG_NAME_LENGTH\");\n    }\n\n    function _onlyValidRewardAddress(address _rewardAddress) internal view {\n        _onlyNonZeroAddress(_rewardAddress);\n        // The Lido address is forbidden explicitly because stETH transfers on this contract will revert\n        // See onExitedAndStuckValidatorsCountsUpdated() and StETH._transferShares() for details\n        require(_rewardAddress != getLocator().lido(), \"LIDO_REWARD_ADDRESS\");\n    }\n\n    function _onlyNonZeroAddress(address _a) internal pure {\n        require(_a != address(0), \"ZERO_ADDRESS\");\n    }\n}\n"
    }
}