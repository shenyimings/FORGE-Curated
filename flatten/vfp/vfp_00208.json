{
    "vfp_id": "vfp_00208",
    "project_name": "ackee-blockchain-lido-triggerable-withdrawals-report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "Unimplemented function called",
            "description": "The contract calls a function that is declared but not implemented, which could lead to a revert or unexpected behavior when invoked.\nThe root cause is a missing implementation for a referenced interface function, likely due to incomplete integration or oversight during development.\nAn attacker could trigger this by calling the affected function path, leading to a failed transaction or disruption in expected workflow.\nThe impact is classified as Warning because the issue cannot be exploited under current configuration, but it poses a risk if the function is later implemented or called unintentionally.\nSpecifically, the StakingRouter.updateRefundedValidatorsCount function calls the NodeOperatorsRegistry.updateRefundedValidatorsCount function, which is not implemented in the target contract. This occurs because the NodeOperatorsRegistry contract fails to implement the IStakingModule interface method despite the external call expecting its existence. As a result, any call to updateRefundedValidatorsCount in StakingRouter will cause the transaction to revert. An attacker could potentially trigger such a call if they have the appropriate role, leading to a failed transaction and disruption in validator refund accounting. The impact is functional disruption in a critical staking management function, although it does not directly lead to fund loss.\n",
            "severity": "Informational",
            "location": [
                "StakingRouter.sol::updateRefundedValidatorsCount#373-381",
                "NodeOperatorsRegistry.sol"
            ],
            "files": [
                "core/contracts/0.8.9/StakingRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "StakingRouter.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport {AccessControlEnumerable} from \"./utils/access/AccessControlEnumerable.sol\";\n\nimport {IStakingModule} from \"./interfaces/IStakingModule.sol\";\n\nimport {Math256} from \"../common/lib/Math256.sol\";\nimport {UnstructuredStorage} from \"./lib/UnstructuredStorage.sol\";\nimport {MinFirstAllocationStrategy} from \"../common/lib/MinFirstAllocationStrategy.sol\";\n\nimport {BeaconChainDepositor} from \"./BeaconChainDepositor.sol\";\nimport {Versioned} from \"./utils/Versioned.sol\";\n\ncontract StakingRouter is AccessControlEnumerable, BeaconChainDepositor, Versioned {\n    using UnstructuredStorage for bytes32;\n\n    /// @dev Events\n    event StakingModuleAdded(uint256 indexed stakingModuleId, address stakingModule, string name, address createdBy);\n    event StakingModuleShareLimitSet(uint256 indexed stakingModuleId, uint256 stakeShareLimit, uint256 priorityExitShareThreshold, address setBy);\n    event StakingModuleFeesSet(uint256 indexed stakingModuleId, uint256 stakingModuleFee, uint256 treasuryFee, address setBy);\n    event StakingModuleStatusSet(uint256 indexed stakingModuleId, StakingModuleStatus status, address setBy);\n    event StakingModuleExitedValidatorsIncompleteReporting(uint256 indexed stakingModuleId, uint256 unreportedExitedValidatorsCount);\n    event StakingModuleMaxDepositsPerBlockSet(\n        uint256 indexed stakingModuleId, uint256 maxDepositsPerBlock, address setBy\n    );\n    event StakingModuleMinDepositBlockDistanceSet(\n        uint256 indexed stakingModuleId, uint256 minDepositBlockDistance, address setBy\n    );\n    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials, address setBy);\n    event WithdrawalsCredentialsChangeFailed(uint256 indexed stakingModuleId, bytes lowLevelRevertData);\n    event ExitedAndStuckValidatorsCountsUpdateFailed(uint256 indexed stakingModuleId, bytes lowLevelRevertData);\n    event RewardsMintedReportFailed(uint256 indexed stakingModuleId, bytes lowLevelRevertData);\n\n    /// Emitted when the StakingRouter received ETH\n    event StakingRouterETHDeposited(uint256 indexed stakingModuleId, uint256 amount);\n\n    event StakingModuleExitNotificationFailed(\n        uint256 indexed stakingModuleId,\n        uint256 indexed nodeOperatorId,\n        bytes _publicKey\n    );\n\n    /// @dev Errors\n    error ZeroAddressLido();\n    error ZeroAddressAdmin();\n    error ZeroAddressStakingModule();\n    error InvalidStakeShareLimit();\n    error InvalidFeeSum();\n    error StakingModuleNotActive();\n    error EmptyWithdrawalsCredentials();\n    error DirectETHTransfer();\n    error InvalidReportData(uint256 code);\n    error ExitedValidatorsCountCannotDecrease();\n    error ReportedExitedValidatorsExceedDeposited(\n        uint256 reportedExitedValidatorsCount,\n        uint256 depositedValidatorsCount\n    );\n    error StakingModulesLimitExceeded();\n    error StakingModuleUnregistered();\n    error AppAuthLidoFailed();\n    error StakingModuleStatusTheSame();\n    error StakingModuleWrongName();\n    error UnexpectedCurrentValidatorsCount(\n        uint256 currentModuleExitedValidatorsCount,\n        uint256 currentNodeOpExitedValidatorsCount\n    );\n    error UnexpectedFinalExitedValidatorsCount (\n        uint256 newModuleTotalExitedValidatorsCount,\n        uint256 newModuleTotalExitedValidatorsCountInStakingRouter\n    );\n    error InvalidDepositsValue(uint256 etherValue, uint256 depositsCount);\n    error StakingModuleAddressExists();\n    error ArraysLengthMismatch(uint256 firstArrayLength, uint256 secondArrayLength);\n    error UnrecoverableModuleError();\n    error InvalidPriorityExitShareThreshold();\n    error InvalidMinDepositBlockDistance();\n    error InvalidMaxDepositPerBlockValue();\n\n    enum StakingModuleStatus {\n        Active, // deposits and rewards allowed\n        DepositsPaused, // deposits NOT allowed, rewards allowed\n        Stopped // deposits and rewards NOT allowed\n    }\n\n    struct StakingModule {\n        /// @notice Unique id of the staking module.\n        uint24 id;\n        /// @notice Address of the staking module.\n        address stakingModuleAddress;\n        /// @notice Part of the fee taken from staking rewards that goes to the staking module.\n        uint16 stakingModuleFee;\n        /// @notice Part of the fee taken from staking rewards that goes to the treasury.\n        uint16 treasuryFee;\n        /// @notice Maximum stake share that can be allocated to a module, in BP.\n        /// @dev Formerly known as `targetShare`.\n        uint16 stakeShareLimit;\n        /// @notice Staking module status if staking module can not accept the deposits or can\n        /// participate in further reward distribution.\n        uint8 status;\n        /// @notice Name of the staking module.\n        string name;\n        /// @notice block.timestamp of the last deposit of the staking module.\n        /// @dev NB: lastDepositAt gets updated even if the deposit value was 0 and no actual deposit happened.\n        uint64 lastDepositAt;\n        /// @notice block.number of the last deposit of the staking module.\n        /// @dev NB: lastDepositBlock gets updated even if the deposit value was 0 and no actual deposit happened.\n        uint256 lastDepositBlock;\n        /// @notice Number of exited validators.\n        uint256 exitedValidatorsCount;\n        /// @notice Module's share threshold, upon crossing which, exits of validators from the module will be prioritized, in BP.\n        uint16 priorityExitShareThreshold;\n        /// @notice The maximum number of validators that can be deposited in a single block.\n        /// @dev Must be harmonized with `OracleReportSanityChecker.appearedValidatorsPerDayLimit`.\n        /// See docs for the `OracleReportSanityChecker.setAppearedValidatorsPerDayLimit` function.\n        uint64 maxDepositsPerBlock;\n        /// @notice The minimum distance between deposits in blocks.\n        /// @dev Must be harmonized with `OracleReportSanityChecker.appearedValidatorsPerDayLimit`.\n        /// See docs for the `OracleReportSanityChecker.setAppearedValidatorsPerDayLimit` function).\n        uint64 minDepositBlockDistance;\n    }\n\n    struct StakingModuleCache {\n        address stakingModuleAddress;\n        uint24 stakingModuleId;\n        uint16 stakingModuleFee;\n        uint16 treasuryFee;\n        uint16 stakeShareLimit;\n        StakingModuleStatus status;\n        uint256 activeValidatorsCount;\n        uint256 availableValidatorsCount;\n    }\n\n    struct ValidatorExitData {\n        uint256 stakingModuleId;\n        uint256 nodeOperatorId;\n        bytes pubkey;\n    }\n\n    bytes32 public constant MANAGE_WITHDRAWAL_CREDENTIALS_ROLE = keccak256(\"MANAGE_WITHDRAWAL_CREDENTIALS_ROLE\");\n    bytes32 public constant STAKING_MODULE_MANAGE_ROLE = keccak256(\"STAKING_MODULE_MANAGE_ROLE\");\n    bytes32 public constant STAKING_MODULE_UNVETTING_ROLE = keccak256(\"STAKING_MODULE_UNVETTING_ROLE\");\n    bytes32 public constant REPORT_EXITED_VALIDATORS_ROLE = keccak256(\"REPORT_EXITED_VALIDATORS_ROLE\");\n    bytes32 public constant REPORT_VALIDATOR_EXITING_STATUS_ROLE = keccak256(\"REPORT_VALIDATOR_EXITING_STATUS_ROLE\");\n    bytes32 public constant REPORT_VALIDATOR_EXIT_TRIGGERED_ROLE = keccak256(\"REPORT_VALIDATOR_EXIT_TRIGGERED_ROLE\");\n    bytes32 public constant UNSAFE_SET_EXITED_VALIDATORS_ROLE = keccak256(\"UNSAFE_SET_EXITED_VALIDATORS_ROLE\");\n    bytes32 public constant REPORT_REWARDS_MINTED_ROLE = keccak256(\"REPORT_REWARDS_MINTED_ROLE\");\n\n    bytes32 internal constant LIDO_POSITION = keccak256(\"lido.StakingRouter.lido\");\n\n    /// @dev Credentials to withdraw ETH on Consensus Layer side.\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_POSITION = keccak256(\"lido.StakingRouter.withdrawalCredentials\");\n\n    /// @dev Total count of staking modules.\n    bytes32 internal constant STAKING_MODULES_COUNT_POSITION = keccak256(\"lido.StakingRouter.stakingModulesCount\");\n    /// @dev Id of the last added staking module. This counter grow on staking modules adding.\n    bytes32 internal constant LAST_STAKING_MODULE_ID_POSITION = keccak256(\"lido.StakingRouter.lastStakingModuleId\");\n    /// @dev Mapping is used instead of array to allow to extend the StakingModule.\n    bytes32 internal constant STAKING_MODULES_MAPPING_POSITION = keccak256(\"lido.StakingRouter.stakingModules\");\n    /// @dev Position of the staking modules in the `_stakingModules` map, plus 1 because\n    /// index 0 means a value is not in the set.\n    bytes32 internal constant STAKING_MODULE_INDICES_MAPPING_POSITION = keccak256(\"lido.StakingRouter.stakingModuleIndicesOneBased\");\n\n    uint256 public constant FEE_PRECISION_POINTS = 10 ** 20; // 100 * 10 ** 18\n    uint256 public constant TOTAL_BASIS_POINTS = 10000;\n    uint256 public constant MAX_STAKING_MODULES_COUNT = 32;\n    /// @dev Restrict the name size with 31 bytes to storage in a single slot.\n    uint256 public constant MAX_STAKING_MODULE_NAME_LENGTH = 31;\n\n    constructor(address _depositContract) BeaconChainDepositor(_depositContract) {}\n\n    /// @notice Initializes the contract.\n    /// @param _admin Lido DAO Aragon agent contract address.\n    /// @param _lido Lido address.\n    /// @param _withdrawalCredentials Credentials to withdraw ETH on Consensus Layer side.\n    /// @dev Proxy initialization method.\n    function initialize(address _admin, address _lido, bytes32 _withdrawalCredentials) external {\n        if (_admin == address(0)) revert ZeroAddressAdmin();\n        if (_lido == address(0)) revert ZeroAddressLido();\n\n        _initializeContractVersionTo(3);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n\n        LIDO_POSITION.setStorageAddress(_lido);\n        WITHDRAWAL_CREDENTIALS_POSITION.setStorageBytes32(_withdrawalCredentials);\n        emit WithdrawalCredentialsSet(_withdrawalCredentials, msg.sender);\n    }\n\n    /// @dev Prohibit direct transfer to contract.\n    receive() external payable {\n        revert DirectETHTransfer();\n    }\n\n    /// @notice A function to finalize upgrade to v2 (from v1). Removed and no longer used.\n    /// @dev https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n    /// See historical usage in commit: https://github.com/lidofinance/core/blob/c19480aa3366b26aa6eac17f85a6efae8b9f4f72/contracts/0.8.9/StakingRouter.sol#L190\n    // function finalizeUpgrade_v2(\n    //     uint256[] memory _priorityExitShareThresholds,\n    //     uint256[] memory _maxDepositsPerBlock,\n    //     uint256[] memory _minDepositBlockDistances\n    // ) external\n\n    /// @notice Finalizes upgrade to v3 (from v2). Can be called only once.\n    function finalizeUpgrade_v3() external {\n        _checkContractVersion(2);\n        _updateContractVersion(3);\n    }\n\n    /// @notice Returns Lido contract address.\n    /// @return Lido contract address.\n    function getLido() public view returns (address) {\n        return LIDO_POSITION.getStorageAddress();\n    }\n\n    /// @notice Registers a new staking module.\n    /// @param _name Name of staking module.\n    /// @param _stakingModuleAddress Address of staking module.\n    /// @param _stakeShareLimit Maximum share that can be allocated to a module.\n    /// @param _priorityExitShareThreshold Module's priority exit share threshold.\n    /// @param _stakingModuleFee Fee of the staking module taken from the staking rewards.\n    /// @param _treasuryFee Treasury fee.\n    /// @param _maxDepositsPerBlock The maximum number of validators that can be deposited in a single block.\n    /// @param _minDepositBlockDistance The minimum distance between deposits in blocks.\n    /// @dev The function is restricted to the `STAKING_MODULE_MANAGE_ROLE` role.\n    function addStakingModule(\n        string calldata _name,\n        address _stakingModuleAddress,\n        uint256 _stakeShareLimit,\n        uint256 _priorityExitShareThreshold,\n        uint256 _stakingModuleFee,\n        uint256 _treasuryFee,\n        uint256 _maxDepositsPerBlock,\n        uint256 _minDepositBlockDistance\n    ) external onlyRole(STAKING_MODULE_MANAGE_ROLE) {\n        if (_stakingModuleAddress == address(0)) revert ZeroAddressStakingModule();\n        if (bytes(_name).length == 0 || bytes(_name).length > MAX_STAKING_MODULE_NAME_LENGTH) revert StakingModuleWrongName();\n\n        uint256 newStakingModuleIndex = getStakingModulesCount();\n\n        if (newStakingModuleIndex >= MAX_STAKING_MODULES_COUNT)\n            revert StakingModulesLimitExceeded();\n\n        for (uint256 i; i < newStakingModuleIndex; ) {\n            if (_stakingModuleAddress == _getStakingModuleByIndex(i).stakingModuleAddress)\n                revert StakingModuleAddressExists();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        StakingModule storage newStakingModule = _getStakingModuleByIndex(newStakingModuleIndex);\n        uint24 newStakingModuleId = uint24(LAST_STAKING_MODULE_ID_POSITION.getStorageUint256()) + 1;\n\n        newStakingModule.id = newStakingModuleId;\n        newStakingModule.name = _name;\n        newStakingModule.stakingModuleAddress = _stakingModuleAddress;\n        /// @dev Since `enum` is `uint8` by nature, so the `status` is stored as `uint8` to avoid\n        ///      possible problems when upgrading. But for human readability, we use `enum` as\n        ///      function parameter type. More about conversion in the docs:\n        ///      https://docs.soliditylang.org/en/v0.8.17/types.html#enums\n        newStakingModule.status = uint8(StakingModuleStatus.Active);\n\n        /// @dev Simulate zero value deposit to prevent real deposits into the new StakingModule via\n        ///      DepositSecurityModule just after the addition.\n        _updateModuleLastDepositState(newStakingModule, newStakingModuleId, 0);\n\n        _setStakingModuleIndexById(newStakingModuleId, newStakingModuleIndex);\n        LAST_STAKING_MODULE_ID_POSITION.setStorageUint256(newStakingModuleId);\n        STAKING_MODULES_COUNT_POSITION.setStorageUint256(newStakingModuleIndex + 1);\n\n        emit StakingModuleAdded(newStakingModuleId, _stakingModuleAddress, _name, msg.sender);\n        _updateStakingModule(\n            newStakingModule,\n            newStakingModuleId,\n            _stakeShareLimit,\n            _priorityExitShareThreshold,\n            _stakingModuleFee,\n            _treasuryFee,\n            _maxDepositsPerBlock,\n            _minDepositBlockDistance\n        );\n    }\n\n    /// @notice Updates staking module params.\n    /// @param _stakingModuleId Staking module id.\n    /// @param _stakeShareLimit Target total stake share.\n    /// @param _priorityExitShareThreshold Module's priority exit share threshold.\n    /// @param _stakingModuleFee Fee of the staking module taken from the staking rewards.\n    /// @param _treasuryFee Treasury fee.\n    /// @param _maxDepositsPerBlock The maximum number of validators that can be deposited in a single block.\n    /// @param _minDepositBlockDistance The minimum distance between deposits in blocks.\n    /// @dev The function is restricted to the `STAKING_MODULE_MANAGE_ROLE` role.\n    function updateStakingModule(\n        uint256 _stakingModuleId,\n        uint256 _stakeShareLimit,\n        uint256 _priorityExitShareThreshold,\n        uint256 _stakingModuleFee,\n        uint256 _treasuryFee,\n        uint256 _maxDepositsPerBlock,\n        uint256 _minDepositBlockDistance\n    ) external onlyRole(STAKING_MODULE_MANAGE_ROLE) {\n        StakingModule storage stakingModule = _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId));\n        _updateStakingModule(\n            stakingModule,\n            _stakingModuleId,\n            _stakeShareLimit,\n            _priorityExitShareThreshold,\n            _stakingModuleFee,\n            _treasuryFee,\n            _maxDepositsPerBlock,\n            _minDepositBlockDistance\n        );\n    }\n\n    function _updateStakingModule(\n        StakingModule storage stakingModule,\n        uint256 _stakingModuleId,\n        uint256 _stakeShareLimit,\n        uint256 _priorityExitShareThreshold,\n        uint256 _stakingModuleFee,\n        uint256 _treasuryFee,\n        uint256 _maxDepositsPerBlock,\n        uint256 _minDepositBlockDistance\n    ) internal {\n        if (_stakeShareLimit > TOTAL_BASIS_POINTS) revert InvalidStakeShareLimit();\n        if (_priorityExitShareThreshold > TOTAL_BASIS_POINTS) revert InvalidPriorityExitShareThreshold();\n        if (_stakeShareLimit > _priorityExitShareThreshold) revert InvalidPriorityExitShareThreshold();\n        if (_stakingModuleFee + _treasuryFee > TOTAL_BASIS_POINTS) revert InvalidFeeSum();\n        if (_minDepositBlockDistance == 0 || _minDepositBlockDistance > type(uint64).max) revert InvalidMinDepositBlockDistance();\n        if (_maxDepositsPerBlock > type(uint64).max) revert InvalidMaxDepositPerBlockValue();\n\n        stakingModule.stakeShareLimit = uint16(_stakeShareLimit);\n        stakingModule.priorityExitShareThreshold = uint16(_priorityExitShareThreshold);\n        stakingModule.treasuryFee = uint16(_treasuryFee);\n        stakingModule.stakingModuleFee = uint16(_stakingModuleFee);\n        stakingModule.maxDepositsPerBlock = uint64(_maxDepositsPerBlock);\n        stakingModule.minDepositBlockDistance = uint64(_minDepositBlockDistance);\n\n        emit StakingModuleShareLimitSet(_stakingModuleId, _stakeShareLimit, _priorityExitShareThreshold, msg.sender);\n        emit StakingModuleFeesSet(_stakingModuleId, _stakingModuleFee, _treasuryFee, msg.sender);\n        emit StakingModuleMaxDepositsPerBlockSet(_stakingModuleId, _maxDepositsPerBlock, msg.sender);\n        emit StakingModuleMinDepositBlockDistanceSet(_stakingModuleId, _minDepositBlockDistance, msg.sender);\n    }\n\n    /// @notice Updates the limit of the validators that can be used for deposit.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @param _nodeOperatorId Id of the node operator.\n    /// @param _targetLimitMode Target limit mode.\n    /// @param _targetLimit Target limit of the node operator.\n    /// @dev The function is restricted to the `STAKING_MODULE_MANAGE_ROLE` role.\n    function updateTargetValidatorsLimits(\n        uint256 _stakingModuleId,\n        uint256 _nodeOperatorId,\n        uint256 _targetLimitMode,\n        uint256 _targetLimit\n    ) external onlyRole(STAKING_MODULE_MANAGE_ROLE) {\n        _getIStakingModuleById(_stakingModuleId).updateTargetValidatorsLimits(\n            _nodeOperatorId, _targetLimitMode, _targetLimit\n        );\n    }\n\n    /// @notice Updates the number of the refunded validators in the staking module with the given\n    /// node operator id.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @param _nodeOperatorId Id of the node operator.\n    /// @param _refundedValidatorsCount New number of refunded validators of the node operator.\n    /// @dev The function is restricted to the `STAKING_MODULE_MANAGE_ROLE` role.\n    function updateRefundedValidatorsCount(\n        uint256 _stakingModuleId,\n        uint256 _nodeOperatorId,\n        uint256 _refundedValidatorsCount\n    ) external onlyRole(STAKING_MODULE_MANAGE_ROLE) {\n        _getIStakingModuleById(_stakingModuleId).updateRefundedValidatorsCount(\n            _nodeOperatorId, _refundedValidatorsCount\n        );\n    }\n\n    /// @notice Reports the minted rewards to the staking modules with the specified ids.\n    /// @param _stakingModuleIds Ids of the staking modules.\n    /// @param _totalShares Total shares minted for the staking modules.\n    /// @dev The function is restricted to the `REPORT_REWARDS_MINTED_ROLE` role.\n    function reportRewardsMinted(uint256[] calldata _stakingModuleIds, uint256[] calldata _totalShares)\n        external\n        onlyRole(REPORT_REWARDS_MINTED_ROLE)\n    {\n        _validateEqualArrayLengths(_stakingModuleIds.length, _totalShares.length);\n\n        for (uint256 i = 0; i < _stakingModuleIds.length; ) {\n            if (_totalShares[i] > 0) {\n                try _getIStakingModuleById(_stakingModuleIds[i]).onRewardsMinted(_totalShares[i]) {}\n                catch (bytes memory lowLevelRevertData) {\n                    /// @dev This check is required to prevent incorrect gas estimation of the method.\n                    ///      Without it, Ethereum nodes that use binary search for gas estimation may\n                    ///      return an invalid value when the onRewardsMinted() reverts because of the\n                    ///      \"out of gas\" error. Here we assume that the onRewardsMinted() method doesn't\n                    ///      have reverts with empty error data except \"out of gas\".\n                    if (lowLevelRevertData.length == 0) revert UnrecoverableModuleError();\n                    emit RewardsMintedReportFailed(\n                        _stakingModuleIds[i],\n                        lowLevelRevertData\n                    );\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Updates total numbers of exited validators for staking modules with the specified module ids.\n    /// @param _stakingModuleIds Ids of the staking modules to be updated.\n    /// @param _exitedValidatorsCounts New counts of exited validators for the specified staking modules.\n    /// @return The total increase in the aggregate number of exited validators across all updated modules.\n    ///\n    /// @dev The total numbers are stored in the staking router and can differ from the totals obtained by calling\n    /// `IStakingModule.getStakingModuleSummary()`. The overall process of updating validator counts is the following:\n    ///\n    /// 1. In the first data submission phase, the oracle calls `updateExitedValidatorsCountByStakingModule` on the\n    ///    staking router, passing the totals by module. The staking router stores these totals and uses them to\n    ///    distribute new stake and staking fees between the modules. There can only be single call of this function\n    ///    per oracle reporting frame.\n    ///\n    /// 2. In the second part of the second data submission phase, the oracle calls\n    ///    `StakingRouter.reportStakingModuleExitedValidatorsCountByNodeOperator` on the staking router which passes\n    ///    the counts by node operator to the staking module by calling `IStakingModule.updateExitedValidatorsCount`.\n    ///    This can be done multiple times for the same module, passing data for different subsets of node\n    ///    operators.\n    ///\n    /// 3. At the end of the second data submission phase, it's expected for the aggregate exited validators count\n    ///    across all module's node operators (stored in the module) to match the total count for this module\n    ///    (stored in the staking router). However, it might happen that the second phase of data submission doesn't\n    ///    finish until the new oracle reporting frame is started, in which case staking router will emit a warning\n    ///    event `StakingModuleExitedValidatorsIncompleteReporting` when the first data submission phase is performed\n    ///    for a new reporting frame. This condition will result in the staking module having an incomplete data about\n    ///    the exited validator counts during the whole reporting frame. Handling this condition is\n    ///    the responsibility of each staking module.\n    ///\n    /// 4. When the second reporting phase is finished, i.e. when the oracle submitted the complete data on the exited\n    ///    validator counts per node operator for the current reporting frame, the oracle calls\n    ///    `StakingRouter.onValidatorsCountsByNodeOperatorReportingFinished` which, in turn, calls\n    ///    `IStakingModule.onExitedAndStuckValidatorsCountsUpdated` on all modules.\n    ///\n    /// @dev The function is restricted to the `REPORT_EXITED_VALIDATORS_ROLE` role.\n    function updateExitedValidatorsCountByStakingModule(\n        uint256[] calldata _stakingModuleIds,\n        uint256[] calldata _exitedValidatorsCounts\n    )\n        external\n        onlyRole(REPORT_EXITED_VALIDATORS_ROLE)\n        returns (uint256)\n    {\n        _validateEqualArrayLengths(_stakingModuleIds.length, _exitedValidatorsCounts.length);\n\n        uint256 newlyExitedValidatorsCount;\n\n        for (uint256 i = 0; i < _stakingModuleIds.length; ) {\n            uint256 stakingModuleId = _stakingModuleIds[i];\n            StakingModule storage stakingModule = _getStakingModuleByIndex(_getStakingModuleIndexById(stakingModuleId));\n\n            uint256 prevReportedExitedValidatorsCount = stakingModule.exitedValidatorsCount;\n            if (_exitedValidatorsCounts[i] < prevReportedExitedValidatorsCount) {\n                revert ExitedValidatorsCountCannotDecrease();\n            }\n\n            (\n                uint256 totalExitedValidators,\n                uint256 totalDepositedValidators,\n                /* uint256 depositableValidatorsCount */\n            ) = _getStakingModuleSummary(IStakingModule(stakingModule.stakingModuleAddress));\n\n            if (_exitedValidatorsCounts[i] > totalDepositedValidators) {\n                revert ReportedExitedValidatorsExceedDeposited(\n                    _exitedValidatorsCounts[i],\n                    totalDepositedValidators\n                );\n            }\n\n            newlyExitedValidatorsCount += _exitedValidatorsCounts[i] - prevReportedExitedValidatorsCount;\n\n            if (totalExitedValidators < prevReportedExitedValidatorsCount) {\n                // not all of the exited validators were async reported to the module\n                emit StakingModuleExitedValidatorsIncompleteReporting(\n                    stakingModuleId,\n                    prevReportedExitedValidatorsCount - totalExitedValidators\n                );\n            }\n\n            stakingModule.exitedValidatorsCount = _exitedValidatorsCounts[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return newlyExitedValidatorsCount;\n    }\n\n    /// @notice Updates exited validators counts per node operator for the staking module with\n    /// the specified id. See the docs for `updateExitedValidatorsCountByStakingModule` for the\n    /// description of the overall update process.\n    ///\n    /// @param _stakingModuleId The id of the staking modules to be updated.\n    /// @param _nodeOperatorIds Ids of the node operators to be updated.\n    /// @param _exitedValidatorsCounts New counts of exited validators for the specified node operators.\n    ///\n    /// @dev The function is restricted to the `REPORT_EXITED_VALIDATORS_ROLE` role.\n    function reportStakingModuleExitedValidatorsCountByNodeOperator(\n        uint256 _stakingModuleId,\n        bytes calldata _nodeOperatorIds,\n        bytes calldata _exitedValidatorsCounts\n    )\n        external\n        onlyRole(REPORT_EXITED_VALIDATORS_ROLE)\n    {\n        _checkValidatorsByNodeOperatorReportData(_nodeOperatorIds, _exitedValidatorsCounts);\n        _getIStakingModuleById(_stakingModuleId).updateExitedValidatorsCount(_nodeOperatorIds, _exitedValidatorsCounts);\n    }\n\n    struct ValidatorsCountsCorrection {\n        /// @notice The expected current number of exited validators of the module that is\n        /// being corrected.\n        uint256 currentModuleExitedValidatorsCount;\n        /// @notice The expected current number of exited validators of the node operator\n        /// that is being corrected.\n        uint256 currentNodeOperatorExitedValidatorsCount;\n        /// @notice The corrected number of exited validators of the module.\n        uint256 newModuleExitedValidatorsCount;\n        /// @notice The corrected number of exited validators of the node operator.\n        uint256 newNodeOperatorExitedValidatorsCount;\n    }\n\n    /// @notice Sets exited validators count for the given module and given node operator in that module\n    /// without performing critical safety checks, e.g. that exited validators count cannot decrease.\n    ///\n    /// Should only be used by the DAO in extreme cases and with sufficient precautions to correct invalid\n    /// data reported by the oracle committee due to a bug in the oracle daemon.\n    ///\n    /// @param _stakingModuleId Id of the staking module.\n    /// @param _nodeOperatorId Id of the node operator.\n    /// @param _triggerUpdateFinish Whether to call `onExitedAndStuckValidatorsCountsUpdated` on the module\n    /// after applying the corrections.\n    /// @param _correction See the docs for the `ValidatorsCountsCorrection` struct.\n    ///\n    /// @dev Reverts if the current numbers of exited validators of the module and node operator\n    /// don't match the supplied expected current values.\n    ///\n    /// @dev The function is restricted to the `UNSAFE_SET_EXITED_VALIDATORS_ROLE` role.\n    function unsafeSetExitedValidatorsCount(\n        uint256 _stakingModuleId,\n        uint256 _nodeOperatorId,\n        bool _triggerUpdateFinish,\n        ValidatorsCountsCorrection memory _correction\n    )\n        external\n        onlyRole(UNSAFE_SET_EXITED_VALIDATORS_ROLE)\n    {\n        StakingModule storage stakingModuleState = _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId));\n        IStakingModule stakingModule = IStakingModule(stakingModuleState.stakingModuleAddress);\n\n        (\n            /* uint256 targetLimitMode */,\n            /* uint256 targetValidatorsCount */,\n            /* uint256 stuckValidatorsCount, */,\n            /* uint256 refundedValidatorsCount */,\n            /* uint256 stuckPenaltyEndTimestamp */,\n            uint256 totalExitedValidators,\n            /* uint256 totalDepositedValidators */,\n            /* uint256 depositableValidatorsCount */\n        ) = stakingModule.getNodeOperatorSummary(_nodeOperatorId);\n\n        if (_correction.currentModuleExitedValidatorsCount != stakingModuleState.exitedValidatorsCount ||\n            _correction.currentNodeOperatorExitedValidatorsCount != totalExitedValidators\n        ) {\n            revert UnexpectedCurrentValidatorsCount(\n                stakingModuleState.exitedValidatorsCount,\n                totalExitedValidators\n            );\n        }\n\n        stakingModuleState.exitedValidatorsCount = _correction.newModuleExitedValidatorsCount;\n\n        stakingModule.unsafeUpdateValidatorsCount(\n            _nodeOperatorId,\n            _correction.newNodeOperatorExitedValidatorsCount\n        );\n\n        (\n            uint256 moduleTotalExitedValidators,\n            uint256 moduleTotalDepositedValidators,\n        ) = _getStakingModuleSummary(stakingModule);\n\n        if (_correction.newModuleExitedValidatorsCount > moduleTotalDepositedValidators) {\n            revert ReportedExitedValidatorsExceedDeposited(\n                _correction.newModuleExitedValidatorsCount,\n                moduleTotalDepositedValidators\n            );\n        }\n\n        if (_triggerUpdateFinish) {\n            if (moduleTotalExitedValidators != _correction.newModuleExitedValidatorsCount) {\n                revert UnexpectedFinalExitedValidatorsCount(\n                    moduleTotalExitedValidators,\n                    _correction.newModuleExitedValidatorsCount\n                );\n            }\n\n            stakingModule.onExitedAndStuckValidatorsCountsUpdated();\n        }\n    }\n\n    /// @notice Finalizes the reporting of the exited validators counts for the current\n    /// reporting frame.\n    ///\n    /// @dev Called by the oracle when the second phase of data reporting finishes, i.e. when the\n    /// oracle submitted the complete data on the exited validator counts per node operator\n    /// for the current reporting frame. See the docs for `updateExitedValidatorsCountByStakingModule`\n    /// for the description of the overall update process.\n    ///\n    /// @dev The function is restricted to the `REPORT_EXITED_VALIDATORS_ROLE` role.\n    function onValidatorsCountsByNodeOperatorReportingFinished()\n        external\n        onlyRole(REPORT_EXITED_VALIDATORS_ROLE)\n    {\n        uint256 stakingModulesCount = getStakingModulesCount();\n        StakingModule storage stakingModule;\n        IStakingModule moduleContract;\n\n        for (uint256 i; i < stakingModulesCount; ) {\n            stakingModule = _getStakingModuleByIndex(i);\n            moduleContract = IStakingModule(stakingModule.stakingModuleAddress);\n\n            (uint256 exitedValidatorsCount, , ) = _getStakingModuleSummary(moduleContract);\n            if (exitedValidatorsCount == stakingModule.exitedValidatorsCount) {\n                // oracle finished updating exited validators for all node ops\n                try moduleContract.onExitedAndStuckValidatorsCountsUpdated() {}\n                catch (bytes memory lowLevelRevertData) {\n                    /// @dev This check is required to prevent incorrect gas estimation of the method.\n                    ///      Without it, Ethereum nodes that use binary search for gas estimation may\n                    ///      return an invalid value when the onExitedAndStuckValidatorsCountsUpdated()\n                    ///      reverts because of the \"out of gas\" error. Here we assume that the\n                    ///      onExitedAndStuckValidatorsCountsUpdated() method doesn't have reverts with\n                    ///      empty error data except \"out of gas\".\n                    if (lowLevelRevertData.length == 0) revert UnrecoverableModuleError();\n                    emit ExitedAndStuckValidatorsCountsUpdateFailed(\n                        stakingModule.id,\n                        lowLevelRevertData\n                    );\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Decreases vetted signing keys counts per node operator for the staking module with\n    /// the specified id.\n    /// @param _stakingModuleId The id of the staking module to be updated.\n    /// @param _nodeOperatorIds Ids of the node operators to be updated.\n    /// @param _vettedSigningKeysCounts New counts of vetted signing keys for the specified node operators.\n    /// @dev The function is restricted to the `STAKING_MODULE_UNVETTING_ROLE` role.\n    function decreaseStakingModuleVettedKeysCountByNodeOperator(\n        uint256 _stakingModuleId,\n        bytes calldata _nodeOperatorIds,\n        bytes calldata _vettedSigningKeysCounts\n    ) external onlyRole(STAKING_MODULE_UNVETTING_ROLE) {\n        _checkValidatorsByNodeOperatorReportData(_nodeOperatorIds, _vettedSigningKeysCounts);\n        _getIStakingModuleById(_stakingModuleId).decreaseVettedSigningKeysCount(_nodeOperatorIds, _vettedSigningKeysCounts);\n    }\n\n    /// @notice Returns all registered staking modules.\n    /// @return res Array of staking modules.\n    function getStakingModules() external view returns (StakingModule[] memory res) {\n        uint256 stakingModulesCount = getStakingModulesCount();\n        res = new StakingModule[](stakingModulesCount);\n        for (uint256 i; i < stakingModulesCount; ) {\n            res[i] = _getStakingModuleByIndex(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the ids of all registered staking modules.\n    /// @return stakingModuleIds Array of staking module ids.\n    function getStakingModuleIds() public view returns (uint256[] memory stakingModuleIds) {\n        uint256 stakingModulesCount = getStakingModulesCount();\n        stakingModuleIds = new uint256[](stakingModulesCount);\n        for (uint256 i; i < stakingModulesCount; ) {\n            stakingModuleIds[i] = _getStakingModuleByIndex(i).id;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the staking module by its id.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return Staking module data.\n    function getStakingModule(uint256 _stakingModuleId)\n        public\n        view\n        returns (StakingModule memory)\n    {\n        return _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId));\n    }\n\n    /// @notice Returns total number of staking modules.\n    /// @return Total number of staking modules.\n    function getStakingModulesCount() public view returns (uint256) {\n        return STAKING_MODULES_COUNT_POSITION.getStorageUint256();\n    }\n\n    /// @notice Returns true if staking module with the given id was registered via `addStakingModule`, false otherwise.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return True if staking module with the given id was registered, false otherwise.\n    function hasStakingModule(uint256 _stakingModuleId) external view returns (bool) {\n        return _getStorageStakingIndicesMapping()[_stakingModuleId] != 0;\n    }\n\n    /// @notice Returns status of staking module.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return Status of the staking module.\n    function getStakingModuleStatus(uint256 _stakingModuleId)\n        public\n        view\n        returns (StakingModuleStatus)\n    {\n        return StakingModuleStatus(_getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId)).status);\n    }\n\n    /// @notice A summary of the staking module's validators.\n    struct StakingModuleSummary {\n        /// @notice The total number of validators in the EXITED state on the Consensus Layer.\n        /// @dev This value can't decrease in normal conditions.\n        uint256 totalExitedValidators;\n\n        /// @notice The total number of validators deposited via the official Deposit Contract.\n        /// @dev This value is a cumulative counter: even when the validator goes into EXITED state this\n        /// counter is not decreasing.\n        uint256 totalDepositedValidators;\n\n        /// @notice The number of validators in the set available for deposit\n        uint256 depositableValidatorsCount;\n    }\n\n    /// @notice A summary of node operator and its validators.\n    struct NodeOperatorSummary {\n        /// @notice Shows whether the current target limit applied to the node operator.\n        uint256 targetLimitMode;\n\n        /// @notice Relative target active validators limit for operator.\n        uint256 targetValidatorsCount;\n\n        /// @notice The number of validators with an expired request to exit time.\n        /// @dev [deprecated] Stuck key processing has been removed, this field is no longer used.\n        uint256 stuckValidatorsCount;\n\n        /// @notice The number of validators that can't be withdrawn, but deposit costs were\n        /// compensated to the Lido by the node operator.\n        uint256 refundedValidatorsCount;\n\n        /// @notice A time when the penalty for stuck validators stops applying to node operator rewards.\n        /// @dev [deprecated] Stuck key processing has been removed, this field is no longer used.\n        uint256 stuckPenaltyEndTimestamp;\n\n        /// @notice The total number of validators in the EXITED state on the Consensus Layer.\n        /// @dev This value can't decrease in normal conditions.\n        uint256 totalExitedValidators;\n\n        /// @notice The total number of validators deposited via the official Deposit Contract.\n        /// @dev This value is a cumulative counter: even when the validator goes into EXITED state this\n        /// counter is not decreasing.\n        uint256 totalDepositedValidators;\n\n        /// @notice The number of validators in the set available for deposit.\n        uint256 depositableValidatorsCount;\n    }\n\n    /// @notice Returns all-validators summary in the staking module.\n    /// @param _stakingModuleId Id of the staking module to return summary for.\n    /// @return summary Staking module summary.\n    function getStakingModuleSummary(uint256 _stakingModuleId)\n        public\n        view\n        returns (StakingModuleSummary memory summary)\n    {\n        IStakingModule stakingModule = IStakingModule(getStakingModule(_stakingModuleId).stakingModuleAddress);\n        (\n            summary.totalExitedValidators,\n            summary.totalDepositedValidators,\n            summary.depositableValidatorsCount\n        ) = _getStakingModuleSummary(stakingModule);\n    }\n\n\n    /// @notice Returns node operator summary from the staking module.\n    /// @param _stakingModuleId Id of the staking module where node operator is onboarded.\n    /// @param _nodeOperatorId Id of the node operator to return summary for.\n    /// @return summary Node operator summary.\n    function getNodeOperatorSummary(uint256 _stakingModuleId, uint256 _nodeOperatorId)\n        public\n        view\n        returns (NodeOperatorSummary memory summary)\n    {\n        IStakingModule stakingModule = IStakingModule(getStakingModule(_stakingModuleId).stakingModuleAddress);\n        /// @dev using intermediate variables below due to \"Stack too deep\" error in case of\n        /// assigning directly into the NodeOperatorSummary struct\n        (\n            uint256 targetLimitMode,\n            uint256 targetValidatorsCount,\n            /* uint256 stuckValidatorsCount */,\n            uint256 refundedValidatorsCount,\n            /* uint256 stuckPenaltyEndTimestamp */,\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n        ) = stakingModule.getNodeOperatorSummary(_nodeOperatorId);\n        summary.targetLimitMode = targetLimitMode;\n        summary.targetValidatorsCount = targetValidatorsCount;\n        summary.refundedValidatorsCount = refundedValidatorsCount;\n        summary.totalExitedValidators = totalExitedValidators;\n        summary.totalDepositedValidators = totalDepositedValidators;\n        summary.depositableValidatorsCount = depositableValidatorsCount;\n    }\n\n    /// @notice A collection of the staking module data stored across the StakingRouter and the\n    /// staking module contract.\n    ///\n    /// @dev This data, first of all, is designed for off-chain usage and might be redundant for\n    /// on-chain calls. Give preference for dedicated methods for gas-efficient on-chain calls.\n    struct StakingModuleDigest {\n        /// @notice The number of node operators registered in the staking module.\n        uint256 nodeOperatorsCount;\n        /// @notice The number of node operators registered in the staking module in active state.\n        uint256 activeNodeOperatorsCount;\n        /// @notice The current state of the staking module taken from the StakingRouter.\n        StakingModule state;\n        /// @notice A summary of the staking module's validators.\n        StakingModuleSummary summary;\n    }\n\n    /// @notice A collection of the node operator data stored in the staking module.\n    /// @dev This data, first of all, is designed for off-chain usage and might be redundant for\n    /// on-chain calls. Give preference for dedicated methods for gas-efficient on-chain calls.\n    struct NodeOperatorDigest {\n        /// @notice Id of the node operator.\n        uint256 id;\n        /// @notice Shows whether the node operator is active or not.\n        bool isActive;\n        /// @notice A summary of node operator and its validators.\n        NodeOperatorSummary summary;\n    }\n\n    /// @notice Returns staking module digest for each staking module registered in the staking router.\n    /// @return Array of staking module digests.\n    /// @dev WARNING: This method is not supposed to be used for onchain calls due to high gas costs\n    /// for data aggregation.\n    function getAllStakingModuleDigests() external view returns (StakingModuleDigest[] memory) {\n        return getStakingModuleDigests(getStakingModuleIds());\n    }\n\n    /// @notice Returns staking module digest for passed staking module ids.\n    /// @param _stakingModuleIds Ids of the staking modules to return data for.\n    /// @return digests Array of staking module digests.\n    /// @dev WARNING: This method is not supposed to be used for onchain calls due to high gas costs\n    /// for data aggregation.\n    function getStakingModuleDigests(uint256[] memory _stakingModuleIds)\n        public\n        view\n        returns (StakingModuleDigest[] memory digests)\n    {\n        digests = new StakingModuleDigest[](_stakingModuleIds.length);\n        for (uint256 i = 0; i < _stakingModuleIds.length; ) {\n            StakingModule memory stakingModuleState = getStakingModule(_stakingModuleIds[i]);\n            IStakingModule stakingModule = IStakingModule(stakingModuleState.stakingModuleAddress);\n            digests[i] = StakingModuleDigest({\n                nodeOperatorsCount: stakingModule.getNodeOperatorsCount(),\n                activeNodeOperatorsCount: stakingModule.getActiveNodeOperatorsCount(),\n                state: stakingModuleState,\n                summary: getStakingModuleSummary(_stakingModuleIds[i])\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns node operator digest for each node operator registered in the given staking module.\n    /// @param _stakingModuleId Id of the staking module to return data for.\n    /// @return Array of node operator digests.\n    /// @dev WARNING: This method is not supposed to be used for onchain calls due to high gas costs\n    /// for data aggregation.\n    function getAllNodeOperatorDigests(uint256 _stakingModuleId) external view returns (NodeOperatorDigest[] memory) {\n        return getNodeOperatorDigests(\n            _stakingModuleId, 0, _getIStakingModuleById(_stakingModuleId).getNodeOperatorsCount()\n        );\n    }\n\n    /// @notice Returns node operator digest for passed node operator ids in the given staking module.\n    /// @param _stakingModuleId Id of the staking module where node operators registered.\n    /// @param _offset Node operators offset starting with 0.\n    /// @param _limit The max number of node operators to return.\n    /// @return Array of node operator digests.\n    /// @dev WARNING: This method is not supposed to be used for onchain calls due to high gas costs\n    /// for data aggregation.\n    function getNodeOperatorDigests(\n        uint256 _stakingModuleId,\n        uint256 _offset,\n        uint256 _limit\n    ) public view returns (NodeOperatorDigest[] memory) {\n        return getNodeOperatorDigests(\n            _stakingModuleId, _getIStakingModuleById(_stakingModuleId).getNodeOperatorIds(_offset, _limit)\n        );\n    }\n\n    /// @notice Returns node operator digest for a slice of node operators registered in the given\n    /// staking module.\n    /// @param _stakingModuleId Id of the staking module where node operators registered.\n    /// @param _nodeOperatorIds Ids of the node operators to return data for.\n    /// @return digests Array of node operator digests.\n    /// @dev WARNING: This method is not supposed to be used for onchain calls due to high gas costs\n    /// for data aggregation.\n    function getNodeOperatorDigests(uint256 _stakingModuleId, uint256[] memory _nodeOperatorIds)\n        public\n        view\n        returns (NodeOperatorDigest[] memory digests)\n    {\n        IStakingModule stakingModule = _getIStakingModuleById(_stakingModuleId);\n        digests = new NodeOperatorDigest[](_nodeOperatorIds.length);\n        for (uint256 i = 0; i < _nodeOperatorIds.length; ) {\n            digests[i] = NodeOperatorDigest({\n                id: _nodeOperatorIds[i],\n                isActive: stakingModule.getNodeOperatorIsActive(_nodeOperatorIds[i]),\n                summary: getNodeOperatorSummary(_stakingModuleId, _nodeOperatorIds[i])\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Sets the staking module status flag for participation in further deposits and/or reward distribution.\n    /// @param _stakingModuleId Id of the staking module to be updated.\n    /// @param _status New status of the staking module.\n    /// @dev The function is restricted to the `STAKING_MODULE_MANAGE_ROLE` role.\n    function setStakingModuleStatus(\n        uint256 _stakingModuleId,\n        StakingModuleStatus _status\n    ) external onlyRole(STAKING_MODULE_MANAGE_ROLE) {\n        StakingModule storage stakingModule = _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId));\n        if (StakingModuleStatus(stakingModule.status) == _status) revert StakingModuleStatusTheSame();\n        _setStakingModuleStatus(stakingModule, _status);\n    }\n\n    /// @notice Returns whether the staking module is stopped.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return True if the staking module is stopped, false otherwise.\n    function getStakingModuleIsStopped(uint256 _stakingModuleId) external view returns (bool)\n    {\n        return getStakingModuleStatus(_stakingModuleId) == StakingModuleStatus.Stopped;\n    }\n\n    /// @notice Returns whether the deposits are paused for the staking module.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return True if the deposits are paused, false otherwise.\n    function getStakingModuleIsDepositsPaused(uint256 _stakingModuleId)\n        external\n        view\n        returns (bool)\n    {\n        return getStakingModuleStatus(_stakingModuleId) == StakingModuleStatus.DepositsPaused;\n    }\n\n    /// @notice Returns whether the staking module is active.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return True if the staking module is active, false otherwise.\n    function getStakingModuleIsActive(uint256 _stakingModuleId) external view returns (bool) {\n        return getStakingModuleStatus(_stakingModuleId) == StakingModuleStatus.Active;\n    }\n\n    /// @notice Returns staking module nonce.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return Staking module nonce.\n    function getStakingModuleNonce(uint256 _stakingModuleId) external view returns (uint256) {\n        return _getIStakingModuleById(_stakingModuleId).getNonce();\n    }\n\n    /// @notice Returns the last deposit block for the staking module.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return Last deposit block for the staking module.\n    function getStakingModuleLastDepositBlock(uint256 _stakingModuleId)\n        external\n        view\n        returns (uint256)\n    {\n        return _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId)).lastDepositBlock;\n    }\n\n    /// @notice Returns the min deposit block distance for the staking module.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return Min deposit block distance for the staking module.\n    function getStakingModuleMinDepositBlockDistance(uint256 _stakingModuleId) external view returns (uint256) {\n        return _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId)).minDepositBlockDistance;\n    }\n\n    /// @notice Returns the max deposits count per block for the staking module.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return Max deposits count per block for the staking module.\n    function getStakingModuleMaxDepositsPerBlock(uint256 _stakingModuleId) external view returns (uint256) {\n        return _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId)).maxDepositsPerBlock;\n    }\n\n    /// @notice Returns active validators count for the staking module.\n    /// @param _stakingModuleId Id of the staking module.\n    /// @return activeValidatorsCount Active validators count for the staking module.\n    function getStakingModuleActiveValidatorsCount(uint256 _stakingModuleId)\n        external\n        view\n        returns (uint256 activeValidatorsCount)\n    {\n        StakingModule storage stakingModule = _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId));\n        (\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            /* uint256 depositableValidatorsCount */\n        ) = _getStakingModuleSummary(IStakingModule(stakingModule.stakingModuleAddress));\n\n        activeValidatorsCount = totalDepositedValidators - Math256.max(\n            stakingModule.exitedValidatorsCount, totalExitedValidators\n        );\n    }\n\n    /// @notice Returns the max count of deposits which the staking module can provide data for based\n    /// on the passed `_maxDepositsValue` amount.\n    /// @param _stakingModuleId Id of the staking module to be deposited.\n    /// @param _maxDepositsValue Max amount of ether that might be used for deposits count calculation.\n    /// @return Max number of deposits might be done using the given staking module.\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        public\n        view\n        returns (uint256)\n    {\n        (\n            /* uint256 allocated */,\n            uint256[] memory newDepositsAllocation,\n            StakingModuleCache[] memory stakingModulesCache\n        ) = _getDepositsAllocation(_maxDepositsValue / DEPOSIT_SIZE);\n        uint256 stakingModuleIndex = _getStakingModuleIndexById(_stakingModuleId);\n        return\n            newDepositsAllocation[stakingModuleIndex] - stakingModulesCache[stakingModuleIndex].activeValidatorsCount;\n    }\n\n    /// @notice Returns the aggregate fee distribution proportion.\n    /// @return modulesFee Modules aggregate fee in base precision.\n    /// @return treasuryFee Treasury fee in base precision.\n    /// @return basePrecision Base precision: a value corresponding to the full fee.\n    function getStakingFeeAggregateDistribution() public view returns (\n        uint96 modulesFee,\n        uint96 treasuryFee,\n        uint256 basePrecision\n    ) {\n        uint96[] memory moduleFees;\n        uint96 totalFee;\n        (, , moduleFees, totalFee, basePrecision) = getStakingRewardsDistribution();\n        for (uint256 i; i < moduleFees.length; ) {\n            modulesFee += moduleFees[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n        treasuryFee = totalFee - modulesFee;\n    }\n\n    /// @notice Return shares table.\n    /// @return recipients Rewards recipient addresses corresponding to each module.\n    /// @return stakingModuleIds Module IDs.\n    /// @return stakingModuleFees Fee of each recipient.\n    /// @return totalFee Total fee to mint for each staking module and treasury.\n    /// @return precisionPoints Base precision number, which constitutes 100% fee.\n    function getStakingRewardsDistribution()\n        public\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        )\n    {\n        (uint256 totalActiveValidators, StakingModuleCache[] memory stakingModulesCache) = _loadStakingModulesCache();\n        uint256 stakingModulesCount = stakingModulesCache.length;\n\n        /// @dev Return empty response if there are no staking modules or active validators yet.\n        if (stakingModulesCount == 0 || totalActiveValidators == 0) {\n            return (new address[](0), new uint256[](0), new uint96[](0), 0, FEE_PRECISION_POINTS);\n        }\n\n        precisionPoints = FEE_PRECISION_POINTS;\n        stakingModuleIds = new uint256[](stakingModulesCount);\n        recipients = new address[](stakingModulesCount);\n        stakingModuleFees = new uint96[](stakingModulesCount);\n\n        uint256 rewardedStakingModulesCount = 0;\n        uint256 stakingModuleValidatorsShare;\n        uint96 stakingModuleFee;\n\n        for (uint256 i; i < stakingModulesCount; ) {\n            /// @dev Skip staking modules which have no active validators.\n            if (stakingModulesCache[i].activeValidatorsCount > 0) {\n                stakingModuleIds[rewardedStakingModulesCount] = stakingModulesCache[i].stakingModuleId;\n                stakingModuleValidatorsShare = ((stakingModulesCache[i].activeValidatorsCount * precisionPoints) / totalActiveValidators);\n\n                recipients[rewardedStakingModulesCount] = address(stakingModulesCache[i].stakingModuleAddress);\n                stakingModuleFee = uint96((stakingModuleValidatorsShare * stakingModulesCache[i].stakingModuleFee) / TOTAL_BASIS_POINTS);\n                /// @dev If the staking module has the `Stopped` status for some reason, then\n                ///      the staking module's rewards go to the treasury, so that the DAO has ability\n                ///      to manage them (e.g. to compensate the staking module in case of an error, etc.)\n                if (stakingModulesCache[i].status != StakingModuleStatus.Stopped) {\n                    stakingModuleFees[rewardedStakingModulesCount] = stakingModuleFee;\n                }\n                // Else keep stakingModuleFees[rewardedStakingModulesCount] = 0, but increase totalFee.\n\n                totalFee += (uint96((stakingModuleValidatorsShare * stakingModulesCache[i].treasuryFee) / TOTAL_BASIS_POINTS) + stakingModuleFee);\n\n                unchecked {\n                    rewardedStakingModulesCount++;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Total fee never exceeds 100%.\n        assert(totalFee <= precisionPoints);\n\n        /// @dev Shrink arrays.\n        if (rewardedStakingModulesCount < stakingModulesCount) {\n            assembly {\n                mstore(stakingModuleIds, rewardedStakingModulesCount)\n                mstore(recipients, rewardedStakingModulesCount)\n                mstore(stakingModuleFees, rewardedStakingModulesCount)\n            }\n        }\n    }\n\n    /// @notice Returns the same as getStakingRewardsDistribution() but in reduced, 1e4 precision (DEPRECATED).\n    /// @dev Helper only for Lido contract. Use getStakingRewardsDistribution() instead.\n    /// @return totalFee Total fee to mint for each staking module and treasury in reduced, 1e4 precision.\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee) {\n        /// @dev The logic is placed here but in Lido contract to save Lido bytecode.\n        (, , , uint96 totalFeeInHighPrecision, uint256 precision) = getStakingRewardsDistribution();\n        // Here we rely on (totalFeeInHighPrecision <= precision).\n        totalFee = _toE4Precision(totalFeeInHighPrecision, precision);\n    }\n\n    /// @notice Returns the same as getStakingFeeAggregateDistribution() but in reduced, 1e4 precision (DEPRECATED).\n    /// @dev Helper only for Lido contract. Use getStakingFeeAggregateDistribution() instead.\n    /// @return modulesFee Modules aggregate fee in reduced, 1e4 precision.\n    /// @return treasuryFee Treasury fee in reduced, 1e4 precision.\n    function getStakingFeeAggregateDistributionE4Precision()\n        external view\n        returns (uint16 modulesFee, uint16 treasuryFee)\n    {\n        /// @dev The logic is placed here but in Lido contract to save Lido bytecode.\n        (\n            uint256 modulesFeeHighPrecision,\n            uint256 treasuryFeeHighPrecision,\n            uint256 precision\n        ) = getStakingFeeAggregateDistribution();\n        // Here we rely on ({modules,treasury}FeeHighPrecision <= precision).\n        modulesFee = _toE4Precision(modulesFeeHighPrecision, precision);\n        treasuryFee = _toE4Precision(treasuryFeeHighPrecision, precision);\n    }\n\n    /// @notice Returns new deposits allocation after the distribution of the `_depositsCount` deposits.\n    /// @param _depositsCount The maximum number of deposits to be allocated.\n    /// @return allocated Number of deposits allocated to the staking modules.\n    /// @return allocations Array of new deposits allocation to the staking modules.\n    function getDepositsAllocation(uint256 _depositsCount) external view returns (uint256 allocated, uint256[] memory allocations) {\n        (allocated, allocations, ) = _getDepositsAllocation(_depositsCount);\n    }\n\n    /// @notice Invokes a deposit call to the official Deposit contract.\n    /// @param _depositsCount Number of deposits to make.\n    /// @param _stakingModuleId Id of the staking module to be deposited.\n    /// @param _depositCalldata Staking module calldata.\n    /// @dev Only the Lido contract is allowed to call this method.\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes calldata _depositCalldata\n    ) external payable {\n        if (msg.sender != LIDO_POSITION.getStorageAddress()) revert AppAuthLidoFailed();\n\n        bytes32 withdrawalCredentials = getWithdrawalCredentials();\n        if (withdrawalCredentials == 0) revert EmptyWithdrawalsCredentials();\n\n        StakingModule storage stakingModule = _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId));\n        if (StakingModuleStatus(stakingModule.status) != StakingModuleStatus.Active)\n            revert StakingModuleNotActive();\n\n        /// @dev Firstly update the local state of the contract to prevent a reentrancy attack\n        /// even though the staking modules are trusted contracts.\n        uint256 depositsValue = msg.value;\n        if (depositsValue != _depositsCount * DEPOSIT_SIZE) revert InvalidDepositsValue(depositsValue, _depositsCount);\n\n        _updateModuleLastDepositState(stakingModule, _stakingModuleId, depositsValue);\n\n        if (_depositsCount > 0) {\n            (bytes memory publicKeysBatch, bytes memory signaturesBatch) =\n                IStakingModule(stakingModule.stakingModuleAddress)\n                    .obtainDepositData(_depositsCount, _depositCalldata);\n\n            uint256 etherBalanceBeforeDeposits = address(this).balance;\n            _makeBeaconChainDeposits32ETH(\n                _depositsCount,\n                abi.encodePacked(withdrawalCredentials),\n                publicKeysBatch,\n                signaturesBatch\n            );\n            uint256 etherBalanceAfterDeposits = address(this).balance;\n\n            /// @dev All sent ETH must be deposited and self balance stay the same.\n            assert(etherBalanceBeforeDeposits - etherBalanceAfterDeposits == depositsValue);\n        }\n    }\n\n    /// @notice Set credentials to withdraw ETH on Consensus Layer side.\n    /// @param _withdrawalCredentials withdrawal credentials field as defined in the Consensus Layer specs.\n    /// @dev Note that setWithdrawalCredentials discards all unused deposits data as the signatures are invalidated.\n    /// @dev The function is restricted to the `MANAGE_WITHDRAWAL_CREDENTIALS_ROLE` role.\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external onlyRole(MANAGE_WITHDRAWAL_CREDENTIALS_ROLE) {\n        WITHDRAWAL_CREDENTIALS_POSITION.setStorageBytes32(_withdrawalCredentials);\n\n        uint256 stakingModulesCount = getStakingModulesCount();\n        for (uint256 i; i < stakingModulesCount; ) {\n            StakingModule storage stakingModule = _getStakingModuleByIndex(i);\n\n            unchecked {\n                ++i;\n            }\n\n            try IStakingModule(stakingModule.stakingModuleAddress)\n                .onWithdrawalCredentialsChanged() {}\n            catch (bytes memory lowLevelRevertData) {\n                /// @dev This check is required to prevent incorrect gas estimation of the method.\n                ///      Without it, Ethereum nodes that use binary search for gas estimation may\n                ///      return an invalid value when the onWithdrawalCredentialsChanged()\n                ///      reverts because of the \"out of gas\" error. Here we assume that the\n                ///      onWithdrawalCredentialsChanged() method doesn't have reverts with\n                ///      empty error data except \"out of gas\".\n                if (lowLevelRevertData.length == 0) revert UnrecoverableModuleError();\n                _setStakingModuleStatus(stakingModule, StakingModuleStatus.DepositsPaused);\n                emit WithdrawalsCredentialsChangeFailed(stakingModule.id, lowLevelRevertData);\n            }\n        }\n\n        emit WithdrawalCredentialsSet(_withdrawalCredentials, msg.sender);\n    }\n\n    /// @notice Returns current credentials to withdraw ETH on Consensus Layer side.\n    /// @return Withdrawal credentials.\n    function getWithdrawalCredentials() public view returns (bytes32) {\n        return WITHDRAWAL_CREDENTIALS_POSITION.getStorageBytes32();\n    }\n\n    function _checkValidatorsByNodeOperatorReportData(\n        bytes calldata _nodeOperatorIds,\n        bytes calldata _validatorsCounts\n    ) internal pure {\n        if (_nodeOperatorIds.length % 8 != 0 || _validatorsCounts.length % 16 != 0) {\n            revert InvalidReportData(3);\n        }\n        uint256 nodeOperatorsCount = _nodeOperatorIds.length / 8;\n        if (_validatorsCounts.length / 16 != nodeOperatorsCount) {\n            revert InvalidReportData(2);\n        }\n        if (nodeOperatorsCount == 0) {\n            revert InvalidReportData(1);\n        }\n    }\n\n    /// @dev Save the last deposit state for the staking module and emit the event\n    /// @param stakingModule staking module storage ref\n    /// @param stakingModuleId id of the staking module to be deposited\n    /// @param depositsValue value to deposit\n    function _updateModuleLastDepositState(\n        StakingModule storage stakingModule,\n        uint256 stakingModuleId,\n        uint256 depositsValue\n    ) internal {\n        stakingModule.lastDepositAt = uint64(block.timestamp);\n        stakingModule.lastDepositBlock = block.number;\n        emit StakingRouterETHDeposited(stakingModuleId, depositsValue);\n    }\n\n\n    /// @dev Loads modules into a memory cache.\n    /// @return totalActiveValidators Total active validators across all modules.\n    /// @return stakingModulesCache Array of StakingModuleCache structs.\n    function _loadStakingModulesCache() internal view returns (\n        uint256 totalActiveValidators,\n        StakingModuleCache[] memory stakingModulesCache\n    ) {\n        uint256 stakingModulesCount = getStakingModulesCount();\n        stakingModulesCache = new StakingModuleCache[](stakingModulesCount);\n        for (uint256 i; i < stakingModulesCount; ) {\n            stakingModulesCache[i] = _loadStakingModulesCacheItem(i);\n            totalActiveValidators += stakingModulesCache[i].activeValidatorsCount;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _loadStakingModulesCacheItem(uint256 _stakingModuleIndex)\n        internal\n        view\n        returns (StakingModuleCache memory cacheItem)\n    {\n        StakingModule storage stakingModuleData = _getStakingModuleByIndex(_stakingModuleIndex);\n\n        cacheItem.stakingModuleAddress = stakingModuleData.stakingModuleAddress;\n        cacheItem.stakingModuleId = stakingModuleData.id;\n        cacheItem.stakingModuleFee = stakingModuleData.stakingModuleFee;\n        cacheItem.treasuryFee = stakingModuleData.treasuryFee;\n        cacheItem.stakeShareLimit = stakingModuleData.stakeShareLimit;\n        cacheItem.status = StakingModuleStatus(stakingModuleData.status);\n\n        (\n            uint256 totalExitedValidators,\n            uint256 totalDepositedValidators,\n            uint256 depositableValidatorsCount\n        ) = _getStakingModuleSummary(IStakingModule(cacheItem.stakingModuleAddress));\n\n        cacheItem.availableValidatorsCount = cacheItem.status == StakingModuleStatus.Active\n            ? depositableValidatorsCount\n            : 0;\n\n        // The module might not receive all exited validators data yet => we need to replacing\n        // the exitedValidatorsCount with the one that the staking router is aware of.\n        cacheItem.activeValidatorsCount =\n            totalDepositedValidators -\n            Math256.max(totalExitedValidators, stakingModuleData.exitedValidatorsCount);\n    }\n\n    function _setStakingModuleStatus(StakingModule storage _stakingModule, StakingModuleStatus _status) internal {\n        StakingModuleStatus prevStatus = StakingModuleStatus(_stakingModule.status);\n        if (prevStatus != _status) {\n            _stakingModule.status = uint8(_status);\n            emit StakingModuleStatusSet(_stakingModule.id, _status, msg.sender);\n        }\n    }\n\n    function _getDepositsAllocation(\n        uint256 _depositsToAllocate\n    ) internal view returns (uint256 allocated, uint256[] memory allocations, StakingModuleCache[] memory stakingModulesCache) {\n        // Calculate total used validators for operators.\n        uint256 totalActiveValidators;\n\n        (totalActiveValidators, stakingModulesCache) = _loadStakingModulesCache();\n\n        uint256 stakingModulesCount = stakingModulesCache.length;\n        allocations = new uint256[](stakingModulesCount);\n        if (stakingModulesCount > 0) {\n            /// @dev New estimated active validators count.\n            totalActiveValidators += _depositsToAllocate;\n            uint256[] memory capacities = new uint256[](stakingModulesCount);\n            uint256 targetValidators;\n\n            for (uint256 i; i < stakingModulesCount; ) {\n                allocations[i] = stakingModulesCache[i].activeValidatorsCount;\n                targetValidators = (stakingModulesCache[i].stakeShareLimit * totalActiveValidators) / TOTAL_BASIS_POINTS;\n                capacities[i] = Math256.min(targetValidators, stakingModulesCache[i].activeValidatorsCount + stakingModulesCache[i].availableValidatorsCount);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            (allocated, allocations) = MinFirstAllocationStrategy.allocate(allocations, capacities, _depositsToAllocate);\n        }\n    }\n\n    function _getStakingModuleIndexById(uint256 _stakingModuleId) internal view returns (uint256) {\n        mapping(uint256 => uint256) storage _stakingModuleIndicesOneBased = _getStorageStakingIndicesMapping();\n        uint256 indexOneBased = _stakingModuleIndicesOneBased[_stakingModuleId];\n        if (indexOneBased == 0) revert StakingModuleUnregistered();\n        return indexOneBased - 1;\n    }\n\n    function _setStakingModuleIndexById(uint256 _stakingModuleId, uint256 _stakingModuleIndex) internal {\n        mapping(uint256 => uint256) storage _stakingModuleIndicesOneBased = _getStorageStakingIndicesMapping();\n        _stakingModuleIndicesOneBased[_stakingModuleId] = _stakingModuleIndex + 1;\n    }\n\n    function _getIStakingModuleById(uint256 _stakingModuleId) internal view returns (IStakingModule) {\n        return IStakingModule(_getStakingModuleAddressById(_stakingModuleId));\n    }\n\n    function _getStakingModuleByIndex(uint256 _stakingModuleIndex) internal view returns (StakingModule storage) {\n        mapping(uint256 => StakingModule) storage _stakingModules = _getStorageStakingModulesMapping();\n        return _stakingModules[_stakingModuleIndex];\n    }\n\n    function _getStakingModuleAddressById(uint256 _stakingModuleId) internal view returns (address) {\n        return _getStakingModuleByIndex(_getStakingModuleIndexById(_stakingModuleId)).stakingModuleAddress;\n    }\n\n    function _getStorageStakingModulesMapping() internal pure returns (mapping(uint256 => StakingModule) storage result) {\n        bytes32 position = STAKING_MODULES_MAPPING_POSITION;\n        assembly {\n            result.slot := position\n        }\n    }\n\n    function _getStorageStakingIndicesMapping() internal pure returns (mapping(uint256 => uint256) storage result) {\n        bytes32 position = STAKING_MODULE_INDICES_MAPPING_POSITION;\n        assembly {\n            result.slot := position\n        }\n    }\n\n    function _toE4Precision(uint256 _value, uint256 _precision) internal pure returns (uint16) {\n        return uint16((_value * TOTAL_BASIS_POINTS) / _precision);\n    }\n\n    function _validateEqualArrayLengths(uint256 firstArrayLength, uint256 secondArrayLength) internal pure {\n        if (firstArrayLength != secondArrayLength) {\n            revert ArraysLengthMismatch(firstArrayLength, secondArrayLength);\n        }\n    }\n\n    /// @dev Optimizes contract deployment size by wrapping the 'stakingModule.getStakingModuleSummary' function.\n    function _getStakingModuleSummary(IStakingModule stakingModule) internal view returns (uint256, uint256, uint256) {\n        return stakingModule.getStakingModuleSummary();\n    }\n\n    /// @notice Handles tracking and penalization logic for a node operator who failed to exit their validator within the defined exit window.\n    /// @dev This function is called to report the current exit-related status of a validator belonging to a specific node operator.\n    ///      It accepts a validator's public key, associated with the duration (in seconds) it was eligible to exit but has not exited.\n    ///      This data could be used to trigger penalties for the node operator if the validator has been non-exiting for too long.\n    /// @param _stakingModuleId The ID of the staking module.\n    /// @param _nodeOperatorId The ID of the node operator whose validator status is being delivered.\n    /// @param _proofSlotTimestamp The timestamp (slot time) when the validator was last known to be in an active ongoing state.\n    /// @param _publicKey The public key of the validator being reported.\n    /// @param _eligibleToExitInSec The duration (in seconds) indicating how long the validator has been eligible to exit after request but has not exited.\n    function reportValidatorExitDelay(\n        uint256 _stakingModuleId,\n        uint256 _nodeOperatorId,\n        uint256 _proofSlotTimestamp,\n        bytes calldata _publicKey,\n        uint256 _eligibleToExitInSec\n    )\n        external\n        onlyRole(REPORT_VALIDATOR_EXITING_STATUS_ROLE)\n    {\n        _getIStakingModuleById(_stakingModuleId).reportValidatorExitDelay(\n            _nodeOperatorId,\n            _proofSlotTimestamp,\n            _publicKey,\n            _eligibleToExitInSec\n        );\n    }\n\n    /// @notice Handles the triggerable exit event for a set of validators.\n    /// @dev This function is called when validators are exited using triggerable exit requests on the Execution Layer.\n    /// @param validatorExitData An array of `ValidatorExitData` structs, each representing a validator\n    ///        for which a triggerable exit was requested. Each entry includes:\n    ///        - `stakingModuleId`: ID of the staking module.\n    ///        - `nodeOperatorId`: ID of the node operator.\n    ///        - `pubkey`: Validator public key, 48 bytes length.\n    /// @param _withdrawalRequestPaidFee Fee amount paid to send a withdrawal request on the Execution Layer (EL).\n    /// @param _exitType The type of exit being performed.\n    ///        This parameter may be interpreted differently across various staking modules depending on their specific implementation.\n    function onValidatorExitTriggered(\n        ValidatorExitData[] calldata validatorExitData,\n        uint256 _withdrawalRequestPaidFee,\n        uint256 _exitType\n    )\n        external\n        onlyRole(REPORT_VALIDATOR_EXIT_TRIGGERED_ROLE)\n    {\n        ValidatorExitData calldata data;\n        for (uint256 i = 0; i < validatorExitData.length; ++i) {\n            data = validatorExitData[i];\n\n            try _getIStakingModuleById(data.stakingModuleId).onValidatorExitTriggered(\n                data.nodeOperatorId,\n                data.pubkey,\n                _withdrawalRequestPaidFee,\n                _exitType\n            )\n            {} catch (bytes memory lowLevelRevertData) {\n                /// @dev This check is required to prevent incorrect gas estimation of the method.\n                ///      Without it, Ethereum nodes that use binary search for gas estimation may\n                ///      return an invalid value when the onValidatorExitTriggered()\n                ///      reverts because of the \"out of gas\" error. Here we assume that the\n                ///      onValidatorExitTriggered() method doesn't have reverts with\n                ///      empty error data except \"out of gas\".\n                if (lowLevelRevertData.length == 0) revert UnrecoverableModuleError();\n                emit StakingModuleExitNotificationFailed(data.stakingModuleId, data.nodeOperatorId, data.pubkey);\n            }\n        }\n    }\n}\n"
    }
}