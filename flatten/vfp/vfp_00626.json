{
    "vfp_id": "vfp_00626",
    "project_name": "ackee-blockchain-lido-stonks-2.0-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Flawed ETH/USD routing",
            "description": "The vulnerability arises in the OracleRouter contract's getPricesAndDecimals function, which reverts when the requested quote denomination (ETH or USD) does not match the configured primary quote for either token in a pair. This flawed logic prevents the use of an ETH/USD bridge to route prices when tokens are configured with different denominations. As a result, when a user attempts to swap tokens where one is USD-quoted and the other is ETH-quoted, the function call reverts. This leads to a denial of service for users trying to create orders for such token pairs, effectively blocking functionality for mixed-denomination swaps. The root cause is the lack of fallback logic to use the ETH/USD price bridge when direct denomination matching fails.\n",
            "severity": "Medium",
            "location": [
                "OracleRouter.sol::getPricesAndDecimals",
                "AmountConverter.sol::getExpectedOut"
            ],
            "files": [
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Order rounding errors",
            "description": "The vulnerability exists in the Order contract's isValidSignature function, where rounding errors during arithmetic calculations can cause a valid order to be rejected after a partial fill or a small donation of the sell token. The function calculates the current estimated buy amount and compares it to the baseline buy amount derived from the original order parameters. Due to integer division and multiplication in Math.mulDiv, small rounding discrepancies can occur, especially when the sell amount is reduced. In strict tolerance mode (where price changes are not allowed), even a one-unit difference in the calculated buy amount can cause the order validation to fail. This can temporarily block order execution, leading to a denial of service for the order owner. The root cause is the lack of tolerance for minor rounding differences in price comparisons.\n",
            "severity": "Low",
            "location": [
                "Order.sol::isValidSignature#226-250",
                "Stonks.sol::estimateTradeOutput"
            ],
            "files": [
                "stonks/contracts/Order.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Stonks can be unpaused after killSwitch",
            "description": "The Stonks contract implements a killSwitch to irreversibly pause all functionality, but the unpauseCreation and unpauseSignatures functions lack a check to prevent their execution after the killSwitch has been activated. While unpauseCreation is harmless due to the notKilled modifier on order creation functions, unpauseSignatures can re-enable the filling of existing orders even after the killSwitch has been engaged. This contradicts the intended irreversible nature of the killSwitch and reintroduces execution risk when the system should be fully disabled. An attacker or malicious agent could exploit this by calling unpauseSignatures after killSwitch, allowing order fulfillment to resume. The root cause is the absence of the whenNotKilled modifier on the unpause functions.\n",
            "severity": "Low",
            "location": [
                "Stonks.sol::unpauseCreation#302-304",
                "Stonks.sol::unpauseSignatures#322-330"
            ],
            "files": [
                "stonks/contracts/Stonks.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Token decimals used as configured flag",
            "description": "The OracleRouter contract uses the tokenDecimals field as a flag to determine whether a token is configured, by reverting if the token's decimals are zero. This is based on the explicit prohibition of ERC-20 tokens with zero decimals. However, according to the ERC-20 standard, tokens with zero decimals are technically valid, and the protocol could support them with proper modifications. The root cause is the misuse of tokenDecimals as a configuration flag instead of using a dedicated field such as primaryFeed.aggregator. An attacker or user could be misled into thinking zero-decimal tokens are inherently invalid, when the restriction is implementation-specific. The impact is limited to reduced flexibility in token support, potentially excluding valid use cases, but does not lead to fund loss or critical system failure.\n",
            "severity": "Informational",
            "location": [
                "OracleRouter::_setTokenFeed#623-625",
                "OracleRouter::setTokenActive#216-218"
            ],
            "files": [
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing ETH/USD feed configuration check",
            "description": "The OracleRouter.syncEthUsdBridge function allows updating the ETH/USD feed metadata without first verifying that the feed has been configured. This can lead to confusion because if the function is called before setEthUsdBridge, the maxStalenessSeconds value remains uninitialized, causing subsequent calculations to revert due to staleness checks. The root cause is the absence of a validation check on the feed's configuration state (e.g., whether the aggregator address is set). An attacker cannot directly exploit this for financial gain, but a legitimate user or system may experience unexpected reverts if the function call order is incorrect. The impact is operational confusion and potential integration issues, but no security breach or loss of funds occurs.\n",
            "severity": "Informational",
            "location": [
                "OracleRouter::syncEthUsdBridge#159-161"
            ],
            "files": [
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "PRICE_UNIT and PRICE_SCALE discrepancy",
            "description": "The Order contract defines PRICE_SCALE as 1e18, intended to match the PRICE_UNIT value in OracleRouter. However, PRICE_UNIT in OracleRouter is derived from a configurable PRICE_DECIMALS parameter, meaning the two values could diverge if PRICE_DECIMALS is set to anything other than 18. The root cause is the lack of synchronization between the two constants, relying on manual configuration rather than enforced consistency. If mismatched, this could lead to incorrect price calculations across the system, potentially causing incorrect trade outputs or miscalibrated routing. The impact is correctness and reliability of price computations, which could result in economic loss if trades are executed at incorrect rates. However, since the fix locks PRICE_DECIMALS to 18, the risk is mitigated.\n",
            "severity": "Informational",
            "location": [
                "Order#46",
                "OracleRouter"
            ],
            "files": [
                "stonks/contracts/Order.sol",
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Misleading use of errors",
            "description": "The AmountConverter contract reuses the AmountFromTooLarge error in two distinct contexts: first to check if an input exceeds uint128, and second to prevent overflow during decimal scaling, where the input is compared against a scaled maximum. These are logically separate conditions, and using the same error name misleads callers about the actual cause of failure. Similarly, the Stonks contract uses MarginOverflowsAllowedLimit to validate maxImprovementInBasisPoints_, even though the error name refers to margin. The root cause is poor error naming and reuse across unrelated validation logic. While this does not introduce a direct security vulnerability, it complicates debugging and integration, potentially leading to incorrect assumptions by frontends or off-chain systems. The impact is reduced code clarity and increased risk of misinterpretation during integration or incident response.\n",
            "severity": "Informational",
            "location": [
                "AmountConverter::getExpectedOut#148-150",
                "AmountConverter::getExpectedOut#226-228",
                "Stonks::_validateBps#489-497"
            ],
            "files": [
                "stonks/contracts/AmountConverter.sol",
                "stonks/contracts/Stonks.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Inconsistency in allowing manager to be zero address",
            "description": "The Stonks contract prevents setting the manager to the zero address during construction via _validateAddresses, but the inherited setManager function in Ownable allows setting the manager to address(0) afterward without validation. This creates an inconsistency in the system's security model—while the constructor enforces a non-zero manager, the upgradeability or management logic does not. The root cause is a mismatch between initialization-time validation and runtime function permissions. An attacker could potentially manipulate governance flows if the manager is cleared post-deployment, leading to a loss of administrative control. The impact is a potential governance disruption, though the fix later removes the constructor restriction, indicating the behavior was reconsidered.\n",
            "severity": "Informational",
            "location": [
                "Stonks::_validateAddresses#431-433",
                "Ownable::setManager#71-75"
            ],
            "files": [
                "stonks/contracts/Stonks.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "The KillEngaged should not be emitted if the Stonks contract was already killed",
            "description": "The killSwitch function emits the KillEngaged event every time it is called, even if the contract has already been killed. In contrast, other state-changing functions like pausing signatures emit events only when a state transition occurs. The root cause is the lack of a conditional check before emitting the event. While the function's core logic (setting _killed) is idempotent, the event emission is redundant and misleading. This can cause off-chain monitoring systems to误interpret repeated events as multiple kill actions, leading to incorrect alerts or analytics. The impact is degraded observability and potential confusion during incident analysis, but no direct security risk.\n",
            "severity": "Informational",
            "location": [
                "Stonks::killSwitch#335-353"
            ],
            "files": [
                "stonks/contracts/Stonks.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "assertQuotable inefficiency",
            "description": "The Stonks.assertQuotable function is called as a fail-fast check during order initialization, but it performs redundant validations that are repeated in the subsequent estimateTradeOutput call. This results in unnecessary gas costs and computation. Furthermore, in edge cases where both tokens are USD-denominated but USE_ETH_ANCHOR is true, assertQuotable fails to validate the ETH/USD feed, making it an incomplete safeguard. The root cause is the lack of shared state or caching between the two function calls, and the failure to cover all dependency paths. The impact is increased gas consumption and a false sense of security from a check that does not fully prevent failures, reducing system efficiency and reliability.\n",
            "severity": "Informational",
            "location": [
                "Order::initialize#147",
                "Stonks::assertQuotable"
            ],
            "files": [
                "stonks/contracts/Order.sol",
                "stonks/contracts/Stonks.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing public getters",
            "description": "The Order contract's allowPartialFill and cancelled state variables are private without public getter functions, making them inaccessible via standard contract interfaces. While allowPartialFill can be derived from the Stonks contract, cancelled is only accessible through low-level storage probing. The root cause is incomplete interface design. This hinders external tools, UIs, and auditors from easily inspecting order states, reducing transparency and integrability. The impact is primarily on developer experience and system observability, with no direct security vulnerability, but it increases the complexity of interacting with the contract.\n",
            "severity": "Informational",
            "location": [
                "Order#65-68"
            ],
            "files": [
                "stonks/contracts/Order.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant MAX_DECIMALS checks",
            "description": "The AmountConverter contract checks whether the decimal difference between tokens exceeds ROUTER_MAX_DECIMALS, but this check is redundant because the OracleRouter already ensures that no token has more than MAX_DECIMALS. Similarly, OracleRouter performs redundant checks in _computeScaleFactors on upDiff and downDiff, even though both PRICE_DECIMALS and feedDecimals_ are already validated against MAX_DECIMALS during configuration. The root cause is over-defensive programming without considering prior validation layers. The impact is unnecessary gas consumption and code complexity, with no security benefit. Removing these checks improves efficiency without reducing safety.\n",
            "severity": "Informational",
            "location": [
                "AmountConverter::getExpectedOut#201-203",
                "OracleRouter::_computeScaleFactors#725-727",
                "OracleRouter::_computeScaleFactors#736-738"
            ],
            "files": [
                "stonks/contracts/AmountConverter.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emissions",
            "description": "The Stonks contract does not emit events when maxImprovementInBasisPoints and allowPartialFill parameters are set during construction, and the Order contract does not emit ManagerSet during initialize. This breaks consistency with the rest of the codebase, where state changes typically emit events. The root cause is incomplete event instrumentation. The impact is reduced traceability for off-chain systems, making it harder to track configuration changes or debug issues. While not a security flaw, it weakens the system's auditability and monitoring capabilities.\n",
            "severity": "Informational",
            "location": [
                "Stonks",
                "Order::initialize"
            ],
            "files": [
                "stonks/contracts/Stonks.sol",
                "stonks/contracts/Order.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Inefficient variable packing",
            "description": "The TokenConfig and FeedConfig structs in OracleRouter are not optimally packed, leading to higher storage slot usage than necessary. For example, small types like uint8 and bool are not grouped efficiently, causing gaps in storage layout. The root cause is suboptimal struct field ordering. This increases gas costs for storage reads and writes due to additional SLOADs and SSTOREs across multiple slots. The impact is higher transaction costs and reduced efficiency, especially in functions that read or write these structs frequently. Restructuring the fields to pack tightly reduces gas usage and improves performance.\n",
            "severity": "Informational",
            "location": [
                "OracleRouter#41-55"
            ],
            "files": [
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing TokenNotConfigured check",
            "description": "The setTokenEthUsdStalenessOverride function only checks that the token address is not zero but does not verify that the token is actually configured in the tokenConfig mapping. This allows setting overrides for unconfigured tokens, which may lead to unexpected behavior when the token is later configured, as _setTokenFeed resets the override to zero. The root cause is insufficient input validation. The impact is potential configuration drift and confusion for system operators, though no direct exploit path exists. The fix introduces a check on primaryFeed.aggregator to ensure the token is configured before allowing updates.\n",
            "severity": "Informational",
            "location": [
                "OracleRouter::setTokenEthUsdStalenessOverride#186-192",
                "OracleRouter::_setTokenFeed#648-660"
            ],
            "files": [
                "stonks/contracts/routers/OracleRouter.sol"
            ]
        }
    ],
    "affected_files": {
        "AmountConverter.sol": "// SPDX-FileCopyrightText: 2024 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IAmountConverter} from \"./interfaces/IAmountConverter.sol\";\nimport {IOracleRouter} from \"./interfaces/IOracleRouter.sol\";\n\n/**\n * @title AmountConverter\n * @dev This contract provides functionality for converting the amount\n *      of Token A into the amount of Token B based on oracle router prices.\n */\ncontract AmountConverter is IAmountConverter {\n    // ==================== Immutables ====================\n\n    /// @notice Oracle router contract used for fetching token prices.\n    IOracleRouter public immutable ORACLE_ROUTER;\n    /// @notice If true, uses ETH-denominated prices directly (gas optimized for ETH-quoted pairs).\n    ///         If false, uses USD prices (supports mixed denominations).\n    bool public immutable USE_ETH_ANCHOR;\n    /// @notice Cached router max decimals to avoid an external call per quote.\n    uint8 public immutable ROUTER_MAX_DECIMALS;\n\n    // ==================== Storage Variables ====================\n\n    /// @notice Mapping indicating which tokens are allowed to be sold.\n    mapping(address tokenToSell => bool allowed) public allowedTokensToSell;\n    /// @notice Mapping indicating which tokens are allowed to be bought.\n    mapping(address tokenToBuy => bool allowed) public allowedTokensToBuy;\n\n    // ==================== Events ====================\n\n    event AllowedTokenToSellAdded(address token);\n    event AllowedTokenToBuyAdded(address token);\n\n    // ==================== Errors ====================\n\n    error InvalidOracleRouterAddress(address oracleRouter);\n    error InvalidAllowedTokenToBuy(address allowedTokenToBuy);\n    error InvalidAllowedTokenToSell(address allowedTokenToSell);\n    error InvalidAmount(uint256 amount);\n    error InvalidTokensToSellArrayLength();\n    error InvalidTokensToBuyArrayLength();\n    error SellTokenNotAllowed(address tokenFrom);\n    error BuyTokenNotAllowed(address tokenTo);\n    error TokensCannotBeSame();\n    error InvalidDecimalsDifference(uint8 diff);\n    error AmountFromTooLarge(uint256 amount);\n    error ScaledPriceOverflow();\n    error PriceFromUsdZero();\n    error PriceToUsdZero();\n    error PriceFromEthZero();\n    error PriceToEthZero();\n\n    // ==================== Constructor ====================\n\n    /**\n     * @param oracleRouter_ Oracle router for price fetching\n     * @param allowedTokensToSell_ List of addresses which are allowed to use as sell tokens\n     * @param allowedTokensToBuy_ List of addresses of tokens that are allowed to be bought\n     * @param useEthAnchor_ If true, prices are requested in ETH (tokens already quoted in ETH avoid a bridge, others are automatically bridged).\n     *                      If false, prices are requested in USD (router handles bridging as needed).\n     */\n    constructor(\n        address oracleRouter_,\n        address[] memory allowedTokensToSell_,\n        address[] memory allowedTokensToBuy_,\n        bool useEthAnchor_\n    ) {\n        uint256 allowedTokensToSellLength = allowedTokensToSell_.length;\n        uint256 allowedTokensToBuyLength = allowedTokensToBuy_.length;\n\n        if (oracleRouter_ == address(0)) {\n            revert InvalidOracleRouterAddress(oracleRouter_);\n        }\n\n        if (allowedTokensToSellLength == 0) {\n            revert InvalidTokensToSellArrayLength();\n        }\n\n        if (allowedTokensToBuyLength == 0) {\n            revert InvalidTokensToBuyArrayLength();\n        }\n\n        ORACLE_ROUTER = IOracleRouter(oracleRouter_);\n        USE_ETH_ANCHOR = useEthAnchor_;\n        ROUTER_MAX_DECIMALS = uint8(IOracleRouter(oracleRouter_).MAX_DECIMALS());\n\n        for (uint256 i; i < allowedTokensToBuyLength; ) {\n            address token = allowedTokensToBuy_[i];\n\n            if (token == address(0)) {\n                revert InvalidAllowedTokenToBuy(token);\n            }\n\n            allowedTokensToBuy[token] = true;\n\n            emit AllowedTokenToBuyAdded(token);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < allowedTokensToSellLength; ) {\n            address token = allowedTokensToSell_[i];\n\n            if (token == address(0)) {\n                revert InvalidAllowedTokenToSell(token);\n            }\n\n            allowedTokensToSell[token] = true;\n\n            emit AllowedTokenToSellAdded(token);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // ==================== External View Functions ====================\n\n    /**\n     * @notice Calculates the expected amount of `tokenTo_` that one would receive for a given amount of `tokenFrom_`.\n     * @dev Uses the oracle router to get the current price relation between tokens and handles decimal scaling.\n     *\n     * @param tokenFrom_ The address of the token being sold.\n     * @param tokenTo_ The address of the token being bought.\n     * @param amountFrom_ The amount of `tokenFrom_` that is being sold.\n     * @return expectedOutputAmount The expected amount of `tokenTo_` that will be received.\n     */\n    function getExpectedOut(\n        address tokenFrom_,\n        address tokenTo_,\n        uint256 amountFrom_\n    ) external view returns (uint256 expectedOutputAmount) {\n        if (tokenFrom_ == tokenTo_) {\n            revert TokensCannotBeSame();\n        }\n\n        if (amountFrom_ == 0) {\n            revert InvalidAmount(amountFrom_);\n        }\n\n        if (amountFrom_ > type(uint128).max) {\n            revert AmountFromTooLarge(amountFrom_);\n        }\n\n        if (!allowedTokensToSell[tokenFrom_]) {\n            revert SellTokenNotAllowed(tokenFrom_);\n        }\n\n        if (!allowedTokensToBuy[tokenTo_]) {\n            revert BuyTokenNotAllowed(tokenTo_);\n        }\n\n        uint256 priceFrom;\n        uint256 priceTo;\n        uint8 decimalsOfSellToken;\n        uint8 decimalsOfBuyToken;\n\n        IOracleRouter.QuoteDenomination quote;\n\n        if (USE_ETH_ANCHOR) {\n            quote = IOracleRouter.QuoteDenomination.ETH;\n        } else {\n            quote = IOracleRouter.QuoteDenomination.USD;\n        }\n\n        (priceFrom, priceTo, decimalsOfSellToken, decimalsOfBuyToken) = ORACLE_ROUTER\n            .getPricesAndDecimals(tokenFrom_, tokenTo_, quote);\n\n        if (priceFrom == 0) {\n            if (USE_ETH_ANCHOR) {\n                revert PriceFromEthZero();\n            } else {\n                revert PriceFromUsdZero();\n            }\n        }\n\n        if (priceTo == 0) {\n            if (USE_ETH_ANCHOR) {\n                revert PriceToEthZero();\n            } else {\n                revert PriceToUsdZero();\n            }\n        }\n\n        bool sellHasMoreOrEqualDecimals = decimalsOfSellToken >= decimalsOfBuyToken;\n        uint8 decimalsDiff;\n\n        if (sellHasMoreOrEqualDecimals) {\n            decimalsDiff = decimalsOfSellToken - decimalsOfBuyToken;\n        } else {\n            decimalsDiff = decimalsOfBuyToken - decimalsOfSellToken;\n        }\n\n        if (decimalsDiff > ROUTER_MAX_DECIMALS) {\n            revert InvalidDecimalsDifference(decimalsDiff);\n        }\n\n        if (sellHasMoreOrEqualDecimals) {\n            if (decimalsDiff == 0) {\n                expectedOutputAmount = Math.mulDiv(amountFrom_, priceFrom, priceTo);\n            } else {\n                uint256 pow10 = 10 ** decimalsDiff;\n\n                // Pre-multiply overflow check: ensure priceTo * pow10 won't overflow.\n                if (pow10 > type(uint256).max / priceTo) {\n                    revert ScaledPriceOverflow();\n                }\n\n                unchecked {\n                    uint256 scaledPriceTo = priceTo * pow10;\n                    expectedOutputAmount = Math.mulDiv(amountFrom_, priceFrom, scaledPriceTo);\n                }\n            }\n        } else {\n            // Scale the input first to avoid overflow on multiplication by 10**diff.\n            uint256 pow10 = 10 ** decimalsDiff;\n            uint256 maxAmountFromBeforeScale = type(uint256).max / pow10;\n\n            if (amountFrom_ > maxAmountFromBeforeScale) {\n                revert AmountFromTooLarge(amountFrom_);\n            }\n\n            uint256 scaledAmountFrom = amountFrom_ * pow10;\n            expectedOutputAmount = Math.mulDiv(scaledAmountFrom, priceFrom, priceTo);\n        }\n    }\n}\n",
        "Stonks.sol": "// SPDX-FileCopyrightText: 2024 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport {Order} from \"./Order.sol\";\nimport {AssetRecoverer} from \"./AssetRecoverer.sol\";\nimport {IStonks} from \"./interfaces/IStonks.sol\";\nimport {IAmountConverter} from \"./interfaces/IAmountConverter.sol\";\nimport {IOracleRouter} from \"./interfaces/IOracleRouter.sol\";\n\n/**\n * @title Stonks Trading Management Contract\n * @dev Centralizes the management of CoW Swap trading orders, interfacing with the Order contract.\n *\n * Features:\n *  - Stores key trading parameters: token pair, margin, price tolerance and order duration in immutable variables.\n *  - Creates a minimum proxy from the Order contract and passes params for individual trades.\n *  - Provides asset recovery functionality.\n *  - Protected against reentrancy on order creation paths.\n *\n * @notice Orchestrates the setup and execution of trades on CoW Swap, utilizing Order contracts for each trade.\n */\ncontract Stonks is IStonks, AssetRecoverer, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    // ==================== Types ====================\n\n    /// @notice Struct containing all initialization parameters for the Stonks contract.\n    struct InitParams {\n        /// @notice Address of the Lido DAO agent.\n        address agent;\n        /// @notice Address of the manager authorized to place orders.\n        address manager;\n        /// @notice Address of the token being sold in trades.\n        address tokenFrom;\n        /// @notice Address of the token being bought in trades.\n        address tokenTo;\n        /// @notice Address of the AmountConverter contract used for price calculations.\n        address amountConverter;\n        /// @notice Address of the Order contract implementation used as a template for cloning.\n        address orderSample;\n        /// @notice Address of the OracleRouter contract.\n        address oracleRouter;\n        /// @notice Duration in seconds for which orders remain valid.\n        uint256 orderDurationInSeconds;\n        /// @notice Margin in basis points subtracted from expected output to account for fees and volatility.\n        uint256 marginInBasisPoints;\n        /// @notice Price tolerance in basis points allowed for price changes before order becomes invalid.\n        uint256 priceToleranceInBasisPoints;\n        /// @notice Maximum price improvement allowed in basis points (type(uint256).max = no cap, 0 = strict mode).\n        uint256 maxImprovementInBasisPoints;\n        /// @notice Whether orders should allow partial fills (useful for rebasable tokens).\n        bool allowPartialFill;\n    }\n\n    // ==================== Immutables ====================\n\n    /// @notice Address of the AmountConverter contract used for price calculations.\n    address public immutable AMOUNT_CONVERTER;\n    /// @notice Address of the Order contract implementation used as a template for cloning.\n    address public immutable ORDER_SAMPLE;\n    /// @notice Address of the token being sold in trades.\n    address public immutable TOKEN_FROM;\n    /// @notice Address of the token being bought in trades.\n    address public immutable TOKEN_TO;\n    /// @notice Duration in seconds for which orders remain valid.\n    uint256 public immutable ORDER_DURATION_IN_SECONDS;\n    /// @notice Margin in basis points subtracted from expected output to account for fees and volatility.\n    uint256 public immutable MARGIN_IN_BASIS_POINTS;\n    /// @notice Complement of margin in basis points (10000 - MARGIN_IN_BASIS_POINTS).\n    uint256 public immutable MARGIN_DIFFERENCE_IN_BASIS_POINTS;\n    /// @notice Price tolerance in basis points allowed for price changes before order becomes invalid.\n    uint256 public immutable PRICE_TOLERANCE_IN_BASIS_POINTS;\n    /// @notice Maximum price improvement allowed in basis points (type(uint256).max = no cap, 0 = strict mode).\n    uint256 public immutable MAX_IMPROVEMENT_IN_BASIS_POINTS;\n    /// @notice Whether orders should allow partial fills (useful for rebasable tokens).\n    bool public immutable ALLOW_PARTIAL_FILL;\n\n    /// @notice Oracle router contract used for quotability checks.\n    IOracleRouter public immutable ORACLE_ROUTER;\n\n    // ==================== Constants ====================\n\n    /// @notice Maximum basis points value (100%).\n    uint16 private constant MAX_BASIS_POINTS = 1e4;\n    /// @notice Upper limit for basis points parameters (10%).\n    uint16 private constant BASIS_POINTS_PARAMETERS_LIMIT = 1e3;\n    /// @notice Minimum possible balance for placing an order.\n    uint256 private constant MIN_POSSIBLE_BALANCE = 10;\n    /// @notice Minimum possible order duration in seconds.\n    uint256 private constant MIN_POSSIBLE_ORDER_DURATION_IN_SECONDS = 1 minutes;\n    /// @notice Maximum possible order duration in seconds.\n    uint256 private constant MAX_POSSIBLE_ORDER_DURATION_IN_SECONDS = 1 days;\n\n    // ==================== Events ====================\n\n    event AmountConverterSet(address amountConverter);\n    event OrderSampleSet(address orderSample);\n    event TokenFromSet(address tokenFrom);\n    event TokenToSet(address tokenTo);\n    event OrderDurationInSecondsSet(uint256 orderDurationInSeconds);\n    event MarginInBasisPointsSet(uint256 marginInBasisPoints);\n    event PriceToleranceInBasisPointsSet(uint256 priceToleranceInBasisPoints);\n    event OrderContractCreated(address indexed orderContract, uint256 minBuyAmount);\n    event OracleRouterSet(address oracleRouter);\n    event SignaturesPaused(address indexed by);\n    event SignaturesUnpaused(address indexed by);\n    event KillEngaged(address indexed by);\n\n    // ==================== Errors ====================\n\n    error InvalidManagerAddress(address manager);\n    error InvalidTokenFromAddress(address tokenFrom);\n    error InvalidTokenToAddress(address tokenTo);\n    error InvalidAmountConverterAddress(address amountConverter);\n    error InvalidOrderSampleAddress(address orderSample);\n    error InvalidOracleRouterAddress(address oracleRouter);\n    error TokensCannotBeSame();\n    error InvalidOrderDuration(uint256 min, uint256 max, uint256 received);\n    error MarginOverflowsAllowedLimit(uint256 limit, uint256 received);\n    error PriceToleranceOverflowsAllowedLimit(uint256 limit, uint256 received);\n    error MinimumPossibleBalanceNotMet(uint256 min, uint256 received);\n    error InvalidAmount(uint256 amount);\n    error SellAmountExceedsBalance(uint256 available, uint256 requested);\n    error StonksKilled();\n\n    // ==================== Emergency State ====================\n\n    bool private _signaturesPaused;\n    bool private _killed;\n\n    modifier notKilled() {\n        if (_killed) {\n            revert StonksKilled();\n        }\n        _;\n    }\n\n    // ==================== Constructor ====================\n\n    /**\n     * @notice Initializes the Stonks contract with key trading parameters.\n     * @param initParams_ Struct containing all initialization parameters.\n     * @dev Stores essential parameters for trade execution in immutable variables, ensuring consistency and security of trades.\n     */\n    constructor(InitParams memory initParams_) AssetRecoverer(initParams_.agent) {\n        _validateAddresses(\n            initParams_.manager,\n            initParams_.tokenFrom,\n            initParams_.tokenTo,\n            initParams_.amountConverter,\n            initParams_.orderSample,\n            initParams_.oracleRouter\n        );\n        _validateDurations(initParams_.orderDurationInSeconds);\n        _validateBps(\n            initParams_.marginInBasisPoints,\n            initParams_.priceToleranceInBasisPoints,\n            initParams_.maxImprovementInBasisPoints\n        );\n\n        manager = initParams_.manager;\n        ORDER_SAMPLE = initParams_.orderSample;\n        AMOUNT_CONVERTER = initParams_.amountConverter;\n        TOKEN_FROM = initParams_.tokenFrom;\n        TOKEN_TO = initParams_.tokenTo;\n        ORDER_DURATION_IN_SECONDS = initParams_.orderDurationInSeconds;\n        MARGIN_IN_BASIS_POINTS = initParams_.marginInBasisPoints;\n\n        unchecked {\n            MARGIN_DIFFERENCE_IN_BASIS_POINTS = MAX_BASIS_POINTS - MARGIN_IN_BASIS_POINTS;\n        }\n\n        PRICE_TOLERANCE_IN_BASIS_POINTS = initParams_.priceToleranceInBasisPoints;\n        MAX_IMPROVEMENT_IN_BASIS_POINTS = initParams_.maxImprovementInBasisPoints;\n        ALLOW_PARTIAL_FILL = initParams_.allowPartialFill;\n        ORACLE_ROUTER = IOracleRouter(initParams_.oracleRouter);\n\n        emit ManagerSet(initParams_.manager);\n        emit AmountConverterSet(initParams_.amountConverter);\n        emit OrderSampleSet(initParams_.orderSample);\n        emit TokenFromSet(initParams_.tokenFrom);\n        emit TokenToSet(initParams_.tokenTo);\n        emit OrderDurationInSecondsSet(initParams_.orderDurationInSeconds);\n        emit MarginInBasisPointsSet(initParams_.marginInBasisPoints);\n        emit PriceToleranceInBasisPointsSet(initParams_.priceToleranceInBasisPoints);\n        emit OracleRouterSet(initParams_.oracleRouter);\n    }\n\n    // ==================== External Functions ====================\n\n    /**\n     * @notice Initiates a new trading order by creating an Order contract clone with the current token balance.\n     * @dev Transfers the tokenFrom balance to the new Order instance and initializes it with the Stonks' manager settings for execution.\n     *      Protected against reentrancy attacks.\n     * @param minBuyAmount_ Minimum amount of tokenTo to be received as a result of the trade.\n     * @return Address of the newly created Order contract.\n     */\n    function placeOrder(\n        uint256 minBuyAmount_\n    ) external nonReentrant onlyAgentOrManager notKilled whenNotPaused returns (address) {\n        uint256 balance = IERC20(TOKEN_FROM).balanceOf(address(this));\n\n        return _placeOrder(balance, minBuyAmount_, balance);\n    }\n\n    /**\n     * @notice Initiates a new trading order by creating an Order contract clone with the specified sell amount.\n     * @dev Protected against reentrancy attacks.\n     * @param sellAmount_ Amount of `TOKEN_FROM` to transfer into the Order for this trade.\n     * @param minBuyAmount_ Minimum acceptable `TOKEN_TO` received.\n     */\n    function placeOrderWithAmount(\n        uint256 sellAmount_,\n        uint256 minBuyAmount_\n    ) external nonReentrant onlyAgentOrManager notKilled whenNotPaused returns (address) {\n        uint256 balance = IERC20(TOKEN_FROM).balanceOf(address(this));\n\n        return _placeOrder(sellAmount_, minBuyAmount_, balance);\n    }\n\n    // ==================== External View Functions ====================\n\n    /**\n     * @notice Estimates trade output based on current input token balance.\n     * @dev Uses current balance for output estimation via `estimateTradeOutput`.\n     * @return Estimated trade output amount.\n     */\n    function estimateTradeOutputFromCurrentBalance() external view returns (uint256) {\n        uint256 balance = IERC20(TOKEN_FROM).balanceOf(address(this));\n\n        return estimateTradeOutput(balance);\n    }\n\n    /**\n     * @notice Returns trading parameters from Stonks for use in the Order contract.\n     * @dev Facilitates gas efficiency by allowing Order to access existing parameters in Stonks without redundant storage.\n     * @return Tuple of order parameters (tokenFrom, tokenTo, orderDurationInSeconds).\n     */\n    function getOrderParameters() external view returns (address, address, uint256) {\n        return (TOKEN_FROM, TOKEN_TO, ORDER_DURATION_IN_SECONDS);\n    }\n\n    /**\n     * @notice Returns price tolerance parameter from Stonks for use in the Order contract.\n     * @dev Facilitates gas efficiency by allowing Order to access existing parameters in Stonks without redundant storage.\n     * @return Price tolerance in basis points.\n     */\n    function getPriceTolerance() external view returns (uint256) {\n        return PRICE_TOLERANCE_IN_BASIS_POINTS;\n    }\n\n    /**\n     * @notice Returns maximum price improvement parameter from Stonks for use in the Order contract.\n     * @dev Facilitates gas efficiency by allowing Order to access existing parameters in Stonks without redundant storage.\n     * @return Maximum improvement in basis points (type(uint256).max = no cap, 0 = strict mode).\n     */\n    function getMaxImprovementBps() external view returns (uint256) {\n        return MAX_IMPROVEMENT_IN_BASIS_POINTS;\n    }\n\n    /**\n     * @notice Asserts that a price path exists for the pair; used by Order to fail fast.\n     * @dev Reads via OracleRouter which reverts if a token is not configured or the bridge is missing.\n     */\n    function assertQuotable() external view {\n        ORACLE_ROUTER.getUsdPrices(TOKEN_FROM, TOKEN_TO); // reverts internally if unquotable\n    }\n\n    // ==================== Emergency Control Views ====================\n\n    function areSignaturesPaused() external view returns (bool) {\n        return _signaturesPaused;\n    }\n\n    function isCreationPaused() external view returns (bool) {\n        return paused();\n    }\n\n    function isKilled() external view returns (bool) {\n        return _killed;\n    }\n\n    // ==================== Emergency Admin Functions ====================\n\n    /**\n     * @notice Pause order creation. Does not affect recovery or existing orders' validation.\n     */\n    function pauseCreation() external onlyAgentOrManager {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause order creation. No effect if killSwitch was engaged.\n     */\n    function unpauseCreation() external onlyAgentOrManager {\n        _unpause();\n    }\n\n    /**\n     * @notice Pause signatures globally (halts fills).\n     */\n    function pauseSignatures() external onlyAgentOrManager {\n        if (_signaturesPaused) {\n            return;\n        }\n\n        _signaturesPaused = true;\n\n        emit SignaturesPaused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause signatures globally (resume fills).\n     */\n    function unpauseSignatures() external onlyAgentOrManager {\n        if (!_signaturesPaused) {\n            return;\n        }\n\n        _signaturesPaused = false;\n\n        emit SignaturesUnpaused(msg.sender);\n    }\n\n    /**\n     * @notice Engage irreversible kill switch: pauses creation, pauses signatures, marks killed.\n     */\n    function killSwitch() external onlyAgentOrManager {\n        // Set signatures paused if not already, emit telemetry when it changes\n        if (!_signaturesPaused) {\n            _signaturesPaused = true;\n\n            emit SignaturesPaused(msg.sender);\n        }\n        // Pause creation if not already paused\n        if (!paused()) {\n            _pause();\n        }\n\n        // Mark killed (irreversible)\n        if (!_killed) {\n            _killed = true;\n        }\n\n        emit KillEngaged(msg.sender);\n    }\n\n    // ==================== Public Functions ====================\n\n    /**\n     * @notice Estimates output amount for a given trade input amount.\n     * @param amount_ Input token amount for trade.\n     * @dev Uses token amount converter for output estimation.\n     * @return estimatedTradeOutput Estimated trade output amount.\n     * Subtracts the amount that corresponds to the margin parameter from the result obtained from the amount converter.\n     *\n     * |       estimatedTradeOutput        expectedBuyAmount\n     * |  --------------*--------------------------*-----------------> amount\n     * |                 <-------- margin -------->\n     *\n     * where:\n     *      expectedBuyAmount - amount received from the amountConverter based on Chainlink price feed.\n     *      margin - % taken from the expectedBuyAmount includes CoW Protocol fees and maximum accepted losses\n     *               to handle market volatility.\n     *      estimatedTradeOutput - expectedBuyAmount subtracted by the margin that is expected to be result of the trade.\n     */\n    function estimateTradeOutput(\n        uint256 amount_\n    ) public view returns (uint256 estimatedTradeOutput) {\n        if (amount_ == 0) {\n            revert InvalidAmount(amount_);\n        }\n\n        uint256 expectedBuyAmount = IAmountConverter(AMOUNT_CONVERTER).getExpectedOut(\n            TOKEN_FROM,\n            TOKEN_TO,\n            amount_\n        );\n\n        estimatedTradeOutput =\n            (expectedBuyAmount * MARGIN_DIFFERENCE_IN_BASIS_POINTS) /\n            MAX_BASIS_POINTS;\n    }\n\n    // ==================== Internal Functions ====================\n\n    function _placeOrder(\n        uint256 sellAmount_,\n        uint256 minBuyAmount_,\n        uint256 availableBalance_\n    ) internal returns (address) {\n        if (minBuyAmount_ == 0) {\n            revert InvalidAmount(minBuyAmount_);\n        }\n\n        if (sellAmount_ < MIN_POSSIBLE_BALANCE) {\n            revert MinimumPossibleBalanceNotMet(MIN_POSSIBLE_BALANCE, sellAmount_);\n        }\n\n        if (sellAmount_ > availableBalance_) {\n            revert SellAmountExceedsBalance(availableBalance_, sellAmount_);\n        }\n\n        Order orderCopy = Order(Clones.clone(ORDER_SAMPLE));\n\n        IERC20(TOKEN_FROM).safeTransfer(address(orderCopy), sellAmount_);\n        orderCopy.initialize(minBuyAmount_, manager);\n\n        emit OrderContractCreated(address(orderCopy), minBuyAmount_);\n\n        return address(orderCopy);\n    }\n\n    // ==================== Private Functions ====================\n\n    function _validateAddresses(\n        address manager_,\n        address tokenFrom_,\n        address tokenTo_,\n        address amountConverter_,\n        address orderSample_,\n        address oracleRouter_\n    ) private pure {\n        if (manager_ == address(0)) {\n            revert InvalidManagerAddress(manager_);\n        }\n\n        if (tokenFrom_ == address(0)) {\n            revert InvalidTokenFromAddress(tokenFrom_);\n        }\n\n        if (tokenTo_ == address(0)) {\n            revert InvalidTokenToAddress(tokenTo_);\n        }\n\n        if (tokenFrom_ == tokenTo_) {\n            revert TokensCannotBeSame();\n        }\n\n        if (amountConverter_ == address(0)) {\n            revert InvalidAmountConverterAddress(amountConverter_);\n        }\n\n        if (orderSample_ == address(0)) {\n            revert InvalidOrderSampleAddress(orderSample_);\n        }\n\n        if (oracleRouter_ == address(0)) {\n            revert InvalidOracleRouterAddress(oracleRouter_);\n        }\n    }\n\n    function _validateDurations(uint256 orderDurationInSeconds_) private pure {\n        if (\n            orderDurationInSeconds_ > MAX_POSSIBLE_ORDER_DURATION_IN_SECONDS ||\n            orderDurationInSeconds_ < MIN_POSSIBLE_ORDER_DURATION_IN_SECONDS\n        ) {\n            revert InvalidOrderDuration(\n                MIN_POSSIBLE_ORDER_DURATION_IN_SECONDS,\n                MAX_POSSIBLE_ORDER_DURATION_IN_SECONDS,\n                orderDurationInSeconds_\n            );\n        }\n    }\n\n    function _validateBps(\n        uint256 marginInBasisPoints_,\n        uint256 priceToleranceInBasisPoints_,\n        uint256 maxImprovementInBasisPoints_\n    ) private pure {\n        if (marginInBasisPoints_ > BASIS_POINTS_PARAMETERS_LIMIT) {\n            revert MarginOverflowsAllowedLimit(BASIS_POINTS_PARAMETERS_LIMIT, marginInBasisPoints_);\n        }\n\n        if (priceToleranceInBasisPoints_ > BASIS_POINTS_PARAMETERS_LIMIT) {\n            revert PriceToleranceOverflowsAllowedLimit(\n                BASIS_POINTS_PARAMETERS_LIMIT,\n                priceToleranceInBasisPoints_\n            );\n        }\n\n        if (\n            maxImprovementInBasisPoints_ != type(uint256).max &&\n            maxImprovementInBasisPoints_ > BASIS_POINTS_PARAMETERS_LIMIT\n        ) {\n            revert MarginOverflowsAllowedLimit(\n                BASIS_POINTS_PARAMETERS_LIMIT,\n                maxImprovementInBasisPoints_\n            );\n        }\n    }\n}\n",
        "Order.sol": "// SPDX-FileCopyrightText: 2024 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {GPv2Order} from \"./lib/GPv2Order.sol\";\nimport {AssetRecoverer} from \"./AssetRecoverer.sol\";\nimport {IStonks} from \"./interfaces/IStonks.sol\";\n\n/**\n * @title CoW Protocol Programmatic Order\n * @dev Handles the execution of individual trading order for the Stonks contract on CoW Protocol.\n *\n * Features:\n *  - Retrieves trade parameters from Stonks contract, ensuring alignment with the overall trading strategy.\n *  - Single-use design: each contract proxy is intended for one-time use, providing fresh settings for each trade.\n *  - Complies with ERC1271 for secure order validation.\n *  - Provides asset recovery functionality.\n *\n * @notice Serves as an execution module for CoW Protocol trades, operating under parameters set by the Stonks contract.\n */\ncontract Order is IERC1271, AssetRecoverer {\n    using GPv2Order for GPv2Order.Data;\n    using SafeERC20 for IERC20;\n\n    // ==================== Immutables ====================\n\n    /// @notice Address of the CoW Protocol relayer contract handling order execution.\n    address public immutable RELAYER;\n    /// @notice EIP-712 domain separator used for order signature validation.\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    // ==================== Constants ====================\n\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 private constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    /// @notice Minimum token balance required to perform recovery (prevents dust transfers).\n    uint256 private constant MIN_POSSIBLE_BALANCE = 10;\n    /// @notice Maximum basis points value for percentage calculations.\n    uint256 private constant MAX_BASIS_POINTS = 1e4;\n    /// @notice Price scaling factor for ratio calculations (1e18 matches router precision).\n    uint256 private constant PRICE_SCALE = 1e18;\n    /// @notice Application-specific data for the CoW order (empty JSON object hash).\n    bytes32 private constant APP_DATA = keccak256(\"{}\");\n\n    // ==================== Storage Variables ====================\n\n    /// @notice Amount of tokens to sell in the order.\n    uint256 private sellAmount;\n    /// @notice Minimum amount of tokens to buy in the order.\n    uint256 private buyAmount;\n    /// @notice Hash of the order for signature validation.\n    bytes32 private orderHash;\n    /// @notice Address of the Stonks contract that created this order.\n    address public stonks;\n    /// @notice Time until which the order is valid.\n    uint32 private validTo;\n    /// @notice Internal flag indicating whether the contract has been initialized.\n    bool private initialized;\n    /// @notice Whether this order allows partial fills (cached from Stonks to avoid external calls).\n    bool private allowPartialFill;\n    /// @notice Order cancellation flag.\n    bool private cancelled;\n\n    /// @notice Cached token addresses to avoid repeated external calls to Stonks.\n    address private tokenFrom;\n    address private tokenTo;\n\n    // ==================== Events ====================\n\n    event RelayerSet(address relayer);\n    event DomainSeparatorSet(bytes32 domainSeparator);\n    event OrderCreated(address indexed order, bytes32 orderHash, GPv2Order.Data orderData);\n    event OrderCancelledEvent(address indexed order);\n    event RelayerAllowanceRevokedEvent(address indexed order);\n    event OrderFundsReturnedEvent(address indexed order, uint256 amount);\n\n    // ==================== Errors ====================\n\n    error OrderAlreadyInitialized();\n    error OrderExpired(uint256 validTo);\n    error InvalidAmountToRecover(uint256 amount);\n    error CannotRecoverTokenFrom(address token);\n    error InvalidOrderHash(bytes32 expected, bytes32 actual);\n    error OrderNotExpired(uint256 validTo, uint256 currentTimestamp);\n    error PriceImprovementExceedsLimit(uint256 maxAllowedBuyAmount, uint256 actualBuyAmount);\n    error PriceImprovementRejectedInStrictMode(uint256 expectedBuyAmount, uint256 actualBuyAmount);\n    error PriceShortfallExceedsTolerance(uint256 minAcceptableBuyAmount, uint256 actualBuyAmount);\n    error InsufficientSellBalance(uint256 required, uint256 available);\n    error ZeroQuotableAmount(uint256 basisSellAmount);\n    error SignaturesGloballyPaused();\n    error OrderCancelled();\n    error NotInitialized();\n\n    // ==================== Constructor ====================\n\n    /**\n     * @param agent_ The agent's address with control over the contract.\n     * @param relayer_ The address of the relayer handling orders.\n     * @param domainSeparator_ The EIP-712 domain separator to use.\n     * @dev This constructor sets up necessary parameters and state variables to enable the contract's interaction with the CoW Protocol.\n     * @dev It also marks the contract as initialized to prevent unauthorized re-initialization.\n     */\n    constructor(address agent_, address relayer_, bytes32 domainSeparator_) AssetRecoverer(agent_) {\n        // Immutable parameters are captured at deployment time. When used with minimal proxies,\n        // these retain values baked into the original implementation.\n        RELAYER = relayer_;\n        DOMAIN_SEPARATOR = domainSeparator_;\n\n        // Prevents accidental initialization on the implementation itself.\n        initialized = true;\n\n        emit RelayerSet(relayer_);\n        emit DomainSeparatorSet(domainSeparator_);\n    }\n\n    // ==================== External Functions ====================\n\n    /**\n     * @notice Initializes the contract for trading by defining order parameters and approving tokens.\n     * @param minBuyAmount_ The minimum accepted trade outcome.\n     * @param manager_ The manager's address to be set for the contract.\n     * @dev Pulls pair params from Stonks, asserts a quotable price path up front, computes amounts, and arms allowance.\n     */\n    function initialize(uint256 minBuyAmount_, address manager_) external {\n        if (initialized) {\n            revert OrderAlreadyInitialized();\n        }\n\n        initialized = true;\n        stonks = msg.sender;\n        manager = manager_;\n\n        IStonks stonksContract = IStonks(stonks);\n        (\n            address tokenFromLocal,\n            address tokenToLocal,\n            uint256 orderDurationInSeconds\n        ) = stonksContract.getOrderParameters();\n\n        // Fail-fast if either side lacks a valid oracle route (prevents stranded approvals/funds).\n        stonksContract.assertQuotable();\n\n        tokenFrom = tokenFromLocal;\n        tokenTo = tokenToLocal;\n\n        validTo = uint32(block.timestamp + orderDurationInSeconds);\n\n        IERC20Metadata tokenFromErc = IERC20Metadata(tokenFromLocal);\n        IERC20Metadata tokenToErc = IERC20Metadata(tokenToLocal);\n\n        sellAmount = tokenFromErc.balanceOf(address(this));\n\n        // Floor for the CoW order; Stonks uses router-based any-to-any quoting.\n        uint256 estimatedOut = stonksContract.estimateTradeOutput(sellAmount);\n        if (estimatedOut >= minBuyAmount_) {\n            buyAmount = estimatedOut;\n        } else {\n            buyAmount = minBuyAmount_;\n        }\n\n        allowPartialFill = stonksContract.ALLOW_PARTIAL_FILL();\n\n        GPv2Order.Data memory order = GPv2Order.Data({\n            sellToken: tokenFromErc,\n            buyToken: tokenToErc,\n            receiver: AGENT,\n            sellAmount: sellAmount,\n            buyAmount: buyAmount,\n            validTo: validTo,\n            appData: APP_DATA,\n            // Zero-fee → limit order semantics per CoW; solver pays gas via surplus.\n            feeAmount: 0,\n            kind: GPv2Order.KIND_SELL,\n            partiallyFillable: allowPartialFill,\n            sellTokenBalance: GPv2Order.BALANCE_ERC20,\n            buyTokenBalance: GPv2Order.BALANCE_ERC20\n        });\n        orderHash = order.hash(DOMAIN_SEPARATOR);\n\n        // Single-use proxy: set max approval to avoid a second transaction for allowance management.\n        IERC20(tokenFromLocal).forceApprove(RELAYER, type(uint256).max);\n\n        emit OrderCreated(address(this), orderHash, order);\n    }\n\n    // ==================== External View Functions ====================\n\n    /**\n     * @notice Validates the order's signature and ensures compliance with price and timing constraints.\n     * @param hash_ The hash of the order for validation.\n     * @return magicValue The magic value of ERC1271.\n     * @dev For partially fillable orders, validates price pro-rata to the currently available balance\n     *      using price ratios to ensure consistent validation at all sizes and prevent rounding issues.\n     * @dev Price validation uses 1e18-scaled ratios to maintain precision across different token decimals\n     *      and handle dust amounts without special cases.\n     */\n    function isValidSignature(\n        bytes32 hash_,\n        bytes calldata\n    ) external view returns (bytes4 magicValue) {\n        if (hash_ != orderHash) {\n            revert InvalidOrderHash(orderHash, hash_);\n        }\n\n        if (validTo < block.timestamp) {\n            revert OrderExpired(validTo);\n        }\n\n        IStonks stonksContract = IStonks(stonks);\n        // Check per-order cancellation before global pause\n        if (cancelled) {\n            revert OrderCancelled();\n        }\n\n        // Global signatures pause handled by Stonks\n        if (stonksContract.areSignaturesPaused()) {\n            revert SignaturesGloballyPaused();\n        }\n\n        uint256 availableBalance = IERC20(tokenFrom).balanceOf(address(this));\n\n        if (!allowPartialFill) {\n            if (availableBalance < sellAmount) {\n                revert InsufficientSellBalance(sellAmount, availableBalance);\n            }\n        }\n\n        // Determine the basis sell amount for price validation\n        uint256 basisSellAmount = allowPartialFill\n            ? (availableBalance < sellAmount ? availableBalance : sellAmount)\n            : sellAmount;\n\n        if (basisSellAmount == 0) {\n            revert InsufficientSellBalance(1, availableBalance);\n        }\n\n        uint256 currentEstimatedBuyAmount = stonksContract.estimateTradeOutput(basisSellAmount);\n\n        if (currentEstimatedBuyAmount == 0) {\n            revert ZeroQuotableAmount(basisSellAmount);\n        }\n\n        // Pro-rate the original buyAmount to the basis sell amount\n        uint256 baselineBuyAmount = Math.mulDiv(buyAmount, basisSellAmount, sellAmount);\n\n        // Fast path: exact amount match avoids rounding issues in price ratio comparison\n        if (currentEstimatedBuyAmount == baselineBuyAmount) {\n            return ERC1271_MAGIC_VALUE;\n        }\n\n        // Compute prices scaled to 1e18 for ratio comparison\n        uint256 originalLimitPrice = Math.mulDiv(buyAmount, PRICE_SCALE, sellAmount);\n        uint256 currentExecutionPrice = Math.mulDiv(\n            currentEstimatedBuyAmount,\n            PRICE_SCALE,\n            basisSellAmount\n        );\n\n        // Guard against division by zero in BPS calculations\n        if (originalLimitPrice == 0) {\n            revert PriceShortfallExceedsTolerance(baselineBuyAmount, currentEstimatedBuyAmount);\n        }\n\n        // Fast path: exact price match (handles cases where amounts differ due to rounding but prices match)\n        if (currentExecutionPrice == originalLimitPrice) {\n            return ERC1271_MAGIC_VALUE;\n        }\n\n        if (currentExecutionPrice > originalLimitPrice) {\n            uint256 maxImprovementBps = stonksContract.getMaxImprovementBps();\n\n            if (maxImprovementBps == type(uint256).max) {\n                return ERC1271_MAGIC_VALUE;\n            }\n\n            if (maxImprovementBps == 0) {\n                revert PriceImprovementRejectedInStrictMode(\n                    baselineBuyAmount,\n                    currentEstimatedBuyAmount\n                );\n            }\n\n            unchecked {\n                // Calculate improvement in basis points: (currentPrice - originalPrice) / originalPrice\n                uint256 improvementBps = Math.mulDiv(\n                    currentExecutionPrice - originalLimitPrice,\n                    MAX_BASIS_POINTS,\n                    originalLimitPrice\n                );\n\n                if (improvementBps > maxImprovementBps) {\n                    uint256 maxAllowedBuyAmount = Math.mulDiv(\n                        baselineBuyAmount,\n                        MAX_BASIS_POINTS + maxImprovementBps,\n                        MAX_BASIS_POINTS\n                    );\n                    revert PriceImprovementExceedsLimit(\n                        maxAllowedBuyAmount,\n                        currentEstimatedBuyAmount\n                    );\n                }\n            }\n\n            return ERC1271_MAGIC_VALUE;\n        } else {\n            uint256 priceToleranceBps = stonksContract.getPriceTolerance();\n\n            if (priceToleranceBps == 0) {\n                revert PriceShortfallExceedsTolerance(baselineBuyAmount, currentEstimatedBuyAmount);\n            }\n\n            if (priceToleranceBps > MAX_BASIS_POINTS) {\n                revert PriceShortfallExceedsTolerance(baselineBuyAmount, currentEstimatedBuyAmount);\n            }\n\n            unchecked {\n                // Calculate shortfall in basis points: (originalPrice - currentPrice) / originalPrice\n                uint256 shortfallBps = Math.mulDiv(\n                    originalLimitPrice - currentExecutionPrice,\n                    MAX_BASIS_POINTS,\n                    originalLimitPrice\n                );\n\n                if (shortfallBps > priceToleranceBps) {\n                    uint256 maxToleratedShortfall = Math.mulDiv(\n                        baselineBuyAmount,\n                        priceToleranceBps,\n                        MAX_BASIS_POINTS\n                    );\n                    uint256 minAcceptableBuyAmount = baselineBuyAmount - maxToleratedShortfall;\n                    revert PriceShortfallExceedsTolerance(\n                        minAcceptableBuyAmount,\n                        currentEstimatedBuyAmount\n                    );\n                }\n            }\n\n            return ERC1271_MAGIC_VALUE;\n        }\n    }\n\n    /**\n     * @notice Retrieves the details of the placed order.\n     * @return hash_ The hash of the order.\n     * @return tokenFrom_ The address of the token being sold.\n     * @return tokenTo_ The address of the token being bought.\n     * @return sellAmount_ The amount of `tokenFrom_` that is being sold.\n     * @return buyAmount_ The amount of `tokenTo_` that is expected to be bought.\n     * @return validTo_ The timestamp until which the order remains valid.\n     */\n    function getOrderDetails()\n        external\n        view\n        returns (\n            bytes32 hash_,\n            address tokenFrom_,\n            address tokenTo_,\n            uint256 sellAmount_,\n            uint256 buyAmount_,\n            uint32 validTo_\n        )\n    {\n        return (orderHash, tokenFrom, tokenTo, sellAmount, buyAmount, validTo);\n    }\n\n    /**\n     * @notice Allows to return tokens if the order has expired.\n     * @dev Can only be called if the order's validity period has passed.\n     */\n    function recoverTokenFrom() external {\n        uint256 currentTimestamp = block.timestamp;\n\n        if (validTo >= currentTimestamp) {\n            revert OrderNotExpired(validTo, currentTimestamp);\n        }\n\n        IERC20 tokenFromErc = IERC20(tokenFrom);\n        uint256 balance = tokenFromErc.balanceOf(address(this));\n\n        // Prevents dust transfers to avoid rounding issues for rebasable tokens like stETH.\n        if (balance < MIN_POSSIBLE_BALANCE) {\n            revert InvalidAmountToRecover(balance);\n        }\n\n        tokenFromErc.safeTransfer(stonks, balance);\n    }\n\n    // ==================== Public Functions ====================\n\n    /**\n     * @notice Facilitates the recovery of ERC20 tokens from the contract, except for the token involved in the order.\n     * @param token_ The address of the token to recover.\n     * @param amount_ The amount of the token to recover.\n     * @dev Can only be called by the agent or manager of the contract. This is a safety feature to prevent accidental token loss.\n     */\n    function recoverERC20(address token_, uint256 amount_) public override onlyAgentOrManager {\n        address tokenFromLocal = tokenFrom;\n\n        if (tokenFromLocal == address(0)) {\n            (tokenFromLocal, , ) = IStonks(stonks).getOrderParameters();\n        }\n\n        if (token_ == tokenFromLocal) {\n            revert CannotRecoverTokenFrom(tokenFromLocal);\n        }\n\n        AssetRecoverer.recoverERC20(token_, amount_);\n    }\n\n    // ==================== Emergency State & Admin ====================\n\n    /**\n     * @notice Cancels this order and returns all `tokenFrom` back to Stonks. Also revokes relayer allowance.\n     *         Idempotent: repeated calls have no adverse effect.\n     */\n    function emergencyCancelAndReturn() external onlyAgentOrManager {\n        _ensureInitialized();\n        if (!cancelled) {\n            cancelled = true;\n\n            emit OrderCancelledEvent(address(this));\n        }\n\n        _revokeRelayerAllowance();\n        _returnAllTokenFromToStonks();\n    }\n\n    /**\n     * @notice Revokes relayer allowance without moving funds.\n     *         Idempotent and callable by Manager/Agent.\n     */\n    function emergencyRevokeRelayer() external onlyAgentOrManager {\n        _ensureInitialized();\n        _revokeRelayerAllowance();\n    }\n\n    function _ensureInitialized() private view {\n        if (stonks == address(0) || tokenFrom == address(0)) {\n            revert NotInitialized();\n        }\n    }\n\n    function _revokeRelayerAllowance() private {\n        IERC20 tokenFromErc = IERC20(tokenFrom);\n\n        uint256 beforeAllowance = tokenFromErc.allowance(address(this), RELAYER);\n        tokenFromErc.forceApprove(RELAYER, 0);\n\n        if (beforeAllowance != 0) {\n            emit RelayerAllowanceRevokedEvent(address(this));\n        }\n    }\n\n    function _returnAllTokenFromToStonks() private {\n        IERC20 tokenFromErc = IERC20(tokenFrom);\n        uint256 balance = tokenFromErc.balanceOf(address(this));\n\n        if (balance > 0) {\n            tokenFromErc.safeTransfer(stonks, balance);\n\n            emit OrderFundsReturnedEvent(address(this), balance);\n        }\n    }\n}\n",
        "OracleRouter.sol": "// SPDX-FileCopyrightText: 2024 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {Ownable} from \"../Ownable.sol\";\nimport {IOracleRouter} from \"../interfaces/IOracleRouter.sol\";\nimport {IFeedRegistry} from \"../interfaces/IFeedRegistry.sol\";\n\n/**\n * @title OracleRouter\n * @notice Price router based on Chainlink Feed Registry with two hop options:\n *         - TOKEN/USD (preferred), or\n *         - TOKEN/ETH bridged via ETH/USD.\n *         All outputs are normalized to PRICE_UNIT (10 ** PRICE_DECIMALS).\n */\ncontract OracleRouter is IOracleRouter, Ownable {\n    // ==================== Immutables ====================\n\n    /// @notice Number of decimals used for price normalization (typically 8 or 18).\n    uint8 public immutable PRICE_DECIMALS;\n    /// @notice Price unit calculated as 10 ** PRICE_DECIMALS.\n    uint256 public immutable PRICE_UNIT;\n    /// @notice Address of the Chainlink Feed Registry contract.\n    address public immutable FEED_REGISTRY;\n\n    // ==================== Constants ====================\n\n    /// @notice Address representing USD denomination in Chainlink Feed Registry.\n    address private constant USD_DENOMINATION = 0x0000000000000000000000000000000000000348;\n    /// @notice Address representing ETH denomination in Chainlink Feed Registry.\n    address private constant ETH_DENOMINATION = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Maximum supported decimals for feeds and tokens.\n    uint128 public constant MAX_DECIMALS = 38;\n\n    // ==================== Type Definitions ====================\n\n    struct FeedConfig {\n        address aggregator;\n        uint128 scaleNumerator;\n        uint128 scaleDenominator;\n        uint32 maxStalenessSeconds;\n        uint8 aggregatorDecimals;\n    }\n\n    struct TokenConfig {\n        IOracleRouter.QuoteDenomination primaryQuote;\n        FeedConfig primaryFeed;\n        uint8 tokenDecimals;\n        bool isActive;\n        uint32 ethUsdMaxStalenessOverrideSeconds; // 0 => use global bridge staleness\n    }\n\n    struct BridgeCache {\n        uint256 price;\n        uint32 capSeconds;\n    }\n\n    // ==================== Storage Variables ====================\n\n    /// @notice Mapping from token address to its price feed configuration.\n    mapping(address => TokenConfig) public tokenConfig;\n    /// @notice Configuration for the ETH/USD bridge feed used for tokens quoted in ETH.\n    FeedConfig public ethUsdBridge;\n\n    // ==================== Events ====================\n\n    event TokenConfigured(\n        address indexed token,\n        IOracleRouter.QuoteDenomination primaryQuote,\n        address indexed aggregator,\n        uint8 aggregatorDecimals,\n        uint32 maxStalenessSeconds,\n        uint8 tokenDecimals,\n        uint128 scaleNumerator,\n        uint128 scaleDenominator,\n        bool isActive\n    );\n    event TokenActiveUpdated(address indexed token, bool isActive);\n    event EthUsdBridgeConfigured(\n        address indexed aggregator,\n        uint8 aggregatorDecimals,\n        uint32 maxStalenessSeconds,\n        uint128 scaleNumerator,\n        uint128 scaleDenominator\n    );\n    event TokenEthUsdStalenessOverridden(address indexed token, uint32 overrideSeconds);\n\n    // ==================== Errors ====================\n\n    error InvalidFeedRegistryAddress(address feedRegistry);\n    error InvalidTokenAddress(address token);\n    error InvalidStaleness();\n    error InvalidAggregatorDecimals();\n    error InvalidUnitDecimals();\n    error InvalidTokenDecimals();\n    error TokenNotConfigured(address token);\n    error TokenDecimalsMismatch(uint8 erc20Decimals, uint8 providedDecimals);\n    error TokenStateUnchanged(address token, bool currentState);\n    error EthUsdBridgeMissing();\n    error FeedMissing(address base, address quote);\n    error FeedConfigOutOfSync(\n        address expectedAggregator,\n        address actualAggregator,\n        uint8 expectedDecimals,\n        uint8 actualDecimals\n    );\n    error OracleStale(address aggregator, uint256 lastUpdate);\n    error OracleBadAnswer(address aggregator, int256 answer);\n    error OracleUnanswered(address aggregator, uint80 roundId, uint80 answeredInRound);\n    error OracleQuantizedToZero(address aggregator, uint8 feedDecimals, uint8 unitDecimals);\n\n    // ==================== Constructor ====================\n\n    /**\n     * @notice Constructor\n     * @param agent_ Address of the owner agent.\n     * @param unitDecimals_ Number of decimals for price normalization.\n     * @param feedRegistry_ Address of the Chainlink Feed Registry.\n     */\n    constructor(address agent_, uint8 unitDecimals_, address feedRegistry_) Ownable(agent_) {\n        if (unitDecimals_ == 0 || unitDecimals_ > MAX_DECIMALS) {\n            revert InvalidUnitDecimals();\n        }\n\n        if (feedRegistry_ == address(0)) {\n            revert InvalidFeedRegistryAddress(feedRegistry_);\n        }\n\n        FEED_REGISTRY = feedRegistry_;\n        PRICE_DECIMALS = unitDecimals_;\n\n        unchecked {\n            PRICE_UNIT = 10 ** unitDecimals_;\n        }\n    }\n\n    // ==================== External Functions ====================\n\n    /**\n     * @notice Sets the ETH/USD bridge configuration for token price routing.\n     * @param maxStalenessSeconds_ Maximum allowed staleness for ETH/USD price feed.\n     */\n    function setEthUsdBridge(uint32 maxStalenessSeconds_) external onlyAgentOrManager {\n        if (maxStalenessSeconds_ == 0) {\n            revert InvalidStaleness();\n        }\n\n        _updateEthUsdBridge(maxStalenessSeconds_);\n    }\n\n    /**\n     * @notice Synchronizes the ETH/USD bridge configuration with current feed registry state.\n     * @dev Preserves the existing staleness threshold while updating feed metadata.\n     */\n    function syncEthUsdBridge() external onlyAgentOrManager {\n        _updateEthUsdBridge(ethUsdBridge.maxStalenessSeconds);\n    }\n\n    /**\n     * @notice Sets the feed configuration for a token.\n     * @param token_ Address of the token to configure.\n     * @param primaryQuote_ Primary quote denomination (USD or ETH).\n     * @param maxStalenessSeconds_ Maximum allowed staleness for the price feed.\n     * @param tokenDecimals_ Number of decimals for the token.\n     * @param isActive_ Whether the token should be active for price queries.\n     */\n    function setTokenFeed(\n        address token_,\n        IOracleRouter.QuoteDenomination primaryQuote_,\n        uint32 maxStalenessSeconds_,\n        uint8 tokenDecimals_,\n        bool isActive_\n    ) external onlyAgentOrManager {\n        _setTokenFeed(token_, primaryQuote_, maxStalenessSeconds_, tokenDecimals_, isActive_);\n    }\n\n    /**\n     * @notice Sets a custom staleness override for ETH/USD bridge when used for a specific token.\n     * @param token_ Address of the token to configure.\n     * @param overrideSeconds_ Custom staleness threshold for this token's ETH/USD bridge usage.\n     */\n    function setTokenEthUsdStalenessOverride(\n        address token_,\n        uint32 overrideSeconds_\n    ) external onlyAgentOrManager {\n        if (token_ == address(0)) {\n            revert InvalidTokenAddress(token_);\n        }\n\n        tokenConfig[token_].ethUsdMaxStalenessOverrideSeconds = overrideSeconds_;\n\n        emit TokenEthUsdStalenessOverridden(token_, overrideSeconds_);\n    }\n\n    /**\n     * @notice Sets the active status of a token configuration.\n     * @param token_ Address of the token to configure.\n     * @param isActive_ Whether the token should be active for price queries.\n     */\n    function setTokenActive(address token_, bool isActive_) external onlyAgentOrManager {\n        if (token_ == address(0)) {\n            revert InvalidTokenAddress(token_);\n        }\n\n        TokenConfig storage config = tokenConfig[token_];\n\n        if (config.isActive == isActive_) {\n            revert TokenStateUnchanged(token_, config.isActive);\n        }\n\n        if (isActive_) {\n            if (config.tokenDecimals == 0) {\n                revert TokenNotConfigured(token_);\n            }\n        }\n\n        config.isActive = isActive_;\n        emit TokenActiveUpdated(token_, isActive_);\n    }\n\n    /**\n     * @notice Synchronizes a token's feed configuration with current feed registry state.\n     * @param token_ Address of the token to synchronize.\n     */\n    function syncTokenFeed(address token_) external onlyAgentOrManager {\n        TokenConfig storage config = tokenConfig[token_];\n\n        if (config.tokenDecimals == 0) {\n            revert TokenNotConfigured(token_);\n        }\n\n        address quote;\n        if (config.primaryQuote == IOracleRouter.QuoteDenomination.USD) {\n            quote = USD_DENOMINATION;\n        } else {\n            quote = ETH_DENOMINATION;\n        }\n\n        (\n            address aggregator,\n            uint8 decimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        ) = _resolveFeedAndScale(token_, quote);\n\n        FeedConfig storage primaryFeed = config.primaryFeed;\n        primaryFeed.aggregator = aggregator;\n        primaryFeed.aggregatorDecimals = decimals;\n        primaryFeed.scaleNumerator = scaleNumerator;\n        primaryFeed.scaleDenominator = scaleDenominator;\n\n        emit TokenConfigured(\n            token_,\n            config.primaryQuote,\n            aggregator,\n            decimals,\n            primaryFeed.maxStalenessSeconds,\n            config.tokenDecimals,\n            scaleNumerator,\n            scaleDenominator,\n            config.isActive\n        );\n    }\n\n    // ==================== External View Functions ====================\n\n    /**\n     * @notice Gets USD prices for two tokens.\n     * @param baseToken_ Address of the base token.\n     * @param quoteToken_ Address of the quote token.\n     * @return baseUsdPrice USD price of the base token.\n     * @return quoteUsdPrice USD price of the quote token.\n     */\n    function getUsdPrices(\n        address baseToken_,\n        address quoteToken_\n    ) external view returns (uint256 baseUsdPrice, uint256 quoteUsdPrice) {\n        return _getUsdPrices(baseToken_, quoteToken_);\n    }\n\n    /**\n     * @notice Gets prices and decimal places for two tokens in the requested quote denomination.\n     * @dev Tokens can have different primary quote denominations (USD or ETH). If a token's\n     *      primary quote doesn't match the requested quote, the price will be bridged through\n     *      ETH/USD to convert to the requested denomination.\n     * @param baseToken_ Address of the base token.\n     * @param quoteToken_ Address of the quote token.\n     * @param quote_ Requested quote denomination (USD or ETH) for the returned prices.\n     * @return basePrice Price of the base token in the requested quote (normalized to PRICE_UNIT).\n     * @return quotePrice Price of the quote token in the requested quote (normalized to PRICE_UNIT).\n     * @return baseTokenDecimals Number of decimals for the base token.\n     * @return quoteTokenDecimals Number of decimals for the quote token.\n     */\n    function getPricesAndDecimals(\n        address baseToken_,\n        address quoteToken_,\n        IOracleRouter.QuoteDenomination quote_\n    )\n        external\n        view\n        returns (\n            uint256 basePrice,\n            uint256 quotePrice,\n            uint8 baseTokenDecimals,\n            uint8 quoteTokenDecimals\n        )\n    {\n        TokenConfig storage baseConfig = tokenConfig[baseToken_];\n        baseTokenDecimals = baseConfig.tokenDecimals;\n\n        if (!baseConfig.isActive || baseTokenDecimals == 0) {\n            revert TokenNotConfigured(baseToken_);\n        }\n\n        TokenConfig storage quoteConfig = tokenConfig[quoteToken_];\n        quoteTokenDecimals = quoteConfig.tokenDecimals;\n\n        if (!quoteConfig.isActive || quoteTokenDecimals == 0) {\n            revert TokenNotConfigured(quoteToken_);\n        }\n\n        BridgeCache memory sharedBridge = _sharedBridgeIfSameCap(\n            baseConfig.primaryQuote != quote_,\n            quoteConfig.primaryQuote != quote_,\n            baseConfig,\n            quoteConfig\n        );\n\n        // Get prices in the requested quote denomination, bridging through ETH/USD if needed\n        basePrice = _getPriceInQuote(baseToken_, baseConfig, quote_, sharedBridge);\n        quotePrice = _getPriceInQuote(quoteToken_, quoteConfig, quote_, sharedBridge);\n    }\n\n    /**\n     * @notice Checks if the ETH/USD bridge configuration is synchronized with the feed registry.\n     * @return True if the bridge configuration matches the current feed registry state.\n     */\n    function isBridgeInSync() external view returns (bool) {\n        (address aggregator, uint8 decimals) = _currentFeedMeta(ETH_DENOMINATION, USD_DENOMINATION);\n        FeedConfig storage bridge = ethUsdBridge;\n\n        return (aggregator == bridge.aggregator && decimals == bridge.aggregatorDecimals);\n    }\n\n    /**\n     * @notice Checks if a token's feed configuration is synchronized with the feed registry.\n     * @param token_ Address of the token to check.\n     * @return True if the token configuration matches the current feed registry state.\n     */\n    function isFeedInSync(address token_) external view returns (bool) {\n        TokenConfig storage configEntry = tokenConfig[token_];\n\n        if (configEntry.tokenDecimals == 0) {\n            return false;\n        }\n\n        address quote;\n        if (configEntry.primaryQuote == IOracleRouter.QuoteDenomination.USD) {\n            quote = USD_DENOMINATION;\n        } else {\n            quote = ETH_DENOMINATION;\n        }\n\n        (address aggregator, uint8 decimals) = _currentFeedMeta(token_, quote);\n\n        return (aggregator == configEntry.primaryFeed.aggregator &&\n            decimals == configEntry.primaryFeed.aggregatorDecimals);\n    }\n\n    // ==================== Internal Functions ====================\n\n    /**\n     * @dev Updates ETH/USD bridge configuration. Consolidates logic for setEthUsdBridge and syncEthUsdBridge.\n     * @param maxStalenessSeconds_ Maximum allowed staleness for ETH/USD price feed.\n     */\n    function _updateEthUsdBridge(uint32 maxStalenessSeconds_) internal {\n        (\n            address aggregator,\n            uint8 decimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        ) = _resolveFeedAndScale(ETH_DENOMINATION, USD_DENOMINATION);\n\n        ethUsdBridge = FeedConfig({\n            aggregator: aggregator,\n            maxStalenessSeconds: maxStalenessSeconds_,\n            aggregatorDecimals: decimals,\n            scaleNumerator: scaleNumerator,\n            scaleDenominator: scaleDenominator\n        });\n\n        emit EthUsdBridgeConfigured(\n            aggregator,\n            decimals,\n            maxStalenessSeconds_,\n            scaleNumerator,\n            scaleDenominator\n        );\n    }\n\n    /**\n     * @dev Gets USD price for a token, optionally reusing a shared ETH/USD bridge price.\n     * @param token_ Address of the token to price.\n     * @param config_ Token configuration.\n     * @param sharedBridge_ Cached ETH/USD bridge price and cap (if available).\n     * @return price USD price of the token, normalized to PRICE_UNIT.\n     */\n    function _getUsdPrice(\n        address token_,\n        TokenConfig storage config_,\n        BridgeCache memory sharedBridge_\n    ) internal view returns (uint256 price) {\n        if (!config_.isActive || config_.tokenDecimals == 0) {\n            revert TokenNotConfigured(token_);\n        }\n\n        return\n            _getPriceInQuote(token_, config_, IOracleRouter.QuoteDenomination.USD, sharedBridge_);\n    }\n\n    /**\n     * @dev Gets USD prices for two tokens with gas optimization for shared ETH/USD bridge.\n     * When both tokens are ETH-quoted with same staleness cap, fetches ETH/USD once.\n     */\n    function _getUsdPrices(\n        address baseToken_,\n        address quoteToken_\n    ) internal view returns (uint256 baseUsdPrice, uint256 quoteUsdPrice) {\n        TokenConfig storage baseConfig = tokenConfig[baseToken_];\n        TokenConfig storage quoteConfig = tokenConfig[quoteToken_];\n\n        BridgeCache memory sharedBridge = _sharedBridgeIfSameCap(\n            baseConfig.primaryQuote == IOracleRouter.QuoteDenomination.ETH,\n            quoteConfig.primaryQuote == IOracleRouter.QuoteDenomination.ETH,\n            baseConfig,\n            quoteConfig\n        );\n\n        baseUsdPrice = _getUsdPrice(baseToken_, baseConfig, sharedBridge);\n        quoteUsdPrice = _getUsdPrice(quoteToken_, quoteConfig, sharedBridge);\n    }\n\n    function _sharedBridgeIfSameCap(\n        bool firstNeedsBridge_,\n        bool secondNeedsBridge_,\n        TokenConfig storage firstConfig_,\n        TokenConfig storage secondConfig_\n    ) internal view returns (BridgeCache memory cache) {\n        if (!firstNeedsBridge_ || !secondNeedsBridge_) {\n            return cache;\n        }\n\n        uint32 firstCap = _effectiveEthUsdStaleness(firstConfig_);\n        uint32 secondCap = _effectiveEthUsdStaleness(secondConfig_);\n\n        if (firstCap != secondCap) {\n            return cache;\n        }\n\n        uint256 price = _readEthUsdWithCap(firstCap);\n\n        if (price == 0) {\n            return cache;\n        }\n\n        cache = BridgeCache({price: price, capSeconds: firstCap});\n    }\n\n    function _readEthUsdWithCap(uint32 capSeconds_) internal view returns (uint256) {\n        FeedConfig storage bridge = ethUsdBridge;\n\n        if (bridge.aggregatorDecimals == 0) {\n            revert EthUsdBridgeMissing();\n        }\n\n        FeedConfig memory bridgeCopy = bridge;\n        bridgeCopy.maxStalenessSeconds = capSeconds_;\n\n        return _readNormalizedPrice(ETH_DENOMINATION, USD_DENOMINATION, bridgeCopy);\n    }\n\n    function _effectiveEthUsdStaleness(TokenConfig storage config) internal view returns (uint32) {\n        uint32 overrideSeconds = config.ethUsdMaxStalenessOverrideSeconds;\n        uint32 maxStaleness = ethUsdBridge.maxStalenessSeconds;\n\n        if (overrideSeconds == 0) {\n            return maxStaleness;\n        }\n\n        if (overrideSeconds < maxStaleness) {\n            return overrideSeconds;\n        } else {\n            return maxStaleness;\n        }\n    }\n\n    function _getPriceInQuote(\n        address token_,\n        TokenConfig storage config_,\n        IOracleRouter.QuoteDenomination requestedQuote_,\n        BridgeCache memory sharedBridge_\n    ) internal view returns (uint256 price) {\n        // If the token's primary quote matches the requested quote, use it directly\n        if (config_.primaryQuote == requestedQuote_) {\n            if (requestedQuote_ == IOracleRouter.QuoteDenomination.USD) {\n                return _readNormalizedPrice(token_, USD_DENOMINATION, config_.primaryFeed);\n            } else {\n                return _readNormalizedPrice(token_, ETH_DENOMINATION, config_.primaryFeed);\n            }\n        }\n\n        // Need to bridge through ETH/USD\n        // Get the token's price in its primary quote\n        uint256 tokenInPrimaryQuote;\n        if (config_.primaryQuote == IOracleRouter.QuoteDenomination.USD) {\n            tokenInPrimaryQuote = _readNormalizedPrice(\n                token_,\n                USD_DENOMINATION,\n                config_.primaryFeed\n            );\n        } else {\n            tokenInPrimaryQuote = _readNormalizedPrice(\n                token_,\n                ETH_DENOMINATION,\n                config_.primaryFeed\n            );\n        }\n\n        // Get ETH/USD price for bridging\n        uint32 cap = _effectiveEthUsdStaleness(config_);\n        uint256 ethUsdPrice;\n\n        if (sharedBridge_.price != 0 && sharedBridge_.capSeconds == cap) {\n            ethUsdPrice = sharedBridge_.price;\n        } else {\n            ethUsdPrice = _readEthUsdWithCap(cap);\n        }\n\n        // Convert to requested quote\n        if (requestedQuote_ == IOracleRouter.QuoteDenomination.USD) {\n            // Token is ETH-quoted, need USD: token/ETH * ETH/USD = token/USD\n            price = Math.mulDiv(tokenInPrimaryQuote, ethUsdPrice, PRICE_UNIT);\n        } else {\n            // Token is USD-quoted, need ETH: token/USD / ETH/USD = token/ETH\n            price = Math.mulDiv(tokenInPrimaryQuote, PRICE_UNIT, ethUsdPrice);\n        }\n    }\n\n    function _readNormalizedPrice(\n        address baseToken_,\n        address quoteToken_,\n        FeedConfig memory feedConfig_\n    ) internal view returns (uint256 normalizedPrice) {\n        IFeedRegistry registry = IFeedRegistry(FEED_REGISTRY);\n\n        address liveAggregator = registry.getFeed(baseToken_, quoteToken_);\n        uint8 liveDecimals = registry.decimals(baseToken_, quoteToken_);\n\n        if (\n            liveAggregator != feedConfig_.aggregator ||\n            liveDecimals != feedConfig_.aggregatorDecimals\n        ) {\n            revert FeedConfigOutOfSync(\n                feedConfig_.aggregator,\n                liveAggregator,\n                feedConfig_.aggregatorDecimals,\n                liveDecimals\n            );\n        }\n\n        (uint80 roundId, int256 rawAnswer, , uint256 updatedAt, uint80 answeredInRound) = registry\n            .latestRoundData(baseToken_, quoteToken_);\n\n        if (rawAnswer <= 0) {\n            revert OracleBadAnswer(feedConfig_.aggregator, rawAnswer);\n        }\n\n        if (answeredInRound < roundId) {\n            revert OracleUnanswered(feedConfig_.aggregator, roundId, answeredInRound);\n        }\n\n        if (block.timestamp - updatedAt > feedConfig_.maxStalenessSeconds) {\n            revert OracleStale(feedConfig_.aggregator, updatedAt);\n        }\n\n        normalizedPrice = Math.mulDiv(\n            uint256(rawAnswer),\n            feedConfig_.scaleNumerator,\n            feedConfig_.scaleDenominator\n        );\n\n        if (normalizedPrice == 0) {\n            revert OracleQuantizedToZero(feedConfig_.aggregator, liveDecimals, PRICE_DECIMALS);\n        }\n    }\n\n    function _setTokenFeed(\n        address token_,\n        IOracleRouter.QuoteDenomination primaryQuote_,\n        uint32 maxStalenessSeconds_,\n        uint8 tokenDecimals_,\n        bool isActive_\n    ) internal {\n        if (token_ == address(0)) {\n            revert InvalidTokenAddress(token_);\n        }\n\n        if (maxStalenessSeconds_ == 0) {\n            revert InvalidStaleness();\n        }\n\n        uint8 erc20Decimals;\n        if (tokenDecimals_ != 0) {\n            erc20Decimals = tokenDecimals_;\n        } else {\n            erc20Decimals = IERC20Metadata(token_).decimals();\n        }\n\n        if (erc20Decimals == 0 || erc20Decimals > MAX_DECIMALS) {\n            revert InvalidTokenDecimals();\n        }\n\n        if (tokenDecimals_ != 0) {\n            uint8 onchain = IERC20Metadata(token_).decimals();\n            if (onchain != erc20Decimals) {\n                revert TokenDecimalsMismatch(onchain, erc20Decimals);\n            }\n        }\n\n        address quote;\n        if (primaryQuote_ == IOracleRouter.QuoteDenomination.USD) {\n            quote = USD_DENOMINATION;\n        } else {\n            quote = ETH_DENOMINATION;\n        }\n\n        (\n            address aggregator,\n            uint8 feedDecimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        ) = _resolveFeedAndScale(token_, quote);\n\n        tokenConfig[token_] = TokenConfig({\n            primaryQuote: primaryQuote_,\n            primaryFeed: FeedConfig({\n                aggregator: aggregator,\n                maxStalenessSeconds: maxStalenessSeconds_,\n                aggregatorDecimals: feedDecimals,\n                scaleNumerator: scaleNumerator,\n                scaleDenominator: scaleDenominator\n            }),\n            tokenDecimals: erc20Decimals,\n            isActive: isActive_,\n            ethUsdMaxStalenessOverrideSeconds: 0\n        });\n\n        emit TokenConfigured(\n            token_,\n            primaryQuote_,\n            aggregator,\n            feedDecimals,\n            maxStalenessSeconds_,\n            erc20Decimals,\n            scaleNumerator,\n            scaleDenominator,\n            isActive_\n        );\n    }\n\n    function _resolveFeedAndScale(\n        address baseToken_,\n        address quoteToken_\n    )\n        internal\n        view\n        returns (\n            address aggregator,\n            uint8 decimals,\n            uint128 scaleNumerator,\n            uint128 scaleDenominator\n        )\n    {\n        IFeedRegistry registry = IFeedRegistry(FEED_REGISTRY);\n\n        aggregator = registry.getFeed(baseToken_, quoteToken_);\n\n        if (aggregator == address(0)) {\n            revert FeedMissing(baseToken_, quoteToken_);\n        }\n\n        decimals = registry.decimals(baseToken_, quoteToken_);\n\n        if (decimals == 0 || decimals > MAX_DECIMALS) {\n            revert InvalidAggregatorDecimals();\n        }\n\n        (scaleNumerator, scaleDenominator) = _computeScaleFactors(decimals);\n    }\n\n    function _currentFeedMeta(\n        address baseToken_,\n        address quoteToken_\n    ) internal view returns (address aggregator, uint8 decimals) {\n        IFeedRegistry registry = IFeedRegistry(FEED_REGISTRY);\n\n        aggregator = registry.getFeed(baseToken_, quoteToken_);\n        decimals = registry.decimals(baseToken_, quoteToken_);\n    }\n\n    function _computeScaleFactors(\n        uint8 feedDecimals_\n    ) internal view returns (uint128 numerator, uint128 denominator) {\n        if (feedDecimals_ == PRICE_DECIMALS) {\n            return (1, 1);\n        }\n\n        if (feedDecimals_ < PRICE_DECIMALS) {\n            uint8 upDiff = PRICE_DECIMALS - feedDecimals_;\n\n            if (upDiff > MAX_DECIMALS) {\n                revert InvalidAggregatorDecimals();\n            }\n\n            unchecked {\n                return (uint128(10 ** upDiff), 1);\n            }\n        }\n\n        uint8 downDiff = feedDecimals_ - PRICE_DECIMALS;\n\n        if (downDiff > MAX_DECIMALS) {\n            revert InvalidAggregatorDecimals();\n        }\n\n        unchecked {\n            return (1, uint128(10 ** downDiff));\n        }\n    }\n}\n"
    }
}