{
    "vfp_id": "vfp_00626",
    "project_name": "cantina_tadle_oct2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Validator spoofing blocks victim claims indefinitely",
            "description": "The claim function in TadleConnectors allows any user to specify an arbitrary validator address without authentication or consent. This causes the cooldown timestamp for the victim's address to be updated even if the victim did not initiate or approve the claim. As a result, the victim is blocked from making legitimate claims due to the enforced 24-hour cooldown being reset repeatedly by an attacker. The root cause is the lack of validation or binding of the validator to the caller. An attacker can exploit this by repeatedly calling the claim function with a victim's address as the validator, leading to a low-cost, repeatable griefing attack. The impact is indefinite denial of service for victims trying to claim their rightful allocations.\n",
            "severity": "High",
            "location": [
                "Connectors.sol::claim#402-412"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Connectors.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Factory rotation breaks new sandbox claims",
            "description": "The Auth contract allows the admin to rotate the sandbox factory, but TadleConnectors caches the old factory address during initialization and never updates it. As a result, after a factory rotation, newly created sandbox accounts are not recognized by the old factory's isSandboxAccount check, causing their claim attempts to revert. The root cause is the lack of synchronization between Auth and TadleConnectors when the factory is updated. An admin performing a legitimate rotation would inadvertently break claim functionality for all new sandboxes. The impact is a denial of service for all newly created sandbox accounts, halting onboarding and distribution mechanisms dependent on claiming.\n",
            "severity": "Medium",
            "location": [
                "Auth.sol::setFactory#96-105",
                "TadleConnectors.sol::initialize#",
                "TadleConnectors.sol::onlySandboxAccount#"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Auth.sol",
                "v3-sandbox-audit_1/src/core/Connectors.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Unrestricted check-ins skew reward tracking",
            "description": "The checkIn function lacks the onlySandboxAccount modifier, allowing any address to trigger it and emit a UserCheckIn event. This enables off-chain reward systems to be gamed by spamming check-ins from arbitrary accounts. The root cause is missing access control on a function intended for sandbox accounts only. Attackers can exploit this to inflate engagement metrics and potentially claim undeserved rewards. The impact is distorted analytics and potential financial loss if rewards are distributed based on unverified check-in events.\n",
            "severity": "Low",
            "location": [
                "Connectors.sol::checkIn#456-476"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Connectors.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Constructor sets state on implementation",
            "description": "The TadleConnectors and other proxied contracts use constructors to set ownership, but in an upgradeable architecture, constructor code runs only on the implementation, not the proxy. This results in ownership being set in the wrong storage context, leading to confusion and potential misconfiguration. The root cause is improper use of constructors in upgradeable contracts. Tools or operators inspecting the implementation directly may see incorrect state. The impact is operational confusion and risk of failed administrative actions due to mismatched ownership assumptions.\n",
            "severity": "Low",
            "location": [
                "Connectors.sol::constructor#237"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Connectors.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Usage of custom errors",
            "description": "The contract uses string-based require statements for error messages, which are more expensive in gas than custom errors. Custom errors are cheaper and provide structured revert data. The root cause is outdated error handling practices. Replacing string reverts with custom errors would save gas and improve tooling support. The impact is higher transaction costs and reduced efficiency, with no security implications.\n",
            "severity": "Informational",
            "location": [
                "Auth.sol::initialize#91"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Auth.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Dual cooldown trackers allow double rewards",
            "description": "The claim and airdrop functions use separate cooldown mappings (lastClaimTimes and lastTokenReceiveTimes), allowing users to claim twice within the same 24-hour period by using both paths. The root cause is duplicated and uncoordinated state tracking. The comment incorrectly states that timestamps are shared. An attacker can alternate between claim and airdrop to double their rewards. The impact is inflation of token distribution and financial loss to the protocol.\n",
            "severity": "Informational",
            "location": [
                "Connectors.sol::claim#447-448",
                "Connectors.sol::airdrop#"
            ],
            "files": [
                "v3-sandbox-audit_1/src/core/Connectors.sol"
            ]
        }
    ],
    "affected_files": {
        "Auth.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Ownable2Step, Ownable} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n/**\n * @title Auth\n * @dev Contract for managing system and sandbox administrators\n * This contract handles authentication and authorization for the Tadle system\n * and provides management of sandbox account administrators.\n * It maintains separate registries for system admins and sandbox-specific admins.\n */\ncontract Auth is Ownable2Step {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Set of system administrators with global privileges\n    EnumerableSet.AddressSet private admins;\n\n    /// @dev Initialization flag to prevent multiple initialization calls\n    bool private _initialized;\n\n    /// @dev Factory contract address authorized to create sandbox accounts\n    address public factory;\n\n    /// @dev Mapping of sandbox accounts to their administrators\n    mapping(address => EnumerableSet.AddressSet) private sandboxAdmins;\n\n    // Events for tracking administrative changes\n    /**\n     * @dev Emitted when a system administrator is added\n     * @param account Address that was added as admin\n     */\n    event AdminAdded(address indexed account);\n\n    /**\n     * @dev Emitted when a system administrator is removed\n     * @param account Address that was removed from admins\n     */\n    event AdminRemoved(address indexed account);\n\n    /**\n     * @dev Emitted when a sandbox administrator is added\n     * @param sandboxAccount The sandbox account address\n     * @param admin Address that was added as admin for the sandbox\n     */\n    event SandboxAdminAdded(address indexed sandboxAccount, address indexed admin);\n\n    /**\n     * @dev Emitted when a sandbox administrator is removed\n     * @param sandboxAccount The sandbox account address\n     * @param admin Address that was removed from sandbox admins\n     */\n    event SandboxAdminRemoved(address indexed sandboxAccount, address indexed admin);\n\n    /**\n     * @dev Emitted when the factory contract address is updated\n     * @param oldFactory Previous factory contract address\n     * @param newFactory New factory contract address\n     */\n    event FactoryUpdated(address indexed oldFactory, address indexed newFactory);\n\n    /**\n     * @dev Modifier to ensure contract is only initialized once\n     * @notice Prevents multiple initialization calls that could reset contract state\n     */\n    modifier initializer() {\n        require(!_initialized, \"Auth: already initialized\");\n        _;\n        _initialized = true;\n    }\n\n    /**\n     * @dev Initialize contract with deployer as admin and factory\n     */\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @dev Modifier to restrict access to system administrators\n     */\n    modifier onlyAdmin() {\n        require(admins.contains(msg.sender), \"Auth: caller is not an admin\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the contract with the first admin\n     * @param _admin Address to be set as the first system administrator\n     */\n    function initialize(address _admin) external onlyOwner initializer {\n        require(_admin != address(0), \"Auth: invalid admin address\");\n        admins.add(_admin);\n        emit AdminAdded(_admin);\n    }\n\n    /**\n     * @dev Update factory contract address\n     * @param _factory New factory contract address\n     */\n    function setFactory(address _factory) external onlyAdmin {\n        require(_factory != address(0), \"Auth: invalid factory address\");\n        address oldFactory = factory;\n        factory = _factory;\n        emit FactoryUpdated(oldFactory, _factory);\n    }\n\n    /**\n     * @dev Initialize sandbox account with its first admin\n     * @param sandboxAccount Address of the sandbox account\n     * @param admin Address of the initial admin\n     */\n    function createSandboxAdmin(address sandboxAccount, address admin) external {\n        require(msg.sender == factory, \"Auth: only factory can create sandbox admin\");\n        require(sandboxAdmins[sandboxAccount].length() == 0, \"Auth: sandbox already exists\");\n        require(admin != address(0), \"Auth: invalid admin address\");\n\n        sandboxAdmins[sandboxAccount].add(admin);\n\n        emit SandboxAdminAdded(sandboxAccount, admin);\n    }\n\n    /**\n     * @dev Add a new admin to the sandbox account\n     * @param admin Address to be added as admin\n     * @notice Only callable by existing sandbox admins\n     */\n    function addSandboxAdmin(address admin) external {\n        require(sandboxAdmins[msg.sender].length() > 0, \"Auth: sandbox not initialized\");\n        require(admin != address(0), \"Auth: invalid admin address\");\n        require(!sandboxAdmins[msg.sender].contains(admin), \"Auth: admin already exists\");\n\n        sandboxAdmins[msg.sender].add(admin);\n        emit SandboxAdminAdded(msg.sender, admin);\n    }\n\n    /**\n     * @dev Remove an admin from the sandbox account\n     * @param admin Address to be removed from admins\n     * @notice Only callable by existing sandbox admins\n     * @notice Cannot remove the last admin to prevent lockout\n     */\n    function removeSandboxAdmin(address admin) external {\n        require(sandboxAdmins[msg.sender].length() > 1, \"Auth: cannot remove last admin\");\n        require(sandboxAdmins[msg.sender].contains(admin), \"Auth: admin not found\");\n\n        sandboxAdmins[msg.sender].remove(admin);\n        emit SandboxAdminRemoved(msg.sender, admin);\n    }\n\n    /**\n     * @dev Check if an address is admin for a sandbox account\n     * @param sandboxAccount The sandbox account to check\n     * @param admin The address to verify\n     * @return bool True if address is admin\n     */\n    function isSandboxAdmin(address sandboxAccount, address admin) external view returns (bool) {\n        return sandboxAdmins[sandboxAccount].contains(admin);\n    }\n\n    /**\n     * @dev Get all admins for a sandbox account\n     * @param sandboxAccount The sandbox account to query\n     * @return Array of admin addresses\n     */\n    function getSandboxAdmins(address sandboxAccount) external view returns (address[] memory) {\n        return sandboxAdmins[sandboxAccount].values();\n    }\n\n    /**\n     * @dev Add a new system administrator\n     * @param account Address to be granted admin role\n     * @notice Only callable by existing system admins\n     */\n    function addAdmin(address account) external onlyAdmin {\n        require(account != address(0), \"Auth: invalid admin address\");\n        require(!admins.contains(account), \"Auth: admin already exists\");\n\n        admins.add(account);\n        emit AdminAdded(account);\n    }\n\n    /**\n     * @dev Remove a system administrator\n     * @param account Address to be revoked admin role\n     * @notice Only callable by existing system admins\n     * @notice Cannot remove the last admin to prevent lockout\n     */\n    function removeAdmin(address account) external onlyAdmin {\n        require(admins.length() > 1, \"Auth: cannot remove last admin\");\n        require(admins.contains(account), \"Auth: admin not found\");\n\n        admins.remove(account);\n        emit AdminRemoved(account);\n    }\n\n    /**\n     * @dev Check if an address is a system administrator\n     * @param account Address to check\n     * @return bool True if address is admin\n     */\n    function isAdmin(address account) external view returns (bool) {\n        return admins.contains(account);\n    }\n\n    /**\n     * @dev Get all system administrators\n     * @return Array of admin addresses\n     */\n    function getAdmins() external view returns (address[] memory) {\n        return admins.values();\n    }\n}\n",
        "Connectors.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable2Step, Ownable} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title ConnectorInterface\n * @dev Interface that all connectors must implement to be registered in the system\n * @notice Connectors must provide a name function to identify themselves uniquely\n */\ninterface ConnectorInterface {\n    /**\n     * @dev Returns the name of the connector\n     * @return The connector name as a string\n     */\n    function name() external view returns (string memory);\n}\n\n/**\n * @title ITadleSandBoxFactory\n * @dev Interface for the Tadle Sandbox Factory contract\n * @notice Provides verification functionality for sandbox account eligibility and registration\n */\ninterface ITadleSandBoxFactory {\n    /**\n     * @notice Verifies if an account is a registered sandbox account\n     * @param account The address to verify\n     * @return True if the account is a valid sandbox account, false otherwise\n     */\n    function isSandboxAccount(address account) external view returns (bool);\n}\n\n/**\n * @title IAuth\n * @dev Interface for authentication contract\n * @notice Used to verify admin privileges for connector management and system operations\n */\ninterface IAuth {\n    /**\n     * @dev Checks if an account has admin privileges\n     * @param account Address to check for admin status\n     * @return True if the account is an admin, false otherwise\n     */\n    function isAdmin(address account) external view returns (bool);\n}\n\n/**\n * @title TadleConnectors\n * @dev Registry contract for managing connector implementations and token airdrops\n * @notice This contract maintains a registry of connector implementations that can be\n * used by the Tadle system, with admin-controlled addition, update, and removal.\n * It also provides token airdrop functionality with rate limiting and user level-based claims.\n */\ncontract TadleConnectors is Ownable2Step, ReentrancyGuard {\n    /// @notice Auth contract instance for access control and admin verification\n    IAuth public auth;\n\n    /// @notice Initialization flag to prevent multiple initialization calls\n    bool private _initialized;\n\n    /// @notice Address of the Tadle Sandbox Factory contract\n    /// @notice Used to verify sandbox account eligibility for claims and check-ins\n    address public factory;\n\n    /// @notice Mapping of connector names to their implementation addresses\n    mapping(string => address) public connectors;\n\n    /// @notice Mapping to track last claim timestamps for rate limiting\n    /// @notice Maps user address => token address => last claim timestamp\n    /// @dev Used to enforce the 24-hour claim window between claims\n    mapping(address => mapping(address => uint256)) public lastClaimTimes;\n\n    /// @notice Mapping to track cumulative claimed amounts per user and token\n    /// @notice Maps user address => token address => total claimed amount\n    mapping(address => mapping(address => uint256)) public totalClaimedAmounts;\n\n    /// @notice Mapping to configure token amounts by user level\n    /// @notice Maps token address => user level => claimable amount\n    /// @dev Level 0 is typically reserved, levels start from 1\n    mapping(address => mapping(uint256 => uint256)) public tokenAmountsByLevel;\n\n    /// @notice Mapping for token-specific airdrop configurations\n    /// @notice Maps token address => TokenAirdropConfig struct\n    /// @dev Stores individual configuration for each token's airdrop parameters\n    mapping(address => TokenAirdropConfig) public tokenAirdropConfigs;\n\n    /// @notice Mapping to track last airdrop receive timestamps per token per recipient\n    /// @notice Maps recipient address => token address => last receive timestamp\n    /// @dev Used to enforce token-specific cooldown periods for both user and admin claims\n    mapping(address => mapping(address => uint256)) public lastTokenReceiveTimes;\n\n    /// @notice Mapping to track last check-in timestamps for daily check-in limit\n    /// @notice Maps user address => last check-in timestamp\n    /// @dev Used to enforce once-per-day check-in restriction\n    mapping(address => uint256) public lastCheckInTimes;\n\n    // ============================================================================\n    // STRUCTURES\n    // ============================================================================\n\n    /// @notice Configuration structure for token-specific airdrop parameters\n    /// @dev Each token can have its own airdrop rules, limits, and cooldown periods\n    struct TokenAirdropConfig {\n        uint256 userAirdropAmount; // Amount of tokens distributed per user self-claim\n        uint256 userCooldownPeriod; // Cooldown period between user self-claims (in seconds)\n        bool isEnabled; // Global enable/disable flag for this token's airdrop functionality\n    }\n\n    // ============================================================================\n    // CONSTANTS\n    // ============================================================================\n\n    /// @notice Time window between consecutive claims (24 hours)\n    /// @dev Legacy constant maintained for backward compatibility with existing claim logic\n    uint256 public constant CLAIM_WINDOW = 24 hours;\n\n    /// @notice Constant representing ETH address for native token operations\n    /// @dev Special identifier (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) used throughout the contract for ETH transfers\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Address of the monUSD token contract\n    /// @dev Hardcoded token address maintained for legacy compatibility and system integration\n    address public constant monUSD = address(0x57c914e3240C837EBE87F096e0B4d9A06E3F489B);\n\n    // ============================================================================\n    // EVENTS\n    // ============================================================================\n    /// @notice Emitted when the factory contract address is initialized\n    /// @dev This event can only be emitted once during contract initialization\n    /// @param factory The address of the Tadle Sandbox Factory contract\n    event FactoryInitialized(address indexed factory);\n\n    /// @notice Emitted when token claim amounts are configured for a specific user level\n    /// @dev Only contract admins can configure these amounts through the auth system\n    /// @param token The address of the token being configured (ETH_ADDRESS for native ETH)\n    /// @param level The user level (must be > 0)\n    /// @param amount The claimable amount for this token and level combination\n    event TokenAmountConfigured(address indexed token, uint256 indexed level, uint256 amount);\n\n    /// @notice Emitted when token airdrop configuration is updated\n    /// @dev Used for tracking changes to token airdrop parameters and cooldown settings\n    /// @param token The address of the token being configured\n    /// @param userAirdropAmount The amount of tokens distributed per user self-claim\n    /// @param userCooldownPeriod The cooldown period between user self-claims (in seconds)\n    /// @param isEnabled Whether airdrop functionality is enabled for this token\n    event TokenAirdropConfigured(\n        address indexed token, uint256 userAirdropAmount, uint256 userCooldownPeriod, bool isEnabled\n    );\n\n    // ============================================================================\n    // CONNECTOR MANAGEMENT EVENTS\n    // ============================================================================\n\n    /// @notice Emitted when a new connector is added to the registry\n    /// @param nameHash Keccak256 hash of the connector name for efficient indexing\n    /// @param name Human-readable name of the connector\n    /// @param connector Address of the connector implementation contract\n    event LogConnectorAdded(bytes32 indexed nameHash, string name, address indexed connector);\n\n    /// @notice Emitted when an existing connector is updated with a new implementation\n    /// @param nameHash Keccak256 hash of the connector name for efficient indexing\n    /// @param name Human-readable name of the connector\n    /// @param oldConnector Previous connector implementation address\n    /// @param newConnector New connector implementation address\n    event LogConnectorUpdated(\n        bytes32 indexed nameHash, string name, address indexed oldConnector, address indexed newConnector\n    );\n\n    /// @notice Emitted when a connector is removed from the registry\n    /// @param nameHash Keccak256 hash of the connector name for efficient indexing\n    /// @param name Human-readable name of the connector\n    /// @param connector Address of the removed connector implementation\n    event LogConnectorRemoved(bytes32 indexed nameHash, string name, address indexed connector);\n\n    /// @notice Emitted when tokens are successfully claimed by a user\n    /// @param user The address of the user receiving the tokens\n    /// @param token The address of the token being claimed (ETH_ADDRESS for native ETH)\n    /// @param amount The amount of tokens claimed (in token's smallest unit)\n    /// @param timestamp The block timestamp when the claim occurred\n    event TokensClaimed(address indexed user, address indexed token, uint256 amount, uint256 timestamp);\n\n    /// @notice Emitted when tokens are airdropped to a user through self-claim\n    /// @dev Used for tracking token airdrops with rate limiting and cooldown enforcement\n    /// @param recipient The address of the user receiving the tokens\n    /// @param token The address of the token being airdropped\n    /// @param amount The amount of tokens transferred (in token's smallest unit)\n    /// @param timestamp The block timestamp when the transfer occurred\n    event Airdrop(address indexed recipient, address indexed token, uint256 amount, uint256 timestamp);\n\n    /// @notice Emitted when a user performs a daily check-in action\n    /// @dev Only verified sandbox accounts can check in, limited to once per day\n    /// @param user The address of the user checking in\n    /// @param timestamp The block timestamp when the check-in occurred\n    event UserCheckIn(address indexed user, uint256 timestamp);\n\n    /**\n     * @dev Modifier to ensure contract is only initialized once\n     * @notice Prevents multiple initialization calls that could reset contract state\n     * @custom:security Critical for preventing reinitialization attacks\n     */\n    modifier initializer() {\n        require(!_initialized, \"TadleConnectors: contract already initialized\");\n        _;\n        _initialized = true;\n    }\n\n    /**\n     * @dev Modifier to check if caller has admin privileges\n     * @notice Restricts function access to authenticated admin accounts only\n     * @custom:access-control Uses auth contract for privilege verification\n     */\n    modifier isAdmin() {\n        require(auth.isAdmin(msg.sender), \"TadleConnectors: caller lacks admin privileges\");\n        _;\n    }\n\n    /// @notice Restricts function access to verified sandbox accounts only\n    /// @dev Validates caller through the factory contract's isSandboxAccount function\n    /// @custom:access-control Ensures only registered sandbox users can access protected functions\n    modifier onlySandboxAccount() {\n        require(factory != address(0), \"TadleConnectors: factory not initialized\");\n        require(\n            ITadleSandBoxFactory(factory).isSandboxAccount(msg.sender),\n            \"TadleConnectors: caller is not a verified sandbox account\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Constructor that sets the contract deployer as the initial owner\n     * @dev Inherits from Ownable2Step for secure two-step ownership transfer\n     * @custom:security Uses OpenZeppelin's secure ownership pattern\n     */\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Initialize the contract with auth contract address\n     * @dev Can only be called once due to initializer modifier protection\n     * @param _auth Address of the Auth contract for admin verification\n     * @param _factory Address of the Factory contract for sandbox account verification\n     * @custom:initialization Must be called after deployment to activate admin functions\n     */\n    function initialize(address _auth, address _factory) external onlyOwner initializer {\n        require(_auth != address(0), \"TadleConnectors: auth address cannot be zero\");\n        require(_factory != address(0), \"TadleConnectors: factory address cannot be zero\");\n        auth = IAuth(_auth);\n        factory = _factory;\n    }\n\n    /**\n     * @notice Add multiple connectors to the registry in a single transaction\n     * @dev Validates connector implementations and prevents duplicate names\n     * @param _names Array of unique connector names for identification\n     * @param _connectors Array of connector implementation contract addresses\n     * @custom:access-control Restricted to admin accounts only\n     * @custom:batch-operation Processes multiple connectors efficiently\n     */\n    function addConnectors(string[] calldata _names, address[] calldata _connectors) external isAdmin {\n        require(_names.length == _connectors.length, \"TadleConnectors: names and connectors arrays length mismatch\");\n        require(_names.length > 0, \"TadleConnectors: arrays cannot be empty\");\n\n        for (uint256 i = 0; i < _connectors.length; i++) {\n            require(bytes(_names[i]).length > 0, \"TadleConnectors: connector name cannot be empty\");\n            require(connectors[_names[i]] == address(0), \"TadleConnectors: connector name already registered\");\n            _verifyConnector(_connectors[i]);\n\n            connectors[_names[i]] = _connectors[i];\n            emit LogConnectorAdded(keccak256(abi.encodePacked(_names[i])), _names[i], _connectors[i]);\n        }\n    }\n\n    /**\n     * @notice Update multiple existing connectors with new implementations\n     * @dev Validates new implementations and ensures connectors exist before updating\n     * @param _names Array of existing connector names to update\n     * @param _connectors Array of new connector implementation addresses\n     * @custom:access-control Restricted to admin accounts only\n     * @custom:batch-operation Processes multiple updates efficiently\n     */\n    function updateConnectors(string[] calldata _names, address[] calldata _connectors) external isAdmin {\n        require(_names.length == _connectors.length, \"TadleConnectors: array length mismatch\");\n        require(_names.length > 0, \"TadleConnectors: empty arrays\");\n\n        for (uint256 i = 0; i < _connectors.length; i++) {\n            require(bytes(_names[i]).length > 0, \"TadleConnectors: empty connector name\");\n            require(connectors[_names[i]] != address(0), \"TadleConnectors: connector name not found in registry\");\n            require(_connectors[i] != address(0), \"TadleConnectors: connector address cannot be zero\");\n            require(connectors[_names[i]] != _connectors[i], \"TadleConnectors: new connector address same as current\");\n\n            // Verify connector implements required interface\n            _verifyConnector(_connectors[i]);\n\n            address oldConnector = connectors[_names[i]];\n            connectors[_names[i]] = _connectors[i];\n\n            emit LogConnectorUpdated(keccak256(abi.encodePacked(_names[i])), _names[i], oldConnector, _connectors[i]);\n        }\n    }\n\n    /**\n     * @notice Remove multiple connectors from the registry\n     * @dev Validates connector existence before removal\n     * @param _names Array of connector names to remove from the registry\n     * @custom:access-control Restricted to admin accounts only\n     * @custom:batch-operation Processes multiple removals efficiently\n     */\n    function removeConnectors(string[] calldata _names) external isAdmin {\n        require(_names.length > 0, \"TadleConnectors: names array cannot be empty\");\n\n        for (uint256 i = 0; i < _names.length; i++) {\n            require(bytes(_names[i]).length > 0, \"TadleConnectors: empty connector name\");\n            require(connectors[_names[i]] != address(0), \"TadleConnectors: connector does not exist\");\n\n            address connectorAddr = connectors[_names[i]];\n            delete connectors[_names[i]];\n\n            emit LogConnectorRemoved(keccak256(abi.encodePacked(_names[i])), _names[i], connectorAddr);\n        }\n    }\n\n    /**\n     * @notice Check if connectors are registered and retrieve their addresses\n     * @dev Returns false if any connector is not found in the registry\n     * @param _names Array of connector names to check\n     * @return isOk Whether all connectors are registered and enabled\n     * @return _addresses Array of connector implementation addresses (zero address if not found)\n     * @custom:view-function Pure read operation with no state changes\n     */\n    function isConnectors(string[] calldata _names) external view returns (bool isOk, address[] memory _addresses) {\n        isOk = true;\n        uint256 len = _names.length;\n        _addresses = new address[](len);\n\n        for (uint256 i = 0; i < len; i++) {\n            _addresses[i] = connectors[_names[i]];\n            if (_addresses[i] == address(0)) {\n                isOk = false;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to verify connector implementation validity\n     * @dev Ensures connector implements required ConnectorInterface and has valid name\n     * @param _connector Address of connector implementation to verify\n     * @custom:internal-function Only callable from within the contract\n     * @custom:validation Checks interface compliance and name availability\n     */\n    function _verifyConnector(address _connector) internal view {\n        require(_connector != address(0), \"TadleConnectors: connector address cannot be zero\");\n        // Verify connector implements required interface by calling name()\n        string memory connectorName = ConnectorInterface(_connector).name();\n        require(bytes(connectorName).length > 0, \"TadleConnectors: connector must return non-empty name\");\n    }\n\n    /**\n     * @notice Check if a user is eligible to claim a specific token today\n     * @dev This function implements the 24-hour claim window rate limiting mechanism\n     * @dev First-time claims are always allowed regardless of timestamp\n     * @param user Address of the user to check eligibility for\n     * @param token Address of the token to check (use ETH_ADDRESS for native ETH)\n     * @return bool True if user can claim the token, false if still within claim window\n     * @custom:view-function Pure view function with no state changes\n     * @custom:rate-limiting Enforces 24-hour window between consecutive claims\n     */\n    function canClaimToday(address user, address token) public view returns (bool) {\n        uint256 lastClaimTime = lastClaimTimes[user][token];\n        // First time claim is always allowed\n        if (lastClaimTime == 0) {\n            return true;\n        }\n        // Check if CLAIM_WINDOW has passed since last claim\n        return block.timestamp >= lastClaimTime + CLAIM_WINDOW;\n    }\n\n    /**\n     * @notice Get the total cumulative amount claimed by a user for a specific token\n     * @param user Address of the user to query claim history for\n     * @param token Address of the token to query (use ETH_ADDRESS for native ETH)\n     */\n    function getUserClaimedAmount(address user, address token) external view returns (uint256) {\n        return totalClaimedAmounts[user][token];\n    }\n\n    /**\n     * @notice Claims daily airdrop tokens for the caller based on their user level\n     * @dev This is the main claim function that enforces all business rules and rate limits\n     * @dev Both caller and validator must not have claimed this token within the last 24 hours\n     * @dev The function is protected against reentrancy attacks\n     * @param token Address of the token to claim (use ETH_ADDRESS for native ETH)\n     * @param validator Address of the validator (must also be eligible for claims)\n     * @param level User level determining the claimable amount (must be configured)\n     * @custom:security Protected by nonReentrant and onlySandboxAccount modifiers\n     * @custom:rate-limiting Enforces 24-hour claim window for both caller and validator\n     * @custom:requirements Caller must be sandbox account, token must be configured for level\n     * @custom:state-change Updates claim timestamps and transfers tokens\n     */\n    function claim(address token, address validator, uint256 level) external nonReentrant onlySandboxAccount {\n        // Verify claim eligibility for both caller and validator\n        _verifyClaimEligibility(msg.sender, token);\n        _verifyClaimEligibility(validator, token);\n\n        // Update claim timestamps\n        _updateClaimTimestamps(msg.sender, validator, token);\n\n        // Transfer tokens based on user level\n        _transferTokens(token, msg.sender, level);\n    }\n\n    // ============================================================================\n    // PUBLIC AIRDROP FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Allows users to claim tokens through self-service airdrop\n     * @dev Enforces cooldown periods and validates token configuration\n     * @param token Address of the ERC20 token to claim\n     * @custom:security Protected by nonReentrant modifier\n     * @custom:rate-limiting Enforces token-specific cooldown periods\n     * @custom:balance-check Validates sufficient contract token balance\n     */\n    function airdrop(address token) external nonReentrant {\n        require(token != address(0), \"TadleConnectors: token address cannot be zero\");\n\n        // Get token configuration\n        TokenAirdropConfig memory config = tokenAirdropConfigs[token];\n        require(config.isEnabled, \"TadleConnectors: airdrop disabled for this token\");\n\n        uint256 airdropAmount = config.userAirdropAmount;\n        require(airdropAmount > 0, \"TadleConnectors: airdrop amount not configured for this token\");\n\n        // Check cooldown based on claim type (using shared timestamp to prevent double claiming)\n        uint256 lastClaimTime = lastTokenReceiveTimes[msg.sender][token];\n        require(\n            block.timestamp >= lastClaimTime + config.userCooldownPeriod, \"TadleConnectors: cooldown period not elapsed\"\n        );\n\n        // Check contract has sufficient token balance\n        IERC20 tokenContract = IERC20(token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        require(balance >= airdropAmount, \"TadleConnectors: insufficient contract token balance\");\n\n        // Update recipient's last claim timestamp (shared between both claim types to prevent double claiming)\n        lastTokenReceiveTimes[msg.sender][token] = block.timestamp;\n\n        // Transfer configured amount of tokens\n        SafeERC20.safeTransfer(tokenContract, msg.sender, airdropAmount);\n\n        emit Airdrop(msg.sender, token, airdropAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Allows sandbox users to perform a check-in action once per day\n     * @dev Records user activity through event emission for off-chain tracking\n     * @dev Enforces daily check-in limit by tracking last check-in timestamp\n     * @custom:access-control Restricted to verified sandbox accounts only\n     * @custom:rate-limiting Limited to once per 24-hour period\n     */\n    function checkIn() external {\n        uint256 lastCheckIn = lastCheckInTimes[msg.sender];\n\n        // Check if user has already checked in today\n        if (lastCheckIn > 0) {\n            uint256 daysSinceLastCheckIn = (block.timestamp - lastCheckIn) / 1 days;\n            require(daysSinceLastCheckIn >= 1, \"TadleConnectors: daily check-in limit reached\");\n        }\n\n        // Update last check-in timestamp\n        lastCheckInTimes[msg.sender] = block.timestamp;\n\n        emit UserCheckIn(msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Configure the claimable token amount for a specific user level\n     * @dev This function sets up the reward structure for different user tiers\n     * @dev Level 0 is typically reserved, active levels start from 1\n     * @param token Address of the token to configure (use ETH_ADDRESS for native ETH)\n     * @param level User level (must be > 0, represents user tier/rank)\n     * @param amount Amount of tokens claimable for this level (in token's smallest unit)\n     * @custom:security Only callable by contract owner\n     * @custom:configuration Sets up level-based reward structure\n     * @custom:event Emits TokenAmountConfigured event for tracking\n     */\n    function setTokenAmountByLevel(address token, uint256 level, uint256 amount) external onlyOwner {\n        require(token != address(0), \"TadleConnectors: invalid token address\");\n        require(level > 0, \"TadleConnectors: invalid level\");\n        tokenAmountsByLevel[token][level] = amount;\n        emit TokenAmountConfigured(token, level, amount);\n    }\n\n    /**\n     * @notice Configure token airdrop parameters\n     * @dev Sets up airdrop rules for a specific token\n     * @param token Address of the token to configure\n     * @param userAirdropAmount Amount of tokens for user self-claim\n     * @param userCooldownPeriod Cooldown period for user self-claim (in seconds)\n     * @param isEnabled Whether airdrop is enabled for this token\n     * @custom:security Only callable by contract owner\n     * @custom:configuration Sets up token-specific airdrop parameters\n     */\n    function setTokenAirdropConfig(address token, uint256 userAirdropAmount, uint256 userCooldownPeriod, bool isEnabled)\n        external\n        onlyOwner\n    {\n        require(token != address(0), \"TadleConnectorsV4: invalid token address\");\n\n        tokenAirdropConfigs[token] = TokenAirdropConfig({\n            userAirdropAmount: userAirdropAmount,\n            userCooldownPeriod: userCooldownPeriod,\n            isEnabled: isEnabled\n        });\n\n        emit TokenAirdropConfigured(token, userAirdropAmount, userCooldownPeriod, isEnabled);\n    }\n\n    // ============================================================================\n    // INTERNAL HELPER FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Internal function to verify if a user is eligible to claim a token\n     * @dev Provides different error messages for caller vs validator failures\n     * @dev Uses the canClaimToday function to check 24-hour claim window\n     * @param user Address of the user to verify (caller or validator)\n     * @param token Address of the token to verify eligibility for\n     * @custom:internal-function Only callable from within the contract\n     * @custom:view-function Does not modify state, only reads and validates\n     * @custom:error-handling Provides context-specific error messages\n     */\n    function _verifyClaimEligibility(address user, address token) internal view {\n        require(\n            canClaimToday(user, token),\n            user == msg.sender\n                ? \"TadleConnectors: user already claimed this token today\"\n                : \"TadleConnectors: validator already claimed this token today\"\n        );\n    }\n\n    /**\n     * @notice Internal function to update claim timestamps for rate limiting\n     * @dev Records the current block timestamp for both caller and validator\n     * @dev This prevents both addresses from claiming the same token for 24 hours\n     * @param caller Address of the user making the claim\n     * @param validator Address of the validator involved in the claim\n     * @param token Address of the token being claimed\n     * @custom:internal-function Only callable from within the contract\n     * @custom:state-change Modifies lastClaimTimes mapping for both addresses\n     * @custom:rate-limiting Sets timestamp for 24-hour claim window enforcement\n     */\n    function _updateClaimTimestamps(address caller, address validator, address token) internal {\n        lastClaimTimes[caller][token] = block.timestamp;\n        lastClaimTimes[validator][token] = block.timestamp;\n    }\n\n    /**\n     * @notice Internal function to route token transfers based on token type\n     * @dev Determines whether to transfer native ETH or ERC20 tokens\n     * @dev Routes to appropriate specialized transfer function\n     * @param token Address of the token to transfer (ETH_ADDRESS for native ETH)\n     * @param recipient Address of the user receiving the tokens\n     * @param level User level used to determine transfer amount from configuration\n     * @custom:internal-function Only callable from within the contract\n     * @custom:routing Routes to _transferGasToken or _transferERC20Token\n     * @custom:level-based Amount determined by tokenAmountsByLevel mapping\n     */\n    function _transferTokens(address token, address recipient, uint256 level) internal {\n        if (token == ETH_ADDRESS) {\n            _transferGasToken(recipient, level);\n        } else {\n            _transferERC20Token(token, recipient, level);\n        }\n    }\n\n    /**\n     * @notice Internal function to transfer native ETH tokens to a recipient\n     * @dev Validates configuration, balance, and performs secure ETH transfer\n     * @dev Updates tracking variables and emits appropriate events\n     * @param recipient Address of the user receiving the ETH\n     * @param level User level used to lookup configured ETH amount\n     * @custom:internal-function Only callable from within the contract\n     * @custom:native-transfer Uses low-level call for ETH transfer\n     * @custom:balance-check Validates sufficient contract balance before transfer\n     * @custom:state-tracking Updates totalClaimedAmounts and emits event\n     */\n    function _transferGasToken(address recipient, uint256 level) internal {\n        uint256 gasAmount = tokenAmountsByLevel[ETH_ADDRESS][level];\n        require(gasAmount > 0, \"TadleConnectors: ETH airdrop amount not configured for this level\");\n        uint256 balance = address(this).balance;\n        require(balance >= gasAmount, \"TadleConnectors: insufficient contract ETH balance\");\n\n        (bool success,) = recipient.call{value: gasAmount}(\"\");\n        require(success, \"TadleConnectors: ETH transfer failed\");\n\n        totalClaimedAmounts[recipient][ETH_ADDRESS] += gasAmount;\n        emit TokensClaimed(recipient, ETH_ADDRESS, gasAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens to a recipient\n     * @dev Validates configuration, balance, and performs secure ERC20 transfer\n     * @dev Uses OpenZeppelin's SafeERC20 for secure token transfers\n     * @dev Updates tracking variables and emits appropriate events\n     * @param token Address of the ERC20 token contract to transfer\n     * @param recipient Address of the user receiving the tokens\n     * @param level User level used to lookup configured token amount\n     * @custom:internal-function Only callable from within the contract\n     * @custom:safe-transfer Uses SafeERC20.safeTransfer for security\n     * @custom:balance-check Validates sufficient contract token balance\n     * @custom:state-tracking Updates totalClaimedAmounts and emits event\n     */\n    function _transferERC20Token(address token, address recipient, uint256 level) internal {\n        uint256 amount = tokenAmountsByLevel[token][level];\n        require(amount > 0, \"TadleConnectors: token amount not configured for this level\");\n\n        IERC20 tokenContract = IERC20(token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        require(balance >= amount, \"TadleConnectors: insufficient contract token balance\");\n\n        SafeERC20.safeTransfer(tokenContract, recipient, amount);\n\n        totalClaimedAmounts[recipient][token] += amount;\n        emit TokensClaimed(recipient, token, amount, block.timestamp);\n    }\n}\n"
    }
}