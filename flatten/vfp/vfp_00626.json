{
    "vfp_id": "vfp_00626",
    "project_name": "OneSig Phase 2 Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "State Variable Visibility Not Explicitly Declared",
            "description": "The `SIGNATURE_LENGTH` state variable in `MultiSig.sol` does not have an explicitly declared visibility modifier. In Solidity, state variables default to internal visibility, but omitting the modifier reduces code clarity and may lead to confusion about intended access controls. This is a code quality issue rather than a direct security vulnerability. However, explicit visibility declarations improve maintainability and reduce the risk of misinterpretation during future development or audits. The impact is limited to reduced code readability and potential long-term maintenance risks.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::SIGNATURE_LENGTH"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Incomplete Docstring",
            "description": "The `SeedSet` event in `OneSig.sol` lacks complete documentation, specifically omitting documentation for the `seed` parameter. Properly documented events using NatSpec standards are essential for external developers, indexers, and auditors to understand the meaning and context of emitted events. Incomplete documentation can lead to misinterpretation of event data and integration errors in off-chain systems. While this does not introduce a direct security flaw, it degrades developer experience and increases the likelihood of incorrect assumptions. The impact is limited to reduced transparency and integration clarity.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::SeedSet"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Possible Duplicate Event Emissions",
            "description": "Several setter functions, including `_setThreshold` and `_setSeed`, emit events without first checking whether the new value differs from the current one. This can result in redundant event emissions when the same value is set multiple times. Although these functions are permissioned and not vulnerable to spam, duplicate events can confuse off-chain indexers and monitoring tools that rely on event logs to detect meaningful state changes. This inefficiency increases the cost and complexity of event processing. The root cause is the absence of a value comparison check before state updates. The impact is degraded indexer performance and potential misinterpretation of system state.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::_setThreshold",
                "OneSig.sol::_setSeed"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Documentation",
            "description": "The internal documentation for the `verifyNSignatures` function in `MultiSig.sol` incorrectly states that the number of signatures must exactly match the threshold, while the actual implementation only requires that the number of signatures is greater than or equal to the threshold. This discrepancy between documentation and code can mislead developers and auditors into believing stricter validation is in place than actually exists. While the behavior is functionally sound, the misleading comment may result in incorrect assumptions during integration or future audits. The root cause is outdated or inaccurate inline comments. The impact is potential confusion and incorrect threat modeling based on false assumptions.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::verifyNSignatures"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Ambiguous Error Handling",
            "description": "The `verifyNSignatures` function uses the same custom error `SignatureError` for two distinct failure conditions: when the signature data length is not a multiple of 65 bytes, and when the number of signatures is below the threshold. This lack of distinction makes it difficult for off-chain systems and developers to diagnose the exact cause of a transaction revert without parsing the input data or simulating the call. Clear, specific errors improve debugging and monitoring capabilities. The root cause is the use of a generic error type for multiple logical failures. The impact is reduced observability and increased difficulty in troubleshooting failed signature verifications.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::verifyNSignatures"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Seed Invalidation (Guardian L-01)",
            "description": "A malicious actor can front-run a `setSeed` transaction to execute a previously authorized transaction batch before the seed is updated. Since changing the seed is intended to invalidate existing signatures, delaying this update allows an attacker to exploit the window between signer consensus and on-chain seed update. The root cause is the lack of atomicity between seed invalidation and transaction execution. An attacker can monitor the mempool for `setSeed` calls and submit a competing `executeTransaction` with valid signatures and proof. The impact includes unintended execution of transactions that signers believed were invalidated, potentially leading to fund loss or state manipulation, and unexpected nonce increments that block legitimate transactions.\n",
            "severity": "Low",
            "location": [
                "OneSig.sol::executeTransaction",
                "OneSig.sol::setSeed"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Lacking Gas Validations Allows Censoring (Guardian L-03)",
            "description": "The `executeTransaction` function does not validate the amount of gas provided for individual external calls. This allows any address to invoke the function with insufficient gas, potentially causing some calls in a batch to succeed while others fail due to out-of-gas errors, especially within try/catch blocks. The root cause is the absence of a minimum gas check before making external calls. An attacker can manipulate execution outcomes by strategically underfunding the transaction, leading to partial execution and inconsistent state across chains. The impact includes potential censorship of specific operations, disruption of expected workflow, and increased risk of silent failures in cross-chain contexts.\n",
            "severity": "Low",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Network Fork Replay Attacks (Guardian L-04)",
            "description": "In the event of a blockchain fork, valid signatures for a Merkle root could be replayed on both the original and forked chain, leading to unintended transaction execution on one or both chains. The system does not include chain-specific context in the signed message, making signatures valid across forks of the same network. The root cause is the reliance on a static EIP-712 domain that does not incorporate chain ID or other fork-unique identifiers. While the probability is low, the impact could include duplicate executions, fund loss, or inconsistent state across forked networks, especially if one fork is abandoned.\n",
            "severity": "Low",
            "location": [
                "MultiSig.sol::verifyNSignatures"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Stale Transaction Execution on L2 (Guardian L-05)",
            "description": "On Layer 2 networks with sequencers (e.g., Arbitrum), a sequencer outage lasting more than 24 hours could allow stale transactions to be executed using outdated `block.timestamp` values. The expiration check relies on `block.timestamp`, which may not advance during extended outages. Once the sequencer resumes, old transactions with expired timestamps might still be accepted if the system clock has not caught up. The root cause is the dependence on `block.timestamp` for time-based validation without additional safeguards. The impact is limited to rare edge cases but could allow execution of outdated instructions under extreme conditions.\n",
            "severity": "Low",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "Multiple Signed Merkle Roots (Guardian L-06)",
            "description": "If multiple signed Merkle roots exist with overlapping nonces for the same OneSig instance, an arbitrary user can mix and match transactions from different roots using the `executeTransaction` function. This breaks the intended atomicity of a batch and allows for unintended combinations of operations. The root cause is the lack of binding between a transaction and its originating Merkle root beyond the nonce. An attacker can craft proofs from different valid roots to execute a custom sequence of actions. The impact includes unexpected execution outcomes, potential fund loss, and violation of the intended authorization model.\n",
            "severity": "Low",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "executeTransaction treats EOAs and Contracts the same when calling (SpearBit L-01)",
            "description": "The `executeTransaction` function uses low-level `.call` without differentiating between EOAs and contracts, which can mask silent failures. For example, sending ETH to an EOA always returns success, even if the recipient cannot receive it (e.g., due to missing `receive` function). In multichain setups, missing contracts on certain chains may lead to successful-looking calls that do nothing. Future changes like EIP-7702 could further alter behavior. The root cause is the uniform handling of all targets via `.call`. The impact includes false success reporting, reduced reliability, and potential loss of funds or incorrect state assumptions across chains.\n",
            "severity": "Low",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Unexpected Balance (Guardian I-01)",
            "description": "A signature that authorizes a transaction with a non-zero `value` field can be executed without including corresponding `msg.value`, effectively allowing an attacker to drain the contract's native token balance. The function does not enforce that `msg.value` matches the requested `value` when making external calls. The root cause is the lack of validation between the signed transaction value and the actual ETH sent. An attacker can exploit this by calling `executeTransaction` with a high `value` but zero `msg.value`, causing the contract to forward its own balance. The impact is potential loss of funds held in the contract.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unnecessary Return Data (Guardian I-04)",
            "description": "The `executeTransaction` function uses `.call` and loads return data into memory even when it is not used or validated. This wastes gas due to unnecessary memory allocation and copying. The root cause is inefficient use of low-level call patterns. While the impact is not a security vulnerability, it increases execution cost and reduces efficiency, especially for transactions that do not require return data inspection. This is a gas optimization issue that affects scalability and user cost.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Smart Contract Signer Exclusion (Guardian I-05)",
            "description": "The `ECDSA.recover` function used for signature verification only supports signatures from EOA wallets, excluding contract-based signers such as DAO multisigs or smart wallet accounts. The root cause is the reliance on standard ECDSA recovery, which cannot verify signatures produced by contract wallets that do not support EIP-1271. This limits the flexibility and adoption of the protocol in ecosystems where smart contract wallets are prevalent. The impact is reduced composability and exclusion of modern wallet infrastructure.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::verifyNSignatures"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing Event in Receive Function (Guardian I-06)",
            "description": "The `receive` function allows the contract to accept native token deposits but does not emit an event. This makes it impossible for off-chain services to track or index incoming ETH transfers, reducing transparency and auditability. The root cause is the omission of an event emission in the `receive` fallback. The impact is limited visibility into the contract's balance changes, which can hinder accounting, monitoring, and user notifications.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::receive"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Time Drift Across Networks May Be Unexpected (Guardian I-07)",
            "description": "The expiration time for a Merkle root is applied globally, but `block.timestamp` can vary across different chains due to network latency or clock drift. This means a transaction that is expired on one chain might still be valid on another, leading to inconsistent execution outcomes. The root cause is the lack of chain-specific time validation or synchronization mechanisms. The impact includes potential execution of expired transactions on some chains, undermining the intended time-based security guarantees in a cross-chain context.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Low-Level Calls Do Not Validate Contract Code (Guardian I-08)",
            "description": "The `executeTransaction` function performs low-level calls to arbitrary addresses without verifying that the target is a valid contract (i.e., has code). This allows calls to EOAs or empty addresses to succeed silently, which may be misinterpreted as successful execution. The root cause is the absence of a `extcodesize` check before making external calls. The impact includes misleading success indicators, potential loss of funds sent to non-contracts, and reduced reliability of cross-chain operations.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Stuck Nonce (Guardian I-09)",
            "description": "If a transaction fails during execution, the nonce does not increment, preventing all subsequent transactions from being executed until the failed transaction is either successfully executed or invalidated via `setSeed`. The root cause is the nonce increment being conditional on successful execution. This creates a denial-of-service vector where a single failing transaction can block the entire queue. The impact is operational disruption and potential freezing of critical updates until manual intervention.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Unexpected Reinstatement Of Transactions (Guardian I-10)",
            "description": "Resetting the `seed` to a previously used value can inadvertently reinstate old, previously invalidated signatures if the nonce is still valid. This allows execution of transactions that were meant to be permanently invalidated. The root cause is the stateless nature of seed validationâ€”there is no history or revocation list. The impact includes potential replay of old instructions and unexpected state changes, especially if signers accidentally reuse a seed value.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::setSeed",
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-544"
                ]
            },
            "title": "Useful Error Data (ID-06, Guardian)",
            "description": "When a transaction execution fails, the error message returned is generic (\"execution error\") and does not include any contextual data such as the failing target, function, or reason. This makes debugging failed transactions extremely difficult for developers and users. The root cause is the lack of error propagation or structured error reporting. The impact is poor developer experience, increased time to diagnose issues, and reduced transparency in failure scenarios.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Version Compatibility (Guardian I-13)",
            "description": "All cross-chain instances of OneSig must maintain the same `VERSION` constant. If versions are mismatched across chains, it can lead to integration issues, incorrect assumptions, or failed verifications. The root cause is the lack of version negotiation or compatibility checks between instances. The impact is increased deployment complexity and risk of operational errors during upgrades or multi-chain coordination.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::VERSION"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Token Transfer May Silently Fail (Guardian I-14)",
            "description": "External calls, such as token transfers (e.g., USDT), may return `false` on failure, but the `executeTransaction` function does not check the return value or revert in such cases. Instead, it reports success even when the transfer did not occur. The root cause is the lack of return value validation for external calls. The impact includes silent failures of critical operations, false success reporting, and potential loss of funds or incorrect state assumptions.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Missing EIP-5267 (Guardian I-15)",
            "description": "The contract does not implement the `eip712Domain` function as standardized by EIP-5267, which would allow external systems to query the EIP-712 domain separator used for signing. The root cause is the omission of a standardized interface for domain inspection. The impact is reduced interoperability with wallet and signing tools that expect this function to be present, increasing integration complexity.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::eip712Domain"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Unwieldy Seed Behavior (Guardian I-18)",
            "description": "While seeds are intended to prevent signature replay, they must remain identical across all cross-chain instances of OneSig. This makes it impractical to invalidate a Merkle root on a single chain without coordinating a global seed update across all chains. The root cause is the global nature of seed synchronization. The impact is operational complexity and reduced flexibility in managing security incidents on a per-chain basis.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::setSeed"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Arbitrary Transaction Ordering (Guardian I-19)",
            "description": "Since `executeTransaction` can be called by any address, malicious actors can influence the order in which transactions are executed, potentially front-running or reordering sensitive operations like swaps. The root cause is the permissionless execution model. While this does not break the authorization model, it allows external manipulation of execution sequence. The impact includes potential financial loss due to front-running and disruption of intended protocol logic.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Threshold and Signer Consistency (Guardian I-21)",
            "description": "Deployments across chains may have inconsistent threshold or signer configurations, leading to confusion, increased risk of errors, and degraded user experience. The root cause is the lack of enforcement or verification of cross-chain configuration consistency. The impact is operational risk and potential for misconfigured instances to behave unexpectedly compared to others.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::threshold",
                "MultiSig.sol::signers"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Math optimization in `verifyNSignatures` (Spearbit I-02)",
            "description": "The `verifyNSignatures` function performs two multiplication operations for each signature during length validation, which is computationally redundant. The root cause is suboptimal arithmetic logic in the loop. While this does not introduce a security vulnerability, it increases gas consumption unnecessarily. The impact is higher execution costs and reduced efficiency, especially for large numbers of signatures.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::verifyNSignatures"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Missing Docstrings (OpenZeppelin N-02)",
            "description": "The `LEAF_ENCODING_VERSION` constant lacks a NatSpec docstring, reducing code clarity and making it harder for developers to understand its purpose. The root cause is incomplete documentation. The impact is reduced readability and maintainability, especially for external contributors or auditors.\n",
            "severity": "Informational",
            "location": [
                "OneSig.sol::LEAF_ENCODING_VERSION"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Function Visibility Overly Permissive (OpenZeppelin N-04)",
            "description": "Several functions, including `getSigners`, `setSeed`, and `executeTransaction`, are marked `public` when they are only intended to be called externally. Marking them `external` would reduce gas costs and better reflect their intended usage. The root cause is the use of a more permissive visibility modifier than necessary. The impact is slightly higher gas consumption and reduced code clarity regarding function access patterns.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::getSigners",
                "OneSig.sol::setSeed",
                "OneSig.sol::executeTransaction"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol",
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Floating Pragma (OpenZeppelin N-05, Guardian I-16)",
            "description": "The Solidity pragma `^0.8.22` allows compilation with any minor version above 0.8.22, which may introduce unintended compiler behavior or optimizations. The root cause is the use of a floating pragma instead of a fixed version. The impact includes potential compilation inconsistencies across environments and risk of unexpected behavior due to compiler updates.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol",
                "OneSig.sol"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol",
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Lack of Indexed Event Parameters (OpenZeppelin N-06)",
            "description": "Events such as `SignerSet`, `ThresholdSet`, `SeedSet`, and `TransactionExecuted` do not use indexed parameters, making it difficult for off-chain services to efficiently filter logs based on key fields. The root cause is the omission of the `indexed` keyword for important event parameters. The impact is reduced query efficiency and increased cost for event-based indexing and monitoring.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol::SignerSet",
                "MultiSig.sol::ThresholdSet",
                "OneSig.sol::SeedSet",
                "OneSig.sol::TransactionExecuted"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol",
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "EVM Version Compatibility (OpenZeppelin N-08)",
            "description": "The contract does not specify an `evmVersion` in the compiler settings, defaulting to `cancun`. This risks deployment failures on chains that do not support newer opcodes like `PUSH0` or `MCOPY`. The root cause is the lack of explicit EVM version pinning. The impact is potential incompatibility with older or non-upgraded EVM chains, limiting deployment flexibility.\n",
            "severity": "Informational",
            "location": [
                "MultiSig.sol",
                "OneSig.sol"
            ],
            "files": [
                "onesig/packages/onesig-evm/contracts/MultiSig.sol",
                "onesig/packages/onesig-evm/contracts/OneSig.sol"
            ]
        }
    ],
    "affected_files": {
        "OneSig.sol": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.22;\n\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { MultiSig } from \"./MultiSig.sol\";\nimport { ExecutorStore } from \"./ExecutorStore.sol\";\n\n/**\n * @title OneSig\n * @author @TRileySchwarz, @Clearwood, @HansonYip, @mok-lz\n * @notice A multi-chain enabled contract that uses a Merkle tree of transaction leaves.\n *         It allows transactions to be signed once (off-chain) and then executed on multiple chains,\n *         provided the Merkle proof is valid and the threshold of signers is met.\n * @dev Inherits from MultiSig for signature threshold logic.\n */\ncontract OneSig is MultiSig, ReentrancyGuard, ExecutorStore {\n    /// @notice The version string of the OneSig contract.\n    string public constant VERSION = \"0.0.1\";\n\n    uint8 public constant LEAF_ENCODING_VERSION = 1;\n\n    /**\n     * @dev EIP-191 defines the format of the signature prefix.\n     *      See https://eips.ethereum.org/EIPS/eip-191\n     */\n    string private constant EIP191_PREFIX_FOR_EIP712 = \"\\x19\\x01\";\n\n    /**\n     * @dev EIP-712 domain separator type-hash.\n     *      See https://eips.ethereum.org/EIPS/eip-712\n     */\n    bytes32 private constant EIP712DOMAIN_TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /**\n     * @dev This domain separator is used to generate a signature hash for the merkle root,\n     *      specifically using chainId = 1 (Ethereum Mainnet) and verifyingContract = 0xdEaD.\n     *      This ensures that the same merkle root signatures can be used across different chains\n     *      because they are all signed with this consistent \"fake\" domain.\n     *\n     *      In other words, to verify the merkle root with the same signatures on different chains,\n     *      we use the same chainId (1) and verifyingContract (0xdEaD) in the EIP-712 domain.\n     */\n    bytes32 private constant DOMAIN_SEPARATOR =\n        keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPE_HASH,\n                keccak256(bytes(\"OneSig\")), // this contract name\n                keccak256(bytes(VERSION)), // version\n                1, // Ethereum mainnet chainId\n                address(0xdEaD) // verifyingContract\n            )\n        );\n\n    /**\n     * @dev The type-hash of the data being signed to authorize a merkle root.\n     */\n    bytes32 private constant SIGN_MERKLE_ROOT_TYPE_HASH =\n        keccak256(\"SignMerkleRoot(bytes32 seed,bytes32 merkleRoot,uint256 expiry)\");\n\n    /**\n     * @notice The OneSig ID of the contract.\n     * @dev Because the oneSigId is part of the leaf, the same signatures can be used on different chains,\n     *      while leaving each transaction to be targeted towards one\n     */\n    uint64 public immutable ONE_SIG_ID;\n\n    /**\n     * @notice A random seed encoded into the signatures/root.\n     * @dev Allows for a previously signed, but unexecuted, transaction(s) to be 'revoked' by changing the seed.\n     */\n    bytes32 public seed;\n\n    /**\n     * @notice A sequential nonce to prevent replay attacks and enforce transaction ordering.\n     */\n    uint64 public nonce;\n\n    /// @notice Emitted when the seed is updated.\n    event SeedSet(bytes32 seed);\n\n    /// @notice Emitted when a transaction is executed.\n    /// @param merkleRoot The merkle root used to authorize the transaction.\n    /// @param nonce The nonce of the transaction.\n    event TransactionExecuted(bytes32 merkleRoot, uint256 nonce);\n\n    /// @notice Error thrown when a merkle proof is invalid or the nonce does not match the expected value.\n    error InvalidProofOrNonce();\n\n    /// @notice Error thrown when a merkle root has expired (past the _expiry timestamp).\n    error MerkleRootExpired();\n\n    /// @notice Error thrown when a call in the transaction array fails.\n    /// @param index The index of the failing call within the transaction.\n    error ExecutionFailed(uint256 index);\n\n    /// @notice Error thrown when a function is not called from an executor or signer.\n    error OnlyExecutorOrSigner();\n\n    /**\n     * @notice Call to be executed as part of a Transaction.calls.\n     *  - OneSig -> [Arbitrary contract].\n     *  - e.g., setPeer(dstEid, remoteAddress).\n     * @param to Address of the contract for this data to be 'called' on.\n     * @param value Amount of ether to send with this call.\n     * @param data Encoded data to be sent to the contract (calldata).\n     */\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /**\n     * @notice Single call to the OneSig contract (address(this)).\n     *  - EOA -> OneSig\n     *  - This struct is 1:1 with a 'leaf' in the merkle tree.\n     *  - Execution of the underlying calls are atomic.\n     *  - Cannot be processed until the previous leaf (nonce-ordered) has been executed successfully.\n     * @param calls List of calls to be made.\n     * @param proof Merkle proof to verify the transaction.\n     */\n    struct Transaction {\n        Call[] calls;\n        bytes32[] proof;\n    }\n\n    /**\n     * @dev Restricts access to functions so they can only be called via an executor, OR a multisig signer.\n     */\n    modifier onlyExecutorOrSigner() {\n        if (!canExecuteTransaction(msg.sender)) revert OnlyExecutorOrSigner();\n        _;\n    }\n\n    /**\n     * @notice Constructor to initialize the OneSig contract.\n     * @dev Inherits MultiSig(_signers, _threshold).\n     * @param _oneSigId A unique identifier per deployment, (typically block.chainid).\n     * @param _signers The list of signers authorized to sign transactions.\n     * @param _threshold The initial threshold of signers required to execute a transaction.\n     * @param _executors The list of executors authorized to execute transactions.\n     * @param _executorRequired If executors are required to execute transactions.\n     * @param _seed The random seed to encode into the signatures/root.\n     */\n    constructor(\n        uint64 _oneSigId,\n        address[] memory _signers,\n        uint256 _threshold,\n        address[] memory _executors,\n        bool _executorRequired,\n        bytes32 _seed\n    ) MultiSig(_signers, _threshold) ExecutorStore(_executors, _executorRequired) {\n        ONE_SIG_ID = _oneSigId;\n        _setSeed(_seed);\n    }\n\n    /**\n     * @notice Internal method to set the contract's seed.\n     * @param _seed The new seed value.\n     */\n    function _setSeed(bytes32 _seed) internal virtual {\n        seed = _seed;\n        emit SeedSet(_seed);\n    }\n\n    /**\n     * @notice Sets the contract's seed.\n     * @dev Only callable via MultiSig functionality (i.e., requires threshold signatures from signers).\n     * @param _seed The new seed value.\n     */\n    function setSeed(bytes32 _seed) public virtual onlySelfCall {\n        _setSeed(_seed);\n    }\n\n    /**\n     * @notice Executes a single transaction (which corresponds to a leaf in the merkle tree) if valid signatures are provided.\n     * @dev '_transaction' corresponds 1:1 with a leaf. This function can be called by anyone (permissionless),\n     *      provided the merkle root is verified with sufficient signatures.\n     * @param _transaction The transaction data struct, including calls and proof.\n     * @param _merkleRoot The merkle root that authorizes this transaction.\n     * @param _expiry The timestamp after which the merkle root expires.\n     * @param _signatures Signatures from signers that meet the threshold.\n     */\n    function executeTransaction(\n        Transaction calldata _transaction,\n        bytes32 _merkleRoot,\n        uint256 _expiry,\n        bytes calldata _signatures\n    ) public payable virtual nonReentrant onlyExecutorOrSigner {\n        // Verify the merkle root and signatures\n        verifyMerkleRoot(_merkleRoot, _expiry, _signatures);\n\n        // Verify that this transaction matches the merkle root (using its proof)\n        verifyTransactionProof(_merkleRoot, _transaction);\n\n        // Increment nonce before execution to prevent replay\n        uint256 n = nonce++;\n\n        // Execute all calls atomically\n        for (uint256 i = 0; i < _transaction.calls.length; i++) {\n            (bool success, ) = _transaction.calls[i].to.call{ value: _transaction.calls[i].value }(\n                _transaction.calls[i].data\n            );\n\n            // Revert if the call fails\n            if (!success) revert ExecutionFailed(i);\n        }\n\n        emit TransactionExecuted(_merkleRoot, n);\n    }\n\n    /**\n     * @notice Validates the signatures on a given merkle root.\n     * @dev Reverts if the merkle root is expired or signatures do not meet the threshold.\n     * @param _merkleRoot The merkle root to verify.\n     * @param _expiry The timestamp after which the merkle root becomes invalid.\n     * @param _signatures The provided signatures.\n     */\n    function verifyMerkleRoot(bytes32 _merkleRoot, uint256 _expiry, bytes calldata _signatures) public view {\n        // Check expiry\n        if (block.timestamp > _expiry) revert MerkleRootExpired();\n\n        // Compute the EIP-712 hash\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(SIGN_MERKLE_ROOT_TYPE_HASH, seed, _merkleRoot, _expiry))\n            )\n        );\n\n        // Verify the threshold signatures\n        verifySignatures(digest, _signatures);\n    }\n\n    /**\n     * @notice Verifies that the provided merkle proof matches the current transaction leaf under the merkle root.\n     * @dev Reverts if the proof is invalid or the nonce doesn't match the expected value.\n     * @param _merkleRoot The merkle root being used.\n     * @param _transaction The transaction data containing proof and calls.\n     */\n    function verifyTransactionProof(bytes32 _merkleRoot, Transaction calldata _transaction) public view {\n        bytes32 leaf = encodeLeaf(nonce, _transaction.calls);\n        bool valid = MerkleProof.verifyCalldata(_transaction.proof, _merkleRoot, leaf);\n        if (!valid) revert InvalidProofOrNonce();\n    }\n\n    /**\n     * @notice Double encodes the transaction leaf for inclusion in the merkle tree.\n     * @param _nonce The nonce of the transaction.\n     * @param _calls The calls to be made in this transaction.\n     * @return The keccak256 hash of the encoded leaf.\n     */\n    function encodeLeaf(uint64 _nonce, Call[] calldata _calls) public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    keccak256(\n                        abi.encodePacked(\n                            LEAF_ENCODING_VERSION,\n                            ONE_SIG_ID,\n                            bytes32(uint256(uint160(address(this)))), // convert address(this) into bytes32\n                            _nonce,\n                            abi.encode(_calls)\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Checks if the a given address can execute a transaction.\n     * @param _sender The address of the message sender.\n     * @return True if executeTransaction can be called by the executor, otherwise false.\n     */\n    function canExecuteTransaction(address _sender) public view returns (bool) {\n        // If the flag is set to false, then ANYONE can execute permissionlessly, otherwise the msg.sender must be a executor, or a signer\n        return (!executorRequired || isExecutor(_sender) || isSigner(_sender));\n    }\n\n    /**\n     * @notice Fallback function to receive ether.\n     * @dev Allows the contract to accept ETH.\n     */\n    receive() external payable {}\n}\n",
        "MultiSig.sol": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.22;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SelfCallable } from \"./lib/SelfCallable.sol\";\n\n/**\n * @title MultiSig\n * @notice Abstract contract that manages a set of signers and a signature threshold.\n *         Designed to be inherited by contracts requiring multi-signature verification.\n * @dev Uses EnumerableSet to store signer addresses and ECDSA for signature recovery.\n */\nabstract contract MultiSig is SelfCallable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @dev Set of available signers for the MultiSig.\n     */\n    EnumerableSet.AddressSet internal signerSet;\n\n    /**\n     * @notice The number of signatures required to execute a transaction.\n     */\n    uint256 public threshold;\n\n    /// @notice Error thrown when a signer address is invalid.\n    error InvalidSigner();\n\n    /// @notice Error thrown when the threshold is set to zero.\n    error ZeroThreshold();\n\n    /// @notice Error thrown when the total number of signers is less than the threshold.\n    /// @param totalSigners The current number of signers.\n    /// @param threshold The required threshold.\n    error TotalSignersLessThanThreshold(uint256 totalSigners, uint256 threshold);\n\n    /// @notice Error thrown when attempting to add a signer who is already active.\n    /// @param signer The address of the signer.\n    error SignerAlreadyAdded(address signer);\n\n    /// @notice Error thrown when attempting to remove a signer who is not found.\n    /// @param signer The address of the signer.\n    error SignerNotFound(address signer);\n\n    /// @notice Error thrown when there is a signature format error or mismatch in length.\n    error SignatureError();\n\n    /// @notice Error thrown when signers are not sorted in ascending order (prevents duplicates).\n    error UnsortedSigners();\n\n    /**\n     * @notice Emitted when a signer's active status is updated.\n     * @param signer The address of the signer.\n     * @param active True if added, false if removed.\n     */\n    event SignerSet(address indexed signer, bool active);\n\n    /**\n     * @notice Emitted when the threshold for signatures is set.\n     * @param threshold The new threshold.\n     */\n    event ThresholdSet(uint256 threshold);\n\n    /**\n     * @dev The length of a single signature in bytes (r=32, s=32, v=1).\n     */\n    uint8 constant SIGNATURE_LENGTH = 65;\n\n    /**\n     * @dev Initializes the MultiSig with a list of signers and sets the signature threshold.\n     * @param _signers Array of signer addresses.\n     * @param _threshold The initial threshold for signatures.\n     */\n    constructor(address[] memory _signers, uint256 _threshold) {\n        for (uint256 i = 0; i < _signers.length; i++) {\n            _addSigner(_signers[i]);\n        }\n        _setThreshold(_threshold);\n    }\n\n    /**\n     * @notice Allows the MultiSig contract to update the signature threshold.\n     * @dev This function can only be called by the MultiSig contract itself.\n     * @param _threshold The new threshold value.\n     */\n    function setThreshold(uint256 _threshold) external onlySelfCall {\n        _setThreshold(_threshold);\n    }\n\n    /**\n     * @dev Internal function to set the threshold for this MultiSig.\n     *      - The threshold must be greater than zero.\n     *      - The threshold must be less than or equal to the number of signers.\n     * @param _threshold The new threshold value.\n     */\n    function _setThreshold(uint256 _threshold) internal {\n        if (_threshold == 0) revert ZeroThreshold();\n        if (totalSigners() < _threshold) revert TotalSignersLessThanThreshold(totalSigners(), _threshold);\n\n        threshold = _threshold;\n        emit ThresholdSet(_threshold);\n    }\n\n    /**\n     * @notice Adds or removes a signer from this MultiSig.\n     * @dev Only callable via the MultiSig contract itself.\n     * @param _signer The address of the signer to add/remove.\n     * @param _active True to add signer, false to remove signer.\n     */\n    function setSigner(address _signer, bool _active) external onlySelfCall {\n        if (_active) {\n            _addSigner(_signer);\n        } else {\n            _removeSigner(_signer);\n        }\n    }\n\n    /**\n     * @dev Internal function to add a signer.\n     *      - `address(0)` is not a valid signer.\n     *      - A signer cannot be added twice.\n     * @param _signer The address of the signer to add.\n     */\n    function _addSigner(address _signer) internal {\n        if (_signer == address(0)) revert InvalidSigner();\n        if (!signerSet.add(_signer)) revert SignerAlreadyAdded(_signer);\n\n        emit SignerSet(_signer, true);\n    }\n\n    /**\n     * @dev Internal function to remove a signer.\n     *      - Signer must be part of the existing set of signers.\n     *      - The threshold must be less than or equal to the number of remaining signers.\n     * @param _signer The address of the signer to remove.\n     */\n    function _removeSigner(address _signer) internal {\n        if (!signerSet.remove(_signer)) revert SignerNotFound(_signer);\n        if (totalSigners() < threshold) revert TotalSignersLessThanThreshold(totalSigners(), threshold);\n\n        emit SignerSet(_signer, false);\n    }\n\n    /**\n     * @notice Verifies signatures on a given digest against the threshold.\n     * @dev Verifies that exactly `threshold` signatures are present, sorted by ascending signer addresses.\n     * @param _digest The message digest (hash) being signed.\n     * @param _signatures The concatenated signatures.\n     */\n    function verifySignatures(bytes32 _digest, bytes calldata _signatures) public view {\n        verifyNSignatures(_digest, _signatures, threshold);\n    }\n\n    /**\n     * @notice Verifies N signatures on a given digest.\n     * @dev Reverts if:\n     *       - The threshold passed is zero.\n     *       - The number of signatures doesn't match N (each signature is 65 bytes).\n     *       - The signers are not strictly increasing (to prevent duplicates).\n     *       - Any signer is not in the set of authorized signers.\n     * @param _digest The message digest (hash) being signed.\n     * @param _signatures The concatenated signatures.\n     * @param _threshold The required number of valid signatures.\n     */\n    function verifyNSignatures(bytes32 _digest, bytes calldata _signatures, uint256 _threshold) public view {\n        if (_threshold == 0) revert ZeroThreshold();\n        // Each signature is SIGNATURE_LENGTH (65) bytes (r=32, s=32, v=1).\n        if ((_signatures.length % SIGNATURE_LENGTH) != 0) revert SignatureError();\n        uint256 signaturesCount = _signatures.length / SIGNATURE_LENGTH;\n        if (signaturesCount < _threshold) revert SignatureError();\n\n        // There cannot be a signer with address 0, so we start with address(0) to ensure ascending order.\n        address lastSigner = address(0);\n\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            // Extract a single signature (SIGNATURE_LENGTH (65) bytes) at a time.\n            bytes calldata signature = _signatures[i * SIGNATURE_LENGTH:(i + 1) * SIGNATURE_LENGTH];\n            address currentSigner = ECDSA.recover(_digest, signature);\n\n            // Check ordering to avoid duplicates and ensure strictly increasing addresses.\n            if (currentSigner <= lastSigner) revert UnsortedSigners();\n            // Check if the signer is in our set.\n            if (!isSigner(currentSigner)) revert SignerNotFound(currentSigner);\n            lastSigner = currentSigner;\n        }\n    }\n\n    /**\n     * @notice Returns the list of all active signers.\n     * @return An array of addresses representing the current set of signers.\n     */\n    function getSigners() public view returns (address[] memory) {\n        return signerSet.values();\n    }\n\n    /**\n     * @notice Checks if a given address is in the set of signers.\n     * @param _signer The address to check.\n     * @return True if the address is a signer, otherwise false.\n     */\n    function isSigner(address _signer) public view returns (bool) {\n        return signerSet.contains(_signer);\n    }\n\n    /**\n     * @notice Returns the total number of active signers.\n     * @return The number of signers currently active.\n     */\n    function totalSigners() public view returns (uint256) {\n        return signerSet.length();\n    }\n}\n"
    }
}