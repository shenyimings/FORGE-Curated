{
    "vfp_id": "vfp_00420",
    "project_name": "ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ],
                "4": [
                    "CWE-638"
                ],
                "5": [
                    "CWE-424"
                ]
            },
            "title": "BalancerFlashLoan Missing Access Control",
            "description": "The BalancerFlashLoan contract's makeFlashLoan() function lacks access control, allowing any address to trigger flashloans with arbitrary parameters. Although the intended flow requires the zapper to call makeFlashLoan(), the absence of authorization checks means attackers can bypass the zapper's access controls and directly manipulate troves.\n\nThe root cause is the missing validation that only authorized zapper contracts can initiate flashloans. Furthermore, the receiveFlashLoan callback only verifies that the call originates from the Balancer vault, not that it was part of a legitimate flashloan initiated by a zapper.\n\nAn attacker can exploit this by calling makeFlashLoan() directly or by invoking the Balancer vault with BalancerFlashLoan as the recipient. This allows unauthorized trove adjustments—such as levering up close to liquidation or reducing leverage—enabling profitable sandwich attacks through slippage manipulation.\n\nThe impact includes unauthorized modification of user troves, potential liquidation, and financial loss due to adverse trade execution. The fix involved setting a storage-based receiver variable during makeFlashLoan() (set to msg.sender, expected to be a zapper) and having receiveFlashLoan() call only that stored address. Direct callbacks to receiveFlashLoan with zero receiver are now reverted, closing the attack vector.\n",
            "severity": "High",
            "location": [
                "BalancerFlashLoan.sol::makeFlashLoan#",
                "BalancerFlashLoan.sol::receiveFlashLoan#"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Receiver Address in Balancer Flashloan Is Reset Late",
            "description": "The receiver address in `BalancerFlashLoan` is reset after the flash loan callback, rather than at the beginning of the callback, increasing risk in future code changes.\n\nThe root cause is that the reset pattern does not follow secure state-clearing best practices.\n\nIn a fork or modified version, this could allow reentrancy or unauthorized callbacks if the reset is skipped.\n\nThe impact is increased risk of vulnerabilities in future versions or forks, though no immediate exploit exists in the current design.\n",
            "severity": "Informational",
            "location": [
                "BalancerFlashLoan.makeFlashLoan",
                "BalancerFlashLoan.receiveFlashLoan"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        }
    ],
    "affected_files": {
        "BalancerFlashLoan.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Balancer/vault/IVault.sol\";\nimport \"./Balancer/vault/IFlashLoanRecipient.sol\";\n\nimport \"../../Interfaces/ILeverageZapper.sol\";\nimport \"../../Interfaces/IFlashLoanReceiver.sol\";\nimport \"../../Interfaces/IFlashLoanProvider.sol\";\n\ncontract BalancerFlashLoan is IFlashLoanRecipient, IFlashLoanProvider {\n    using SafeERC20 for IERC20;\n\n    IVault private constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    IFlashLoanReceiver public receiver;\n\n    function makeFlashLoan(IERC20 _token, uint256 _amount, Operation _operation, bytes calldata _params) external {\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n\n        // Data for the callback receiveFlashLoan\n        bytes memory userData;\n        if (_operation == Operation.OpenTrove) {\n            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =\n                abi.decode(_params, (ILeverageZapper.OpenLeveragedTroveParams));\n            userData = abi.encode(_operation, openTroveParams);\n        } else if (_operation == Operation.LeverUpTrove) {\n            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =\n                abi.decode(_params, (ILeverageZapper.LeverUpTroveParams));\n            userData = abi.encode(_operation, leverUpTroveParams);\n        } else if (_operation == Operation.LeverDownTrove) {\n            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =\n                abi.decode(_params, (ILeverageZapper.LeverDownTroveParams));\n            userData = abi.encode(_operation, leverDownTroveParams);\n        } else if (_operation == Operation.CloseTrove) {\n            IZapper.CloseTroveParams memory closeTroveParams = abi.decode(_params, (IZapper.CloseTroveParams));\n            userData = abi.encode(_operation, closeTroveParams);\n        } else {\n            revert(\"LZ: Wrong Operation\");\n        }\n\n        // This will be used by the callback below no\n        receiver = IFlashLoanReceiver(msg.sender);\n\n        vault.flashLoan(this, tokens, amounts, userData);\n    }\n\n    function receiveFlashLoan(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata feeAmounts,\n        bytes calldata userData\n    ) external override {\n        require(msg.sender == address(vault), \"Caller is not Vault\");\n        require(address(receiver) != address(0), \"Flash loan not properly initiated\");\n\n        // Cache and reset receiver, to comply with CEI pattern, as some callbacks in zappers do raw calls\n        // It’s not necessary, as Balancer flash loans are protected against re-entrancy\n        // But it’s safer, specially if someone tries to reuse this code, and more gas efficient\n        IFlashLoanReceiver receiverCached = receiver;\n        receiver = IFlashLoanReceiver(address(0));\n\n        // decode and operation\n        Operation operation = abi.decode(userData[0:32], (Operation));\n\n        if (operation == Operation.OpenTrove) {\n            // Open\n            // decode params\n            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =\n                abi.decode(userData[32:], (ILeverageZapper.OpenLeveragedTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnOpenLeveragedTrove(openTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.LeverUpTrove) {\n            // Lever up\n            // decode params\n            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =\n                abi.decode(userData[32:], (ILeverageZapper.LeverUpTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnLeverUpTrove(leverUpTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.LeverDownTrove) {\n            // Lever down\n            // decode params\n            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =\n                abi.decode(userData[32:], (ILeverageZapper.LeverDownTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnLeverDownTrove(leverDownTroveParams, effectiveFlashLoanAmount);\n        } else if (operation == Operation.CloseTrove) {\n            // Close trove\n            // decode params\n            IZapper.CloseTroveParams memory closeTroveParams = abi.decode(userData[32:], (IZapper.CloseTroveParams));\n            // Flash loan minus fees\n            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];\n            // We send only effective flash loan, keeping fees here\n            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);\n            // Zapper callback\n            receiverCached.receiveFlashLoanOnCloseTroveFromCollateral(closeTroveParams, effectiveFlashLoanAmount);\n        } else {\n            revert(\"LZ: Wrong Operation\");\n        }\n\n        // Return flash loan\n        tokens[0].safeTransfer(address(vault), amounts[0] + feeAmounts[0]);\n    }\n}\n"
    }
}