{
    "vfp_id": "vfp_00404",
    "project_name": "OIF Contracts Diff Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Relationship Between `fillDeadline` and `expiryDeadline` Is Not Enforced",
            "description": "In the `InputSettlerEscrow` contract, the `open` function checks that the current timestamp is before both `fillDeadline` and `expiryDeadline`, but it does not enforce that `fillDeadline` must be earlier than `expiryDeadline`. This allows for logically inconsistent orders where the fill deadline occurs after the order has already expired. The root cause is the absence of a validation check comparing the two deadlines during order creation. A user could accidentally create such an order, leading to a situation where the order is technically valid but cannot be filled, resulting in a soft denial of service. While not directly exploitable by an attacker for financial gain, it introduces user experience and reliability issues, potentially leading to locked funds and failed transactions. The impact is limited to usability and correctness, but it undermines the predictability of the system.\n",
            "severity": "Low",
            "location": [
                "InputSettlerEscrow.sol::open#136-137"
            ],
            "files": [
                "oif-contracts/src/input/escrow/InputSettlerEscrow.sol"
            ]
        }
    ],
    "affected_files": {
        "InputSettlerEscrow.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { EfficiencyLib } from \"the-compact/src/lib/EfficiencyLib.sol\";\n\nimport { IERC3009 } from \"../../interfaces/IERC3009.sol\";\n\nimport { IInputCallback } from \"../../interfaces/IInputCallback.sol\";\nimport { IInputOracle } from \"../../interfaces/IInputOracle.sol\";\nimport { IInputSettlerEscrow } from \"../../interfaces/IInputSettlerEscrow.sol\";\n\nimport { BytesLib } from \"../../libs/BytesLib.sol\";\nimport { IsContractLib } from \"../../libs/IsContractLib.sol\";\nimport { LibAddress } from \"../../libs/LibAddress.sol\";\n\nimport { MandateOutput } from \"../types/MandateOutputType.sol\";\nimport { OrderPurchase } from \"../types/OrderPurchaseType.sol\";\nimport { StandardOrder, StandardOrderType } from \"../types/StandardOrderType.sol\";\n\nimport { InputSettlerPurchase } from \"../InputSettlerPurchase.sol\";\nimport { Permit2WitnessType } from \"./Permit2WitnessType.sol\";\n\n/**\n * @title OIF Input Settler supporting using an explicit escrow.\n * @notice This Catalyst Settler implementation contained an escrow to manage input assets. Intents are initiated by\n * depositing assets through either `::open` by msg.sender or `::openFor` by `order.user`. Since tokens are collected on\n * the `::open(For)` call, it is important to wait for the `::open(For)` call to be final before filling the intent.\n *\n * Using Permit2 to call `::openFor` with, `openDeadline` is identical to `order.fillDeadline`. Before calling\n * `::openFor` ensure there is sufficient time to fill.\n *\n * If an order has not been finalised / claimed before `order.expires`, anyone may call `::refund` to send\n * `order.inputs` to `order.user`. Note that if this is not done, an order finalised after `order.expires` still claims\n * `order.inputs` for the solver.\n */\ncontract InputSettlerEscrow is InputSettlerPurchase, IInputSettlerEscrow {\n    using StandardOrderType for bytes;\n    using StandardOrderType for StandardOrder;\n    using LibAddress for bytes32;\n\n    error InvalidOrderStatus();\n    error OrderIdMismatch(bytes32 provided, bytes32 computed);\n    error InputTokenHasDirtyBits();\n    error SignatureAndInputsNotEqual();\n    error ReentrancyDetected();\n    error SignatureNotSupported(bytes1);\n\n    event Open(bytes32 indexed orderId, bytes order);\n    event Refunded(bytes32 indexed orderId);\n\n    bytes1 internal constant SIGNATURE_TYPE_PERMIT2 = 0x00;\n    bytes1 internal constant SIGNATURE_TYPE_3009 = 0x01;\n    bytes1 internal constant SIGNATURE_TYPE_SELF = 0xff;\n\n    enum OrderStatus {\n        None,\n        Deposited,\n        Claimed,\n        Refunded\n    }\n\n    mapping(bytes32 orderId => OrderStatus) public orderStatus;\n\n    // Address of the Permit2 contract.\n    ISignatureTransfer constant PERMIT2 = ISignatureTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    function _domainNameAndVersion()\n        internal\n        pure\n        virtual\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"OIFEscrow\";\n        version = \"1\";\n    }\n\n    // --- Generic order identifier --- //\n\n    function orderIdentifier(\n        bytes calldata order\n    ) external view returns (bytes32) {\n        return order.orderIdentifier();\n    }\n\n    function orderIdentifier(\n        StandardOrder calldata order\n    ) external view returns (bytes32) {\n        return order.orderIdentifier();\n    }\n\n    /**\n     * @notice Opens an intent for `order.user`. `order.input` tokens are collected from msg.sender.\n     * @param order bytes representing an encoded StandardOrder, encoded via abi.encode().\n     */\n    function open(\n        bytes calldata order\n    ) external {\n        // Validate the order structure.\n        _validateInputChain(order.originChainId());\n        _validateTimestampHasNotPassed(order.fillDeadline());\n        _validateTimestampHasNotPassed(order.expires());\n\n        bytes32 orderId = order.orderIdentifier();\n\n        if (orderStatus[orderId] != OrderStatus.None) revert InvalidOrderStatus();\n        // Mark order as deposited. If we can't make the deposit, we will\n        // revert and it will unmark it. This acts as a reentry check.\n        orderStatus[orderId] = OrderStatus.Deposited;\n\n        // Collect input tokens.\n        _open(order);\n\n        // Validate that there has been no reentrancy.\n        if (orderStatus[orderId] != OrderStatus.Deposited) revert ReentrancyDetected();\n\n        emit Open(orderId, order);\n    }\n\n    /**\n     * @notice Collect input tokens directly from msg.sender.\n     * @param order bytes representing an encoded StandardOrder, encoded via abi.encode().\n     */\n    function _open(\n        bytes calldata order\n    ) internal {\n        // Collect input tokens.\n        uint256[2][] calldata inputs = order.inputs();\n        uint256 numInputs = inputs.length;\n        for (uint256 i = 0; i < numInputs; ++i) {\n            uint256[2] calldata input = inputs[i];\n            address token = EfficiencyLib.asSanitizedAddress(input[0]);\n            uint256 amount = input[1];\n            SafeTransferLib.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n    }\n\n    /**\n     * @notice Opens an intent for `order.user`. `order.input` tokens are collected from `sponsor` through transferFrom,\n     * permit2 or ERC-3009.\n     * @dev This function may make multiple sub-call calls either directly from this contract or from deeper inside the\n     * call tree. To protect against reentry, the function uses the `orderStatus`. Local reentry (calling twice) is\n     * protected through a checks-effect pattern while global reentry is enforced by not allowing existing the function\n     * with `orderStatus` not set to `Deposited`\n     * @param order bytes representing an encoded StandardOrder, encoded via abi.encode().\n     * @param sponsor Address to collect tokens from.\n     * @param signature Allowance signature from sponsor with a signature type encoded as:\n     * - SIGNATURE_TYPE_PERMIT2:  b1:0x00 | bytes:signature\n     * - SIGNATURE_TYPE_3009:     b1:0x01 | bytes:signature OR abi.encode(bytes[]:signatures)\n     */\n    function openFor(bytes calldata order, address sponsor, bytes calldata signature) external {\n        // Validate the order structure.\n        _validateInputChain(order.originChainId());\n        _validateTimestampHasNotPassed(order.fillDeadline());\n        _validateTimestampHasNotPassed(order.expires());\n\n        bytes32 orderId = order.orderIdentifier();\n\n        if (orderStatus[orderId] != OrderStatus.None) revert InvalidOrderStatus();\n        // Mark order as deposited. If we can't make the deposit, we will\n        // revert and it will unmark it. This acts as a reentry check.\n        orderStatus[orderId] = OrderStatus.Deposited;\n\n        // Check the first byte of the signature for signature type then collect inputs.\n        bytes1 signatureType = signature.length > 0 ? signature[0] : SIGNATURE_TYPE_SELF;\n        if (signatureType == SIGNATURE_TYPE_PERMIT2) {\n            _openForWithPermit2(order, sponsor, signature[1:], address(this));\n        } else if (signatureType == SIGNATURE_TYPE_3009) {\n            _openForWithAuthorization(order.inputs(), order.fillDeadline(), sponsor, signature[1:], orderId);\n        } else if (msg.sender == sponsor && signatureType == SIGNATURE_TYPE_SELF) {\n            _open(order);\n        } else {\n            revert SignatureNotSupported(signatureType);\n        }\n\n        // Validate that there has been no reentrancy.\n        if (orderStatus[orderId] != OrderStatus.Deposited) revert ReentrancyDetected();\n\n        emit Open(orderId, order);\n    }\n\n    /**\n     * @notice Helper function for using permit2 to collect assets represented by a StandardOrder.\n     * @param order StandardOrder representing the intent.\n     * @param signer Provider of the permit2 funds and signer of the intent.\n     * @param signature permit2 signature with Permit2Witness representing `order` signed by `order.user`.\n     * @param to recipient of the inputs tokens. In most cases, should be address(this).\n     */\n    function _openForWithPermit2(bytes calldata order, address signer, bytes calldata signature, address to) internal {\n        ISignatureTransfer.TokenPermissions[] memory permitted;\n        ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n\n        {\n            uint256[2][] calldata orderInputs = order.inputs();\n            // Load the number of inputs. We need them to set the array size & convert each\n            // input struct into a transferDetails struct.\n            uint256 numInputs = orderInputs.length;\n            permitted = new ISignatureTransfer.TokenPermissions[](numInputs);\n            transferDetails = new ISignatureTransfer.SignatureTransferDetails[](numInputs);\n            // Iterate through each input.\n            for (uint256 i; i < numInputs; ++i) {\n                uint256[2] calldata orderInput = orderInputs[i];\n                uint256 inputToken = orderInput[0];\n                uint256 amount = orderInput[1];\n                // Validate that the input token's 12 leftmost bytes are 0.\n                if ((inputToken >> 160) != 0) revert InputTokenHasDirtyBits();\n                address token;\n                assembly (\"memory-safe\") {\n                    // No dirty bits exist.\n                    token := inputToken\n                }\n                // Check if input tokens are contracts.\n                IsContractLib.validateContainsCode(token);\n                // Set the allowance. This is the explicit max allowed amount approved by the user.\n                permitted[i] = ISignatureTransfer.TokenPermissions({ token: token, amount: amount });\n                // Set our requested transfer. This has to be less than or equal to the allowance\n                transferDetails[i] = ISignatureTransfer.SignatureTransferDetails({ to: to, requestedAmount: amount });\n            }\n        }\n        ISignatureTransfer.PermitBatchTransferFrom memory permitBatch = ISignatureTransfer.PermitBatchTransferFrom({\n            permitted: permitted,\n            nonce: order.nonce(),\n            deadline: order.fillDeadline()\n        });\n        PERMIT2.permitWitnessTransferFrom(\n            permitBatch,\n            transferDetails,\n            signer,\n            Permit2WitnessType.Permit2WitnessHash(order),\n            Permit2WitnessType.PERMIT2_PERMIT2_TYPESTRING,\n            signature\n        );\n    }\n\n    /**\n     * @notice Helper function for using ERC-3009 to collect assets represented by a StandardOrder.\n     * @dev For the `receiveWithAuthorization` call, the nonce is set as the orderId to select the order associated with\n     * the authorization.\n     * @param inputs Order inputs to be collected.\n     * @param fillDeadline Deadline for calling the open function.\n     * @param signer Provider of the ERC-3009 funds and signer of the intent.\n     * @param _signature_ Either a single ERC-3009 signature or abi.encoded bytes[] of signatures. A single signature is\n     * only allowed if the order has exactly 1 input.\n     */\n    function _openForWithAuthorization(\n        uint256[2][] calldata inputs,\n        uint32 fillDeadline,\n        address signer,\n        bytes calldata _signature_,\n        bytes32 orderId\n    ) internal {\n        uint256 numInputs = inputs.length;\n        if (numInputs == 1) {\n            // If there is only 1 input, try using the provided signature as is.\n            uint256[2] calldata input = inputs[0];\n            bytes memory callData = abi.encodeCall(\n                IERC3009.receiveWithAuthorization,\n                (signer, address(this), input[1], 0, fillDeadline, orderId, _signature_)\n            );\n            // The above calldata encoding is equivalent to:\n            // IERC3009(EfficiencyLib.asSanitizedAddress(input[0])).receiveWithAuthorization({\n            //     from: signer,\n            //     to: address(this),\n            //     value: input[1],\n            //     validAfter: 0,\n            //     validBefore: fillDeadline,\n            //     nonce: orderId,\n            //     signature: _signature_\n            // })\n            address token = EfficiencyLib.asSanitizedAddress(input[0]);\n            IsContractLib.validateContainsCode(token); // Ensure called contract has code.\n            (bool success,) = token.call(callData);\n            if (success) return;\n            // Otherwise it could be because of a lot of reasons. One being the signature is abi.encoded as bytes[].\n        }\n        {\n            uint256 numSignatures = BytesLib.getLengthOfBytesArray(_signature_);\n            if (numInputs != numSignatures) revert SignatureAndInputsNotEqual();\n        }\n        for (uint256 i; i < numInputs; ++i) {\n            uint256[2] calldata input = inputs[i];\n            bytes calldata signature = BytesLib.getBytesOfArray(_signature_, i);\n            IERC3009(EfficiencyLib.asSanitizedAddress(input[0])).receiveWithAuthorization({\n                from: signer,\n                to: address(this),\n                value: input[1],\n                validAfter: 0,\n                validBefore: fillDeadline,\n                nonce: orderId,\n                signature: signature\n            });\n        }\n    }\n\n    // --- Refund --- //\n\n    /**\n     * @notice Refunds an order that has not been finalised before it expired. This order may have been filled but\n     * finalise has not been called yet.\n     * @param order StandardOrder description of the intent.\n     */\n    function refund(\n        StandardOrder calldata order\n    ) external {\n        _validateInputChain(order.originChainId);\n        _validateTimestampHasPassed(order.expires);\n\n        bytes32 orderId = order.orderIdentifier();\n        _resolveLock(orderId, order.inputs, order.user, OrderStatus.Refunded);\n        emit Refunded(orderId);\n    }\n\n    // --- Finalise Orders --- //\n\n    /**\n     * @notice Finalise an order, paying the inputs to the solver.\n     * @param order that has been filled.\n     * @param orderId A unique identifier for the order.\n     * @param solver Solver of the outputs.\n     * @param destination Destination of the inputs funds signed for by the user.\n     */\n    function _finalise(\n        StandardOrder calldata order,\n        bytes32 orderId,\n        bytes32 solver,\n        bytes32 destination\n    ) internal virtual {\n        _resolveLock(orderId, order.inputs, destination.fromIdentifier(), OrderStatus.Claimed);\n        emit Finalised(orderId, solver, destination);\n    }\n\n    /**\n     * @notice Finalises an order when called directly by the solver\n     * @dev Finalise is not blocked after the expiry of orders.\n     * The caller must be the address corresponding to the first solver in the solvers array.\n     * @param order StandardOrder description of the intent.\n     * @param timestamps Array of timestamps when each output was filled\n     * @param solvers Array of solvers who filled each output (in order of outputs).\n     * @param destination Address to send the inputs to. If the solver wants to send the inputs to themselves, they\n     * should pass their address to this parameter.\n     * @param call Optional callback data. If non-empty, will call orderFinalised on the destination\n     */\n    function finalise(\n        StandardOrder calldata order,\n        uint32[] calldata timestamps,\n        bytes32[] calldata solvers,\n        bytes32 destination,\n        bytes calldata call\n    ) external virtual {\n        _validateDestination(destination);\n        _validateInputChain(order.originChainId);\n\n        bytes32 orderId = order.orderIdentifier();\n        bytes32 orderOwner = _purchaseGetOrderOwner(orderId, solvers[0], timestamps);\n        _orderOwnerIsCaller(orderOwner);\n\n        _validateFills(order.fillDeadline, order.inputOracle, order.outputs, orderId, timestamps, solvers);\n\n        _finalise(order, orderId, solvers[0], destination);\n\n        if (call.length > 0) {\n            IInputCallback(EfficiencyLib.asSanitizedAddress(uint256(destination))).orderFinalised(order.inputs, call);\n        }\n    }\n\n    /**\n     * @notice Finalises a cross-chain order on behalf of someone else using their signature\n     * @dev Finalise is not blocked after the expiry of orders.\n     * This function serves to finalise intents on the origin chain with proper authorization from the order owner.\n     * @param order StandardOrder description of the intent.\n     * @param timestamps Array of timestamps when each output was filled\n     * @param solvers Array of solvers who filled each output (in order of outputs) element\n     * @param destination Address to send the inputs to.\n     * @param call Optional callback data. If non-empty, will call orderFinalised on the destination\n     * @param orderOwnerSignature Signature from the order owner authorizing this external call\n     */\n    function finaliseWithSignature(\n        StandardOrder calldata order,\n        uint32[] calldata timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes calldata call,\n        bytes calldata orderOwnerSignature\n    ) external virtual {\n        // _validateDestination has been moved down to circumvent stack issue.\n        _validateInputChain(order.originChainId);\n\n        bytes32 orderId = order.orderIdentifier();\n\n        {\n            bytes32 orderOwner = _purchaseGetOrderOwner(orderId, solvers[0], timestamps);\n\n            // Validate the external claimant with signature\n            _validateDestination(destination);\n            _allowExternalClaimant(\n                orderId, EfficiencyLib.asSanitizedAddress(uint256(orderOwner)), destination, call, orderOwnerSignature\n            );\n        }\n\n        _validateFills(order.fillDeadline, order.inputOracle, order.outputs, orderId, timestamps, solvers);\n\n        _finalise(order, orderId, solvers[0], destination);\n\n        if (call.length > 0) {\n            IInputCallback(EfficiencyLib.asSanitizedAddress(uint256(destination))).orderFinalised(order.inputs, call);\n        }\n    }\n\n    //--- Asset Lock & Escrow ---//\n\n    /**\n     * @dev This function employs a local reentry guard: we check the order status and then we update it afterwards.\n     * This is an important check as it is intended to process external ERC20 transfers.\n     * @param newStatus specifies the new status to set the order to. Should never be OrderStatus.Deposited.\n     */\n    function _resolveLock(\n        bytes32 orderId,\n        uint256[2][] calldata inputs,\n        address destination,\n        OrderStatus newStatus\n    ) internal virtual {\n        // Check the order status:\n        if (orderStatus[orderId] != OrderStatus.Deposited) revert InvalidOrderStatus();\n        // Mark order as deposited. If we can't make the deposit, we will\n        // revert and it will unmark it. This acts as a reentry check.\n        orderStatus[orderId] = newStatus;\n\n        // We have now ensured that this point can only be reached once. We can now process the asset delivery.\n        uint256 numInputs = inputs.length;\n        for (uint256 i; i < numInputs; ++i) {\n            uint256[2] calldata input = inputs[i];\n            address token = EfficiencyLib.asSanitizedAddress(input[0]);\n            uint256 amount = input[1];\n\n            SafeTransferLib.safeTransfer(token, destination, amount);\n        }\n    }\n\n    // --- Purchase Order --- //\n\n    /**\n     * @notice This function is called to buy an order from a solver.\n     * If the order was purchased in time, then when the order is settled, the inputs will go to the purchaser instead\n     * of the original solver.\n     * @param orderPurchase Order purchase description signed by solver.\n     * @param order Order to purchase.\n     * @param orderSolvedByIdentifier Solver of the order. Is not validated, if wrong the purchase will be skipped.\n     * @param purchaser The new order owner.\n     * @param expiryTimestamp Set to ensure if your transaction does not mine quickly, you don't end up purchasing an\n     * order that you can not prove OR is outside the timeToBuy window.\n     * @param solverSignature EIP712 Signature of OrderPurchase by orderOwner.\n     */\n    function purchaseOrder(\n        OrderPurchase calldata orderPurchase,\n        StandardOrder calldata order,\n        bytes32 orderSolvedByIdentifier,\n        bytes32 purchaser,\n        uint256 expiryTimestamp,\n        bytes calldata solverSignature\n    ) external virtual {\n        bytes32 computedOrderId = order.orderIdentifier();\n        // Sanity check to ensure the user thinks they are buying the right order.\n        if (computedOrderId != orderPurchase.orderId) revert OrderIdMismatch(orderPurchase.orderId, computedOrderId);\n\n        _purchaseOrder(\n            orderPurchase, order.inputs, orderSolvedByIdentifier, purchaser, expiryTimestamp, solverSignature\n        );\n    }\n}\n"
    }
}