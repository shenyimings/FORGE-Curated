{
    "vfp_id": "vfp_00478",
    "project_name": "cantina_coinbase_zora_creator_coin_sep2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Stale poolKey mapping in ZoraV4CoinHook after hook migration may cause unexpected behavior",
            "description": "The ZoraV4CoinHook contract's migrateLiquidity function allows migration of liquidity from an old hook to a new one but fails to remove the old pool key from the poolCoins mapping after migration. This causes stale state to persist, where the old pool key remains associated with its coin and positions. The root cause is the omission of cleanup logic in the migration function. An attacker or user could potentially interact with the stale liquidity, leading to unexpected behavior such as incorrect reward distribution or state inconsistencies. The impact is considered low as it does not directly lead to fund loss but may cause operational issues and inconsistencies in the system.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "zora-protocol/packages/coins/src/hooks/ZoraV4CoinHook.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing checks allow migration to unregistered hooks",
            "description": "The migrateLiquidity function in ZoraV4CoinHook checks for a registered upgrade path via HookUpgradeGate.isRegisteredUpgradePath but does not verify that the new hook is registered in ZoraHookRegistry via isRegisteredHook. This allows migration to unregistered hooks if their upgrade path remains registered, which could happen if the protocol unregisters a hook but forgets to remove its upgrade path. The root cause is the lack of validation on the new hook's registration status. An attacker or user could exploit this by migrating liquidity to an unregistered hook, potentially leading to loss of funds or unexpected behavior if the hook is malicious or deprecated. The impact is low as the registry is considered informational, but it introduces unnecessary risk.\n",
            "severity": "Low",
            "location": [
                "ZoraHookRegistry.sol#L34-L36",
                "ZoraHookRegistry.sol#L71-L92",
                "ZoraV4CoinHook.sol#L183-L185",
                "ZoraV4CoinHook.sol#L373-L376"
            ],
            "files": [
                "zora-protocol/packages/coins/src/hooks/ZoraV4CoinHook.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Swaps with native ETH will fail if one of the reward recipients cannot receive native ETH",
            "description": "The _afterSwap function in ZoraV4CoinHook calls CoinRewardsV4.distributeMarketRewards, which reverts if a reward transfer in native ETH fails due to a recipient being unable to receive ETH (e.g., a contract without a payable fallback). The root cause is the lack of error handling for ETH transfers. This could cause all swaps involving native ETH to fail if any of the five reward recipients (payoutRecipient, platformReferrer, protocolRewardRecipient, doppler, tradeReferrer) cannot accept ETH. While unlikely under normal conditions, a misconfiguration or malicious setup could brick swaps. The impact is low due to the unlikelihood of such a scenario, but it could disrupt functionality. The issue was later fixed by introducing a backup recipient.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "zora-protocol/packages/coins/src/hooks/ZoraV4CoinHook.sol",
                "zora-protocol/packages/coins/src/libs/CoinRewardsV4.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Restrictive ETH receive function in ZoraV4CoinHook",
            "description": "The receive() function in ZoraV4CoinHook is restricted to onlyPoolManager, preventing direct ETH deposits from unauthorized addresses. However, this does not prevent ETH from being forcibly sent via self-destruct or protocol rewards, potentially leaving ETH stuck in the contract. The root cause is the absence of a withdrawal mechanism for recovered funds. While the restriction reduces risk, it does not eliminate the possibility of ETH accumulation. The impact is informational, as there is no direct exploit, but it represents a potential loss of funds if ETH becomes trapped. No fix was implemented as the team considers it acceptable risk.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "zora-protocol/packages/coins/src/hooks/ZoraV4CoinHook.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing _disableInitializers() in ZoraHookRegistry",
            "description": "The ZoraHookRegistry contract uses an initializer but does not call _disableInitializers() in its constructor, which could allow re-initialization attacks on the implementation contract. The root cause is a missing security best practice for upgradeable contracts. However, the client clarified that the contract is not upgradeable and the initializer is meant to be called once. Despite this, the absence of _disableInitializers() is a common anti-pattern. The impact is informational, as the risk is mitigated by deployment constraints. A comment was added to clarify the deployment flow instead of modifying the code.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "zora-protocol/packages/coins/src/hook-registry/ZoraHookRegistry.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Using the same version across different contracts is misleading",
            "description": "Multiple contracts (BaseCoin, ZoraV4CoinHook, ZoraFactoryImpl) inherit ContractVersionBase and return the same version (e.g., 2.2.0), even if only one is updated. The root cause is a centralized versioning system based on the npm package version. This can be misleading when tracking individual contract changes, as version increments may not reflect actual code changes. The impact is informational, affecting traceability and clarity. The team acknowledged the issue but chose not to fix it, as the current system works for their deployment model.\n",
            "severity": "Informational",
            "location": [
                "ZoraHookRegistry.sol#L64-L68",
                "ZoraV4CoinHook.sol#L159-L161",
                "ContractVersionBase.sol#L9-L14",
                "ZoraFactoryImpl.sol#L116"
            ],
            "files": [
                "zora-protocol/packages/coins/src/BaseCoin.sol",
                "zora-protocol/packages/coins/src/hooks/ZoraV4CoinHook.sol",
                "zora-protocol/packages/coins/src/ZoraFactoryImpl.sol",
                "zora-protocol/packages/coins/src/hook-registry/ZoraHookRegistry.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "ReentrancyGuardUpgradeable is not required for BaseCoin",
            "description": "BaseCoin inherits ReentrancyGuardUpgradeable, but none of its functions use the nonReentrant modifier. The root cause is likely legacy code or unnecessary inheritance. This adds contract bloat and reduces readability without providing any security benefit. The impact is informational, as it does not introduce a vulnerability but represents code quality issues. The issue was fixed by removing the unnecessary inheritance, improving code clarity and reducing size.\n",
            "severity": "Informational",
            "location": [
                "BaseCoin.sol#L57"
            ],
            "files": [
                "zora-protocol/packages/coins/src/BaseCoin.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Using initializer modifier on constructor is non-standard",
            "description": "BaseCoin uses the initializer modifier on its constructor to prevent re-initialization, which is a non-standard pattern compared to calling _disableInitializers() in the constructor. The root cause is a deviation from common upgradeable contract patterns. While functionally equivalent in this context, it may confuse auditors or developers familiar with standard practices. The impact is informational, affecting code readability and maintainability. The team acknowledged the feedback but chose not to change it, as it achieves the intended security goal.\n",
            "severity": "Informational",
            "location": [
                "BaseCoin.sol#L97"
            ],
            "files": [
                "zora-protocol/packages/coins/src/BaseCoin.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Forced downcasting is risky",
            "description": "The convertDeltaToPositiveUint128 function in CoinRewardsV4.sol performs a forced downcast from int256 to uint128 without bounds checking beyond ensuring the value is non-negative. The root cause is the use of unsafe casting practices. While large delta values are unlikely, this could lead to truncation and unexpected behavior in edge cases. The impact is informational, as the risk is low but represents a deviation from safe casting best practices. The issue was fixed by implementing proper bounds checking or safe casting.\n",
            "severity": "Informational",
            "location": [
                "CoinRewardsV4.sol#L89-L94"
            ],
            "files": [
                "zora-protocol/packages/coins/src/libs/CoinRewardsV4.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Creator coins do not support postDeployHook functionality",
            "description": "Unlike ContentCoin, CreatorCoin does not support postDeployHook functionality, which is used to trigger actions like initial token purchases immediately after deployment. The root cause is a lack of feature parity between contract types. This limits functionality and consistency in the protocol. The impact is informational, as it does not introduce a security issue but represents a missed opportunity for feature alignment. The issue was fixed by adding postDeployHook support to CreatorCoin.\n",
            "severity": "Informational",
            "location": [
                "ZoraFactoryImpl.sol#L76-L120",
                "ZoraFactoryImpl.sol#L123-L137",
                "ZoraFactoryImpl.sol#L165-L169"
            ],
            "files": [
                "zora-protocol/packages/coins/src/ZoraFactoryImpl.sol"
            ]
        }
    ],
    "affected_files": {
        "ZoraFactoryImpl.sol": "// SPDX-License-Identifier: ZORA-DELAYED-OSL-v1\n// This software is licensed under the Zora Delayed Open Source License.\n// Under this license, you may use, copy, modify, and distribute this software for\n// non-commercial purposes only. Commercial use and competitive products are prohibited\n// until the \"Open Date\" (3 years from first public distribution or earlier at Zora's discretion),\n// at which point this software automatically becomes available under the MIT License.\n// Full license terms available at: https://docs.zora.co/coins/license\npragma solidity ^0.8.23;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {CoinConfigurationVersions} from \"./libs/CoinConfigurationVersions.sol\";\nimport {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IZoraFactory} from \"./interfaces/IZoraFactory.sol\";\nimport {IHasAfterCoinDeploy} from \"./hooks/deployment/BaseCoinDeployHook.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ICoin, PoolKeyStruct} from \"./interfaces/ICoin.sol\";\nimport {ICoin} from \"./interfaces/ICoin.sol\";\nimport {IHasContractName} from \"@zoralabs/shared-contracts/interfaces/IContractMetadata.sol\";\nimport {ContractVersionBase} from \"./version/ContractVersionBase.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {CoinCommon} from \"./libs/CoinCommon.sol\";\nimport {PoolConfiguration} from \"./types/PoolConfiguration.sol\";\nimport {LpPosition} from \"./types/LpPosition.sol\";\nimport {IVersionedContract} from \"@zoralabs/shared-contracts/interfaces/IVersionedContract.sol\";\nimport {CoinSetup} from \"./libs/CoinSetup.sol\";\nimport {CoinDopplerMultiCurve} from \"./libs/CoinDopplerMultiCurve.sol\";\nimport {ICreatorCoin} from \"./interfaces/ICreatorCoin.sol\";\nimport {MarketConstants} from \"./libs/MarketConstants.sol\";\nimport {DeployedCoinVersionLookup} from \"./utils/DeployedCoinVersionLookup.sol\";\nimport {IZoraHookRegistry} from \"./interfaces/IZoraHookRegistry.sol\";\n\ncontract ZoraFactoryImpl is\n    IZoraFactory,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable,\n    IHasContractName,\n    ContractVersionBase,\n    DeployedCoinVersionLookup\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice The coin contract implementation address\n    address public immutable coinV4Impl;\n    address public immutable creatorCoinImpl;\n    address public immutable hook;\n    address public immutable zoraHookRegistry;\n\n    constructor(address coinV4Impl_, address creatorCoinImpl_, address hook_, address zoraHookRegistry_) {\n        _disableInitializers();\n\n        coinV4Impl = coinV4Impl_;\n        creatorCoinImpl = creatorCoinImpl_;\n        hook = hook_;\n        zoraHookRegistry = zoraHookRegistry_;\n    }\n\n    /// @notice Creates a new creator coin contract\n    /// @param payoutRecipient The recipient of creator reward payouts; this can be updated by an owner\n    /// @param owners The list of addresses that will be able to manage the coin's payout address and metadata uri\n    /// @param uri The coin metadata uri\n    /// @param name The name of the coin\n    /// @param symbol The symbol of the coin\n    /// @param poolConfig The config parameters for the coin's pool\n    /// @param platformReferrer The address of the platform referrer\n    /// @param coinSalt The salt used to deploy the coin\n    function deployCreatorCoin(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        bytes32 coinSalt\n    ) public nonReentrant returns (address) {\n        bytes32 salt = _buildSalt(msg.sender, name, symbol, poolConfig, platformReferrer, coinSalt);\n\n        uint8 version = CoinConfigurationVersions.getVersion(poolConfig);\n\n        require(version == CoinConfigurationVersions.DOPPLER_MULTICURVE_UNI_V4_POOL_VERSION, InvalidConfig());\n\n        address creatorCoin = Clones.cloneDeterministic(creatorCoinImpl, salt);\n\n        _setVersionForDeployedCoin(address(creatorCoin), version);\n\n        (, address currency, uint160 sqrtPriceX96, bool isCoinToken0, PoolConfiguration memory poolConfiguration) = CoinSetup.generatePoolConfig(\n            address(creatorCoin),\n            poolConfig\n        );\n\n        PoolKey memory poolKey = CoinSetup.buildPoolKey(address(creatorCoin), currency, isCoinToken0, IHooks(hook));\n\n        ICreatorCoin(creatorCoin).initialize(payoutRecipient, owners, uri, name, symbol, platformReferrer, currency, poolKey, sqrtPriceX96, poolConfiguration);\n\n        emit CreatorCoinCreated(\n            msg.sender,\n            payoutRecipient,\n            platformReferrer,\n            currency,\n            uri,\n            name,\n            symbol,\n            address(creatorCoin),\n            poolKey,\n            CoinCommon.hashPoolKey(poolKey),\n            IVersionedContract(address(creatorCoin)).contractVersion()\n        );\n\n        return creatorCoin;\n    }\n\n    /// @inheritdoc IZoraFactory\n    function deploy(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        address postDeployHook,\n        bytes calldata postDeployHookData,\n        bytes32 coinSalt\n    ) external payable returns (address coin, bytes memory postDeployHookDataOut) {\n        bytes32 salt = _buildSalt(msg.sender, name, symbol, poolConfig, platformReferrer, coinSalt);\n        return _deployWithHook(payoutRecipient, owners, uri, name, symbol, poolConfig, platformReferrer, postDeployHook, postDeployHookData, salt);\n    }\n\n    function coinAddress(\n        address msgSender,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        bytes32 coinSalt\n    ) external view returns (address) {\n        bytes32 salt = _buildSalt(msgSender, name, symbol, poolConfig, platformReferrer, coinSalt);\n        return Clones.predictDeterministicAddress(getCoinImpl(CoinConfigurationVersions.getVersion(poolConfig)), salt, address(this));\n    }\n\n    function _deployWithHook(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        address deployHook,\n        bytes calldata hookData,\n        bytes32 salt\n    ) internal returns (address coin, bytes memory hookDataOut) {\n        coin = address(_createAndInitializeCoin(payoutRecipient, owners, uri, name, symbol, poolConfig, platformReferrer, salt));\n\n        if (deployHook != address(0)) {\n            if (!IERC165(deployHook).supportsInterface(type(IHasAfterCoinDeploy).interfaceId)) {\n                revert InvalidHook();\n            }\n            hookDataOut = IHasAfterCoinDeploy(deployHook).afterCoinDeploy{value: msg.value}(msg.sender, ICoin(coin), hookData);\n        } else if (msg.value > 0) {\n            // cannot send eth without a hook\n            revert EthTransferInvalid();\n        }\n    }\n\n    /** Deprecated deploy functions */\n\n    /// @dev Deprecated: use `deploy` instead that has a salt and hook specified\n    function deploy(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        uint256 /*orderSize*/\n    ) public payable nonReentrant returns (address, uint256) {\n        bytes32 salt = _randomSalt(payoutRecipient, uri, bytes32(0));\n\n        ICoin coin = _createAndInitializeCoin(payoutRecipient, owners, uri, name, symbol, poolConfig, platformReferrer, salt);\n\n        uint256 coinsPurchased = 0;\n\n        return (address(coin), coinsPurchased);\n    }\n\n    /// @dev Deprecated: use `deploy` instead that has a salt and hook specified\n    function deployWithHook(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        address hook_,\n        bytes calldata hookData\n    ) public payable nonReentrant returns (address coin, bytes memory hookDataOut) {\n        bytes32 salt = _randomSalt(payoutRecipient, uri, bytes32(0));\n        return _deployWithHook(payoutRecipient, owners, uri, name, symbol, poolConfig, platformReferrer, hook_, hookData, salt);\n    }\n\n    /// @dev deprecated Use deploy() with poolConfig instead\n    function deploy(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        address platformReferrer,\n        address currency,\n        // tickLower is no longer used\n        int24 /* tickLower */,\n        // orderSize is no longer used\n        uint256 /* orderSize */\n    ) public payable nonReentrant returns (address, uint256) {\n        bytes memory poolConfig = CoinConfigurationVersions.defaultConfig(currency);\n        bytes32 salt = _randomSalt(payoutRecipient, uri, bytes32(0));\n\n        ICoin coin = _createAndInitializeCoin(payoutRecipient, owners, uri, name, symbol, poolConfig, platformReferrer, salt);\n\n        return (address(coin), 0);\n    }\n\n    function getCoinImpl(uint8 version) internal view returns (address) {\n        if (CoinConfigurationVersions.isV4(version)) {\n            return coinV4Impl;\n        }\n\n        revert ICoin.InvalidPoolVersion();\n    }\n\n    function _createCoin(uint8 version, bytes32 salt) internal returns (address payable) {\n        return payable(Clones.cloneDeterministic(getCoinImpl(version), salt));\n    }\n\n    function _setupV4Coin(\n        ICoin coin,\n        address currency,\n        bool isCoinToken0,\n        uint160 sqrtPriceX96,\n        PoolConfiguration memory poolConfiguration,\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        address platformReferrer\n    ) internal {\n        PoolKey memory poolKey = CoinSetup.buildPoolKey(address(coin), currency, isCoinToken0, IHooks(hook));\n\n        // Initialize coin with pre-configured pool\n        coin.initialize(payoutRecipient, owners, uri, name, symbol, platformReferrer, currency, poolKey, sqrtPriceX96, poolConfiguration);\n\n        emit CoinCreatedV4(\n            msg.sender,\n            payoutRecipient,\n            platformReferrer,\n            currency,\n            uri,\n            name,\n            symbol,\n            address(coin),\n            poolKey,\n            CoinCommon.hashPoolKey(poolKey),\n            IVersionedContract(address(coin)).contractVersion()\n        );\n    }\n\n    function _createAndInitializeCoin(\n        address payoutRecipient,\n        address[] memory owners,\n        string memory uri,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        bytes32 coinSalt\n    ) internal returns (ICoin) {\n        uint8 version = CoinConfigurationVersions.getVersion(poolConfig);\n\n        address payable coin = _createCoin(version, coinSalt);\n\n        _setVersionForDeployedCoin(address(coin), version);\n\n        (, address currency, uint160 sqrtPriceX96, bool isCoinToken0, PoolConfiguration memory poolConfiguration) = CoinSetup.generatePoolConfig(\n            address(coin),\n            poolConfig\n        );\n\n        if (CoinConfigurationVersions.isV3(version)) {\n            // V3 is no longer supported\n            revert ICoin.InvalidPoolVersion();\n        } else if (CoinConfigurationVersions.isV4(version)) {\n            _setupV4Coin(ICoin(coin), currency, isCoinToken0, sqrtPriceX96, poolConfiguration, payoutRecipient, owners, uri, name, symbol, platformReferrer);\n        } else {\n            revert ICoin.InvalidPoolVersion();\n        }\n\n        return ICoin(coin);\n    }\n\n    function _buildSalt(\n        address msgSender,\n        string memory name,\n        string memory symbol,\n        bytes memory poolConfig,\n        address platformReferrer,\n        bytes32 coinSalt\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(msgSender, name, symbol, poolConfig, platformReferrer, coinSalt));\n    }\n\n    /// @dev Generates a unique salt for deterministic deployment\n    function _randomSalt(address payoutRecipient, string memory uri, bytes32 coinSalt) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    msg.sender,\n                    payoutRecipient,\n                    keccak256(abi.encodePacked(uri)),\n                    block.coinbase,\n                    block.number,\n                    block.prevrandao,\n                    block.timestamp,\n                    tx.gasprice,\n                    tx.origin,\n                    coinSalt\n                )\n            );\n    }\n\n    /// @notice Initializes the factory proxy contract\n    /// @param initialOwner Address of the contract owner\n    /// @dev Can only be called once due to initializer modifier\n    function initialize(address initialOwner) external initializer {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(initialOwner);\n    }\n\n    /// @notice The implementation address of the factory contract\n    function implementation() external view returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n\n    /// @inheritdoc IHasContractName\n    function contractName() public pure override returns (string memory) {\n        return \"ZoraCoinFactory\";\n    }\n\n    /// @dev Authorizes an upgrade to a new implementation\n    /// @param newImpl The new implementation address\n    function _authorizeUpgrade(address newImpl) internal override onlyOwner {\n        // try to get the existing contract name - if it reverts, the existing contract was an older version that didn't have the contract name\n        // unfortunately we cannot use supportsInterface here because the existing implementation did not have that function\n        try IHasContractName(newImpl).contractName() returns (string memory name) {\n            if (!Strings.equal(name, contractName())) {\n                revert UpgradeToMismatchedContractName(contractName(), name);\n            }\n        } catch {}\n\n        // Auto-register the new hooks in the Zora hook registry\n        address[] memory hooks = new address[](1);\n        string[] memory tags = new string[](1);\n\n        hooks[0] = IZoraFactory(newImpl).hook();\n        tags[0] = \"CoinHook\";\n\n        IZoraHookRegistry(zoraHookRegistry).registerHooks(hooks, tags);\n    }\n\n    /// @notice The address of the latest creator coin hook\n    /// @dev Deprecated: use `hook` instead\n    function creatorCoinHook() external view returns (address) {\n        return hook;\n    }\n\n    /// @notice The address of the latest coin hook\n    /// @dev Deprecated: use `hook` instead\n    function contentCoinHook() external view returns (address) {\n        return hook;\n    }\n}\n",
        "CoinRewardsV4.sol": "// SPDX-License-Identifier: ZORA-DELAYED-OSL-v1\n// This software is licensed under the Zora Delayed Open Source License.\n// Under this license, you may use, copy, modify, and distribute this software for\n// non-commercial purposes only. Commercial use and competitive products are prohibited\n// until the \"Open Date\" (3 years from first public distribution or earlier at Zora's discretion),\n// at which point this software automatically becomes available under the MIT License.\n// Full license terms available at: https://docs.zora.co/coins/license\npragma solidity ^0.8.28;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PathKey} from \"@uniswap/v4-periphery/src/libraries/PathKey.sol\";\nimport {ModifyLiquidityParams} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {TransientStateLibrary} from \"@uniswap/v4-core/src/libraries/TransientStateLibrary.sol\";\nimport {LpPosition} from \"../types/LpPosition.sol\";\nimport {V4Liquidity} from \"./V4Liquidity.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {StateLibrary} from \"@uniswap/v4-core/src/libraries/StateLibrary.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {DopplerMath} from \"../libs/DopplerMath.sol\";\nimport {LiquidityAmounts} from \"../utils/uniswap/LiquidityAmounts.sol\";\nimport {IHasRewardsRecipients} from \"../interfaces/IHasRewardsRecipients.sol\";\nimport {ICoin} from \"../interfaces/ICoin.sol\";\nimport {IZoraV4CoinHook} from \"../interfaces/IZoraV4CoinHook.sol\";\nimport {IHasSwapPath} from \"../interfaces/ICoin.sol\";\nimport {V4Liquidity} from \"./V4Liquidity.sol\";\nimport {UniV4SwapToCurrency} from \"./UniV4SwapToCurrency.sol\";\nimport {ICreatorCoinHook} from \"../interfaces/ICreatorCoinHook.sol\";\nimport {IHasCoinType} from \"../interfaces/ICoin.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ICreatorCoin} from \"../interfaces/ICreatorCoin.sol\";\n\nlibrary CoinRewardsV4 {\n    using SafeERC20 for IERC20;\n\n    // Creator gets 62.5% of market rewards (0.50% of total 1% fee)\n    // Market rewards = 80% of total fee (0.80% of 1%)\n    uint256 public constant CREATOR_REWARD_BPS = 6250;\n\n    // Platform referrer gets 25% of market rewards (0.20% of total 1% fee)\n    uint256 public constant CREATE_REFERRAL_REWARD_BPS = 2500;\n\n    // Trade referrer gets 5% of market rewards (0.04% of total 1% fee)\n    uint256 public constant TRADE_REFERRAL_REWARD_BPS = 500;\n\n    // Doppler gets 1.25% of market rewards (0.01% of total 1% fee)\n    uint256 public constant DOPPLER_REWARD_BPS = 125;\n\n    // LPs get 20% of total fee (0.20% of 1%)\n    uint256 public constant LP_REWARD_BPS = 2000;\n\n    function getTradeReferral(bytes calldata hookData) internal pure returns (address) {\n        return hookData.length >= 20 ? abi.decode(hookData, (address)) : address(0);\n    }\n\n    /// @dev Converts collected fees from LP positions into target payout currency, and transfers to hook contract, so\n    ///      that they can later be distributed as rewards.\n    /// @param poolManager The pool manager instance\n    /// @param fees0 The amount of fees collected in currency0\n    /// @param fees1 The amount of fees collected in currency1\n    /// @param payoutSwapPath The swap path to convert fees to target currency\n    /// @return receivedCurrency The final currency after swapping\n    /// @return receivedAmount The final amount after swapping\n    function convertToPayoutCurrency(\n        IPoolManager poolManager,\n        uint128 fees0,\n        uint128 fees1,\n        IHasSwapPath.PayoutSwapPath memory payoutSwapPath\n    ) internal returns (Currency receivedCurrency, uint128 receivedAmount) {\n        // This handles multi-hop swaps if needed (e.g. coin -> backingCoin -> backingCoin's currency)\n        (receivedCurrency, receivedAmount) = UniV4SwapToCurrency.swapToPath(poolManager, fees0, fees1, payoutSwapPath.currencyIn, payoutSwapPath.path);\n\n        // Transfer the final converted currency amount to this contract for distribution\n        // This makes the tokens available for the subsequent reward distribution\n        if (receivedAmount > 0) {\n            poolManager.take(receivedCurrency, address(this), receivedAmount);\n        }\n    }\n\n    /// @dev Computes the LP reward and remaining amount for market rewards from the total amount\n    function computeLpReward(uint128 totalBackingAmount) internal pure returns (uint128 lpRewardAmount) {\n        lpRewardAmount = uint128(calculateReward(uint256(totalBackingAmount), LP_REWARD_BPS));\n    }\n\n    function convertDeltaToPositiveUint128(int256 delta) internal pure returns (uint128) {\n        if (delta < 0) {\n            revert SafeCast.SafeCastOverflow();\n        }\n        return uint128(uint256(delta));\n    }\n\n    function getCurrencyZeroBalance(IPoolManager poolManager, PoolKey calldata key) internal view returns (uint128) {\n        return convertDeltaToPositiveUint128(TransientStateLibrary.currencyDelta(poolManager, address(this), key.currency0));\n    }\n\n    function getCurrencyOneBalance(IPoolManager poolManager, PoolKey calldata key) internal view returns (uint128) {\n        return convertDeltaToPositiveUint128(TransientStateLibrary.currencyDelta(poolManager, address(this), key.currency1));\n    }\n\n    /// @notice Mints LP rewards by creating new liquidity positions from collected fees\n    /// @dev Splits collected fees between LP rewards and market rewards, then mints new LP positions\n    ///      with the LP reward portion. The remaining amount becomes market rewards for distribution.\n    /// @param poolManager The pool manager instance\n    /// @param key The pool key identifying the specific pool\n    /// @param fees0 The amount of fees collected in currency0\n    /// @param fees1 The amount of fees collected in currency1\n    /// @return marketRewardsAmount0 The amount of currency0 remaining for market rewards\n    /// @return marketRewardsAmount1 The amount of currency1 remaining for market rewards\n    function mintLpReward(\n        IPoolManager poolManager,\n        PoolKey calldata key,\n        int128 fees0,\n        int128 fees1\n    ) internal returns (uint128 marketRewardsAmount0, uint128 marketRewardsAmount1) {\n        if (fees0 > 0) {\n            uint128 lpRewardAmount0 = computeLpReward(uint128(fees0));\n            if (lpRewardAmount0 > 0) {\n                _modifyLiquidity(poolManager, key, lpRewardAmount0, true);\n            }\n        }\n\n        if (fees1 > 0) {\n            uint128 lpRewardAmount1 = computeLpReward(uint128(fees1));\n            if (lpRewardAmount1 > 0) {\n                _modifyLiquidity(poolManager, key, lpRewardAmount1, false);\n            }\n        }\n\n        marketRewardsAmount0 = getCurrencyZeroBalance(poolManager, key);\n        marketRewardsAmount1 = getCurrencyOneBalance(poolManager, key);\n    }\n\n    /// @notice Mints a single-sided LP position\n    /// @dev The position is created for a single tick spacing range, either entirely above or below the current tick, to ensure only one currency is required\n    function _modifyLiquidity(IPoolManager poolManager, PoolKey calldata key, uint128 lpRewardAmount, bool isFeesToken0) private {\n        // Get the current tick to determine where to place the new position.\n        (, int24 currentTick, , ) = StateLibrary.getSlot0(poolManager, key.toId());\n\n        int24 tickLower;\n        int24 tickUpper;\n\n        if (isFeesToken0) {\n            // For token0 fees, the position must be entirely above the current tick\n            // We set the lower tick to be at least two tick spacings away to ensure it's not in the active range\n            int24 minTickLower = currentTick + (key.tickSpacing * 2);\n            tickLower = DopplerMath.alignTickToTickSpacing(true, minTickLower, key.tickSpacing);\n            tickUpper = tickLower + key.tickSpacing;\n        } else {\n            // For token1 fees, the position must be entirely below the current tick\n            // We set the upper tick to be at least two tick spacings away\n            int24 maxTickUpper = currentTick - (key.tickSpacing * 2);\n            tickUpper = DopplerMath.alignTickToTickSpacing(false, maxTickUpper, key.tickSpacing);\n            tickLower = tickUpper - key.tickSpacing;\n        }\n\n        uint160 sqrtPriceA = TickMath.getSqrtPriceAtTick(tickLower);\n        uint160 sqrtPriceB = TickMath.getSqrtPriceAtTick(tickUpper);\n\n        uint128 liquidity = isFeesToken0\n            ? LiquidityAmounts.getLiquidityForAmount0(sqrtPriceA, sqrtPriceB, lpRewardAmount)\n            : LiquidityAmounts.getLiquidityForAmount1(sqrtPriceA, sqrtPriceB, lpRewardAmount);\n\n        if (liquidity > 0) {\n            ModifyLiquidityParams memory params = ModifyLiquidityParams({\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: SafeCast.toInt256(liquidity),\n                salt: 0\n            });\n            poolManager.modifyLiquidity(key, params, \"\");\n        }\n    }\n\n    /// @notice Distributes collected market fees as rewards to various recipients including creator, referrers, protocol, and doppler\n    /// @dev Calculates reward amounts based on predefined basis points and transfers the specified currency to each recipient\n    /// @param currency The currency token to distribute as rewards (can be native ETH if address is zero)\n    /// @param fees The total amount of fees collected to be distributed\n    /// @param coin The coin contract instance that implements IHasRewardsRecipients to get recipient addresses\n    /// @param tradeReferrer The address of the trade referrer who should receive trade referral rewards (can be zero address)\n    function distributeMarketRewards(\n        Currency currency,\n        uint128 fees,\n        IHasRewardsRecipients coin,\n        address tradeReferrer,\n        IHasCoinType.CoinType coinType\n    ) internal {\n        address payoutRecipient = coin.payoutRecipient();\n        address platformReferrer = coin.platformReferrer();\n        address protocolRewardRecipient = coin.protocolRewardRecipient();\n        address doppler = coin.dopplerFeeRecipient();\n\n        MarketRewards memory rewards = _distributeCurrencyRewards(\n            currency,\n            fees,\n            payoutRecipient,\n            platformReferrer,\n            protocolRewardRecipient,\n            doppler,\n            tradeReferrer\n        );\n\n        IZoraV4CoinHook.MarketRewardsV4 memory marketRewards = IZoraV4CoinHook.MarketRewardsV4({\n            creatorPayoutAmountCurrency: rewards.creatorAmount,\n            creatorPayoutAmountCoin: 0,\n            platformReferrerAmountCurrency: rewards.platformReferrerAmount,\n            platformReferrerAmountCoin: 0,\n            tradeReferrerAmountCurrency: rewards.tradeReferrerAmount,\n            tradeReferrerAmountCoin: 0,\n            protocolAmountCurrency: rewards.protocolAmount,\n            protocolAmountCoin: 0,\n            dopplerAmountCurrency: rewards.dopplerAmount,\n            dopplerAmountCoin: 0\n        });\n\n        emit IZoraV4CoinHook.CoinMarketRewardsV4(\n            address(coin),\n            Currency.unwrap(currency),\n            payoutRecipient,\n            platformReferrer,\n            tradeReferrer,\n            protocolRewardRecipient,\n            doppler,\n            marketRewards\n        );\n\n        if (coinType == IHasCoinType.CoinType.Creator) {\n            emit ICreatorCoinHook.CreatorCoinRewards(\n                address(coin),\n                Currency.unwrap(currency),\n                payoutRecipient,\n                protocolRewardRecipient,\n                rewards.creatorAmount,\n                rewards.protocolAmount\n            );\n        }\n    }\n\n    struct MarketRewards {\n        uint256 platformReferrerAmount;\n        uint256 tradeReferrerAmount;\n        uint256 protocolAmount;\n        uint256 creatorAmount;\n        uint256 dopplerAmount;\n    }\n\n    function _distributeCurrencyRewards(\n        Currency currency,\n        uint128 fee,\n        address payoutRecipient,\n        address platformReferrer,\n        address protocolRewardRecipient,\n        address doppler,\n        address tradeReferral\n    ) internal returns (MarketRewards memory rewards) {\n        rewards = _computeMarketRewards(fee, tradeReferral != address(0), platformReferrer != address(0));\n\n        if (platformReferrer != address(0)) {\n            _transferCurrency(currency, rewards.platformReferrerAmount, platformReferrer);\n        }\n        if (tradeReferral != address(0)) {\n            _transferCurrency(currency, rewards.tradeReferrerAmount, tradeReferral);\n        }\n        _transferCurrency(currency, rewards.creatorAmount, payoutRecipient);\n        _transferCurrency(currency, rewards.dopplerAmount, doppler);\n        _transferCurrency(currency, rewards.protocolAmount, protocolRewardRecipient);\n    }\n\n    function _transferCurrency(Currency currency, uint256 amount, address to) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (currency.isAddressZero()) {\n            (bool success, ) = payable(to).call{value: amount}(\"\");\n            if (!success) {\n                revert ICoin.EthTransferFailed();\n            }\n        } else {\n            IERC20(Currency.unwrap(currency)).safeTransfer(to, amount);\n        }\n    }\n\n    function _computeMarketRewards(uint128 fee, bool hasTradeReferral, bool hasCreateReferral) internal pure returns (MarketRewards memory rewards) {\n        if (fee == 0) {\n            return rewards;\n        }\n\n        uint256 totalAmount = uint256(fee);\n        rewards.platformReferrerAmount = hasCreateReferral ? calculateReward(totalAmount, CREATE_REFERRAL_REWARD_BPS) : 0;\n        rewards.tradeReferrerAmount = hasTradeReferral ? calculateReward(totalAmount, TRADE_REFERRAL_REWARD_BPS) : 0;\n        rewards.creatorAmount = calculateReward(totalAmount, CREATOR_REWARD_BPS);\n        rewards.dopplerAmount = calculateReward(totalAmount, DOPPLER_REWARD_BPS);\n        rewards.protocolAmount = totalAmount - rewards.platformReferrerAmount - rewards.tradeReferrerAmount - rewards.creatorAmount - rewards.dopplerAmount;\n    }\n\n    function calculateReward(uint256 amount, uint256 bps) internal pure returns (uint256) {\n        return (amount * bps) / 10_000;\n    }\n\n    function getCoinType(IHasRewardsRecipients coin) internal view returns (IHasCoinType.CoinType) {\n        // first check if the coin supports the IHasCoinType interface - if it does, we can use that\n        if (IERC165(address(coin)).supportsInterface(type(IHasCoinType).interfaceId)) {\n            return IHasCoinType(address(coin)).coinType();\n        }\n\n        // see if its a legacy creator coin\n        return isLegacyCreatorCoin(coin) ? IHasCoinType.CoinType.Creator : IHasCoinType.CoinType.Content;\n    }\n\n    function isLegacyCreatorCoin(IHasRewardsRecipients coin) internal view returns (bool) {\n        // try to call the method `getClaimableAmount` on the legacy creator coin, if it succeeds, then it is a legacy creator coin,\n        // otherwise we can assume it is a content coin\n        try ICreatorCoin(address(coin)).getClaimableAmount() returns (uint256) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n",
        "ZoraHookRegistry.sol": "// SPDX-License-Identifier: ZORA-DELAYED-OSL-v1\n// This software is licensed under the Zora Delayed Open Source License.\n// Under this license, you may use, copy, modify, and distribute this software for\n// non-commercial purposes only. Commercial use and competitive products are prohibited\n// until the \"Open Date\" (3 years from first public distribution or earlier at Zora's discretion),\n// at which point this software automatically becomes available under the MIT License.\n// Full license terms available at: https://docs.zora.co/coins/license\npragma solidity ^0.8.23;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IVersionedContract} from \"@zoralabs/shared-contracts/interfaces/IVersionedContract.sol\";\nimport {MultiOwnable} from \"../utils/MultiOwnable.sol\";\nimport {IZoraHookRegistry} from \"../interfaces/IZoraHookRegistry.sol\";\n\n/// @title Zora Hook Registry\n/// @notice A registry of Zora hook contracts for Uniswap V4\ncontract ZoraHookRegistry is IZoraHookRegistry, MultiOwnable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev The set of registered hook addresses\n    EnumerableSet.AddressSet internal registeredHooks;\n\n    /// @dev The tag for each hook\n    mapping(address hook => string tag) internal hookTags;\n\n    constructor() {}\n\n    /// @notice Initializes the registry with initial owners\n    function initialize(address[] memory initialOwners) external initializer {\n        __MultiOwnable_init(initialOwners);\n    }\n\n    /// @notice Returns whether a hook is currently registered\n    function isRegisteredHook(address hook) external view returns (bool) {\n        return registeredHooks.contains(hook);\n    }\n\n    /// @notice Returns all registered hooks\n    function getHooks() external view returns (ZoraHook[] memory) {\n        uint256 numHooks = registeredHooks.length();\n\n        ZoraHook[] memory hooks = new ZoraHook[](numHooks);\n\n        for (uint256 i; i < numHooks; i++) {\n            address hook = registeredHooks.at(i);\n\n            hooks[i] = ZoraHook({hook: hook, tag: getHookTag(hook), version: getHookVersion(hook)});\n        }\n\n        return hooks;\n    }\n\n    /// @notice Returns all registered hook addresses\n    function getHookAddresses() external view returns (address[] memory) {\n        return registeredHooks.values();\n    }\n\n    /// @notice Returns the tag for a hook\n    function getHookTag(address hook) public view returns (string memory) {\n        return hookTags[hook];\n    }\n\n    /// @notice Returns the contract version for a hook if it exists\n    function getHookVersion(address hook) public pure returns (string memory version) {\n        try IVersionedContract(hook).contractVersion() returns (string memory _version) {\n            version = _version;\n        } catch {}\n    }\n\n    /// @notice Adds hooks to the registry\n    function registerHooks(address[] calldata hooks, string[] calldata tags) external onlyOwner {\n        require(hooks.length == tags.length, ArrayLengthMismatch());\n\n        for (uint256 i; i < hooks.length; i++) {\n            if (registeredHooks.add(hooks[i])) {\n                hookTags[hooks[i]] = tags[i];\n\n                emit ZoraHookRegistered(hooks[i], tags[i], getHookVersion(hooks[i]));\n            }\n        }\n    }\n\n    /// @notice Removes hooks from the registry\n    function removeHooks(address[] calldata hooks) external onlyOwner {\n        for (uint256 i; i < hooks.length; i++) {\n            if (registeredHooks.remove(hooks[i])) {\n                emit ZoraHookRemoved(hooks[i], hookTags[hooks[i]], getHookVersion(hooks[i]));\n\n                delete hookTags[hooks[i]];\n            }\n        }\n    }\n}\n",
        "ZoraV4CoinHook.sol": "// SPDX-License-Identifier: ZORA-DELAYED-OSL-v1\n// This software is licensed under the Zora Delayed Open Source License.\n// Under this license, you may use, copy, modify, and distribute this software for\n// non-commercial purposes only. Commercial use and competitive products are prohibited\n// until the \"Open Date\" (3 years from first public distribution or earlier at Zora's discretion),\n// at which point this software automatically becomes available under the MIT License.\n// Full license terms available at: https://docs.zora.co/coins/license\npragma solidity ^0.8.23;\n\nimport {BaseHook} from \"@uniswap/v4-periphery/src/utils/BaseHook.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {BalanceDelta, BalanceDeltaLibrary} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {SwapParams} from \"@uniswap/v4-core/src/types/PoolOperation.sol\";\nimport {IZoraV4CoinHook} from \"../interfaces/IZoraV4CoinHook.sol\";\nimport {IMsgSender} from \"../interfaces/IMsgSender.sol\";\nimport {IHasSwapPath} from \"../interfaces/ICoin.sol\";\nimport {LpPosition} from \"../types/LpPosition.sol\";\nimport {V4Liquidity} from \"../libs/V4Liquidity.sol\";\nimport {CoinRewardsV4} from \"../libs/CoinRewardsV4.sol\";\nimport {ICoin} from \"../interfaces/ICoin.sol\";\nimport {IDeployedCoinVersionLookup} from \"../interfaces/IDeployedCoinVersionLookup.sol\";\nimport {CoinCommon} from \"../libs/CoinCommon.sol\";\nimport {CoinDopplerMultiCurve} from \"../libs/CoinDopplerMultiCurve.sol\";\nimport {PoolStateReader} from \"../libs/PoolStateReader.sol\";\nimport {IHasRewardsRecipients} from \"../interfaces/ICoin.sol\";\nimport {CoinConfigurationVersions} from \"../libs/CoinConfigurationVersions.sol\";\nimport {IUpgradeableV4Hook} from \"../interfaces/IUpgradeableV4Hook.sol\";\nimport {IHooksUpgradeGate} from \"../interfaces/IHooksUpgradeGate.sol\";\nimport {MultiOwnable} from \"../utils/MultiOwnable.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IUpgradeableDestinationV4Hook} from \"../interfaces/IUpgradeableV4Hook.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {BurnedPosition} from \"../interfaces/IUpgradeableV4Hook.sol\";\nimport {LiquidityAmounts} from \"../utils/uniswap/LiquidityAmounts.sol\";\nimport {TickMath} from \"../utils/uniswap/TickMath.sol\";\nimport {ContractVersionBase, IVersionedContract} from \"../version/ContractVersionBase.sol\";\nimport {IHasCoinType} from \"../interfaces/ICoin.sol\";\n\n/// @title ZoraV4CoinHook\n/// @notice Uniswap V4 hook that automatically handles fee collection and reward distributions on every swap,\n/// paying out all rewards in a backing currency.\n/// @dev This hook executes on afterSwap withdraw fees, swap for a backing currency, and distribute rewards.\n///      On pool initialization, it creates multiple liquidity positions based on the coin's pool configuration.\n///      On every swap, it automatically:\n///      1. Collects accrued LP fees from all positions\n///      2. Swaps collected fees to the backing currency through multi-hop paths\n///      3. Distributes converted fees as rewards\n/// @author oveddan\ncontract ZoraV4CoinHook is BaseHook, ContractVersionBase, IZoraV4CoinHook, ERC165, IUpgradeableDestinationV4Hook {\n    using BalanceDeltaLibrary for BalanceDelta;\n\n    /// @notice Mapping of trusted message senders - these are addresses that are trusted to provide a\n    /// an original msg.sender\n    mapping(address => bool) internal trustedMessageSender;\n\n    /// @notice Mapping of pool keys to coins.\n    mapping(bytes32 => IZoraV4CoinHook.PoolCoin) internal poolCoins;\n\n    /// @notice The coin version lookup contract - used to determine if an address is a coin and what version it is.\n    IDeployedCoinVersionLookup internal immutable coinVersionLookup;\n\n    /// @notice The upgrade gate contract - used to verify allowed upgrade paths\n    IHooksUpgradeGate internal immutable upgradeGate;\n\n    /// @notice The constructor for the ZoraV4CoinHook.\n    /// @param poolManager_ The Uniswap V4 pool manager\n    /// @param coinVersionLookup_ The coin version lookup contract - used to determine if an address is a coin and what version it is.\n    /// @param trustedMessageSenders_ The addresses of the trusted message senders - these are addresses that are trusted to provide a\n    /// @param upgradeGate_ The upgrade gate contract for managing hook upgrades\n    constructor(\n        IPoolManager poolManager_,\n        IDeployedCoinVersionLookup coinVersionLookup_,\n        address[] memory trustedMessageSenders_,\n        IHooksUpgradeGate upgradeGate_\n    ) BaseHook(poolManager_) {\n        require(address(coinVersionLookup_) != address(0), CoinVersionLookupCannotBeZeroAddress());\n\n        require(address(upgradeGate_) != address(0), UpgradeGateCannotBeZeroAddress());\n\n        coinVersionLookup = coinVersionLookup_;\n        upgradeGate = upgradeGate_;\n\n        for (uint256 i = 0; i < trustedMessageSenders_.length; i++) {\n            trustedMessageSender[trustedMessageSenders_[i]] = true;\n        }\n    }\n\n    /// @notice Returns the uniswap v4 hook settings / permissions.\n    /// @dev The permissions currently requested are: afterInitialize and afterSwap.\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return\n            Hooks.Permissions({\n                beforeInitialize: false,\n                afterInitialize: true,\n                beforeAddLiquidity: false,\n                afterAddLiquidity: false,\n                beforeRemoveLiquidity: false,\n                afterRemoveLiquidity: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false,\n                beforeSwapReturnDelta: false,\n                afterSwapReturnDelta: false,\n                afterAddLiquidityReturnDelta: false,\n                afterRemoveLiquidityReturnDelta: false\n            });\n    }\n\n    /// @inheritdoc IZoraV4CoinHook\n    function isTrustedMessageSender(address sender) external view returns (bool) {\n        return trustedMessageSender[sender];\n    }\n\n    /// @inheritdoc IZoraV4CoinHook\n    function getPoolCoinByHash(bytes32 poolKeyHash) external view returns (IZoraV4CoinHook.PoolCoin memory) {\n        return poolCoins[poolKeyHash];\n    }\n\n    /// @inheritdoc IZoraV4CoinHook\n    function getPoolCoin(PoolKey memory key) external view returns (IZoraV4CoinHook.PoolCoin memory) {\n        return poolCoins[CoinCommon.hashPoolKey(key)];\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            super.supportsInterface(interfaceId) ||\n            interfaceId == type(IUpgradeableDestinationV4Hook).interfaceId ||\n            interfaceId == type(IVersionedContract).interfaceId;\n    }\n\n    /// @notice Internal fn generating the positions for a given pool key.\n    /// @param coin The coin address.\n    /// @param key The pool key for the coin.\n    /// @return positions The contract-created liquidity positions the positions for the coin's pool.\n    function _generatePositions(ICoin coin, PoolKey memory key) internal view returns (LpPosition[] memory positions) {\n        bool isCoinToken0 = Currency.unwrap(key.currency0) == address(coin);\n\n        positions = CoinDopplerMultiCurve.calculatePositions(isCoinToken0, coin.getPoolConfiguration(), coin.totalSupplyForPositions());\n    }\n\n    /// @notice Internal fn called when a pool is initialized.\n    /// @dev This hook is called from BaseHook library from uniswap v4.\n    /// @param sender The address of the sender.\n    /// @param key The pool key.\n    /// @return selector The selector of the afterInitialize hook to confirm the action.\n    function _afterInitialize(address sender, PoolKey calldata key, uint160, int24) internal override returns (bytes4) {\n        // If the sender is the hook itself, we assume this is a migration and we return early.\n        if (sender == address(this)) {\n            return BaseHook.afterInitialize.selector;\n        }\n\n        // Otherwise, we initialize the hook positions.\n        address coin = sender;\n        if (!CoinConfigurationVersions.isV4(coinVersionLookup.getVersionForDeployedCoin(coin))) {\n            revert NotACoin(coin);\n        }\n\n        LpPosition[] memory positions = _generatePositions(ICoin(coin), key);\n\n        _initializeForPositions(key, coin, positions);\n\n        return BaseHook.afterInitialize.selector;\n    }\n\n    /// @inheritdoc IUpgradeableDestinationV4Hook\n    function initializeFromMigration(\n        PoolKey calldata poolKey,\n        address coin,\n        uint160 sqrtPriceX96,\n        BurnedPosition[] calldata migratedLiquidity,\n        bytes calldata\n    ) external {\n        address oldHook = msg.sender;\n        address newHook = address(this);\n\n        // Verify that the caller (new hook) is authorized to perform this migration\n        // Only registered upgrade paths in the upgrade gate are allowed to migrate liquidity\n        if (!upgradeGate.isRegisteredUpgradePath(oldHook, newHook)) {\n            revert IUpgradeableV4Hook.UpgradePathNotRegistered(oldHook, newHook);\n        }\n\n        // Create a new pool key with the same parameters but pointing to this hook\n        // This ensures the migrated pool uses the new hook implementation\n        PoolKey memory newKey = PoolKey({\n            currency0: poolKey.currency0,\n            currency1: poolKey.currency1,\n            fee: poolKey.fee,\n            tickSpacing: poolKey.tickSpacing,\n            hooks: IHooks(newHook)\n        });\n\n        // Initialize the new pool with the migrated price\n        // This creates the actual Uniswap V4 pool with the current market price\n        // A side effect is that the _afterInitialize hook is called here, so we find self-referential calls there and return early.\n        // This preserves the previous sqrtPriceX96 in the new pools.\n        poolManager.initialize(newKey, sqrtPriceX96);\n\n        // Convert the burned/migrated liquidity positions into new LP positions\n        // This recreates the liquidity structure from the old hook in the new hook\n        LpPosition[] memory positions = V4Liquidity.generatePositionsFromMigratedLiquidity(sqrtPriceX96, migratedLiquidity);\n\n        // Store the positions and mint the initial liquidity into the new pool\n        _initializeForPositions(newKey, coin, positions);\n\n        // Handle any remaining token balances by adding them to the last position\n        // This ensures no tokens are left unminted during the migration process\n        _mintExtraLiquidityAtLastPosition(sqrtPriceX96, newKey);\n    }\n\n    /// @notice Internal fn to add any remaining token balances to the last liquidity position.\n    /// @param sqrtPriceX96 The sqrt price x96.\n    /// @param poolKey The pool key.\n    function _mintExtraLiquidityAtLastPosition(uint160 sqrtPriceX96, PoolKey memory poolKey) internal {\n        // Check if there are any leftover token balances in the hook after migration\n        // These could result from rounding or partial liquidity transfers\n        uint256 currency0Balance = poolKey.currency0.balanceOfSelf();\n        uint256 currency1Balance = poolKey.currency1.balanceOfSelf();\n\n        // Get the stored positions for this pool to access the last position\n        LpPosition[] storage positions = poolCoins[CoinCommon.hashPoolKey(poolKey)].positions;\n\n        // Only proceed if there are actually leftover tokens to mint\n        if (currency0Balance > 0 || currency1Balance > 0) {\n            // Get reference to the last position where we'll add the extra liquidity\n            LpPosition storage lastPosition = positions[positions.length - 1];\n\n            // Calculate how much liquidity we can create with the remaining token balances\n            // This uses the current pool price and the last position's tick range\n            uint128 newLiquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96,\n                TickMath.getSqrtPriceAtTick(lastPosition.tickLower),\n                TickMath.getSqrtPriceAtTick(lastPosition.tickUpper),\n                currency0Balance,\n                currency1Balance\n            );\n\n            // Create a temporary array with just the last position to mint the extra liquidity\n            LpPosition[] memory newPositions = new LpPosition[](1);\n            newPositions[0] = lastPosition;\n            newPositions[0].liquidity = newLiquidity; // Set the calculated liquidity amount\n\n            // Mint the extra liquidity into the pool using the V4 liquidity manager\n            V4Liquidity.lockAndMint(poolManager, poolKey, newPositions);\n\n            // Update our internal tracking of the last position's liquidity\n            // This keeps our records in sync with the actual pool state\n            positions[positions.length - 1].liquidity += newPositions[0].liquidity;\n        }\n    }\n\n    /// @notice Saves the positions for the coin and mints them into the pool\n    /// @param key The pool key.\n    /// @param coin The coin address.\n    /// @param positions The positions.\n    function _initializeForPositions(PoolKey memory key, address coin, LpPosition[] memory positions) internal {\n        // Store the association between this pool and its coin + positions\n        // This creates the internal mapping that tracks which coin owns which positions\n        poolCoins[CoinCommon.hashPoolKey(key)] = PoolCoin({coin: coin, positions: positions});\n\n        // Mint all the calculated liquidity positions into the Uniswap V4 pool\n        // This actually provides the liquidity that users can trade against\n        V4Liquidity.lockAndMint(poolManager, key, positions);\n    }\n\n    /// @notice Internal fn called when a swap is executed.\n    /// @dev This hook is called from BaseHook library from uniswap v4.\n    /// This hook:\n    /// 1. Collects accrued LP fees from all positions\n    /// 2. Mints a new LP position back into the pool\n    /// 3. Swaps remaining collected fees to the backing currency through multi-hop paths\n    /// 4. Distributes converted fees as rewards\n    /// @param sender The address of the sender.\n    /// @param key The pool key.\n    /// @param params The swap parameters.\n    /// @param delta The balance delta.\n    /// @param hookData The hook data.\n    /// @return selector The selector of the afterSwap hook to confirm the action.\n    function _afterSwap(\n        address sender,\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) internal virtual override returns (bytes4, int128) {\n        bytes32 poolKeyHash = CoinCommon.hashPoolKey(key);\n\n        // get the coin address and positions for the pool key; they must have been set in the afterInitialize callback\n        address coin = poolCoins[poolKeyHash].coin;\n        require(coin != address(0), NoCoinForHook(key));\n\n        // get path for swapping the payout to a single currency\n        IHasSwapPath.PayoutSwapPath memory payoutSwapPath = IHasSwapPath(coin).getPayoutSwapPath(coinVersionLookup);\n\n        // collect lp fees\n        (int128 fees0, int128 fees1) = V4Liquidity.collectFees(poolManager, key, poolCoins[poolKeyHash].positions);\n\n        (uint128 marketRewardsAmount0, uint128 marketRewardsAmount1) = CoinRewardsV4.mintLpReward(poolManager, key, fees0, fees1);\n\n        // convert remaining fees to payout currency for market rewards\n        (Currency payoutCurrency, uint128 payoutAmount) = CoinRewardsV4.convertToPayoutCurrency(\n            poolManager,\n            marketRewardsAmount0,\n            marketRewardsAmount1,\n            payoutSwapPath\n        );\n\n        _distributeMarketRewards(payoutCurrency, payoutAmount, ICoin(coin), CoinRewardsV4.getTradeReferral(hookData));\n\n        {\n            (address swapper, bool isTrustedSwapSenderAddress) = _getOriginalMsgSender(sender);\n            bool isCoinBuy = params.zeroForOne ? Currency.unwrap(key.currency1) == address(coin) : Currency.unwrap(key.currency0) == address(coin);\n            emit Swapped(\n                sender,\n                swapper,\n                isTrustedSwapSenderAddress,\n                key,\n                poolKeyHash,\n                params,\n                delta.amount0(),\n                delta.amount1(),\n                isCoinBuy,\n                hookData,\n                PoolStateReader.getSqrtPriceX96(key, poolManager)\n            );\n        }\n\n        return (BaseHook.afterSwap.selector, 0);\n    }\n\n    /// @dev Internal fn to allow for overriding market reward distribution logic\n    function _distributeMarketRewards(Currency currency, uint128 fees, IHasRewardsRecipients coin, address tradeReferrer) internal virtual {\n        // get rewards distribution methodology from the coin\n        IHasCoinType.CoinType coinType = _getCoinType(coin);\n        CoinRewardsV4.distributeMarketRewards(currency, fees, coin, tradeReferrer, coinType);\n    }\n\n    function _getCoinType(IHasRewardsRecipients coin) internal view returns (IHasCoinType.CoinType) {\n        return CoinRewardsV4.getCoinType(coin);\n    }\n\n    /// @notice Internal fn called when the PoolManager is unlocked.  Used to mint initial liquidity positions.\n    function unlockCallback(bytes calldata data) external onlyPoolManager returns (bytes memory) {\n        return V4Liquidity.handleCallback(poolManager, data);\n    }\n\n    /// @notice Internal fn to get the original message sender.\n    /// @param sender The address of the sender.\n    /// @return swapper The original message sender.\n    /// @return senderIsTrusted Whether the sender is a trusted message sender.\n    function _getOriginalMsgSender(address sender) internal view returns (address swapper, bool senderIsTrusted) {\n        senderIsTrusted = trustedMessageSender[sender];\n\n        // If getter function reverts, we return a 0 address by default and continue execution.\n        try IMsgSender(sender).msgSender() returns (address _swapper) {\n            swapper = _swapper;\n        } catch {\n            swapper = address(0);\n        }\n    }\n\n    /// @inheritdoc IUpgradeableV4Hook\n    function migrateLiquidity(address newHook, PoolKey memory poolKey, bytes calldata additionalData) external returns (PoolKey memory newPoolKey) {\n        bytes32 poolKeyHash = CoinCommon.hashPoolKey(poolKey);\n        PoolCoin storage poolCoin = poolCoins[poolKeyHash];\n        // check that the coin associated with the poolkey is the caller\n        require(poolCoin.coin == msg.sender, OnlyCoin(msg.sender, poolCoin.coin));\n\n        // Verify upgrade path is allowed\n        if (!upgradeGate.isRegisteredUpgradePath(address(this), newHook)) {\n            revert IUpgradeableV4Hook.UpgradePathNotRegistered(address(this), newHook);\n        }\n\n        newPoolKey = V4Liquidity.lockAndMigrate(poolManager, poolKey, poolCoin.positions, poolCoin.coin, newHook, additionalData);\n    }\n\n    receive() external payable onlyPoolManager {}\n}\n",
        "BaseCoin.sol": "// SPDX-License-Identifier: ZORA-DELAYED-OSL-v1\n// This software is licensed under the Zora Delayed Open Source License.\n// Under this license, you may use, copy, modify, and distribute this software for\n// non-commercial purposes only. Commercial use and competitive products are prohibited\n// until the \"Open Date\" (3 years from first public distribution or earlier at Zora's discretion),\n// at which point this software automatically becomes available under the MIT License.\n// Full license terms available at: https://docs.zora.co/coins/license\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ICoin, IHasTotalSupplyForPositions, IHasCoinType} from \"./interfaces/ICoin.sol\";\nimport {IHasRewardsRecipients} from \"./interfaces/IHasRewardsRecipients.sol\";\nimport {ICoinComments} from \"./interfaces/ICoinComments.sol\";\nimport {IERC7572} from \"./interfaces/IERC7572.sol\";\nimport {IUniswapV3Factory} from \"./interfaces/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"./interfaces/IUniswapV3Pool.sol\";\nimport {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\nimport {IAirlock} from \"./interfaces/IAirlock.sol\";\nimport {IProtocolRewards} from \"./interfaces/IProtocolRewards.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\n\nimport {IPoolManager, PoolKey, Currency, IHooks} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IHasPoolKey, IHasSwapPath} from \"./interfaces/ICoin.sol\";\nimport {PoolConfiguration} from \"./types/PoolConfiguration.sol\";\nimport {UniV4SwapToCurrency} from \"./libs/UniV4SwapToCurrency.sol\";\nimport {PathKey} from \"@uniswap/v4-periphery/src/libraries/PathKey.sol\";\nimport {IDeployedCoinVersionLookup} from \"./interfaces/IDeployedCoinVersionLookup.sol\";\nimport {IUpgradeableV4Hook} from \"./interfaces/IUpgradeableV4Hook.sol\";\nimport {CoinCommon} from \"./libs/CoinCommon.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ContractVersionBase} from \"./version/ContractVersionBase.sol\";\nimport {MultiOwnable} from \"./utils/MultiOwnable.sol\";\nimport {FullMath} from \"./utils/uniswap/FullMath.sol\";\nimport {TickMath} from \"./utils/uniswap/TickMath.sol\";\nimport {LiquidityAmounts} from \"./utils/uniswap/LiquidityAmounts.sol\";\nimport {CoinConstants} from \"./libs/CoinConstants.sol\";\nimport {MarketConstants} from \"./libs/MarketConstants.sol\";\nimport {LpPosition} from \"./types/LpPosition.sol\";\nimport {PoolState} from \"./types/PoolState.sol\";\n\n/*\n     $$$$$$\\   $$$$$$\\  $$$$$$\\ $$\\   $$\\ \n    $$  __$$\\ $$  __$$\\ \\_$$  _|$$$\\  $$ |\n    $$ /  \\__|$$ /  $$ |  $$ |  $$$$\\ $$ |\n    $$ |      $$ |  $$ |  $$ |  $$ $$\\$$ |\n    $$ |      $$ |  $$ |  $$ |  $$ \\$$$$ |\n    $$ |  $$\\ $$ |  $$ |  $$ |  $$ |\\$$$ |\n    \\$$$$$$  | $$$$$$  |$$$$$$\\ $$ | \\$$ |\n     \\______/  \\______/ \\______|\\__|  \\__|\n*/\nabstract contract BaseCoin is ICoin, ContractVersionBase, ERC20PermitUpgradeable, MultiOwnable, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @notice The address of the protocol rewards contract\n    address public immutable protocolRewards;\n    /// @notice The address of the protocol reward recipient\n    address public immutable protocolRewardRecipient;\n    /// @notice The address of the Airlock contract, ownership is used for a protocol fee split.\n    address public immutable airlock;\n\n    /// @notice The Uniswap v4 pool manager singleton contract reference.\n    IPoolManager public immutable poolManager;\n\n    /// @notice The pool key for the coin. Type from Uniswap V4 core.\n    PoolKey internal poolKey;\n\n    /// @notice The configuration for the pool.\n    PoolConfiguration internal poolConfiguration;\n\n    /// @notice The metadata URI\n    string public tokenURI;\n    /// @notice The address of the coin creator\n    address public payoutRecipient;\n    /// @notice The address of the platform referrer\n    address public platformReferrer;\n    /// @notice The address of the currency\n    address public currency;\n\n    /// @notice The name of the token\n    string private _name;\n    /// @notice The symbol of the token\n    string private _symbol;\n\n    /**\n     * @notice The constructor for the static Coin contract deployment shared across all Coins.\n     * @param protocolRewardRecipient_ The address of the protocol reward recipient\n     * @param protocolRewards_ The address of the protocol rewards contract\n     * @param poolManager_ The address of the pool manager\n     * @param airlock_ The address of the Airlock contract\n     */\n    constructor(address protocolRewardRecipient_, address protocolRewards_, IPoolManager poolManager_, address airlock_) initializer {\n        if (protocolRewardRecipient_ == address(0)) {\n            revert AddressZero();\n        }\n        if (protocolRewards_ == address(0)) {\n            revert AddressZero();\n        }\n        if (address(poolManager_) == address(0)) {\n            revert AddressZero();\n        }\n        if (airlock_ == address(0)) {\n            revert AddressZero();\n        }\n\n        protocolRewardRecipient = protocolRewardRecipient_;\n        protocolRewards = protocolRewards_;\n        poolManager = poolManager_;\n        airlock = airlock_;\n    }\n\n    /// @inheritdoc ICoin\n    function initialize(\n        address payoutRecipient_,\n        address[] memory owners_,\n        string memory tokenURI_,\n        string memory name_,\n        string memory symbol_,\n        address platformReferrer_,\n        address currency_,\n        PoolKey memory poolKey_,\n        uint160 sqrtPriceX96,\n        PoolConfiguration memory poolConfiguration_\n    ) public virtual initializer {\n        currency = currency_;\n        // we need to set this before initialization, because\n        // distributing currency relies on the poolkey being set since the hooks\n        // are retrieved from there\n        poolKey = poolKey_;\n        poolConfiguration = poolConfiguration_;\n\n        _initialize(payoutRecipient_, owners_, tokenURI_, name_, symbol_, platformReferrer_);\n\n        // initialize the pool - the hook will mint its positions in the afterInitialize callback\n        poolManager.initialize(poolKey, sqrtPriceX96);\n    }\n\n    /// @notice Initializes a new coin (internal version)\n    /// @param payoutRecipient_ The address of the coin creator\n    /// @param tokenURI_ The metadata URI\n    /// @param name_ The coin name\n    /// @param symbol_ The coin symbol\n    /// @param platformReferrer_ The address of the platform referrer\n    function _initialize(\n        address payoutRecipient_,\n        address[] memory owners_,\n        string memory tokenURI_,\n        string memory name_,\n        string memory symbol_,\n        address platformReferrer_\n    ) internal {\n        // Validate the creation parameters\n        if (payoutRecipient_ == address(0)) {\n            revert AddressZero();\n        }\n\n        _setNameAndSymbol(name_, symbol_);\n\n        // Set base contract state, leave name and symbol empty to save space.\n        __ERC20_init(\"\", \"\");\n\n        // Set permit support without name later overriding name to match contract name.\n        __ERC20Permit_init(\"\");\n\n        __MultiOwnable_init(owners_);\n        __ReentrancyGuard_init();\n\n        // Set mutable state\n        _setPayoutRecipient(payoutRecipient_);\n        _setContractURI(tokenURI_);\n\n        // Store the referrer or use the protocol reward recipient if not set\n        platformReferrer = platformReferrer_ == address(0) ? protocolRewardRecipient : platformReferrer_;\n\n        // Distribute the initial supply\n        _handleInitialDistribution();\n    }\n\n    /// @dev The initial mint and distribution of the coin supply.\n    function _handleInitialDistribution() internal virtual {\n        // Mint the total supply to the coin contract\n        _mint(address(this), CoinConstants.MAX_TOTAL_SUPPLY);\n\n        // Distribute the creator launch reward to the payout recipient\n        _transfer(address(this), payoutRecipient, CoinConstants.CREATOR_LAUNCH_REWARD);\n    }\n\n    /// @notice Returns the name of the token for EIP712 domain.\n    /// @notice This can change when the user changes the \"name\" of the token.\n    /// @dev Overrides the default implementation to align name getter with Permit support.\n    function _EIP712Name() internal pure override returns (string memory) {\n        return \"Coin\";\n    }\n\n    /// @notice Enables a user to burn their tokens\n    /// @param amount The amount of tokens to burn\n    function burn(uint256 amount) external {\n        // This burn function sets the from as msg.sender, so having an unauthed call is safe.\n        _burn(msg.sender, amount);\n    }\n\n    /// @notice Set the creator's payout address\n    /// @param newPayoutRecipient The new recipient address\n    function setPayoutRecipient(address newPayoutRecipient) external onlyOwner {\n        _setPayoutRecipient(newPayoutRecipient);\n    }\n\n    /// @notice Set the contract URI\n    /// @param newURI The new URI\n    function setContractURI(string memory newURI) external onlyOwner {\n        _setContractURI(newURI);\n    }\n\n    /// @notice The contract metadata\n    function contractURI() external view returns (string memory) {\n        return tokenURI;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyOwner {\n        _setNameAndSymbol(newName, newSymbol);\n    }\n\n    function _setNameAndSymbol(string memory newName, string memory newSymbol) internal {\n        if (bytes(newName).length == 0) {\n            revert NameIsRequired();\n        }\n        _name = newName;\n        _symbol = newSymbol;\n        emit NameAndSymbolUpdated(msg.sender, newName, newSymbol);\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice ERC165 interface support\n    /// @param interfaceId The interface ID to check\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) ||\n            interfaceId == type(ICoin).interfaceId ||\n            interfaceId == type(ICoinComments).interfaceId ||\n            interfaceId == type(IERC7572).interfaceId ||\n            interfaceId == type(IHasRewardsRecipients).interfaceId ||\n            interfaceId == type(IHasPoolKey).interfaceId ||\n            interfaceId == type(IHasCoinType).interfaceId ||\n            interfaceId == type(IHasTotalSupplyForPositions).interfaceId ||\n            interfaceId == type(IHasSwapPath).interfaceId;\n    }\n\n    /// @dev Overrides ERC20's _update function to emit a superset `CoinTransfer` event\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n\n        emit CoinTransfer(from, to, value, balanceOf(from), balanceOf(to));\n    }\n\n    /// @dev Used to set the payout recipient on coin creation and updates\n    /// @param newPayoutRecipient The new recipient address\n    function _setPayoutRecipient(address newPayoutRecipient) internal {\n        if (newPayoutRecipient == address(0)) {\n            revert AddressZero();\n        }\n\n        emit CoinPayoutRecipientUpdated(msg.sender, payoutRecipient, newPayoutRecipient);\n\n        payoutRecipient = newPayoutRecipient;\n    }\n\n    /// @dev Used to set the contract URI on coin creation and updates\n    /// @param newURI The new URI\n    function _setContractURI(string memory newURI) internal {\n        emit ContractMetadataUpdated(msg.sender, newURI, name());\n        emit ContractURIUpdated();\n\n        tokenURI = newURI;\n    }\n\n    /// @notice Returns the address of the Doppler protocol fee recipient\n    function dopplerFeeRecipient() public view returns (address) {\n        return IAirlock(airlock).owner();\n    }\n\n    /// @inheritdoc IHasPoolKey\n    function getPoolKey() public view returns (PoolKey memory) {\n        return poolKey;\n    }\n\n    /// @inheritdoc ICoin\n    function getPoolConfiguration() public view returns (PoolConfiguration memory) {\n        return poolConfiguration;\n    }\n\n    /// @inheritdoc ICoin\n    function hooks() external view returns (IHooks) {\n        return poolKey.hooks;\n    }\n\n    /// @notice Migrate liquidity from current hook to a new hook implementation\n    /// @param newHook Address of the new hook implementation\n    /// @param additionalData Additional data to pass to the new hook during initialization\n    function migrateLiquidity(address newHook, bytes calldata additionalData) external onlyOwner returns (PoolKey memory newPoolKey) {\n        newPoolKey = IUpgradeableV4Hook(address(poolKey.hooks)).migrateLiquidity(newHook, poolKey, additionalData);\n\n        emit LiquidityMigrated(poolKey, CoinCommon.hashPoolKey(poolKey), newPoolKey, CoinCommon.hashPoolKey(newPoolKey));\n\n        poolKey = newPoolKey;\n    }\n\n    /// @inheritdoc IHasSwapPath\n    function getPayoutSwapPath(IDeployedCoinVersionLookup coinVersionLookup) external view returns (IHasSwapPath.PayoutSwapPath memory payoutSwapPath) {\n        // if to swap in is this currency,\n        // if backing currency is a coin, then recursively get the path from the coin\n        payoutSwapPath.currencyIn = Currency.wrap(address(this));\n\n        // swap to backing currency\n        PathKey memory thisPathKey = PathKey({\n            intermediateCurrency: Currency.wrap(currency),\n            fee: poolKey.fee,\n            tickSpacing: poolKey.tickSpacing,\n            hooks: poolKey.hooks,\n            hookData: \"\"\n        });\n\n        // get backing currency swap path - if the backing currency is a v4 coin and has a swap path.\n        PathKey[] memory subPath = UniV4SwapToCurrency.getSubSwapPath(currency, coinVersionLookup);\n\n        if (subPath.length > 0) {\n            payoutSwapPath.path = new PathKey[](1 + subPath.length);\n            payoutSwapPath.path[0] = thisPathKey;\n            for (uint256 i = 0; i < subPath.length; i++) {\n                payoutSwapPath.path[i + 1] = subPath[i];\n            }\n        } else {\n            payoutSwapPath.path = new PathKey[](1);\n            payoutSwapPath.path[0] = thisPathKey;\n        }\n    }\n}\n"
    }
}