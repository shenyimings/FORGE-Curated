{
    "vfp_id": "vfp_00199",
    "project_name": "EVM Emulator and Semi-abstracted Nonces Update Audit.md",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Deprecation of Arbitrary Ordering Is Not Explicit",
            "description": "The `Arbitrary` nonce ordering has been deprecated and replaced with `KeyedSequential`, but the deprecation is not clearly reflected in the code. The `IContractDeployer` interface still includes the `Arbitrary` enum value without marking it as deprecated, and documentation still references the old default.\n\nThis inconsistency stems from incomplete updates across the codebase after the design change, leaving legacy references that may mislead developers.\n\nIntegrators might assume `Arbitrary` is still a valid option and attempt to use it, only to find it is blocked at runtime. This could lead to failed deployments or unexpected reverts.\n\nThe impact is confusion and potential integration errors, undermining developer experience and trust in the API's clarity.\n",
            "severity": "Low",
            "location": [
                "IContractDeployer.sol",
                "ContractDeployer.sol",
                "docs/l2_system_contracts/system_contracts_bootloader_description.md"
            ],
            "files": [
                "era-contracts/system-contracts/contracts/interfaces/IContractDeployer.sol"
            ]
        }
    ],
    "affected_files": {
        "IContractDeployer.sol": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.20;\n\n/// @notice A struct that describes a forced deployment on an address\nstruct ForceDeployment {\n    // The bytecode hash to put on an address. Hash and length parts are ignored in case of EVM deployment with constructor.\n    bytes32 bytecodeHash;\n    // The address on which to deploy the bytecodehash to\n    address newAddress;\n    // Whether to run the constructor on the force deployment.\n    bool callConstructor;\n    // The value with which to initialize a contract\n    uint256 value;\n    // The constructor calldata\n    bytes input;\n}\n\ninterface IContractDeployer {\n    /// @notice Defines the version of the account abstraction protocol\n    /// that a contract claims to follow.\n    /// - `None` means that the account is just a contract and it should never be interacted\n    /// with as a custom account\n    /// - `Version1` means that the account follows the first version of the account abstraction protocol\n    enum AccountAbstractionVersion {\n        None,\n        Version1\n    }\n\n    /// @notice Defines the nonce ordering used by the account\n    /// - `KeyedSequential` means that it is expected that the nonces are monotonic and increment by 1\n    /// at a time for each key (nonces are split 192:64 bits into nonceKey:nonceValue parts, as proposed by EIP-4337).\n    /// - `Arbitrary` means that the nonces for the accounts can be arbitrary. The operator\n    /// should serve the transactions from such an account on a first-come-first-serve basis.\n    /// @dev This ordering is more of a suggestion to the operator on how the AA expects its transactions\n    /// to be processed and is not considered as a system invariant.\n    enum AccountNonceOrdering {\n        KeyedSequential,\n        Arbitrary\n    }\n\n    /// @notice Defines what types of bytecode are allowed to be deployed on this chain\n    /// - `EraVm` means that only native contracts can be deployed\n    /// - `EraVmAndEVM` means that native contracts and EVM contracts can be deployed\n    enum AllowedBytecodeTypes {\n        EraVm,\n        EraVmAndEVM\n    }\n\n    struct AccountInfo {\n        AccountAbstractionVersion supportedAAVersion;\n        AccountNonceOrdering nonceOrdering;\n    }\n\n    event ContractDeployed(\n        address indexed deployerAddress,\n        bytes32 indexed bytecodeHash,\n        address indexed contractAddress\n    );\n\n    event AccountNonceOrderingUpdated(address indexed accountAddress, AccountNonceOrdering nonceOrdering);\n\n    event AccountVersionUpdated(address indexed accountAddress, AccountAbstractionVersion aaVersion);\n\n    event AllowedBytecodeTypesModeUpdated(AllowedBytecodeTypes mode);\n\n    /// @notice Returns what types of bytecode are allowed to be deployed on this chain\n    function allowedBytecodeTypesToDeploy() external view returns (AllowedBytecodeTypes mode);\n\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) external view returns (address newAddress);\n\n    function getNewAddressCreate(address _sender, uint256 _senderNonce) external pure returns (address newAddress);\n\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress);\n\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) external payable returns (address newAddress);\n\n    /// @dev While the `_salt` parameter is not used anywhere here,\n    /// it is still needed for consistency between `create` and\n    /// `create2` functions (required by the compiler).\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress);\n\n    /// @dev While `_salt` is never used here, we leave it here as a parameter\n    /// for the consistency with the `create` function.\n    function createAccount(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) external payable returns (address newAddress);\n\n    /// @notice Returns the information about a certain AA.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info);\n\n    /// @notice Can be called by an account to update its account version\n    function updateAccountVersion(AccountAbstractionVersion _version) external;\n\n    /// @notice Can be called by an account to update its nonce ordering\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external;\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable;\n\n    function createEVM(bytes calldata _initCode) external payable returns (uint256 evmGasUsed, address newAddress);\n\n    function create2EVM(\n        bytes32 _salt,\n        bytes calldata _initCode\n    ) external payable returns (uint256 evmGasUsed, address newAddress);\n\n    /// @notice Changes what types of bytecodes are allowed to be deployed on the chain.\n    /// @param newAllowedBytecodeTypes The new allowed bytecode types mode.\n    function setAllowedBytecodeTypesToDeploy(AllowedBytecodeTypes newAllowedBytecodeTypes) external;\n}\n"
    }
}