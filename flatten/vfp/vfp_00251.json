{
    "vfp_id": "vfp_00251",
    "project_name": "Vicuna Finance - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "API3 and Pegged Oracles revert on invalid prices, potentially blocking the fallback oracle if configured",
            "description": "The PeggedOracle and API3 oracle implementations revert when invalid prices are detected, instead of returning a zero value. This behavior prevents the fallback oracle from being triggered in case of failure, as reverts halt execution before the fallback logic can be reached. The root cause is the use of `revert` statements in price-fetching functions rather than gracefully returning zero. An attacker could manipulate or disrupt primary price feeds, causing the entire price retrieval mechanism to fail without fallback, potentially leading to incorrect valuations or halted operations. The impact is low, as it affects availability rather than leading to direct fund loss, but it undermines the resilience of the oracle system.\n",
            "severity": "Low",
            "location": [
                "Oracles"
            ],
            "files": [
                "Vicuna-core-bl/contracts/misc/AaveOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "AaveOracle.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {AggregatorInterface} from '../dependencies/chainlink/AggregatorInterface.sol';\nimport {Errors} from '../protocol/libraries/helpers/Errors.sol';\nimport {IACLManager} from '../interfaces/IACLManager.sol';\nimport {IPoolAddressesProvider} from '../interfaces/IPoolAddressesProvider.sol';\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {IAaveOracle} from '../interfaces/IAaveOracle.sol';\n\n/**\n * @title AaveOracle\n * @author Aave\n * @notice Contract to get asset prices, manage price sources and update the fallback oracle\n * - Use of Chainlink Aggregators as first source of price\n * - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallback oracle\n * - Owned by the Aave governance\n */\ncontract AaveOracle is IAaveOracle {\n  IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n  // Map of asset price sources (asset => priceSource)\n  mapping(address => AggregatorInterface) private assetsSources;\n\n  IPriceOracleGetter private _fallbackOracle;\n  address public immutable override BASE_CURRENCY;\n  uint256 public immutable override BASE_CURRENCY_UNIT;\n\n  /**\n   * @dev Only asset listing or pool admin can call functions marked by this modifier.\n   */\n  modifier onlyAssetListingOrPoolAdmins() {\n    _onlyAssetListingOrPoolAdmins();\n    _;\n  }\n\n  /**\n   * @notice Constructor\n   * @param provider The address of the new PoolAddressesProvider\n   * @param assets The addresses of the assets\n   * @param sources The address of the source of each asset\n   * @param fallbackOracle The address of the fallback oracle to use if the data of an\n   *        aggregator is not consistent\n   * @param baseCurrency The base currency used for the price quotes. If USD is used, base currency is 0x0\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  constructor(\n    IPoolAddressesProvider provider,\n    address[] memory assets,\n    address[] memory sources,\n    address fallbackOracle,\n    address baseCurrency,\n    uint256 baseCurrencyUnit\n  ) {\n    ADDRESSES_PROVIDER = provider;\n    _setFallbackOracle(fallbackOracle);\n    _setAssetsSources(assets, sources);\n    BASE_CURRENCY = baseCurrency;\n    BASE_CURRENCY_UNIT = baseCurrencyUnit;\n    emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n  }\n\n  /// @inheritdoc IAaveOracle\n  function setAssetSources(\n    address[] calldata assets,\n    address[] calldata sources\n  ) external override onlyAssetListingOrPoolAdmins {\n    _setAssetsSources(assets, sources);\n  }\n\n  /// @inheritdoc IAaveOracle\n  function setFallbackOracle(\n    address fallbackOracle\n  ) external override onlyAssetListingOrPoolAdmins {\n    _setFallbackOracle(fallbackOracle);\n  }\n\n  /**\n   * @notice Internal function to set the sources for each asset\n   * @param assets The addresses of the assets\n   * @param sources The address of the source of each asset\n   */\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\n    require(assets.length == sources.length, Errors.INCONSISTENT_PARAMS_LENGTH);\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsSources[assets[i]] = AggregatorInterface(sources[i]);\n      emit AssetSourceUpdated(assets[i], sources[i]);\n    }\n  }\n\n  /**\n   * @notice Internal function to set the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function _setFallbackOracle(address fallbackOracle) internal {\n    _fallbackOracle = IPriceOracleGetter(fallbackOracle);\n    emit FallbackOracleUpdated(fallbackOracle);\n  }\n\n  /// @inheritdoc IPriceOracleGetter\n  function getAssetPrice(address asset) public view override returns (uint256) {\n    AggregatorInterface source = assetsSources[asset];\n\n    if (asset == BASE_CURRENCY) {\n      return BASE_CURRENCY_UNIT;\n    } else if (address(source) == address(0)) {\n      return _fallbackOracle.getAssetPrice(asset);\n    } else {\n      int256 price = source.latestAnswer();\n      if (price > 0) {\n        return uint256(price);\n      } else {\n        return _fallbackOracle.getAssetPrice(asset);\n      }\n    }\n  }\n\n  /// @inheritdoc IAaveOracle\n  function getAssetsPrices(\n    address[] calldata assets\n  ) external view override returns (uint256[] memory) {\n    uint256[] memory prices = new uint256[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      prices[i] = getAssetPrice(assets[i]);\n    }\n    return prices;\n  }\n\n  /// @inheritdoc IAaveOracle\n  function getSourceOfAsset(address asset) external view override returns (address) {\n    return address(assetsSources[asset]);\n  }\n\n  /// @inheritdoc IAaveOracle\n  function getFallbackOracle() external view returns (address) {\n    return address(_fallbackOracle);\n  }\n\n  function _onlyAssetListingOrPoolAdmins() internal view {\n    IACLManager aclManager = IACLManager(ADDRESSES_PROVIDER.getACLManager());\n    require(\n      aclManager.isAssetListingAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),\n      Errors.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN\n    );\n  }\n}\n"
    }
}