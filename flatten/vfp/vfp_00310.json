{
    "vfp_id": "vfp_00310",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Beacon Block Root Retrieval Lacks Fallback for Missed Slots",
            "description": "The `PreconfWhitelist` contract retrieves beacon block roots using `getBeaconBlockRootAt`, which requires a block to exist at the exact epoch boundary timestamp. If that slot is missed, the function returns `bytes32(0)`, resulting in zero randomness and causing the operator selection to default to index 0.\n\nThe root cause is the use of a strict lookup function without a fallback mechanism. The `_getRandomNumber` function does not handle the case of missed slots, leading to deterministic and biased operator selection during network anomalies.\n\nThe impact is a loss of randomness and fairness in proposer selection, introducing a predictable bias toward the first operator. This weakens the security of the preconfirmation system and could be exploited during periods of network instability to manipulate which operator is selected.\n",
            "severity": "Low",
            "location": [
                "PreconfWhitelist.sol::_getRandomNumber#280",
                "LibPreconfUtils.sol::getBeaconBlockRootAt#60"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/preconf/impl/PreconfWhitelist.sol"
            ]
        }
    ],
    "affected_files": {
        "PreconfWhitelist.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"../iface/IPreconfWhitelist.sol\";\nimport \"../libs/LibPreconfConstants.sol\";\nimport \"../libs/LibPreconfUtils.sol\";\nimport \"src/layer1/core/iface/IProposerChecker.sol\";\nimport \"src/shared/common/EssentialContract.sol\";\n\nimport \"./PreconfWhitelist_Layout.sol\"; // DO NOT DELETE\n\n/// @title PreconfWhitelist\n/// @custom:security-contact security@taiko.xyz\ncontract PreconfWhitelist is EssentialContract, IPreconfWhitelist, IProposerChecker {\n    struct OperatorInfo {\n        uint32 activeSince; // Epoch when the operator becomes active.\n        uint32 deprecatedInactiveSince; // Deprecated. Kept for storage compatibility.\n        uint8 index; // Index in operatorMapping.\n        address sequencerAddress; // Sequencer address for this operator (for off-chain use).\n    }\n\n    // ---------------------------------------------------------------\n    // Constants\n    // ---------------------------------------------------------------\n    /// @dev The number of epochs before a newly added operator becomes active.\n    uint8 public constant OPERATOR_CHANGE_DELAY = 2;\n    /// @dev The number of epochs to use as delay when selecting an operator.\n    ///      This needs to be 2 epochs or more to ensure the randomness seed source is stable across epochs.\n    uint8 public constant RANDOMNESS_DELAY = 2;\n\n    // ---------------------------------------------------------------\n    // State Variables\n    // ---------------------------------------------------------------\n    /// @dev An operator consists of a proposer address(the key to this mapping) and a sequencer\n    /// address.\n    ///     The proposer address is their main identifier and is used on-chain to identify the\n    /// operator and decide if they are allowed to propose.\n    ///     The sequencer address is used off-chain to to identify the address that is emitting\n    /// preconfirmations.\n    ///     NOTE: These two addresses may be the same, it is up to the operator to decide.\n    mapping(address proposer => OperatorInfo info) public operators;\n    mapping(uint256 index => address proposer) public operatorMapping;\n\n    /// @notice The total number of operators in the whitelist.\n    /// This includes both active and inactive operators.\n    uint8 public operatorCount;\n    /// @dev Deprecated variable. Kept for storage compatibility.\n    uint8 private _deprecatedOperatorChangeDelay;\n    /// @dev Deprecated variable. Kept for storage compatibility.\n    uint8 private _deprecatedRandomnessDelay;\n    /// @dev Deprecated variable. Kept for storage compatibility.\n    bool private _deprecatedHavingPerfectOperators;\n    /// @notice The epoch when the latest operator was or will be activated.\n    /// @dev No need to reinitialize the contract, this value starts at 0(i.e. no pending activations)\n    uint32 public latestActivationEpoch;\n\n    /// @dev The addresses that can eject operators from the whitelist.\n    mapping(address ejecter => bool isEjecter) public ejecters;\n\n    uint256[45] private __gap;\n\n    modifier onlyOwnerOrEjecter() {\n        require(msg.sender == owner() || ejecters[msg.sender], NotOwnerOrEjecter());\n        _;\n    }\n\n    function init(address _owner) external initializer {\n        __Essential_init(_owner);\n    }\n\n    /// @inheritdoc IPreconfWhitelist\n    /// @dev The operator only becomes active after `OPERATOR_CHANGE_DELAY` epochs.\n    function addOperator(address _proposer, address _sequencer) external onlyOwnerOrEjecter {\n        _addOperator(_proposer, _sequencer);\n    }\n\n    /// @inheritdoc IPreconfWhitelist\n    /// @dev IMPORTANT: The operator is removed immediately\n    function removeOperator(uint256 _operatorIndex) external onlyOwnerOrEjecter {\n        require(_operatorIndex < operatorCount, InvalidOperatorIndex());\n        _removeOperator(operatorMapping[_operatorIndex]);\n    }\n\n    /// @notice Removes an operator by proposer address, keeping the index mapping densely packed.\n    /// IMPORTANT: The operator is removed immediately\n    /// @param _proposer The proposer address of the operator to remove.\n    function removeOperatorByAddress(address _proposer) external onlyOwnerOrEjecter {\n        _removeOperator(_proposer);\n    }\n\n    /// @notice Sets the ejecter address.\n    /// @param _ejecter The new ejecter address.\n    function setEjecter(address _ejecter, bool _isEjecter) external onlyOwner {\n        ejecters[_ejecter] = _isEjecter;\n        emit EjecterUpdated(_ejecter, _isEjecter);\n    }\n\n    /// @inheritdoc IProposerChecker\n    function checkProposer(\n        address _proposer,\n        bytes calldata\n    )\n        external\n        view\n        override(IProposerChecker)\n        returns (uint48 endOfSubmissionWindowTimestamp_)\n    {\n        address operator = _getOperatorForEpoch(epochStartTimestamp(0));\n        require(operator != address(0), InvalidProposer());\n        require(operator == _proposer, InvalidProposer());\n        // Slashing is not enabled for whitelisted preconfers, so we return 0\n        endOfSubmissionWindowTimestamp_ = 0;\n    }\n\n    /// @inheritdoc IPreconfWhitelist\n    function getOperatorForCurrentEpoch() public view returns (address) {\n        return _getOperatorForEpoch(epochStartTimestamp(0));\n    }\n\n    /// @inheritdoc IPreconfWhitelist\n    function getOperatorForNextEpoch() external view returns (address) {\n        return _getOperatorForEpoch(epochStartTimestamp(1));\n    }\n\n    /// @notice Returns true if the operator is active in the given epoch.\n    /// @param _proposer The proposer address of the operator to check.\n    /// @param _epochTimestamp The timestamp of the epoch to check.\n    /// @return _ True if the operator is active in the given epoch, false otherwise.\n    function isOperatorActive(\n        address _proposer,\n        uint32 _epochTimestamp\n    )\n        public\n        view\n        returns (bool)\n    {\n        unchecked {\n            OperatorInfo storage info = operators[_proposer];\n\n            uint32 activeSince = info.activeSince;\n            return activeSince != 0 && _epochTimestamp >= activeSince;\n        }\n    }\n\n    /// @notice Returns the timestamp of the epoch start with the given offset\n    /// @param _offset The offset from the current epoch start.\n    /// @return The timestamp of the epoch start with the given offset.\n    function epochStartTimestamp(uint256 _offset) public view returns (uint32) {\n        return uint32(\n            LibPreconfUtils.getEpochTimestamp() + _offset * LibPreconfConstants.SECONDS_IN_EPOCH\n        );\n    }\n\n    /// @dev Checks if there is another active operator excluding the given operator\n    /// @param _excluded The proposer address of the operator to exclude.\n    /// @param _epochTimestamp The timestamp of the epoch to check.\n    /// @return True if there is another active operator, false otherwise.\n    function _hasAnotherActiveOperator(\n        address _excluded,\n        uint32 _epochTimestamp\n    )\n        internal\n        view\n        returns (bool)\n    {\n        uint8 _operatorCount = operatorCount;\n        for (uint8 i; i < _operatorCount; ++i) {\n            address operator = operatorMapping[i];\n            if (operator == _excluded) continue;\n            if (isOperatorActive(operator, _epochTimestamp)) return true;\n        }\n        return false;\n    }\n\n    /// @dev Adds an operator to the whitelist.\n    /// NOTE: The operator only becomes active after `OPERATOR_CHANGE_DELAY` epochs.\n    /// @param _proposer The proposer address of the operator to add.\n    /// @param _sequencer The sequencer address of the operator to add.\n    function _addOperator(address _proposer, address _sequencer) internal {\n        require(_proposer != address(0), InvalidOperatorAddress());\n        require(_sequencer != address(0), InvalidOperatorAddress());\n\n        OperatorInfo storage info = operators[_proposer];\n\n        // if they're already active, just revert\n        if (info.activeSince != 0) {\n            revert OperatorAlreadyExists();\n        }\n\n        uint32 activeSince = epochStartTimestamp(OPERATOR_CHANGE_DELAY);\n        uint8 idx = operatorCount;\n        info.index = idx;\n        operatorMapping[idx] = _proposer;\n\n        operatorCount = idx + 1;\n\n        info.activeSince = activeSince;\n        info.sequencerAddress = _sequencer;\n\n        latestActivationEpoch = activeSince;\n\n        emit OperatorAdded(_proposer, _sequencer, activeSince);\n    }\n\n    /// @dev Removes an operator immediately and backfills its slot with the last proposer so\n    ///      operatorMapping stays packed from 0..operatorCount-1.\n    /// IMPORTANT: Reverts if no other operator is active.\n    /// @param _proposer The proposer address of the operator to remove.\n    function _removeOperator(address _proposer) internal {\n        require(operatorCount > 1, CannotRemoveLastOperator());\n        require(_proposer != address(0), InvalidOperatorAddress());\n        OperatorInfo storage info = operators[_proposer];\n        require(info.activeSince != 0, InvalidOperatorAddress());\n\n        uint32 currentEpochTs = epochStartTimestamp(0);\n        if (isOperatorActive(_proposer, currentEpochTs)) {\n            require(\n                _hasAnotherActiveOperator(_proposer, currentEpochTs), NoActiveOperatorRemaining()\n            );\n        }\n\n        address sequencer = info.sequencerAddress;\n        uint8 index = info.index;\n        uint8 lastIndex = operatorCount - 1;\n\n        if (index != lastIndex) {\n            address lastProposer = operatorMapping[lastIndex];\n            operatorMapping[index] = lastProposer;\n            operators[lastProposer].index = index;\n        }\n\n        delete operatorMapping[lastIndex];\n        delete operators[_proposer];\n\n        operatorCount = lastIndex;\n\n        emit OperatorRemoved(_proposer, sequencer, block.timestamp);\n    }\n\n    /// @dev Returns the operator for the given epoch\n    /// This function is not affected by operators that are added mid-epoch, since it filters active ones.\n    /// NOTE: We optimize for the common case where all operators are active.\n    /// In that case we don't scan the entire operator set or check if the operator is active.\n    /// @param _epochTimestamp The timestamp of the epoch to get the operator for.\n    /// @return The operator for the given epoch.\n    function _getOperatorForEpoch(uint32 _epochTimestamp) internal view returns (address) {\n        unchecked {\n            // Get epoch-stable randomness with a delayed applied. This avoids querying future beacon roots.\n            uint256 delaySeconds = RANDOMNESS_DELAY * LibPreconfConstants.SECONDS_IN_EPOCH;\n            uint256 ts = uint256(_epochTimestamp);\n            uint32 randomnessTs = uint32(ts >= delaySeconds ? ts - delaySeconds : ts);\n\n            // One SLOAD\n            uint256 _operatorCount = operatorCount;\n            uint32 _latestActivationEpoch = latestActivationEpoch;\n\n            if (_operatorCount == 0) return address(0);\n            uint256 randomNumber = _getRandomNumber(randomnessTs);\n            if (_epochTimestamp >= _latestActivationEpoch) {\n                // Fast path: This means all operators are active, so we can just select one without checking\n                return operatorMapping[randomNumber % _operatorCount];\n            }\n\n            // Slow path: We need to check which operators are active\n            address[] memory candidates = new address[](_operatorCount);\n            uint256 count;\n            for (uint256 i; i < _operatorCount; ++i) {\n                address operator = operatorMapping[i];\n                if (isOperatorActive(operator, _epochTimestamp)) {\n                    candidates[count++] = operator;\n                }\n            }\n            if (count == 0) return address(0);\n            return candidates[randomNumber % count];\n        }\n    }\n\n    function _getRandomNumber(uint32 _epochTimestamp) internal view returns (uint256) {\n        // Get the beacon root at the epoch start - this stays constant throughout the epoch\n        bytes32 beaconRoot = LibPreconfUtils.getBeaconBlockRootAt(_epochTimestamp);\n\n        return uint256(beaconRoot);\n    }\n\n    // ---------------------------------------------------------------\n    // Errors\n    // ---------------------------------------------------------------\n\n    error CannotRemoveLastOperator();\n    error InvalidOperatorIndex();\n    error InvalidOperatorCount();\n    error InvalidOperatorAddress();\n    error OperatorAlreadyExists();\n    error OperatorAlreadyRemoved();\n    error OperatorNotAvailableYet();\n    error NoActiveOperatorRemaining();\n    error NotOwnerOrEjecter();\n}\n"
    }
}