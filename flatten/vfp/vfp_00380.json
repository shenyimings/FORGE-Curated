{
    "vfp_id": "vfp_00380",
    "project_name": "cantina_eco_pr28_pr38_aug2025.pdf",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Overloaded function names are confusing",
            "description": "The MultiTokenPermit contract uses heavily overloaded function names such as transferFrom() and batchTransferFrom() to handle different token standards and batching strategies. While Solidity supports function overloading, the lack of distinct names based on functionality reduces code clarity and makes it difficult to determine the exact behavior without inspecting argument types. This is not exploitable in a security sense, but increases the risk of integration errors by developers who may misunderstand which overload is being called. The impact is reduced code readability and increased likelihood of developer mistakes during integration, potentially leading to incorrect usage and reverted transactions.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "70649332/permit3/src/MultiTokenPermit.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect NatSpec comments",
            "description": "The NatSpec documentation in MultiTokenPermit.sol incorrectly states that tokenId = 0 is used to refer to ERC20 tokens. The comment is misleading because tokenId = 0 is not a special value reserved for ERC20s; collection-wide approvals are handled separately using type(uint256).max or address-based keys. Developers relying on documentation may misunderstand the approval mechanism, leading to incorrect assumptions about how ERC20 approvals are managed. The impact is misleading documentation that can result in integration bugs and confusion, reducing the reliability of external tooling and developer implementations.\n",
            "severity": "Informational",
            "location": [
                "MultiTokenPermit.sol::_getTokenKey#L20",
                "MultiTokenPermit.sol::allowance#L38",
                "MultiTokenPermit.sol::approve#L59"
            ],
            "files": [
                "70649332/permit3/src/MultiTokenPermit.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Approval event for NFTs lacks tokenId",
            "description": "The approve() function in MultiTokenPermit.sol emits the standard Approval event when approving specific ERC721 or ERC1155 tokens, but this event does not include the tokenId. The function uses the generic ERC20-style Approval event, which only includes owner, spender, and value, omitting the tokenId parameter relevant for NFTs. Off-chain services (e.g., indexers, wallets, explorers) cannot determine which specific NFT was approved, making it impossible to accurately track approvals. The impact is reduced transparency and functionality for off-chain monitoring systems, leading to incomplete or inaccurate user interfaces and analytics.\n",
            "severity": "Informational",
            "location": [
                "MultiTokenPermit.sol::approve#L80"
            ],
            "files": [
                "70649332/permit3/src/MultiTokenPermit.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "The struct MultiTokenTransfer is misleadingly named",
            "description": "The MultiTokenTransfer struct is used in batchTransferFrom() for ERC1155 transfers but implies support for multiple token types. The name suggests broader functionality than what is implemented, as it only handles transfers of a single token type (ERC1155) in a batch. Developers may assume the struct supports heterogeneous token transfers, leading to incorrect usage and integration bugs. The impact is misleading naming that increases cognitive load and risk of misuse, reducing code maintainability and developer experience.\n",
            "severity": "Informational",
            "location": [
                "MultiTokenPermit.sol::MultiTokenTransfer#L177-L179"
            ],
            "files": [
                "70649332/permit3/src/interfaces/IMultiTokenPermit.sol",
                "70649332/permit3/src/MultiTokenPermit.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Inefficiency on batch ERC1155 transfers",
            "description": "The batchTransferFrom() function processes each ERC1155 transfer individually using safeTransferFrom() instead of aggregating them. The function iterates through each token and performs a separate external call, missing the opportunity to use the more efficient safeBatchTransferFrom() function. This inefficiency increases gas costs and execution time for batch transfers, making the function more expensive to use. The impact is higher transaction costs and reduced scalability for users performing batch transfers of ERC1155 tokens.\n",
            "severity": "Informational",
            "location": [
                "MultiTokenPermit.sol::batchTransferFrom#L207-L211"
            ],
            "files": [
                "70649332/permit3/src/MultiTokenPermit.sol"
            ]
        }
    ],
    "affected_files": {
        "MultiTokenPermit.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { IMultiTokenPermit } from \"./interfaces/IMultiTokenPermit.sol\";\n\nimport { PermitBase } from \"./PermitBase.sol\";\n\n/**\n * @title MultiTokenPermit\n * @notice Multi-token support (ERC20, ERC721, ERC1155) for the Permit3 system\n * @dev Extends PermitBase with NFT and semi-fungible token functionality\n */\nabstract contract MultiTokenPermit is PermitBase, IMultiTokenPermit {\n    /**\n     * @dev Internal helper to get the storage key for a token/tokenId pair\n     * @param token Token contract address\n     * @param tokenId Token ID (0 for ERC20, specific ID for NFT, type(uint256).max for collection-wide)\n     * @return Storage key for allowance mapping\n     */\n    function _getTokenKey(address token, uint256 tokenId) internal pure returns (bytes32) {\n        if (tokenId == type(uint256).max) {\n            // ERC20 or collection-wide approval - convert address to bytes32\n            return bytes32(uint256(uint160(token)));\n        } else {\n            // Specific token ID - hash token and tokenId together\n            return keccak256(abi.encodePacked(token, tokenId));\n        }\n    }\n\n    /**\n     * @notice Query multi-token allowance for a specific token ID\n     * @param owner Token owner\n     * @param token Token contract address\n     * @param spender Approved spender\n     * @param tokenId Token ID (0 for ERC20, type(uint256).max for NFT collection-wide approval allowing any token in\n     * collection)\n     * @return amount Approved amount (max uint160 for unlimited)\n     * @return expiration Timestamp when approval expires (0 for no expiration)\n     * @return timestamp Timestamp when approval was set\n     */\n    function allowance(\n        address owner,\n        address token,\n        address spender,\n        uint256 tokenId\n    ) external view override returns (uint160 amount, uint48 expiration, uint48 timestamp) {\n        bytes32 tokenKey = _getTokenKey(token, tokenId);\n        Allowance memory allowed = allowances[owner][tokenKey][spender];\n        return (allowed.amount, allowed.expiration, allowed.timestamp);\n    }\n\n    /**\n     * @notice Approve a spender for a specific token or collection\n     * @param token Token contract address\n     * @param spender Address to approve\n     * @param tokenId Token ID (0 for ERC20, specific ID for NFT, type(uint256).max for NFT collection-wide approval)\n     * @param amount Amount to approve (ignored for ERC721, used for ERC20/ERC1155)\n     * @param expiration Timestamp when approval expires (0 for no expiration)\n     */\n    function approve(\n        address token,\n        address spender,\n        uint256 tokenId,\n        uint160 amount,\n        uint48 expiration\n    ) external override {\n        bytes32 tokenKey = _getTokenKey(token, tokenId);\n\n        // Use the same validation as PermitBase\n        _validateApproval(msg.sender, tokenKey, token, spender, expiration);\n\n        // Update the allowance\n        allowances[msg.sender][tokenKey][spender] =\n            Allowance({ amount: amount, expiration: expiration, timestamp: uint48(block.timestamp) });\n\n        // Emit standard approval event from IPermit interface - emit original token address\n        emit Approval(msg.sender, token, spender, amount, expiration);\n    }\n\n    /**\n     * @notice Execute approved ERC721 token transfer\n     * @dev Uses a dual-allowance system: first checks for specific token ID approval,\n     *      then falls back to collection-wide approval (set with tokenId = type(uint256).max).\n     *      This allows users to either approve individual NFTs or entire collections.\n     * @param from Token owner address\n     * @param to Transfer recipient address\n     * @param token ERC721 contract address\n     * @param tokenId The unique NFT token ID to transfer\n     */\n    function transferFrom(address from, address to, address token, uint256 tokenId) public override {\n        // Get the encoded identifier for this specific token ID\n        bytes32 encodedId = _getTokenKey(token, tokenId);\n\n        // First, try to update allowance for the specific token ID\n        (, bytes memory revertDataPerId) = _updateAllowance(from, encodedId, msg.sender, 1);\n\n        if (revertDataPerId.length > 0) {\n            // Fallback: if no specific token approval exists, check for collection-wide approval\n            // Collection-wide approval is set by calling approve() with tokenId = type(uint256).max\n            bytes32 collectionKey = bytes32(uint256(uint160(token)));\n\n            if (encodedId == collectionKey) {\n                // Special case: tokenId = max is the same wild card approval\n                _revert(revertDataPerId);\n            }\n\n            (, bytes memory revertDataWildcard) = _updateAllowance(from, collectionKey, msg.sender, 1);\n\n            _handleAllowanceError(revertDataPerId, revertDataWildcard);\n        }\n        IERC721(token).safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @notice Execute approved ERC1155 token transfer\n     * @dev Uses a dual-allowance system: first checks for specific token ID approval,\n     *      then falls back to collection-wide approval (set with tokenId = type(uint256).max).\n     *      This allows users to either approve individual token types or entire collections.\n     * @param from Token owner address\n     * @param to Transfer recipient address\n     * @param token ERC1155 contract address\n     * @param tokenId The specific ERC1155 token ID to transfer\n     * @param amount Number of tokens to transfer\n     */\n    function transferFrom(address from, address to, address token, uint256 tokenId, uint160 amount) public override {\n        // Get the encoded identifier for this specific token ID\n        bytes32 encodedId = _getTokenKey(token, tokenId);\n\n        // First, try to update allowance for the specific token ID\n        (, bytes memory revertDataPerId) = _updateAllowance(from, encodedId, msg.sender, amount);\n\n        if (revertDataPerId.length > 0) {\n            // Fallback: if no specific token approval exists, check for collection-wide approval\n            // Collection-wide approval is set by calling approve() with tokenId = type(uint256).max\n            bytes32 collectionKey = bytes32(uint256(uint160(token)));\n\n            if (encodedId == collectionKey) {\n                // Special case: tokenId = max is the same wild card approval\n                _revert(revertDataPerId);\n            }\n\n            (, bytes memory revertDataWildcard) = _updateAllowance(from, collectionKey, msg.sender, amount);\n\n            _handleAllowanceError(revertDataPerId, revertDataWildcard);\n        }\n\n        // Execute the ERC1155 transfer\n        IERC1155(token).safeTransferFrom(from, to, tokenId, amount, \"\");\n    }\n\n    /**\n     * @notice Execute multiple approved ERC721 transfers in a single transaction\n     * @dev Each transfer uses the dual-allowance system independently\n     * @param transfers Array of ERC721 transfer instructions\n     */\n    function transferFrom(\n        ERC721TransferDetails[] calldata transfers\n    ) external override {\n        uint256 transfersLength = transfers.length;\n        if (transfersLength == 0) {\n            revert EmptyArray();\n        }\n\n        for (uint256 i = 0; i < transfersLength; i++) {\n            transferFrom(transfers[i].from, transfers[i].to, transfers[i].token, transfers[i].tokenId);\n        }\n    }\n\n    /**\n     * @notice Execute multiple approved ERC1155 transfers in a single transaction\n     * @dev Each transfer uses the dual-allowance system independently\n     * @param transfers Array of multi-token transfer instructions\n     */\n    function transferFrom(\n        MultiTokenTransfer[] calldata transfers\n    ) external override {\n        uint256 transfersLength = transfers.length;\n        if (transfersLength == 0) {\n            revert EmptyArray();\n        }\n\n        for (uint256 i = 0; i < transfersLength; i++) {\n            transferFrom(\n                transfers[i].from, transfers[i].to, transfers[i].token, transfers[i].tokenId, transfers[i].amount\n            );\n        }\n    }\n\n    /**\n     * @notice Execute approved ERC1155 batch transfer for multiple token IDs to a single recipient\n     * @dev Processes each token ID individually through the dual-allowance system\n     * @param transfer Batch transfer details containing arrays of token IDs and amounts\n     */\n    function batchTransferFrom(\n        ERC1155BatchTransferDetails calldata transfer\n    ) external override {\n        uint256 tokenIdsLength = transfer.tokenIds.length;\n        if (tokenIdsLength == 0) {\n            revert EmptyArray();\n        }\n        if (tokenIdsLength != transfer.amounts.length) {\n            revert InvalidArrayLength();\n        }\n\n        // Execute batch by processing each token ID individually to leverage dual-allowance logic\n        for (uint256 i = 0; i < tokenIdsLength; i++) {\n            transferFrom(transfer.from, transfer.to, transfer.token, transfer.tokenIds[i], transfer.amounts[i]);\n        }\n    }\n\n    /**\n     * @notice Execute multiple token transfers of any type in a single transaction\n     * @dev Routes each transfer to the appropriate function based on explicit token type.\n     *      Note: This function uses explicit TokenStandard enum instead of tokenId conventions\n     *      (tokenId=0 for ERC20) to provide unambiguous routing for mixed-type batches.\n     * @param transfers Array of multi-token transfer instructions with explicit token types\n     */\n    function batchTransferFrom(\n        TokenTypeTransfer[] calldata transfers\n    ) external override {\n        uint256 transfersLength = transfers.length;\n        if (transfersLength == 0) {\n            revert EmptyArray();\n        }\n\n        for (uint256 i = 0; i < transfersLength; i++) {\n            TokenTypeTransfer calldata typeTransfer = transfers[i];\n            MultiTokenTransfer calldata transfer = typeTransfer.transfer;\n\n            if (typeTransfer.tokenType == TokenStandard.ERC20) {\n                // ERC20: Use amount field, tokenId is ignored\n                PermitBase.transferFrom(transfer.from, transfer.to, transfer.amount, transfer.token);\n            } else if (typeTransfer.tokenType == TokenStandard.ERC721) {\n                // ERC721: Use tokenId field, amount should be 1 (but not enforced)\n                transferFrom(transfer.from, transfer.to, transfer.token, transfer.tokenId);\n            } else if (typeTransfer.tokenType == TokenStandard.ERC1155) {\n                // ERC1155: Use both tokenId and amount\n                transferFrom(transfer.from, transfer.to, transfer.token, transfer.tokenId, transfer.amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal helper to handle allowance errors with priority logic\n     * @param revertDataPerId Revert data from specific token ID allowance check\n     * @param revertDataWildcard Revert data from collection-wide allowance check\n     */\n    function _handleAllowanceError(bytes memory revertDataPerId, bytes memory revertDataWildcard) internal pure {\n        if (revertDataPerId.length == 0 || revertDataWildcard.length == 0) {\n            // If any allowance succeeded, no error to handle\n            return;\n        }\n\n        bytes4 perIdSelector = bytes4(revertDataPerId);\n\n        // Priority error handling: show collection-wide error for insufficient allowance,\n        // otherwise show the more specific per-token error\n        if (perIdSelector == InsufficientAllowance.selector) {\n            _revert(revertDataWildcard);\n        } else {\n            _revert(revertDataPerId);\n        }\n    }\n}\n",
        "IMultiTokenPermit.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IMultiTokenPermit\n * @notice Interface for multi-token support (ERC20, ERC721, ERC1155) in the Permit3 system\n * @dev Extends the existing permit system to handle NFTs and semi-fungible tokens\n */\ninterface IMultiTokenPermit {\n    /**\n     * @notice Error thrown when array lengths don't match in batch operations\n     * @dev Used when tokenIds.length != amounts.length in ERC1155 batch transfers\n     */\n    error InvalidArrayLength();\n\n    /**\n     * @notice Emitted when a multi-token permit is executed for NFTs with specific token IDs\n     * @dev Used when tokenKey is a hash of token address and token ID\n     * @param owner Token owner address\n     * @param tokenKey Token identifier hash (keccak256(token, tokenId))\n     * @param spender Spender address\n     * @param amount Approved amount\n     * @param expiration Expiration timestamp\n     * @param timestamp Permit execution timestamp\n     */\n    event PermitMultiToken(\n        address indexed owner,\n        bytes32 indexed tokenKey,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 timestamp\n    );\n\n    /**\n     * @notice Enum representing different token standards\n     * @param ERC20 Standard fungible tokens with divisible amounts\n     * @param ERC721 Non-fungible tokens with unique token IDs\n     * @param ERC1155 Semi-fungible tokens with both ID and amount\n     */\n    enum TokenStandard {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    /**\n     * @notice Transfer details for ERC721 tokens\n     * @param from Token owner\n     * @param to Token recipient\n     * @param tokenId The specific NFT token ID\n     * @param token The ERC721 contract address\n     */\n    struct ERC721TransferDetails {\n        address from;\n        address to;\n        uint256 tokenId;\n        address token;\n    }\n\n    /**\n     * @notice Unified transfer details for any token type\n     * @param from Token owner\n     * @param to Transfer recipient\n     * @param token Token contract address\n     * @param tokenId Token ID (used for ERC721 and ERC1155, ignored for ERC20)\n     * @param amount Transfer amount (used for ERC20 and ERC1155, must be 1 for ERC721)\n     */\n    struct MultiTokenTransfer {\n        address from;\n        address to;\n        address token;\n        uint256 tokenId;\n        uint160 amount;\n    }\n\n    /**\n     * @notice Batch ERC1155 transfer details\n     * @param from Token owner\n     * @param to Token recipient\n     * @param tokenIds Array of ERC1155 token IDs\n     * @param amounts Array of amounts corresponding to each token ID\n     * @param token The ERC1155 contract address\n     */\n    struct ERC1155BatchTransferDetails {\n        address from;\n        address to;\n        uint256[] tokenIds;\n        uint160[] amounts;\n        address token;\n    }\n\n    /**\n     * @notice Multi-token transfer instruction with explicit token type\n     * @param tokenType The type of token (ERC20, ERC721, or ERC1155)\n     * @param transfer The unified transfer details struct\n     */\n    struct TokenTypeTransfer {\n        TokenStandard tokenType;\n        MultiTokenTransfer transfer;\n    }\n\n    /**\n     * @notice Query multi-token allowance for a specific token ID\n     * @param owner Token owner\n     * @param token Token contract address\n     * @param spender Approved spender\n     * @param tokenId Token ID (0 for ERC20, specific ID for NFT/ERC1155, type(uint256).max for collection-wide\n     * wildcard)\n     * @return amount Approved amount (max uint160 for unlimited)\n     * @return expiration Timestamp when approval expires (0 for no expiration)\n     * @return timestamp Timestamp when approval was set\n     */\n    function allowance(\n        address owner,\n        address token,\n        address spender,\n        uint256 tokenId\n    ) external view returns (uint160 amount, uint48 expiration, uint48 timestamp);\n\n    /**\n     * @notice Approve a spender for a specific token or collection\n     * @param token Token contract address\n     * @param spender Address to approve\n     * @param tokenId Token ID (0 for ERC20, specific ID for NFT/ERC1155, type(uint256).max for collection wildcard)\n     * @param amount Amount to approve (ignored for ERC721, used for ERC20/ERC1155)\n     * @param expiration Timestamp when approval expires (0 for no expiration)\n     */\n    function approve(address token, address spender, uint256 tokenId, uint160 amount, uint48 expiration) external;\n\n    /**\n     * @notice Execute approved ERC721 token transfer\n     * @param from Token owner\n     * @param to Transfer recipient\n     * @param token ERC721 token address\n     * @param tokenId The NFT token ID\n     */\n    function transferFrom(address from, address to, address token, uint256 tokenId) external;\n\n    /**\n     * @notice Execute approved ERC1155 token transfer\n     * @param from Token owner\n     * @param to Transfer recipient\n     * @param token ERC1155 token address\n     * @param tokenId The ERC1155 token ID\n     * @param amount Transfer amount\n     */\n    function transferFrom(address from, address to, address token, uint256 tokenId, uint160 amount) external;\n\n    /**\n     * @notice Execute approved ERC721 batch transfer\n     * @param transfers Array of ERC721 transfer instructions\n     */\n    function transferFrom(\n        ERC721TransferDetails[] calldata transfers\n    ) external;\n\n    /**\n     * @notice Execute approved ERC1155 batch transfer with multiple token types\n     * @param transfers Array of multi-token transfer instructions\n     */\n    function transferFrom(\n        MultiTokenTransfer[] calldata transfers\n    ) external;\n\n    /**\n     * @notice Execute approved ERC1155 batch transfer for multiple token IDs\n     * @param transfer Batch transfer details for multiple token IDs\n     */\n    function batchTransferFrom(\n        ERC1155BatchTransferDetails calldata transfer\n    ) external;\n\n    /**\n     * @notice Execute multiple token transfers of any type in a single transaction\n     * @param transfers Array of multi-token transfer instructions\n     */\n    function batchTransferFrom(\n        TokenTypeTransfer[] calldata transfers\n    ) external;\n}\n"
    }
}