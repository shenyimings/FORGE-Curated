{
    "vfp_id": "vfp_00380",
    "project_name": "cantina_eco_pr28_pr38_aug2025.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ]
            },
            "title": "Lockdown issues",
            "description": "In the event of a token contract compromise, there is no mechanism to lock down all allowances for a specific token across all users. The current lockdown feature only applies per-account and does not prevent existing approvals to the Permit3 contract from being exploited. Users must manually revoke allowances on each token, which is impractical during an emergency. The root cause is the lack of a global or token-wide lockdown mechanism. The impact is increased risk during a token-level security incident, as users cannot quickly and collectively revoke permissions, potentially leading to widespread asset loss.\n",
            "severity": "Informational",
            "location": [
                "PermitBase.sol#L159-L183"
            ],
            "files": [
                "70649332/permit3/src/PermitBase.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "No way to reset an existing allowance",
            "description": "The approve() function in PermitBase.sol disallows setting an allowance to zero, preventing users from revoking existing approvals through the standard method. This deviates from the common ERC20 pattern where setting allowance to zero is the first step before increasing it, used to prevent front-running. The cause is a validation that explicitly blocks zero amounts. This limitation reduces compatibility with standard wallet and dApp behaviors, potentially leading to confusion or failed transactions. The impact is reduced usability and increased risk of allowance-related attacks, as users cannot properly reset their allowances.\n",
            "severity": "Low",
            "location": [
                "PermitBase.sol#L70-L71"
            ],
            "files": [
                "70649332/permit3/src/PermitBase.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Unnecessary checks on address parameters",
            "description": "The transferFrom() function in PermitBase.sol performs zero-address checks on 'from', 'to', and 'token' parameters, but these are redundant because the internal _transferFrom() function already includes the same validations. This results in duplicated require statements that increase deployment and runtime gas costs without adding security. The cause is lack of coordination between public interface and internal validation layers. The impact is avoidable gas overhead on every call to transferFrom(), reducing cost-efficiency for users.\n",
            "severity": "Informational",
            "location": [
                "PermitBase.sol#L92-L100"
            ],
            "files": [
                "70649332/permit3/src/PermitBase.sol"
            ]
        }
    ],
    "affected_files": {
        "PermitBase.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IPermit } from \"./interfaces/IPermit.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title PermitBase\n * @notice Base implementation for token approvals and transfers\n * @dev Core functionality for managing token permissions\n */\ncontract PermitBase is IPermit {\n    using SafeERC20 for IERC20;\n\n    /// @dev Special value representing a locked allowance that cannot be used\n    /// @dev Value of 2 is chosen to distinguish from 0 (no expiration) and 1 (expired)\n    uint48 internal constant LOCKED_ALLOWANCE = 2;\n\n    /// @dev Maximum value for uint160, representing unlimited/infinite allowance\n    /// @dev Using uint160 instead of uint256 to save gas on storage operations\n    uint160 internal constant MAX_ALLOWANCE = type(uint160).max;\n\n    /**\n     * @dev Core data structure for tracking token permissions\n     * Maps: owner => tokenAddress32 => spender => {amount, expiration, timestamp}\n     */\n    mapping(address => mapping(bytes32 => mapping(address => Allowance))) internal allowances;\n\n    /**\n     * @notice Query current token allowance\n     * @dev Retrieves full allowance details including expiration\n     * @param user Token owner\n     * @param token ERC20 token address\n     * @param spender Approved spender\n     * @return amount Current approved amount\n     * @return expiration Timestamp when approval expires\n     * @return timestamp Timestamp when approval was set\n     */\n    function allowance(\n        address user,\n        address token,\n        address spender\n    ) external view returns (uint160 amount, uint48 expiration, uint48 timestamp) {\n        bytes32 tokenKey = bytes32(uint256(uint160(token)));\n        Allowance memory allowed = allowances[user][tokenKey][spender];\n        return (allowed.amount, allowed.expiration, allowed.timestamp);\n    }\n\n    /**\n     * @notice Internal function to validate approval parameters and check for locked allowances\n     * @param owner Token owner address\n     * @param tokenKey Token identifier key\n     * @param token Token contract address\n     * @param spender Spender address\n     * @param expiration Expiration timestamp\n     */\n    function _validateApproval(\n        address owner,\n        bytes32 tokenKey,\n        address token,\n        address spender,\n        uint48 expiration\n    ) internal view {\n        // Check if allowance is locked\n        if (allowances[owner][tokenKey][spender].expiration == LOCKED_ALLOWANCE) {\n            revert AllowanceLocked(owner, tokenKey, spender);\n        }\n\n        // Validate parameters\n        if (token == address(0)) {\n            revert ZeroToken();\n        }\n        if (spender == address(0)) {\n            revert ZeroSpender();\n        }\n        if (expiration != 0 && expiration <= block.timestamp) {\n            revert InvalidExpiration(expiration);\n        }\n    }\n\n    /**\n     * @notice Direct allowance approval without signature\n     * @dev Alternative to permit() for simple approvals\n     * @param token ERC20 token address\n     * @param spender Address to approve\n     * @param amount Approval amount\n     * @param expiration Optional expiration timestamp\n     */\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external override {\n        bytes32 tokenKey = bytes32(uint256(uint160(token)));\n        _validateApproval(msg.sender, tokenKey, token, spender, expiration);\n\n        allowances[msg.sender][tokenKey][spender] =\n            Allowance({ amount: amount, expiration: expiration, timestamp: uint48(block.timestamp) });\n\n        emit Approval(msg.sender, token, spender, amount, expiration);\n    }\n\n    /**\n     * @notice Execute approved token transfer\n     * @dev Checks allowance and expiration before transfer using _updateAllowance helper\n     * @param from Token owner address\n     * @param to Transfer recipient address\n     * @param amount Transfer amount (max 2^160-1)\n     * @param token ERC20 token contract address\n     */\n    function transferFrom(address from, address to, uint160 amount, address token) public {\n        bytes32 tokenKey = bytes32(uint256(uint160(token)));\n        (, bytes memory revertData) = _updateAllowance(from, tokenKey, msg.sender, amount);\n        if (revertData.length > 0) {\n            _revert(revertData);\n        }\n        _transferFrom(from, to, amount, token);\n    }\n\n    /**\n     * @notice Execute multiple approved transfers\n     * @dev Batch version of transferFrom()\n     * @param transfers Array of transfer instructions\n     */\n    function transferFrom(\n        AllowanceTransferDetails[] calldata transfers\n    ) external {\n        uint256 transfersLength = transfers.length;\n        if (transfersLength == 0) {\n            revert EmptyArray();\n        }\n\n        for (uint256 i = 0; i < transfersLength; i++) {\n            transferFrom(transfers[i].from, transfers[i].to, transfers[i].amount, transfers[i].token);\n        }\n    }\n\n    /**\n     * @notice Revoke multiple token approvals\n     * @dev Emergency function to quickly remove permissions\n     * @param approvals Array of token-spender pairs to revoke\n     */\n    function lockdown(\n        TokenSpenderPair[] calldata approvals\n    ) external {\n        uint256 approvalsLength = approvals.length;\n        if (approvalsLength == 0) {\n            revert EmptyArray();\n        }\n\n        for (uint256 i = 0; i < approvalsLength; i++) {\n            address token = approvals[i].token;\n            address spender = approvals[i].spender;\n\n            if (token == address(0)) {\n                revert ZeroToken();\n            }\n            if (spender == address(0)) {\n                revert ZeroSpender();\n            }\n\n            bytes32 tokenKey = bytes32(uint256(uint160(token)));\n            allowances[msg.sender][tokenKey][spender] =\n                Allowance({ amount: 0, expiration: LOCKED_ALLOWANCE, timestamp: uint48(block.timestamp) });\n\n            emit Lockdown(msg.sender, token, spender);\n        }\n    }\n\n    /**\n     * @dev Internal helper function to revert with custom error data\n     * @dev Uses inline assembly to revert with the exact error from revertData\n     * @param revertData The ABI-encoded error data to revert with\n     */\n    function _revert(\n        bytes memory revertData\n    ) internal pure {\n        assembly {\n            revert(add(32, revertData), mload(revertData))\n        }\n    }\n\n    /**\n     * @notice Updates allowance after checking validity and sufficiency\n     * @dev Internal helper that validates lock status, expiration, and sufficient balance\n     * @dev Returns error data instead of reverting to allow fallback mechanisms\n     * @param from Token owner address\n     * @param tokenKey Bytes32 token key for allowance mapping\n     * @param spender Approved spender address\n     * @param amount Amount to deduct from allowance\n     * @return allowed Updated allowance struct after deduction\n     * @return revertData Encoded error data if validation fails, empty bytes if successful\n     */\n    function _updateAllowance(\n        address from,\n        bytes32 tokenKey,\n        address spender,\n        uint160 amount\n    ) internal returns (Allowance memory allowed, bytes memory revertData) {\n        allowed = allowances[from][tokenKey][spender];\n\n        if (allowed.expiration == LOCKED_ALLOWANCE) {\n            revertData = abi.encodeWithSelector(AllowanceLocked.selector, from, tokenKey, spender);\n            return (allowed, revertData);\n        }\n\n        if (allowed.expiration != 0 && block.timestamp > allowed.expiration) {\n            revertData = abi.encodeWithSelector(AllowanceExpired.selector, allowed.expiration);\n            return (allowed, revertData);\n        }\n\n        if (allowed.amount == MAX_ALLOWANCE) {\n            return (allowed, revertData);\n        }\n\n        if (allowed.amount < amount) {\n            revertData = abi.encodeWithSelector(InsufficientAllowance.selector, amount, allowed.amount);\n            return (allowed, revertData);\n        }\n        /**\n         * @dev SAFETY: This unchecked block is safe from underflow because:\n         * 1. The require statement immediately above guarantees that allowed.amount >= amount\n         * 2. When subtracting amount from allowed.amount, the result will always be >= 0\n         * 3. Both allowed.amount and amount are uint160 types, ensuring type consistency\n         * 4. The subtraction can never underflow since we've verified the allowance is sufficient\n         *\n         * This optimization saves gas by avoiding redundant underflow checks that Solidity\n         * would normally perform, since we've already validated the operation will succeed.\n         */\n        unchecked {\n            allowed.amount -= amount;\n        }\n\n        allowances[from][tokenKey][spender] = allowed;\n    }\n\n    /**\n     * @dev Execute ERC20 token transfer with safety checks using SafeERC20\n     * @dev Uses SafeERC20.safeTransferFrom to handle non-standard token implementations\n     * @param from Token sender address that must have approved this contract\n     * @param to Token recipient address that will receive the tokens\n     * @param amount Transfer amount in token units (max uint160)\n     * @param token ERC20 token contract address to transfer\n     * @notice This function handles tokens that don't return boolean values or return false on failure\n     * @notice Assumes the caller has already verified allowances and will revert on transfer failure\n     */\n    function _transferFrom(address from, address to, uint160 amount, address token) internal {\n        IERC20(token).safeTransferFrom(from, to, amount);\n    }\n}\n"
    }
}