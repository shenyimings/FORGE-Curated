{
    "vfp_id": "vfp_00435",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary typecasts to payable",
            "description": "The codebase performs unnecessary typecasts to payable when casting addresses to the ISafe interface, such as ISafe(payable(msg.sender)). These casts are redundant because the ISafe interface does not require payable addressing, and the conversion adds no functional benefit. The root cause is a misunderstanding of Solidity's type system and interface casting rules. While this does not introduce a security vulnerability, it reduces code clarity and may confuse developers about the intended usage. The impact is informational, as it pertains to code quality rather than security. The issue was later resolved by introducing an inheritance relationship that made the casts semantically meaningful.\n",
            "severity": "Informational",
            "location": [
                "**/*.sol"
            ],
            "files": [
                "safe-smart-account/contracts/interfaces/ISafe.sol"
            ]
        }
    ],
    "affected_files": {
        "ISafe.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"./../libraries/Enum.sol\";\nimport {IFallbackManager} from \"./IFallbackManager.sol\";\nimport {IGuardManager} from \"./IGuardManager.sol\";\nimport {IModuleManager} from \"./IModuleManager.sol\";\nimport {IOwnerManager} from \"./IOwnerManager.sol\";\n\n/**\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\n * @author @safe-global/safe-protocol\n */\ninterface ISafe is IModuleManager, IGuardManager, IOwnerManager, IFallbackManager {\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\n\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     * @dev This method can only be called once.\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     * @param to Contract address for optional delegate call.\n     * @param data Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\n     * @param payment Value that should be paid\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall} transaction to `to` with `value` (Native Currency)\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\n     * @dev The fees are always transferred, even if the user transaction fails.\n     *      This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      - if the `gasToken` is a contract or not\n     *      It is the responsibility of the caller to perform such checks.\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param safeTxGas Gas that should be used for the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash and executor. Reverts otherwise.\n     * @param executor Address that executes the transaction.\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(address executor, bytes32 dataHash, bytes memory signatures) external view;\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\n     * @param executor Address that executes the transaction.\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\n\n    /**\n     * @notice Marks hash `hashToApprove` as approved.\n     * @dev This can be used with a pre-approved hash transaction signature.\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external;\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Gas that should be used for the safe transaction.\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n\n    /**\n     * External getter function for state variables.\n     */\n\n    /**\n     * @notice Returns the version of the Safe contract.\n     * @return Version string.\n     */\n    // solhint-disable-next-line\n    function VERSION() external view returns (string memory);\n\n    /**\n     * @notice Returns the nonce of the Safe contract.\n     * @return Nonce.\n     */\n    function nonce() external view returns (uint256);\n\n    /**\n     * @notice Returns a uint if the messageHash is signed by the owner.\n     * @param messageHash Hash of message that should be checked.\n     * @return Number denoting if an owner signed the hash.\n     */\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\n\n    /**\n     * @notice Returns a uint if the messageHash is approved by the owner.\n     * @param owner Owner address that should be checked.\n     * @param messageHash Hash of message that should be checked.\n     * @return Number denoting if an owner approved the hash.\n     */\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\n}\n"
    }
}