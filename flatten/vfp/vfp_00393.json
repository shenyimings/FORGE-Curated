{
    "vfp_id": "vfp_00393",
    "project_name": "cantina_coinbase_flywheel_sep2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ]
            },
            "title": "InvalidCode error uses empty value for toCode() function",
            "description": "The InvalidCode error is triggered when converting a tokenId to a code using normalizeSmallString, which may return a value differing from the direct bytes32 cast—likely due to case differences. The root cause is the ambiguity in error signaling: the error implies the output (code) is invalid, rather than clearly indicating the input (tokenId) is invalid. An attacker cannot directly exploit this, but it creates confusion during debugging and error handling. The impact is low, as it does not lead to fund loss or control issues, but it reduces code clarity and user experience.\n",
            "severity": "Low",
            "location": [
                "BuilderCodes.sol#L292-L296"
            ],
            "files": [
                "flywheel/src/BuilderCodes.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Buyers of BuilderCodes tokens might lose payouts due to missing updating payout address",
            "description": "The updatePayoutAddress() function allows a token owner to set the address for receiving payouts. However, upon token transfer, the payout address is not automatically updated to the new owner. The cause is the lack of integration between token transfer logic and payout address management. An attacker could not directly exploit this, but a new owner who fails to update the payout address risks having rewards sent to the previous owner. The impact is potential loss of payouts for legitimate owners, though the risk is mitigated by user action.\n",
            "severity": "Low",
            "location": [
                "BuilderCodes.sol#L178"
            ],
            "files": [
                "flywheel/src/BuilderCodes.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-340"
                ],
                "4": [
                    "CWE-341"
                ]
            },
            "title": "createCampaign() is front-runnable which might cause confusion for callers and potentially lost funds",
            "description": "The createCampaign() function uses CREATE2 with a salt that does not include msg.sender, making the deployment deterministic and susceptible to front-running. The root cause is the predictable salt, allowing an attacker to replicate the salt and deploy the contract first. Exploitation involves submitting a transaction with the same salt, causing the victim's transaction to revert. This can lead to confusion, failed dependent transactions, or perceived loss of funds if pre-funded addresses are used. The impact is moderate user disruption and potential DoS-like behavior, though no direct theft occurs.\n",
            "severity": "Low",
            "location": [
                "Flywheel.sol#L241"
            ],
            "files": [
                "flywheel/src/Flywheel.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Non-existent builder codes can prevent users from receiving bridged funds immediately",
            "description": "If an incorrect builder code is used during bridging, the transaction reverts, and user funds remain locked in the bridge. The cause is strict validation of builder codes without fallback handling. While not directly exploitable for gain, it creates a poor user experience where user error leads to fund immobilization. The impact is temporary fund loss from the user's perspective, requiring operator intervention to resolve.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "flywheel/src/BuilderCodes.sol",
                "flywheel/src/Flywheel.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unnecessary call to hook contracts when updating metadata",
            "description": "The Flywheel contract makes an extra external call to retrieve the updated URI after calling onUpdateMetadata(), even though the hook could return it directly. The cause is inefficient design in the metadata update flow. This does not pose a security risk but increases gas costs unnecessarily. The impact is higher transaction costs for users, with no direct financial loss but reduced efficiency.\n",
            "severity": "Informational",
            "location": [
                "Flywheel.sol#L448-L449"
            ],
            "files": [
                "flywheel/src/Flywheel.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused imports",
            "description": "The contracts CashbackRewards.sol and Flywheel.sol contain unused imports (CampaignHooks and SafeERC20, respectively). The cause is leftover or unnecessary import statements. This does not introduce security vulnerabilities but increases contract size and deployment cost. The impact is minor, limited to higher gas usage during deployment, but represents a code hygiene issue.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "flywheel/src/hooks/CashbackRewards.sol",
                "flywheel/src/Flywheel.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "_onCreateCampaign does not check existence before overwriting",
            "description": "The _onCreateCampaign function in hook contracts (e.g., CashbackRewards) does not verify if a campaign is already registered before overwriting its data. The cause is missing validation logic. Although Flywheel generates unique addresses, future versions or integrations might reuse addresses, leading to silent data corruption. The impact is potential loss of campaign state in edge cases, especially if multiple Flywheel instances interact with the same hook.\n",
            "severity": "Informational",
            "location": [
                "CashbackRewards.sol#L91-L99"
            ],
            "files": [
                "flywheel/src/hooks/CashbackRewards.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-331"
                ],
                "4": [
                    "CWE-332"
                ]
            },
            "title": "Edge case for referral code mismatch in case of reorgs",
            "description": "Referral codes generated by PseudoRandomRegistrar depend on block context (timestamp, prevrandao, block hash), which can be identical across reorged blocks, especially on chains like Arbitrum. If transaction order changes during a reorg, users may receive swapped referral codes. The cause is insufficient entropy in code generation. The impact is low—a rare edge case—but could lead to incorrect attribution and user confusion.\n",
            "severity": "Informational",
            "location": [
                "PseudoRandomRegistrar.sol#L57-L59"
            ],
            "files": [
                "flywheel/src/registrars/PseudoRandomRegistrar.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "BuilderCodes.updateMetadata: Missing tokenId existence check",
            "description": "The updateMetadata function emits a MetadataUpdate event without verifying that the tokenId exists or is owned by the caller. The cause is missing _requireOwned(tokenId) check. This allows events to be emitted for non-existent or future tokens, potentially misleading off-chain indexers. The impact is data inconsistency in event-based systems, though no direct fund loss occurs.\n",
            "severity": "Informational",
            "location": [
                "BuilderCodes.sol#L160-L162"
            ],
            "files": [
                "flywheel/src/BuilderCodes.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Out-of-order alphanumeric characters",
            "description": "The constant ALLOWED_CHARACTERS in BuilderCodes.sol and ALPHANUMERIC in PseudoRandomRegistrar.sol contain misplaced 'n' and 'o', resulting in \"monpqrstuvwxyz\" instead of \"nopqrstuvwxyz\". The cause is a typographical error. This leads to incorrect character sets being used in code generation, potentially reducing entropy or causing unexpected behavior. The impact is functional correctness and security of generated codes, though likely limited in practice.\n",
            "severity": "Informational",
            "location": [
                "BuilderCodes.sol#L47",
                "PseudoRandomRegistrar.sol#L16"
            ],
            "files": [
                "flywheel/src/BuilderCodes.sol",
                "flywheel/src/registrars/PseudoRandomRegistrar.sol"
            ]
        }
    ],
    "affected_files": {
        "BuilderCodes.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\n\n/// @notice Registry for builder codes\n///\n/// @author Coinbase\ncontract BuilderCodes is\n    Initializable,\n    ERC721Upgradeable,\n    AccessControlUpgradeable,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    EIP712,\n    IERC4906\n{\n    /// @notice EIP-712 storage structure for registry data\n    /// @custom:storage-location erc7201:base.flywheel.BuilderCodes\n    struct RegistryStorage {\n        /// @notice Base URI for referral code metadata\n        string uriPrefix;\n        /// @dev Mapping of referral code token IDs to payout recipients\n        mapping(uint256 tokenId => address payoutAddress) payoutAddresses;\n    }\n\n    /// @notice Role identifier for addresses authorized to call register or sign registrations\n    bytes32 public constant REGISTER_ROLE = keccak256(\"REGISTER_ROLE\");\n\n    /// @notice Role identifier for addresses authorized to update metadata for one or all codes\n    bytes32 public constant METADATA_ROLE = keccak256(\"METADATA_ROLE\");\n\n    /// @notice EIP-712 typehash for registration\n    bytes32 public constant REGISTRATION_TYPEHASH =\n        keccak256(\"BuilderCodeRegistration(string code,address initialOwner,address payoutAddress,uint48 deadline)\");\n\n    /// @notice Allowed characters for referral codes\n    string public constant ALLOWED_CHARACTERS = \"0123456789abcdefghijklmonpqrstuvwxyz_\";\n\n    /// @notice Allowed characters for referral codes lookup\n    /// @dev LibString.to7BitASCIIAllowedLookup(ALLOWED_CHARACTERS)\n    uint128 public constant ALLOWED_CHARACTERS_LOOKUP = 10633823847437083212121898993101832192;\n\n    /// @notice EIP-1967 storage slot base for registry mapping using ERC-7201\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"base.flywheel.BuilderCodes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REGISTRY_STORAGE_LOCATION =\n        0xe3aaf266708e5133bd922e269bb5e8f72a7444c3b231cbf562ddc67a383e5700;\n\n    /// @notice Emitted when a referral code is registered\n    ///\n    /// @param tokenId Token ID of the referral code\n    /// @param code Referral code\n    event CodeRegistered(uint256 indexed tokenId, string code);\n\n    /// @notice Emitted when a publisher's default payout address is updated\n    ///\n    /// @param tokenId Token ID of the referral code\n    /// @param payoutAddress New default payout address for all chains\n    event PayoutAddressUpdated(uint256 indexed tokenId, address payoutAddress);\n\n    /// @notice Emits when the contract URI is updated (ERC-7572)\n    event ContractURIUpdated();\n\n    /// @notice Thrown when call doesn't have required permissions\n    error Unauthorized();\n\n    /// @notice Thrown when provided address is invalid (usually zero address)\n    error ZeroAddress();\n\n    /// @notice Thrown when signed registration deadline has passed\n    error AfterRegistrationDeadline(uint48 deadline);\n\n    /// @notice Thrown when builder code is invalid\n    error InvalidCode(string code);\n\n    /// @notice Thrown when builder code is not registered\n    error Unregistered(string code);\n\n    /// @notice Thrown when trying to renounce ownership (disabled for security)\n    error OwnershipRenunciationDisabled();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract (replaces constructor)\n    ///\n    /// @param initialOwner Address that will own the contract\n    /// @param initialRegistrar Address to grant REGISTER_ROLE (can be address(0) to skip)\n    function initialize(address initialOwner, address initialRegistrar, string memory uriPrefix) external initializer {\n        if (initialOwner == address(0)) revert ZeroAddress();\n\n        __AccessControl_init();\n        __ERC721_init(\"Builder Codes\", \"BUILDERCODE\");\n        __Ownable2Step_init();\n        _transferOwnership(initialOwner);\n        __UUPSUpgradeable_init();\n        _getRegistryStorage().uriPrefix = uriPrefix;\n\n        if (initialRegistrar != address(0)) _grantRole(REGISTER_ROLE, initialRegistrar);\n    }\n\n    /// @notice Registers a new referral code in the system with a custom value\n    ///\n    /// @param code Custom builder code for the builder code\n    /// @param initialOwner Owner of the builder code\n    /// @param payoutAddress Default payout address for all chains\n    function register(string memory code, address initialOwner, address payoutAddress)\n        external\n        onlyRole(REGISTER_ROLE)\n    {\n        _register(code, initialOwner, payoutAddress);\n    }\n\n    /// @notice Registers a new referral code in the system with a signature\n    ///\n    /// @param code Custom builder code for the builder code\n    /// @param initialOwner Owner of the builder code\n    /// @param payoutAddress Default payout address for all chains\n    /// @param deadline Deadline to submit the registration\n    /// @param registrar Address of the registrar\n    /// @param signature Signature of the registrar\n    function registerWithSignature(\n        string memory code,\n        address initialOwner,\n        address payoutAddress,\n        uint48 deadline,\n        address registrar,\n        bytes memory signature\n    ) external {\n        // Check deadline has not passed\n        if (block.timestamp > deadline) revert AfterRegistrationDeadline(deadline);\n\n        // Check registrar has role\n        _checkRole(REGISTER_ROLE, registrar);\n\n        // Check signature is valid\n        bytes32 structHash =\n            keccak256(abi.encode(REGISTRATION_TYPEHASH, keccak256(bytes(code)), initialOwner, payoutAddress, deadline));\n        if (!SignatureCheckerLib.isValidSignatureNow(registrar, _hashTypedData(structHash), signature)) {\n            revert Unauthorized();\n        }\n\n        _register(code, initialOwner, payoutAddress);\n    }\n\n    /// @notice Updates the metadata for a builder code\n    ///\n    /// @param tokenId Token ID of the builder code\n    function updateMetadata(uint256 tokenId) external onlyRole(METADATA_ROLE) {\n        emit MetadataUpdate(tokenId);\n    }\n\n    /// @notice Updates the base URI for the builder codes\n    ///\n    /// @param uriPrefix New base URI for the builder codes\n    function updateBaseURI(string memory uriPrefix) external onlyRole(METADATA_ROLE) {\n        _getRegistryStorage().uriPrefix = uriPrefix;\n        emit BatchMetadataUpdate(0, type(uint256).max);\n        emit ContractURIUpdated();\n    }\n\n    /// @notice Updates the default payout address for a referral code\n    ///\n    /// @param code Builder code\n    /// @param payoutAddress New default payout address\n    /// @dev Only callable by referral code owner\n    function updatePayoutAddress(string memory code, address payoutAddress) external {\n        uint256 tokenId = toTokenId(code);\n        if (_requireOwned(tokenId) != msg.sender) revert Unauthorized();\n        _updatePayoutAddress(tokenId, payoutAddress);\n    }\n\n    /// @notice Gets the default payout address for a referral code\n    ///\n    /// @param code Builder code\n    ///\n    /// @return The default payout address\n    function payoutAddress(string memory code) external view returns (address) {\n        uint256 tokenId = toTokenId(code);\n        if (_ownerOf(tokenId) == address(0)) revert Unregistered(code);\n        return _getRegistryStorage().payoutAddresses[tokenId];\n    }\n\n    /// @notice Gets the default payout address for a referral code\n    ///\n    /// @param tokenId Token ID of the referral code\n    ///\n    /// @return The default payout address\n    function payoutAddress(uint256 tokenId) external view returns (address) {\n        if (_ownerOf(tokenId) == address(0)) revert Unregistered(toCode(tokenId));\n        return _getRegistryStorage().payoutAddresses[tokenId];\n    }\n\n    /// @notice Returns the URI for a referral code\n    ///\n    /// @param code Builder code\n    ///\n    /// @return The URI for the referral code\n    function codeURI(string memory code) external view returns (string memory) {\n        return tokenURI(toTokenId(code));\n    }\n\n    /// @notice Returns the URI for the contract\n    ///\n    /// @return The URI for the contract\n    function contractURI() external view returns (string memory) {\n        string memory uriPrefix = _getRegistryStorage().uriPrefix;\n        return bytes(uriPrefix).length > 0 ? string.concat(uriPrefix, \"contractURI.json\") : \"\";\n    }\n\n    /// @notice Returns the URI for a referral code\n    ///\n    /// @param tokenId Token ID of the referral code\n    ///\n    /// @return uri The URI for the referral code\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireOwned(tokenId);\n        string memory uriPrefix = _getRegistryStorage().uriPrefix;\n        return bytes(uriPrefix).length > 0 ? string.concat(uriPrefix, toCode(tokenId)) : \"\";\n    }\n\n    /// @notice Checks if a referral code exists\n    ///\n    /// @param code Builder code to check\n    ///\n    /// @return True if the referral code exists\n    function isRegistered(string memory code) public view returns (bool) {\n        return _ownerOf(toTokenId(code)) != address(0);\n    }\n\n    /// @notice Checks if an address has a role\n    ///\n    /// @param role The role to check\n    /// @param account The address to check\n    ///\n    /// @return True if the address has the role\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return account == owner() || super.hasRole(role, account);\n    }\n\n    /// @inheritdoc ERC721Upgradeable\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable, IERC165)\n        returns (bool)\n    {\n        return ERC721Upgradeable.supportsInterface(interfaceId)\n            || AccessControlUpgradeable.supportsInterface(interfaceId) || interfaceId == bytes4(0x49064906);\n    }\n\n    /// @notice Checks if a referral code is valid\n    ///\n    /// @param code Builder code to check\n    ///\n    /// @return True if the referral code is valid\n    function isValidCode(string memory code) public pure returns (bool) {\n        // Early return invalid if code is zero or over 32 bytes/characters\n        uint256 length = bytes(code).length;\n        if (length == 0 || length > 32) return false;\n\n        // Return if code is 7-bit ASCII matching the allowed characters\n        return LibString.is7BitASCII(code, ALLOWED_CHARACTERS_LOOKUP);\n    }\n\n    /// @notice Converts a referral code to a token ID\n    ///\n    /// @param code Builder code to convert\n    ///\n    /// @return tokenId The token ID for the referral code\n    function toTokenId(string memory code) public pure returns (uint256 tokenId) {\n        if (!isValidCode(code)) revert InvalidCode(code);\n        return uint256(LibString.toSmallString(code));\n    }\n\n    /// @notice Converts a token ID to a referral code\n    ///\n    /// @param tokenId Token ID to convert\n    ///\n    /// @return code The referral code for the token ID\n    function toCode(uint256 tokenId) public pure returns (string memory code) {\n        if (bytes32(tokenId) != LibString.normalizeSmallString(bytes32(tokenId))) revert InvalidCode(code);\n        code = LibString.fromSmallString(bytes32(tokenId));\n        if (!isValidCode(code)) revert InvalidCode(code);\n        return code;\n    }\n\n    /// @notice Disabled to prevent accidental ownership renunciation\n    ///\n    /// @dev Overrides OpenZeppelin's renounceOwnership to prevent accidental calls\n    function renounceOwnership() public pure override {\n        revert OwnershipRenunciationDisabled();\n    }\n\n    /// @notice Registers a new referral code\n    ///\n    /// @param code Referral code\n    /// @param initialOwner Owner of the ref code\n    /// @param payoutAddress Default payout address for all chains\n    function _register(string memory code, address initialOwner, address payoutAddress) internal {\n        uint256 tokenId = toTokenId(code);\n        _mint(initialOwner, tokenId);\n        emit CodeRegistered(tokenId, code);\n        _updatePayoutAddress(tokenId, payoutAddress);\n    }\n\n    /// @notice Registers a new referral code\n    ///\n    /// @param tokenId Token ID of the referral code\n    /// @param payoutAddress Default payout address for all chains\n    function _updatePayoutAddress(uint256 tokenId, address payoutAddress) internal {\n        if (payoutAddress == address(0)) revert ZeroAddress();\n        _getRegistryStorage().payoutAddresses[tokenId] = payoutAddress;\n        emit PayoutAddressUpdated(tokenId, payoutAddress);\n    }\n\n    /// @notice Authorization for upgrades\n    ///\n    /// @param newImplementation Address of new implementation\n    function _authorizeUpgrade(address newImplementation) internal view override onlyOwner {}\n\n    /// @notice Returns the domain name and version for the referral codes\n    ///\n    /// @return name The domain name for the referral codes\n    /// @return version The version of the referral codes\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        name = \"Builder Codes\";\n        version = \"1\";\n    }\n\n    /// @notice Returns if the domain name and version may change\n    ///\n    /// @return True if the domain name and version may change\n    function _domainNameAndVersionMayChange() internal pure override returns (bool) {\n        return true;\n    }\n\n    /// @notice Gets the storage reference for the registry\n    ///\n    /// @return $ Storage reference for the registry\n    function _getRegistryStorage() private pure returns (RegistryStorage storage $) {\n        assembly {\n            $.slot := REGISTRY_STORAGE_LOCATION\n        }\n    }\n}\n",
        "CashbackRewards.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {AuthCaptureEscrow} from \"commerce-payments/AuthCaptureEscrow.sol\";\n\nimport {Flywheel} from \"../Flywheel.sol\";\nimport {CampaignHooks} from \"../CampaignHooks.sol\";\nimport {SimpleRewards} from \"./SimpleRewards.sol\";\n\n/// @title CashbackRewards\n///\n/// @notice Reward buyers for their purchases made with the Commerce Payments Protocol (https://github.com/base/commerce-payments)\n///\n/// @dev Rewards must be made in the same token as the original payment token (cashback)\n/// @dev Rewards can be made in any amount (supports %, fixed, etc.)\n/// @dev Maximum reward percentage can be optionally configured per campaign\n/// @dev Rewards can be made on any payment (supports custom filtering for platforms, wallets, merchants, etc.)\n///\n/// @author Coinbase\ncontract CashbackRewards is SimpleRewards {\n    /// @notice Operation types for reward validation\n    enum RewardOperation {\n        REWARD,\n        ALLOCATE,\n        DEALLOCATE,\n        DISTRIBUTE\n    }\n\n    /// @notice Tracks rewards info per payment per campaign\n    struct RewardState {\n        /// @dev Amount of reward allocated for this payment\n        uint120 allocated;\n        /// @dev Amount of reward distributed for this payment\n        uint120 distributed;\n    }\n\n    /// @notice A struct for a payment reward\n    struct PaymentReward {\n        /// @dev The payment to reward\n        AuthCaptureEscrow.PaymentInfo paymentInfo;\n        /// @dev The reward payout amount\n        uint120 payoutAmount;\n    }\n\n    /// @notice The divisor for max reward basis points (10_000 = 100%)\n    uint256 public constant BASIS_POINTS_100_PERCENT = 10_000;\n\n    /// @notice The escrow contract to track payment states and calculate payment hash\n    AuthCaptureEscrow public immutable escrow;\n\n    /// @notice Tracks an optional maximum reward percentage per campaign in basis points (10_000 = 100%)\n    mapping(address campaign => uint256 maxRewardBasisPoints) public maxRewardBasisPoints;\n\n    /// @notice Tracks rewards info per campaign per payment\n    mapping(address campaign => mapping(bytes32 paymentHash => RewardState rewardState)) public rewards;\n\n    /// @notice Emitted when a reward operation fails but revertOnError is false\n    ///\n    /// @param paymentInfoHash The attempted payment\n    /// @param amount The attempted reward amount\n    /// @param operation The attempted reward operation\n    /// @param error The error bytes\n    event RewardFailed(bytes32 indexed paymentInfoHash, uint256 amount, RewardOperation operation, bytes error);\n\n    /// @notice Thrown when the allocated amount is less than the amount being deallocated or distributed\n    error InsufficientAllocation(uint120 amount, uint120 allocated);\n\n    /// @notice Thrown when the payment amount is invalid\n    error ZeroPayoutAmount();\n\n    /// @notice Thrown when the payment token does not match the campaign token\n    error TokenMismatch();\n\n    /// @notice Thrown when the payment has not been collected\n    error PaymentNotCollected();\n\n    /// @notice Thrown when the reward amount exceeds the maximum allowed percentage\n    error RewardExceedsMaxPercentage(\n        bytes32 paymentInfoHash, uint120 maxAllowedRewardAmount, uint120 excessRewardAmount\n    );\n\n    /// @notice Constructor\n    ///\n    /// @param flywheel_ The Flywheel core protocol contract address\n    /// @param escrow_ The AuthCaptureEscrow contract address\n    constructor(address flywheel_, address escrow_) SimpleRewards(flywheel_) {\n        escrow = AuthCaptureEscrow(escrow_);\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onCreateCampaign(address campaign, uint256 nonce, bytes calldata hookData) internal override {\n        (address owner, address manager, string memory uri, uint16 maxRewardBasisPoints_) =\n            abi.decode(hookData, (address, address, string, uint16));\n        owners[campaign] = owner;\n        managers[campaign] = manager;\n        campaignURI[campaign] = uri;\n        maxRewardBasisPoints[campaign] = uint256(maxRewardBasisPoints_);\n        emit CampaignCreated(campaign, owner, manager, uri);\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onSend(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        onlyManager(sender, campaign)\n        returns (\n            Flywheel.Payout[] memory payouts,\n            Flywheel.Payout[] memory immediateFees,\n            Flywheel.Allocation[] memory delayedFees\n        )\n    {\n        (PaymentReward[] memory paymentRewards, bool revertOnError) = abi.decode(hookData, (PaymentReward[], bool));\n        (uint256 inputLen, uint256 outputLen) = (paymentRewards.length, 0);\n        payouts = new Flywheel.Payout[](inputLen);\n\n        for (uint256 i = 0; i < inputLen; i++) {\n            // Validate the payment reward\n            (bytes32 paymentInfoHash, uint120 amount, address payer, bytes memory err) =\n                _validatePaymentReward(paymentRewards[i], campaign, token, RewardOperation.REWARD);\n\n            // Skip this reward if there was a non-reverted error\n            if (err.length > 0) {\n                _revertOrEmitError(revertOnError, paymentInfoHash, amount, RewardOperation.REWARD, err);\n                continue;\n            }\n\n            // Add the payout amount to the distributed amount\n            rewards[campaign][paymentInfoHash].distributed += amount;\n\n            // Append to return array\n            payouts[outputLen++] =\n                Flywheel.Payout({recipient: payer, amount: amount, extraData: abi.encodePacked(paymentInfoHash)});\n        }\n\n        // Resize array to actual output length\n        assembly {\n            mstore(payouts, outputLen)\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onAllocate(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        onlyManager(sender, campaign)\n        returns (Flywheel.Allocation[] memory allocations)\n    {\n        (PaymentReward[] memory paymentRewards, bool revertOnError) = abi.decode(hookData, (PaymentReward[], bool));\n        (uint256 inputLen, uint256 outputLen) = (paymentRewards.length, 0);\n        allocations = new Flywheel.Allocation[](inputLen);\n\n        for (uint256 i = 0; i < inputLen; i++) {\n            // Validate the payment reward\n            (bytes32 paymentInfoHash, uint120 amount, address payer, bytes memory err) =\n                _validatePaymentReward(paymentRewards[i], campaign, token, RewardOperation.ALLOCATE);\n\n            // Skip this reward if there was a non-reverted error\n            if (err.length > 0) {\n                _revertOrEmitError(revertOnError, paymentInfoHash, amount, RewardOperation.ALLOCATE, err);\n                continue;\n            }\n\n            // Add the payout amount to the allocated amount\n            rewards[campaign][paymentInfoHash].allocated += amount;\n\n            // Append to return array\n            allocations[outputLen++] = Flywheel.Allocation({\n                key: bytes32(bytes20(payer)),\n                amount: amount,\n                extraData: abi.encodePacked(paymentInfoHash)\n            });\n        }\n\n        // Resize array to actual output length\n        assembly {\n            mstore(allocations, outputLen)\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onDeallocate(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        onlyManager(sender, campaign)\n        returns (Flywheel.Allocation[] memory allocations)\n    {\n        (PaymentReward[] memory paymentRewards, bool revertOnError) = abi.decode(hookData, (PaymentReward[], bool));\n        (uint256 inputLen, uint256 outputLen) = (paymentRewards.length, 0);\n        allocations = new Flywheel.Allocation[](inputLen);\n\n        for (uint256 i = 0; i < inputLen; i++) {\n            // Validate the payment reward\n            (bytes32 paymentInfoHash, uint120 amount, address payer, bytes memory err) =\n                _validatePaymentReward(paymentRewards[i], campaign, token, RewardOperation.DEALLOCATE);\n\n            // Skip this reward if there was a non-reverted error\n            if (err.length > 0) {\n                _revertOrEmitError(revertOnError, paymentInfoHash, amount, RewardOperation.DEALLOCATE, err);\n                continue;\n            }\n\n            // Determine correct deallocation amount (special case of max uint120 means deallocate all allocated)\n            uint120 allocated = rewards[campaign][paymentInfoHash].allocated;\n            if (amount == type(uint120).max) amount = allocated;\n\n            // Check sufficient allocation\n            if (allocated < amount) revert InsufficientAllocation(amount, allocated);\n\n            // Decrease allocated amount for payment\n            rewards[campaign][paymentInfoHash].allocated = allocated - amount;\n\n            // Append to return array\n            allocations[outputLen++] = Flywheel.Allocation({\n                key: bytes32(bytes20(payer)),\n                amount: amount,\n                extraData: abi.encodePacked(paymentInfoHash)\n            });\n        }\n\n        // Resize array to actual output length\n        assembly {\n            mstore(allocations, outputLen)\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onDistribute(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        onlyManager(sender, campaign)\n        returns (\n            Flywheel.Distribution[] memory distributions,\n            Flywheel.Payout[] memory immediateFees,\n            Flywheel.Allocation[] memory delayedFees\n        )\n    {\n        (PaymentReward[] memory paymentRewards, bool revertOnError) = abi.decode(hookData, (PaymentReward[], bool));\n        (uint256 inputLen, uint256 outputLen) = (paymentRewards.length, 0);\n        distributions = new Flywheel.Distribution[](inputLen);\n\n        for (uint256 i = 0; i < inputLen; i++) {\n            // Validate the payment reward\n            (bytes32 paymentInfoHash, uint120 amount, address payer, bytes memory err) =\n                _validatePaymentReward(paymentRewards[i], campaign, token, RewardOperation.DISTRIBUTE);\n\n            // Skip this reward if there was a non-reverted error\n            if (err.length > 0) {\n                _revertOrEmitError(revertOnError, paymentInfoHash, amount, RewardOperation.DISTRIBUTE, err);\n                continue;\n            }\n\n            // Check sufficient allocation\n            uint120 allocated = rewards[campaign][paymentInfoHash].allocated;\n            if (allocated < amount) revert InsufficientAllocation(amount, allocated);\n\n            // Shift the payout amount from allocated to distributed\n            rewards[campaign][paymentInfoHash].allocated = allocated - amount;\n            rewards[campaign][paymentInfoHash].distributed += amount;\n\n            // Append to return array\n            distributions[outputLen++] = Flywheel.Distribution({\n                recipient: payer,\n                key: bytes32(bytes20(payer)),\n                amount: amount,\n                extraData: abi.encodePacked(paymentInfoHash)\n            });\n        }\n\n        // Resize array to actual output length\n        assembly {\n            mstore(distributions, outputLen)\n        }\n    }\n\n    /// @notice Handles error with either a revert or event emission.\n    ///\n    /// @param err The error bytes to revert with or emit\n    /// @param revertOnError Whether to revert on error or emit RewardFailed event\n    /// @param paymentInfoHash The payment info hash for the failed reward\n    /// @param amount The payout amount that failed\n    /// @param operation The RewardOperation type\n    function _revertOrEmitError(\n        bool revertOnError,\n        bytes32 paymentInfoHash,\n        uint256 amount,\n        RewardOperation operation,\n        bytes memory err\n    ) internal {\n        if (revertOnError) {\n            assembly {\n                revert(add(err, 0x20), mload(err))\n            }\n        } else {\n            emit RewardFailed(paymentInfoHash, amount, operation, err);\n        }\n    }\n\n    /// @dev Validates a payment reward and returns the payment info hash\n    ///\n    /// @param paymentReward The payment reward\n    /// @param campaign The campaign address\n    /// @param token The campaign token\n    /// @param operation The type of operation being performed\n    function _validatePaymentReward(\n        PaymentReward memory paymentReward,\n        address campaign,\n        address token,\n        RewardOperation operation\n    ) internal view returns (bytes32 paymentInfoHash, uint120 amount, address payer, bytes memory err) {\n        (paymentInfoHash, amount, payer) =\n            (escrow.getHash(paymentReward.paymentInfo), paymentReward.payoutAmount, paymentReward.paymentInfo.payer);\n\n        // Check reward amount non-zero\n        if (amount == 0) {\n            return (paymentInfoHash, amount, payer, abi.encodeWithSelector(ZeroPayoutAmount.selector));\n        }\n\n        // Check the token matches the payment token\n        if (paymentReward.paymentInfo.token != token) {\n            return (paymentInfoHash, amount, payer, abi.encodeWithSelector(TokenMismatch.selector));\n        }\n\n        // Check payment has been collected\n        (bool hasCollectedPayment, uint120 capturableAmount, uint120 refundableAmount) =\n            escrow.paymentState(paymentInfoHash);\n        if (!hasCollectedPayment) {\n            return (paymentInfoHash, amount, payer, abi.encodeWithSelector(PaymentNotCollected.selector));\n        }\n\n        // Early return if deallocating, skips percentage validation\n        if (operation == RewardOperation.DEALLOCATE) return (paymentInfoHash, amount, payer, \"\");\n\n        // Early return if no max reward percentage is configured\n        uint256 maxRewardBps = maxRewardBasisPoints[campaign];\n        if (maxRewardBps == 0) return (paymentInfoHash, amount, payer, \"\");\n\n        // Payment amount is the captured amount that has not been refunded i.e. \"refundable\" amount\n        uint120 paymentAmount = refundableAmount;\n        uint120 previouslyRewardedAmount = rewards[campaign][paymentInfoHash].distributed;\n\n        // If allocating, add the pre-capture and pre-distribution amounts too to prevent allocating more than the max allowed reward for this payment\n        if (operation == RewardOperation.ALLOCATE) {\n            paymentAmount += capturableAmount;\n            previouslyRewardedAmount += rewards[campaign][paymentInfoHash].allocated;\n        }\n\n        // Check total reward amount doesn't exceed the max allowed reward for this payment\n        uint120 totalRewardAmount = previouslyRewardedAmount + amount;\n        uint120 maxAllowedRewardAmount = uint120(paymentAmount * maxRewardBps / BASIS_POINTS_100_PERCENT);\n        if (totalRewardAmount > maxAllowedRewardAmount) {\n            err = abi.encodeWithSelector(\n                RewardExceedsMaxPercentage.selector,\n                paymentInfoHash,\n                maxAllowedRewardAmount,\n                totalRewardAmount - maxAllowedRewardAmount\n            );\n        }\n        return (paymentInfoHash, amount, payer, err);\n    }\n}\n",
        "Flywheel.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardTransient} from \"solady/utils/ReentrancyGuardTransient.sol\";\n\nimport {Campaign} from \"./Campaign.sol\";\nimport {CampaignHooks} from \"./CampaignHooks.sol\";\n\n/// @title Flywheel\n///\n/// @notice Main contract for managing advertising campaigns and attribution\n///\n/// @dev Structures campaign metadata, lifecycle, payouts, and fees\ncontract Flywheel is ReentrancyGuardTransient {\n    /// @notice Possible states a campaign can be in\n    enum CampaignStatus {\n        /// @dev Campaign is not yet live, default on creation\n        INACTIVE,\n        /// @dev Campaign is live and can process payouts\n        ACTIVE,\n        /// @dev Campaign is no longer live but can still process lagging payouts, can only update status to finalized\n        FINALIZING,\n        /// @dev Campaign is no longer live and no more payouts can be processed, cannot update status\n        FINALIZED\n    }\n\n    /// @notice Campaign information structure\n    struct CampaignInfo {\n        /// @dev status Current status of the campaign\n        CampaignStatus status;\n        /// @dev hooks Address of the campaign hooks contract\n        CampaignHooks hooks;\n    }\n\n    /// @notice Payout for a recipient\n    struct Payout {\n        /// @dev recipient Address receiving the payout\n        address recipient;\n        /// @dev amount Amount of tokens to be paid out\n        uint256 amount;\n        /// @dev extraData Extra data for the payout to attach in events\n        bytes extraData;\n    }\n\n    /// @notice Allocation for a key\n    struct Allocation {\n        /// @dev key Key for the allocation\n        bytes32 key;\n        /// @dev amount Amount of tokens to be paid out\n        uint256 amount;\n        /// @dev extraData Extra data to attach in events\n        bytes extraData;\n    }\n\n    /// @notice Distribution for a key to a recipient\n    struct Distribution {\n        /// @dev recipient Address receiving the distribution\n        address recipient;\n        /// @dev key Key for the allocation\n        bytes32 key;\n        /// @dev amount Amount of tokens to be paid out\n        uint256 amount;\n        /// @dev extraData Extra data to attach in events\n        bytes extraData;\n    }\n\n    /// @notice Implementation for Campaign contracts\n    address public immutable campaignImplementation;\n\n    /// @notice Allocated rewards that are pending distribution\n    mapping(address campaign => mapping(address token => mapping(bytes32 key => uint256 amount))) public allocatedPayout;\n\n    /// @notice Fees that are pending collection\n    mapping(address campaign => mapping(address token => mapping(bytes32 key => uint256 amount))) public allocatedFee;\n\n    /// @notice Total funds reserved for a campaign's allocations\n    mapping(address campaign => mapping(address token => uint256 amount)) public totalAllocatedPayouts;\n\n    /// @notice Total funds reserved for a campaign's fees\n    mapping(address campaign => mapping(address token => uint256 amount)) public totalAllocatedFees;\n\n    /// @notice Campaign state\n    mapping(address campaign => CampaignInfo) internal _campaigns;\n\n    /// @notice Emitted when a new campaign is created\n    ///\n    /// @param campaign Address of the created campaign\n    /// @param hooks Address of the campaign hooks contract\n    event CampaignCreated(address indexed campaign, address hooks);\n\n    /// @notice Emitted when a campaign is updated\n    ///\n    /// @param campaign Address of the campaign\n    /// @param uri The URI for the campaign\n    event CampaignMetadataUpdated(address indexed campaign, string uri);\n\n    /// @notice Emitted when a campaign status is updated\n    ///\n    /// @param campaign Address of the campaign\n    /// @param sender Address that triggered the status change\n    /// @param oldStatus Previous status of the campaign\n    /// @param newStatus New status of the campaign\n    event CampaignStatusUpdated(\n        address indexed campaign, address sender, CampaignStatus oldStatus, CampaignStatus newStatus\n    );\n\n    /// @notice Emitted when a payout is sent to a recipient\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the payout token\n    /// @param recipient Address receiving the payout\n    /// @param amount Amount of tokens sent\n    /// @param extraData Extra data for the payout to attach in events\n    event PayoutSent(address indexed campaign, address token, address recipient, uint256 amount, bytes extraData);\n\n    /// @notice Emitted when a payout is allocated to a recipient\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the payout token\n    /// @param key Key for the allocation\n    /// @param amount Amount of tokens allocated\n    /// @param extraData Extra data for the payout to attach in events\n    event PayoutAllocated(address indexed campaign, address token, bytes32 key, uint256 amount, bytes extraData);\n\n    /// @notice Emitted when allocated payouts are distributed to a recipient\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the payout token\n    /// @param key Key for the allocation\n    /// @param recipient Address receiving the distribution\n    /// @param amount Amount of tokens distributed\n    /// @param extraData Extra data for the payout to attach in events\n    event PayoutsDistributed(\n        address indexed campaign, address token, bytes32 key, address recipient, uint256 amount, bytes extraData\n    );\n\n    /// @notice Emitted when allocated payouts are deallocated from a recipient\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the payout token\n    /// @param key Key for the allocation\n    /// @param amount Amount of tokens deallocated\n    /// @param extraData Extra data for the payout to attach in events\n    event PayoutsDeallocated(address indexed campaign, address token, bytes32 key, uint256 amount, bytes extraData);\n\n    /// @notice Emitted when a fee is sent to a recipient\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the payout token\n    /// @param recipient Address receiving the fee\n    /// @param amount Amount of tokens sent\n    /// @param extraData Extra data for the fee to attach in events\n    event FeeSent(address indexed campaign, address token, address recipient, uint256 amount, bytes extraData);\n\n    /// @notice Emitted when a fee is allocated to a recipient\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the payout token\n    /// @param key Key for the fees\n    /// @param amount Amount of tokens allocated\n    /// @param extraData Extra data for the payout to attach in events\n    event FeeAllocated(address indexed campaign, address token, bytes32 key, uint256 amount, bytes extraData);\n\n    /// @notice Emitted when accumulated fees are collected\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the collected token\n    /// @param key Key for the fees\n    /// @param recipient Address receiving the collected fees\n    /// @param amount Amount of tokens collected\n    /// @param extraData Extra data for the payout to attach in events\n    event FeesDistributed(\n        address indexed campaign, address token, bytes32 key, address recipient, uint256 amount, bytes extraData\n    );\n\n    /// @notice Emitted when someone withdraws funding from a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the withdrawn token\n    /// @param recipient Address that received the withdrawn tokens\n    /// @param amount Amount of tokens withdrawn\n    /// @param extraData Extra data for the payout to attach in events\n    event FundsWithdrawn(address indexed campaign, address token, address recipient, uint256 amount, bytes extraData);\n\n    /// @notice Thrown when campaign does not exist\n    error CampaignDoesNotExist();\n\n    /// @notice Thrown when campaign is in invalid status for operation\n    error InvalidCampaignStatus();\n\n    /// @notice Thrown when address is zero\n    error ZeroAddress();\n\n    /// @notice Thrown when amount is zero\n    error ZeroAmount();\n\n    /// @notice Thrown when campaign does not have enough balance for an operation\n    error InsufficientCampaignFunds();\n\n    /// @notice Check if a campaign exists\n    ///\n    /// @param campaign Address of the campaign\n    modifier onlyExists(address campaign) {\n        if (!campaignExists(campaign)) revert CampaignDoesNotExist();\n        _;\n    }\n\n    /// @notice Check if a campaign's status allows payouts\n    ///\n    /// @param campaign Address of the campaign\n    modifier acceptingPayouts(address campaign) {\n        CampaignStatus status = _campaigns[campaign].status;\n        if (status == CampaignStatus.INACTIVE || status == CampaignStatus.FINALIZED) revert InvalidCampaignStatus();\n        _;\n    }\n\n    /// @notice Constructor for the Flywheel contract\n    ///\n    /// @dev Deploys a new Campaign implementation for cloning\n    constructor() {\n        campaignImplementation = address(new Campaign());\n    }\n\n    /// @notice Creates a new campaign\n    ///\n    /// @param hooks Address of the campaign hooks contract\n    /// @param nonce Nonce used to create the campaign\n    /// @param hookData Data for the campaign hook\n    ///\n    /// @return campaign Address of the newly created campaign\n    ///\n    /// @dev Call `predictCampaignAddress` to know the address of the campaign without deploying it\n    function createCampaign(address hooks, uint256 nonce, bytes calldata hookData)\n        external\n        nonReentrant\n        returns (address campaign)\n    {\n        if (hooks == address(0)) revert ZeroAddress();\n        campaign = Clones.cloneDeterministic(campaignImplementation, keccak256(abi.encode(hooks, nonce, hookData)));\n        _campaigns[campaign] = CampaignInfo({status: CampaignStatus.INACTIVE, hooks: CampaignHooks(hooks)});\n        emit CampaignCreated(campaign, hooks);\n        CampaignHooks(hooks).onCreateCampaign(campaign, nonce, hookData);\n    }\n\n    /// @notice Sends immediate payouts to recipients for a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to send\n    /// @param hookData Data for the campaign hook\n    function send(address campaign, address token, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n        acceptingPayouts(campaign)\n        returns (Payout[] memory payouts, Payout[] memory immediateFees, Allocation[] memory delayedFees)\n    {\n        (payouts, immediateFees, delayedFees) = _campaigns[campaign].hooks.onSend(msg.sender, campaign, token, hookData);\n        _processFees(campaign, token, immediateFees, delayedFees);\n\n        uint256 count = payouts.length;\n        for (uint256 i = 0; i < count; i++) {\n            (address recipient, uint256 amount) = (payouts[i].recipient, payouts[i].amount);\n            if (amount == 0) continue;\n            Campaign(payable(campaign)).sendTokens(token, recipient, amount);\n            emit PayoutSent(campaign, token, recipient, amount, payouts[i].extraData);\n        }\n\n        _assertCampaignSolvency(campaign, token);\n    }\n\n    /// @notice Allocates payouts to a key for a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to be distributed\n    /// @param hookData Data for the campaign hook\n    ///\n    /// @dev Allocated payouts are transferred to recipients on `distribute`\n    function allocate(address campaign, address token, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n        acceptingPayouts(campaign)\n        returns (Allocation[] memory allocations)\n    {\n        allocations = _campaigns[campaign].hooks.onAllocate(msg.sender, campaign, token, hookData);\n\n        (uint256 totalAmount, uint256 count) = (0, allocations.length);\n        mapping(bytes32 key => uint256 amount) storage _allocatedPayout = allocatedPayout[campaign][token];\n        for (uint256 i = 0; i < count; i++) {\n            (bytes32 key, uint256 amount) = (allocations[i].key, allocations[i].amount);\n            if (amount == 0) continue;\n            totalAmount += amount;\n            _allocatedPayout[key] += amount;\n            emit PayoutAllocated(campaign, token, key, amount, allocations[i].extraData);\n        }\n\n        totalAllocatedPayouts[campaign][token] += totalAmount;\n        _assertCampaignSolvency(campaign, token);\n    }\n\n    /// @notice Deallocates allocated payouts from a key for a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to deallocate\n    /// @param hookData Data for the campaign hook\n    function deallocate(address campaign, address token, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n        acceptingPayouts(campaign)\n        returns (Allocation[] memory allocations)\n    {\n        allocations = _campaigns[campaign].hooks.onDeallocate(msg.sender, campaign, token, hookData);\n\n        (uint256 totalAmount, uint256 count) = (0, allocations.length);\n        mapping(bytes32 key => uint256 amount) storage _allocatedPayout = allocatedPayout[campaign][token];\n        for (uint256 i = 0; i < count; i++) {\n            (bytes32 key, uint256 amount) = (allocations[i].key, allocations[i].amount);\n            if (amount == 0) continue;\n            totalAmount += amount;\n            _allocatedPayout[key] -= amount;\n            emit PayoutsDeallocated(campaign, token, key, amount, allocations[i].extraData);\n        }\n\n        totalAllocatedPayouts[campaign][token] -= totalAmount;\n        _assertCampaignSolvency(campaign, token);\n    }\n\n    /// @notice Distributes allocated payouts to recipients for a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to distribute\n    /// @param hookData Data for the campaign hook\n    ///\n    /// @dev Payouts must first be allocated to a recipient before they can be distributed\n    /// @dev Use `reward` for immediate payouts\n    function distribute(address campaign, address token, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n        acceptingPayouts(campaign)\n        returns (Distribution[] memory distributions, Payout[] memory immediateFees, Allocation[] memory delayedFees)\n    {\n        (distributions, immediateFees, delayedFees) =\n            _campaigns[campaign].hooks.onDistribute(msg.sender, campaign, token, hookData);\n        _processFees(campaign, token, immediateFees, delayedFees);\n\n        (uint256 totalAmount, uint256 count) = (0, distributions.length);\n        mapping(bytes32 key => uint256 amount) storage _allocatedPayout = allocatedPayout[campaign][token];\n        for (uint256 i = 0; i < count; i++) {\n            (address recipient, bytes32 key, uint256 amount) =\n                (distributions[i].recipient, distributions[i].key, distributions[i].amount);\n            if (amount == 0) continue;\n            totalAmount += amount;\n            _allocatedPayout[key] -= amount;\n            Campaign(payable(campaign)).sendTokens(token, recipient, amount);\n            emit PayoutsDistributed(campaign, token, key, recipient, amount, distributions[i].extraData);\n        }\n\n        totalAllocatedPayouts[campaign][token] -= totalAmount;\n        _assertCampaignSolvency(campaign, token);\n    }\n\n    /// @notice Collects fees from a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to collect fees from\n    /// @param hookData Data for the campaign hook\n    function distributeFees(address campaign, address token, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n        returns (Distribution[] memory distributions)\n    {\n        distributions = _campaigns[campaign].hooks.onDistributeFees(msg.sender, campaign, token, hookData);\n\n        (uint256 totalAmount, uint256 count) = (0, distributions.length);\n        mapping(bytes32 key => uint256 amount) storage _allocatedFee = allocatedFee[campaign][token];\n        for (uint256 i = 0; i < count; i++) {\n            (address recipient, bytes32 key, uint256 amount) =\n                (distributions[i].recipient, distributions[i].key, distributions[i].amount);\n            if (amount == 0) continue;\n            totalAmount += amount;\n            _allocatedFee[key] -= amount;\n            Campaign(payable(campaign)).sendTokens(token, recipient, amount);\n            emit FeesDistributed(campaign, token, key, recipient, amount, distributions[i].extraData);\n        }\n\n        totalAllocatedFees[campaign][token] -= totalAmount;\n        _assertCampaignSolvency(campaign, token);\n    }\n\n    /// @notice Withdraw tokens from a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to withdraw\n    /// @param hookData Data for the campaign hook\n    function withdrawFunds(address campaign, address token, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n    {\n        Payout memory payout = _campaigns[campaign].hooks.onWithdrawFunds(msg.sender, campaign, token, hookData);\n        (address recipient, uint256 amount) = (payout.recipient, payout.amount);\n        if (amount == 0) revert ZeroAmount();\n        Campaign(payable(campaign)).sendTokens(token, recipient, amount);\n        emit FundsWithdrawn(campaign, token, recipient, amount, payout.extraData);\n\n        // Assert campaign solvency, but ignore payouts if campaign is finalized\n        uint256 requiredSolvency = campaignStatus(campaign) == CampaignStatus.FINALIZED\n            ? totalAllocatedFees[campaign][token]\n            : totalAllocatedFees[campaign][token] + totalAllocatedPayouts[campaign][token];\n        if (IERC20(token).balanceOf(campaign) < requiredSolvency) revert InsufficientCampaignFunds();\n    }\n\n    /// @notice Updates the status of a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param newStatus New status of the campaign\n    /// @param hookData Data for the campaign hook\n    function updateStatus(address campaign, CampaignStatus newStatus, bytes calldata hookData)\n        external\n        nonReentrant\n        onlyExists(campaign)\n    {\n        CampaignStatus oldStatus = _campaigns[campaign].status;\n        if (\n            newStatus == oldStatus // must update status\n                || oldStatus == CampaignStatus.FINALIZED // cannot update from finalized\n                || (oldStatus == CampaignStatus.FINALIZING && newStatus != CampaignStatus.FINALIZED) // finalizing can only update to finalized\n        ) revert InvalidCampaignStatus();\n\n        _campaigns[campaign].hooks.onUpdateStatus(msg.sender, campaign, oldStatus, newStatus, hookData);\n        _campaigns[campaign].status = newStatus;\n        emit CampaignStatusUpdated(campaign, msg.sender, oldStatus, newStatus);\n    }\n\n    /// @notice Updates the metadata for a campaign\n    ///\n    /// @param campaign Address of the campaign\n    /// @param hookData Data for the campaign hook\n    ///\n    /// @dev Indexers should update their metadata cache for this campaign by fetching the campaignURI\n    function updateMetadata(address campaign, bytes calldata hookData) external nonReentrant onlyExists(campaign) {\n        if (_campaigns[campaign].status == CampaignStatus.FINALIZED) revert InvalidCampaignStatus();\n        _campaigns[campaign].hooks.onUpdateMetadata(msg.sender, campaign, hookData);\n        emit CampaignMetadataUpdated(campaign, campaignURI(campaign));\n        Campaign(payable(campaign)).updateContractURI();\n    }\n\n    /// @notice Returns the address of a campaign given its creation parameters\n    ///\n    /// @param hooks Address of the campaign hooks contract\n    /// @param nonce Nonce used to create the campaign\n    /// @param hookData Data for the campaign hook\n    ///\n    /// @return campaign Address of the campaign\n    function predictCampaignAddress(address hooks, uint256 nonce, bytes calldata hookData)\n        external\n        view\n        returns (address campaign)\n    {\n        return Clones.predictDeterministicAddress(campaignImplementation, keccak256(abi.encode(hooks, nonce, hookData)));\n    }\n\n    /// @notice Checks if a campaign exists\n    ///\n    /// @param campaign Address of the campaign\n    ///\n    /// @return true if the campaign exists, false otherwise\n    function campaignExists(address campaign) public view returns (bool) {\n        return address(_campaigns[campaign].hooks) != address(0);\n    }\n\n    /// @notice Returns the hooks of a campaign\n    ///\n    /// @param campaign Address of the campaign\n    ///\n    /// @return hooks of the campaign\n    function campaignHooks(address campaign) public view onlyExists(campaign) returns (address hooks) {\n        return address(_campaigns[campaign].hooks);\n    }\n\n    /// @notice Returns the status of a campaign\n    ///\n    /// @param campaign Address of the campaign\n    ///\n    /// @return status of the campaign\n    function campaignStatus(address campaign) public view onlyExists(campaign) returns (CampaignStatus status) {\n        return _campaigns[campaign].status;\n    }\n\n    /// @notice Returns the URI for a campaign\n    ///\n    /// @param campaign Address of the campaign\n    ///\n    /// @return uri The URI for the campaign\n    function campaignURI(address campaign) public view onlyExists(campaign) returns (string memory uri) {\n        return _campaigns[campaign].hooks.campaignURI(campaign);\n    }\n\n    /// @notice Allocates a fee to a key\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to allocate the fee from\n    /// @param immediateFees Allocation of the fees to be sent immediately\n    /// @param delayedFees Allocation of the fees to be allocated\n    function _processFees(\n        address campaign,\n        address token,\n        Payout[] memory immediateFees,\n        Allocation[] memory delayedFees\n    ) internal {\n        uint256 count = immediateFees.length;\n        for (uint256 i = 0; i < count; i++) {\n            (address recipient, uint256 amount) = (immediateFees[i].recipient, immediateFees[i].amount);\n            if (amount == 0) continue;\n            Campaign(payable(campaign)).sendTokens(token, recipient, amount);\n            emit FeeSent(campaign, token, recipient, amount, immediateFees[i].extraData);\n        }\n\n        count = delayedFees.length;\n        uint256 totalFeeAmount = 0;\n        mapping(bytes32 key => uint256 amount) storage _allocatedFee = allocatedFee[campaign][token];\n        for (uint256 i = 0; i < count; i++) {\n            (bytes32 key, uint256 amount) = (delayedFees[i].key, delayedFees[i].amount);\n            if (amount == 0) continue;\n            totalFeeAmount += amount;\n            _allocatedFee[key] += amount;\n            emit FeeAllocated(campaign, token, key, amount, delayedFees[i].extraData);\n        }\n        totalAllocatedFees[campaign][token] += totalFeeAmount;\n    }\n\n    /// @notice Enforces that a campaign has enough reserved funds for an operation\n    ///\n    /// @param campaign Address of the campaign\n    /// @param token Address of the token to check\n    function _assertCampaignSolvency(address campaign, address token) internal {\n        uint256 totalAllocated = totalAllocatedPayouts[campaign][token] + totalAllocatedFees[campaign][token];\n        if (IERC20(token).balanceOf(campaign) < totalAllocated) revert InsufficientCampaignFunds();\n    }\n\n    /// @dev Override to use transient reentrancy guard on all chains\n    function _useTransientReentrancyGuardOnlyOnMainnet() internal pure override returns (bool) {\n        return false;\n    }\n}\n",
        "PseudoRandomRegistrar.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {BuilderCodes} from \"../BuilderCodes.sol\";\n\n/// @notice Pseudo-random registrar for referral codes\n///\n/// @dev Generates unique referral codes using a pseudo-random algorithm\n///\n/// @author Coinbase\ncontract PseudoRandomRegistrar {\n    /// @notice Prefix for new permissionless referral codes\n    string public constant PREFIX = \"rnd_\";\n\n    /// @notice Prefix for new permissionless referral codes\n    string public constant ALPHANUMERIC = \"0123456789abcdefghijklmonpqrstuvwxyz\";\n\n    /// @notice Default length of new permissionless referral codes\n    uint256 public constant SUFFIX_LENGTH = 8;\n\n    /// @notice Referral codes contract\n    BuilderCodes public immutable codes;\n\n    /// @notice Nonce for generating unique referral codes\n    uint256 public nonce;\n\n    /// @notice Constructor for PseudoRandomRegistrar\n    ///\n    /// @param codes_ Address of the BuilderCodes contract\n    constructor(address codes_) {\n        codes = BuilderCodes(codes_);\n    }\n\n    /// @notice Registers a new referral code in the system\n    ///\n    /// @param payoutAddress Default payout address for all chains\n    function register(address payoutAddress) external returns (string memory code) {\n        // Generate unique referral code by looping until we find an unused one\n        do {\n            code = computeCode(++nonce);\n        } while (!codes.isValidCode(code) || codes.isRegistered(code));\n\n        codes.register(code, msg.sender, payoutAddress);\n    }\n\n    /// @notice Generates a unique code for a referral code\n    ///\n    /// @param nonceValue Nonce value to generate a code from\n    ///\n    /// @return code Referral code for the referral code\n    function computeCode(uint256 nonceValue) public view returns (string memory code) {\n        bytes memory allowedCharacters = bytes(ALPHANUMERIC);\n        uint256 len = allowedCharacters.length;\n        bytes memory suffix = new bytes(SUFFIX_LENGTH);\n\n        // Iteratively generate code with modulo arithmetic on pseudo-random hash\n        uint256 hashNum = uint256(\n            keccak256(abi.encodePacked(nonceValue, block.timestamp, blockhash(block.number - 1), block.prevrandao))\n        );\n        for (uint256 i; i < SUFFIX_LENGTH; i++) {\n            suffix[i] = allowedCharacters[hashNum % len];\n            hashNum /= len;\n        }\n\n        return string.concat(PREFIX, string(suffix));\n    }\n}\n"
    }
}