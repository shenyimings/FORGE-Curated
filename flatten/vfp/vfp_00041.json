{
    "vfp_id": "vfp_00041",
    "project_name": "ChainSecurity_MellowFinance_Multivault_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Bank Run on Excess Funds in Vault Prior to Slashing Event",
            "description": "The vault holds idle liquid assets when not all funds are deposited into external protocols. These idle assets can be withdrawn immediately by converting shares to underlying assets at the current exchange rate. This creates a risk of a bank run on the excess funds just before a slashing event, as users are incentivized to withdraw early to avoid losses. Since slashing events are predictable (e.g., via VetoSlasher in Symbiotic), malicious actors can frontrun or backrun withdrawal transactions. The root cause is the lack of withdrawal delay or pro-rata distribution mechanism during pending slashing periods. This allows users to selectively withdraw from subvaults with higher-valued pending assets, leading to unfair distribution and potential loss for remaining share owners. The impact includes economic loss for remaining stakeholders and potential destabilization of the vault due to rushed withdrawals.\n",
            "severity": "Medium",
            "location": [
                "Vault::convertShares#withdraw",
                "Subvault::pendingAssets"
            ],
            "files": [
                "simple-lrt/src/vaults/MultiVault.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ]
            },
            "title": "Old Vault Contracts Can Not Be Migrated Easily",
            "description": "Migrating from old vault versions to `MultiVault` is problematic due to initialization conflicts and role identifier changes (e.g., `SET_FARM_ROLE` replaced by `SET_REWARDS_DATA_ROLE`). The `initialize` function uses a modifier that prevents reinitialization, and role mappings are not backward compatible. Migration attempts may revert due to initialization guards, and farm operators may lose permissions unless roles are manually reassigned. This complicates upgrades and may lead to governance or operational failures during migration.\n",
            "severity": "Low",
            "location": [
                "MultiVault.initialize",
                "SET_FARM_ROLE"
            ],
            "files": [
                "simple-lrt/src/vaults/MultiVault.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Implementation Contract Can Be Initialized",
            "description": "The `MultiVault` implementation contract does not disable initializers, allowing anyone to initialize it and potentially corrupt its state. Missing `_disableInitializers()` call in the constructor. On chains supporting `selfdestruct`, an attacker could set a malicious module and self-destruct the implementation. Potential destruction of the implementation contract, breaking upgrades and affecting all proxies.\n",
            "severity": "Informational",
            "location": [
                "MultiVault constructor"
            ],
            "files": [
                "simple-lrt/src/vaults/MultiVault.sol"
            ]
        }
    ],
    "affected_files": {
        "MultiVault.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.25;\n\nimport \"../interfaces/vaults/IMultiVault.sol\";\nimport {ERC4626Vault} from \"./ERC4626Vault.sol\";\nimport {MultiVaultStorage} from \"./MultiVaultStorage.sol\";\nimport {VaultControlStorage} from \"./VaultControlStorage.sol\";\n\ncontract MultiVault is IMultiVault, ERC4626Vault, MultiVaultStorage {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 private constant D6 = 1e6;\n    bytes32 public constant ADD_SUBVAULT_ROLE = keccak256(\"ADD_SUBVAULT_ROLE\");\n    bytes32 public constant REMOVE_SUBVAULT_ROLE = keccak256(\"REMOVE_SUBVAULT_ROLE\");\n    bytes32 public constant SET_STRATEGY_ROLE = keccak256(\"SET_STRATEGY_ROLE\");\n    bytes32 public constant SET_FARM_ROLE = keccak256(\"SET_FARM_ROLE\");\n    bytes32 public constant REBALANCE_ROLE = keccak256(\"REBALANCE_ROLE\");\n    bytes32 public constant SET_DEFAULT_COLLATERAL_ROLE = keccak256(\"SET_DEFAULT_COLLATERAL_ROLE\");\n    bytes32 public constant SET_ADAPTER_ROLE = keccak256(\"SET_ADAPTER_ROLE\");\n\n    constructor(bytes32 name_, uint256 version_)\n        VaultControlStorage(name_, version_)\n        MultiVaultStorage(name_, version_)\n    {\n        _disableInitializers();\n    }\n\n    // ------------------------------- EXTERNAL VIEW FUNCTIONS -------------------------------\n\n    /// @inheritdoc IERC4626\n    function totalAssets()\n        public\n        view\n        virtual\n        override(IERC4626, ERC4626Upgradeable)\n        returns (uint256 assets_)\n    {\n        address this_ = address(this);\n        assets_ = IERC20(asset()).balanceOf(this_);\n        IDefaultCollateral collateral = defaultCollateral();\n        if (address(collateral) != address(0)) {\n            assets_ += collateral.balanceOf(this_);\n        }\n\n        uint256 length = subvaultsCount();\n        Subvault memory subvault;\n        for (uint256 i = 0; i < length; i++) {\n            subvault = subvaultAt(i);\n            assets_ += adapterOf(subvault.protocol).stakedAt(subvault.vault);\n            if (subvault.withdrawalQueue != address(0)) {\n                assets_ += IWithdrawalQueue(subvault.withdrawalQueue).claimableAssetsOf(this_)\n                    + IWithdrawalQueue(subvault.withdrawalQueue).pendingAssetsOf(this_);\n            }\n        }\n    }\n\n    // ------------------------------- EXTERNAL MUTATIVE FUNCTIONS -------------------------------\n\n    /// @inheritdoc IMultiVault\n    function initialize(InitParams calldata initParams) public virtual reinitializer(2) {\n        __initializeERC4626(\n            initParams.admin,\n            initParams.limit,\n            initParams.depositPause,\n            initParams.withdrawalPause,\n            initParams.depositWhitelist,\n            initParams.asset,\n            initParams.name,\n            initParams.symbol\n        );\n        __initializeMultiVaultStorage(\n            initParams.depositStrategy,\n            initParams.withdrawalStrategy,\n            initParams.rebalanceStrategy,\n            initParams.defaultCollateral,\n            initParams.symbioticAdapter,\n            initParams.eigenLayerAdapter,\n            initParams.erc4626Adapter\n        );\n        require(\n            initParams.defaultCollateral == address(0)\n                || IDefaultCollateral(initParams.defaultCollateral).asset() == initParams.asset,\n            \"MultiVault: default collateral asset does not match the vault asset\"\n        );\n    }\n\n    /// @inheritdoc IMultiVault\n    function addSubvault(address vault, Protocol protocol) external onlyRole(ADD_SUBVAULT_ROLE) {\n        IProtocolAdapter adapter = adapterOf(protocol);\n        require(\n            adapter.assetOf(vault) == asset(),\n            \"MultiVault: subvault asset does not match the vault asset\"\n        );\n        _addSubvault(vault, adapter.handleVault(vault), protocol);\n    }\n\n    /// @inheritdoc IMultiVault\n    function removeSubvault(address subvault) external onlyRole(REMOVE_SUBVAULT_ROLE) {\n        _removeSubvault(subvault);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setDepositStrategy(address newDepositStrategy) external onlyRole(SET_STRATEGY_ROLE) {\n        require(\n            newDepositStrategy != address(0), \"MultiVault: deposit strategy cannot be zero address\"\n        );\n        _setDepositStrategy(newDepositStrategy);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setWithdrawalStrategy(address newWithdrawalStrategy)\n        external\n        onlyRole(SET_STRATEGY_ROLE)\n    {\n        require(\n            newWithdrawalStrategy != address(0),\n            \"MultiVault: withdrawal strategy cannot be zero address\"\n        );\n        _setWithdrawalStrategy(newWithdrawalStrategy);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setRebalanceStrategy(address newRebalanceStrategy)\n        external\n        onlyRole(SET_STRATEGY_ROLE)\n    {\n        require(\n            newRebalanceStrategy != address(0),\n            \"MultiVault: rebalance strategy cannot be zero address\"\n        );\n        _setRebalanceStrategy(newRebalanceStrategy);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setDefaultCollateral(address defaultCollateral_)\n        external\n        onlyRole(SET_DEFAULT_COLLATERAL_ROLE)\n    {\n        require(\n            address(defaultCollateral()) == address(0) && defaultCollateral_ != address(0),\n            \"MultiVault: default collateral already set or cannot be zero address\"\n        );\n        require(\n            IDefaultCollateral(defaultCollateral_).asset() == asset(),\n            \"MultiVault: default collateral asset does not match the vault asset\"\n        );\n        _setDefaultCollateral(defaultCollateral_);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setSymbioticAdapter(address adapter_) external onlyRole(SET_ADAPTER_ROLE) {\n        require(adapter_ != address(0), \"MultiVault: adapter cannot be zero address\");\n        _setSymbioticAdapter(adapter_);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setEigenLayerAdapter(address adapter_) external onlyRole(SET_ADAPTER_ROLE) {\n        require(adapter_ != address(0), \"MultiVault: adapter cannot be zero address\");\n        _setEigenLayerAdapter(adapter_);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setERC4626Adapter(address adapter_) external onlyRole(SET_ADAPTER_ROLE) {\n        require(adapter_ != address(0), \"MultiVault: adapter cannot be zero address\");\n        _setERC4626Adapter(adapter_);\n    }\n\n    /// @inheritdoc IMultiVault\n    function setRewardsData(uint256 farmId, RewardData calldata rewardData)\n        external\n        onlyRole(SET_FARM_ROLE)\n    {\n        if (rewardData.token != address(0)) {\n            require(\n                rewardData.token != asset() && rewardData.token != address(defaultCollateral()),\n                \"MultiVault: reward token cannot be the same as the asset or default collateral\"\n            );\n            require(rewardData.curatorFeeD6 <= D6, \"MultiVault: curator fee exceeds 100%\");\n            require(\n                rewardData.distributionFarm != address(0),\n                \"MultiVault: distribution farm address cannot be zero\"\n            );\n            if (rewardData.curatorFeeD6 != 0) {\n                require(\n                    rewardData.curatorTreasury != address(0),\n                    \"MultiVault: curator treasury address cannot be zero when fee is set\"\n                );\n            }\n            adapterOf(rewardData.protocol).validateRewardData(rewardData.data);\n        }\n        _setRewardData(farmId, rewardData);\n    }\n\n    /// @inheritdoc IMultiVault\n    function rebalance() external onlyRole(REBALANCE_ROLE) {\n        address this_ = address(this);\n        IRebalanceStrategy.RebalanceData[] memory data =\n            rebalanceStrategy().calculateRebalanceAmounts(this_);\n        for (uint256 i = 0; i < data.length; i++) {\n            _withdraw(data[i].subvaultIndex, data[i].staked, 0, data[i].claimable, this_, this_);\n        }\n        IDefaultCollateral collateral = defaultCollateral();\n        if (address(collateral) != address(0)) {\n            uint256 balance = collateral.balanceOf(this_);\n            if (balance != 0) {\n                collateral.withdraw(this_, balance);\n            }\n        }\n        for (uint256 i = 0; i < data.length; i++) {\n            _deposit(data[i].subvaultIndex, data[i].deposit);\n        }\n        _depositIntoCollateral();\n        emit Rebalance(data, block.timestamp);\n    }\n\n    /// @inheritdoc IMultiVault\n    function pushRewards(uint256 farmId, bytes calldata farmData) external nonReentrant {\n        require(farmIdsContains(farmId), \"MultiVault: farm not found\");\n        IMultiVaultStorage.RewardData memory data = rewardData(farmId);\n        IERC20 rewardToken = IERC20(data.token);\n\n        address this_ = address(this);\n        uint256 rewardAmount = rewardToken.balanceOf(this_);\n\n        Address.functionDelegateCall(\n            address(adapterOf(data.protocol)),\n            abi.encodeCall(\n                IProtocolAdapter.pushRewards, (address(rewardToken), farmData, data.data)\n            )\n        );\n\n        rewardAmount = rewardToken.balanceOf(this_) - rewardAmount;\n        if (rewardAmount == 0) {\n            return;\n        }\n\n        uint256 curatorFee = rewardAmount.mulDiv(data.curatorFeeD6, D6);\n        if (curatorFee != 0) {\n            rewardToken.safeTransfer(data.curatorTreasury, curatorFee);\n        }\n        rewardAmount = rewardAmount - curatorFee;\n        if (rewardAmount != 0) {\n            rewardToken.safeTransfer(data.distributionFarm, rewardAmount);\n        }\n        emit RewardsPushed(farmId, rewardAmount, curatorFee, block.timestamp);\n    }\n\n    // ------------------------------- INTERNAL MUTATIVE FUNCTIONS -------------------------------\n\n    /// @dev Deposits assets into the specified subvault\n    function _deposit(uint256 subvaultIndex, uint256 assets) private {\n        if (assets == 0) {\n            return;\n        }\n        Subvault memory subvault = subvaultAt(subvaultIndex);\n        Address.functionDelegateCall(\n            address(adapterOf(subvault.protocol)),\n            abi.encodeCall(IProtocolAdapter.deposit, (subvault.vault, assets))\n        );\n    }\n\n    /// @dev Withdraws assets from the specified subvault\n    function _withdraw(\n        uint256 subvaultIndex,\n        uint256 request,\n        uint256 pending,\n        uint256 claimable,\n        address owner,\n        address receiver\n    ) private {\n        Subvault memory subvault = subvaultAt(subvaultIndex);\n        address this_ = address(this);\n        if (claimable != 0) {\n            IWithdrawalQueue(subvault.withdrawalQueue).claim(this_, receiver, claimable);\n        }\n        if (pending != 0) {\n            IWithdrawalQueue(subvault.withdrawalQueue).transferPendingAssets(receiver, pending);\n        }\n        if (request != 0) {\n            Address.functionDelegateCall(\n                address(adapterOf(subvault.protocol)),\n                abi.encodeCall(\n                    IProtocolAdapter.withdraw,\n                    (subvault.vault, subvault.withdrawalQueue, receiver, request, owner)\n                )\n            );\n        }\n    }\n\n    /// @dev Deposits assets into the default collateral\n    function _depositIntoCollateral() private {\n        IDefaultCollateral collateral = defaultCollateral();\n        if (address(collateral) == address(0)) {\n            return;\n        }\n        uint256 limit_ = collateral.limit();\n        uint256 supply_ = collateral.totalSupply();\n        if (supply_ >= limit_) {\n            return;\n        }\n        address this_ = address(this);\n        IERC20 asset_ = IERC20(asset());\n        uint256 assets = asset_.balanceOf(this_).min(limit_ - supply_);\n        if (assets == 0) {\n            return;\n        }\n        asset_.safeIncreaseAllowance(address(collateral), assets);\n        collateral.deposit(this_, assets);\n        emit DepositIntoCollateral(assets);\n    }\n\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        address this_ = address(this);\n        IDepositStrategy.DepositData[] memory data =\n            depositStrategy().calculateDepositAmounts(this_, assets);\n        super._deposit(caller, receiver, assets, shares);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (data[i].deposit != 0) {\n                _deposit(data[i].subvaultIndex, data[i].deposit);\n                assets -= data[i].deposit;\n            }\n        }\n\n        _depositIntoCollateral();\n    }\n\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        address this_ = address(this);\n\n        IWithdrawalStrategy.WithdrawalData[] memory data =\n            withdrawalStrategy().calculateWithdrawalAmounts(this_, assets);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n\n        uint256 liquid = assets;\n        IWithdrawalStrategy.WithdrawalData memory d;\n        for (uint256 i = 0; i < data.length; i++) {\n            d = data[i];\n            _withdraw(d.subvaultIndex, d.staked, d.pending, d.claimable, owner, receiver);\n            liquid -= d.staked + d.pending + d.claimable;\n        }\n\n        if (liquid != 0) {\n            IERC20 asset_ = IERC20(asset());\n            uint256 balance = asset_.balanceOf(this_);\n            if (balance < liquid) {\n                if (balance != 0) {\n                    asset_.safeTransfer(receiver, balance);\n                    liquid -= balance;\n                }\n                defaultCollateral().withdraw(receiver, liquid);\n            } else {\n                asset_.safeTransfer(receiver, liquid);\n            }\n        }\n\n        // emitting event with transferred + new pending assets\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n}\n"
    }
}