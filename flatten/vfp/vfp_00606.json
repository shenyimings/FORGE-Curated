{
    "vfp_id": "vfp_00606",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ],
                "4": [
                    "CWE-613"
                ]
            },
            "title": "Redemption Waiting Can Be Gamed",
            "description": "The `requestRedeem` function in the FxUSDBasePool contract allows users to register a redemption request without any expiration. A user can deposit and immediately request redemption, then wait indefinitely to execute it after the cooldown period. This undermines the intended purpose of the cooldown, which is to prevent rapid redemption runs on the stability pool. The root cause is the lack of a time-bound expiration for redemption requests. An attacker could exploit this by locking in a favorable rate and redeeming later when market conditions are more advantageous, effectively gaming the system. The impact is potential economic imbalance and reduced effectiveness of the cooldown mechanism in stabilizing the pool during volatility.\n",
            "severity": "Low",
            "location": [
                "FxUSDBasePool.sol::requestRedeem#315-325"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FxUSDBasePool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Stale Value of `totalStableToken` Used in Stability Pool",
            "description": "The `previewDeposit`, `previewRedeem`, and `nav` functions in the FxUSDBasePool contract do not use the `sync` modifier, resulting in the use of a stale `totalStableToken` value. This variable reflects the total stablecoin balance including yield from strategies, and if not updated, these view functions return incorrect estimates. The root cause is the omission of the `sync` modifier on read-only functions that depend on dynamically updated state. An attacker could exploit this by triggering a deposit when the view function overestimates shares, causing the transaction to revert due to `minSharesOut` checks, leading to a denial-of-service for legitimate users. The impact is inaccurate previews and potential failed transactions, degrading user experience and trust.\n",
            "severity": "Low",
            "location": [
                "FxUSDBasePool.sol::previewDeposit#226",
                "FxUSDBasePool.sol::previewRedeem#246",
                "FxUSDBasePool.sol::nav#257"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FxUSDBasePool.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Missing L2 Sequencer Uptime Checks",
            "description": "The protocol does not implement checks for L2 sequencer downtime, which can render the application unusable for most users even if the underlying chain is operational. Oracle calls such as `latestRoundData` in FxUSDBasePool and SpotPriceOracleBase may return stale or incorrect data during such outages. The root cause is the absence of integration with Chainlink's Sequencer Uptime Feeds or equivalent monitoring. An attacker could exploit network downtime to manipulate prices or delay updates, leading to unfair liquidations or incorrect state changes. The impact is reduced reliability and potential for user harm during L2 outages, especially on chains like Base where sequencer health is critical.\n",
            "severity": "Low",
            "location": [
                "FxUSDBasePool.sol::latestRoundData#279",
                "SpotPriceOracleBase.sol::latestRoundData#59"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FxUSDBasePool.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Different Pragma Directives",
            "description": "The Solidity pragma directives across the codebase are inconsistent and not fixed to a specific version, which can lead to different compiler behaviors and potential vulnerabilities during deployment. This inconsistency increases the risk of introducing compiler-specific bugs or unexpected behavior due to version differences. The root cause is the lack of a unified compiler version policy across contract files. An attacker could potentially exploit differences in compiler behavior if a contract is recompiled with a different version than intended. This could result in logic errors, failed deployments, or even security breaches due to changed bytecode semantics.\n",
            "severity": null,
            "location": [],
            "files": [
                "fx-protocol-contracts/contracts/core/ReservePool.sol",
                "fx-protocol-contracts/contracts/core/FxUSDBasePool.sol",
                "fx-protocol-contracts/contracts/periphery/facets/MigrateFacet.sol",
                "fx-protocol-contracts/contracts/periphery/libraries/LibRouter.sol",
                "fx-protocol-contracts/contracts/v2/interfaces/IFxUSD.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Possible Duplicate Event Emissions",
            "description": "Multiple setter functions across the codebase emit events without first checking if the new value differs from the current one. This allows for repeated emission of identical events when the same value is set multiple times. The cause is the absence of a value-change precondition check in these functions. An attacker or user could spam the event logs by repeatedly calling setters with the same value. This could confuse off-chain indexing services, increase gas costs for users, and degrade the reliability of event-based monitoring systems, leading to incorrect state assumptions by frontends or bots.\n",
            "severity": null,
            "location": [
                "FxUSDBasePool.sol::_updateRedeemCoolDownPeriod#565-572",
                "FxUSDBasePool.sol::_updateInstantRedeemFeeRatio#576-583",
                "PegKeeper.sol::_updateConverter#193-200",
                "PegKeeper.sol::_updateCurvePool#204-211",
                "PegKeeper.sol::_updatePriceThreshold#215-220",
                "PoolManager.sol::_updateThreshold#600-605",
                "PoolStorage.sol::_updatePriceOracle#245-252",
                "ProtocolFees.sol::_updateTreasury#275-282",
                "ProtocolFees.sol::_updateOpenRevenuePool#286-293",
                "ProtocolFees.sol::_updateCloseRevenuePool#297-304",
                "ProtocolFees.sol::_updateMiscRevenuePool#308-315",
                "ProtocolFees.sol::_updateReservePool#319-326"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FxUSDBasePool.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-477"
                ]
            },
            "title": "Use Custom Errors",
            "description": "The contracts use plain `revert` statements with string messages instead of custom errors, which are more gas-efficient and provide better clarity. The cause is the use of older Solidity patterns before custom errors were introduced in 0.8.4. While not directly exploitable, this reduces transparency and increases gas costs during reverts. The impact includes higher gas usage and less informative error messages for users and frontends.\n",
            "severity": null,
            "location": [
                "FxUSDBasePool.sol",
                "FxUSDRegeneracy.sol",
                "SavingFxUSD.sol",
                "AssetManagement.sol",
                "StrategyBase.sol",
                "BTCDerivativeOracleBase.sol",
                "SpotPriceOracleBase.sol"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/FxUSDBasePool.sol"
            ]
        }
    ],
    "affected_files": {
        "FxUSDBasePool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.25;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { IStrategy } from \"../fund/IStrategy.sol\";\nimport { AggregatorV3Interface } from \"../interfaces/Chainlink/AggregatorV3Interface.sol\";\nimport { IPegKeeper } from \"../interfaces/IPegKeeper.sol\";\nimport { IPool } from \"../interfaces/IPool.sol\";\nimport { IPoolManager } from \"../interfaces/IPoolManager.sol\";\nimport { IFxUSDBasePool } from \"../interfaces/IFxUSDBasePool.sol\";\n\nimport { AssetManagement } from \"../fund/AssetManagement.sol\";\nimport { Math } from \"../libraries/Math.sol\";\n\ncontract FxUSDBasePool is\n  ERC20PermitUpgradeable,\n  AccessControlUpgradeable,\n  ReentrancyGuardUpgradeable,\n  AssetManagement,\n  IFxUSDBasePool\n{\n  using SafeERC20 for IERC20;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when the deposited amount is zero.\n  error ErrDepositZeroAmount();\n\n  /// @dev Thrown when the minted shares are not enough.\n  error ErrInsufficientSharesOut();\n\n  /// @dev Thrown the input token in invalid.\n  error ErrInvalidTokenIn();\n\n  /// @dev Thrown when the redeemed shares is zero.\n  error ErrRedeemZeroShares();\n\n  error ErrorCallerNotPegKeeper();\n\n  error ErrorStableTokenDepeg();\n\n  error ErrorSwapExceedBalance();\n\n  error ErrorInsufficientOutput();\n\n  error ErrorInsufficientArbitrage();\n\n  error ErrorRedeemCoolDownPeriodTooLarge();\n\n  error ErrorRedeemMoreThanBalance();\n\n  error ErrorRedeemLockedShares();\n\n  error ErrorInsufficientFreeBalance();\n\n  error ErrorInstantRedeemFeeTooLarge();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The exchange rate precision.\n  uint256 internal constant PRECISION = 1e18;\n\n  uint256 internal constant MAX_INSTANT_REDEEM_FEE = 5e16; // 5%\n\n  /***********************\n   * Immutable Variables *\n   ***********************/\n\n  /// @notice The address of `PoolManager` contract.\n  address public immutable poolManager;\n\n  /// @notice The address of `PegKeeper` contract.\n  address public immutable pegKeeper;\n\n  /// @inheritdoc IFxUSDBasePool\n  /// @dev This is also the address of FxUSD token.\n  address public immutable yieldToken;\n\n  /// @inheritdoc IFxUSDBasePool\n  /// @dev The address of USDC token.\n  address public immutable stableToken;\n\n  uint256 private immutable stableTokenScale;\n\n  /// @notice The Chainlink USDC/USD price feed.\n  /// @dev The encoding is below.\n  /// ```text\n  /// |  32 bits  | 64 bits |  160 bits  |\n  /// | heartbeat |  scale  | price_feed |\n  /// |low                          high |\n  /// ```\n  bytes32 public immutable Chainlink_USDC_USD_Spot;\n\n  /***********\n   * Structs *\n   ***********/\n\n  struct RebalanceMemoryVar {\n    uint256 stablePrice;\n    uint256 totalYieldToken;\n    uint256 totalStableToken;\n    uint256 yieldTokenToUse;\n    uint256 stableTokenToUse;\n    uint256 colls;\n    uint256 yieldTokenUsed;\n    uint256 stableTokenUsed;\n  }\n\n  struct RedeemRequest {\n    uint128 amount;\n    uint128 unlockAt;\n  }\n\n  /*************\n   * Variables *\n   *************/\n\n  /// @inheritdoc IFxUSDBasePool\n  uint256 public totalYieldToken;\n\n  /// @inheritdoc IFxUSDBasePool\n  uint256 public totalStableToken;\n\n  /// @notice The depeg price for stable token.\n  uint256 public stableDepegPrice;\n\n  /// @notice Mapping from user address to redeem request.\n  mapping(address => RedeemRequest) public redeemRequests;\n\n  /// @notice The number of seconds of cool down before redeem from this pool.\n  uint256 public redeemCoolDownPeriod;\n\n  /// @notice The fee ratio for instantly redeem.\n  uint256 public instantRedeemFeeRatio;\n\n  /*************\n   * Modifiers *\n   *************/\n\n  modifier onlyValidToken(address token) {\n    if (token != stableToken && token != yieldToken) {\n      revert ErrInvalidTokenIn();\n    }\n    _;\n  }\n\n  modifier onlyPegKeeper() {\n    if (_msgSender() != pegKeeper) revert ErrorCallerNotPegKeeper();\n    _;\n  }\n\n  modifier sync() {\n    {\n      // we only manage stable token\n      Allocation memory b = allocations[stableToken];\n      if (b.strategy != address(0)) {\n        totalStableToken = IStrategy(b.strategy).totalSupply() + IERC20(stableToken).balanceOf(address(this));\n      }\n    }\n    _;\n  }\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(\n    address _poolManager,\n    address _pegKeeper,\n    address _yieldToken,\n    address _stableToken,\n    bytes32 _Chainlink_USDC_USD_Spot\n  ) {\n    poolManager = _poolManager;\n    pegKeeper = _pegKeeper;\n    yieldToken = _yieldToken;\n    stableToken = _stableToken;\n    Chainlink_USDC_USD_Spot = _Chainlink_USDC_USD_Spot;\n\n    stableTokenScale = 10 ** (18 - IERC20Metadata(_stableToken).decimals());\n  }\n\n  function initialize(\n    address admin,\n    string memory _name,\n    string memory _symbol,\n    uint256 _stableDepegPrice,\n    uint256 _redeemCoolDownPeriod\n  ) external initializer {\n    __Context_init();\n    __ERC165_init();\n    __AccessControl_init();\n    __ReentrancyGuard_init();\n\n    __ERC20_init(_name, _symbol);\n    __ERC20Permit_init(_name);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n    _updateStableDepegPrice(_stableDepegPrice);\n    _updateRedeemCoolDownPeriod(_redeemCoolDownPeriod);\n\n    // approve\n    IERC20(yieldToken).forceApprove(poolManager, type(uint256).max);\n    IERC20(stableToken).forceApprove(poolManager, type(uint256).max);\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc IFxUSDBasePool\n  function previewDeposit(\n    address tokenIn,\n    uint256 amountTokenToDeposit\n  ) public view override onlyValidToken(tokenIn) returns (uint256 amountSharesOut) {\n    uint256 price = getStableTokenPriceWithScale();\n    uint256 amountUSD = amountTokenToDeposit;\n    if (tokenIn == stableToken) {\n      amountUSD = (amountUSD * price) / PRECISION;\n    }\n\n    uint256 _totalSupply = totalSupply();\n    if (_totalSupply == 0) {\n      amountSharesOut = amountUSD;\n    } else {\n      uint256 totalUSD = totalYieldToken + (totalStableToken * price) / PRECISION;\n      amountSharesOut = (amountUSD * _totalSupply) / totalUSD;\n    }\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function previewRedeem(\n    uint256 amountSharesToRedeem\n  ) external view returns (uint256 amountYieldOut, uint256 amountStableOut) {\n    uint256 cachedTotalYieldToken = totalYieldToken;\n    uint256 cachedTotalStableToken = totalStableToken;\n    uint256 cachedTotalSupply = totalSupply();\n    amountYieldOut = (amountSharesToRedeem * cachedTotalYieldToken) / cachedTotalSupply;\n    amountStableOut = (amountSharesToRedeem * cachedTotalStableToken) / cachedTotalSupply;\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function nav() external view returns (uint256) {\n    uint256 _totalSupply = totalSupply();\n    if (_totalSupply == 0) {\n      return PRECISION;\n    } else {\n      uint256 stablePrice = getStableTokenPriceWithScale();\n      uint256 yieldPrice = IPegKeeper(pegKeeper).getFxUSDPrice();\n      return (totalYieldToken * yieldPrice + totalStableToken * stablePrice) / _totalSupply;\n    }\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function getStableTokenPrice() public view returns (uint256) {\n    bytes32 encoding = Chainlink_USDC_USD_Spot;\n    address aggregator;\n    uint256 scale;\n    uint256 heartbeat;\n    assembly {\n      aggregator := shr(96, encoding)\n      scale := and(shr(32, encoding), 0xffffffffffffffff)\n      heartbeat := and(encoding, 0xffffffff)\n    }\n    (, int256 answer, , uint256 updatedAt, ) = AggregatorV3Interface(aggregator).latestRoundData();\n    if (answer < 0) revert(\"invalid\");\n    if (block.timestamp - updatedAt > heartbeat) revert(\"expired\");\n    return uint256(answer) * scale;\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function getStableTokenPriceWithScale() public view returns (uint256) {\n    return getStableTokenPrice() * stableTokenScale;\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc IFxUSDBasePool\n  function deposit(\n    address receiver,\n    address tokenIn,\n    uint256 amountTokenToDeposit,\n    uint256 minSharesOut\n  ) external override nonReentrant onlyValidToken(tokenIn) sync returns (uint256 amountSharesOut) {\n    if (amountTokenToDeposit == 0) revert ErrDepositZeroAmount();\n\n    // we are very sure every token is normal token, so no fot check here.\n    IERC20(tokenIn).safeTransferFrom(_msgSender(), address(this), amountTokenToDeposit);\n\n    amountSharesOut = _deposit(tokenIn, amountTokenToDeposit);\n    if (amountSharesOut < minSharesOut) revert ErrInsufficientSharesOut();\n\n    _mint(receiver, amountSharesOut);\n\n    emit Deposit(_msgSender(), receiver, tokenIn, amountTokenToDeposit, amountSharesOut);\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function requestRedeem(uint256 shares) external {\n    address caller = _msgSender();\n    uint256 balance = balanceOf(caller);\n    RedeemRequest memory request = redeemRequests[caller];\n    if (request.amount + shares > balance) revert ErrorRedeemMoreThanBalance();\n    request.amount += uint128(shares);\n    request.unlockAt = uint128(block.timestamp + redeemCoolDownPeriod);\n    redeemRequests[caller] = request;\n\n    emit RequestRedeem(caller, shares, request.unlockAt);\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function redeem(\n    address receiver,\n    uint256 amountSharesToRedeem\n  ) external nonReentrant sync returns (uint256 amountYieldOut, uint256 amountStableOut) {\n    address caller = _msgSender();\n    RedeemRequest memory request = redeemRequests[caller];\n    if (request.unlockAt > block.timestamp) revert ErrorRedeemLockedShares();\n    if (request.amount < amountSharesToRedeem) {\n      amountSharesToRedeem = request.amount;\n    }\n    if (amountSharesToRedeem == 0) revert ErrRedeemZeroShares();\n    request.amount -= uint128(amountSharesToRedeem);\n    redeemRequests[caller] = request;\n\n    uint256 cachedTotalYieldToken = totalYieldToken;\n    uint256 cachedTotalStableToken = totalStableToken;\n    uint256 cachedTotalSupply = totalSupply();\n\n    amountYieldOut = (amountSharesToRedeem * cachedTotalYieldToken) / cachedTotalSupply;\n    amountStableOut = (amountSharesToRedeem * cachedTotalStableToken) / cachedTotalSupply;\n\n    _burn(caller, amountSharesToRedeem);\n\n    if (amountYieldOut > 0) {\n      _transferOut(yieldToken, amountYieldOut, receiver);\n      unchecked {\n        totalYieldToken = cachedTotalYieldToken - amountYieldOut;\n      }\n    }\n    if (amountStableOut > 0) {\n      _transferOut(stableToken, amountStableOut, receiver);\n      unchecked {\n        totalStableToken = cachedTotalStableToken - amountStableOut;\n      }\n    }\n\n    emit Redeem(caller, receiver, amountSharesToRedeem, amountYieldOut, amountStableOut);\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function instantRedeem(\n    address receiver,\n    uint256 amountSharesToRedeem\n  ) external nonReentrant sync returns (uint256 amountYieldOut, uint256 amountStableOut) {\n    if (amountSharesToRedeem == 0) revert ErrRedeemZeroShares();\n\n    address caller = _msgSender();\n    uint256 leftover = balanceOf(caller) - redeemRequests[caller].amount;\n    if (amountSharesToRedeem > leftover) revert ErrorInsufficientFreeBalance();\n\n    uint256 cachedTotalYieldToken = totalYieldToken;\n    uint256 cachedTotalStableToken = totalStableToken;\n    uint256 cachedTotalSupply = totalSupply();\n\n    amountYieldOut = (amountSharesToRedeem * cachedTotalYieldToken) / cachedTotalSupply;\n    amountStableOut = (amountSharesToRedeem * cachedTotalStableToken) / cachedTotalSupply;\n    uint256 feeRatio = instantRedeemFeeRatio;\n\n    _burn(caller, amountSharesToRedeem);\n\n    if (amountYieldOut > 0) {\n      uint256 fee = (amountYieldOut * feeRatio) / PRECISION;\n      amountYieldOut -= fee;\n      _transferOut(yieldToken, amountYieldOut, receiver);\n      unchecked {\n        totalYieldToken = cachedTotalYieldToken - amountYieldOut;\n      }\n    }\n    if (amountStableOut > 0) {\n      uint256 fee = (amountStableOut * feeRatio) / PRECISION;\n      amountStableOut -= fee;\n      _transferOut(stableToken, amountStableOut, receiver);\n      unchecked {\n        totalStableToken = cachedTotalStableToken - amountStableOut;\n      }\n    }\n\n    emit InstantRedeem(caller, receiver, amountSharesToRedeem, amountYieldOut, amountStableOut);\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function rebalance(\n    address pool,\n    int16 tickId,\n    address tokenIn,\n    uint256 maxAmount,\n    uint256 minCollOut\n  ) external onlyValidToken(tokenIn) nonReentrant sync returns (uint256 tokenUsed, uint256 colls) {\n    RebalanceMemoryVar memory op = _beforeRebalanceOrLiquidate(tokenIn, maxAmount);\n    (op.colls, op.yieldTokenUsed, op.stableTokenUsed) = IPoolManager(poolManager).rebalance(\n      pool,\n      _msgSender(),\n      tickId,\n      op.yieldTokenToUse,\n      op.stableTokenToUse\n    );\n    tokenUsed = _afterRebalanceOrLiquidate(tokenIn, minCollOut, op);\n    colls = op.colls;\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function rebalance(\n    address pool,\n    address tokenIn,\n    uint256 maxAmount,\n    uint256 minCollOut\n  ) external onlyValidToken(tokenIn) nonReentrant sync returns (uint256 tokenUsed, uint256 colls) {\n    RebalanceMemoryVar memory op = _beforeRebalanceOrLiquidate(tokenIn, maxAmount);\n    (op.colls, op.yieldTokenUsed, op.stableTokenUsed) = IPoolManager(poolManager).rebalance(\n      pool,\n      _msgSender(),\n      op.yieldTokenToUse,\n      op.stableTokenToUse\n    );\n    tokenUsed = _afterRebalanceOrLiquidate(tokenIn, minCollOut, op);\n    colls = op.colls;\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function liquidate(\n    address pool,\n    address tokenIn,\n    uint256 maxAmount,\n    uint256 minCollOut\n  ) external onlyValidToken(tokenIn) nonReentrant sync returns (uint256 tokenUsed, uint256 colls) {\n    RebalanceMemoryVar memory op = _beforeRebalanceOrLiquidate(tokenIn, maxAmount);\n    (op.colls, op.yieldTokenUsed, op.stableTokenUsed) = IPoolManager(poolManager).liquidate(\n      pool,\n      _msgSender(),\n      op.yieldTokenToUse,\n      op.stableTokenToUse\n    );\n    tokenUsed = _afterRebalanceOrLiquidate(tokenIn, minCollOut, op);\n    colls = op.colls;\n  }\n\n  /// @inheritdoc IFxUSDBasePool\n  function arbitrage(\n    address srcToken,\n    uint256 amountIn,\n    address receiver,\n    bytes calldata data\n  ) external onlyValidToken(srcToken) onlyPegKeeper nonReentrant sync returns (uint256 amountOut, uint256 bonusOut) {\n    address dstToken;\n    uint256 expectedOut;\n    uint256 cachedTotalYieldToken = totalYieldToken;\n    uint256 cachedTotalStableToken = totalStableToken;\n    {\n      uint256 price = getStableTokenPrice();\n      uint256 scaledPrice = price * stableTokenScale;\n      if (srcToken == yieldToken) {\n        // check if usdc depeg\n        if (price < stableDepegPrice) revert ErrorStableTokenDepeg();\n        if (amountIn > cachedTotalYieldToken) revert ErrorSwapExceedBalance();\n        dstToken = stableToken;\n        unchecked {\n          // rounding up\n          expectedOut = Math.mulDivUp(amountIn, PRECISION, scaledPrice);\n          cachedTotalYieldToken -= amountIn;\n          cachedTotalStableToken += expectedOut;\n        }\n      } else {\n        if (amountIn > cachedTotalStableToken) revert ErrorSwapExceedBalance();\n        dstToken = yieldToken;\n        unchecked {\n          // rounding up\n          expectedOut = Math.mulDivUp(amountIn, scaledPrice, PRECISION);\n          cachedTotalStableToken -= amountIn;\n          cachedTotalYieldToken += expectedOut;\n        }\n      }\n    }\n    _transferOut(srcToken, amountIn, pegKeeper);\n    uint256 actualOut = IERC20(dstToken).balanceOf(address(this));\n    amountOut = IPegKeeper(pegKeeper).onSwap(srcToken, dstToken, amountIn, data);\n    actualOut = IERC20(dstToken).balanceOf(address(this)) - actualOut;\n    // check actual fxUSD swapped in case peg keeper is hacked.\n    if (amountOut > actualOut) revert ErrorInsufficientOutput();\n    // check swapped token has no loss\n    if (amountOut < expectedOut) revert ErrorInsufficientArbitrage();\n\n    totalYieldToken = cachedTotalYieldToken;\n    totalStableToken = cachedTotalStableToken;\n    bonusOut = amountOut - expectedOut;\n    if (bonusOut > 0) {\n      _transferOut(dstToken, bonusOut, receiver);\n    }\n\n    emit Arbitrage(_msgSender(), srcToken, amountIn, amountOut, bonusOut);\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update depeg price for stable token.\n  /// @param newPrice The new depeg price of stable token, multiplied by 1e18\n  function updateStableDepegPrice(uint256 newPrice) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateStableDepegPrice(newPrice);\n  }\n\n  /// @notice Update redeem cool down period.\n  /// @param newPeriod The new redeem cool down period, in seconds.\n  function updateRedeemCoolDownPeriod(uint256 newPeriod) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateRedeemCoolDownPeriod(newPeriod);\n  }\n\n  function updateInstantRedeemFeeRatio(uint256 newRatio) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateInstantRedeemFeeRatio(newRatio);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @inheritdoc ERC20Upgradeable\n  function _update(address from, address to, uint256 value) internal virtual override {\n    // make sure from don't transfer more than free balance\n    if (from != address(0) && to != address(0)) {\n      uint256 leftover = balanceOf(from) - redeemRequests[from].amount;\n      if (value > leftover) revert ErrorInsufficientFreeBalance();\n    }\n\n    super._update(from, to, value);\n  }\n\n  /// @dev Internal function to update depeg price for stable token.\n  /// @param newPrice The new depeg price of stable token, multiplied by 1e18\n  function _updateStableDepegPrice(uint256 newPrice) internal {\n    uint256 oldPrice = stableDepegPrice;\n    stableDepegPrice = newPrice;\n\n    emit UpdateStableDepegPrice(oldPrice, newPrice);\n  }\n\n  /// @dev Internal function to update redeem cool down period.\n  /// @param newPeriod The new redeem cool down period, in seconds.\n  function _updateRedeemCoolDownPeriod(uint256 newPeriod) internal {\n    if (newPeriod > 7 days) revert ErrorRedeemCoolDownPeriodTooLarge();\n\n    uint256 oldPeriod = redeemCoolDownPeriod;\n    redeemCoolDownPeriod = newPeriod;\n\n    emit UpdateRedeemCoolDownPeriod(oldPeriod, newPeriod);\n  }\n\n  /// @dev Internal function to update the instant redeem fee ratio.\n  /// @param newRatio The new instant redeem fee ratio, multiplied by 1e18.\n  function _updateInstantRedeemFeeRatio(uint256 newRatio) internal {\n    if (newRatio > MAX_INSTANT_REDEEM_FEE) revert ErrorInstantRedeemFeeTooLarge();\n\n    uint256 oldRatio = instantRedeemFeeRatio;\n    instantRedeemFeeRatio = newRatio;\n\n    emit UpdateInstantRedeemFeeRatio(oldRatio, newRatio);\n  }\n\n  /// @dev mint shares based on the deposited base tokens\n  /// @param tokenIn base token address used to mint shares\n  /// @param amountDeposited amount of base tokens deposited\n  /// @return amountSharesOut amount of shares minted\n  function _deposit(address tokenIn, uint256 amountDeposited) internal virtual returns (uint256 amountSharesOut) {\n    uint256 price = getStableTokenPriceWithScale();\n    if (price < stableDepegPrice * stableTokenScale) revert ErrorStableTokenDepeg();\n\n    uint256 amountUSD = amountDeposited;\n    if (tokenIn == stableToken) {\n      amountUSD = (amountUSD * price) / PRECISION;\n    }\n\n    uint256 cachedTotalYieldToken = totalYieldToken;\n    uint256 cachedTotalStableToken = totalStableToken;\n    uint256 totalUSD = cachedTotalYieldToken + (cachedTotalStableToken * price) / PRECISION;\n    uint256 cachedTotalSupply = totalSupply();\n    if (cachedTotalSupply == 0) {\n      amountSharesOut = amountUSD;\n    } else {\n      amountSharesOut = (amountUSD * cachedTotalSupply) / totalUSD;\n    }\n\n    if (tokenIn == stableToken) {\n      totalStableToken = cachedTotalStableToken + amountDeposited;\n    } else {\n      totalYieldToken = cachedTotalYieldToken + amountDeposited;\n    }\n  }\n\n  /// @dev Internal hook function to prepare before rebalance or liquidate.\n  /// @param tokenIn The address of input token.\n  /// @param maxAmount The maximum amount of input tokens.\n  function _beforeRebalanceOrLiquidate(\n    address tokenIn,\n    uint256 maxAmount\n  ) internal view returns (RebalanceMemoryVar memory op) {\n    op.stablePrice = getStableTokenPriceWithScale();\n    op.totalYieldToken = totalYieldToken;\n    op.totalStableToken = totalStableToken;\n\n    uint256 amountYieldToken = op.totalYieldToken;\n    uint256 amountStableToken;\n    // we always, try use fxUSD first then USDC\n    if (tokenIn == yieldToken) {\n      // user pays fxUSD\n      if (maxAmount < amountYieldToken) amountYieldToken = maxAmount;\n      else {\n        amountStableToken = ((maxAmount - amountYieldToken) * PRECISION) / op.stablePrice;\n      }\n    } else {\n      // user pays USDC\n      uint256 maxAmountInUSD = (maxAmount * op.stablePrice) / PRECISION;\n      if (maxAmountInUSD < amountYieldToken) amountYieldToken = maxAmountInUSD;\n      else {\n        amountStableToken = ((maxAmountInUSD - amountYieldToken) * PRECISION) / op.stablePrice;\n      }\n    }\n\n    if (amountStableToken > op.totalStableToken) {\n      amountStableToken = op.totalStableToken;\n    }\n\n    op.yieldTokenToUse = amountYieldToken;\n    op.stableTokenToUse = amountStableToken;\n  }\n\n  /// @dev Internal hook function after rebalance or liquidate.\n  /// @param tokenIn The address of input token.\n  /// @param minCollOut The minimum expected collateral tokens.\n  /// @param op The memory variable for rebalance or liquidate.\n  /// @return tokenUsed The amount of input token used.\n  function _afterRebalanceOrLiquidate(\n    address tokenIn,\n    uint256 minCollOut,\n    RebalanceMemoryVar memory op\n  ) internal returns (uint256 tokenUsed) {\n    if (op.colls < minCollOut) revert ErrorInsufficientOutput();\n\n    op.totalYieldToken -= op.yieldTokenUsed;\n    op.totalStableToken -= op.stableTokenUsed;\n\n    uint256 amountUSD = op.yieldTokenUsed + (op.stableTokenUsed * op.stablePrice) / PRECISION;\n    if (tokenIn == yieldToken) {\n      tokenUsed = amountUSD;\n      op.totalYieldToken += tokenUsed;\n    } else {\n      // rounding up\n      tokenUsed = Math.mulDivUp(amountUSD, PRECISION, op.stablePrice);\n      op.totalStableToken += tokenUsed;\n    }\n\n    totalYieldToken = op.totalYieldToken;\n    totalStableToken = op.totalStableToken;\n\n    // transfer token from caller, the collateral is already transferred to caller.\n    IERC20(tokenIn).safeTransferFrom(_msgSender(), address(this), tokenUsed);\n\n    emit Rebalance(_msgSender(), tokenIn, tokenUsed, op.colls, op.yieldTokenUsed, op.stableTokenUsed);\n  }\n}\n",
        "IFxUSD.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IFxUSD {\n  /**********\n   * Events *\n   **********/\n\n  /// @notice Emitted when a new market is added.\n  /// @param baseToken The address of base token of the market.\n  /// @param mintCap The mint capacity of the market.\n  event AddMarket(address indexed baseToken, uint256 mintCap);\n\n  /// @notice Emitted when the mint capacity is updated.\n  /// @param baseToken The address of base token of the market.\n  /// @param oldCap The value of previous mint capacity.\n  /// @param newCap The value of current mint capacity.\n  event UpdateMintCap(address indexed baseToken, uint256 oldCap, uint256 newCap);\n\n  /// @notice Emitted when a new rebalance pool is added.\n  /// @param baseToken The address of base token of the market.\n  /// @param pool The address of the rebalance pool.\n  event AddRebalancePool(address indexed baseToken, address indexed pool);\n\n  /// @notice Emitted when a new rebalance pool is removed.\n  /// @param baseToken The address of base token of the market.\n  /// @param pool The address of the rebalance pool.\n  event RemoveRebalancePool(address indexed baseToken, address indexed pool);\n\n  /// @notice Emitted when someone wrap fToken as fxUSD.\n  /// @param baseToken The address of base token of the market.\n  /// @param owner The address of fToken owner.\n  /// @param receiver The address of fxUSD recipient.\n  /// @param amount The amount of fxUSD minted.\n  event Wrap(address indexed baseToken, address indexed owner, address indexed receiver, uint256 amount);\n\n  /// @notice Emitted when someone unwrap fxUSD as fToken.\n  /// @param baseToken The address of base token of the market.\n  /// @param owner The address of fxUSD owner.\n  /// @param receiver The address of base token recipient.\n  /// @param amount The amount of fxUSD burned.\n  event Unwrap(address indexed baseToken, address indexed owner, address indexed receiver, uint256 amount);\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when someone tries to interact with unsupported market.\n  error ErrorUnsupportedMarket();\n\n  /// @dev Thrown when someone tries to interact with unsupported rebalance pool.\n  error ErrorUnsupportedRebalancePool();\n\n  /// @dev Thrown when someone tries to interact with market in stability mode.\n  error ErrorMarketInStabilityMode();\n\n  /// @dev Thrown when someone tries to interact with market has invalid price.\n  error ErrorMarketWithInvalidPrice();\n\n  /// @dev Thrown when someone tries to add a supported market.\n  error ErrorMarketAlreadySupported();\n\n  /// @dev Thrown when the total supply of fToken exceed mint capacity.\n  error ErrorExceedMintCap();\n\n  /// @dev Thrown when the amount of fToken is not enough for redeem.\n  error ErrorInsufficientLiquidity();\n\n  /// @dev Thrown when current is under collateral.\n  error ErrorUnderCollateral();\n\n  /// @dev Thrown when the length of two arrays is mismatch.\n  error ErrorLengthMismatch();\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @notice Return the list of supported markets.\n  function getMarkets() external view returns (address[] memory);\n\n  /// @notice Return the list of supported rebalance pools.\n  function getRebalancePools() external view returns (address[] memory);\n\n  /// @notice Return the nav of fxUSD.\n  function nav() external view returns (uint256);\n\n  /// @notice Return whether the system is under collateral.\n  function isUnderCollateral() external view returns (bool);\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @notice Wrap fToken to fxUSD.\n  /// @param baseToken The address of corresponding base token.\n  /// @param amount The amount of fToken to wrap.\n  /// @param receiver The address of fxUSD recipient.\n  function wrap(\n    address baseToken,\n    uint256 amount,\n    address receiver\n  ) external;\n\n  /// @notice Unwrap fxUSD to fToken.\n  /// @param baseToken The address of corresponding base token.\n  /// @param amount The amount of fxUSD to unwrap.\n  /// @param receiver The address of fToken recipient.\n  function unwrap(\n    address baseToken,\n    uint256 amount,\n    address receiver\n  ) external;\n\n  /// @notice Wrap fToken from rebalance pool to fxUSD.\n  /// @param pool The address of rebalance pool.\n  /// @param amount The amount of fToken to wrap.\n  /// @param receiver The address of fxUSD recipient.\n  function wrapFrom(\n    address pool,\n    uint256 amount,\n    address receiver\n  ) external;\n\n  /// @notice Mint fxUSD with base token.\n  /// @param baseToken The address of the base token.\n  /// @param amountIn The amount of base token to use.\n  /// @param receiver The address of fxUSD recipient.\n  /// @param minOut The minimum amount of fxUSD should receive.\n  /// @return amountOut The amount of fxUSD received by the receiver.\n  function mint(\n    address baseToken,\n    uint256 amountIn,\n    address receiver,\n    uint256 minOut\n  ) external returns (uint256 amountOut);\n\n  /// @notice Deposit fxUSD to rebalance pool.\n  /// @param pool The address of rebalance pool.\n  /// @param amount The amount of fxUSD to use.\n  /// @param receiver The address of rebalance pool share recipient.\n  function earn(\n    address pool,\n    uint256 amount,\n    address receiver\n  ) external;\n\n  /// @notice Mint fxUSD with base token and deposit to rebalance pool.\n  /// @param pool The address of rebalance pool.\n  /// @param amountIn The amount of base token to use.\n  /// @param receiver The address of rebalance pool recipient.\n  /// @param minOut The minimum amount of rebalance pool shares should receive.\n  /// @return amountOut The amount of rebalance pool shares received by the receiver.\n  function mintAndEarn(\n    address pool,\n    uint256 amountIn,\n    address receiver,\n    uint256 minOut\n  ) external returns (uint256 amountOut);\n\n  /// @notice Redeem fxUSD to base token.\n  /// @param baseToken The address of the base token.\n  /// @param amountIn The amount of fxUSD to redeem.\n  /// @param receiver The address of base token recipient.\n  /// @param minOut The minimum amount of base token should receive.\n  /// @return amountOut The amount of base token received by the receiver.\n  /// @return bonusOut The amount of bonus base token received by the receiver.\n  function redeem(\n    address baseToken,\n    uint256 amountIn,\n    address receiver,\n    uint256 minOut\n  ) external returns (uint256 amountOut, uint256 bonusOut);\n\n  /// @notice Redeem fToken from rebalance pool to base token.\n  /// @param amountIn The amount of fxUSD to redeem.\n  /// @param receiver The address of base token recipient.\n  /// @param minOut The minimum amount of base token should receive.\n  /// @return amountOut The amount of base token received by the receiver.\n  /// @return bonusOut The amount of bonus base token received by the receiver.\n  function redeemFrom(\n    address pool,\n    uint256 amountIn,\n    address receiver,\n    uint256 minOut\n  ) external returns (uint256 amountOut, uint256 bonusOut);\n\n  /// @notice Redeem fxUSD to base token optimally.\n  /// @param amountIn The amount of fxUSD to redeem.\n  /// @param receiver The address of base token recipient.\n  /// @param minOuts The list of minimum amount of base token should receive.\n  /// @return baseTokens The list of base token received by the receiver.\n  /// @return amountOuts The list of amount of base token received by the receiver.\n  /// @return bonusOuts The list of amount of bonus base token received by the receiver.\n  function autoRedeem(\n    uint256 amountIn,\n    address receiver,\n    uint256[] memory minOuts\n  )\n    external\n    returns (\n      address[] memory baseTokens,\n      uint256[] memory amountOuts,\n      uint256[] memory bonusOuts\n    );\n}\n",
        "LibRouter.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IMultiPathConverter } from \"../../helpers/interfaces/IMultiPathConverter.sol\";\nimport { IWrappedEther } from \"../../interfaces/IWrappedEther.sol\";\n\nlibrary LibRouter {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when use unapproved target contract.\n  error ErrorTargetNotApproved();\n\n  /// @dev Thrown when msg.value is different from amount.\n  error ErrorMsgValueMismatch();\n\n  /// @dev Thrown when the output token is not enough.\n  error ErrorInsufficientOutput();\n\n  /// @dev Thrown when the whitelisted account type is incorrect.\n  error ErrorNotWhitelisted();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The storage slot for router storage.\n  bytes32 private constant ROUTER_STORAGE_SLOT = keccak256(\"diamond.router.storage\");\n\n  /// @dev The address of WETH token.\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  uint8 internal constant NOT_FLASH_LOAN = 0;\n\n  uint8 internal constant HAS_FLASH_LOAN = 1;\n\n  uint8 internal constant NOT_ENTRANT = 0;\n\n  uint8 internal constant HAS_ENTRANT = 1;\n\n  /***********\n   * Structs *\n   ***********/\n\n  /// @param spenders Mapping from target address to token spender address.\n  /// @param approvedTargets The list of approved target contracts.\n  /// @param whitelisted The list of whitelisted contracts.\n  struct RouterStorage {\n    mapping(address => address) spenders;\n    EnumerableSet.AddressSet approvedTargets;\n    EnumerableSet.AddressSet whitelisted;\n    address revenuePool;\n    uint8 flashLoanContext;\n    uint8 reentrantContext;\n  }\n\n  /// @notice The struct for input token convert parameters.\n  ///\n  /// @param tokenIn The address of source token.\n  /// @param amount The amount of source token.\n  /// @param target The address of converter contract.\n  /// @param data The calldata passing to the target contract.\n  /// @param minOut The minimum amount of output token should receive.\n  /// @param signature The optional data for future usage.\n  struct ConvertInParams {\n    address tokenIn;\n    uint256 amount;\n    address target;\n    bytes data;\n    uint256 minOut;\n    bytes signature;\n  }\n\n  /// @notice The struct for output token convert parameters.\n  /// @param tokenOut The address of output token.\n  /// @param converter The address of converter contract.\n  /// @param encodings The encodings for `MultiPathConverter`.\n  /// @param minOut The minimum amount of output token should receive.\n  /// @param routes The convert route encodings.\n  /// @param signature The optional data for future usage.\n  struct ConvertOutParams {\n    address tokenOut;\n    address converter;\n    uint256 encodings;\n    uint256[] routes;\n    uint256 minOut;\n    bytes signature;\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Return the RouterStorage reference.\n  function routerStorage() internal pure returns (RouterStorage storage gs) {\n    bytes32 position = ROUTER_STORAGE_SLOT;\n    assembly {\n      gs.slot := position\n    }\n  }\n\n  /// @dev Approve contract to be used in token converting.\n  function approveTarget(address target, address spender) internal {\n    RouterStorage storage $ = routerStorage();\n\n    if ($.approvedTargets.add(target) && target != spender) {\n      $.spenders[target] = spender;\n    }\n  }\n\n  /// @dev Remove approve contract in token converting.\n  function removeTarget(address target) internal {\n    RouterStorage storage $ = routerStorage();\n\n    if ($.approvedTargets.remove(target)) {\n      delete $.spenders[target];\n    }\n  }\n\n  /// @dev Whitelist account with type.\n  function updateWhitelist(address account, bool status) internal {\n    RouterStorage storage $ = routerStorage();\n\n    if (status) {\n      $.whitelisted.add(account);\n    } else {\n      $.whitelisted.remove(account);\n    }\n  }\n\n  /// @dev Check whether the account is whitelisted with specific type.\n  function ensureWhitelisted(address account) internal view {\n    RouterStorage storage $ = routerStorage();\n    if (!$.whitelisted.contains(account)) {\n      revert ErrorNotWhitelisted();\n    }\n  }\n\n  function updateRevenuePool(address revenuePool) internal {\n    RouterStorage storage $ = routerStorage();\n    $.revenuePool = revenuePool;\n  }\n\n  /// @dev Transfer token into this contract and convert to `tokenOut`.\n  /// @param params The parameters used in token converting.\n  /// @param tokenOut The address of final converted token.\n  /// @return amountOut The amount of token received.\n  function transferInAndConvert(ConvertInParams memory params, address tokenOut) internal returns (uint256 amountOut) {\n    RouterStorage storage $ = routerStorage();\n    if (!$.approvedTargets.contains(params.target)) {\n      revert ErrorTargetNotApproved();\n    }\n\n    transferTokenIn(params.tokenIn, address(this), params.amount);\n\n    amountOut = IERC20(tokenOut).balanceOf(address(this));\n    if (params.tokenIn == tokenOut) return amountOut;\n\n    bool _success;\n    if (params.tokenIn == address(0)) {\n      (_success, ) = params.target.call{ value: params.amount }(params.data);\n    } else {\n      address _spender = $.spenders[params.target];\n      if (_spender == address(0)) _spender = params.target;\n\n      approve(params.tokenIn, _spender, params.amount);\n      (_success, ) = params.target.call(params.data);\n    }\n\n    // below lines will propagate inner error up\n    if (!_success) {\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        let ptr := mload(0x40)\n        let size := returndatasize()\n        returndatacopy(ptr, 0, size)\n        revert(ptr, size)\n      }\n    }\n\n    amountOut = IERC20(tokenOut).balanceOf(address(this)) - amountOut;\n  }\n\n  /// @dev Convert `tokenIn` to other token and transfer out.\n  /// @param params The parameters used in token converting.\n  /// @param tokenIn The address of token to convert.\n  /// @param amountIn The amount of token to convert.\n  /// @return amountOut The amount of token received.\n  function convertAndTransferOut(\n    ConvertOutParams memory params,\n    address tokenIn,\n    uint256 amountIn,\n    address receiver\n  ) internal returns (uint256 amountOut) {\n    RouterStorage storage $ = routerStorage();\n    if (!$.approvedTargets.contains(params.converter)) {\n      revert ErrorTargetNotApproved();\n    }\n    if (amountIn == 0) return 0;\n\n    amountOut = amountIn;\n    if (params.routes.length > 0) {\n      approve(tokenIn, params.converter, amountIn);\n      amountOut = IMultiPathConverter(params.converter).convert(tokenIn, amountIn, params.encodings, params.routes);\n    }\n    if (amountOut < params.minOut) revert ErrorInsufficientOutput();\n    if (params.tokenOut == address(0)) {\n      IWrappedEther(WETH).withdraw(amountOut);\n      Address.sendValue(payable(receiver), amountOut);\n    } else {\n      IERC20(params.tokenOut).safeTransfer(receiver, amountOut);\n    }\n  }\n\n  /// @dev Internal function to transfer token to this contract.\n  /// @param token The address of token to transfer.\n  /// @param amount The amount of token to transfer.\n  /// @return uint256 The amount of token transferred.\n  function transferTokenIn(address token, address receiver, uint256 amount) internal returns (uint256) {\n    if (token == address(0)) {\n      if (msg.value != amount) revert ErrorMsgValueMismatch();\n    } else {\n      IERC20(token).safeTransferFrom(msg.sender, receiver, amount);\n    }\n    return amount;\n  }\n\n  /// @dev Internal function to refund extra token.\n  /// @param token The address of token to refund.\n  /// @param recipient The address of the token receiver.\n  function refundERC20(address token, address recipient) internal {\n    uint256 _balance = IERC20(token).balanceOf(address(this));\n    if (_balance > 0) {\n      IERC20(token).safeTransfer(recipient, _balance);\n    }\n  }\n\n  /// @dev Internal function to approve token.\n  function approve(address token, address spender, uint256 amount) internal {\n    IERC20(token).forceApprove(spender, amount);\n  }\n}\n",
        "ReservePool.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.25;\npragma abicoder v2;\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IReservePool } from \"../interfaces/IReservePool.sol\";\n\ncontract ReservePool is AccessControl, IReservePool {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown the bonus ratio is too large.\n  error ErrorRatioTooLarge();\n\n  /// @dev Thrown when add an already added rebalance pool.\n  error ErrorRebalancePoolAlreadyAdded();\n\n  /// @dev Thrown when remove an unknown rebalance pool.\n  error ErrorRebalancePoolNotAdded();\n\n  /// @dev Thrown when the caller is not `FxOmniVault`.\n  error ErrorCallerNotPoolManager();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The address of `PoolManager` contract.\n  address public immutable poolManager;\n\n  /*************\n   * Variables *\n   *************/\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address admin, address _poolManager) {\n    poolManager = _poolManager;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc IReservePool\n  function getBalance(address token) external view returns (uint256) {\n    return _getBalance(token);\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  // solhint-disable-next-line no-empty-blocks\n  receive() external payable {}\n\n  /// @inheritdoc IReservePool\n  function requestBonus(address _token, address _recipient, uint256 _bonus) external {\n    if (_msgSender() != poolManager) revert ErrorCallerNotPoolManager();\n\n    uint256 _balance = _getBalance(_token);\n\n    if (_bonus > _balance) {\n      _bonus = _balance;\n    }\n    if (_bonus > 0) {\n      _transferToken(_token, _recipient, _bonus);\n\n      emit RequestBonus(_token, _recipient, _bonus);\n    }\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Withdraw dust assets in this contract.\n  /// @param _token The address of token to withdraw.\n  /// @param _recipient The address of token receiver.\n  function withdrawFund(address _token, uint256 amount, address _recipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _transferToken(_token, _recipient, amount);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to return the balance of the token in this contract.\n  /// @param _token The address of token to query.\n  function _getBalance(address _token) internal view returns (uint256) {\n    if (_token == address(0)) {\n      return address(this).balance;\n    } else {\n      return IERC20(_token).balanceOf(address(this));\n    }\n  }\n\n  /// @dev Internal function to transfer ETH or ERC20 tokens to some `_receiver`.\n  ///\n  /// @param _token The address of token to transfer, user `_token=address(0)` if transfer ETH.\n  /// @param _receiver The address of token receiver.\n  /// @param _amount The amount of token to transfer.\n  function _transferToken(address _token, address _receiver, uint256 _amount) internal {\n    if (_token == address(0)) {\n      Address.sendValue(payable(_receiver), _amount);\n    } else {\n      IERC20(_token).safeTransfer(_receiver, _amount);\n    }\n  }\n}\n",
        "MigrateFacet.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { IMultiPathConverter } from \"../../helpers/interfaces/IMultiPathConverter.sol\";\nimport { IBalancerVault } from \"../../interfaces/Balancer/IBalancerVault.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IPoolManager } from \"../../interfaces/IPoolManager.sol\";\nimport { IFxMarketV2 } from \"../../v2/interfaces/IFxMarketV2.sol\";\nimport { IFxUSD } from \"../../v2/interfaces/IFxUSD.sol\";\n\nimport { WordCodec } from \"../../common/codec/WordCodec.sol\";\nimport { LibRouter } from \"../libraries/LibRouter.sol\";\nimport { FlashLoanFacetBase } from \"./FlashLoanFacetBase.sol\";\n\ncontract MigrateFacet is FlashLoanFacetBase {\n  using SafeERC20 for IERC20;\n  using WordCodec for bytes32;\n\n  /**********\n   * Errors *\n   **********/\n\n  /// @dev Thrown when the amount of tokens swapped are not enough.\n  error ErrorInsufficientAmountSwapped();\n\n  /// @dev Thrown when debt ratio out of range.\n  error ErrorDebtRatioOutOfRange();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The address of USDC token.\n  address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  /// @dev The address of fxUSD token.\n  address private constant fxUSD = 0x085780639CC2cACd35E474e71f4d000e2405d8f6;\n\n  /// @dev The address of wstETH market contract.\n  address private constant wstETHMarket = 0xAD9A0E7C08bc9F747dF97a3E7E7f620632CB6155;\n\n  /// @dev The address of wstETH token.\n  address private constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n\n  /// @dev The address of fstETH token.\n  address private constant fstETH = 0xD6B8162e2fb9F3EFf09bb8598ca0C8958E33A23D;\n\n  /// @dev The address of xstETH token.\n  address private constant xstETH = 0x5a097b014C547718e79030a077A91Ae37679EfF5;\n\n  /// @dev The address of sfrxETH market contract.\n  address private constant sfrxETHMarket = 0x714B853b3bA73E439c652CfE79660F329E6ebB42;\n\n  /// @dev The address of sfrxETH token.\n  address private constant sfrxETH = 0xac3E018457B222d93114458476f3E3416Abbe38F;\n\n  /// @dev The address of ffrxETH token.\n  address private constant ffrxETH = 0xa87F04c9743Fd1933F82bdDec9692e9D97673769;\n\n  /// @dev The address of xfrxETH token.\n  address private constant xfrxETH = 0x2bb0C32101456F5960d4e994Bac183Fe0dc6C82c;\n\n  /***********************\n   * Immutable Variables *\n   ***********************/\n\n  /// @dev The address of `PoolManager` contract.\n  address private immutable poolManager;\n\n  /// @dev The address of `MultiPathConverter` contract.\n  address private immutable converter;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address _balancer, address _poolManager, address _converter) FlashLoanFacetBase(_balancer) {\n    poolManager = _poolManager;\n    converter = _converter;\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @notice Migrate xstETH to fx position.\n  /// @param pool The address of fx position pool.\n  /// @param positionId The index of position.\n  /// @param xTokenAmount The amount of xstETH to migrate.\n  /// @param borrowAmount The amount of USDC to borrow.\n  /// @param data The calldata passing to `onMigrateXstETHPosition` hook function.\n  function migrateXstETHPosition(\n    address pool,\n    uint256 positionId,\n    uint256 xTokenAmount,\n    uint256 borrowAmount,\n    bytes calldata data\n  ) external nonReentrant {\n    IERC20(xstETH).safeTransferFrom(msg.sender, address(this), xTokenAmount);\n    if (positionId > 0) {\n      IERC721(pool).transferFrom(msg.sender, address(this), positionId);\n    }\n\n    _invokeFlashLoan(\n      USDC,\n      borrowAmount,\n      abi.encodeCall(\n        MigrateFacet.onMigrateXstETHPosition,\n        (pool, positionId, xTokenAmount, borrowAmount, msg.sender, data)\n      )\n    );\n\n    // refund USDC to caller\n    LibRouter.refundERC20(USDC, LibRouter.routerStorage().revenuePool);\n  }\n\n  /// @notice Migrate xfrxETH to fx position.\n  /// @param pool The address of fx position pool.\n  /// @param positionId The index of position.\n  /// @param xTokenAmount The amount of xfrxETH to migrate.\n  /// @param borrowAmount The amount of USDC to borrow.\n  /// @param data The calldata passing to `onMigrateXfrxETHPosition` hook function.\n  function migrateXfrxETHPosition(\n    address pool,\n    uint256 positionId,\n    uint256 xTokenAmount,\n    uint256 borrowAmount,\n    bytes calldata data\n  ) external nonReentrant {\n    IERC20(xfrxETH).safeTransferFrom(msg.sender, address(this), xTokenAmount);\n    if (positionId > 0) {\n      IERC721(pool).transferFrom(msg.sender, address(this), positionId);\n    }\n\n    _invokeFlashLoan(\n      USDC,\n      borrowAmount,\n      abi.encodeCall(\n        MigrateFacet.onMigrateXfrxETHPosition,\n        (pool, positionId, xTokenAmount, borrowAmount, msg.sender, data)\n      )\n    );\n\n    // refund USDC to caller\n    LibRouter.refundERC20(USDC, LibRouter.routerStorage().revenuePool);\n  }\n\n  /// @notice Hook for `migrateXstETHPosition`.\n  /// @param pool The address of fx position pool.\n  /// @param positionId The index of position.\n  /// @param xTokenAmount The amount of xstETH to migrate.\n  /// @param borrowAmount The amount of USDC to borrow.\n  /// @param recipient The address of position holder.\n  /// @param data Hook data.\n  function onMigrateXstETHPosition(\n    address pool,\n    uint256 positionId,\n    uint256 xTokenAmount,\n    uint256 borrowAmount,\n    address recipient,\n    bytes memory data\n  ) external onlySelf {\n    uint256 fTokenAmount = (xTokenAmount * IERC20(fstETH).totalSupply()) / IERC20(xstETH).totalSupply();\n\n    // swap USDC to fxUSD\n    fTokenAmount = _swapUSDCToFxUSD(borrowAmount, fTokenAmount, data);\n\n    // unwrap fxUSD as fToken\n    IFxUSD(fxUSD).unwrap(wstETH, fTokenAmount, address(this));\n\n    uint256 wstETHAmount;\n    {\n      wstETHAmount = IFxMarketV2(wstETHMarket).redeemXToken(xTokenAmount, address(this), 0);\n      (uint256 baseOut, uint256 bonus) = IFxMarketV2(wstETHMarket).redeemFToken(fTokenAmount, address(this), 0);\n      wstETHAmount += baseOut + bonus;\n    }\n\n    // since we need to swap back to USDC, mint 0.1% more fxUSD to cover slippage.\n    fTokenAmount = (fTokenAmount * 1001) / 1000;\n\n    LibRouter.approve(wstETH, poolManager, wstETHAmount);\n    positionId = IPoolManager(poolManager).operate(pool, positionId, int256(wstETHAmount), int256(fTokenAmount));\n    _checkPositionDebtRatio(pool, positionId, abi.decode(data, (bytes32)));\n    IERC721(pool).transferFrom(address(this), recipient, positionId);\n\n    // swap fxUSD to USDC and pay debts\n    _swapFxUSDToUSDC(IERC20(fxUSD).balanceOf(address(this)), borrowAmount, data);\n  }\n\n  /// @notice Hook for `migrateXfrxETHPosition`.\n  /// @param pool The address of fx position pool.\n  /// @param positionId The index of position.\n  /// @param xTokenAmount The amount of xstETH to migrate.\n  /// @param borrowAmount The amount of USDC to borrow.\n  /// @param recipient The address of position holder.\n  /// @param data Hook data.\n  function onMigrateXfrxETHPosition(\n    address pool,\n    uint256 positionId,\n    uint256 xTokenAmount,\n    uint256 borrowAmount,\n    address recipient,\n    bytes memory data\n  ) external onlySelf {\n    uint256 fTokenAmount = (xTokenAmount * IERC20(ffrxETH).totalSupply()) / IERC20(xfrxETH).totalSupply();\n\n    // swap USDC to fxUSD\n    fTokenAmount = _swapUSDCToFxUSD(borrowAmount, fTokenAmount, data);\n\n    // unwrap fxUSD as fToken\n    IFxUSD(fxUSD).unwrap(sfrxETH, fTokenAmount, address(this));\n\n    uint256 wstETHAmount;\n    {\n      // redeem\n      wstETHAmount = IFxMarketV2(sfrxETHMarket).redeemXToken(xTokenAmount, address(this), 0);\n      (uint256 baseOut, uint256 bonus) = IFxMarketV2(sfrxETHMarket).redeemFToken(fTokenAmount, address(this), 0);\n      wstETHAmount += baseOut + bonus;\n      // swap sfrxETH to wstETH\n      wstETHAmount = _swapSfrxETHToWstETH(wstETHAmount, 0, data);\n    }\n\n    // since we need to swap back to USDC, mint 0.1% more fxUSD to cover slippage.\n    fTokenAmount = (fTokenAmount * 1001) / 1000;\n\n    LibRouter.approve(wstETH, poolManager, wstETHAmount);\n    positionId = IPoolManager(poolManager).operate(pool, positionId, int256(wstETHAmount), int256(fTokenAmount));\n    _checkPositionDebtRatio(pool, positionId, abi.decode(data, (bytes32)));\n    IERC721(pool).transferFrom(address(this), recipient, positionId);\n\n    // swap fxUSD to USDC and pay debts\n    _swapFxUSDToUSDC(IERC20(fxUSD).balanceOf(address(this)), borrowAmount, data);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to swap USDC to fxUSD.\n  /// @param amountUSDC The amount of USDC to use.\n  /// @param minFxUSD The minimum amount of fxUSD should receive.\n  /// @param data The swap route encoding.\n  /// @return amountFxUSD The amount of fxUSD received.\n  function _swapUSDCToFxUSD(\n    uint256 amountUSDC,\n    uint256 minFxUSD,\n    bytes memory data\n  ) internal returns (uint256 amountFxUSD) {\n    (, uint256 swapEncoding, uint256[] memory swapRoutes) = abi.decode(data, (bytes32, uint256, uint256[]));\n    return _swap(USDC, amountUSDC, minFxUSD, swapEncoding, swapRoutes);\n  }\n\n  /// @dev Internal function to swap fxUSD to USDC.\n  /// @param amountFxUSD The amount of fxUSD to use.\n  /// @param minUSDC The minimum amount of USDC should receive.\n  /// @param data The swap route encoding.\n  /// @return amountUSDC The amount of USDC received.\n  function _swapFxUSDToUSDC(\n    uint256 amountFxUSD,\n    uint256 minUSDC,\n    bytes memory data\n  ) internal returns (uint256 amountUSDC) {\n    (, , , uint256 swapEncoding, uint256[] memory swapRoutes) = abi.decode(\n      data,\n      (bytes32, uint256, uint256[], uint256, uint256[])\n    );\n    return _swap(fxUSD, amountFxUSD, minUSDC, swapEncoding, swapRoutes);\n  }\n\n  /// @dev Internal function to swap sfrxETH to wstETH.\n  /// @param amountSfrxETH The amount of sfrxETH to use.\n  /// @param minWstETH The minimum amount of wstETH should receive.\n  /// @param data The swap route encoding.\n  /// @return amountWstETH The amount of wstETH received.\n  function _swapSfrxETHToWstETH(\n    uint256 amountSfrxETH,\n    uint256 minWstETH,\n    bytes memory data\n  ) internal returns (uint256 amountWstETH) {\n    (, , , , , uint256 swapEncoding, uint256[] memory swapRoutes) = abi.decode(\n      data,\n      (bytes32, uint256, uint256[], uint256, uint256[], uint256, uint256[])\n    );\n    return _swap(sfrxETH, amountSfrxETH, minWstETH, swapEncoding, swapRoutes);\n  }\n\n  /// @dev Internal function to do swap.\n  /// @param token The address of input token.\n  /// @param amountIn The amount of input token.\n  /// @param minOut The minimum amount of output tokens should receive.\n  /// @param encoding The encoding for swap routes.\n  /// @param routes The swap routes to `MultiPathConverter`.\n  /// @return amountOut The amount of output tokens received.\n  function _swap(\n    address token,\n    uint256 amountIn,\n    uint256 minOut,\n    uint256 encoding,\n    uint256[] memory routes\n  ) internal returns (uint256 amountOut) {\n    LibRouter.approve(token, converter, amountIn);\n    amountOut = IMultiPathConverter(converter).convert(token, amountIn, encoding, routes);\n    if (amountOut < minOut) revert ErrorInsufficientAmountSwapped();\n  }\n\n  /// @dev Internal function to check debt ratio for the position.\n  /// @param pool The address of fx position pool.\n  /// @param positionId The index of the position.\n  /// @param miscData The encoded data for debt ratio range.\n  function _checkPositionDebtRatio(address pool, uint256 positionId, bytes32 miscData) internal view {\n    uint256 debtRatio = IPool(pool).getPositionDebtRatio(positionId);\n    uint256 minDebtRatio = miscData.decodeUint(0, 60);\n    uint256 maxDebtRatio = miscData.decodeUint(60, 60);\n    if (debtRatio < minDebtRatio || debtRatio > maxDebtRatio) {\n      revert ErrorDebtRatioOutOfRange();\n    }\n  }\n}\n"
    }
}