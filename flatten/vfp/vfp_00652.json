{
    "vfp_id": "vfp_00652",
    "project_name": "ackee-blockchain-vfat-sickle-report.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Non-contract registries can cause reverts",
            "description": "The ConnectorRegistry contract does not validate that addresses added to the customRegistries array are actual smart contracts, allowing EOAs (externally owned accounts) to be registered. When the connectorOf or hasConnector functions are called, they attempt external calls to each custom registry. While try-catch blocks are used, they do not catch reverts caused by calling functions on EOAs, which lack code and will always revert on function calls. This leads to unexpected reverts in the calling contract, disrupting normal operation and potentially causing denial of service. The root cause is the missing validation in the addCustomRegistry function, which should ensure only contract addresses are accepted. The impact is low as it requires an admin error and affects only specific functionality, but it can still impair system reliability.\n",
            "severity": "Low",
            "location": [
                "ConnectorRegistry.sol::addCustomRegistry",
                "ConnectorRegistry.sol::connectorOf",
                "ConnectorRegistry.sol::hasConnector"
            ],
            "files": [
                "sickle-public/contracts/ConnectorRegistry.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Incomplete data validation for NFT positions",
            "description": "The NftSettingsRegistry contract lacks comprehensive input validation for NFT position settings, exposing the system to misconfiguration risks. Multiple critical parameters are not validated, including tick bounds (MIN_TICK/MAX_TICK), relative ordering of trigger ticks, validity of token addresses (zero address or EOA), alignment with pool tick spacing, existence of the NFT position, and logical conflicts between autoExit and autoRebalance triggers. Additionally, there is no validation that harvest or exit tokens are valid contracts, or that pool addresses correspond to the actual NFT's pool. The root cause is insufficient defensive programming and lack of invariant enforcement. While the client partially addressed this by dismissing some validations as unnecessary, the absence of these checks increases the risk of user errors leading to ineffective or broken automation strategies. The impact is limited to individual positions and can be corrected via updates, but it reduces system robustness and user trust.\n",
            "severity": "Informational",
            "location": [
                "NftSettingsRegistry.sol"
            ],
            "files": [
                "sickle-public/contracts/NftSettingsRegistry.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Duplicate Sickle retrieval",
            "description": "The _get_sickle_by_owner function is duplicated in both NftSettingsRegistry and PositionSettingsRegistry contracts, violating the DRY (Don't Repeat Yourself) principle and increasing maintenance burden. The function performs the same logic to retrieve a Sickle instance based on owner address, but is implemented separately in two contracts. This redundancy increases the risk of inconsistent behavior if one copy is modified without updating the other, and complicates future upgrades. The root cause is poor code organization and lack of shared utility functions. While not directly exploitable, it represents a code quality issue that could indirectly lead to vulnerabilities during refactoring or extension. The recommended fix is to centralize this logic in the SickleFactory contract, but the client acknowledged the duplication as acceptable due to deployment costs.\n",
            "severity": "Informational",
            "location": [
                "NftSettingsRegistry.sol::_get_sickle_by_owner",
                "PositionSettingsRegistry.sol::_get_sickle_by_owner"
            ],
            "files": [
                "sickle-public/contracts/NftSettingsRegistry.sol",
                "sickle-public/contracts/PositionSettingsRegistry.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Potential underflow or overflow in tick range calculation",
            "description": "The validateRebalanceFor function in NftSettingsRegistry.sol calculates tick bounds using buffer values without proper bounds checking. This can lead to integer underflow when tickLower is very small (due to subtraction of bufferTicksBelow) or integer overflow when tickUpper is very large (due to addition of bufferTicksAbove). The root cause is the lack of clipping for extreme values in tick arithmetic involving int24 types. An attacker could potentially manipulate pool states or prevent rebalancing operations by triggering these arithmetic errors. This would result in a denial of service for certain rebalancing actions, undermining the protocol's automated position management. Although the impact is classified as a warning, the potential for arithmetic exceptions in critical logic paths poses a risk to system reliability.\n",
            "severity": "Informational",
            "location": [
                "NftSettingsRegistry.sol::validateRebalanceFor#125-130"
            ],
            "files": [
                "sickle-public/contracts/NftSettingsRegistry.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1109"
                ]
            },
            "title": "Variable shadowing",
            "description": "In PositionSettingsRegistry.sol, the constructor parameter `timelockAdmin` shadows the inherited storage variable of the same name from the TimelockAdmin contract. This creates confusion during code review and increases the risk of bugs if developers mistakenly believe they are accessing or modifying the storage variable when they are actually referencing the local parameter. The root cause is poor naming hygiene in constructor arguments that conflict with existing state variables. This issue also occurs in multiple functions within SickleFactory.sol where the `admin` parameter shadows a storage variable. While this does not directly enable exploitation, it degrades code clarity and maintainability, increasing the likelihood of future vulnerabilities during upgrades or modifications. The impact is primarily on code quality and long-term security posture.\n",
            "severity": "Informational",
            "location": [
                "PositionSettingsRegistry.sol::constructor",
                "SickleFactory.sol::_deploy",
                "SickleFactory.sol::_getSickle",
                "SickleFactory.sol::predict",
                "SickleFactory.sol::sickles",
                "SickleFactory.sol::admins",
                "SickleFactory.sol::getOrDeploy"
            ],
            "files": [
                "sickle-public/contracts/PositionSettingsRegistry.sol",
                "sickle-public/contracts/SickleFactory.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Insufficient data validation in the PositionSettingsRegistry contract",
            "description": "The PositionSettingsRegistry contract fails to validate critical input parameters during initialization and operation. Specifically, it does not check for zero addresses in constructor arguments or in settings such as pair, router, and stakingContract. Additionally, it does not verify relationships between interdependent parameters or ensure valid token paths when output tokens differ from pool tokens. The root cause is the absence of defensive input validation. An attacker could exploit this by deploying the contract with invalid or malicious addresses, leading to loss of funds or complete contract dysfunction. For example, setting a zero address for the router would make swaps impossible. The impact includes potential fund loss, broken functionality, and reduced trust in the system's robustness.\n",
            "severity": "Informational",
            "location": [
                "PositionSettingsRegistry.sol::constructor",
                "PositionSettingsRegistry.sol"
            ],
            "files": [
                "sickle-public/contracts/PositionSettingsRegistry.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect price calculation in PositionSettingsRegistry",
            "description": "The PositionSettingsRegistry contract calculates pool prices using getAmountOut with an amountIn of 1 wei, which can return zero due to precision loss, especially in stablecoin pools with balanced reserves. This causes the transaction to revert with InvalidPrice, disrupting functionality. The root cause is the use of an insufficiently large input amount for price estimation, combined with improper handling of edge cases. For pools like USDC/USDT, where reserves are nearly equal, swapping 1 wei returns zero output, triggering the revert. Additionally, if the return amount exceeds 1e18, the inverse calculation results in zero, also causing a revert. This leads to denial of service for price-sensitive operations. The impact is operational disruption in stable or highly volatile pools, reducing protocol reliability.\n",
            "severity": "Informational",
            "location": [
                "PositionSettingsRegistry.sol::getAmountOut#275-300"
            ],
            "files": [
                "sickle-public/contracts/PositionSettingsRegistry.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Variable naming convention",
            "description": "The _referralCodes variable in SickleFactory.sol is marked public but uses an underscore prefix, which contradicts Solidity naming conventions that reserve underscores for internal/private variables. The root cause is inconsistent adherence to naming standards. This may mislead developers into believing the variable is private when it is actually publicly accessible, increasing the risk of unintended access or incorrect assumptions during integration. While the impact is primarily on code readability and maintainability, it can indirectly contribute to security issues during future development or audits due to confusion about access levels.\n",
            "severity": "Informational",
            "location": [
                "SickleFactory.sol::_referralCodes"
            ],
            "files": [
                "sickle-public/contracts/SickleFactory.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-282"
                ],
                "3": [
                    "CWE-283"
                ]
            },
            "title": "One-step ownership transfer",
            "description": "The SickleFactory contract uses a single-step admin transfer via setAdmin, which risks permanent loss of control if the new admin address is mistyped or compromised. The root cause is the lack of a two-step ownership transfer mechanism. Although the issue was acknowledged with the justification that a multisig is used, the pattern remains risky if the admin is ever changed to a non-multisig address. A single-step transfer provides no safety window for error correction. The impact is high: a typo in the address could result in irreversible loss of administrative privileges, disabling critical functions like upgrades or emergency pauses.\n",
            "severity": "Informational",
            "location": [
                "SickleFactory.sol::setAdmin"
            ],
            "files": [
                "sickle-public/contracts/SickleFactory.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Duplicate tokens in feeTokens array can lead to inconsistent fee calculation",
            "description": "The chargeFees function in FeesLib.sol loops through a feeTokens array without deduplication. If duplicates exist, earlier fee charges alter the balance used as the basis for subsequent calculations, making fees dependent on input order. The root cause is the lack of input validation for duplicate entries. This undermines the predictability and transparency of the fee model. An attacker could manipulate the fee structure by crafting inputs with repeated tokens, potentially reducing total fees owed or creating accounting inconsistencies. The impact is financial—distorting the intended economic model—and reputational, as users cannot trust fee calculations.\n",
            "severity": "Informational",
            "location": [
                "FeesLib.sol::chargeFees#84-89",
                "FeesLib.sol::chargeFee#47-57"
            ],
            "files": [
                "sickle-public/contracts/libraries/FeesLib.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Inconsistent handling of ETH and WETH across the FeesLib contract",
            "description": "FeesLib.sol treats ETH and WETH inconsistently: chargeFee unwraps WETH and uses native balance when feeToken is ETH, but treats WETH as a regular ERC-20 when passed directly, ignoring native ETH. Conversely, getBalance returns only WETH balance for ETH queries, ignoring native ETH. The root cause is a lack of unified token handling logic. This can lead to incorrect fee calculations, especially when both ETH and WETH are present. For example, fees might be calculated on WETH only in one context but on combined ETH+WETH in another. The impact includes financial discrepancies, unexpected reverts, and potential fund loss due to miscalculated balances.\n",
            "severity": "Informational",
            "location": [
                "FeesLib.sol::chargeFee#48-56",
                "FeesLib.sol::getBalance#92-100"
            ],
            "files": [
                "sickle-public/contracts/libraries/FeesLib.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Ambiguous handling of the native value in the SwapLib contract",
            "description": "SwapLib.sol does not properly handle native ETH as an input token. The _swap function reverts when tokenIn is the zero address or ETH address due to balance checks and approvals on what is assumed to be an ERC-20. The root cause is the lack of native token wrapping logic. Although the issue was acknowledged with the note that ETH is wrapped earlier, the absence of explicit handling in SwapLib creates ambiguity and potential for misuse. If a caller bypasses pre-wrapping, the function will revert unexpectedly. The impact is functional disruption and potential denial of service for swap operations involving native ETH.\n",
            "severity": "Informational",
            "location": [
                "SwapLib.sol::_swap#49",
                "SwapLib.sol::_swap#58"
            ],
            "files": [
                "sickle-public/contracts/libraries/SwapLib.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-657"
                ]
            },
            "title": "Misleading inheritance",
            "description": "The Automation.sol contract inherits from NonDelegateMulticall, which in turn inherits from SickleStorage (an upgradeable pattern), despite Automation being non-upgradeable. This introduces unused initializers and uninitialized owner/approved roles, rendering some functions inoperable (e.g., setApproved cannot be called). The root cause is improper inheritance design, mixing upgradeable and non-upgradeable components. This creates dead code, storage bloat, and confusion about access control. The impact is reduced code clarity, increased maintenance burden, and potential for future vulnerabilities if developers assume roles are functional when they are not.\n",
            "severity": "Informational",
            "location": [
                "Automation.sol",
                "NonDelegateMulticall.sol"
            ],
            "files": [
                "sickle-public/contracts/Automation.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "No input array length validation",
            "description": "The setConnectors, updateConnectors (in ConnectorRegistry.sol), and multicall functions in Automation.sol (e.g., harvestFor, compoundFor) accept multiple arrays that must be of equal length but lack validation. The root cause is missing require checks for array lengths. This can lead to out-of-bounds runtime panics if arrays are mismatched. An attacker or erroneous caller could trigger a denial of service by providing arrays of different lengths. The impact is operational disruption, especially in batch operations critical to automation, potentially freezing protocol functions that rely on these multicalls.\n",
            "severity": "Informational",
            "location": [
                "ConnectorRegistry.sol::setConnectors",
                "ConnectorRegistry.sol::updateConnectors",
                "Automation.sol::harvestFor#178-192",
                "Automation.sol::compoundFor#286-302"
            ],
            "files": [
                "sickle-public/contracts/ConnectorRegistry.sol",
                "sickle-public/contracts/Automation.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "No data validation on registry adding and updates",
            "description": "The addCustomRegistry and updateCustomRegistry functions in ConnectorRegistry.sol lack critical validations: no duplicate checks, no zero address checks, and no bounds checking on indices. This allows duplicate entries and out-of-bounds access, leading to inconsistent state where a registry may be in the array but marked as not custom. The root cause is insufficient input validation in admin functions. Although partially fixed with duplicate checks, the lack of full on-chain validation increases risk. The impact includes state corruption, potential for unauthorized registry manipulation, and unreliable lookups, undermining the integrity of the registry system.\n",
            "severity": "Informational",
            "location": [
                "ConnectorRegistry.sol::addCustomRegistry",
                "ConnectorRegistry.sol::updateCustomRegistry"
            ],
            "files": [
                "sickle-public/contracts/ConnectorRegistry.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing zero address validation",
            "description": "Multiple contracts, including SickleFactory, ConnectorRegistry, SickleMultisig, NftSettingsRegistry, Automation, PositionSettingsRegistry, FeesLib, SwapLib, and TransferLib, lack zero address checks in constructors and critical functions. The root cause is the omission of basic defensive programming practices. Setting a zero address for critical dependencies (e.g., router, registry, WETH) would permanently break contract functionality. The impact is high: accidental or malicious use of zero addresses could lead to irreversible loss of functionality, fund locking, or governance paralysis. While acknowledged as handled off-chain, on-chain validation is a critical safety net.\n",
            "severity": "Informational",
            "location": [
                "SickleFactory.sol::constructor",
                "ConnectorRegistry.sol::constructor",
                "SickleMultisig.sol::constructor",
                "SickleMultisig.sol::_addSigner",
                "NftSettingsRegistry.sol::constructor",
                "Automation.sol::constructor",
                "PositionSettingsRegistry.sol::constructor",
                "FeesLib.sol::constructor",
                "SwapLib.sol::constructor",
                "TransferLib.sol::constructor"
            ],
            "files": [
                "sickle-public/contracts/SickleFactory.sol",
                "sickle-public/contracts/ConnectorRegistry.sol",
                "sickle-public/contracts/SickleMultisig.sol",
                "sickle-public/contracts/NftSettingsRegistry.sol",
                "sickle-public/contracts/Automation.sol",
                "sickle-public/contracts/PositionSettingsRegistry.sol",
                "sickle-public/contracts/libraries/FeesLib.sol",
                "sickle-public/contracts/libraries/SwapLib.sol",
                "sickle-public/contracts/libraries/TransferLib.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Duplicate code",
            "description": "The ConnectorRegistry contract contains duplicate logic in connectorOf and hasConnector functions, which both iterate to find a connector but return different values. The root cause is lack of code reuse through internal helper functions. This increases code size, maintenance burden, and the risk of inconsistent fixes. While not directly exploitable, it violates the DRY principle and can lead to bugs if one function is updated and the other is not. The impact is reduced code quality and increased technical debt, making audits and upgrades more error-prone.\n",
            "severity": "Informational",
            "location": [
                "ConnectorRegistry.sol::connectorOf",
                "ConnectorRegistry.sol::hasConnector"
            ],
            "files": [
                "sickle-public/contracts/ConnectorRegistry.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Redundant storage variable",
            "description": "The approvedAutomatorsLength variable in Automation.sol redundantly stores the length of the approvedAutomators array, which can be obtained via approvedAutomators.length. The root cause is unnecessary state variable usage. This wastes gas on updates and increases storage costs. Additionally, the _setApprovedAutomator function lacks a check for duplicate entries. The impact is increased transaction costs and potential for duplicate entries in the list, leading to inefficiencies and possible logic errors in access control checks.\n",
            "severity": "Informational",
            "location": [
                "Automation.sol::approvedAutomatorsLength",
                "Automation.sol::_setApprovedAutomator"
            ],
            "files": [
                "sickle-public/contracts/Automation.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Mapping isCustomRegistry is redundant",
            "description": "The isCustomRegistry mapping in ConnectorRegistry.sol is never read and only updated during registry additions and updates. The active state is already reflected in the customRegistries array, and removals are logged via events. The root cause is redundant state tracking. This wastes storage and increases gas costs. The impact is inefficient use of blockchain resources and unnecessary complexity. Removing it simplifies the contract and reduces attack surface, as confirmed by the fix that replaced it with a derived function.\n",
            "severity": "Informational",
            "location": [
                "ConnectorRegistry.sol::isCustomRegistry"
            ],
            "files": [
                "sickle-public/contracts/ConnectorRegistry.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Inconsistent function naming convention",
            "description": "The NftSettingsRegistry.sol and PositionSettingsRegistry.sol contracts use snake_case for internal function names (e.g., _get_sickle_by_owner), violating Solidity's camelCase convention. The root cause is inconsistent style adherence. This reduces code readability and professionalism, making the codebase harder to navigate for developers familiar with standard practices. While not a security risk, it impacts maintainability and collaboration. The impact is on code quality and long-term project sustainability, increasing the cognitive load during reviews and audits.\n",
            "severity": "Informational",
            "location": [
                "NftSettingsRegistry.sol::_get_sickle_by_owner",
                "NftSettingsRegistry.sol::_set_nft_settings",
                "NftSettingsRegistry.sol::_unset_nft_settings",
                "NftSettingsRegistry.sol::_check_rebalance_config",
                "NftSettingsRegistry.sol::_check_tick_width",
                "PositionSettingsRegistry.sol::_check_reward_config",
                "PositionSettingsRegistry.sol::_get_sickle_by_owner",
                "PositionSettingsRegistry.sol::_get_pool_price"
            ],
            "files": [
                "sickle-public/contracts/NftSettingsRegistry.sol",
                "sickle-public/contracts/PositionSettingsRegistry.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typographical error in function comment",
            "description": "The NftSettingsRegistry.sol contract contains a typographical error in the comment for the _check_rebalance_config function, where \"configuratgion\" is incorrectly spelled instead of \"configuration.\" The cause is a simple typographical mistake in a code comment. This issue cannot be exploited as it pertains only to a comment and does not affect runtime behavior or security. The impact is purely informational, affecting code readability and professionalism but not functionality or security.\n",
            "severity": "Informational",
            "location": [
                "NftSettingsRegistry.sol"
            ],
            "files": [
                "sickle-public/contracts/NftSettingsRegistry.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused errors",
            "description": "The NftSettingsRegistry.sol contract defines two custom errors, CompoundOrHarvestNotSet and CompoundAndHarvestBothSet, which are not used anywhere in the codebase. The cause is that these errors were likely defined in anticipation of use but were never actually referenced, resulting in dead code. Unused errors cannot be triggered and thus pose no exploit risk. The impact is minimal, limited to increased bytecode size and reduced code clarity, but no security risk.\n",
            "severity": "Informational",
            "location": [
                "NftSettingsRegistry.sol#35-36"
            ],
            "files": [
                "sickle-public/contracts/NftSettingsRegistry.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing duplicate registry validation",
            "description": "The ConnectorRegistry contract does not validate for duplicate entries when adding or updating custom registries, allowing the same address to be added multiple times. The cause is lack of input validation in the addCustomRegistry and updateCustomRegistry functions. An attacker or user could repeatedly add the same registry, increasing gas costs for future iterations over the array. This leads to inefficient gas usage and potential denial-of-service via bloating, though the severity is low as it does not compromise security directly.\n",
            "severity": "Informational",
            "location": [
                "ConnectorRegistry.sol::addCustomRegistry",
                "ConnectorRegistry.sol::updateCustomRegistry"
            ],
            "files": [
                "sickle-public/contracts/ConnectorRegistry.sol"
            ]
        }
    ],
    "affected_files": {
        "Automation.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IUniswapV3Pool } from\n    \"contracts/interfaces/external/uniswap/IUniswapV3Pool.sol\";\n\nimport { Admin } from \"contracts/base/Admin.sol\";\nimport { NonDelegateMulticall } from \"contracts/base/NonDelegateMulticall.sol\";\nimport { Sickle } from \"contracts/Sickle.sol\";\nimport { SickleRegistry } from \"contracts/SickleRegistry.sol\";\nimport { IAutomation } from \"contracts/interfaces/IAutomation.sol\";\nimport { INftAutomation } from \"contracts/interfaces/INftAutomation.sol\";\nimport {\n    NftRebalance,\n    NftPosition,\n    NftHarvest,\n    NftWithdraw,\n    NftCompound\n} from \"contracts/structs/NftFarmStrategyStructs.sol\";\nimport {\n    Farm,\n    HarvestParams,\n    WithdrawParams,\n    CompoundParams\n} from \"contracts/structs/FarmStrategyStructs.sol\";\n\n// @title Automation contract for automating farming strategies\n// @notice This contract allows users to automate their farming strategies\n// by enabling auto-compound or auto-harvest for non-NFT positions.\n// Only one of Auto-Compound or Auto-Harvest can be enabled:\n// all user positions will be either auto-compounded or auto-harvested.\n// For NFT positions, all automation settings are handled by NftSettingsRegistry\n// instead.\n// The contract also allows an approved automator to compound, harvest, exit or\n// rebalance farming positions on behalf of users.\n// @dev This contract is expected to be used by an external automation bot\n// that will call the compoundFor, harvestFor, and rebalanceFor functions.\n// The automation bot is expected to be the EOA of the approved automator.\n// The approved automator is set by the protocol admin.\ncontract Automation is Admin, NonDelegateMulticall {\n    error InvalidInputLength();\n    error NotApprovedAutomator();\n\n    event HarvestedFor(\n        Sickle indexed sickle,\n        address indexed stakingContract,\n        uint256 indexed poolIndex\n    );\n    event CompoundedFor(\n        Sickle indexed sickle,\n        address indexed claimStakingContract,\n        uint256 claimPoolIndex,\n        address indexed depositStakingContract,\n        uint256 depositPoolIndex\n    );\n    event ExitedFor(\n        Sickle indexed sickle,\n        address indexed stakingContract,\n        uint256 indexed poolIndex\n    );\n\n    event NftHarvestedFor(\n        Sickle indexed sickle,\n        address indexed nftAddress,\n        uint256 indexed tokenId\n    );\n    event NftCompoundedFor(\n        Sickle indexed sickle,\n        address indexed nftAddress,\n        uint256 indexed tokenId\n    );\n    event NftExitedFor(\n        Sickle indexed sickle,\n        address indexed nftAddress,\n        uint256 indexed tokenId\n    );\n    event NftRebalancedFor(\n        Sickle indexed sickle,\n        address indexed nftAddress,\n        uint256 indexed tokenId\n    );\n    event ApprovedAutomatorSet(address approvedAutomator);\n\n    address payable public approvedAutomator;\n\n    constructor(\n        SickleRegistry registry_,\n        address payable approvedAutomator_,\n        address admin_\n    ) Admin(admin_) NonDelegateMulticall(registry_) {\n        approvedAutomator = approvedAutomator_;\n    }\n\n    modifier onlyApprovedAutomator() {\n        if (msg.sender != approvedAutomator) revert NotApprovedAutomator();\n        _;\n    }\n\n    // Admin functions\n\n    /// @notice Update approved automator address.\n    /// @dev Controls which external address is allowed to\n    /// compound farming positions for Sickles. This is expected to be the EOA\n    /// of an automation bot.\n    /// @custom:access Restricted to protocol admin.\n    function setApprovedAutomator(\n        address payable approvedAutomator_\n    ) external onlyAdmin {\n        approvedAutomator = approvedAutomator_;\n        emit ApprovedAutomatorSet(approvedAutomator_);\n    }\n\n    // Automator functions\n\n    function compoundFor(\n        IAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        CompoundParams[] memory params,\n        address[][] memory sweepTokens\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != params.length\n                || strategiesLength != sweepTokens.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            Sickle sickle = sickles[i];\n            CompoundParams memory param = params[i];\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                IAutomation.compoundFor, (sickle, param, sweepTokens[i])\n            );\n            emit CompoundedFor(\n                sickle,\n                param.claimFarm.stakingContract,\n                param.claimFarm.poolIndex,\n                param.depositFarm.stakingContract,\n                param.depositFarm.poolIndex\n            );\n        }\n        this.multicall(targets, data);\n    }\n\n    function harvestFor(\n        IAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        Farm[] memory farms,\n        HarvestParams[] memory params,\n        address[][] memory sweepTokens\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != params.length\n                || strategiesLength != sweepTokens.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            Sickle sickle = sickles[i];\n            Farm memory farm = farms[i];\n            HarvestParams memory param = params[i];\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                IAutomation.harvestFor, (sickle, farm, param, sweepTokens[i])\n            );\n            emit HarvestedFor(sickle, farm.stakingContract, farm.poolIndex);\n        }\n        this.multicall(targets, data);\n    }\n\n    function exitFor(\n        IAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        Farm[] memory farms,\n        HarvestParams[] memory harvestParams,\n        address[][] memory harvestSweepTokens,\n        WithdrawParams[] memory withdrawParams,\n        address[][] memory withdrawSweepTokens\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != farms.length\n                || strategiesLength != harvestParams.length\n                || strategiesLength != withdrawParams.length\n                || strategiesLength != harvestSweepTokens.length\n                || strategiesLength != withdrawSweepTokens.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                IAutomation.exitFor,\n                (\n                    sickles[i],\n                    farms[i],\n                    harvestParams[i],\n                    harvestSweepTokens[i],\n                    withdrawParams[i],\n                    withdrawSweepTokens[i]\n                )\n            );\n            emit ExitedFor(\n                sickles[i], farms[i].stakingContract, farms[i].poolIndex\n            );\n        }\n        this.multicall(targets, data);\n    }\n\n    // NFT Automator functions\n    // Validation is done in the NftAutomation contract\n\n    function harvestFor(\n        INftAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        NftPosition[] memory positions,\n        NftHarvest[] memory params\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != positions.length\n                || strategiesLength != params.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            Sickle sickle = sickles[i];\n            NftPosition memory position = positions[i];\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                INftAutomation.harvestFor, (sickle, position, params[i])\n            );\n            emit NftHarvestedFor(\n                sickle, address(position.nft), position.tokenId\n            );\n        }\n        this.multicall(targets, data);\n    }\n\n    function compoundFor(\n        INftAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        NftPosition[] memory positions,\n        NftCompound[] memory params,\n        bool[] memory inPlace,\n        address[][] memory sweepTokens\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != positions.length\n                || strategiesLength != params.length\n                || strategiesLength != sweepTokens.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            Sickle sickle = sickles[i];\n            NftPosition memory position = positions[i];\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                INftAutomation.compoundFor,\n                (sickle, position, params[i], inPlace[i], sweepTokens[i])\n            );\n            emit NftCompoundedFor(\n                sickle, address(position.nft), position.tokenId\n            );\n        }\n        this.multicall(targets, data);\n    }\n\n    function exitFor(\n        INftAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        NftPosition[] memory positions,\n        NftHarvest[] memory harvestParams,\n        NftWithdraw[] memory withdrawParams,\n        address[][] memory sweepTokens\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != positions.length\n                || strategiesLength != harvestParams.length\n                || strategiesLength != withdrawParams.length\n                || strategiesLength != sweepTokens.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            Sickle sickle = sickles[i];\n            NftPosition memory position = positions[i];\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                INftAutomation.exitFor,\n                (\n                    sickle,\n                    position,\n                    harvestParams[i],\n                    withdrawParams[i],\n                    sweepTokens[i]\n                )\n            );\n            emit NftExitedFor(sickle, address(position.nft), position.tokenId);\n        }\n        this.multicall(targets, data);\n    }\n\n    function rebalanceFor(\n        INftAutomation[] memory strategies,\n        Sickle[] memory sickles,\n        NftRebalance[] memory params,\n        address[][] memory sweepTokens\n    ) external onlyApprovedAutomator {\n        uint256 strategiesLength = strategies.length;\n        if (\n            strategiesLength != sickles.length\n                || strategiesLength != params.length\n                || strategiesLength != sweepTokens.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        address[] memory targets = new address[](strategiesLength);\n        bytes[] memory data = new bytes[](strategiesLength);\n        for (uint256 i; i < strategiesLength; i++) {\n            NftRebalance memory param = params[i];\n            Sickle sickle = sickles[i];\n            targets[i] = address(strategies[i]);\n            data[i] = abi.encodeCall(\n                INftAutomation.rebalanceFor, (sickle, param, sweepTokens[i])\n            );\n            emit NftRebalancedFor(\n                sickle, address(param.position.nft), param.position.tokenId\n            );\n        }\n        this.multicall(targets, data);\n    }\n}\n",
        "TransferLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { MsgValueModule } from \"contracts/modules/MsgValueModule.sol\";\nimport { WETH } from \"lib/solmate/src/tokens/WETH.sol\";\nimport { Sickle } from \"contracts/Sickle.sol\";\nimport { SafeTransferLib } from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { IERC20 } from\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport { IFeesLib } from \"contracts/interfaces/libraries/IFeesLib.sol\";\nimport { DelegateModule } from \"contracts/modules/DelegateModule.sol\";\nimport { ITransferLib } from \"contracts/interfaces/libraries/ITransferLib.sol\";\n\ncontract TransferLib is MsgValueModule, DelegateModule, ITransferLib {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    WETH public immutable weth;\n\n    IFeesLib public immutable feesLib;\n\n    constructor(IFeesLib feesLib_, WETH weth_) {\n        feesLib = feesLib_;\n        weth = weth_;\n    }\n\n    /// @dev Transfers the balance of {token} from the contract to the\n    /// sickle owner\n    /// @param token Address of the token to transfer\n    function transferTokenToUser(\n        address token\n    ) public payable checkTransferTo(token) {\n        address recipient = Sickle(payable(address(this))).owner();\n        if (token == ETH) {\n            uint256 wethBalance = weth.balanceOf(address(this));\n            if (wethBalance > 0) {\n                weth.withdraw(wethBalance);\n            }\n            if (address(this).balance > 0) {\n                SafeTransferLib.safeTransferETH(\n                    recipient, address(this).balance\n                );\n            }\n        } else {\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance > 0) {\n                SafeTransferLib.safeTransfer(token, recipient, balance);\n            }\n        }\n    }\n\n    /// @dev Transfers all balances of {tokens} and/or ETH from the contract\n    /// to the sickle owner\n    /// @param tokens An array of token addresses\n    function transferTokensToUser(\n        address[] memory tokens\n    ) external payable checkTransfersTo(tokens) {\n        for (uint256 i; i != tokens.length;) {\n            transferTokenToUser(tokens[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @dev Transfers {amountIn} of {tokenIn} from the user to the Sickle\n    /// contract, charging the fees and converting the amount to WETH if\n    /// necessary\n    /// @param tokenIn Address of the token to transfer\n    /// @param amountIn Amount of the token to transfer\n    /// @param strategy Address of the caller strategy\n    /// @param feeSelector Selector of the caller function\n    function transferTokenFromUser(\n        address tokenIn,\n        uint256 amountIn,\n        address strategy,\n        bytes4 feeSelector\n    ) public payable checkTransferFrom(tokenIn, amountIn) {\n        _checkMsgValue(amountIn, tokenIn == ETH);\n\n        _transferTokenFromUser(tokenIn, amountIn, strategy, feeSelector);\n    }\n\n    /// @dev Transfers {amountIn} of {tokenIn} from the user to the Sickle\n    /// contract, charging the fees and converting the amount to WETH if\n    /// necessary\n    /// @param tokensIn Addresses of the tokens to transfer\n    /// @param amountsIn Amounts of the tokens to transfer\n    /// @param strategy Address of the caller strategy\n    /// @param feeSelector Selector of the caller function\n    function transferTokensFromUser(\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        address strategy,\n        bytes4 feeSelector\n    ) external payable checkTransfersFrom(tokensIn, amountsIn) {\n        bool hasEth = false;\n\n        for (uint256 i; i < tokensIn.length; i++) {\n            if (tokensIn[i] == ETH) {\n                _checkMsgValue(amountsIn[i], true);\n                hasEth = true;\n            }\n            _transferTokenFromUser(\n                tokensIn[i], amountsIn[i], strategy, feeSelector\n            );\n        }\n\n        if (!hasEth) {\n            // Revert if ETH was sent but not used\n            _checkMsgValue(0, false);\n        }\n    }\n\n    /* Internal functions */\n\n    function _transferTokenFromUser(\n        address tokenIn,\n        uint256 amountIn,\n        address strategy,\n        bytes4 feeSelector\n    ) internal {\n        if (tokenIn != ETH) {\n            SafeTransferLib.safeTransferFrom(\n                tokenIn,\n                Sickle(payable(address(this))).owner(),\n                address(this),\n                amountIn\n            );\n        }\n\n        bytes memory result = _delegateTo(\n            address(feesLib),\n            abi.encodeCall(\n                IFeesLib.chargeFee, (strategy, feeSelector, tokenIn, 0)\n            )\n        );\n        uint256 remainder = abi.decode(result, (uint256));\n\n        if (tokenIn == ETH) {\n            weth.deposit{ value: remainder }();\n        }\n    }\n\n    modifier checkTransferFrom(address tokenIn, uint256 amountIn) {\n        if (tokenIn == address(0)) {\n            revert TokenInRequired();\n        }\n        if (amountIn == 0) {\n            revert AmountInRequired();\n        }\n        _;\n    }\n\n    modifier checkTransfersFrom(\n        address[] memory tokensIn,\n        uint256[] memory amountsIn\n    ) {\n        uint256 tokenLength = tokensIn.length;\n        if (tokenLength != amountsIn.length) {\n            revert ArrayLengthMismatch();\n        }\n        if (tokenLength == 0) {\n            revert TokenInRequired();\n        }\n        for (uint256 i; i < tokenLength; i++) {\n            if (tokensIn[i] == address(0)) {\n                revert TokenInRequired();\n            }\n            if (amountsIn[i] == 0) {\n                revert AmountInRequired();\n            }\n        }\n        if (tokenLength == 2 && tokensIn[0] == tokensIn[1]) {\n            revert SameTokenIn();\n        }\n        if (tokenLength > 2) {\n            revert TwoTokenMaximum();\n        }\n        _;\n    }\n\n    modifier checkTransferTo(\n        address tokenOut\n    ) {\n        if (tokenOut == address(0)) {\n            revert TokenOutRequired();\n        }\n        _;\n    }\n\n    modifier checkTransfersTo(\n        address[] memory tokensOut\n    ) {\n        uint256 tokenLength = tokensOut.length;\n        if (tokenLength == 0) {\n            revert TokenOutRequired();\n        }\n        for (uint256 i; i < tokenLength; i++) {\n            if (tokensOut[i] == address(0)) {\n                revert TokenOutRequired();\n            }\n        }\n        _;\n    }\n}\n",
        "FeesLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { WETH } from \"solmate/tokens/WETH.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Sickle } from \"contracts/Sickle.sol\";\nimport { SickleRegistry } from \"contracts/SickleRegistry.sol\";\nimport { IFeesLib } from \"contracts/interfaces/libraries/IFeesLib.sol\";\n\ncontract FeesLib is IFeesLib {\n    /// @notice Fees library version\n    uint256 public constant VERSION = 1;\n\n    /// @notice Sickle registry address\n    SickleRegistry public immutable registry;\n\n    /// @notice WETH9 token address\n    WETH public immutable weth;\n\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    constructor(SickleRegistry registry_, WETH weth_) {\n        registry = registry_;\n        weth = weth_;\n    }\n\n    /**\n     * @notice Strategy contract charges fee to user depending on the type of\n     * action and sends funds to the collector address\n     * @param strategy Address of the strategy contract\n     * @param feeDescriptor Descriptor of the fee to be charged\n     * @param feeToken Address of the token from which an amount will be\n     * @param feeBasis Amount to be charged (zero if on full amount)\n     * charged (zero address if native token)\n     */\n    function chargeFee(\n        address strategy,\n        bytes4 feeDescriptor,\n        address feeToken,\n        uint256 feeBasis\n    ) public payable returns (uint256 remainder) {\n        uint256 fee = registry.feeRegistry(\n            keccak256(abi.encodePacked(strategy, feeDescriptor))\n        );\n\n        if (feeBasis == 0) {\n            if (feeToken == ETH) {\n                uint256 wethBalance = weth.balanceOf(address(this));\n                if (wethBalance > 0) {\n                    weth.withdraw(wethBalance);\n                }\n                feeBasis = address(this).balance;\n            } else {\n                feeBasis = IERC20(feeToken).balanceOf(address(this));\n            }\n        }\n\n        uint256 amountToCharge = feeBasis * fee / 10_000;\n\n        if (amountToCharge == 0) {\n            return feeBasis;\n        }\n\n        if (feeToken == ETH) {\n            SafeTransferLib.safeTransferETH(\n                registry.collector(), amountToCharge\n            );\n        } else {\n            SafeTransferLib.safeTransfer(\n                feeToken, registry.collector(), amountToCharge\n            );\n        }\n\n        emit FeeCharged(strategy, feeDescriptor, amountToCharge, feeToken);\n        return feeBasis - amountToCharge;\n    }\n\n    function chargeFees(\n        address strategy,\n        bytes4 feeDescriptor,\n        address[] memory feeTokens\n    ) external payable {\n        for (uint256 i = 0; i < feeTokens.length;) {\n            chargeFee(strategy, feeDescriptor, feeTokens[i], 0);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function getBalance(\n        Sickle sickle,\n        address token\n    ) public view returns (uint256) {\n        if (token == ETH) {\n            return weth.balanceOf(address(sickle));\n        }\n        return IERC20(token).balanceOf(address(sickle));\n    }\n}\n",
        "NftSettingsRegistry.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {\n    IUniswapV3Pool,\n    IUniswapV3PoolState,\n    IUniswapV3PoolImmutables\n} from \"contracts/interfaces/external/uniswap/IUniswapV3Pool.sol\";\nimport { INonfungiblePositionManager } from\n    \"contracts/interfaces/external/uniswap/INonfungiblePositionManager.sol\";\n\nimport { Sickle } from \"contracts/Sickle.sol\";\nimport { INftSettingsRegistry } from\n    \"contracts/interfaces/INftSettingsRegistry.sol\";\nimport {\n    RewardBehavior,\n    RewardConfig\n} from \"contracts/structs/PositionSettingsStructs.sol\";\nimport {\n    NftKey,\n    NftSettings,\n    ExitConfig,\n    RebalanceConfig\n} from \"contracts/structs/NftSettingsStructs.sol\";\nimport { SickleFactory } from \"contracts/SickleFactory.sol\";\n\ninterface IPreviousAutomation {\n    function rewardAutomation(\n        address user\n    ) external returns (RewardBehavior);\n    function harvestTokensOut(\n        address user\n    ) external returns (address);\n}\n\ninterface IPreviousNftSettingsRegistry {\n    struct PreviousRebalanceConfig {\n        int24 bufferTicksBelow;\n        int24 bufferTicksAbove;\n        uint256 slippageBP;\n        int24 cutoffTickLow;\n        int24 cutoffTickHigh;\n        uint8 delayMin;\n    }\n\n    struct PreviousNftSettings {\n        bool autoRebalance;\n        RewardBehavior rewardBehavior;\n        address harvestTokenOut;\n        PreviousRebalanceConfig rebalanceConfig;\n    }\n\n    function getNftSettings(\n        NftKey memory key\n    ) external returns (PreviousNftSettings memory);\n}\n\ncontract NftSettingsRegistry is INftSettingsRegistry {\n    error AutoHarvestNotSet();\n    error AutoCompoundNotSet();\n    error AutoRebalanceNotSet();\n    error AutoExitNotSet();\n    error CompoundOrHarvestNotSet();\n    error CompoundAndHarvestBothSet();\n    error ExitTriggersNotSet();\n    error InvalidTokenOut();\n    error InvalidMinMaxTickRange();\n    error InvalidSlippageBP();\n    error InvalidPriceImpactBP();\n    error InvalidDustBP();\n    error InvalidMinTickLow();\n    error InvalidMaxTickHigh();\n    error OnlySickle();\n    error RebalanceConfigNotSet();\n    error TickWithinRange();\n    error TickOutsideStopLossRange();\n    error SickleNotDeployed();\n    error InvalidWidth(uint24 actual, uint24 expected);\n\n    event NftSettingsSet(NftKey key, NftSettings settings);\n    event NftSettingsUnset(NftKey key);\n\n    uint256 constant MAX_SLIPPAGE_BP = 500;\n    uint256 constant MAX_PRICE_IMPACT_BP = 5000;\n    uint256 constant MAX_DUST_BP = 5000;\n    int24 constant MAX_TICK = 887_272;\n    int24 constant MIN_TICK = -MAX_TICK;\n\n    SickleFactory public immutable factory;\n\n    constructor(\n        SickleFactory _factory\n    ) {\n        factory = _factory;\n    }\n\n    mapping(bytes32 => NftSettings) settingsMap;\n\n    /* Public functions */\n\n    function getNftSettings(\n        NftKey memory key\n    ) public view returns (NftSettings memory) {\n        return settingsMap[keccak256(abi.encode(key))];\n    }\n\n    function validateHarvestFor(\n        NftKey memory key\n    ) public view {\n        NftSettings memory settings = getNftSettings(key);\n        if (\n            !settings.automateRewards\n                || settings.rewardConfig.rewardBehavior != RewardBehavior.Harvest\n        ) {\n            revert AutoHarvestNotSet();\n        }\n    }\n\n    function validateCompoundFor(\n        NftKey memory key\n    ) public view {\n        NftSettings memory settings = getNftSettings(key);\n        if (\n            !settings.automateRewards\n                || settings.rewardConfig.rewardBehavior != RewardBehavior.Compound\n        ) {\n            revert AutoCompoundNotSet();\n        }\n    }\n\n    // Validate that a rebalanceFor meets the user requirements\n    function validateRebalanceFor(\n        NftKey memory key\n    ) public {\n        NftSettings memory settings = getNftSettings(key);\n        RebalanceConfig memory config = settings.rebalanceConfig;\n\n        if (!settings.autoRebalance) {\n            revert AutoRebalanceNotSet();\n        }\n        if (config.cutoffTickLow == 0) {\n            revert RebalanceConfigNotSet();\n        }\n\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) =\n            key.nftManager.positions(key.tokenId);\n\n        int24 tick = _get_current_tick(settings.pool);\n\n        if (\n            tick >= tickLower - int24(config.bufferTicksBelow)\n                && tick < tickUpper + int24(config.bufferTicksAbove)\n        ) {\n            revert TickWithinRange();\n        }\n        if (tick <= config.cutoffTickLow || tick >= config.cutoffTickHigh) {\n            revert TickOutsideStopLossRange();\n        }\n    }\n\n    function validateExitFor(\n        NftKey memory key\n    ) public {\n        NftSettings memory settings = getNftSettings(key);\n        ExitConfig memory config = settings.exitConfig;\n\n        if (!settings.autoExit) {\n            revert AutoExitNotSet();\n        }\n\n        int24 tick = _get_current_tick(settings.pool);\n\n        if (tick >= config.triggerTickLow && tick < config.triggerTickHigh) {\n            revert TickWithinRange();\n        }\n    }\n\n    /* Sickle Owner functions */\n\n    function setNftSettings(\n        INonfungiblePositionManager nftManager,\n        uint256 tokenId,\n        NftSettings calldata settings\n    ) external {\n        Sickle sickle = _get_sickle_by_owner(msg.sender);\n        NftKey memory key = NftKey(sickle, nftManager, tokenId);\n        _set_nft_settings(key, settings);\n    }\n\n    function unsetNftSettings(\n        INonfungiblePositionManager nftManager,\n        uint256 tokenId\n    ) external {\n        Sickle sickle = _get_sickle_by_owner(msg.sender);\n        NftKey memory key = NftKey(sickle, nftManager, tokenId);\n        _unset_nft_settings(key);\n    }\n\n    /* Sickle (delegatecall) functions */\n\n    function setNftSettings(\n        NftKey calldata key,\n        NftSettings calldata settings\n    ) external {\n        Sickle sickle = Sickle(payable(msg.sender));\n\n        if (key.sickle != sickle) {\n            revert OnlySickle();\n        }\n\n        _set_nft_settings(key, settings);\n    }\n\n    function resetNftSettings(\n        NftKey calldata oldKey,\n        NftKey calldata newKey,\n        NftSettings calldata settings\n    ) external {\n        Sickle sickle = Sickle(payable(msg.sender));\n\n        if (oldKey.sickle != sickle || newKey.sickle != sickle) {\n            revert OnlySickle();\n        }\n\n        _unset_nft_settings(oldKey);\n\n        _set_nft_settings(newKey, settings);\n    }\n\n    function migrateNftSettings(\n        IPreviousAutomation automation,\n        IPreviousNftSettingsRegistry previousNftSettingsRegistry,\n        INonfungiblePositionManager nftManager,\n        IUniswapV3Pool[] memory pools,\n        uint256[] memory tokenIds\n    ) external {\n        Sickle sickle = _get_sickle_by_owner(msg.sender);\n\n        uint256 tokenLength = tokenIds.length;\n        for (uint256 i; i < tokenLength; i++) {\n            NftKey memory key = NftKey(sickle, nftManager, tokenIds[i]);\n            RebalanceConfig memory newConfig =\n                _get_new_rebalance_config(previousNftSettingsRegistry, key);\n            NftSettings memory settings =\n                _get_new_nft_settings(automation, sickle, pools[i], newConfig);\n            _set_nft_settings(key, settings);\n        }\n    }\n\n    /* Modifiers */\n\n    modifier checkConfigValues(NftKey memory key, NftSettings memory settings) {\n        if (settings.autoRebalance) {\n            _check_rebalance_config(settings.rebalanceConfig);\n            _check_tick_width(key, settings);\n        } else {\n            if (\n                settings.rebalanceConfig.cutoffTickLow != 0\n                    || settings.rebalanceConfig.cutoffTickHigh != 0\n            ) {\n                revert AutoRebalanceNotSet();\n            }\n        }\n        if (\n            settings.rewardConfig.rewardBehavior != RewardBehavior.Harvest\n                && settings.rewardConfig.harvestTokenOut != address(0)\n        ) {\n            revert InvalidTokenOut();\n        }\n        if (!settings.autoExit) {\n            if (\n                settings.exitConfig.triggerTickLow != 0\n                    || settings.exitConfig.triggerTickHigh != 0\n                    || settings.exitConfig.exitTokenOutLow != address(0)\n                    || settings.exitConfig.exitTokenOutHigh != address(0)\n                    || settings.exitConfig.slippageBP != 0\n                    || settings.exitConfig.priceImpactBP != 0\n            ) {\n                revert AutoExitNotSet();\n            }\n        } else {\n            if (\n                settings.exitConfig.triggerTickLow == 0\n                    && settings.exitConfig.triggerTickHigh == 0\n            ) {\n                revert ExitTriggersNotSet();\n            }\n            if (settings.exitConfig.slippageBP > MAX_SLIPPAGE_BP) {\n                revert InvalidSlippageBP();\n            }\n            if (\n                settings.exitConfig.priceImpactBP > MAX_PRICE_IMPACT_BP\n                    || settings.exitConfig.priceImpactBP == 0\n            ) {\n                revert InvalidPriceImpactBP();\n            }\n        }\n        _;\n    }\n\n    /* Internal */\n\n    function _get_sickle_by_owner(\n        address owner\n    ) internal view returns (Sickle) {\n        Sickle sickle = Sickle(payable(factory.sickles(owner)));\n        if (address(sickle) == address(0)) {\n            revert SickleNotDeployed();\n        }\n        return sickle;\n    }\n\n    function _set_nft_settings(\n        NftKey memory key,\n        NftSettings memory settings\n    ) internal checkConfigValues(key, settings) {\n        settingsMap[keccak256(abi.encode(key))] = settings;\n        emit NftSettingsSet(key, settings);\n    }\n\n    function _unset_nft_settings(\n        NftKey memory key\n    ) internal {\n        delete settingsMap[keccak256(abi.encode(key))];\n        emit NftSettingsUnset(key);\n    }\n\n    // Tick is the 2nd field in slot0, the rest can vary\n    function _get_current_tick(\n        IUniswapV3Pool pool\n    ) internal returns (int24) {\n        (, bytes memory result) =\n            address(pool).call(abi.encodeCall(IUniswapV3PoolState.slot0, ()));\n\n        int24 tick;\n\n        assembly {\n            tick := mload(add(result, 64))\n        }\n\n        return tick;\n    }\n\n    // Check configuratgion parameters for errors\n    function _check_rebalance_config(\n        RebalanceConfig memory config\n    ) internal pure {\n        if (config.cutoffTickLow < MIN_TICK) {\n            revert InvalidMinTickLow();\n        }\n        if (config.cutoffTickLow >= config.cutoffTickHigh) {\n            revert InvalidMinMaxTickRange();\n        }\n        if (config.cutoffTickHigh > MAX_TICK) {\n            revert InvalidMaxTickHigh();\n        }\n        if (config.slippageBP > MAX_SLIPPAGE_BP) {\n            revert InvalidSlippageBP();\n        }\n        if (\n            config.priceImpactBP > MAX_PRICE_IMPACT_BP\n                || config.priceImpactBP == 0\n        ) {\n            revert InvalidPriceImpactBP();\n        }\n        if (config.dustBP > MAX_DUST_BP || config.dustBP == 0) {\n            revert InvalidDustBP();\n        }\n        if (\n            config.rewardConfig.rewardBehavior != RewardBehavior.Harvest\n                && config.rewardConfig.harvestTokenOut != address(0)\n        ) {\n            revert InvalidTokenOut();\n        }\n    }\n\n    function _check_tick_width(\n        NftKey memory key,\n        NftSettings memory settings\n    ) internal view {\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) =\n            key.nftManager.positions(key.tokenId);\n        int24 tickSpacing = settings.pool.tickSpacing();\n\n        uint24 actualWidth = uint24(tickUpper - tickLower) / uint24(tickSpacing);\n        uint24 expectedWidth = settings.rebalanceConfig.tickSpacesBelow\n            + settings.rebalanceConfig.tickSpacesAbove + 1;\n\n        if (actualWidth != expectedWidth) {\n            revert InvalidWidth(actualWidth, expectedWidth);\n        }\n    }\n\n    /* Migration internals */\n\n    function _get_position_tick_spaces_each_side(\n        NftKey memory key\n    ) private view returns (uint24 below, uint24 above) {\n        (,,,, uint24 tickSpacing, int24 tickLower, int24 tickUpper,,,,,) =\n            key.nftManager.positions(key.tokenId);\n        uint24 totalSpaces = uint24(tickUpper - tickLower) / tickSpacing - 1;\n        below = totalSpaces / 2;\n        above = totalSpaces / 2 + totalSpaces % 2;\n    }\n\n    function _get_new_nft_settings(\n        IPreviousAutomation automation,\n        Sickle sickle,\n        IUniswapV3Pool pool,\n        RebalanceConfig memory newConfig\n    ) internal returns (NftSettings memory) {\n        address sickleOwner = sickle.owner();\n        RewardBehavior rewardBehavior = automation.rewardAutomation(sickleOwner);\n\n        return NftSettings({\n            pool: pool,\n            autoRebalance: true,\n            rebalanceConfig: newConfig,\n            automateRewards: rewardBehavior != RewardBehavior.None,\n            rewardConfig: RewardConfig(\n                rewardBehavior, automation.harvestTokensOut(sickleOwner)\n            ),\n            autoExit: false,\n            exitConfig: ExitConfig(0, 0, address(0), address(0), 0, 0)\n        });\n    }\n\n    function _get_new_rebalance_config(\n        IPreviousNftSettingsRegistry previousNftSettingsRegistry,\n        NftKey memory key\n    ) internal returns (RebalanceConfig memory) {\n        IPreviousNftSettingsRegistry.PreviousNftSettings memory previousSettings =\n            previousNftSettingsRegistry.getNftSettings(key);\n        IPreviousNftSettingsRegistry.PreviousRebalanceConfig memory oldConfig =\n            previousSettings.rebalanceConfig;\n        (uint24 spacesBelow, uint24 spacesAbove) =\n            _get_position_tick_spaces_each_side(key);\n        return RebalanceConfig(\n            spacesBelow,\n            spacesAbove,\n            int24(oldConfig.bufferTicksBelow),\n            int24(oldConfig.bufferTicksAbove),\n            oldConfig.slippageBP,\n            oldConfig.slippageBP,\n            oldConfig.slippageBP,\n            oldConfig.cutoffTickLow,\n            oldConfig.cutoffTickHigh,\n            oldConfig.delayMin,\n            RewardConfig(\n                previousSettings.rewardBehavior,\n                previousSettings.harvestTokenOut\n            )\n        );\n    }\n}\n",
        "SwapLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { DelegateModule } from \"contracts/modules/DelegateModule.sol\";\nimport { ConnectorRegistry } from \"contracts/ConnectorRegistry.sol\";\nimport { ILiquidityConnector } from\n    \"contracts/interfaces/ILiquidityConnector.sol\";\nimport { ISwapLib } from \"contracts/interfaces/libraries/ISwapLib.sol\";\nimport { SwapParams } from \"contracts/structs/LiquidityStructs.sol\";\n\ncontract SwapLib is DelegateModule, ISwapLib {\n    error SwapAmountZero();\n\n    ConnectorRegistry immutable connectorRegistry;\n\n    constructor(\n        ConnectorRegistry connectorRegistry_\n    ) {\n        connectorRegistry = connectorRegistry_;\n    }\n\n    function swap(\n        SwapParams memory swapParams\n    ) external payable {\n        _swap(swapParams);\n    }\n\n    function swapMultiple(\n        SwapParams[] memory swapParams\n    ) external {\n        uint256 swapDataLength = swapParams.length;\n        for (uint256 i; i < swapDataLength;) {\n            _swap(swapParams[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /* Internal Functions */\n\n    function _swap(\n        SwapParams memory swapParams\n    ) internal {\n        address tokenIn = swapParams.tokenIn;\n\n        if (swapParams.amountIn == 0) {\n            swapParams.amountIn = IERC20(tokenIn).balanceOf(address(this));\n        }\n\n        if (swapParams.amountIn == 0) {\n            revert SwapAmountZero();\n        }\n\n        // In case there is USDT dust approval, revoke it\n        SafeTransferLib.safeApprove(tokenIn, swapParams.router, 0);\n\n        SafeTransferLib.safeApprove(\n            tokenIn, swapParams.router, swapParams.amountIn\n        );\n\n        address connectorAddress =\n            connectorRegistry.connectorOf(swapParams.router);\n\n        ILiquidityConnector routerConnector =\n            ILiquidityConnector(connectorAddress);\n\n        _delegateTo(\n            address(routerConnector),\n            abi.encodeCall(routerConnector.swapExactTokensForTokens, swapParams)\n        );\n\n        // Revoke any approval after swap in case the swap amount was estimated\n        SafeTransferLib.safeApprove(tokenIn, swapParams.router, 0);\n    }\n}\n",
        "PositionSettingsRegistry.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Sickle } from \"contracts/Sickle.sol\";\nimport { SickleFactory } from \"contracts/SickleFactory.sol\";\nimport { ConnectorRegistry } from \"contracts/ConnectorRegistry.sol\";\nimport { TimelockAdmin } from \"contracts/base/TimelockAdmin.sol\";\nimport { Farm } from \"contracts/structs/FarmStrategyStructs.sol\";\nimport {\n    PositionKey,\n    RewardBehavior,\n    RewardConfig,\n    ExitConfig,\n    PositionSettings\n} from \"contracts/structs/PositionSettingsStructs.sol\";\nimport {\n    GetAmountOutParams,\n    ILiquidityConnector\n} from \"contracts/interfaces/ILiquidityConnector.sol\";\n\ncontract PositionSettingsRegistry is TimelockAdmin {\n    error SickleNotDeployed();\n    error AutoHarvestNotSet();\n    error AutoCompoundNotSet();\n    error RewardBehaviorNotSet();\n    error AutoExitNotSet();\n    error ConditionsNotMet();\n    error InvalidPrice();\n    error InvalidTokenOut();\n    error ExitTriggersNotSet();\n    error InvalidExitTriggers();\n    error InvalidSlippageBP();\n    error InvalidPriceImpactBP();\n    error OnlySickle();\n    error NonZeroRewardConfig();\n    error NonZeroExitConfig();\n\n    event PositionSettingsSet(PositionKey key, PositionSettings settings);\n    event ConnectionRegistrySet(address connectorRegistry);\n\n    uint256 constant MAX_SLIPPAGE_BP = 500;\n    uint256 constant MAX_PRICE_IMPACT_BP = 5000;\n\n    SickleFactory public immutable factory;\n    ConnectorRegistry private _connectorRegistry;\n\n    mapping(bytes32 => PositionSettings) positionSettingsMap;\n\n    constructor(\n        SickleFactory _factory,\n        ConnectorRegistry connectorRegistry,\n        address timelockAdmin\n    ) TimelockAdmin(timelockAdmin) {\n        factory = _factory;\n        _connectorRegistry = connectorRegistry;\n        emit ConnectionRegistrySet(address(connectorRegistry));\n    }\n\n    /* Timelock functions */\n\n    function setConnectorRegistry(\n        ConnectorRegistry connectorRegistry\n    ) external onlyTimelockAdmin {\n        _connectorRegistry = connectorRegistry;\n        emit ConnectionRegistrySet(address(connectorRegistry));\n    }\n\n    /* Public functions */\n\n    function getPositionSettings(\n        PositionKey calldata key\n    ) public view returns (PositionSettings memory) {\n        bytes32 keyHash = keccak256(abi.encode(key));\n        return positionSettingsMap[keyHash];\n    }\n\n    /* Owner functions */\n\n    function setPositionSettings(\n        Farm calldata farm,\n        PositionSettings calldata settings\n    ) external checkPositionSettings(settings) {\n        PositionKey memory key = PositionKey({\n            sickle: _get_sickle_by_owner(msg.sender),\n            stakingContract: farm.stakingContract,\n            poolIndex: farm.poolIndex\n        });\n        bytes32 keyHash = keccak256(abi.encode(key));\n        positionSettingsMap[keyHash] = settings;\n        emit PositionSettingsSet(key, settings);\n    }\n\n    /* Sickle functions */\n\n    function setPositionSettings(\n        PositionKey calldata key,\n        PositionSettings calldata settings\n    ) external checkPositionSettings(settings) {\n        Sickle sickle = Sickle(payable(msg.sender));\n        if (key.sickle != sickle) {\n            revert OnlySickle();\n        }\n        bytes32 keyHash = keccak256(abi.encode(key));\n        positionSettingsMap[keyHash] = settings;\n        emit PositionSettingsSet(key, settings);\n    }\n\n    // Used to set reward behavior (but not auto-exit) for multiple positions\n    function setPositionSettings(\n        Farm[] calldata farms,\n        RewardConfig calldata rewardConfig\n    ) public checkRewardConfig(rewardConfig) {\n        Sickle sickle = _get_sickle_by_owner(msg.sender);\n        PositionSettings memory settings;\n        PositionKey memory key;\n        for (uint256 i; i < farms.length; i++) {\n            key = PositionKey({\n                sickle: sickle,\n                stakingContract: farms[i].stakingContract,\n                poolIndex: farms[i].poolIndex\n            });\n            bytes32 keyHash = keccak256(abi.encode(key));\n            settings = positionSettingsMap[keyHash];\n            settings.rewardConfig = rewardConfig;\n            positionSettingsMap[keyHash] = settings;\n            emit PositionSettingsSet(key, settings);\n        }\n    }\n\n    function validateHarvestFor(\n        PositionKey calldata key\n    ) public view {\n        PositionSettings memory settings = getPositionSettings(key);\n        if (\n            !settings.automateRewards\n                || settings.rewardConfig.rewardBehavior != RewardBehavior.Harvest\n        ) {\n            revert AutoHarvestNotSet();\n        }\n    }\n\n    function validateCompoundFor(\n        PositionKey calldata key\n    ) public view {\n        PositionSettings memory settings = getPositionSettings(key);\n        if (\n            !settings.automateRewards\n                || settings.rewardConfig.rewardBehavior != RewardBehavior.Compound\n        ) {\n            revert AutoCompoundNotSet();\n        }\n    }\n\n    function validateExitFor(\n        PositionKey calldata key\n    ) public view {\n        PositionSettings memory settings = getPositionSettings(key);\n        ExitConfig memory config = settings.exitConfig;\n\n        if (!settings.autoExit) {\n            revert AutoExitNotSet();\n        }\n\n        uint256 price = _get_pool_price(settings);\n        (uint256 reserves0, uint256 reserves1,) = settings.pair.getReserves();\n\n        bool priceBelowRange = price < config.triggerPriceLow;\n\n        bool priceAboveRange = price > config.triggerPriceHigh;\n\n        bool reservesBelowRange = reserves0 < config.triggerReserves0\n            || reserves1 < config.triggerReserves1;\n\n        if (!priceBelowRange && !priceAboveRange && !reservesBelowRange) {\n            revert ConditionsNotMet();\n        }\n    }\n\n    /* Modifiers */\n\n    modifier checkPositionSettings(\n        PositionSettings memory settings\n    ) {\n        if (settings.automateRewards) {\n            _check_reward_config(settings.rewardConfig);\n        } else {\n            if (\n                settings.rewardConfig.rewardBehavior != RewardBehavior.None\n                    || settings.rewardConfig.harvestTokenOut != address(0)\n            ) {\n                revert NonZeroRewardConfig();\n            }\n        }\n        if (settings.autoExit) {\n            if (\n                settings.exitConfig.triggerPriceLow == 0\n                    && settings.exitConfig.triggerPriceHigh == 0\n            ) {\n                revert ExitTriggersNotSet();\n            }\n            if (\n                settings.exitConfig.triggerPriceLow\n                    >= settings.exitConfig.triggerPriceHigh\n            ) {\n                revert InvalidExitTriggers();\n            }\n            if (settings.exitConfig.slippageBP > MAX_SLIPPAGE_BP) {\n                revert InvalidSlippageBP();\n            }\n            if (\n                settings.exitConfig.priceImpactBP > MAX_PRICE_IMPACT_BP\n                    || settings.exitConfig.priceImpactBP == 0\n            ) {\n                revert InvalidPriceImpactBP();\n            }\n        } else {\n            if (\n                settings.exitConfig.triggerPriceLow != 0\n                    || settings.exitConfig.triggerPriceHigh != 0\n                    || settings.exitConfig.exitTokenOutLow != address(0)\n                    || settings.exitConfig.exitTokenOutHigh != address(0)\n                    || settings.exitConfig.slippageBP != 0\n                    || settings.exitConfig.priceImpactBP != 0\n            ) {\n                revert NonZeroExitConfig();\n            }\n        }\n        _;\n    }\n\n    modifier checkRewardConfig(\n        RewardConfig memory rewardConfig\n    ) {\n        _check_reward_config(rewardConfig);\n        _;\n    }\n\n    function _check_reward_config(\n        RewardConfig memory rewardConfig\n    ) private pure {\n        if (rewardConfig.rewardBehavior == RewardBehavior.None) {\n            revert RewardBehaviorNotSet();\n        }\n        if (\n            rewardConfig.rewardBehavior == RewardBehavior.Compound\n                && rewardConfig.harvestTokenOut != address(0)\n        ) {\n            revert InvalidTokenOut();\n        }\n    }\n\n    /* Internal */\n\n    function _get_sickle_by_owner(\n        address owner\n    ) public view returns (Sickle) {\n        Sickle sickle = Sickle(payable(factory.sickles(owner)));\n        if (address(sickle) == address(0)) {\n            revert SickleNotDeployed();\n        }\n        return sickle;\n    }\n\n    function _get_pool_price(\n        PositionSettings memory settings\n    ) private view returns (uint256 price) {\n        address token0 = settings.pair.token0();\n        address token1 = settings.pair.token1();\n\n        ILiquidityConnector connector = ILiquidityConnector(\n            _connectorRegistry.connectorOf(address(settings.router))\n        );\n\n        uint256 amountOut0 = connector.getAmountOut(\n            GetAmountOutParams({\n                router: address(settings.router),\n                lpToken: address(settings.pair),\n                tokenIn: token0,\n                tokenOut: token1,\n                amountIn: 1\n            })\n        );\n\n        if (amountOut0 > 0) {\n            price = amountOut0 * 1e18;\n        } else {\n            uint256 amountOut1 = connector.getAmountOut(\n                GetAmountOutParams({\n                    router: address(settings.router),\n                    lpToken: address(settings.pair),\n                    tokenIn: token1,\n                    tokenOut: token0,\n                    amountIn: 1\n                })\n            );\n            if (amountOut1 == 0) {\n                revert InvalidPrice();\n            }\n            price = 1e18 / amountOut1;\n        }\n\n        if (price == 0) {\n            revert InvalidPrice();\n        }\n    }\n}\n",
        "SickleFactory.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { SickleRegistry } from \"contracts/SickleRegistry.sol\";\nimport { Sickle } from \"contracts/Sickle.sol\";\nimport { Admin } from \"contracts/base/Admin.sol\";\n\n/// @title SickleFactory contract\n/// @author vfat.tools\n/// @notice Factory deploying new Sickle contracts\ncontract SickleFactory is Admin {\n    /// EVENTS ///\n\n    /// @notice Emitted when a new Sickle contract is deployed\n    /// @param admin Address receiving the admin rights of the Sickle contract\n    /// @param sickle Address of the newly deployed Sickle contract\n    event Deploy(address indexed admin, address sickle);\n\n    /// @notice Thrown when the caller is not whitelisted\n    /// @param caller Address of the non-whitelisted caller\n    error CallerNotWhitelisted(address caller); // 0x252c8273\n\n    /// @notice Thrown when the factory is not active and a deploy is attempted\n    error NotActive(); // 0x80cb55e2\n\n    /// @notice Thrown when a Sickle contract is already deployed for a user\n    error SickleAlreadyDeployed(); //0xf6782ef1\n\n    /// STORAGE ///\n\n    mapping(address => address) private _sickles;\n    mapping(address => address) private _admins;\n    mapping(address => bytes32) public _referralCodes;\n\n    /// @notice Address of the SickleRegistry contract\n    SickleRegistry public immutable registry;\n\n    /// @notice Address of the Sickle implementation contract\n    address public immutable implementation;\n\n    /// @notice Address of the previous SickleFactory contract (if applicable)\n    SickleFactory public immutable previousFactory;\n\n    /// @notice Whether the factory is active (can deploy new Sickle contracts)\n    bool public isActive = true;\n\n    /// WRITE FUNCTIONS ///\n\n    /// @param admin_ Address of the admin\n    /// @param sickleRegistry_ Address of the SickleRegistry contract\n    /// @param sickleImplementation_ Address of the Sickle implementation\n    /// contract\n    /// @param previousFactory_ Address of the previous SickleFactory contract\n    /// if applicable\n    constructor(\n        address admin_,\n        address sickleRegistry_,\n        address sickleImplementation_,\n        address previousFactory_\n    ) Admin(admin_) {\n        registry = SickleRegistry(sickleRegistry_);\n        implementation = sickleImplementation_;\n        previousFactory = SickleFactory(previousFactory_);\n    }\n\n    /// @notice Update the isActive flag.\n    /// @dev Effectively pauses and unpauses new Sickle deployments.\n    /// @custom:access Restricted to protocol admin.\n    function setActive(bool active) external onlyAdmin {\n        isActive = active;\n    }\n\n    function _deploy(\n        address admin,\n        address approved,\n        bytes32 referralCode\n    ) internal returns (address sickle) {\n        sickle = Clones.cloneDeterministic(\n            implementation, keccak256(abi.encode(admin))\n        );\n        Sickle(payable(sickle)).initialize(admin, approved);\n        _sickles[admin] = sickle;\n        _admins[sickle] = admin;\n        if (referralCode != bytes32(0)) {\n            _referralCodes[sickle] = referralCode;\n        }\n        emit Deploy(admin, sickle);\n    }\n\n    function _getSickle(address admin) internal returns (address sickle) {\n        sickle = _sickles[admin];\n        if (sickle != address(0)) {\n            return sickle;\n        }\n        if (address(previousFactory) != address(0)) {\n            sickle = previousFactory.sickles(admin);\n            if (sickle != address(0)) {\n                _sickles[admin] = sickle;\n                _admins[sickle] = admin;\n                _referralCodes[sickle] = previousFactory.referralCodes(sickle);\n                return sickle;\n            }\n        }\n    }\n\n    /// @notice Predict the address of a Sickle contract for a specific user\n    /// @param admin Address receiving the admin rights of the Sickle contract\n    /// @return sickle Address of the predicted Sickle contract\n    function predict(address admin) external view returns (address) {\n        bytes32 salt = keccak256(abi.encode(admin));\n        return Clones.predictDeterministicAddress(implementation, salt);\n    }\n\n    /// @notice Returns the Sickle contract for a specific user\n    /// @param admin Address that owns the Sickle contract\n    /// @return sickle Address of the Sickle contract\n    function sickles(address admin) external view returns (address sickle) {\n        sickle = _sickles[admin];\n        if (sickle == address(0) && address(previousFactory) != address(0)) {\n            sickle = previousFactory.sickles(admin);\n        }\n    }\n\n    /// @notice Returns the admin for a specific Sickle contract\n    /// @param sickle Address of the Sickle contract\n    /// @return admin Address that owns the Sickle contract\n    function admins(address sickle) external view returns (address admin) {\n        admin = _admins[sickle];\n        if (admin == address(0) && address(previousFactory) != address(0)) {\n            admin = previousFactory.admins(sickle);\n        }\n    }\n\n    /// @notice Returns the referral code for a specific Sickle contract\n    /// @param sickle Address of the Sickle contract\n    /// @return referralCode Referral code for the user\n    function referralCodes(address sickle)\n        external\n        view\n        returns (bytes32 referralCode)\n    {\n        referralCode = _referralCodes[sickle];\n        if (\n            referralCode == bytes32(0) && address(previousFactory) != address(0)\n        ) {\n            referralCode = previousFactory.referralCodes(sickle);\n        }\n    }\n\n    /// @notice Deploys a new Sickle contract for a specific user, or returns\n    /// the existing one if it exists\n    /// @param admin Address receiving the admin rights of the Sickle contract\n    /// @param referralCode Referral code for the user\n    /// @return sickle Address of the deployed Sickle contract\n    function getOrDeploy(\n        address admin,\n        address approved,\n        bytes32 referralCode\n    ) external returns (address sickle) {\n        if (!isActive) {\n            revert NotActive();\n        }\n        if (!registry.isWhitelistedCaller(msg.sender)) {\n            revert CallerNotWhitelisted(msg.sender);\n        }\n        if ((sickle = _getSickle(admin)) != address(0)) {\n            return sickle;\n        }\n        return _deploy(admin, approved, referralCode);\n    }\n\n    /// @notice Deploys a new Sickle contract for a specific user\n    /// @dev Sickle contracts are deployed with create2, the address of the\n    /// admin is used as a salt, so all the Sickle addresses can be pre-computed\n    /// and only 1 Sickle will exist per address\n    /// @param referralCode Referral code for the user\n    /// @return sickle Address of the deployed Sickle contract\n    function deploy(\n        address approved,\n        bytes32 referralCode\n    ) external returns (address sickle) {\n        if (!isActive) {\n            revert NotActive();\n        }\n        if (_getSickle(msg.sender) != address(0)) {\n            revert SickleAlreadyDeployed();\n        }\n        return _deploy(msg.sender, approved, referralCode);\n    }\n}\n",
        "ConnectorRegistry.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Admin } from \"contracts/base/Admin.sol\";\nimport { TimelockAdmin } from \"contracts/base/TimelockAdmin.sol\";\n\nerror ConnectorNotRegistered(address target);\n\ninterface ICustomConnectorRegistry {\n    function connectorOf(address target) external view returns (address);\n}\n\ncontract ConnectorRegistry is Admin, TimelockAdmin {\n    event ConnectorChanged(address target, address connector);\n    event CustomRegistryAdded(address registry);\n    event CustomRegistryRemoved(address registry);\n\n    error ConnectorAlreadySet(address target);\n    error ConnectorNotSet(address target);\n\n    ICustomConnectorRegistry[] public customRegistries;\n    mapping(ICustomConnectorRegistry => bool) public isCustomRegistry;\n\n    mapping(address target => address connector) private connectors_;\n\n    constructor(\n        address admin_,\n        address timelockAdmin_\n    ) Admin(admin_) TimelockAdmin(timelockAdmin_) { }\n\n    /// @notice Update connector addresses for a batch of targets.\n    /// @dev Controls which connector contracts are used for the specified\n    /// targets.\n    /// @custom:access Restricted to protocol admin.\n    function setConnectors(\n        address[] calldata targets,\n        address[] calldata connectors\n    ) external onlyAdmin {\n        for (uint256 i; i != targets.length;) {\n            if (connectors_[targets[i]] != address(0)) {\n                revert ConnectorAlreadySet(targets[i]);\n            }\n            connectors_[targets[i]] = connectors[i];\n            emit ConnectorChanged(targets[i], connectors[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function updateConnectors(\n        address[] calldata targets,\n        address[] calldata connectors\n    ) external onlyTimelockAdmin {\n        for (uint256 i; i != targets.length;) {\n            if (connectors_[targets[i]] == address(0)) {\n                revert ConnectorNotSet(targets[i]);\n            }\n            connectors_[targets[i]] = connectors[i];\n            emit ConnectorChanged(targets[i], connectors[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Append an address to the custom registries list.\n    /// @custom:access Restricted to protocol admin.\n    function addCustomRegistry(ICustomConnectorRegistry registry)\n        external\n        onlyAdmin\n    {\n        customRegistries.push(registry);\n        isCustomRegistry[registry] = true;\n        emit CustomRegistryAdded(address(registry));\n    }\n\n    /// @notice Replace an address in the custom registries list.\n    /// @custom:access Restricted to protocol admin.\n    function updateCustomRegistry(\n        uint256 index,\n        ICustomConnectorRegistry newRegistry\n    ) external onlyTimelockAdmin {\n        address oldRegistry = address(customRegistries[index]);\n        isCustomRegistry[customRegistries[index]] = false;\n        emit CustomRegistryRemoved(oldRegistry);\n        customRegistries[index] = newRegistry;\n        isCustomRegistry[newRegistry] = true;\n        if (address(newRegistry) != address(0)) {\n            emit CustomRegistryAdded(address(newRegistry));\n        }\n    }\n\n    function connectorOf(address target) external view returns (address) {\n        address connector = connectors_[target];\n        if (connector != address(0)) {\n            return connector;\n        }\n\n        uint256 length = customRegistries.length;\n        for (uint256 i; i != length;) {\n            if (address(customRegistries[i]) != address(0)) {\n                try customRegistries[i].connectorOf(target) returns (\n                    address _connector\n                ) {\n                    if (_connector != address(0)) {\n                        return _connector;\n                    }\n                } catch {\n                    // Ignore\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        revert ConnectorNotRegistered(target);\n    }\n\n    function hasConnector(address target) external view returns (bool) {\n        if (connectors_[target] != address(0)) {\n            return true;\n        }\n\n        uint256 length = customRegistries.length;\n        for (uint256 i; i != length;) {\n            if (address(customRegistries[i]) != address(0)) {\n                try customRegistries[i].connectorOf(target) returns (\n                    address _connector\n                ) {\n                    if (_connector != address(0)) {\n                        return true;\n                    }\n                } catch {\n                    // Ignore\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n"
    }
}