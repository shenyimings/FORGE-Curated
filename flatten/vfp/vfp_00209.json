{
    "vfp_id": "vfp_00209",
    "project_name": "cantina_sky_spark_alm_controller_aug2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Malicious relayer could take spark vault assets and deposit them back",
            "description": "The vulnerability allows a malicious relayer (acting as the ALM proxy or taker) to withdraw assets from a Spark Vault without burning shares, and then deposit those same assets back into the vault to receive new shares. The root cause lies in the lack of coordination between rate limits for asset withdrawal and deposit controls, which enables the taker to manipulate the vault's accounting state. An attacker could exploit this by first taking assets via the taker role and then depositing them back through ERC4626 mechanisms, thereby inflating their share balance and causing the totalAssets() function to report an incorrect value. The impact is a potential discrepancy in vault accounting, which could affect fairness and accuracy in share calculations, though no direct fund loss is implied. This was classified as low risk due to the specific conditions required and the mitigation implemented in the vault code.\n",
            "severity": "Low",
            "location": [
                "MainnetController.sol::#L888-L897"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "The superstateRedemption and artifacts can be removed",
            "description": "The Superstate redemption functionality was previously removed from the MainnetController, but related code artifacts (such as variables or functions) were left behind in the contract. The root cause is incomplete cleanup after feature removal. While this does not introduce a direct security risk, it increases code complexity, reduces readability, and may lead to confusion during future audits or maintenance. There is no direct exploitation path, but leftover code can obscure real vulnerabilities. The impact is limited to code maintainability and audit efficiency. This is purely an informational finding recommending code hygiene improvements.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol::#L60-L64",
                "MainnetController.sol::#L141"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        }
    ],
    "affected_files": {
        "MainnetController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\n// This interface has been reviewed, and is compliant with the specs: https://eips.ethereum.org/EIPS/eip-7540\nimport { IERC7540 } from \"forge-std/interfaces/IERC7540.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IERC20 }   from \"openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\n\nimport { Ethereum } from \"spark-address-registry/Ethereum.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport  \"./interfaces/ILayerZero.sol\";\n\nimport { CCTPLib }                        from \"./libraries/CCTPLib.sol\";\nimport { CurveLib }                       from \"./libraries/CurveLib.sol\";\nimport { IDaiUsdsLike, IPSMLike, PSMLib } from \"./libraries/PSMLib.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ninterface IEthenaMinterLike {\n    function setDelegatedSigner(address delegateSigner) external;\n    function removeDelegatedSigner(address delegateSigner) external;\n}\n\ninterface ICentrifugeToken is IERC7540 {\n    function cancelDepositRequest(uint256 requestId, address controller) external;\n    function cancelRedeemRequest(uint256 requestId, address controller) external;\n    function claimCancelDepositRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 assets);\n    function claimCancelRedeemRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 shares);\n}\n\ninterface IMapleTokenLike is IERC4626 {\n    function requestRedeem(uint256 shares, address receiver) external;\n    function removeShares(uint256 shares, address receiver) external;\n}\n\ninterface IFarmLike {\n    function stake(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n}\n\ninterface ISSRedemptionLike is IERC20 {\n    function calculateUsdcOut(uint256 ustbAmount)\n        external view returns (uint256 usdcOutAmount, uint256 usdPerUstbChainlinkRaw);\n    function redeem(uint256 ustbAmout) external;\n}\n\ninterface ISUSDELike is IERC4626 {\n    function cooldownAssets(uint256 usdeAmount) external;\n    function cooldownShares(uint256 susdeAmount) external;\n    function unstake(address receiver) external;\n}\n\ninterface IUSTBLike is IERC20 {\n    function subscribe(uint256 inAmount, address stablecoin) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function draw(uint256 usdsAmount) external;\n    function wipe(uint256 usdsAmount) external;\n}\n\ninterface ISparkVaultLike {\n    function take(uint256 assetAmount) external;\n}\n\ncontract MainnetController is AccessControl {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n    event MaxSlippageSet(address indexed pool, uint256 maxSlippage);\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public FREEZER = keccak256(\"FREEZER\");\n    bytes32 public RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public LIMIT_4626_DEPOSIT         = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public LIMIT_4626_WITHDRAW        = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public LIMIT_7540_DEPOSIT         = keccak256(\"LIMIT_7540_DEPOSIT\");\n    bytes32 public LIMIT_7540_REDEEM          = keccak256(\"LIMIT_7540_REDEEM\");\n    bytes32 public LIMIT_AAVE_DEPOSIT         = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public LIMIT_AAVE_WITHDRAW        = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public LIMIT_ASSET_TRANSFER       = keccak256(\"LIMIT_ASSET_TRANSFER\");\n    bytes32 public LIMIT_CURVE_DEPOSIT        = keccak256(\"LIMIT_CURVE_DEPOSIT\");\n    bytes32 public LIMIT_CURVE_SWAP           = keccak256(\"LIMIT_CURVE_SWAP\");\n    bytes32 public LIMIT_CURVE_WITHDRAW       = keccak256(\"LIMIT_CURVE_WITHDRAW\");\n    bytes32 public LIMIT_LAYERZERO_TRANSFER   = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public LIMIT_MAPLE_REDEEM         = keccak256(\"LIMIT_MAPLE_REDEEM\");\n    bytes32 public LIMIT_FARM_DEPOSIT         = keccak256(\"LIMIT_FARM_DEPOSIT\");\n    bytes32 public LIMIT_FARM_WITHDRAW        = keccak256(\"LIMIT_FARM_WITHDRAW\");\n    bytes32 public LIMIT_SPARK_VAULT_TAKE     = keccak256(\"LIMIT_SPARK_VAULT_TAKE\");\n    bytes32 public LIMIT_SUPERSTATE_REDEEM    = keccak256(\"LIMIT_SUPERSTATE_REDEEM\");\n    bytes32 public LIMIT_SUPERSTATE_SUBSCRIBE = keccak256(\"LIMIT_SUPERSTATE_SUBSCRIBE\");\n    bytes32 public LIMIT_SUSDE_COOLDOWN       = keccak256(\"LIMIT_SUSDE_COOLDOWN\");\n    bytes32 public LIMIT_USDC_TO_CCTP         = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public LIMIT_USDC_TO_DOMAIN       = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n    bytes32 public LIMIT_USDE_BURN            = keccak256(\"LIMIT_USDE_BURN\");\n    bytes32 public LIMIT_USDE_MINT            = keccak256(\"LIMIT_USDE_MINT\");\n    bytes32 public LIMIT_USDS_MINT            = keccak256(\"LIMIT_USDS_MINT\");\n    bytes32 public LIMIT_USDS_TO_USDC         = keccak256(\"LIMIT_USDS_TO_USDC\");\n\n    uint256 internal CENTRIFUGE_REQUEST_ID = 0;\n\n    address public buffer;\n\n    IALMProxy         public proxy;\n    ICCTPLike         public cctp;\n    IDaiUsdsLike      public daiUsds;\n    IEthenaMinterLike public ethenaMinter;\n    IPSMLike          public psm;\n    IRateLimits       public rateLimits;\n    ISSRedemptionLike public superstateRedemption;\n    IVaultLike        public vault;\n\n    IERC20     public dai;\n    IERC20     public usds;\n    IERC20     public usde;\n    IERC20     public usdc;\n    IUSTBLike  public ustb;\n    ISUSDELike public susde;\n\n    uint256 public psmTo18ConversionFactor;\n\n    mapping(address pool => uint256 maxSlippage) public maxSlippages;  // 1e18 precision\n\n    mapping(uint32 destinationDomain     => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId => bytes32 layerZeroRecipient) public layerZeroRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address vault_,\n        address psm_,\n        address daiUsds_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        vault      = IVaultLike(vault_);\n        buffer     = IVaultLike(vault_).buffer();\n        psm        = IPSMLike(psm_);\n        daiUsds    = IDaiUsdsLike(daiUsds_);\n        cctp       = ICCTPLike(cctp_);\n\n        ethenaMinter         = IEthenaMinterLike(Ethereum.ETHENA_MINTER);\n        superstateRedemption = ISSRedemptionLike(Ethereum.SUPERSTATE_REDEMPTION);\n\n        susde = ISUSDELike(Ethereum.SUSDE);\n        ustb  = IUSTBLike(Ethereum.USTB);\n        dai   = IERC20(daiUsds.dai());\n        usdc  = IERC20(psm.gem());\n        usds  = IERC20(Ethereum.USDS);\n        usde  = IERC20(Ethereum.USDE);\n\n        psmTo18ConversionFactor = psm.to18ConversionFactor();\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(\n        uint32  destinationEndpointId,\n        bytes32 layerZeroRecipient\n    )\n        external\n    {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    function setMaxSlippage(address pool, uint256 maxSlippage) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        maxSlippages[pool] = maxSlippage;\n        emit MaxSlippageSet(pool, maxSlippage);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external {\n        _checkRole(FREEZER);\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer vault functions                                                                ***/\n    /**********************************************************************************************/\n\n    function mintUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDS_MINT, usdsAmount);\n\n        // Mint USDS into the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.draw, (usdsAmount))\n        );\n\n        // Transfer USDS from the buffer to the proxy\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transferFrom, (buffer, address(proxy), usdsAmount))\n        );\n    }\n\n    function burnUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _cancelRateLimit(LIMIT_USDS_MINT, usdsAmount);\n\n        // Transfer USDS from the proxy to the buffer\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transfer, (buffer, usdsAmount))\n        );\n\n        // Burn USDS from the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.wipe, (usdsAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC20 functions                                                                ***/\n    /**********************************************************************************************/\n\n    function transferAsset(address asset, address destination, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            RateLimitHelpers.makeAssetDestinationKey(LIMIT_ASSET_TRANSFER, asset, destination),\n            amount\n        );\n\n        proxy.doCall(\n            asset,\n            abi.encodeCall(IERC20(asset).transfer, (destination, amount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount);\n\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        _cancelRateLimit(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, token), amount);\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares) external returns (uint256 assets) {\n        _checkRole(RELAYER);\n\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n\n        _cancelRateLimit(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, token), assets);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC7540 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function requestDepositERC7540(address token, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_7540_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC7540(token).asset());\n\n        // Approve asset to vault from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Submit deposit request by transferring assets\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestDeposit, (amount, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimDepositERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        uint256 shares = IERC7540(token).maxMint(address(proxy));\n\n        // Claim shares from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC4626(token).mint, (shares, address(proxy)))\n        );\n    }\n\n    function requestRedeemERC7540(address token, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_7540_REDEEM,\n            token,\n            IERC7540(token).convertToAssets(shares)\n        );\n\n        // Submit redeem request by transferring shares\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestRedeem, (shares, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimRedeemERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        uint256 assets = IERC7540(token).maxWithdraw(address(proxy));\n\n        // Claim assets from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).withdraw, (assets, address(proxy), address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Centrifuge functions                                                           ***/\n    /**********************************************************************************************/\n\n    // NOTE: These cancelation methods are compatible with ERC-7887\n\n    function cancelCentrifugeDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        // NOTE: While the cancelation is pending, no new deposit request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    function cancelCentrifugeRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        // NOTE: While the cancelation is pending, no new redeem request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount);\n\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        _checkRole(RELAYER);\n\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n\n        _cancelRateLimit(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_DEPOSIT, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Curve StableSwap functions                                                     ***/\n    /**********************************************************************************************/\n\n    function swapCurve(\n        address pool,\n        uint256 inputIndex,\n        uint256 outputIndex,\n        uint256 amountIn,\n        uint256 minAmountOut\n    )\n        external returns (uint256 amountOut)\n    {\n        _checkRole(RELAYER);\n\n        amountOut = CurveLib.swap(CurveLib.SwapCurveParams({\n            proxy        : proxy,\n            rateLimits   : rateLimits,\n            pool         : pool,\n            rateLimitId  : LIMIT_CURVE_SWAP,\n            inputIndex   : inputIndex,\n            outputIndex  : outputIndex,\n            amountIn     : amountIn,\n            minAmountOut : minAmountOut,\n            maxSlippage  : maxSlippages[pool]\n        }));\n    }\n\n    function addLiquidityCurve(\n        address pool,\n        uint256[] memory depositAmounts,\n        uint256 minLpAmount\n    )\n        external returns (uint256 shares)\n    {\n        _checkRole(RELAYER);\n\n        shares = CurveLib.addLiquidity(CurveLib.AddLiquidityParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            pool                    : pool,\n            addLiquidityRateLimitId : LIMIT_CURVE_DEPOSIT,\n            swapRateLimitId         : LIMIT_CURVE_SWAP,\n            minLpAmount             : minLpAmount,\n            maxSlippage             : maxSlippages[pool],\n            depositAmounts          : depositAmounts\n        }));\n    }\n\n    function removeLiquidityCurve(\n        address pool,\n        uint256 lpBurnAmount,\n        uint256[] memory minWithdrawAmounts\n    )\n        external returns (uint256[] memory withdrawnTokens)\n    {\n        _checkRole(RELAYER);\n\n        withdrawnTokens = CurveLib.removeLiquidity(CurveLib.RemoveLiquidityParams({\n            proxy              : proxy,\n            rateLimits         : rateLimits,\n            pool               : pool,\n            rateLimitId        : LIMIT_CURVE_WITHDRAW,\n            lpBurnAmount       : lpBurnAmount,\n            minWithdrawAmounts : minWithdrawAmounts,\n            maxSlippage        : maxSlippages[pool]\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Ethena functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.setDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    function removeDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.removeDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    // Note that Ethena's mint/redeem per-block limits include other users\n    function prepareUSDeMint(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_MINT, usdcAmount);\n        _approve(address(usdc), address(ethenaMinter), usdcAmount);\n    }\n\n    function prepareUSDeBurn(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_BURN, usdeAmount);\n        _approve(address(usde), address(ethenaMinter), usdeAmount);\n    }\n\n    function cooldownAssetsSUSDe(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUSDE_COOLDOWN, usdeAmount);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.cooldownAssets, (usdeAmount))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function cooldownSharesSUSDe(uint256 susdeAmount)\n        external\n        returns (uint256 cooldownAmount)\n    {\n        _checkRole(RELAYER);\n\n        cooldownAmount = abi.decode(\n            proxy.doCall(\n                address(susde),\n                abi.encodeCall(susde.cooldownShares, (susdeAmount))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUSDE_COOLDOWN, cooldownAmount);\n    }\n\n    function unstakeSUSDe() external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.unstake, (address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Maple functions                                                                ***/\n    /**********************************************************************************************/\n\n    function requestMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_MAPLE_REDEEM,\n            mapleToken,\n            IMapleTokenLike(mapleToken).convertToAssets(shares)\n        );\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).requestRedeem, (shares, address(proxy)))\n        );\n    }\n\n    function cancelMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_MAPLE_REDEEM, mapleToken));\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).removeShares, (shares, address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Superstate functions                                                           ***/\n    /**********************************************************************************************/\n\n    function subscribeSuperstate(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUPERSTATE_SUBSCRIBE, usdcAmount);\n\n        _approve(address(usdc), address(ustb), usdcAmount);\n\n        proxy.doCall(\n            address(ustb),\n            abi.encodeCall(ustb.subscribe, (usdcAmount, address(usdc)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer DaiUsds functions                                                              ***/\n    /**********************************************************************************************/\n\n    function swapUSDSToDAI(uint256 usdsAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(address(usds), address(daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.usdsToDai, (address(proxy), usdsAmount))\n        );\n    }\n\n    function swapDAIToUSDS(uint256 daiAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(address(dai), address(daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.daiToUsds, (address(proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    // NOTE: The param `usdcAmount` is denominated in 1e6 precision to match how PSM uses\n    //       USDC precision for both `buyGemNoFee` and `sellGemNoFee`\n    function swapUSDSToUSDC(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDSToUSDC(PSMLib.SwapUSDSToUSDCParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            usds                    : usds,\n            dai                     : dai,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    function swapUSDCToUSDS(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDCToUSDS(PSMLib.SwapUSDCToUSDSParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            dai                     : dai,\n            usdc                    : usdc,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external payable\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        // NOTE: Full integration testing of this logic is not possible without OFTs with\n        //       approvalRequired == false. Add integration testing for this case before\n        //       using in production.\n        if (ILayerZero(oftAddress).approvalRequired()) {\n            _approve(ILayerZero(oftAddress).token(), oftAddress, amount);\n        }\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue{value: fee.nativeFee}(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain) external {\n        _checkRole(RELAYER);\n\n        CCTPLib.transferUSDCToCCTP(CCTPLib.TransferUSDCToCCTPParams({\n            proxy             : proxy,\n            rateLimits        : rateLimits,\n            cctp              : cctp,\n            usdc              : usdc,\n            domainRateLimitId : LIMIT_USDC_TO_DOMAIN,\n            cctpRateLimitId   : LIMIT_USDC_TO_CCTP,\n            mintRecipient     : mintRecipients[destinationDomain],\n            destinationDomain : destinationDomain,\n            usdcAmount        : usdcAmount\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer SPK Farm functions                                                             ***/\n    /**********************************************************************************************/\n\n    function depositToFarm(address farm, uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_FARM_DEPOSIT, farm)),\n            usdsAmount\n        );\n\n        _approve(address(usds), farm, usdsAmount);\n\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.stake, (usdsAmount))\n        );\n    }\n\n    function withdrawFromFarm(address farm, uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_FARM_WITHDRAW, farm)),\n            usdsAmount\n        );\n\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.withdraw, (usdsAmount))\n        );\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.getReward, ())\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Spark Vault functions                                                                  ***/\n    /**********************************************************************************************/\n\n    function takeFromSparkVault(address sparkVault, uint256 assetAmount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_SPARK_VAULT_TAKE, sparkVault, assetAmount);\n\n        // Take assets from the vault\n        proxy.doCall(\n            sparkVault,\n            abi.encodeCall(ISparkVaultLike.take, (assetAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        bytes memory approveCallReturnData;\n\n        if (success) {\n            // Data is the ABI-encoding of the approve call bytes return data, need to\n            // decode it first\n            approveCallReturnData = abi.decode(data, (bytes));\n            // Approve was successful if 1) no return value or 2) true return value\n            if (approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool))) {\n                return;\n            }\n        }\n\n        // If call was unsuccessful, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n\n        approveCallReturnData = proxy.doCall(token, approveData);\n\n        // Revert if approve returns false\n        require(\n            approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool)),\n            \"MainnetController/approve-failed\"\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Rate Limit helper functions                                                            ***/\n    /**********************************************************************************************/\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n    function _rateLimitedAsset(bytes32 key, address asset, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n    }\n\n    function _cancelRateLimit(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitIncrease(key, amount);\n    }\n\n    function _rateLimitExists(bytes32 key) internal view {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"MainnetController/invalid-action\"\n        );\n    }\n\n}\n\n"
    }
}