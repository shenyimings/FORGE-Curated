{
    "vfp_id": "vfp_00356",
    "project_name": "Polygon Staking - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect minimum unbond quantity calculation",
            "description": "The vulnerability arises in the `unbond` function of the PolygonStrategy contract, where the condition for claiming rewards relies on a miscalculated `rewards` value. The `rewards` variable is derived from `getTotalDeposits() - getPrincipalDeposits()`, which includes `token.balanceOf(address(this))`—a value that can be arbitrarily inflated by an attacker via token donations. However, the upstream `ValidatorShare` contract's `minRewardClaimAmount` check only considers actual staking rewards, not external token balances. This discrepancy causes the local check to pass even when the upstream withdrawal would revert due to insufficient actual rewards.\n\nThe root cause is the incorrect inclusion of the contract's token balance in the rewards calculation, which does not align with the upstream contract's logic. An attacker can exploit this by front-running an `unbond` call and donating tokens to the vault, causing the `rewards >= vault.minRewardClaimAmount()` check to pass locally. However, when `vault.withdrawRewards()` is called, the upstream contract reverts due to insufficient actual rewards, causing the entire `unbond` transaction to fail.\n\nThe impact is that legitimate `unbond` requests can be permanently reverted if the attacker's donation keeps the balance above the threshold without triggering actual reward withdrawal. This leads to user inconvenience and potential need for governance intervention to resolve the stuck state.\n",
            "severity": "High",
            "location": [
                "PolygonStrategy.sol::unbond"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "The rewards quantity is not deducted if the unbond quantity is lesser",
            "description": "In the `unbond` function of the PolygonStrategy contract, when a vault's rewards are below the minimum claim threshold, the rewards are not deducted from the `toUnbondRemaining` amount even though they will be automatically claimed upon unbonding principal deposits. This occurs because the logic only subtracts rewards when `toUnbondRemaining > rewards`, but fails to account for cases where the `minRewardClaimAmount` condition fails. As a result, the function unbonds more principal than necessary.\n\nThe root cause is a flaw in the accounting logic that does not consistently treat reward claims during unbonding. The contract assumes that rewards are only claimed when explicitly withdrawn, but the upstream `ValidatorShare` contract automatically claims rewards when unstaking. This leads to a misalignment in expected vs. actual behavior.\n\nAn attacker or user could exploit this by structuring unbonding operations across multiple vaults to cause excess unbonding, which distorts the staking distribution and causes earlier-than-necessary unbonding of subsequent vaults. This could slightly reduce the overall rewards rate and disrupt the intended staking strategy.\n\nThe impact is a financial inefficiency and misallocation of staked assets, leading to suboptimal yield for users and potential imbalance in the staking pool distribution.\n",
            "severity": "Medium",
            "location": [
                "PolygonStrategy.sol::unbond"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Donations can arbitrarily inflate fees to skip paying any fees via an upstream safety check",
            "description": "The `getDepositChange` function in the `PolygonStrategy` contract includes the contract's token balance and vault balances when calculating profit, which can be inflated by external donations. This inflated profit increases the fee amount calculated by `updateDeposits`. However, the `StakingPool` contract has a safety check that sets fees to zero if they exceed the total staked amount, which can be triggered by large donations.\n\nThe root cause is the inclusion of arbitrary external balances in profit calculations without accounting for the potential to trigger safety mechanisms. The fee recipients are controlled by the owner and may not align with depositors, creating a misalignment of incentives.\n\nAn attacker could exploit this by colluding with fee recipients to donate tokens, inflate reported profits, trigger the safety check, and zero out fees—effectively allowing them to extract value without paying fees. This is particularly effective if the fee recipients are separate from the depositors and MEV recipients.\n\nThe impact is a financial risk where fees are avoided through manipulation, potentially leading to loss of revenue for the protocol and unfair advantage for colluding parties.\n",
            "severity": "Low",
            "location": [
                "PolygonStrategy.sol::getDepositChange"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Rewards remain unclaimed when principalDeposits is zero",
            "description": "When `queueValidatorRemoval` is called on a vault with zero principal deposits but non-zero rewards, the rewards are not claimed or transferred to the strategy. The function only processes rewards if `principalDeposits != 0`, and the finalization step does not include a balance withdrawal. This results in lost rewards that remain trapped in the vault.\n\nThe root cause is the omission of a balance check and withdrawal step when removing a validator with no principal. While the impact is minimal due to the rarity of such balances, any accumulated rewards (e.g., from donated shares triggering reward claims) are effectively lost.\n\nAn attacker could exploit this by donating small amounts of shares to a validator marked for removal, causing rewards to be claimed into the vault but not transferred out, resulting in permanent loss of those funds.\n\nThe impact is minimal financial loss, primarily affecting edge cases where token balances accumulate in vaults scheduled for removal. However, it represents a correctness issue in fund management.\n",
            "severity": "Informational",
            "location": [
                "PolygonStrategy.sol::queueValidatorRemoval"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ],
                "3": [
                    "CWE-130"
                ]
            },
            "title": "No length check is present on the amounts parameter",
            "description": "The `depositQueuedTokens` and `forceUnbond` functions in the `PolygonStrategy` contract accept two arrays—`_vaultIds` and `_amounts`—but do not validate that they have the same length. If `_amounts` is longer than `_vaultIds`, the extra elements are silently ignored. If it is shorter, the function reverts due to array bounds access.\n\nThe root cause is the absence of an explicit length validation, which could lead to silent data truncation or confusing reverts. This makes the function behavior ambiguous and error-prone for callers.\n\nAn attacker or buggy frontend could exploit this by providing mismatched array lengths, leading to incorrect deposit or unbond amounts being processed, or unexpected transaction failures.\n\nThe impact is a potential for user error or manipulation, leading to incorrect state changes or failed transactions, reducing the reliability and usability of the contract interface.\n",
            "severity": "Informational",
            "location": [
                "PolygonStrategy.sol::depositQueuedTokens",
                "PolygonStrategy.sol::forceUnbond"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "The totalStaked function name could be confusing",
            "description": "The `totalStaked` function in the `PolygonStrategy` contract may have a misleading name, as it does not clearly indicate what it returns. The function likely returns the total amount of staked assets, but the name does not distinguish between principal, rewards, or queued withdrawals, which could confuse developers or auditors.\n\nThe root cause is poor naming convention, which can lead to misunderstandings about the function's behavior. In security-critical code, clarity is essential to prevent logic errors.\n\nAn attacker could exploit this confusion by manipulating code that depends on `totalStaked`, assuming it includes or excludes certain components, leading to incorrect calculations in integrations or governance decisions.\n\nThe impact is primarily on code maintainability and safety, increasing the risk of logic errors in dependent systems due to ambiguous semantics.\n",
            "severity": "Informational",
            "location": [
                "PolygonStrategy.sol::totalStaked"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Renumbered vault/validator IDs",
            "description": "The finalizeValidatorRemoval function in PolygonStrategy shifts all validators and vaults after the removed one down by one index, effectively renumbering the IDs of subsequent validators.\n\nThe cause is the use of a compacting array update mechanism that does not preserve stable IDs for validators and vaults.\n\nA block builder can reorder transactions such that calls to functions like unstakeClaim, restakeRewards, or queueValidatorRemoval that reference vault/validator IDs are executed after finalizeValidatorRemoval, causing them to target a different validator than intended.\n\nThe impact is that legitimate user calls can unexpectedly revert if they reference a vault/validator that has been shifted, leading to a minor usability issue and potential confusion, though no direct fund loss occurs.\n",
            "severity": "Informational",
            "location": [
                "PolygonStrategy::finalizeValidatorRemoval#"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "The addFee functions can repeat receivers",
            "description": "The addFee functions in both PolygonStrategy and LSTRewardsSplitter allow the same receiver address to be added multiple times to the fees array.\n\nThe cause is the lack of deduplication checks using a mapping or similar structure to prevent duplicate entries by address.\n\nAn owner could accidentally or intentionally add the same receiver multiple times, leading to that receiver receiving multiple shares of fees proportional to their duplicate entries.\n\nThe impact is potential confusion for users and external systems that expect each receiver to appear only once, and could result in unintended fee distribution if duplicates are not monitored.\n",
            "severity": "Informational",
            "location": [
                "PolygonStrategy::addFee#",
                "LSTRewardsSplitter::addFee#"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "PolygonStrategy.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"../core/base/Strategy.sol\";\nimport \"../core/interfaces/IRewardsPool.sol\";\nimport \"./interfaces/IPolygonVault.sol\";\nimport \"./interfaces/IPolygonStakeManager.sol\";\n\n/**\n * @title Polygon Strategy\n * @notice Strategy for managing multiple Polygon staking vaults\n */\ncontract PolygonStrategy is Strategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Validator {\n        // address of validator shares pool\n        address pool;\n        // address to receive validator share of MEV rewards\n        address rewardsReceiver;\n    }\n\n    struct ValidatorRemoval {\n        // whether a validator is queued for removal\n        bool isActive;\n        // id of validator\n        uint64 validatorId;\n        // total queued withdrawals for validator\n        uint128 queuedWithdrawals;\n    }\n\n    struct Fee {\n        // address to recieve fee\n        address receiver;\n        // value of fee in basis points\n        uint256 basisPoints;\n    }\n\n    // list of fees that are paid on rewards\n    Fee[] private fees;\n\n    // address of polygon stake manager\n    address public stakeManager;\n    // address of fund flow controller\n    address public fundFlowController;\n\n    // address of MEV rewards pool\n    IRewardsPool public validatorMEVRewardsPool;\n    // percentage of MEV rewards validators will receive\n    uint256 public validatorMEVRewardsPercentage;\n\n    // list of validators\n    Validator[] private validators;\n    // list of vaults\n    IPolygonVault[] private vaults;\n    // address of vault implementation contract to be used when deploying new vaults\n    address public vaultImplementation;\n\n    // queued validator removal state\n    ValidatorRemoval public validatorRemoval;\n\n    // total number of tokens staked in this strategy\n    uint256 private totalDeposits;\n    // total number of tokens queued for deposit into vaults\n    uint256 public totalQueued;\n    // total number of vaults currently unbonding\n    uint256 public numVaultsUnbonding;\n    // index of validator to withdraw from on next withdrawal\n    uint256 public validatorWithdrawalIndex;\n\n    event DepositQueuedTokens(int256 balanceChange);\n    event Unbond(uint256 amount);\n    event ForceUnbond(uint256 amount);\n    event UnstakeClaim(uint256 amount);\n    event RestakeRewards();\n    event AddValidator(address indexed pool, address rewardsReceiver);\n    event QueueValidatorRemoval(address indexed pool, address rewardsReceiver);\n    event FinalizeValidatorRemoval(address indexed pool);\n    event UpgradedVaults(address[] vaults);\n    event AddFee(address receiver, uint256 feeBasisPoints);\n    event UpdateFee(uint256 index, address receiver, uint256 feeBasisPoints);\n    event RemoveFee(uint256 index, address receiver, uint256 feeBasisPoints);\n    event SetValidatorMEVRewardsPercentage(uint256 validatorMEVRewardsPercentage);\n    event SetVaultImplementation(address vaultImplementation);\n\n    error FeesTooLarge();\n    error SenderNotAuthorized();\n    error UnbondingInProgress();\n    error MustWithdrawAllVaults();\n    error ValidatorAlreadyAdded();\n    error RemovalAlreadyQueued();\n    error NoRemovalQueued();\n    error InvalidVaultIds();\n    error InvalidAmount();\n    error NoVaultsUnbonding();\n    error InvalidAddress();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes contract\n     * @param _token address of POL token\n     * @param _stakingPool address of the staking pool that controls this strategy\n     * @param _stakeManager address of the Polygon stake manager\n     * @param _vaultImplementation address of the implementation contract to use when deploying new vaults\n     * @param _validatorMEVRewardsPercentage basis point amount of MEV fees that validators will receive\n     * @param _fees list of fees to be paid on rewards\n     **/\n    function initialize(\n        address _token,\n        address _stakingPool,\n        address _stakeManager,\n        address _vaultImplementation,\n        uint256 _validatorMEVRewardsPercentage,\n        Fee[] memory _fees\n    ) public initializer {\n        __Strategy_init(_token, _stakingPool);\n\n        stakeManager = _stakeManager;\n        vaultImplementation = _vaultImplementation;\n\n        if (_validatorMEVRewardsPercentage > 5000) revert FeesTooLarge();\n        validatorMEVRewardsPercentage = _validatorMEVRewardsPercentage;\n\n        for (uint256 i = 0; i < _fees.length; ++i) {\n            fees.push(_fees[i]);\n        }\n        if (_totalFeesBasisPoints() > 3000) revert FeesTooLarge();\n    }\n\n    /**\n     * @notice Reverts if sender is not fund flow controller\n     */\n    modifier onlyFundFlowController() {\n        if (msg.sender != fundFlowController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Returns a list of all validators\n     * @return list of validators\n     */\n    function getValidators() external view returns (Validator[] memory) {\n        return validators;\n    }\n\n    /**\n     * @notice Returns a list of all vaults controlled by this contract\n     * @return list of vault addresses\n     */\n    function getVaults() external view returns (IPolygonVault[] memory) {\n        return vaults;\n    }\n\n    /**\n     * @notice Deposits tokens from the staking pool into this strategy\n     * @param _amount amount to deposit\n     */\n    function deposit(uint256 _amount, bytes calldata) external onlyStakingPool {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        totalDeposits += _amount;\n        totalQueued += _amount;\n    }\n\n    /**\n     * @notice Withdraws tokens from this strategy and sends them to staking pool\n     * @param _amount amount to withdraw\n     */\n    function withdraw(uint256 _amount, bytes calldata) external onlyStakingPool {\n        token.safeTransfer(msg.sender, _amount);\n        totalDeposits -= _amount;\n        totalQueued -= _amount;\n    }\n\n    /**\n     * @notice Deposits queued tokens into vaults\n     * @param _vaultIds list of vaults to deposit into\n     * @param _amounts list of amounts to deposit into each vault\n     */\n    function depositQueuedTokens(\n        uint256[] calldata _vaultIds,\n        uint256[] calldata _amounts\n    ) external onlyFundFlowController {\n        if (numVaultsUnbonding != 0) revert UnbondingInProgress();\n\n        uint256 preBalance = token.balanceOf(address(this));\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            if (_vaultIds[i] == skipIndex) revert InvalidVaultIds();\n\n            uint256 amount = _amounts[i];\n            if (amount == 0) revert InvalidAmount();\n\n            vaults[_vaultIds[i]].deposit(amount);\n        }\n\n        // balance change could be positive if many rewards are claimed while depositing\n        int256 balanceChange = int256(token.balanceOf(address(this))) - int256(preBalance);\n        if (balanceChange < 0) {\n            totalQueued -= uint256(-1 * balanceChange);\n        } else if (balanceChange > 0) {\n            totalQueued += uint256(balanceChange);\n        }\n\n        emit DepositQueuedTokens(balanceChange);\n    }\n\n    /**\n     * @notice Unbonds token deposits in vaults\n     * @dev there are some edge cases caused by the reward claim mechanism where the\n     * amount unbonded will be slightly less than _toUnbond\n     * @param _toUnbond amount to unbond\n     */\n    function unbond(uint256 _toUnbond) external onlyFundFlowController {\n        if (numVaultsUnbonding != 0) revert UnbondingInProgress();\n        if (_toUnbond == 0) revert InvalidAmount();\n\n        uint256 toUnbondRemaining = _toUnbond;\n\n        uint256 i = validatorWithdrawalIndex;\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n        uint256 numVaultsUnbonded;\n        uint256 preBalance = token.balanceOf(address(this));\n\n        while (toUnbondRemaining != 0) {\n            if (i != skipIndex) {\n                IPolygonVault vault = vaults[i];\n                uint256 deposits = vault.getTotalDeposits();\n\n                if (deposits != 0) {\n                    uint256 principalDeposits = vault.getPrincipalDeposits();\n                    uint256 rewards = deposits - principalDeposits;\n\n                    if (rewards >= toUnbondRemaining && rewards >= vault.minRewardClaimAmount()) {\n                        vault.withdrawRewards();\n                        toUnbondRemaining = 0;\n                        break;\n                    } else if (principalDeposits != 0) {\n                        if (toUnbondRemaining > rewards) {\n                            toUnbondRemaining -= rewards;\n                        }\n\n                        uint256 vaultToUnbond = principalDeposits >= toUnbondRemaining\n                            ? toUnbondRemaining\n                            : principalDeposits;\n\n                        vault.unbond(vaultToUnbond);\n\n                        toUnbondRemaining -= vaultToUnbond;\n                        ++numVaultsUnbonded;\n                    }\n                }\n            }\n\n            ++i;\n            if (i >= vaults.length) i = 0;\n            if (i == validatorWithdrawalIndex) break;\n        }\n\n        if (numVaultsUnbonded != 0) {\n            validatorWithdrawalIndex = i;\n            numVaultsUnbonding = numVaultsUnbonded;\n        }\n\n        uint256 rewardsClaimed = token.balanceOf(address(this)) - preBalance;\n        if (rewardsClaimed != 0) totalQueued += rewardsClaimed;\n\n        emit Unbond(_toUnbond);\n    }\n\n    /**\n     * @notice Unbonds token deposits in vaults\n     * @dev used to rebalance deposits between vaults if necessary\n     * @param _vaultIds list of vaults to unbond\n     * @param _amounts list of amounts to unbond\n     */\n    function forceUnbond(\n        uint256[] calldata _vaultIds,\n        uint256[] calldata _amounts\n    ) external onlyFundFlowController {\n        if (numVaultsUnbonding != 0) revert UnbondingInProgress();\n\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n        uint256 totalUnbonded;\n        uint256 preBalance = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            if (_vaultIds[i] == skipIndex) revert InvalidVaultIds();\n            if (i > 0 && _vaultIds[i] <= _vaultIds[i - 1]) revert InvalidVaultIds();\n            if (_amounts[i] == 0) revert InvalidAmount();\n\n            vaults[_vaultIds[i]].unbond(_amounts[i]);\n            totalUnbonded += _amounts[i];\n        }\n\n        numVaultsUnbonding = _vaultIds.length;\n\n        uint256 rewardsClaimed = token.balanceOf(address(this)) - preBalance;\n        if (rewardsClaimed != 0) totalQueued += rewardsClaimed;\n\n        emit ForceUnbond(totalUnbonded);\n    }\n\n    /**\n     * @notice Claims and withdraws tokens from vaults that are unbonded\n     * @param _vaultIds list of vaults to withdraw from\n     */\n    function unstakeClaim(uint256[] calldata _vaultIds) external onlyFundFlowController {\n        if (numVaultsUnbonding == 0) revert NoVaultsUnbonding();\n\n        uint256 preBalance = token.balanceOf(address(this));\n        uint256 skipIndex = validatorRemoval.isActive\n            ? validatorRemoval.validatorId\n            : type(uint256).max;\n        uint256 vaultsWithdrawn;\n\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            if (_vaultIds[i] == skipIndex) revert InvalidVaultIds();\n\n            vaults[_vaultIds[i]].withdraw();\n            ++vaultsWithdrawn;\n        }\n\n        if (vaultsWithdrawn != numVaultsUnbonding) revert MustWithdrawAllVaults();\n        numVaultsUnbonding = 0;\n\n        uint256 amountWithdrawn = token.balanceOf(address(this)) - preBalance;\n        totalQueued += amountWithdrawn;\n\n        emit UnstakeClaim(amountWithdrawn);\n    }\n\n    /**\n     * @notice Returns the deposit change since deposits were last updated\n     * @dev deposit change could be positive or negative depending on reward rate and whether\n     * any slashing occurred\n     * @return deposit change\n     */\n    function getDepositChange() public view returns (int) {\n        uint256 totalBalance = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            totalBalance += vaults[i].getTotalDeposits();\n        }\n        return int(totalBalance) - int(totalDeposits);\n    }\n\n    /**\n     * @notice Updates deposit accounting and calculates fees on newly earned rewards\n     * @return depositChange change in deposits since last update\n     * @return receivers list of fee receivers\n     * @return amounts list of fee amounts\n     */\n    function updateDeposits(\n        bytes calldata\n    )\n        external\n        onlyStakingPool\n        returns (int256 depositChange, address[] memory receivers, uint256[] memory amounts)\n    {\n        depositChange = getDepositChange();\n        uint256 balance = token.balanceOf(address(this));\n\n        if (depositChange > 0) {\n            totalDeposits += uint256(depositChange);\n\n            uint256 validatorMEVRewards = ((balance - totalQueued) *\n                validatorMEVRewardsPercentage) / 10000;\n\n            receivers = new address[](fees.length + (validatorMEVRewards != 0 ? 1 : 0));\n            amounts = new uint256[](receivers.length);\n\n            for (uint256 i = 0; i < fees.length; ++i) {\n                receivers[i] = fees[i].receiver;\n                amounts[i] = (uint256(depositChange) * fees[i].basisPoints) / 10000;\n            }\n\n            if (validatorMEVRewards != 0) {\n                receivers[receivers.length - 1] = address(validatorMEVRewardsPool);\n                amounts[amounts.length - 1] = validatorMEVRewards;\n            }\n        } else if (depositChange < 0) {\n            totalDeposits -= uint256(depositChange * -1);\n        }\n\n        totalQueued = balance;\n    }\n\n    /**\n     * @notice Restakes rewards in the polygon staking contract\n     * @param _vaultIds list of vaults to restake rewards for\n     */\n    function restakeRewards(uint256[] calldata _vaultIds) external {\n        for (uint256 i = 0; i < _vaultIds.length; ++i) {\n            vaults[_vaultIds[i]].restakeRewards();\n        }\n\n        emit RestakeRewards();\n    }\n\n    /**\n     * @notice Returns the total amount of deposits as tracked in this strategy\n     * @return total deposits\n     */\n    function getTotalDeposits() public view override returns (uint256) {\n        return totalDeposits;\n    }\n\n    /**\n     * @notice Returns the maximum amount of tokens this strategy can hold\n     * @return maximum deposits\n     */\n    function getMaxDeposits() public view override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Returns the minimum amount of tokens that must remain in this strategy\n     * @return minimum deposits\n     */\n    function getMinDeposits() public view override returns (uint256) {\n        return totalDeposits > totalQueued ? totalDeposits - totalQueued : 0;\n    }\n\n    /**\n     * @notice Returns whether an account should receive validator rewards\n     * @dev used by the validator MEV rewards pool\n     * @return 1 for accounts that should receive rewards, 0 otherwise\n     */\n    function staked(address _account) public view returns (uint256) {\n        for (uint256 i = 0; i < validators.length; ++i) {\n            if (validators[i].rewardsReceiver == _account) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Returns the total number of active validators\n     * @dev used by the validator MEV rewards pool\n     * @return total number of active validators\n     */\n    function totalStaked() public view returns (uint256) {\n        uint256 totalValidators = validators.length;\n        if (validatorRemoval.isActive) --totalValidators;\n        return totalValidators;\n    }\n\n    /**\n     * @notice Adds a new validator\n     * @param _pool address of validator shares pool\n     * @param _rewardsReceiver address to receive validator share of MEV rewards\n     */\n    function addValidator(address _pool, address _rewardsReceiver) external onlyOwner {\n        for (uint256 i = 0; i < validators.length; ++i) {\n            if (validators[i].pool == _pool) revert ValidatorAlreadyAdded();\n        }\n        validatorMEVRewardsPool.updateReward(_rewardsReceiver);\n        validators.push(Validator(_pool, _rewardsReceiver));\n\n        address vault = address(\n            new ERC1967Proxy(\n                vaultImplementation,\n                abi.encodeWithSignature(\n                    \"initialize(address,address,address,address)\",\n                    address(token),\n                    address(this),\n                    stakeManager,\n                    _pool\n                )\n            )\n        );\n        token.safeApprove(vault, type(uint256).max);\n        vaults.push(IPolygonVault(vault));\n\n        emit AddValidator(_pool, _rewardsReceiver);\n    }\n\n    /**\n     * @notice Queues a validator for removal\n     * @param _validatorId id of validator to remove\n     */\n    function queueValidatorRemoval(uint256 _validatorId) external onlyOwner {\n        if (validatorRemoval.isActive) revert RemovalAlreadyQueued();\n\n        IPolygonVault vault = vaults[_validatorId];\n        uint256 principalDeposits = vault.getPrincipalDeposits();\n\n        if (vault.isUnbonding() || vault.isWithdrawable()) {\n            --numVaultsUnbonding;\n        }\n\n        if (principalDeposits != 0) {\n            uint256 preBalance = token.balanceOf(address(this));\n            vault.unbond(principalDeposits);\n            uint256 rewardsClaimed = token.balanceOf(address(this)) - preBalance;\n            if (rewardsClaimed != 0) totalQueued += rewardsClaimed;\n        }\n\n        validatorMEVRewardsPool.updateReward(validators[_validatorId].rewardsReceiver);\n\n        uint256 queuedWithdrawals = vault.getQueuedWithdrawals();\n        validatorRemoval = ValidatorRemoval(true, uint64(_validatorId), uint128(queuedWithdrawals));\n\n        emit QueueValidatorRemoval(\n            validators[_validatorId].pool,\n            validators[_validatorId].rewardsReceiver\n        );\n\n        delete validators[_validatorId].rewardsReceiver;\n    }\n\n    /**\n     * @notice Finalizes a queued validator removal\n     * @dev all vaults must be empty or unbonded\n     */\n    function finalizeValidatorRemoval() external onlyOwner {\n        if (!validatorRemoval.isActive) revert NoRemovalQueued();\n\n        uint256 validatorId = validatorRemoval.validatorId;\n        uint256 preBalance = token.balanceOf(address(this));\n\n        IPolygonVault vault = vaults[validatorId];\n        if (vault.getQueuedWithdrawals() != 0) {\n            vault.withdraw();\n        }\n\n        uint256 amountWithdrawn = token.balanceOf(address(this)) - preBalance;\n        totalQueued += amountWithdrawn;\n\n        token.safeApprove(address(vault), 0);\n\n        emit FinalizeValidatorRemoval(validators[validatorId].pool);\n\n        if (\n            validatorId == validators.length - 1 &&\n            validatorWithdrawalIndex == validators.length - 1\n        ) {\n            validatorWithdrawalIndex = 0;\n        } else if (validatorWithdrawalIndex > validatorId) {\n            --validatorWithdrawalIndex;\n        }\n\n        for (uint256 i = validatorId; i < validators.length - 1; ++i) {\n            validators[i] = validators[i + 1];\n            vaults[i] = vaults[i + 1];\n        }\n\n        validators.pop();\n        vaults.pop();\n\n        delete validatorRemoval;\n    }\n\n    /**\n     * @notice Upgrades vaults to a new implementation contract\n     * @param _vaults list of vauls to upgrade\n     * @param _data list of encoded function calls to be executed for each vault after upgrade\n     */\n    function upgradeVaults(address[] calldata _vaults, bytes[] memory _data) external onlyOwner {\n        for (uint256 i = 0; i < _vaults.length; ++i) {\n            if (_data.length == 0 || _data[i].length == 0) {\n                IPolygonVault(_vaults[i]).upgradeTo(vaultImplementation);\n            } else {\n                IPolygonVault(_vaults[i]).upgradeToAndCall(vaultImplementation, _data[i]);\n            }\n        }\n        emit UpgradedVaults(_vaults);\n    }\n\n    /**\n     * @notice Returns a list of all fees and fee receivers\n     * @return list of fees\n     */\n    function getFees() external view returns (Fee[] memory) {\n        return fees;\n    }\n\n    /**\n     * @notice Adds a new fee\n     * @dev stakingPool.updateStrategyRewards is called to credit all past fees at\n     * the old rate before the percentage changes\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function addFee(address _receiver, uint256 _feeBasisPoints) external onlyOwner {\n        _updateStrategyRewards();\n        fees.push(Fee(_receiver, _feeBasisPoints));\n        if (_totalFeesBasisPoints() > 3000) revert FeesTooLarge();\n        emit AddFee(_receiver, _feeBasisPoints);\n    }\n\n    /**\n     * @notice Updates an existing fee\n     * @dev stakingPool.updateStrategyRewards is called to credit all past fees at\n     * the old rate before the percentage changes\n     * @param _index index of fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function updateFee(\n        uint256 _index,\n        address _receiver,\n        uint256 _feeBasisPoints\n    ) external onlyOwner {\n        _updateStrategyRewards();\n\n        if (_feeBasisPoints == 0) {\n            Fee memory toRemove = fees[_index];\n            fees[_index] = fees[fees.length - 1];\n            fees.pop();\n            emit RemoveFee(_index, toRemove.receiver, toRemove.basisPoints);\n        } else {\n            fees[_index].receiver = _receiver;\n            fees[_index].basisPoints = _feeBasisPoints;\n            if (_totalFeesBasisPoints() > 3000) revert FeesTooLarge();\n            emit UpdateFee(_index, _receiver, _feeBasisPoints);\n        }\n    }\n\n    /**\n     * @notice Sets the validator MEV rewards pool\n     * @param _validatorMEVRewardsPool address of rewards pool\n     */\n    function setValidatorMEVRewardsPool(address _validatorMEVRewardsPool) external onlyOwner {\n        if (_validatorMEVRewardsPool == address(0)) revert InvalidAddress();\n        validatorMEVRewardsPool = IRewardsPool(_validatorMEVRewardsPool);\n    }\n\n    /**\n     * @notice Sets the percentage of MEV rewards that validators receiver\n     * @param _validatorMEVRewardsPercentage basis point amount\n     */\n    function setValidatorMEVRewardsPercentage(\n        uint256 _validatorMEVRewardsPercentage\n    ) external onlyOwner {\n        if (_validatorMEVRewardsPercentage > 5000) revert FeesTooLarge();\n\n        validatorMEVRewardsPercentage = _validatorMEVRewardsPercentage;\n        emit SetValidatorMEVRewardsPercentage(_validatorMEVRewardsPercentage);\n    }\n\n    /**\n     * @notice Sets a new vault implementation contract to be used when deploying/upgrading vaults\n     * @param _vaultImplementation address of implementation contract\n     */\n    function setVaultImplementation(address _vaultImplementation) external onlyOwner {\n        if (_vaultImplementation == address(0)) revert InvalidAddress();\n        vaultImplementation = _vaultImplementation;\n        emit SetVaultImplementation(_vaultImplementation);\n    }\n\n    /**\n     * @notice Sets the fund flow controller\n     * @param _fundFlowController address of fund flow controller\n     */\n    function setFundFlowController(address _fundFlowController) external onlyOwner {\n        if (_fundFlowController == address(0)) revert InvalidAddress();\n        fundFlowController = _fundFlowController;\n    }\n\n    /**\n     * @notice Updates rewards for all strategies controlled by the staking pool\n     * @dev called before fees are changed to credit any past rewards at the old rate\n     */\n    function _updateStrategyRewards() internal {\n        address[] memory strategies = stakingPool.getStrategies();\n        uint256[] memory strategyIdxs = new uint256[](strategies.length);\n        for (uint256 i = 0; i < strategies.length; ++i) {\n            strategyIdxs[i] = i;\n        }\n        stakingPool.updateStrategyRewards(strategyIdxs, \"\");\n    }\n\n    /**\n     * @notice Returns the sum of all fees\n     * @return sum of fees in basis points\n     **/\n    function _totalFeesBasisPoints() private view returns (uint256) {\n        uint256 totalFees;\n        for (uint i = 0; i < fees.length; ++i) {\n            totalFees += fees[i].basisPoints;\n        }\n        return totalFees;\n    }\n}\n"
    }
}