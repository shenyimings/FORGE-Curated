{
    "vfp_id": "vfp_00510",
    "project_name": "ChainSecurity_Enzyme_SuluExtensionsXXIV_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Unpriced Left Tickets",
            "description": "1. **Description:** The vulnerability involves the incorrect pricing of exit requests in the Stakewise V3 external position, where partially withdrawable exit requests could leave unpriced \"left tickets\" in the system. This leads to an undervaluation of the position when calculating managed assets.\n2. **Cause:** The root cause is that the `getManagedAssets()` function only accounts for the claimed assets from exit requests using `calculateExitedAssets()`, but does not consider the remaining unclaimed or pending exit shares (leftTickets), which should also contribute to the position value.\n3. **Exploitation:** An attacker could potentially manipulate or exploit the valuation discrepancy during asset reporting or fund withdrawal, especially in scenarios where partial exits are common, leading to incorrect net asset value calculations.\n4. **Impact:** The impact includes inaccurate valuation of the fund's managed assets, which could affect investor decisions, rebalancing operations, or profit calculations, ultimately undermining trust in the system's financial accuracy.\n",
            "severity": "Low",
            "location": [
                "StakeWiseV3StakingPositionLib.sol::getManagedAssets"
            ],
            "files": [
                "protocol/contracts/release/extensions/external-position-manager/external-positions/stakewise-v3-staking/StakeWiseV3StakingPositionLib.sol"
            ]
        }
    ],
    "affected_files": {
        "StakeWiseV3StakingPositionLib.sol": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Foundation <security@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.8.19;\n\nimport {Address} from \"openzeppelin-solc-0.8/utils/Address.sol\";\nimport {IStakeWiseV3EthVault} from \"../../../../../external-interfaces/IStakeWiseV3EthVault.sol\";\nimport {IWETH} from \"../../../../../external-interfaces/IWETH.sol\";\nimport {IAddressListRegistry} from \"../../../../../persistent/address-list-registry/IAddressListRegistry.sol\";\nimport {AddressArrayLib} from \"../../../../../utils/0.8.19/AddressArrayLib.sol\";\nimport {StakeWiseV3StakingPositionLibBase1} from \"./bases/StakeWiseV3StakingPositionLibBase1.sol\";\nimport {IStakeWiseV3StakingPosition} from \"./IStakeWiseV3StakingPosition.sol\";\nimport {StakeWiseV3StakingPositionDataDecoder} from \"./StakeWiseV3StakingPositionDataDecoder.sol\";\n\n/// @title StakeWiseV3StakingPositionLib Contract\n/// @author Enzyme Foundation <security@enzyme.finance>\n/// @notice An External Position library contract for StakeWiseV3 Staking Positions\ncontract StakeWiseV3StakingPositionLib is\n    IStakeWiseV3StakingPosition,\n    StakeWiseV3StakingPositionDataDecoder,\n    StakeWiseV3StakingPositionLibBase1\n{\n    using AddressArrayLib for address[];\n\n    IWETH public immutable WETH_TOKEN;\n    address private immutable REFERRER_ADDRESS;\n    IAddressListRegistry public immutable ADDRESS_LIST_REGISTRY;\n    uint256 public immutable SUPPORTED_IMPLEMENTATIONS_LIST_ID;\n\n    constructor(\n        address _wethToken,\n        address _referrer,\n        IAddressListRegistry _addressListRegistry,\n        uint256 _supportedImplementationsListID\n    ) {\n        WETH_TOKEN = IWETH(_wethToken);\n        REFERRER_ADDRESS = _referrer;\n        ADDRESS_LIST_REGISTRY = _addressListRegistry;\n        SUPPORTED_IMPLEMENTATIONS_LIST_ID = _supportedImplementationsListID;\n    }\n\n    /// @notice Initializes the external position\n    /// @dev Nothing to initialize for this contract\n    function init(bytes memory) external override {}\n\n    /// @param _actionData Encoded data to execute the action\n    function receiveCallFromVault(bytes memory _actionData) external override {\n        (uint256 actionId, bytes memory actionArgs) = abi.decode(_actionData, (uint256, bytes));\n\n        if (actionId == uint256(Actions.Stake)) {\n            __stake(actionArgs);\n        } else if (actionId == uint256(Actions.Redeem)) {\n            revert(\"receiveCallFromVault: Redeem is a legacy method that is now unsupported\");\n        } else if (actionId == uint256(Actions.EnterExitQueue)) {\n            __enterExitQueue(actionArgs);\n        } else if (actionId == uint256(Actions.ClaimExitedAssets)) {\n            __claimExitedAssets(actionArgs);\n        }\n    }\n\n    /// @dev Stakes ETH to StakeWiseV3 deposit contract\n    function __stake(bytes memory _actionArgs) private {\n        (IStakeWiseV3EthVault stakeWiseVault, uint256 assetAmount) = __decodeStakeActionArgs(_actionArgs);\n\n        __validateStakeWiseVault(stakeWiseVault);\n\n        WETH_TOKEN.withdraw(assetAmount);\n\n        IStakeWiseV3EthVault(stakeWiseVault).deposit{value: assetAmount}({\n            _receiver: address(this),\n            _referrer: REFERRER_ADDRESS\n        });\n\n        if (!stakeWiseVaultTokens.storageArrayContains(address(stakeWiseVault))) {\n            stakeWiseVaultTokens.push(address(stakeWiseVault));\n\n            emit VaultTokenAdded(address(stakeWiseVault));\n        }\n    }\n\n    /// @dev Locks shares to the exit queue.\n    function __enterExitQueue(bytes memory _actionArgs) private {\n        (IStakeWiseV3EthVault stakeWiseVault, uint256 sharesAmount) = __decodeEnterExitQueueActionArgs(_actionArgs);\n\n        __validateStakeWiseVault(stakeWiseVault);\n\n        uint256 positionTicket = stakeWiseVault.enterExitQueue({_shares: sharesAmount, _receiver: address(this)});\n\n        // If the positionTicket is type(uint256).max, it means that the shares were redeemed directly\n        if (positionTicket == type(uint256).max) {\n            // Transfer the ETH balance to the vaultProxy\n            Address.sendValue(payable(msg.sender), address(this).balance);\n        } else {\n            // Add ExitRequest to storage\n            exitRequests.push(\n                ExitRequest({\n                    stakeWiseVaultAddress: address(stakeWiseVault),\n                    positionTicket: positionTicket,\n                    timestamp: block.timestamp,\n                    sharesAmount: sharesAmount\n                })\n            );\n\n            emit ExitRequestAdded(address(stakeWiseVault), positionTicket, block.timestamp, sharesAmount);\n        }\n\n        // Remove StakeWiseVaultToken from storage if exited in full\n        __removeStakeWiseVaultTokenIfNoBalance(stakeWiseVault);\n    }\n\n    /// @dev Claims assets that were exited.\n    function __claimExitedAssets(bytes memory _actionArgs) private {\n        (IStakeWiseV3EthVault stakeWiseVault, uint256 positionTicket, uint256 timestamp) =\n            __decodeClaimExitedAssetsActionArgs(_actionArgs);\n\n        __validateStakeWiseVault(stakeWiseVault);\n\n        int256 exitQueueIndex = stakeWiseVault.getExitQueueIndex({_positionTicket: positionTicket});\n        require(exitQueueIndex >= 0, \"__claimExitedAssets: positionTicket is not in exit queue\");\n\n        // Since V2, claimExitedAssets does not provide a return value, we have to call the following manually to get the tickets left\n        (uint256 leftTickets, uint256 exitedTickets,) = stakeWiseVault.calculateExitedAssets({\n            _receiver: address(this),\n            _positionTicket: positionTicket,\n            _timestamp: timestamp,\n            _exitQueueIndex: uint256(exitQueueIndex)\n        });\n\n        // Claim the position ticket\n        stakeWiseVault.claimExitedAssets({\n            _positionTicket: positionTicket,\n            _timestamp: timestamp,\n            _exitQueueIndex: uint256(exitQueueIndex)\n        });\n\n        // Update or remove the ExitRequest\n        uint256 finalExitRequestsIndex = exitRequests.length - 1;\n        for (uint256 i; i <= finalExitRequestsIndex; i++) {\n            ExitRequest storage exitRequest = exitRequests[i];\n\n            if (\n                exitRequest.stakeWiseVaultAddress == address(stakeWiseVault)\n                    && exitRequest.positionTicket == positionTicket\n            ) {\n                // Replicating StakeWise's internal logic. Updating the position if there are still tickets left (leaving one for rounding error)\n                if (leftTickets > 1) {\n                    uint256 nextPositionTicket = positionTicket + exitedTickets;\n                    // If the claim was only partial, update the ExitRequest\n                    exitRequest.positionTicket = nextPositionTicket;\n                    exitRequest.sharesAmount = leftTickets;\n\n                    // New requests added in the context of a partial claim keep the original timestamp\n                    emit ExitRequestAdded(address(stakeWiseVault), nextPositionTicket, timestamp, leftTickets);\n                } else {\n                    // If the claim was in full, remove the ExitRequest from exitRequests\n                    if (i != finalExitRequestsIndex) {\n                        exitRequests[i] = exitRequests[finalExitRequestsIndex];\n                    }\n                    exitRequests.pop();\n                }\n\n                emit ExitRequestRemoved(address(stakeWiseVault), positionTicket);\n\n                break;\n            }\n        }\n\n        // Transfer the ETH balance to the vaultProxy\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @dev Helper to remove a stakeWiseVaultToken from storage and emit the corresponding event if balance is 0\n    function __removeStakeWiseVaultTokenIfNoBalance(IStakeWiseV3EthVault _stakeWiseVault) private {\n        if (_stakeWiseVault.getShares(address(this)) == 0) {\n            stakeWiseVaultTokens.removeStorageItem(address(_stakeWiseVault));\n            emit VaultTokenRemoved(address(_stakeWiseVault));\n        }\n    }\n\n    /// @dev Helper to validate that a StakeWise implementation belongs to the allowed lists\n    function __validateStakeWiseVault(IStakeWiseV3EthVault _stakeWiseVault) private view {\n        require(\n            ADDRESS_LIST_REGISTRY.isInList({\n                _id: SUPPORTED_IMPLEMENTATIONS_LIST_ID,\n                _item: _stakeWiseVault.implementation()\n            }),\n            \"__validateStakeWiseVault: Unregistered implementation\"\n        );\n    }\n\n    ////////////////////\n    // POSITION VALUE //\n    ////////////////////\n\n    /// @notice Retrieves the debt assets (negative value) of the external position\n    /// @return assets_ Debt assets\n    /// @return amounts_ Debt asset amounts\n    function getDebtAssets() external pure override returns (address[] memory assets_, uint256[] memory amounts_) {\n        return (assets_, amounts_);\n    }\n\n    /// @notice Retrieves the managed assets (positive value) of the external position\n    /// @return assets_ Managed assets\n    /// @return amounts_ Managed asset amounts\n    /// @dev Reverts if any position (stakeWiseVaultTokens or pending exit requests) belong to an unsupported StakeWise vault implementation\n    function getManagedAssets() external view override returns (address[] memory assets_, uint256[] memory amounts_) {\n        // If no stakeWiseVaultToken is held and no exitRequests are pending, return empty arrays.\n        uint256 stakeWiseVaultTokensLength = stakeWiseVaultTokens.length;\n        uint256 exitRequestsLength = exitRequests.length;\n\n        if (stakeWiseVaultTokensLength == 0 && exitRequestsLength == 0) {\n            return (assets_, amounts_);\n        }\n\n        assets_ = new address[](1);\n        amounts_ = new uint256[](1);\n\n        assets_[0] = address(WETH_TOKEN);\n\n        // stakeWiseVaultTokens held by the EP\n        for (uint256 i; i < stakeWiseVaultTokensLength; i++) {\n            IStakeWiseV3EthVault stakeWiseVault = IStakeWiseV3EthVault(stakeWiseVaultTokens[i]);\n\n            __validateStakeWiseVault(stakeWiseVault);\n\n            amounts_[0] += stakeWiseVault.convertToAssets({_shares: stakeWiseVault.getShares(address(this))});\n        }\n\n        // Pending exit requests\n        for (uint256 i; i < exitRequestsLength; i++) {\n            ExitRequest memory exitRequest = exitRequests[i];\n\n            IStakeWiseV3EthVault stakeWiseVault = IStakeWiseV3EthVault(exitRequest.stakeWiseVaultAddress);\n\n            __validateStakeWiseVault(stakeWiseVault);\n\n            // If the positionTicket is invalid or already claimed, the exit queue index will be -1\n            int256 exitQueueIndex = stakeWiseVault.getExitQueueIndex({_positionTicket: exitRequest.positionTicket});\n\n            // A missing positionTicket means that the VaultState has not been updated.\n            // In this case, we fallback to valuing the exitRequest based on the sharePrice\n            if (exitQueueIndex < 0) {\n                amounts_[0] += stakeWiseVault.convertToAssets({_shares: exitRequest.sharesAmount});\n                continue;\n            }\n\n            (,, uint256 claimedAssets) = stakeWiseVault.calculateExitedAssets({\n                _receiver: address(this),\n                _positionTicket: exitRequest.positionTicket,\n                _timestamp: exitRequest.timestamp,\n                _exitQueueIndex: uint256(exitQueueIndex)\n            });\n\n            amounts_[0] += claimedAssets;\n        }\n\n        return (assets_, amounts_);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the exitRequests var\n    /// @return exitRequests_ The stakeWise exit requests\n    function getExitRequests() public view returns (ExitRequest[] memory exitRequests_) {\n        return exitRequests;\n    }\n\n    /// @notice Gets the stakeWiseVaultTokens var\n    /// @return stakeWiseVaultTokens_ The stakeWiseVaultTokens var\n    function getStakeWiseVaultTokens() public view returns (address[] memory stakeWiseVaultTokens_) {\n        return stakeWiseVaultTokens;\n    }\n}\n"
    }
}