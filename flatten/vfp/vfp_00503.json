{
    "vfp_id": "vfp_00503",
    "project_name": "2025.08.14 - Final - Malda Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Wrong direction of rounding in redeem may lead to drain if exchange rate grows large",
            "description": "In the mToken contract, the redeem function uses `div_` (rounding down) when calculating the number of tokens to burn in exchange for underlying assets. This causes the protocol to burn fewer shares than it should, while still sending out the full requested amount of underlying. Over many transactions, this discrepancy can be exploited. The root cause is the incorrect rounding direction in the division operation during redeem logic. An attacker can manipulate the exchange rate by repeatedly depositing and redeeming small amounts when the supply is low, inflating the exchange rate significantly. Once the exchange rate is large enough, the rounding error becomes substantial, allowing the attacker to withdraw large amounts of underlying while burning negligible shares. The impact is a potential economic drain on the protocol's reserves.\n",
            "severity": "Medium",
            "location": [
                "mToken.sol#614-630",
                "mToken.sol#699-707"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/mToken.sol"
            ]
        }
    ],
    "affected_files": {
        "mToken.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\n// interfaces\nimport {ImToken, ImTokenMinimal} from \"src/interfaces/ImToken.sol\";\nimport {IInterestRateModel} from \"src/interfaces/IInterestRateModel.sol\";\nimport {IOperator, IOperatorDefender} from \"src/interfaces/IOperator.sol\";\n\n// contracts\nimport {mTokenConfiguration} from \"./mTokenConfiguration.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nabstract contract mToken is mTokenConfiguration, ReentrancyGuard {\n    constructor() {\n        borrowRateMaxMantissa = 0.0005e16;\n    }\n    /**\n     * @notice Initialize the money market\n     * @param operator_ The address of the Operator\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n\n    function _initializeMToken(\n        address operator_,\n        address interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        require(accrualBlockTimestamp == 0 && borrowIndex == 0, mt_AlreadyInitialized());\n        require(initialExchangeRateMantissa_ > 0, mt_ExchangeRateNotValid());\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        _setOperator(operator_);\n\n        accrualBlockTimestamp = _getBlockTimestamp();\n        borrowIndex = mantissaOne;\n\n        _setInterestRateModel(interestRateModel_);\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    // ----------- TOKENS VIEW ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @inheritdoc ImTokenMinimal\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    // ----------- MARKETS VIEW ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256) {\n        return (accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function borrowRatePerBlock() external view override returns (uint256) {\n        return IInterestRateModel(interestRateModel).getBorrowRate(_getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return IInterestRateModel(interestRateModel).getSupplyRate(\n            _getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa\n        );\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function borrowBalanceStored(address account) external view override returns (uint256) {\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function getCash() external view override returns (uint256) {\n        return _getCashPrior();\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function exchangeRateStored() external view override returns (uint256) {\n        return _exchangeRateStored();\n    }\n\n    // ----------- TOKENS PUBLIC ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, msg.sender, dst, amount);\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, src, dst, amount);\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        transferAllowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // ----------- MARKETS PUBLIC ------------\n    /**\n     * @inheritdoc ImToken\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n        _accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n        _accrueInterest();\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\n        _accrueInterest();\n        return _exchangeRateStored();\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external override nonReentrant {\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @inheritdoc ImToken\n     */\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\n        require(\n            msg.sender == admin || rolesOperator.isAllowedFor(msg.sender, rolesOperator.GUARDIAN_RESERVE()),\n            mt_OnlyAdminOrRole()\n        );\n\n        _accrueInterest();\n\n        require(_getCashPrior() >= reduceAmount, mt_ReserveCashNotAvailable());\n        require(reduceAmount <= totalReserves, mt_ReserveCashNotAvailable());\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew = totalReserves - reduceAmount;\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        _doTransferOut(payable(msg.sender), reduceAmount);\n        totalUnderlying -= reduceAmount;\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n    }\n\n    // ----------- INTERNAL VIEW ------------\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function _borrowBalanceStored(address account) internal view returns (uint256) {\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return 0;\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n        return principalTimesIndex / borrowSnapshot.interestIndex;\n    }\n\n    // ----------- INTERNAL ------------\n    /**\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param user The user address\n     * @param user The receiver address\n     * @param mintAmount The amount of the underlying asset to supply\n     * @param minAmountOut The minimum amount to be received\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _mint(address user, address receiver, uint256 mintAmount, uint256 minAmountOut, bool doTransfer)\n        internal\n        nonReentrant\n    {\n        _accrueInterest();\n        // emits the actual Mint event if successful and logs on errors, so we don't need to\n        __mint(user, receiver, mintAmount, minAmountOut, doTransfer);\n    }\n\n    /**\n     * @notice Sender redeems mTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param user The user address\n     * @param redeemTokens The number of mTokens to redeem into underlying\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _redeem(address user, uint256 redeemTokens, bool doTransfer)\n        internal\n        nonReentrant\n        returns (uint256 underlyingAmount)\n    {\n        _accrueInterest();\n        // emits redeem-specific logs on errors, so we don't need to\n        underlyingAmount = __redeem(payable(user), redeemTokens, 0, doTransfer);\n    }\n\n    /**\n     * @notice Sender redeems mTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param user The user address\n     * @param redeemAmount The amount of underlying to receive from redeeming mTokens\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _redeemUnderlying(address user, uint256 redeemAmount, bool doTransfer) internal nonReentrant {\n        _accrueInterest();\n        // emits redeem-specific logs on errors, so we don't need to\n        __redeem(payable(user), 0, redeemAmount, doTransfer);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param user The user address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _borrow(address user, uint256 borrowAmount, bool doTransfer) internal nonReentrant {\n        _accrueInterest();\n        // emits borrow-specific logs on errors, so we don't need to\n        __borrow(payable(user), payable(user), borrowAmount, doTransfer);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param user The user address\n     * @param receiver The underlying receiver address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     */\n    function _borrowWithReceiver(address user, address receiver, uint256 borrowAmount) internal nonReentrant {\n        _accrueInterest();\n        __borrow(payable(user), payable(receiver), borrowAmount, true);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or `type(uint256).max` for the full outstanding amount\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _repay(uint256 repayAmount, bool doTransfer) internal nonReentrant returns (uint256) {\n        _accrueInterest();\n        // emits repay-borrow-specific logs on errors, so we don't need to\n        return __repay(msg.sender, msg.sender, repayAmount, doTransfer);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or `type(uint256).max` for the full outstanding amount\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _repayBehalf(address borrower, uint256 repayAmount, bool doTransfer)\n        internal\n        nonReentrant\n        returns (uint256)\n    {\n        _accrueInterest();\n        // emits repay-borrow-specific logs on errors, so we don't need to\n        return __repay(msg.sender, borrower, repayAmount, doTransfer);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param liquidator The liquidator address\n     * @param borrower The borrower of this mToken to be liquidated\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function _liquidate(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address mTokenCollateral,\n        bool doTransfer\n    ) internal nonReentrant {\n        _accrueInterest();\n\n        ImToken(mTokenCollateral).accrueInterest();\n\n        // emits borrow-specific logs on errors, so we don't need to\n        __liquidate(liquidator, borrower, repayAmount, mTokenCollateral, doTransfer);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another mToken.\n     *  Its absolutely critical to use msg.sender as the seizer mToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed mToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of mTokens to seize\n     */\n    function _seize(address seizerToken, address liquidator, address borrower, uint256 seizeTokens) internal {\n        IOperatorDefender(operator).beforeMTokenSeize(address(this), seizerToken, liquidator, borrower);\n\n        require(borrower != liquidator, mt_InvalidInput());\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        uint256 protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: PROTOCOL_SEIZE_SHARE_MANTISSA}));\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\n        uint256 totalReservesNew = totalReserves + protocolSeizeAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the calculated values into storage */\n        totalReserves = totalReservesNew;\n        totalSupply = totalSupply - protocolSeizeTokens;\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     */\n    function _addReserves(uint256 addAmount) internal nonReentrant {\n        _accrueInterest();\n\n        // totalReserves + actualAddAmount\n        uint256 totalReservesNew;\n        uint256 actualAddAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the mToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n\n        actualAddAmount = _doTransferIn(msg.sender, addAmount);\n        totalUnderlying += actualAddAmount;\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    // ----------- PRIVATE ------------\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param borrower The borrower of this mToken to be liquidated\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param doTransfer If an actual transfer should be performed\n     */\n    function __liquidate(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address mTokenCollateral,\n        bool doTransfer\n    ) internal {\n        require(borrower != liquidator, mt_InvalidInput());\n        require(repayAmount > 0 && repayAmount != type(uint256).max, mt_InvalidInput());\n\n        IOperatorDefender(operator).beforeMTokenLiquidate(address(this), mTokenCollateral, borrower, repayAmount);\n\n        require(\n            ImToken(mTokenCollateral).accrualBlockTimestamp() == _getBlockTimestamp(),\n            mt_CollateralBlockTimestampNotValid()\n        );\n\n        /* Fail if repayBorrow fails */\n        uint256 actualRepayAmount = __repay(liquidator, borrower, repayAmount, doTransfer);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        uint256 seizeTokens =\n            IOperator(operator).liquidateCalculateSeizeTokens(address(this), mTokenCollateral, actualRepayAmount);\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(ImToken(mTokenCollateral).balanceOf(borrower) >= seizeTokens, mt_LiquidateSeizeTooMuch());\n\n        // If this is also the collateral, run _seize to avoid re-entrancy, otherwise make an external call\n        if (address(mTokenCollateral) == address(this)) {\n            _seize(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            ImToken(mTokenCollateral).seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(mTokenCollateral), seizeTokens);\n    }\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of underlying tokens being returned, or `type(uint256).max` for the full outstanding amount\n     * @param doTransfer If an actual transfer should be performed\n     */\n\n    function __repay(address payer, address borrower, uint256 repayAmount, bool doTransfer) private returns (uint256) {\n        IOperatorDefender(operator).beforeMTokenRepay(address(this), borrower);\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\n\n        /* If repayAmount == type(uint256).max , repayAmount = accountBorrows */\n        uint256 repayAmountFinal = repayAmount == type(uint256).max ? accountBorrowsPrev : repayAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call _doTransferIn for the payer and the repayAmount\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the mToken holds an additional repayAmount of cash.\n         *  _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        uint256 actualRepayAmount = doTransfer ? _doTransferIn(payer, repayAmountFinal) : repayAmountFinal;\n        totalUnderlying += actualRepayAmount;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n        return actualRepayAmount;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     */\n    function __borrow(address payable borrower, address payable receiver, uint256 borrowAmount, bool doTransfer)\n        private\n    {\n        IOperatorDefender(operator).beforeMTokenBorrow(address(this), borrower, borrowAmount);\n\n        require(_getCashPrior() >= borrowAmount, mt_BorrowCashNotAvailable());\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowNew = accountBorrow + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        if (doTransfer) {\n            /*\n            * We invoke _doTransferOut for the borrower and the borrowAmount.\n            *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n            *  On success, the mToken borrowAmount less of cash.\n            *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n            */\n            _doTransferOut(receiver, borrowAmount);\n        }\n        totalUnderlying -= borrowAmount;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n    }\n\n    function __redeem(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, bool doTransfer)\n        private\n        returns (uint256 redeemAmount)\n    {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, mt_InvalidInput());\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\n\n        uint256 redeemTokens;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n        if (redeemTokens == 0 && redeemAmount == 0) revert mt_RedeemEmpty();\n\n        /* Fail if redeem not allowed */\n        IOperatorDefender(operator).beforeMTokenRedeem(address(this), redeemer, redeemTokens);\n\n        require(_getCashPrior() >= redeemAmount, mt_RedeemCashNotAvailable());\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n         */\n        totalSupply = totalSupply - redeemTokens;\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n        /*\n         * We invoke _doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the mToken has redeemAmount less of cash.\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        if (doTransfer) _doTransferOut(redeemer, redeemAmount);\n        totalUnderlying -= redeemAmount;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), redeemTokens);\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\n    }\n    /**\n     * @notice User supplies assets into the market and receives mTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param receiver The address of the account which is receiving the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @param minAmountOut The min amount to be received\n     * @param doTransfer If an actual transfer should be performed\n     */\n\n    function __mint(address minter, address receiver, uint256 mintAmount, uint256 minAmountOut, bool doTransfer)\n        private\n    {\n        IOperatorDefender(operator).beforeMTokenMint(address(this), minter);\n\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `_doTransferIn` for the minter and the mintAmount.\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\n         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the mToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        uint256 actualMintAmount = doTransfer ? _doTransferIn(minter, mintAmount) : mintAmount;\n        totalUnderlying += actualMintAmount;\n\n        /*\n         * We get the current exchange rate and calculate the number of mTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\n        require(mintTokens >= minAmountOut, mt_MinAmountNotValid());\n\n        // avoid exchangeRate manipulation\n        if (totalSupply == 0) {\n            totalSupply = 1000;\n            accountTokens[address(0)] = 1000;\n            mintTokens -= 1000;\n        }\n\n        /*\n         * We calculate the new total supply of mTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[receiver] = accountTokens[receiver] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, receiver, actualMintAmount, mintTokens);\n        emit Transfer(address(this), receiver, mintTokens);\n\n        /* We call the defense hook */\n        IOperatorDefender(operator).afterMTokenMint(address(this));\n\n        // Activate market by default if not entered already\n        bool isEntered = IOperator(operator).checkMembership(minter, address(this));\n        if (!isEntered) {\n            IOperator(operator).enterMarketsWithSender(minter);\n        }\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     */\n    function _transferTokens(address spender, address src, address dst, uint256 tokens) private {\n        IOperatorDefender(operator).beforeMTokenTransfer(address(this), src, dst, tokens);\n\n        require(src != dst, mt_TransferNotValid());\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint256 allowanceNew = startingAllowance - tokens;\n        uint256 srcTokensNew = accountTokens[src] - tokens;\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint256).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n    }\n}\n"
    }
}