{
    "vfp_id": "vfp_00634",
    "project_name": "Berachain BEND v2 - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Compromised MetaFeePartitioner owner could halt MetaMorphoV1_1 vaults",
            "description": "1. **Description:** The MetaMorphoV1_1 vault operations (deposit, mint, withdraw, redeem) and administrative functions (setFee, setFeeRecipient) all call _accrueInterest(), which in turn calls FEE_PARTITIONER.getShares() when feeShares is nonzero. Since FEE_PARTITIONER is an upgradable contract, a compromised owner could upgrade it to a malicious implementation that reverts on getShares(), thereby blocking all vault operations that require fee accrual.\n\n2. **Cause:** The vulnerability stems from the centralization risk inherent in the upgradable MetaFeePartitioner contract. The FEE_PARTITIONER address is set as immutable during deployment, creating a permanent dependency. Because the contract is upgradeable via UUPS, a single compromised owner key can introduce a malicious implementation.\n\n3. **Exploitation:** An attacker who gains control of the MetaFeePartitioner owner's private key could deploy a malicious upgrade where getShares() always reverts. This would cause _accrueInterest() to revert whenever feeShares != 0, effectively halting all critical vault functions in MetaMorphoV1_1.\n\n4. **Impact:** The impact is operational disruption â€” an attacker could freeze all MetaMorphoV1_1 vaults that have nonzero feeShares, preventing users from depositing, withdrawing, minting, or redeeming assets. While funds are not directly at risk of theft, the protocol's functionality would be severely degraded.\n",
            "severity": "Informational",
            "location": [
                "MetaMorphoV1_1.sol::_accrueInterest",
                "MetaFeePartitioner.sol::getShares"
            ],
            "files": [
                "contracts-metamorpho-v1.1/src/MetaMorphoV1_1.sol"
            ]
        }
    ],
    "affected_files": {
        "MetaMorphoV1_1.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.26;\n\nimport {\n    MarketConfig,\n    PendingUint192,\n    PendingAddress,\n    MarketAllocation,\n    IMetaMorphoV1_1Base,\n    IMetaMorphoV1_1StaticTyping\n} from \"./interfaces/IMetaMorphoV1_1.sol\";\nimport {Id, MarketParams, Market, IMorpho} from \"../lib/morpho-blue/src/interfaces/IMorpho.sol\";\n\nimport {PendingUint192, PendingAddress, PendingLib} from \"./libraries/PendingLib.sol\";\nimport {ConstantsLib} from \"./libraries/ConstantsLib.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\nimport {EventsLib} from \"./libraries/EventsLib.sol\";\nimport {WAD} from \"../lib/morpho-blue/src/libraries/MathLib.sol\";\nimport {UtilsLib} from \"../lib/morpho-blue/src/libraries/UtilsLib.sol\";\nimport {SafeCast} from \"../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\nimport {SharesMathLib} from \"../lib/morpho-blue/src/libraries/SharesMathLib.sol\";\nimport {MorphoLib} from \"../lib/morpho-blue/src/libraries/periphery/MorphoLib.sol\";\nimport {MarketParamsLib} from \"../lib/morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport {IERC20Metadata} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {MorphoBalancesLib} from \"../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\";\n\nimport {Multicall} from \"../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {Ownable2Step, Ownable} from \"../lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport {ERC20Permit} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {\n    IERC20,\n    IERC4626,\n    ERC20,\n    ERC4626,\n    Math,\n    SafeERC20\n} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/// @title MetaMorpho\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice ERC4626 compliant vault allowing users to deposit assets to Morpho.\ncontract MetaMorphoV1_1 is ERC4626, ERC20Permit, Ownable2Step, Multicall, IMetaMorphoV1_1StaticTyping {\n    using Math for uint256;\n    using UtilsLib for uint256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using MorphoLib for IMorpho;\n    using SharesMathLib for uint256;\n    using MorphoBalancesLib for IMorpho;\n    using MarketParamsLib for MarketParams;\n    using PendingLib for MarketConfig;\n    using PendingLib for PendingUint192;\n    using PendingLib for PendingAddress;\n\n    /* IMMUTABLES */\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    IMorpho public immutable MORPHO;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    uint8 public immutable DECIMALS_OFFSET;\n\n    /* STORAGE */\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    address public curator;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    mapping(address => bool) public isAllocator;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    address public guardian;\n\n    /// @inheritdoc IMetaMorphoV1_1StaticTyping\n    mapping(Id => MarketConfig) public config;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    uint256 public timelock;\n\n    /// @inheritdoc IMetaMorphoV1_1StaticTyping\n    PendingAddress public pendingGuardian;\n\n    /// @inheritdoc IMetaMorphoV1_1StaticTyping\n    mapping(Id => PendingUint192) public pendingCap;\n\n    /// @inheritdoc IMetaMorphoV1_1StaticTyping\n    PendingUint192 public pendingTimelock;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    uint96 public fee;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    address public feeRecipient;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    address public skimRecipient;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    Id[] public supplyQueue;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    Id[] public withdrawQueue;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    uint256 public lastTotalAssets;\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    uint256 public lostAssets;\n\n    /// @dev \"Overrides\" the ERC20's storage variable to be able to modify it.\n    string private _name;\n\n    /// @dev \"Overrides\" the ERC20's storage variable to be able to modify it.\n    string private _symbol;\n\n    /* CONSTRUCTOR */\n\n    /// @dev Initializes the contract.\n    /// @param owner The owner of the contract.\n    /// @param morpho The address of the Morpho contract.\n    /// @param initialTimelock The initial timelock.\n    /// @param _asset The address of the underlying asset.\n    /// @param __name The name of the vault.\n    /// @param __symbol The symbol of the vault.\n    /// @dev We pass \"\" as name and symbol to the ERC20 because these are overriden in this contract.\n    /// This means that the contract deviates slightly from the ERC2612 standard.\n    constructor(\n        address owner,\n        address morpho,\n        uint256 initialTimelock,\n        address _asset,\n        string memory __name,\n        string memory __symbol\n    ) ERC4626(IERC20(_asset)) ERC20Permit(\"\") ERC20(\"\", \"\") Ownable(owner) {\n        if (morpho == address(0)) revert ErrorsLib.ZeroAddress();\n        if (initialTimelock != 0) _checkTimelockBounds(initialTimelock);\n        _setTimelock(initialTimelock);\n\n        _name = __name;\n        emit EventsLib.SetName(__name);\n\n        _symbol = __symbol;\n        emit EventsLib.SetSymbol(__symbol);\n\n        MORPHO = IMorpho(morpho);\n        DECIMALS_OFFSET = uint8(uint256(18).zeroFloorSub(IERC20Metadata(_asset).decimals()));\n\n        IERC20(_asset).forceApprove(morpho, type(uint256).max);\n    }\n\n    /* MODIFIERS */\n\n    /// @dev Reverts if the caller doesn't have the curator role.\n    modifier onlyCuratorRole() {\n        address sender = _msgSender();\n        if (sender != curator && sender != owner()) revert ErrorsLib.NotCuratorRole();\n\n        _;\n    }\n\n    /// @dev Reverts if the caller doesn't have the allocator role.\n    modifier onlyAllocatorRole() {\n        address sender = _msgSender();\n        if (!isAllocator[sender] && sender != curator && sender != owner()) {\n            revert ErrorsLib.NotAllocatorRole();\n        }\n\n        _;\n    }\n\n    /// @dev Reverts if the caller doesn't have the guardian role.\n    modifier onlyGuardianRole() {\n        if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();\n\n        _;\n    }\n\n    /// @dev Reverts if the caller doesn't have the curator nor the guardian role.\n    modifier onlyCuratorOrGuardianRole() {\n        if (_msgSender() != guardian && _msgSender() != curator && _msgSender() != owner()) {\n            revert ErrorsLib.NotCuratorNorGuardianRole();\n        }\n\n        _;\n    }\n\n    /// @dev Makes sure conditions are met to accept a pending value.\n    /// @dev Reverts if:\n    /// - there's no pending value;\n    /// - the timelock has not elapsed since the pending value has been submitted.\n    modifier afterTimelock(uint256 validAt) {\n        if (validAt == 0) revert ErrorsLib.NoPendingValue();\n        if (block.timestamp < validAt) revert ErrorsLib.TimelockNotElapsed();\n\n        _;\n    }\n\n    /* ONLY OWNER FUNCTIONS */\n\n    function setName(string memory newName) external onlyOwner {\n        _name = newName;\n\n        emit EventsLib.SetName(newName);\n    }\n\n    function setSymbol(string memory newSymbol) external onlyOwner {\n        _symbol = newSymbol;\n\n        emit EventsLib.SetSymbol(newSymbol);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function setCurator(address newCurator) external onlyOwner {\n        if (newCurator == curator) revert ErrorsLib.AlreadySet();\n\n        curator = newCurator;\n\n        emit EventsLib.SetCurator(newCurator);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function setIsAllocator(address newAllocator, bool newIsAllocator) external onlyOwner {\n        if (isAllocator[newAllocator] == newIsAllocator) revert ErrorsLib.AlreadySet();\n\n        isAllocator[newAllocator] = newIsAllocator;\n\n        emit EventsLib.SetIsAllocator(newAllocator, newIsAllocator);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function setSkimRecipient(address newSkimRecipient) external onlyOwner {\n        if (newSkimRecipient == skimRecipient) revert ErrorsLib.AlreadySet();\n\n        skimRecipient = newSkimRecipient;\n\n        emit EventsLib.SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function submitTimelock(uint256 newTimelock) external onlyOwner {\n        if (newTimelock == timelock) revert ErrorsLib.AlreadySet();\n        if (pendingTimelock.validAt != 0) revert ErrorsLib.AlreadyPending();\n        _checkTimelockBounds(newTimelock);\n\n        if (newTimelock > timelock) {\n            _setTimelock(newTimelock);\n        } else {\n            // Safe \"unchecked\" cast because newTimelock <= MAX_TIMELOCK.\n            pendingTimelock.update(uint184(newTimelock), timelock);\n\n            emit EventsLib.SubmitTimelock(newTimelock);\n        }\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function setFee(uint256 newFee) external onlyOwner {\n        if (newFee == fee) revert ErrorsLib.AlreadySet();\n        if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();\n        if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();\n\n        // Accrue interest and fee using the previous fee set before changing it.\n        _accrueInterest();\n\n        // Safe \"unchecked\" cast because newFee <= MAX_FEE.\n        fee = uint96(newFee);\n\n        emit EventsLib.SetFee(_msgSender(), fee);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        if (newFeeRecipient == feeRecipient) revert ErrorsLib.AlreadySet();\n        if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();\n\n        // Accrue interest and fee to the previous fee recipient set before changing it.\n        _accrueInterest();\n\n        feeRecipient = newFeeRecipient;\n\n        emit EventsLib.SetFeeRecipient(newFeeRecipient);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function submitGuardian(address newGuardian) external onlyOwner {\n        if (newGuardian == guardian) revert ErrorsLib.AlreadySet();\n        if (pendingGuardian.validAt != 0) revert ErrorsLib.AlreadyPending();\n\n        if (guardian == address(0)) {\n            _setGuardian(newGuardian);\n        } else {\n            pendingGuardian.update(newGuardian, timelock);\n\n            emit EventsLib.SubmitGuardian(newGuardian);\n        }\n    }\n\n    /* ONLY CURATOR FUNCTIONS */\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {\n        Id id = marketParams.id();\n        if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);\n        if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();\n        if (pendingCap[id].validAt != 0) revert ErrorsLib.AlreadyPending();\n        if (config[id].removableAt != 0) revert ErrorsLib.PendingRemoval();\n        uint256 supplyCap = config[id].cap;\n        if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();\n\n        if (newSupplyCap < supplyCap) {\n            _setCap(marketParams, id, newSupplyCap.toUint184());\n        } else {\n            pendingCap[id].update(newSupplyCap.toUint184(), timelock);\n\n            emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);\n        }\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function submitMarketRemoval(MarketParams memory marketParams) external onlyCuratorRole {\n        Id id = marketParams.id();\n        if (config[id].removableAt != 0) revert ErrorsLib.AlreadyPending();\n        if (config[id].cap != 0) revert ErrorsLib.NonZeroCap();\n        if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled(id);\n        if (pendingCap[id].validAt != 0) revert ErrorsLib.PendingCap(id);\n\n        // Safe \"unchecked\" cast because timelock <= MAX_TIMELOCK.\n        config[id].removableAt = uint64(block.timestamp + timelock);\n\n        emit EventsLib.SubmitMarketRemoval(_msgSender(), id);\n    }\n\n    /* ONLY ALLOCATOR FUNCTIONS */\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function setSupplyQueue(Id[] calldata newSupplyQueue) external onlyAllocatorRole {\n        uint256 length = newSupplyQueue.length;\n\n        if (length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();\n\n        for (uint256 i; i < length; ++i) {\n            if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);\n        }\n\n        supplyQueue = newSupplyQueue;\n\n        emit EventsLib.SetSupplyQueue(_msgSender(), newSupplyQueue);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {\n        uint256 newLength = indexes.length;\n        uint256 currLength = withdrawQueue.length;\n\n        bool[] memory seen = new bool[](currLength);\n        Id[] memory newWithdrawQueue = new Id[](newLength);\n\n        for (uint256 i; i < newLength; ++i) {\n            uint256 prevIndex = indexes[i];\n\n            // If prevIndex >= currLength, it will revert with native \"Index out of bounds\".\n            Id id = withdrawQueue[prevIndex];\n            if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);\n            seen[prevIndex] = true;\n\n            newWithdrawQueue[i] = id;\n        }\n\n        for (uint256 i; i < currLength; ++i) {\n            if (!seen[i]) {\n                Id id = withdrawQueue[i];\n\n                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);\n                if (pendingCap[id].validAt != 0) revert ErrorsLib.PendingCap(id);\n\n                if (MORPHO.supplyShares(id, address(this)) != 0) {\n                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);\n\n                    if (block.timestamp < config[id].removableAt) {\n                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);\n                    }\n                }\n\n                delete config[id];\n            }\n        }\n\n        withdrawQueue = newWithdrawQueue;\n\n        emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {\n        uint256 totalSupplied;\n        uint256 totalWithdrawn;\n        for (uint256 i; i < allocations.length; ++i) {\n            MarketAllocation memory allocation = allocations[i];\n            Id id = allocation.marketParams.id();\n            if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled(id);\n\n            (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);\n            uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);\n\n            if (withdrawn > 0) {\n                // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.\n                uint256 shares;\n                if (allocation.assets == 0) {\n                    shares = supplyShares;\n                    withdrawn = 0;\n                }\n\n                (uint256 withdrawnAssets, uint256 withdrawnShares) =\n                    MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));\n\n                emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);\n\n                totalWithdrawn += withdrawnAssets;\n            } else {\n                uint256 suppliedAssets = allocation.assets == type(uint256).max\n                    ? totalWithdrawn.zeroFloorSub(totalSupplied)\n                    : allocation.assets.zeroFloorSub(supplyAssets);\n\n                if (suppliedAssets == 0) continue;\n\n                uint256 supplyCap = config[id].cap;\n                if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);\n\n                // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.\n                (, uint256 suppliedShares) =\n                    MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex\"\");\n\n                emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);\n\n                totalSupplied += suppliedAssets;\n            }\n        }\n\n        if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();\n    }\n\n    /* REVOKE FUNCTIONS */\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function revokePendingTimelock() external onlyGuardianRole {\n        delete pendingTimelock;\n\n        emit EventsLib.RevokePendingTimelock(_msgSender());\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function revokePendingGuardian() external onlyGuardianRole {\n        delete pendingGuardian;\n\n        emit EventsLib.RevokePendingGuardian(_msgSender());\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function revokePendingCap(Id id) external onlyCuratorOrGuardianRole {\n        delete pendingCap[id];\n\n        emit EventsLib.RevokePendingCap(_msgSender(), id);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function revokePendingMarketRemoval(Id id) external onlyCuratorOrGuardianRole {\n        delete config[id].removableAt;\n\n        emit EventsLib.RevokePendingMarketRemoval(_msgSender(), id);\n    }\n\n    /* EXTERNAL */\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function supplyQueueLength() external view returns (uint256) {\n        return supplyQueue.length;\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function withdrawQueueLength() external view returns (uint256) {\n        return withdrawQueue.length;\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function acceptTimelock() external afterTimelock(pendingTimelock.validAt) {\n        _setTimelock(pendingTimelock.value);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function acceptGuardian() external afterTimelock(pendingGuardian.validAt) {\n        _setGuardian(pendingGuardian.value);\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function acceptCap(MarketParams memory marketParams)\n        external\n        afterTimelock(pendingCap[marketParams.id()].validAt)\n    {\n        Id id = marketParams.id();\n\n        // Safe \"unchecked\" cast because pendingCap <= type(uint184).max.\n        _setCap(marketParams, id, uint184(pendingCap[id].value));\n    }\n\n    /// @inheritdoc IMetaMorphoV1_1Base\n    function skim(address token) external {\n        if (skimRecipient == address(0)) revert ErrorsLib.ZeroAddress();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).safeTransfer(skimRecipient, amount);\n\n        emit EventsLib.Skim(_msgSender(), token, amount);\n    }\n\n    /* ERC4626 (PUBLIC) */\n\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view override(ERC20, ERC4626) returns (uint8) {\n        return ERC4626.decimals();\n    }\n\n    function name() public view override(IERC20Metadata, ERC20) returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override(IERC20Metadata, ERC20) returns (string memory) {\n        return _symbol;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Warning: May be higher than the actual max deposit due to duplicate markets in the supplyQueue.\n    function maxDeposit(address) public view override returns (uint256) {\n        return _maxDeposit();\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Warning: May be higher than the actual max mint due to duplicate markets in the supplyQueue.\n    function maxMint(address) public view override returns (uint256) {\n        uint256 suppliable = _maxDeposit();\n\n        return _convertToShares(suppliable, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Warning: May be lower than the actual amount of assets that can be withdrawn by `owner` due to conversion\n    /// roundings between shares and assets.\n    function maxWithdraw(address owner) public view override returns (uint256 assets) {\n        (assets,,) = _maxWithdraw(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Warning: May be lower than the actual amount of shares that can be redeemed by `owner` due to conversion\n    /// roundings between shares and assets.\n    function maxRedeem(address owner) public view override returns (uint256) {\n        (uint256 assets, uint256 newTotalSupply, uint256 newTotalAssets) = _maxWithdraw(owner);\n\n        return _convertToSharesWithTotals(assets, newTotalSupply, newTotalAssets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice For tokens with 18 decimals, the protection against the inflation front-running attack is low. To\n    /// protect against this attack, vault deployers should make an initial deposit of a non-trivial amount in the vault\n    /// or depositors should check that the share price does not exceed a certain limit.\n    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\n        _accrueInterest();\n\n        shares = _convertToSharesWithTotals(assets, totalSupply(), lastTotalAssets, Math.Rounding.Floor);\n\n        _deposit(_msgSender(), receiver, assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public override returns (uint256 assets) {\n        _accrueInterest();\n\n        assets = _convertToAssetsWithTotals(shares, totalSupply(), lastTotalAssets, Math.Rounding.Ceil);\n\n        _deposit(_msgSender(), receiver, assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n        _accrueInterest();\n\n        // Do not call expensive `maxWithdraw` and optimistically withdraw assets.\n\n        shares = _convertToSharesWithTotals(assets, totalSupply(), lastTotalAssets, Math.Rounding.Ceil);\n\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {\n        _accrueInterest();\n\n        // Do not call expensive `maxRedeem` and optimistically redeem shares.\n\n        assets = _convertToAssetsWithTotals(shares, totalSupply(), lastTotalAssets, Math.Rounding.Floor);\n\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev totalAssets is the sum of the vault's assets on the Morpho markets plus the lost assets (see corresponding\n    /// docs in IMetaMorphoV1_1.sol).\n    function totalAssets() public view override returns (uint256) {\n        (, uint256 newTotalAssets,) = _accruedFeeAndAssets();\n\n        return newTotalAssets;\n    }\n\n    /* ERC4626 (INTERNAL) */\n\n    /// @inheritdoc ERC4626\n    function _decimalsOffset() internal view override returns (uint8) {\n        return DECIMALS_OFFSET;\n    }\n\n    /// @dev Returns the maximum amount of asset (`assets`) that the `owner` can withdraw from the vault, as well as the\n    /// new vault's total supply (`newTotalSupply`) and total assets (`newTotalAssets`).\n    function _maxWithdraw(address owner)\n        internal\n        view\n        returns (uint256 assets, uint256 newTotalSupply, uint256 newTotalAssets)\n    {\n        uint256 feeShares;\n        (feeShares, newTotalAssets,) = _accruedFeeAndAssets();\n        newTotalSupply = totalSupply() + feeShares;\n\n        assets = _convertToAssetsWithTotals(balanceOf(owner), newTotalSupply, newTotalAssets, Math.Rounding.Floor);\n        assets -= _simulateWithdrawMorpho(assets);\n    }\n\n    /// @dev Returns the maximum amount of assets that the vault can supply on Morpho.\n    function _maxDeposit() internal view returns (uint256 totalSuppliable) {\n        for (uint256 i; i < supplyQueue.length; ++i) {\n            Id id = supplyQueue[i];\n\n            uint256 supplyCap = config[id].cap;\n            if (supplyCap == 0) continue;\n\n            uint256 supplyShares = MORPHO.supplyShares(id, address(this));\n            (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = MORPHO.expectedMarketBalances(_marketParams(id));\n            // `supplyAssets` needs to be rounded up for `totalSuppliable` to be rounded down.\n            uint256 supplyAssets = supplyShares.toAssetsUp(totalSupplyAssets, totalSupplyShares);\n\n            totalSuppliable += supplyCap.zeroFloorSub(supplyAssets);\n        }\n    }\n\n    /// @inheritdoc ERC4626\n    /// @dev The accrual of performance fees is taken into account in the conversion.\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view override returns (uint256) {\n        (uint256 feeShares, uint256 newTotalAssets,) = _accruedFeeAndAssets();\n\n        return _convertToSharesWithTotals(assets, totalSupply() + feeShares, newTotalAssets, rounding);\n    }\n\n    /// @inheritdoc ERC4626\n    /// @dev The accrual of performance fees is taken into account in the conversion.\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view override returns (uint256) {\n        (uint256 feeShares, uint256 newTotalAssets,) = _accruedFeeAndAssets();\n\n        return _convertToAssetsWithTotals(shares, totalSupply() + feeShares, newTotalAssets, rounding);\n    }\n\n    /// @dev Returns the amount of shares that the vault would exchange for the amount of `assets` provided.\n    /// @dev It assumes that the arguments `newTotalSupply` and `newTotalAssets` are up to date.\n    function _convertToSharesWithTotals(\n        uint256 assets,\n        uint256 newTotalSupply,\n        uint256 newTotalAssets,\n        Math.Rounding rounding\n    ) internal view returns (uint256) {\n        return assets.mulDiv(newTotalSupply + 10 ** _decimalsOffset(), newTotalAssets + 1, rounding);\n    }\n\n    /// @dev Returns the amount of assets that the vault would exchange for the amount of `shares` provided.\n    /// @dev It assumes that the arguments `newTotalSupply` and `newTotalAssets` are up to date.\n    function _convertToAssetsWithTotals(\n        uint256 shares,\n        uint256 newTotalSupply,\n        uint256 newTotalAssets,\n        Math.Rounding rounding\n    ) internal view returns (uint256) {\n        return shares.mulDiv(newTotalAssets + 1, newTotalSupply + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /// @inheritdoc ERC4626\n    /// @dev Used in mint or deposit to deposit the underlying asset to Morpho markets.\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {\n        super._deposit(caller, receiver, assets, shares);\n\n        _supplyMorpho(assets);\n\n        // `lastTotalAssets + assets` may be a little above `totalAssets()`.\n        // This can lead to a small accrual of `lostAssets` at the next interaction.\n        _updateLastTotalAssets(lastTotalAssets + assets);\n    }\n\n    /// @inheritdoc ERC4626\n    /// @dev Used in redeem or withdraw to withdraw the underlying asset from Morpho markets.\n    /// @dev Depending on 3 cases, reverts when withdrawing \"too much\" with:\n    /// 1. NotEnoughLiquidity when withdrawing more than available liquidity.\n    /// 2. ERC20InsufficientAllowance when withdrawing more than `caller`'s allowance.\n    /// 3. ERC20InsufficientBalance when withdrawing more than `owner`'s balance.\n    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)\n        internal\n        override\n    {\n        // `lastTotalAssets - assets` may be a little above `totalAssets()`.\n        // This can lead to a small accrual of `lostAssets` at the next interaction.\n        // clamp at 0 so the error raised is the more informative NotEnoughLiquidity.\n        _updateLastTotalAssets(lastTotalAssets.zeroFloorSub(assets));\n\n        _withdrawMorpho(assets);\n\n        super._withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /* INTERNAL */\n\n    /// @dev Returns the market params of the market defined by `id`.\n    function _marketParams(Id id) internal view returns (MarketParams memory) {\n        return MORPHO.idToMarketParams(id);\n    }\n\n    /// @dev Accrues interest on Morpho Blue and returns the vault's assets & corresponding shares supplied on the\n    /// market defined by `marketParams`, as well as the market's state.\n    /// @dev Assumes that the inputs `marketParams` and `id` match.\n    function _accruedSupplyBalance(MarketParams memory marketParams, Id id)\n        internal\n        returns (uint256 assets, uint256 shares, Market memory market)\n    {\n        MORPHO.accrueInterest(marketParams);\n\n        market = MORPHO.market(id);\n        shares = MORPHO.supplyShares(id, address(this));\n        assets = shares.toAssetsDown(market.totalSupplyAssets, market.totalSupplyShares);\n    }\n\n    /// @dev Reverts if `newTimelock` is not within the bounds.\n    function _checkTimelockBounds(uint256 newTimelock) internal pure {\n        if (newTimelock > ConstantsLib.MAX_TIMELOCK) revert ErrorsLib.AboveMaxTimelock();\n        if (newTimelock < ConstantsLib.POST_INITIALIZATION_MIN_TIMELOCK) revert ErrorsLib.BelowMinTimelock();\n    }\n\n    /// @dev Sets `timelock` to `newTimelock`.\n    function _setTimelock(uint256 newTimelock) internal {\n        timelock = newTimelock;\n\n        emit EventsLib.SetTimelock(_msgSender(), newTimelock);\n\n        delete pendingTimelock;\n    }\n\n    /// @dev Sets `guardian` to `newGuardian`.\n    function _setGuardian(address newGuardian) internal {\n        guardian = newGuardian;\n\n        emit EventsLib.SetGuardian(_msgSender(), newGuardian);\n\n        delete pendingGuardian;\n    }\n\n    /// @dev Sets the cap of the market defined by `id` to `supplyCap`.\n    /// @dev Assumes that the inputs `marketParams` and `id` match.\n    function _setCap(MarketParams memory marketParams, Id id, uint184 supplyCap) internal {\n        MarketConfig storage marketConfig = config[id];\n\n        if (supplyCap > 0) {\n            if (!marketConfig.enabled) {\n                withdrawQueue.push(id);\n\n                if (withdrawQueue.length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();\n\n                marketConfig.enabled = true;\n\n                // Take into account assets of the new market without applying a fee.\n                _updateLastTotalAssets(lastTotalAssets + MORPHO.expectedSupplyAssets(marketParams, address(this)));\n\n                emit EventsLib.SetWithdrawQueue(msg.sender, withdrawQueue);\n            }\n\n            marketConfig.removableAt = 0;\n        }\n\n        marketConfig.cap = supplyCap;\n\n        emit EventsLib.SetCap(_msgSender(), id, supplyCap);\n\n        delete pendingCap[id];\n    }\n\n    /* LIQUIDITY ALLOCATION */\n\n    /// @dev Supplies `assets` to Morpho.\n    function _supplyMorpho(uint256 assets) internal {\n        for (uint256 i; i < supplyQueue.length; ++i) {\n            Id id = supplyQueue[i];\n\n            uint256 supplyCap = config[id].cap;\n            if (supplyCap == 0) continue;\n\n            MarketParams memory marketParams = _marketParams(id);\n\n            MORPHO.accrueInterest(marketParams);\n\n            Market memory market = MORPHO.market(id);\n            uint256 supplyShares = MORPHO.supplyShares(id, address(this));\n            // `supplyAssets` needs to be rounded up for `toSupply` to be rounded down.\n            uint256 supplyAssets = supplyShares.toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);\n\n            uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);\n\n            if (toSupply > 0) {\n                // Using try/catch to skip markets that revert.\n                try MORPHO.supply(marketParams, toSupply, 0, address(this), hex\"\") {\n                    assets -= toSupply;\n                } catch {}\n            }\n\n            if (assets == 0) return;\n        }\n\n        if (assets != 0) revert ErrorsLib.AllCapsReached();\n    }\n\n    /// @dev Withdraws `assets` from Morpho.\n    function _withdrawMorpho(uint256 assets) internal {\n        for (uint256 i; i < withdrawQueue.length; ++i) {\n            Id id = withdrawQueue[i];\n            MarketParams memory marketParams = _marketParams(id);\n            (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);\n\n            uint256 toWithdraw = UtilsLib.min(\n                _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets\n            );\n\n            if (toWithdraw > 0) {\n                // Using try/catch to skip markets that revert.\n                try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {\n                    assets -= toWithdraw;\n                } catch {}\n            }\n\n            if (assets == 0) return;\n        }\n\n        if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();\n    }\n\n    /// @dev Simulates a withdraw of `assets` from Morpho.\n    /// @return The remaining assets to be withdrawn.\n    function _simulateWithdrawMorpho(uint256 assets) internal view returns (uint256) {\n        for (uint256 i; i < withdrawQueue.length; ++i) {\n            Id id = withdrawQueue[i];\n            MarketParams memory marketParams = _marketParams(id);\n\n            uint256 supplyShares = MORPHO.supplyShares(id, address(this));\n            (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets,) =\n                MORPHO.expectedMarketBalances(marketParams);\n\n            // The vault withdrawing from Morpho cannot fail because:\n            // 1. oracle.price() is never called (the vault doesn't borrow)\n            // 2. the amount is capped to the liquidity available on Morpho\n            // 3. virtually accruing interest didn't fail\n            assets = assets.zeroFloorSub(\n                _withdrawable(\n                    marketParams,\n                    totalSupplyAssets,\n                    totalBorrowAssets,\n                    supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares)\n                )\n            );\n\n            if (assets == 0) break;\n        }\n\n        return assets;\n    }\n\n    /// @dev Returns the withdrawable amount of assets from the market defined by `marketParams`, given the market's\n    /// total supply and borrow assets and the vault's assets supplied.\n    function _withdrawable(\n        MarketParams memory marketParams,\n        uint256 totalSupplyAssets,\n        uint256 totalBorrowAssets,\n        uint256 supplyAssets\n    ) internal view returns (uint256) {\n        // Inside a flashloan callback, liquidity on Morpho Blue may be limited to the singleton's balance.\n        uint256 availableLiquidity = UtilsLib.min(\n            totalSupplyAssets - totalBorrowAssets, ERC20(marketParams.loanToken).balanceOf(address(MORPHO))\n        );\n\n        return UtilsLib.min(supplyAssets, availableLiquidity);\n    }\n\n    /* FEE MANAGEMENT */\n\n    /// @dev Updates `lastTotalAssets` to `updatedTotalAssets`.\n    function _updateLastTotalAssets(uint256 updatedTotalAssets) internal {\n        lastTotalAssets = updatedTotalAssets;\n\n        emit EventsLib.UpdateLastTotalAssets(updatedTotalAssets);\n    }\n\n    /// @dev Accrues `lastTotalAssets`, `lostAssets` and mints the fee shares to the fee recipient.\n    function _accrueInterest() internal {\n        (uint256 feeShares, uint256 newTotalAssets, uint256 newLostAssets) = _accruedFeeAndAssets();\n\n        _updateLastTotalAssets(newTotalAssets);\n        lostAssets = newLostAssets;\n        emit EventsLib.UpdateLostAssets(newLostAssets);\n\n        if (feeShares != 0) _mint(feeRecipient, feeShares);\n\n        emit EventsLib.AccrueInterest(newTotalAssets, feeShares);\n    }\n\n    /// @dev Computes and returns the `feeShares` to mint, the new `totalAssets` and the new `lostAssets`.\n    /// @return feeShares the shares to mint to `feeRecipient`.\n    /// @return newTotalAssets the new `totalAssets`.\n    /// @return newLostAssets the new lostAssets.\n    function _accruedFeeAndAssets()\n        internal\n        view\n        returns (uint256 feeShares, uint256 newTotalAssets, uint256 newLostAssets)\n    {\n        // The assets that the vault has on Morpho.\n        uint256 realTotalAssets;\n        for (uint256 i; i < withdrawQueue.length; ++i) {\n            realTotalAssets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));\n        }\n\n        // If the vault lost some assets (realTotalAssets decreased), lostAssets is increased.\n        if (realTotalAssets < lastTotalAssets - lostAssets) newLostAssets = lastTotalAssets - realTotalAssets;\n        // If it did not, lostAssets stays the same.\n        else newLostAssets = lostAssets;\n\n        newTotalAssets = realTotalAssets + newLostAssets;\n        uint256 totalInterest = newTotalAssets - lastTotalAssets;\n        if (totalInterest != 0 && fee != 0) {\n            // It is acknowledged that `feeAssets` may be rounded down to 0 if `totalInterest * fee < WAD`.\n            uint256 feeAssets = totalInterest.mulDiv(fee, WAD);\n            // The fee assets is subtracted from the total assets in this calculation to compensate for the fact\n            // that total assets is already increased by the total interest (including the fee assets).\n            feeShares =\n                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);\n        }\n    }\n}\n"
    }
}