{
    "vfp_id": "vfp_00634",
    "project_name": "cantina_tadle_oct2025.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Ambient buy flow withholds quote token approvals",
            "description": "When buying base tokens, the Ambient connector fails to approve the quote token, causing ERC-20 quote purchases to revert due to insufficient allowance. Only native ETH buys work. The root cause is incorrect approval logic that only approves the base token regardless of trade direction. The impact is broken functionality for ERC-20 quote token trades, limiting usability and causing transaction failures.\n",
            "severity": "Informational",
            "location": [
                "main.sol#367-370"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/ambient-finance/main.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Fixed price limit disables Ambient trade protections",
            "description": "The Ambient connector hardcodes price limits to near-protocol extremes, rendering them ineffective. This disables intended trade protections, leaving swaps vulnerable to slippage if amountOutMin is misconfigured. The root cause is static, non-adaptive price limits. Operators relying on these limits may believe they are protected when they are not. The impact is potential financial loss due to unfavorable trade execution, though amountOutMin still provides some protection.\n",
            "severity": "Informational",
            "location": [
                "main.sol::_encodeTradeCommand#425-463"
            ],
            "files": [
                "v3-sandbox-audit_1/src/relayers/monad_testnet/ambient-finance/main.sol"
            ]
        }
    ],
    "affected_files": {
        "main.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Stores} from \"../implementation/Stores.sol\";\nimport {TokenHelper, TokenInterface} from \"../../../libraries/TokenHelper.sol\";\n\n/**\n * @title IAmbientFinance\n * @notice Interface for interacting with Ambient Finance protocol\n * @dev Provides access to the main user command function\n */\ninterface IAmbientFinance {\n    /// @notice Execute a user command on the Ambient Finance protocol\n    /// @param callpath Protocol operation identifier\n    /// @param cmd Encoded command data\n    /// @return Response data from the protocol\n    function userCmd(\n        uint16 callpath,\n        bytes calldata cmd\n    ) external payable returns (bytes memory);\n}\n\n/**\n * @title AmbientFinanceResolver\n * @author Tadle Team\n * @notice Contract for interacting with Ambient Finance protocol\n * @dev Handles liquidity operations, pool management, and trading\n * @custom:security Implements token approval management and validation\n */\ncontract AmbientFinanceResolver is Stores {\n    /// @dev Ambient Finance protocol contract address\n    /// @notice Immutable reference to the main protocol contract\n    address public immutable ambientFinance;\n\n    /// @dev Native token address (ETH)\n    /// @notice Standard representation for native ETH in the protocol\n    address public constant NATIVE_TOKEN = address(0);\n\n    /// @dev Command identifiers for Ambient Finance operations\n    /// @notice Protocol-specific operation codes\n    uint256 public constant REMOVE_LIQUIDITY = 2;\n    uint256 public constant HARVEST = 5;\n    uint256 public constant SWAP = 3;\n    uint256 public constant CREATE_POOL = 71;\n\n    /**\n     * @dev Initializes the contract with Ambient Finance address\n     * @param _ambientFinance Address of Ambient Finance protocol\n     * @param _tadleMemory Address of storage contract\n     * @notice Sets up the resolver with required protocol contracts\n     * @custom:validation Inherits storage validation from Stores contract\n     */\n    constructor(\n        address _ambientFinance,\n        address _tadleMemory\n    ) Stores(_tadleMemory) {\n        ambientFinance = _ambientFinance;\n    }\n\n    /**\n     * @dev Creates a new liquidity pool\n     * @param callPath Protocol operation identifier\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Index of the pool\n     * @param price Initial pool price\n     * @param value ETH value to send with the transaction\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     * @notice Creates a new trading pool with specified parameters\n     * @custom:validation Automatically approves tokens for future operations\n     */\n    function createPool(\n        uint16 callPath,\n        address base,\n        address quote,\n        uint256 poolIndex,\n        uint128 price,\n        uint256 value\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        // Pre-approve tokens for future operations\n        approve(base);\n        approve(quote);\n\n        // Encode pool creation parameters\n        bytes memory cmd = abi.encode(\n            CREATE_POOL,\n            base,\n            quote,\n            poolIndex,\n            price\n        );\n\n        // Execute pool creation command and get response\n        _executeCommand(callPath, cmd, value);\n\n        // Return standardized event data\n        _eventName = \"LogCreatePool(address,address,uint256,uint128)\";\n        _eventParam = abi.encode(base, quote, poolIndex, price);\n    }\n\n    /**\n     * @dev Adds liquidity to a pool\n     * @param callPath Protocol operation identifier\n     * @param operation Specific liquidity operation type\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Index of the pool\n     * @param bidTick Lower price tick\n     * @param askTick Upper price tick\n     * @param liq Amount of liquidity to add\n     * @param limitLower Lower limit for position\n     * @param limitHigher Upper limit for position\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     * @notice Adds liquidity to an existing pool within specified price range\n     * @custom:validation Automatically approves tokens before operation\n     */\n    function addLiquidity(\n        uint16 callPath,\n        uint256 operation,\n        address base,\n        address quote,\n        uint256 poolIndex,\n        int24 bidTick,\n        int24 askTick,\n        uint128 liq,\n        uint128 limitLower,\n        uint128 limitHigher\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        // Approve tokens before adding liquidity\n        approve(base);\n        approve(quote);\n\n        // Encode command parameters\n        bytes memory cmd = _encodeLiquidityCommand(\n            operation,\n            base,\n            quote,\n            poolIndex,\n            bidTick,\n            askTick,\n            liq,\n            limitLower,\n            limitHigher\n        );\n\n        // Execute command with or without ETH value\n        _executeCommand(callPath, cmd, base == NATIVE_TOKEN ? liq : 0);\n\n        // Return event data\n        _eventName = \"LogAddLiquidity(address,address,address,uint256,int24,int24,uint128)\";\n        _eventParam = abi.encode(\n            address(this),\n            base,\n            quote,\n            poolIndex,\n            bidTick,\n            askTick,\n            liq\n        );\n    }\n\n    /**\n     * @dev Internal helper to encode liquidity command parameters\n     * @param operation Type of liquidity operation\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Pool identifier\n     * @param bidTick Lower price tick\n     * @param askTick Upper price tick\n     * @param liq Liquidity amount\n     * @param limitLower Lower position limit\n     * @param limitHigher Upper position limit\n     * @return Encoded command data for protocol\n     * @notice Standardizes parameter encoding for liquidity operations\n     */\n    function _encodeLiquidityCommand(\n        uint256 operation,\n        address base,\n        address quote,\n        uint256 poolIndex,\n        int24 bidTick,\n        int24 askTick,\n        uint128 liq,\n        uint128 limitLower,\n        uint128 limitHigher\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encode(\n                operation,\n                base,\n                quote,\n                poolIndex,\n                bidTick,\n                askTick,\n                liq,\n                limitLower,\n                limitHigher,\n                uint8(0),\n                address(0)\n            );\n    }\n\n    /**\n     * @dev Internal helper to execute Ambient Finance commands\n     * @param callPath Protocol operation identifier\n     * @param cmd Encoded command data\n     * @param value ETH value to send with the command\n     * @return res Response data from the protocol\n     * @notice Handles both payable and non-payable command execution\n     * @custom:gas-optimization Conditionally sends ETH only when needed\n     */\n    function _executeCommand(\n        uint16 callPath,\n        bytes memory cmd,\n        uint256 value\n    ) internal returns (bytes memory res) {\n        if (value > 0) {\n            res = IAmbientFinance(ambientFinance).userCmd{value: value}(\n                callPath,\n                cmd\n            );\n        } else {\n            res = IAmbientFinance(ambientFinance).userCmd(callPath, cmd);\n        }\n    }\n\n    /**\n     * @dev Removes liquidity from a pool\n     * @param callPath Protocol operation identifier\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Index of the pool\n     * @param bidTick Lower price tick\n     * @param askTick Upper price tick\n     * @param liq Amount of liquidity to remove\n     * @param limitLower Lower limit for position\n     * @param limitHigher Upper limit for position\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     * @notice Removes liquidity from an existing position\n     */\n    function removeLiquidity(\n        uint16 callPath,\n        address base,\n        address quote,\n        uint256 poolIndex,\n        int24 bidTick,\n        int24 askTick,\n        uint128 liq,\n        uint128 limitLower,\n        uint128 limitHigher\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        bytes memory cmd = _encodeLiquidityCommand(\n            REMOVE_LIQUIDITY,\n            base,\n            quote,\n            poolIndex,\n            bidTick,\n            askTick,\n            liq,\n            limitLower,\n            limitHigher\n        );\n\n        // Execute and validate response\n        _executeCommand(callPath, cmd, 0);\n\n        // Return event data\n        _eventName = \"LogRemoveLiquidity(address,address,address,uint256,int24,int24,uint128)\";\n        _eventParam = abi.encode(\n            address(this),\n            base,\n            quote,\n            poolIndex,\n            bidTick,\n            askTick,\n            liq\n        );\n    }\n\n    /**\n     * @dev Harvests rewards from a liquidity position\n     * @param callPath Protocol operation identifier\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Index of the pool\n     * @param bidTick Lower price tick\n     * @param askTick Upper price tick\n     * @param liq Position liquidity amount\n     * @param limitLower Lower limit for position\n     * @param limitHigher Upper limit for position\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     * @notice Collects accumulated fees from a liquidity position\n     */\n    function harvest(\n        uint16 callPath,\n        address base,\n        address quote,\n        uint256 poolIndex,\n        int24 bidTick,\n        int24 askTick,\n        uint128 liq,\n        uint128 limitLower,\n        uint128 limitHigher\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        bytes memory cmd = _encodeLiquidityCommand(\n            HARVEST,\n            base,\n            quote,\n            poolIndex,\n            bidTick,\n            askTick,\n            liq,\n            limitLower,\n            limitHigher\n        );\n\n        // Execute and validate response\n        _executeCommand(callPath, cmd, 0);\n\n        // Return event data\n        _eventName = \"LogHarvest(address,address,address,uint256,int24,int24,uint128)\";\n        _eventParam = abi.encode(\n            address(this),\n            base,\n            quote,\n            poolIndex,\n            bidTick,\n            askTick,\n            liq\n        );\n    }\n\n    /**\n     * @dev Executes a trading operation in the specified pool\n     * @param callPath Protocol operation identifier\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Index of the pool\n     * @param amountIn Amount of token to input\n     * @param amountOutMin Minimum amount of output token\n     * @param buyBase True if buying base token, false if selling\n     * @param getIds Storage ID to retrieve input amount\n     * @param setIds Storage ID to store output amount\n     * @return _eventName Event name for logging\n     * @return _eventParam Encoded event parameters\n     * @notice Executes a swap with slippage protection\n     * @custom:validation Validates trade direction and amounts\n     */\n    function buy(\n        uint16 callPath,\n        address base,\n        address quote,\n        uint256 poolIndex,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bool buyBase,\n        uint256 getIds,\n        uint256 setIds\n    ) external returns (string memory _eventName, bytes memory _eventParam) {\n        // Get input amount from storage\n        amountIn = getUint(getIds, amountIn);\n\n        // Approve input token if not native token\n        if (base != NATIVE_TOKEN) {\n            approve(base);\n        }\n\n        // Encode command parameters\n        bytes memory cmd = _encodeTradeCommand(\n            base,\n            quote,\n            poolIndex,\n            amountIn,\n            amountOutMin,\n            buyBase\n        );\n\n        // Execute command with ETH value if using native token\n        bytes memory res = _executeCommand(\n            callPath,\n            cmd,\n            base == NATIVE_TOKEN ? amountIn : 0\n        );\n\n        (int128 baseAmount, int128 quoteAmount) = abi.decode(\n            res,\n            (int128, int128)\n        );\n\n        uint256 amountOut;\n        // Convert negative amounts to positive uint256, handling the direction\n        if (buyBase) {\n            require(\n                quoteAmount < 0,\n                \"AmbientFinanceResolver: invalid quote amount for base purchase\"\n            );\n            amountOut = uint256(uint128(-quoteAmount));\n        } else {\n            require(\n                baseAmount < 0,\n                \"AmbientFinanceResolver: invalid base amount for quote purchase\"\n            );\n            amountOut = uint256(uint128(-baseAmount));\n        }\n\n        setUint(setIds, amountOut);\n\n        // Return event data\n        _eventName = \"LogTrade(address,address,address,uint256,uint256,uint256,bool)\";\n        _eventParam = abi.encode(\n            address(this),\n            base,\n            quote,\n            poolIndex,\n            amountIn,\n            amountOut,\n            buyBase\n        );\n    }\n\n    /**\n     * @dev Internal helper to encode trade command parameters\n     * @param base Base token address\n     * @param quote Quote token address\n     * @param poolIndex Pool identifier\n     * @param amountIn Input amount\n     * @param amountOutMin Minimum output amount\n     * @param buyBase True if buying base token\n     * @return Encoded command data for Ambient Finance protocol\n     * @notice Encodes swap parameters with appropriate price limits\n     * @custom:security Sets conservative price limits to prevent MEV attacks\n     */\n    function _encodeTradeCommand(\n        address base,\n        address quote,\n        uint256 poolIndex,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bool buyBase\n    ) internal pure returns (bytes memory) {\n        // Calculate price limit based on trade direction\n        uint128 priceLimit = buyBase\n            ? uint128(21267430153580247136652501917186561137) // Maximum price for buying base\n            : uint128(65538); // Minimum price for selling base\n\n        return\n            abi.encode(\n                base,\n                quote,\n                poolIndex,\n                buyBase, // Trade direction (buy/sell base token)\n                buyBase, // Use same quantity denomination as trade direction\n                uint128(amountIn),\n                uint16(0), // Default pool type\n                priceLimit, // Price limit for the trade\n                uint128(amountOutMin),\n                0 // Reserved for future use\n            );\n    }\n\n    /**\n     * @dev Approves token spending for Ambient Finance\n     * @param token Address of token to approve\n     * @notice Optimizes gas by only approving when necessary\n     * @custom:gas-optimization Checks existing allowance before approval\n     * @custom:security Uses maximum allowance for efficiency\n     */\n    function approve(address token) internal {\n        if (token == NATIVE_TOKEN) {\n            return;\n        }\n\n        // Check current allowance\n        uint256 currentAllowance = TokenInterface(token).allowance(\n            address(this),\n            ambientFinance\n        );\n\n        // Only approve if necessary\n        if (currentAllowance == 0) {\n            TokenHelper.approve(\n                TokenInterface(token),\n                ambientFinance,\n                type(uint256).max\n            );\n        }\n    }\n}\n\n/**\n * @title ConnectV1AmbientFinance\n * @author Tadle Team\n * @notice Version 1.0.0 of the Ambient Finance connector\n * @dev Extends AmbientFinanceResolver with version identification\n * @custom:version 1.0.0\n */\ncontract ConnectV1AmbientFinance is AmbientFinanceResolver {\n    /// @dev Version identifier for the connector\n    /// @notice Human-readable version string\n    string public constant name = \"AmbientFinance-v1.0.0\";\n\n    /**\n     * @dev Initializes the connector with required dependencies\n     * @param _ambientFinance Address of Ambient Finance protocol\n     * @param _tadleMemory Address of storage contract\n     * @notice Sets up the connector with required protocol contracts\n     * @custom:initialization Inherits validation from AmbientFinanceResolver\n     */\n    constructor(\n        address _ambientFinance,\n        address _tadleMemory\n    ) AmbientFinanceResolver(_ambientFinance, _tadleMemory) {}\n}\n"
    }
}