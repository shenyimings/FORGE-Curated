{
    "vfp_id": "vfp_00110",
    "project_name": "cantina_coinbase_bridge_aug2025.pdf",
    "findings": [
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Integer division truncation in TokenLib",
            "description": "Integer division operations in TokenLib truncate remainders, leading to precision loss. The cause is use of standard integer division without rounding or remainder handling. Could be exploited in fee calculation or token conversion logic to accumulate small losses. The impact is economic inefficiency and potential fund leakage over time.\n",
            "severity": "Informational",
            "location": [
                "TokenLib.sol#L169-L175"
            ],
            "files": [
                "bridge/base/src/libraries/TokenLib.sol"
            ]
        }
    ],
    "affected_files": {
        "TokenLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {CrossChainERC20} from \"../CrossChainERC20.sol\";\nimport {CrossChainERC20Factory} from \"../CrossChainERC20Factory.sol\";\n\nimport {Pubkey} from \"./SVMLib.sol\";\n\n/// @notice Struct representing a token transfer.\n///\n/// @custom:field localToken Address of the ERC20 token on this chain.\n/// @custom:field remoteToken Pubkey of the remote token on Solana.\n/// @custom:field to Address of the recipient on the target chain. EVM address on Base, Solana pubkey on Solana.\n/// @custom:field remoteAmount Amount of tokens being bridged (expressed in Solana units).\nstruct Transfer {\n    address localToken;\n    Pubkey remoteToken;\n    bytes32 to;\n    uint64 remoteAmount;\n}\n\n/// @notice Enum representing the Solana token type.\nenum SolanaTokenType {\n    Sol,\n    Spl,\n    WrappedToken\n}\n\n/// @notice Storage layout used by this library.\n///\n/// @custom:storage-location erc7201:coinbase.storage.TokenLib\n///\n/// @custom:field deposits Mapping that stores deposit balances for token pairs between Base and Solana.\n/// @custom:field scalars Mapping that stores the scalars to use to scale Solana amounts to Base amounts.\n///                               Only used when bridging native ETH or ERC20 tokens to (or back from) Solana.\nstruct TokenLibStorage {\n    mapping(address localToken => mapping(Pubkey remoteToken => uint256 amount)) deposits;\n    mapping(address localToken => mapping(Pubkey remoteToken => uint256 scalar)) scalars;\n}\n\nlibrary TokenLib {\n    //////////////////////////////////////////////////////////////\n    ///                       Errors                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when the ETH value sent with a transaction doesn't match the expected amount.\n    error InvalidMsgValue();\n\n    /// @notice Thrown when the remote token is not the expected token.\n    error IncorrectRemoteToken();\n\n    /// @notice Thrown when the token pair is not registered.\n    error WrappedSplRouteNotRegistered();\n\n    //////////////////////////////////////////////////////////////\n    ///                       Events                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a token transfer is initialized.\n    ///\n    /// @param localToken Address of the local token on Base.\n    /// @param remoteToken Pubkey of the remote token on Solana.\n    /// @param to Pubkey of the recipient on Solana.\n    /// @param amount Amount of tokens bridged to the recipient (expressed in local units).\n    event TransferInitialized(address localToken, Pubkey remoteToken, Pubkey to, uint256 amount);\n\n    /// @notice Emitted when a token transfer is finalized.\n    ///\n    /// @param localToken Address of the local token on Base.\n    /// @param remoteToken Pubkey of the remote token on Solana.\n    /// @param to Address of the recipient on Base.\n    /// @param amount Amount of tokens bridged to the recipient (expressed in local units).\n    event TransferFinalized(address localToken, Pubkey remoteToken, address to, uint256 amount);\n\n    //////////////////////////////////////////////////////////////\n    ///                       Constants                        ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice The ERC-7528 pseudo-address representing native ETH in token operations.\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Sentinel pubkey used to denote native SOL within bridging logic.\n    /// (\"SoL1111111111111111111111111111111111111111\")\n    Pubkey public constant NATIVE_SOL_PUBKEY =\n        Pubkey.wrap(0x069be72ab836d4eacc02525b7350a78a395da2f1253a40ebafd6630000000000);\n\n    /// @dev Slot for the `TokenLibStorage` struct in storage.\n    ///      Computed from:\n    ///         keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.TokenLib\")) - 1)) & ~bytes32(uint256(0xff))\n    ///\n    ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n    bytes32 private constant _TOKEN_LIB_STORAGE_LOCATION =\n        0x86fd1c0757ed9526a07041356cbdd3c36e2a83be313529de06f943db14148300;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Internal Functions               ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Helper function to get a storage reference to the `TokenLibStorage` struct.\n    ///\n    /// @return $ A storage reference to the `TokenLibStorage` struct.\n    function getTokenLibStorage() internal pure returns (TokenLibStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := _TOKEN_LIB_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Initializes a token transfer.\n    ///\n    /// @dev IMPORTANT: For native ERC20 tokens with transfer fees, the `transfer.remoteAmount` field might be modified\n    ///                 directly IN MEMORY.\n    ///\n    /// @param transfer The token transfer to initialize.\n    /// @param crossChainErc20Factory The address of the CrossChainERC20Factory.\n    ///\n    /// @return tokenType The Solana token type.\n    function initializeTransfer(Transfer memory transfer, address crossChainErc20Factory)\n        internal\n        returns (SolanaTokenType tokenType)\n    {\n        TokenLibStorage storage $ = getTokenLibStorage();\n        uint256 localAmount;\n\n        if (transfer.localToken == ETH_ADDRESS) {\n            // Case: Bridging native ETH to Solana\n            uint256 scalar = $.scalars[transfer.localToken][transfer.remoteToken];\n            require(scalar != 0, WrappedSplRouteNotRegistered());\n\n            localAmount = transfer.remoteAmount * scalar;\n            require(msg.value == localAmount, InvalidMsgValue());\n\n            tokenType = SolanaTokenType.WrappedToken;\n            $.deposits[transfer.localToken][transfer.remoteToken] += localAmount;\n        } else {\n            // Prevent sending ETH when bridging ERC20 tokens\n            require(msg.value == 0, InvalidMsgValue());\n\n            if (CrossChainERC20Factory(crossChainErc20Factory).isCrossChainErc20(transfer.localToken)) {\n                // Case: Bridging back native SOL or SPL token to Solana\n                bytes32 remoteToken = CrossChainERC20(transfer.localToken).remoteToken();\n                require(Pubkey.wrap(remoteToken) == transfer.remoteToken, IncorrectRemoteToken());\n\n                localAmount = transfer.remoteAmount;\n                CrossChainERC20(transfer.localToken).burn({from: msg.sender, amount: localAmount});\n\n                tokenType = transfer.remoteToken == NATIVE_SOL_PUBKEY ? SolanaTokenType.Sol : SolanaTokenType.Spl;\n            } else {\n                // Case: Bridging native ERC20 to Solana\n                uint256 scalar = $.scalars[transfer.localToken][transfer.remoteToken];\n                require(scalar != 0, WrappedSplRouteNotRegistered());\n\n                uint256 transferLocalAmount = transfer.remoteAmount * scalar;\n\n                // Compute the precise amount of tokens that have been received.\n                // NOTE: This is needed to support tokens with transfer fees.\n                uint256 balanceBefore = SafeTransferLib.balanceOf({token: transfer.localToken, account: address(this)});\n                SafeTransferLib.safeTransferFrom({\n                    token: transfer.localToken,\n                    from: msg.sender,\n                    to: address(this),\n                    amount: transferLocalAmount\n                });\n                uint256 balanceAfter = SafeTransferLib.balanceOf({token: transfer.localToken, account: address(this)});\n                uint256 receivedLocalAmount = balanceAfter - balanceBefore;\n\n                // Convert back to remote amount and transfer the dust back to the sender.\n                uint256 receivedRemoteAmount = receivedLocalAmount / scalar;\n                localAmount = receivedRemoteAmount * scalar;\n                uint256 dust = receivedLocalAmount - localAmount;\n                if (dust > 0) {\n                    SafeTransferLib.safeTransfer({token: transfer.localToken, to: msg.sender, amount: dust});\n                }\n\n                // IMPORTANT: Update the transfer struct IN MEMORY to reflect the remote amount to use for bridging.\n                transfer.remoteAmount = SafeCastLib.toUint64(receivedRemoteAmount);\n\n                $.deposits[transfer.localToken][transfer.remoteToken] += localAmount;\n\n                tokenType = SolanaTokenType.WrappedToken;\n            }\n        }\n\n        emit TransferInitialized({\n            localToken: transfer.localToken,\n            remoteToken: transfer.remoteToken,\n            to: Pubkey.wrap(transfer.to),\n            amount: localAmount\n        });\n    }\n\n    /// @notice Finalizes a token transfer.\n    ///\n    /// @param transfer The token transfer to finalize.\n    /// @param crossChainErc20Factory The address of the CrossChainERC20Factory.\n    function finalizeTransfer(Transfer memory transfer, address crossChainErc20Factory) internal {\n        TokenLibStorage storage $ = getTokenLibStorage();\n\n        address to = address(bytes20(transfer.to));\n        uint256 localAmount;\n\n        if (transfer.localToken == ETH_ADDRESS) {\n            // Case: Bridging back native ETH to EVM\n            uint256 scalar = $.scalars[transfer.localToken][transfer.remoteToken];\n            require(scalar != 0, WrappedSplRouteNotRegistered());\n            localAmount = transfer.remoteAmount * scalar;\n            $.deposits[transfer.localToken][transfer.remoteToken] -= localAmount;\n\n            SafeTransferLib.safeTransferETH({to: to, amount: localAmount});\n        } else {\n            if (CrossChainERC20Factory(crossChainErc20Factory).isCrossChainErc20(transfer.localToken)) {\n                // Case: Bridging native SOL or SPL token to EVM\n                bytes32 remoteToken = CrossChainERC20(transfer.localToken).remoteToken();\n                require(Pubkey.wrap(remoteToken) == transfer.remoteToken, IncorrectRemoteToken());\n\n                localAmount = transfer.remoteAmount;\n                CrossChainERC20(transfer.localToken).mint({to: to, amount: localAmount});\n            } else {\n                // Case: Bridging back native ERC20 to EVM\n                uint256 scalar = $.scalars[transfer.localToken][transfer.remoteToken];\n                require(scalar != 0, WrappedSplRouteNotRegistered());\n\n                localAmount = transfer.remoteAmount * scalar;\n                $.deposits[transfer.localToken][transfer.remoteToken] -= localAmount;\n\n                SafeTransferLib.safeTransfer({token: transfer.localToken, to: to, amount: localAmount});\n            }\n        }\n\n        emit TransferFinalized({\n            localToken: transfer.localToken,\n            remoteToken: transfer.remoteToken,\n            to: to,\n            amount: localAmount\n        });\n    }\n\n    /// @notice Registers a remote token and its conversion scalar.\n    ///\n    /// @param localToken Address of the ERC20 token on this chain.\n    /// @param remoteToken Pubkey of the remote token on Solana.\n    /// @param scalarExponent Exponent used to compute the remote->local conversion scalar\n    ///        (localAmount = remoteAmount * 10^scalarExponent).\n    function registerRemoteToken(address localToken, Pubkey remoteToken, uint8 scalarExponent) internal {\n        TokenLibStorage storage $ = getTokenLibStorage();\n        $.scalars[localToken][remoteToken] = 10 ** scalarExponent;\n    }\n}\n"
    }
}