{
    "vfp_id": "vfp_00110",
    "project_name": "cantina_coinbase_bridge_aug2025.pdf",
    "findings": [
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Inconsistent threshold configuration for validators",
            "description": "Validator threshold settings differ across components, leading to potential quorum mismatches. The cause is lack of centralized configuration management. Could result in failed consensus or rejected valid messages. The impact is reduced reliability and fault tolerance of the validation process.\n",
            "severity": "Informational",
            "location": [
                "BridgeValidator.sol#L29-L31"
            ],
            "files": [
                "bridge/base/src/BridgeValidator.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Pausing does not stop message registration on Base",
            "description": "When the bridge is paused, message registration on the Base chain is still permitted. The cause is incomplete implementation of the pause functionality, failing to cover all relevant functions. An attacker can continue registering messages during a pause state, potentially leading to inconsistent states. The impact is undermines the intended security of the pause mechanism, risking state inconsistency or unintended message processing.\n",
            "severity": "Low",
            "location": [
                "BridgeValidator.sol#L142-L159",
                "register_output_root.rs#L62-L65"
            ],
            "files": [
                "bridge/base/src/BridgeValidator.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Unhelpful error message when trying to register a 0-length array",
            "description": "Attempting to register an empty array returns a generic or unclear error. The cause is lack of specific input validation with descriptive errors. No direct exploit, but degrades user experience. The impact is increased difficulty in debugging client-side issues.\n",
            "severity": "Informational",
            "location": [
                "BridgeValidator.sol#L142"
            ],
            "files": [
                "bridge/base/src/BridgeValidator.sol"
            ]
        }
    ],
    "affected_files": {
        "BridgeValidator.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {OwnableRoles} from \"solady/auth/OwnableRoles.sol\";\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\nimport {Initializable} from \"solady/utils/Initializable.sol\";\n\nimport {IPartner} from \"./interfaces/IPartner.sol\";\nimport {MessageLib} from \"./libraries/MessageLib.sol\";\nimport {VerificationLib} from \"./libraries/VerificationLib.sol\";\n\n/// @title BridgeValidator\n///\n/// @notice A validator contract to be used during the Stage 0 phase of Base Bridge. This will likely later be replaced\n///         by `CrossL2Inbox` from the OP Stack.\ncontract BridgeValidator is Initializable {\n    using ECDSA for bytes32;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Constants                        ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice The max allowed partner validator threshold\n    uint256 public constant MAX_PARTNER_VALIDATOR_THRESHOLD = 5;\n\n    /// @notice Guardian role bit used by the `Bridge` contract for privileged actions on this contract.\n    uint256 public constant GUARDIAN_ROLE = 1 << 0;\n\n    /// @notice Required number of external (non-Base) signatures\n    uint256 public immutable PARTNER_VALIDATOR_THRESHOLD;\n\n    /// @notice Address of the Base Bridge contract. Used for authenticating guardian roles\n    address public immutable BRIDGE;\n\n    /// @notice Address of the contract holding the partner validator set\n    address public immutable PARTNER_VALIDATORS;\n\n    /// @notice A bit to be used in bitshift operations\n    uint256 private constant _BIT = 1;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Storage                          ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice The next expected nonce to be received in `registerMessages`\n    uint256 public nextNonce;\n\n    /// @notice A mapping of pre-validated valid messages. Each pre-validated message corresponds to a message sent\n    ///         from Solana.\n    mapping(bytes32 messageHash => bool isValid) public validMessages;\n\n    //////////////////////////////////////////////////////////////\n    ///                       Events                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a single message is registered (pre-validated).\n    ///\n    /// @param messageHash The pre-validated message hash (derived from the inner message hash and an incremental\n    ///                    nonce) corresponding to an `IncomingMessage` in the `Bridge` contract.\n    event MessageRegistered(bytes32 indexed messageHash);\n\n    //////////////////////////////////////////////////////////////\n    ///                       Errors                           ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when the provided `validatorSigs` byte string length is not a multiple of 65\n    error InvalidSignatureLength();\n\n    /// @notice Thrown when the required amount of Base signatures is not included with a `registerMessages` call\n    error BaseThresholdNotMet();\n\n    /// @notice Thrown when the required amount of partner signatures is not included with a `registerMessages` call\n    error PartnerThresholdNotMet();\n\n    /// @notice Thrown when a zero address is detected\n    error ZeroAddress();\n\n    /// @notice Thrown when the partner validator threshold is higher than number of validators\n    error ThresholdTooHigh();\n\n    /// @notice Thrown when the caller of a protected function is not a Base Bridge guardian\n    error CallerNotGuardian();\n\n    /// @notice Thrown when a duplicate partner validator is detected during signature verification\n    error DuplicateSigner();\n\n    /// @notice Thrown when the recovered signers are not sorted\n    error UnsortedSigners();\n\n    //////////////////////////////////////////////////////////////\n    ///                       Modifiers                        ///\n    //////////////////////////////////////////////////////////////\n\n    /// @dev Restricts function to `Bridge` guardians (as defined by `GUARDIAN_ROLE`).\n    modifier isGuardian() {\n        require(OwnableRoles(BRIDGE).hasAnyRole(msg.sender, GUARDIAN_ROLE), CallerNotGuardian());\n        _;\n    }\n\n    //////////////////////////////////////////////////////////////\n    ///                       Public Functions                 ///\n    //////////////////////////////////////////////////////////////\n\n    /// @notice Deploys the BridgeValidator contract with configuration for partner signatures and the `Bridge` address.\n    ///\n    /// @dev Reverts with `ThresholdTooHigh()` if `partnerThreshold` exceeds\n    ///      `MAX_PARTNER_VALIDATOR_THRESHOLD`. Reverts with `ZeroAddress()` if `bridge` is the zero address.\n    ///\n    /// @param partnerThreshold  The number of partner (external) validator signatures required for message\n    ///                          pre-validation.\n    /// @param bridgeAddress     The address of the `Bridge` contract used to check guardian roles.\n    /// @param partnerValidators Address of the contract holding the partner validator set\n    constructor(uint256 partnerThreshold, address bridgeAddress, address partnerValidators) {\n        require(partnerThreshold <= MAX_PARTNER_VALIDATOR_THRESHOLD, ThresholdTooHigh());\n        require(bridgeAddress != address(0), ZeroAddress());\n        require(partnerValidators != address(0), ZeroAddress());\n        PARTNER_VALIDATOR_THRESHOLD = partnerThreshold;\n        BRIDGE = bridgeAddress;\n        PARTNER_VALIDATORS = partnerValidators;\n        _disableInitializers();\n    }\n\n    /// @notice Initializes Base validator set and threshold.\n    ///\n    /// @dev Callable only once due to `initializer` modifier.\n    ///\n    /// @param baseValidators The initial list of Base validators.\n    /// @param baseThreshold The minimum number of Base validator signatures required.\n    function initialize(address[] calldata baseValidators, uint128 baseThreshold) external initializer {\n        VerificationLib.initialize(baseValidators, baseThreshold);\n    }\n\n    /// @notice Pre-validates a batch of Solana --> Base messages.\n    ///\n    /// @param innerMessageHashes An array of inner message hashes to pre-validate (hash over message data excluding the\n    ///                           nonce). Each is combined with a monotonically increasing nonce to form\n    ///                           `messageHashes`.\n    /// @param validatorSigs A concatenated bytes array of signatures over the EIP-191 `eth_sign` digest of\n    ///                      `abi.encode(messageHashes)`, provided in strictly ascending order by signer address.\n    ///                      Must include at least `getBaseThreshold()` Base validator signatures. The external\n    ///                      signature threshold is controlled by `PARTNER_VALIDATOR_THRESHOLD`.\n    function registerMessages(bytes32[] calldata innerMessageHashes, bytes calldata validatorSigs) external {\n        uint256 len = innerMessageHashes.length;\n        bytes32[] memory messageHashes = new bytes32[](len);\n        uint256 currentNonce = nextNonce;\n\n        for (uint256 i; i < len; i++) {\n            messageHashes[i] = MessageLib.getMessageHash(currentNonce++, innerMessageHashes[i]);\n        }\n\n        _validateSigs({messageHashes: messageHashes, sigData: validatorSigs});\n\n        for (uint256 i; i < len; i++) {\n            validMessages[messageHashes[i]] = true;\n            emit MessageRegistered(messageHashes[i]);\n        }\n\n        nextNonce = currentNonce;\n    }\n\n    /// @notice Updates the Base signature threshold.\n    ///\n    /// @dev Only callable by a Bridge guardian.\n    ///\n    /// @param newThreshold The new threshold value.\n    function setThreshold(uint256 newThreshold) external isGuardian {\n        VerificationLib.setThreshold(newThreshold);\n    }\n\n    /// @notice Adds a Base validator.\n    ///\n    /// @dev Only callable by a Bridge guardian.\n    ///\n    /// @param validator The validator address to add.\n    function addValidator(address validator) external isGuardian {\n        VerificationLib.addValidator(validator);\n    }\n\n    /// @notice Removes a Base validator.\n    ///\n    /// @dev Only callable by a Bridge guardian.\n    ///\n    /// @param validator The validator address to remove.\n    function removeValidator(address validator) external isGuardian {\n        VerificationLib.removeValidator(validator);\n    }\n\n    //////////////////////////////////////////////////////////////\n    ///                    Private Functions                   ///\n    //////////////////////////////////////////////////////////////\n\n    /// @dev Verifies that the provided signatures satisfy Base and partner thresholds for `messageHashes`.\n    ///\n    /// @param messageHashes The derived message hashes (inner hash + nonce) for the batch.\n    /// @param sigData Concatenated signatures over `toEthSignedMessageHash(abi.encode(messageHashes))`.\n    function _validateSigs(bytes32[] memory messageHashes, bytes calldata sigData) private view {\n        address[] memory recoveredSigners = _getSignersFromSigs(messageHashes, sigData);\n        require(_countBaseSigners(recoveredSigners) >= VerificationLib.getBaseThreshold(), BaseThresholdNotMet());\n\n        if (PARTNER_VALIDATOR_THRESHOLD > 0) {\n            IPartner.Signer[] memory partnerValidators = IPartner(PARTNER_VALIDATORS).getSigners();\n            require(\n                _countPartnerSigners(partnerValidators, recoveredSigners) >= PARTNER_VALIDATOR_THRESHOLD,\n                PartnerThresholdNotMet()\n            );\n        }\n    }\n\n    function _getSignersFromSigs(bytes32[] memory messageHashes, bytes calldata sigData)\n        private\n        view\n        returns (address[] memory)\n    {\n        // Check that the provided signature data is a multiple of the valid sig length\n        require(sigData.length % VerificationLib.SIGNATURE_LENGTH_THRESHOLD == 0, InvalidSignatureLength());\n\n        uint256 sigCount = sigData.length / VerificationLib.SIGNATURE_LENGTH_THRESHOLD;\n        bytes32 signedHash = ECDSA.toEthSignedMessageHash(abi.encode(messageHashes));\n        address lastValidator = address(0);\n        address[] memory recoveredSigners = new address[](sigCount);\n\n        uint256 offset;\n        assembly {\n            offset := sigData.offset\n        }\n\n        for (uint256 i; i < sigCount; i++) {\n            (uint8 v, bytes32 r, bytes32 s) = VerificationLib.signatureSplit(offset, i);\n            address currentValidator = signedHash.recover(v, r, s);\n            require(currentValidator > lastValidator, UnsortedSigners());\n            recoveredSigners[i] = currentValidator;\n            lastValidator = currentValidator;\n        }\n\n        return recoveredSigners;\n    }\n\n    function _countBaseSigners(address[] memory signers) private view returns (uint256) {\n        uint256 count;\n\n        for (uint256 i; i < signers.length; i++) {\n            if (VerificationLib.isBaseValidator(signers[i])) {\n                unchecked {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    function _countPartnerSigners(IPartner.Signer[] memory partnerValidators, address[] memory signers)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 count;\n        uint256 signedBitMap;\n\n        for (uint256 i; i < signers.length; i++) {\n            uint256 partnerIndex = _indexOf(partnerValidators, signers[i]);\n            if (partnerIndex == partnerValidators.length) {\n                continue;\n            }\n\n            if (signedBitMap & (_BIT << partnerIndex) != 0) {\n                revert DuplicateSigner();\n            }\n\n            signedBitMap |= _BIT << partnerIndex;\n            unchecked {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    /// @dev Linear search for `addr` in memory array `addrs`.\n    function _indexOf(IPartner.Signer[] memory addrs, address addr) private pure returns (uint256) {\n        for (uint256 i; i < addrs.length; i++) {\n            if (addr == addrs[i].evmAddress || addr == addrs[i].newEvmAddress) {\n                return i;\n            }\n        }\n        return addrs.length;\n    }\n}\n"
    }
}