{
    "vfp_id": "vfp_00308",
    "project_name": "Across Protocol OFT Integration Differential Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Compromised Messengers Cannot Be Removed",
            "description": "The `_setOftMessenger` function in the SpokePool contract allows setting or updating an OFT messenger for a token but does not allow removing a messenger by setting its address to zero. The function reverts if the provided messenger address is zero or does not implement the `token()` method, preventing the admin from disabling a compromised or malfunctioning messenger.\n\nThe root cause is the lack of a dedicated removal function and the strict validation that blocks zero-address updates. This forces the admin to replace a compromised messenger with a new one, which may not be feasible during an active exploit or emergency.\n\nAn attacker who compromises a messenger contract could block all OFT-based transfers by causing reverts or stealing funds. The admin cannot quickly disable the messenger, increasing the window of exposure.\n\nThe impact is prolonged vulnerability exposure and potential fund loss or service disruption until a new contract is deployed and configured, reducing the protocol's resilience to attacks.\n",
            "severity": "Medium",
            "location": [
                "SpokePool.sol::_setOftMessenger#1739"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "EIP-7702 EOA Accounts' Treatment Could Result in Reentrancy",
            "description": "When sending ETH or WETH to an EIP-7702 EOA wallet, the `_unwrapwrappedNativeTokenTo` function uses a low-level `.call` without limiting gas, allowing the recipient's fallback or receive function to execute arbitrary logic, including reentrancy attacks. The root cause is treating EIP-7702 EOAs as regular wallets without restricting gas or using WETH instead. Since EIP-7702 wallets can have arbitrary logic, a malicious implementation could reenter the protocol before state changes are finalized, potentially manipulating funds or logic flow. Although some functions are reentrancy-protected, this vector increases the attack surface and could be exploited in combination with other vulnerabilities.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol::_is7702DelegatedWallet#1611",
                "SpokePool.sol::_unwrapwrappedNativeTokenTo#1613"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Lack of Validation On Linked Messengers",
            "description": "The `SpokePool` contract performs only a basic `token` function check when setting messengers, which is insufficient to verify that a contract supports the required `IOFT` interface. The root cause is the absence of EIP-165 interface detection, allowing potentially incompatible contracts to be registered. A malicious or misconfigured contract with a `token` function could be accepted, leading to unexpected behavior or failed messages. This could result in message delivery failures, loss of funds, or denial of service. The risk is mitigated slightly by admin control, but human error remains a concern.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol#1740",
                "AdapterStore.sol#28-L64",
                "IOFT.sol#48"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Logic Not Fully Deprecated",
            "description": "The `SpokePool` contract inherits `OFTTransportAdapter` and accepts OFT-related constructor parameters even on chains that do not use OFT functionality, setting them to zero. The root cause is incomplete deprecation of unused logic. This increases the attack surface because zero values in `OFT_DST_EID` and `OFT_FEE_CAP` could be exploited in future upgrades if the OFT path becomes active. Additionally, admins can still modify the `oftMessengers` mapping, potentially pre-configuring malicious or incorrect messengers for future exploitation. This represents a latent security risk.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol#1739-L1749",
                "SpokePool.sol#226",
                "Polygon_SpokePool.sol#94-L96",
                "OFTTransportAdapter.sol#57",
                "OFTTransportAdapter.sol#85-L92",
                "OFTTransportAdapter.sol#88"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1061"
                ],
                "3": [
                    "CWE-766"
                ]
            },
            "title": "Abstract Contracts Allow Direct Modification of State Variables",
            "description": "The `SpokePool` abstract contract exposes the `oftMessengers` state variable as `public`, allowing child contracts to modify it directly without going through controlled setters. The root cause is improper visibility settings in an abstract base contract. This can break expected invariants, bypass validation logic, and prevent event emission, hindering off-chain monitoring. A malicious or buggy child contract could corrupt the mapping, leading to incorrect messenger routing and potential fund loss. While admin-controlled, it reduces code safety and auditability.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol#117"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Zero-Address Checks",
            "description": "Multiple functions that assign address parameters lack zero-address validation, including `_setMessenger` in `AdapterStore` and `SpokePool`, and `_adapterStore` in `OFTTransportAdapterWithStore`. The root cause is missing input validation. If a zero address is accidentally set, it could lead to loss of control or unintended behavior, such as sending funds to the burn address. Although these functions are admin-controlled, the lack of safeguards increases the risk of operational errors. The team acknowledges this but considers it low risk due to admin trust assumptions.\n",
            "severity": "Low",
            "location": [
                "AdapterStore.sol#34",
                "AdapterStore.sol#52",
                "OFTTransportAdapterWithStore.sol#17",
                "SpokePool.sol#363"
            ],
            "files": [
                "contracts/contracts/AdapterStore.sol",
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Missing Docstrings",
            "description": "Numerous contracts, including `AdapterStore.sol`, `OFTTransportAdapter.sol`, and various SpokePool implementations, lack NatSpec documentation for functions, parameters, and state variables. The root cause is incomplete code documentation practices. This reduces code readability, increases the risk of misinterpretation during audits or upgrades, and hinders developer onboarding. While not directly exploitable, it contributes to long-term maintainability and security risks. Some docstrings were added post-audit, but coverage remains incomplete.\n",
            "severity": "Low",
            "location": [
                "AdapterStore.sol",
                "OFTTransportAdapter.sol",
                "SpokePool.sol",
                "Universal_Adapter.sol"
            ],
            "files": [
                "contracts/contracts/AdapterStore.sol",
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Floating Pragma",
            "description": "Multiple contracts use floating pragma directives (e.g., `^0.8.0`, `^0.8.19`), which can lead to compilation with untested Solidity versions. The root cause is lack of version pinning. This introduces risk of unexpected behavior due to compiler changes, including security-relevant optimizations or bugs. While the team uses consistent versions in practice, the absence of fixed pragmas makes the build process less deterministic and increases supply chain risk.\n",
            "severity": "Low",
            "location": [
                "AdapterStore.sol#2",
                "AlephZero_SpokePool.sol#5",
                "Arbitrum_Adapter.sol#2",
                "SpokePool.sol#2",
                "OFTTransportAdapter.sol#2",
                "Universal_Adapter.sol#2"
            ],
            "files": [
                "contracts/contracts/AdapterStore.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "Function Selectors On Deprecated Functions Are Not Locked",
            "description": "The contract removed deprecated functions such as `depositDeprecated_5947912356` and `depositFor`, but did not preserve their function selectors to block reuse. This creates a risk that future functions could accidentally inherit the same selectors, leading to unintended execution if old calls are replayed. The root cause is the deletion of function definitions without adding explicit reverts for their selectors. An attacker or legacy system could call the contract with calldata matching the old function signatures, potentially triggering new logic with unintended consequences. The impact includes potential misrouting of calls and unexpected behavior in the contract, especially in systems relying on historical interfaces.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol::depositDeprecated_5947912356",
                "SpokePool.sol::depositFor"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Zero-Address Validation Bypass in SpokePool",
            "description": "The `_setOftMessenger` function in `SpokePool` validates that the messenger is appropriate for the token but does not check that the `_token` parameter is non-zero. If the messenger has not set its token, an admin could link it to the zero address. While subsequent transfers would fail, this edge case increases the attack surface and could be exploited in complex call sequences or during initialization phases. The root cause is missing input validation for the zero address. An admin with malicious intent or error could set the token to address(0), leading to confusion or potential future vulnerabilities if logic changes. The impact is limited due to subsequent checks, but it represents an unnecessary risk.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol::_setOftMessenger#1740"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Possible Duplicate Event Emissions",
            "description": "The `setOftMessenger` function in `SpokePool` emits an event without checking if the value has changed. This allows an admin to repeatedly emit the same event by setting an identical value, potentially spamming off-chain indexing systems and causing confusion. The root cause is the absence of a state-change check before event emission. A malicious or misconfigured admin could exploit this to flood event logs, making it harder for clients to track real changes. The impact is primarily on off-chain monitoring and data integrity, with minimal on-chain consequences.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol::setOftMessenger#1743",
                "SpokePool.sol::setOftMessenger#1744"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant Getter Function",
            "description": "The `_getOftMessenger` function in `SpokePool` is redundant because the `oftMessengers` mapping is public and already generates a getter. This redundancy adds unnecessary code and can confuse developers about intended access patterns. The root cause is the explicit creation of a getter for a public state variable. While not directly exploitable, it increases code complexity and maintenance burden. The impact is reduced code clarity and potential for inconsistent usage across the codebase.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol::_getOftMessenger#1747-1749"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-668"
                ]
            },
            "title": "Function Visibility Overly Permissive",
            "description": "Several functions have more permissive visibility than necessary. For example, `_setOftMessenger` is `internal` but could be `private`, and `setOftMessenger` is `public` but should be `external` since it's only intended for admin calls. The root cause is overly broad access modifiers. While not immediately exploitable due to admin controls, overly permissive visibility increases the attack surface and may lead to unintended usage in derived contracts. The impact includes potential misuse in inheritance hierarchies and slightly higher gas costs.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol::_setOftMessenger#1739-1745",
                "SpokePool.sol::setOftMessenger#362"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Non-Explicit Imports",
            "description": "The codebase uses global imports (e.g., `import \"./libraries/OFTTransportAdapter.sol\";`) instead of named imports. This reduces code clarity and increases the risk of naming conflicts, especially in large files or complex inheritance trees. The root cause is the use of legacy import syntax. While not a direct security vulnerability, it can lead to developer errors and confusion during audits or maintenance. The impact is reduced readability and maintainability.\n",
            "severity": "Low",
            "location": [
                "SpokePool.sol#15",
                "Universal_Adapter.sol#11"
            ],
            "files": [
                "contracts/contracts/SpokePool.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Multiple Contract Declarations Per File",
            "description": "The `AdapterStore.sol` file declares both the `MessengerTypes` library and the `AdapterStore` contract. While acceptable for small libraries, this practice can reduce code organization and make it harder to navigate. The root cause is combining multiple logical components in one file. This does not pose a direct security risk but can hinder code review and understanding, especially for new developers. The impact is reduced code modularity and clarity.\n",
            "severity": "Low",
            "location": [
                "AdapterStore.sol"
            ],
            "files": [
                "contracts/contracts/AdapterStore.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Missing Named Parameters in Mappings",
            "description": "Mappings such as `crossChainMessengers` and `oftMessengers` do not use named parameters, a feature available since Solidity 0.8.18. This reduces code readability and makes it harder to understand the purpose of each mapping component. The root cause is the use of older syntax. While not a vulnerability, it affects code maintainability and clarity. The impact is reduced developer experience and potential for misinterpretation during audits.\n",
            "severity": "Low",
            "location": [
                "AdapterStore.sol::crossChainMessengers#17",
                "SpokePool.sol::oftMessengers#117"
            ],
            "files": [
                "contracts/contracts/AdapterStore.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Lack of Security Contact",
            "description": "Several contracts and libraries, including `MessengerTypes`, `AdapterStore`, and `OFTTransportAdapterWithStore`, lack a `@custom:security-contact` NatSpec tag. This makes it harder for security researchers to report vulnerabilities. The root cause is missing documentation. The impact is potential delays in vulnerability disclosure and response, increasing the window of exposure if a critical issue is found.\n",
            "severity": "Low",
            "location": [
                "AdapterStore.sol::MessengerTypes",
                "AdapterStore.sol::AdapterStore",
                "OFTTransportAdapterWithStore.sol"
            ],
            "files": [
                "contracts/contracts/AdapterStore.sol"
            ]
        }
    ],
    "affected_files": {
        "AdapterStore.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nlibrary MessengerTypes {\n    bytes32 public constant OFT_MESSENGER = bytes32(\"OFT_MESSENGER\");\n}\n\n/**\n * @dev A helper contract for chain adapters on the hub chain that support OFT messaging. Handles\n * @dev token => messenger mapping storage. Adapters can't store this themselves as they're called\n * @dev via `delegateCall` and their storage is not part of available context.\n */\ncontract AdapterStore is Ownable {\n    // (messengerType, dstDomainId, srcChainToken) => messenger address\n    mapping(bytes32 => mapping(uint256 => mapping(address => address))) public crossChainMessengers;\n\n    event MessengerSet(\n        bytes32 indexed messengerType,\n        uint256 indexed dstDomainId,\n        address indexed srcChainToken,\n        address srcChainMessenger\n    );\n\n    error ArrayLengthMismatch();\n\n    function setMessenger(\n        bytes32 messengerType,\n        uint256 dstDomainId,\n        address srcChainToken,\n        address srcChainMessenger\n    ) external onlyOwner {\n        _setMessenger(messengerType, dstDomainId, srcChainToken, srcChainMessenger);\n    }\n\n    function batchSetMessengers(\n        bytes32[] calldata messengerTypes,\n        uint256[] calldata dstDomainIds,\n        address[] calldata srcChainTokens,\n        address[] calldata srcChainMessengers\n    ) external onlyOwner {\n        if (\n            messengerTypes.length != dstDomainIds.length ||\n            messengerTypes.length != srcChainTokens.length ||\n            messengerTypes.length != srcChainMessengers.length\n        ) {\n            revert ArrayLengthMismatch();\n        }\n\n        for (uint256 i = 0; i < dstDomainIds.length; i++) {\n            _setMessenger(messengerTypes[i], dstDomainIds[i], srcChainTokens[i], srcChainMessengers[i]);\n        }\n    }\n\n    function _setMessenger(\n        bytes32 _messengerType,\n        uint256 _dstDomainId,\n        address _srcChainToken,\n        address _srcChainMessenger\n    ) internal {\n        crossChainMessengers[_messengerType][_dstDomainId][_srcChainToken] = _srcChainMessenger;\n        emit MessengerSet(_messengerType, _dstDomainId, _srcChainToken, _srcChainMessenger);\n    }\n}\n",
        "SpokePool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./erc7683/ERC7683.sol\";\nimport \"./erc7683/ERC7683Permit2Lib.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolMessageHandler.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./upgradeable/MultiCallerUpgradeable.sol\";\nimport \"./upgradeable/EIP712CrossChainUpgradeable.sol\";\nimport \"./upgradeable/AddressLibUpgradeable.sol\";\nimport \"./libraries/AddressConverters.sol\";\nimport \"./libraries/OFTTransportAdapter.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title SpokePool\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \"data worker\",\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\n * @custom:security-contact bugs@across.to\n */\nabstract contract SpokePool is\n    V3SpokePoolInterface,\n    SpokePoolInterface,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MultiCallerUpgradeable,\n    EIP712CrossChainUpgradeable,\n    IDestinationSettler,\n    OFTTransportAdapter\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressLibUpgradeable for address;\n    using Bytes32ToAddress for bytes32;\n    using AddressToBytes32 for address;\n\n    // Address of the L1 contract that acts as the owner of this SpokePool. This should normally be set to the HubPool\n    // address. The crossDomainAdmin address is unused when the SpokePool is deployed to the same chain as the HubPool.\n    address public crossDomainAdmin;\n\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\n    // refunds and slow relays.\n    address public withdrawalRecipient;\n\n    // Note: The following two storage variables prefixed with DEPRECATED used to be variables that could be set by\n    // the cross-domain admin. Admins ended up not changing these in production, so to reduce\n    // gas in deposit/fill functions, we are converting them to private variables to maintain the contract\n    // storage layout and replacing them with immutable or constant variables, because retrieving a constant\n    // value is cheaper than retrieving a storage variable. Please see out the immutable/constant variable section.\n    WETH9Interface private DEPRECATED_wrappedNativeToken;\n    uint32 private DEPRECATED_depositQuoteTimeBuffer;\n\n    // `numberOfDeposits` acts as a counter to generate unique deposit identifiers for this spoke pool.\n    // It is a uint32 that increments with each `depositV3` call. In the `FundsDeposited` event, it is\n    // implicitly cast to uint256 by setting its most significant bits to 0, reducing the risk of ID collisions\n    // with unsafe deposits. However, this variable's name could be improved (e.g., `depositNonceCounter`)\n    // since it does not accurately reflect the total number of deposits, as `unsafeDeposit` can bypass this increment.\n    uint32 public numberOfDeposits;\n\n    // Whether deposits and fills are disabled.\n    bool public pausedFills;\n    bool public pausedDeposits;\n\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\n    RootBundle[] public rootBundles;\n\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\n    mapping(address => mapping(uint256 => bool)) private DEPRECATED_enabledDepositRoutes;\n\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\n    // relay, the fees, and the agents are all parameters included in the hash key.\n    mapping(bytes32 => uint256) private DEPRECATED_relayFills;\n\n    // Note: We will likely un-deprecate the fill and deposit counters to implement a better\n    // dynamic LP fee mechanism but for now we'll deprecate it to reduce bytecode\n    // in deposit/fill functions. These counters are designed to implement a fee mechanism that is based on a\n    // canonical history of deposit and fill events and how they update a virtual running balance of liabilities and\n    // assets, which then determines the LP fee charged to relays.\n\n    // This keeps track of the worst-case liabilities due to fills.\n    // It is never reset. Users should only rely on it to determine the worst-case increase in liabilities between\n    // two points. This is used to provide frontrunning protection to ensure the relayer's assumptions about the state\n    // upon which their expected repayments are based will not change before their transaction is mined.\n    mapping(address => uint256) private DEPRECATED_fillCounter;\n\n    // This keeps track of the total running deposits for each token. This allows depositors to protect themselves from\n    // frontrunning that might change their worst-case quote.\n    mapping(address => uint256) private DEPRECATED_depositCounter;\n\n    // This tracks the number of identical refunds that have been requested.\n    // The intention is to allow an off-chain system to know when this could be a duplicate and ensure that the other\n    // requests are known and accounted for.\n    mapping(bytes32 => uint256) private DEPRECATED_refundsRequested;\n\n    // Mapping of V3 relay hashes to fill statuses. Distinguished from relayFills\n    // to eliminate any chance of collision between pre and post V3 relay hashes.\n    mapping(bytes32 => uint256) public fillStatuses;\n\n    // Mapping of L2TokenAddress to relayer to outstanding refund amount. Used when a relayer repayment fails for some\n    // reason (eg blacklist) to track their outstanding liability, thereby letting them claim it later.\n    mapping(address => mapping(address => uint256)) public relayerRefund;\n\n    // Mapping of L2 token address to L2 IOFT messenger address. Required to support bridging via OFT standard\n    mapping(address => address) public oftMessengers;\n\n    /**************************************************************\n     *                CONSTANT/IMMUTABLE VARIABLES                *\n     **************************************************************/\n    // Constant and immutable variables do not take up storage slots and are instead added to the contract bytecode\n    // at compile time. The difference between them is that constant variables must be declared inline, meaning\n    // that they cannot be changed in production without changing the contract code, while immutable variables\n    // can be set in the constructor. Therefore we use the immutable keyword for variables that we might want to be\n    // different for each child contract (one obvious example of this is the wrappedNativeToken) or that we might\n    // want to update in the future like depositQuoteTimeBuffer. Constants are unlikely to ever be changed.\n\n    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can\n    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    WETH9Interface public immutable wrappedNativeToken;\n\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\n    // caller to use an approximately \"current\" realized fee.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable depositQuoteTimeBuffer;\n\n    // The fill deadline can only be set this far into the future from the timestamp of the deposit on this contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable fillDeadlineBuffer;\n\n    uint256 public constant MAX_TRANSFER_SIZE = 1e36;\n\n    bytes32 public constant UPDATE_BYTES32_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint256 depositId,uint256 originChainId,uint256 updatedOutputAmount,bytes32 updatedRecipient,bytes updatedMessage)\"\n        );\n    // Default chain Id used to signify that no repayment is requested, for example when executing a slow fill.\n    uint256 public constant EMPTY_REPAYMENT_CHAIN_ID = 0;\n    // Default address used to signify that no relayer should be credited with a refund, for example\n    // when executing a slow fill.\n    bytes32 public constant EMPTY_RELAYER = bytes32(0);\n    // This is the magic value that signals to the off-chain validator\n    // that this deposit can never expire. A deposit with this fill deadline should always be eligible for a\n    // slow fill, meaning that its output token and input token must be \"equivalent\". Therefore, this value is only\n    // used as a fillDeadline in deposit(), a soon to be deprecated function that also hardcodes outputToken to\n    // the zero address, which forces the off-chain validator to replace the output token with the equivalent\n    // token for the input token. By using this magic value, off-chain validators do not have to keep\n    // this event in their lookback window when querying for expired deposits.\n    uint32 public constant INFINITE_FILL_DEADLINE = type(uint32).max;\n\n    // One year in seconds. If `exclusivityParameter` is set to a value less than this, then the emitted\n    // exclusivityDeadline in a deposit event will be set to the current time plus this value.\n    uint32 public constant MAX_EXCLUSIVITY_PERIOD_SECONDS = 31_536_000;\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n    event SetXDomainAdmin(address indexed newAdmin);\n    event SetWithdrawalRecipient(address indexed newWithdrawalRecipient);\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\n    event RelayedRootBundle(\n        uint32 indexed rootBundleId,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 indexed slowRelayRoot\n    );\n    event ExecutedRelayerRefundRoot(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint256[] refundAmounts,\n        uint32 indexed rootBundleId,\n        uint32 indexed leafId,\n        address l2TokenAddress,\n        address[] refundAddresses,\n        bool deferredRefunds,\n        address caller\n    );\n    event TokensBridged(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint32 indexed leafId,\n        bytes32 indexed l2TokenAddress,\n        address caller\n    );\n    event EmergencyDeletedRootBundle(uint256 indexed rootBundleId);\n    event PausedDeposits(bool isPaused);\n    event PausedFills(bool isPaused);\n    event SetOFTMessenger(address indexed token, address indexed messenger);\n\n    error OFTTokenMismatch();\n\n    /**\n     * @notice Construct the SpokePool. Normally, logic contracts used in upgradeable proxies shouldn't\n     * have constructors since the following code will be executed within the logic contract's state, not the\n     * proxy contract's state. However, if we restrict the constructor to setting only immutable variables, then\n     * we are safe because immutable variables are included in the logic contract's bytecode rather than its storage.\n     * @dev Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be\n     * taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being\n     * used, you should invoke the _disableInitializers function in the constructor to automatically lock it when\n     * it is deployed:\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     * @param _oftDstEid destination endpoint id for OFT messaging\n     * @param _oftFeeCap fee cap in native token when paying for cross-chain OFT transfers\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    ) OFTTransportAdapter(_oftDstEid, _oftFeeCap) {\n        wrappedNativeToken = WETH9Interface(_wrappedNativeTokenAddress);\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\n        fillDeadlineBuffer = _fillDeadlineBuffer;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct the base SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function __SpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public onlyInitializing {\n        numberOfDeposits = _initialDepositId;\n        __EIP712_init(\"ACROSS-V2\", \"1.0.0\");\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n        _setWithdrawalRecipient(_withdrawalRecipient);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     * @dev This should be set to cross domain admin for specific SpokePool.\n     */\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    modifier unpausedDeposits() {\n        if (pausedDeposits) revert DepositsArePaused();\n        _;\n    }\n\n    modifier unpausedFills() {\n        if (pausedFills) revert FillsArePaused();\n        _;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    // Allows cross domain admin to upgrade UUPS proxy implementation.\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {}\n\n    /**\n     * @notice Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects `deposit()` but not `speedUpDeposit()`, so that existing deposits can be sped up and still\n     * relayed.\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseDeposits(bool pause) public override onlyAdmin nonReentrant {\n        pausedDeposits = pause;\n        emit PausedDeposits(pause);\n    }\n\n    /**\n     * @notice Pauses fill-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects fillRelayWithUpdatedDeposit() and fillRelay().\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseFills(bool pause) public override onlyAdmin nonReentrant {\n        pausedFills = pause;\n        emit PausedFills(pause);\n    }\n\n    /**\n     * @notice Change cross domain admin address. Callable by admin only.\n     * @param newCrossDomainAdmin New cross domain admin.\n     */\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    /**\n     * @notice Change L1 withdrawal recipient address. Callable by admin only.\n     * @param newWithdrawalRecipient New withdrawal recipient address.\n     */\n    function setWithdrawalRecipient(address newWithdrawalRecipient) public override onlyAdmin nonReentrant {\n        _setWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    /**\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\n     * executeRelayerRefundLeaf().\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\n     * executeSlowRelayLeaf().\n     */\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {\n        uint32 rootBundleId = uint32(rootBundles.length);\n        RootBundle storage rootBundle = rootBundles.push();\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\n        rootBundle.slowRelayRoot = slowRelayRoot;\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\n    }\n\n    /**\n     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the\n     * SpokePool.\n     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256\n     * to ensure that a small input range doesn't limit which indices this method is able to reach.\n     */\n    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {\n        // Deleting a struct containing a mapping does not delete the mapping in Solidity, therefore the bitmap's\n        // data will still remain potentially leading to vulnerabilities down the line. The way around this would\n        // be to iterate through every key in the mapping and resetting the value to 0, but this seems expensive and\n        // would require a new list in storage to keep track of keys.\n        //slither-disable-next-line mapping-deletion\n        delete rootBundles[rootBundleId];\n        emit EmergencyDeletedRootBundle(rootBundleId);\n    }\n\n    /**\n     * @notice Add token -> OFTMessenger relationship. Callable only by admin.\n     * @param token token address on the current chain\n     * @param messenger IOFT contract address on the current chain for the specified token. Acts as a 'mailbox'\n     */\n    function setOftMessenger(address token, address messenger) public onlyAdmin nonReentrant {\n        _setOftMessenger(token, messenger);\n    }\n\n    /**************************************\n     *    LEGACY DEPOSITOR FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\n     *      Please use deposit (under DEPOSITOR FUNCTIONS below) or depositV3 instead.\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\n     * token mapping is stored on the L1 HubPool.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @dev Produces a FundsDeposited event with an infinite expiry, meaning that this deposit can never expire.\n     * Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositDeprecated_5947912356(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(\n            msg.sender,\n            recipient,\n            originToken,\n            amount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message\n        );\n    }\n\n    /**\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\n     *      Please use the other deposit or depositV3 instead.\n     * @notice The only difference between depositFor and deposit is that the depositor address stored\n     * in the relay hash can be overridden by the caller. This means that the passed in depositor\n     * can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer\n     * contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @param depositor Address who is credited for depositing funds on origin chain and can speed up the deposit.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(depositor, recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp, message);\n    }\n\n    /********************************************\n     *            DEPOSITOR FUNCTIONS           *\n     ********************************************/\n\n    /**\n     * @notice Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the\n     * as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now,\n     * the caller is expected to pass in a number that will be interpreted either as an offset or a fixed\n     * timestamp depending on its value.\n     * @notice Request to bridge input token cross chain to a destination chain and receive a specified amount\n     * of output tokens. The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs,\n     * the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and the system fee that they'll be charged.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is\n     * greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be\n     * address(0), and vice versa if this is address(0).\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where\n     * currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function deposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override nonReentrant unpausedDeposits {\n        // Increment the `numberOfDeposits` counter to ensure a unique deposit ID for this spoke pool.\n        DepositV3Params memory params = DepositV3Params({\n            depositor: depositor,\n            recipient: recipient,\n            inputToken: inputToken,\n            outputToken: outputToken,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            destinationChainId: destinationChainId,\n            exclusiveRelayer: exclusiveRelayer,\n            depositId: numberOfDeposits++,\n            quoteTimestamp: quoteTimestamp,\n            fillDeadline: fillDeadline,\n            exclusivityParameter: exclusivityParameter,\n            message: message\n        });\n        _depositV3(params);\n    }\n\n    /**\n     * @notice A version of `deposit` that accepts `address` types for backward compatibility.\n     * This function allows bridging of input tokens cross-chain to a destination chain, receiving a specified amount of output tokens.\n     * The relayer is refunded in input tokens on a repayment chain of their choice, minus system fees, after an optimistic challenge\n     * window. The exclusivity period is specified as an offset from the current block timestamp.\n     *\n     * @dev This version mirrors the original `depositV3` function, but uses `address` types for `depositor`, `recipient`,\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` for compatibility with contracts using the `address` type.\n     *\n     * The key functionality and logic remain identical, ensuring interoperability across both versions.\n     *\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\n     * The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal\n     * to the wrapped native token, the caller can optionally pass in native token as msg.value, provided msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract. This\n     * amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token as a valid\n     * deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer exclusively allowed to fill this deposit before the exclusivity deadline.\n     * @param quoteTimestamp The HubPool timestamp that determines the system fee paid by the depositor. This must be set\n     * between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will\n     * revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp\n     * on this chain.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract. If the\n     * message is not empty, the recipient contract must implement `handleV3AcrossMessage()` or the fill will revert.\n     */\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override {\n        deposit(\n            depositor.toBytes32(),\n            recipient.toBytes32(),\n            inputToken.toBytes32(),\n            outputToken.toBytes32(),\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer.toBytes32(),\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice See deposit for details. This function is identical to deposit except that it does not use the\n     * global deposit ID counter as a deposit nonce, instead allowing the caller to pass in a deposit nonce. This\n     * function is designed to be used by anyone who wants to pre-compute their resultant relay data hash, which\n     * could be useful for filling a deposit faster and avoiding any risk of a relay hash unexpectedly changing\n     * due to another deposit front-running this one and incrementing the global deposit ID counter.\n     * @dev This is labeled \"unsafe\" because there is no guarantee that the depositId emitted in the resultant\n     * FundsDeposited event is unique which means that the\n     * corresponding fill might collide with an existing relay hash on the destination chain SpokePool,\n     * which would make this deposit unfillable. In this case, the depositor would subsequently receive a refund\n     * of `inputAmount` of `inputToken` on the origin chain after the fill deadline. Re-using a depositNonce is very\n     * dangerous when combined with `speedUpDeposit`, as a speed up signature can be re-used for any deposits\n     * with the same deposit ID.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositNonce The nonce that uniquely identifies this deposit. This function will combine this parameter\n     * with the msg.sender address to create a unique uint256 depositNonce and ensure that the msg.sender cannot\n     * use this function to front-run another depositor's unsafe deposit. This function guarantees that the resultant\n     * deposit nonce will not collide with a safe uint256 deposit nonce whose 24 most significant bytes are always 0.\n     * @param depositor See identically named parameter in depositV3() comments.\n     * @param recipient See identically named parameter in depositV3() comments.\n     * @param inputToken See identically named parameter in depositV3() comments.\n     * @param outputToken See identically named parameter in depositV3() comments.\n     * @param inputAmount See identically named parameter in depositV3() comments.\n     * @param outputAmount See identically named parameter in depositV3() comments.\n     * @param destinationChainId See identically named parameter in depositV3() comments.\n     * @param exclusiveRelayer See identically named parameter in depositV3() comments.\n     * @param quoteTimestamp See identically named parameter in depositV3() comments.\n     * @param fillDeadline See identically named parameter in depositV3() comments.\n     * @param exclusivityParameter See identically named parameter in depositV3() comments.\n     * @param message See identically named parameter in depositV3() comments.\n     */\n    function unsafeDeposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable nonReentrant unpausedDeposits {\n        // @dev Create the uint256 deposit ID by concatenating the msg.sender and depositor address with the inputted\n        // depositNonce parameter. The resultant 32 byte string will be hashed and then casted to an \"unsafe\"\n        // uint256 deposit ID. The probability that the resultant ID collides with a \"safe\" deposit ID is\n        // equal to the chance that the first 28 bytes of the hash are 0, which is too small for us to consider.\n\n        uint256 depositId = getUnsafeDepositId(msg.sender, depositor, depositNonce);\n        DepositV3Params memory params = DepositV3Params({\n            depositor: depositor,\n            recipient: recipient,\n            inputToken: inputToken,\n            outputToken: outputToken,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            destinationChainId: destinationChainId,\n            exclusiveRelayer: exclusiveRelayer,\n            depositId: depositId,\n            quoteTimestamp: quoteTimestamp,\n            fillDeadline: fillDeadline,\n            exclusivityParameter: exclusivityParameter,\n            message: message\n        });\n        _depositV3(params);\n    }\n\n    /**\n     * @notice Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity\n     * deadlines as offsets added to the current time. This function is designed to be called by users\n     * such as Multisig contracts who do not have certainty when their transaction will mine.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline, which is the deadline for the\n     * relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the\n     * destination chain.\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositNow(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable override {\n        deposit(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice A version of `depositNow` that supports addresses as input types for backward compatibility.\n     * This function submits a deposit and sets `quoteTimestamp` to the current time. The `fill` and `exclusivity` deadlines\n     * are set as offsets added to the current time. It is designed to be called by users, including Multisig contracts, who may\n     * not have certainty when their transaction will be mined.\n     *\n     * @dev This version is identical to the original `depositV3Now` but uses `address` types for `depositor`, `recipient`,\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` to support compatibility with older systems.\n     * It maintains the same logic and purpose, ensuring interoperability with both versions.\n     *\n     * @param depositor The account credited with the deposit, who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive the native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\n     * Equivalent tokens on the relayer's repayment chain will be sent as a refund. If this is the wrapped native token,\n     * msg.value must equal inputTokenAmount when passed.\n     * @param outputToken The token the relayer will send to the recipient on the destination chain. Must be an ERC20.\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract.\n     * This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled with the input token as a valid deposit route\n     * from this spoke pool, or the transaction will revert.\n     * @param exclusiveRelayer The relayer exclusively allowed to fill the deposit before the exclusivity deadline.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline. After this timestamp, fills on the\n     * destination chain will revert.\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\n     * @param message The message to send to the recipient on the destination chain. If the recipient is a contract, it must\n     * implement `handleV3AcrossMessage()` if the message is not empty, or the fill will revert.\n     */\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable override {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice Depositor can use this function to signal to relayer to use updated output amount, recipient,\n     * and/or message. The speed up signature uniquely identifies the speed up based only on\n     * depositor, deposit ID and origin chain, so using this function in conjunction with unsafeDeposit is risky\n     * due to the chance of repeating a deposit ID.\n     * @dev the depositor and depositId must match the params in a FundsDeposited event that the depositor\n     * wants to speed up. The relayer has the option but not the obligation to use this updated information\n     * when filling the deposit via fillRelayWithUpdatedDeposit().\n     * @param depositor Depositor that must sign the depositorSignature and was the original depositor.\n     * @param depositId Deposit ID to speed up.\n     * @param updatedOutputAmount New output amount to use for this deposit. Should be lower than previous value\n     * otherwise relayer has no incentive to use this updated value.\n     * @param updatedRecipient New recipient to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param updatedMessage New message to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See\n     * _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\n     */\n    function speedUpDeposit(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant {\n        _verifyUpdateV3DepositMessage(\n            depositor.toAddress(),\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpDeposit(\n            updatedOutputAmount,\n            depositId,\n            depositor,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**\n     * @notice A version of `speedUpDeposit` using `address` types for backward compatibility.\n     * This function allows the depositor to signal to the relayer to use updated output amount, recipient, and/or message\n     * when filling a deposit. This can be useful when the deposit needs to be modified after the original transaction has\n     * been mined.\n     *\n     * @dev The `depositor` and `depositId` must match the parameters in a `FundsDeposited` event that the depositor wants to speed up.\n     * The relayer is not obligated but has the option to use this updated information when filling the deposit using\n     * `fillRelayWithUpdatedDeposit()`. This version uses `address` types for compatibility with systems relying on\n     * `address`-based implementations.\n     *\n     * @param depositor The depositor that must sign the `depositorSignature` and was the original depositor.\n     * @param depositId The deposit ID to speed up.\n     * @param updatedOutputAmount The new output amount to use for this deposit. It should be lower than the previous value,\n     * otherwise the relayer has no incentive to use this updated value.\n     * @param updatedRecipient The new recipient for this deposit. Can be modified if the original recipient is a contract that\n     * expects to receive a message from the relay and needs to be changed.\n     * @param updatedMessage The new message for this deposit. Can be modified if the recipient is a contract that expects\n     * to receive a message from the relay and needs to be updated.\n     * @param depositorSignature The signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account.\n     * If the depositor is a contract, it should implement EIP1271 to sign as a contract. See `_verifyUpdateV3DepositMessage()`\n     * for more details on how the signature should be constructed.\n     */\n    function speedUpV3Deposit(\n        address depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public {\n        _verifyUpdateV3DepositMessage(\n            depositor,\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient.toBytes32(),\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpDeposit(\n            updatedOutputAmount,\n            depositId,\n            depositor.toBytes32(),\n            updatedRecipient.toBytes32(),\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**************************************\n     *         RELAYER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\n     * @dev The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\n     * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and a system fee charged to relayers.\n     * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters passed to deposit() on the origin chain along with that chain's chainId(). This chain's\n     * chainId() must therefore match the destinationChainId passed into deposit.\n     * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\n     * origin SpokePool therefore the relayer should not modify any params in relayData.\n     * @dev Cannot fill more than once. Partial fills are not supported.\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\n     * all the same-named parameters emitted in the origin chain FundsDeposited event.\n     * - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\n     * token on the repayment chain will be sent as a refund to the caller.\n     * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\n     * following an optimistic challenge window in the HubPool.\n     * - outputAmount: The amount of output tokens that the caller will send to the recipient.\n     * - originChainId: The origin chain identifier.\n     * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\n     * the fill will revert on the destination chain.\n     * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\n     * timestamp, anyone can fill this deposit. Note that if this value was set in deposit by adding an offset\n     * to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's\n     * block.timestamp can change. Read the comments in `deposit` about the `exclusivityParameter` for more details.\n     * - message The message to send to the recipient if the recipient is a contract that implements a\n     * handleV3AcrossMessage() public function\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\n     */\n    function fillRelay(\n        V3RelayData memory relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer.toAddress() != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: relayData.outputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: repaymentChainId\n        });\n\n        _fillRelayV3(relayExecution, repaymentAddress, false);\n    }\n\n    // Exposes the same function as fillRelay but with a legacy V3RelayData struct that takes in address types. Inner\n    // function fillV3Relay() applies reentrancy & non-paused checks.\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) public override {\n        // Convert V3RelayDataLegacy to V3RelayData using the .toBytes32() method.\n        V3RelayData memory convertedRelayData = V3RelayData({\n            depositor: relayData.depositor.toBytes32(),\n            recipient: relayData.recipient.toBytes32(),\n            exclusiveRelayer: relayData.exclusiveRelayer.toBytes32(),\n            inputToken: relayData.inputToken.toBytes32(),\n            outputToken: relayData.outputToken.toBytes32(),\n            inputAmount: relayData.inputAmount,\n            outputAmount: relayData.outputAmount,\n            originChainId: relayData.originChainId,\n            depositId: relayData.depositId,\n            fillDeadline: relayData.fillDeadline,\n            exclusivityDeadline: relayData.exclusivityDeadline,\n            message: relayData.message\n        });\n\n        fillRelay(convertedRelayData, repaymentChainId, msg.sender.toBytes32());\n    }\n\n    /**\n     * @notice Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount,\n     * recipient, and/or message. The relayer should only use this function if they can supply a message signed\n     * by the depositor that contains the fill's matching deposit ID along with updated relay parameters.\n     * If the signature can be verified, then this function will emit a FilledV3Event that will be used by\n     * the system for refund verification purposes. In other words, this function is an alternative way to fill a\n     * a deposit than fillV3Relay.\n     * @dev Subject to same exclusivity deadline rules as fillV3Relay().\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. See fillV3Relay().\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\n     * @param updatedOutputAmount New output amount to use for this deposit.\n     * @param updatedRecipient New recipient to use for this deposit.\n     * @param updatedMessage New message to use for this deposit.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account.\n     */\n    function fillRelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer.toAddress() != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: updatedOutputAmount,\n            updatedRecipient: updatedRecipient,\n            updatedMessage: updatedMessage,\n            repaymentChainId: repaymentChainId\n        });\n\n        _verifyUpdateV3DepositMessage(\n            relayData.depositor.toAddress(),\n            relayData.depositId,\n            relayData.originChainId,\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        _fillRelayV3(relayExecution, repaymentAddress, false);\n    }\n\n    /**\n     * @notice Request Across to send LP funds to this contract to fulfill a slow fill relay\n     * for a deposit in the next bundle.\n     * @dev Slow fills are not possible unless the input and output tokens are \"equivalent\", i.e.\n     * they route to the same L1 token via PoolRebalanceRoutes.\n     * @dev Slow fills are created by inserting slow fill objects into a merkle tree that is included\n     * in the next HubPool \"root bundle\". Once the optimistic challenge window has passed, the HubPool\n     * will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed,\n     * the slow fill can be executed by anyone who calls executeSlowRelayLeaf().\n     * @dev Cannot request a slow fill if the fill deadline has passed.\n     * @dev Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\n     * @param relayData struct containing all the data needed to identify the deposit that should be\n     * slow filled. If any of the params are missing or different from the origin chain deposit,\n     * then Across will not include a slow fill for the intended deposit.\n     */\n    function requestSlowFill(V3RelayData calldata relayData) public override nonReentrant unpausedFills {\n        uint32 currentTime = uint32(getCurrentTime());\n        // If a depositor has set an exclusivity deadline, then only the exclusive relayer should be able to\n        // fast fill within this deadline. Moreover, the depositor should expect to get *fast* filled within\n        // this deadline, not slow filled. As a simplifying assumption, we will not allow slow fills to be requested\n        // during this exclusivity period.\n        if (_fillIsExclusive(relayData.exclusivityDeadline, currentTime)) {\n            revert NoSlowFillsInExclusivityWindow();\n        }\n        if (relayData.fillDeadline < currentTime) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = getV3RelayHash(relayData);\n        if (fillStatuses[relayHash] != uint256(FillStatus.Unfilled)) revert InvalidSlowFillRequest();\n        fillStatuses[relayHash] = uint256(FillStatus.RequestedSlowFill);\n\n        emit RequestedSlowFill(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayData.depositor,\n            relayData.recipient,\n            _hashNonEmptyMessage(relayData.message)\n        );\n    }\n\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev ERC-7683 fill function.\n     * @param orderId Unique order identifier for this order\n     * @param originData Data emitted on the origin to parameterize the fill\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external {\n        if (keccak256(abi.encode(originData, chainId())) != orderId) {\n            revert WrongERC7683OrderId();\n        }\n\n        // Ensure that the call is not malformed. If the call is malformed, abi.decode will fail.\n        V3SpokePoolInterface.V3RelayData memory relayData = abi.decode(originData, (V3SpokePoolInterface.V3RelayData));\n        AcrossDestinationFillerData memory destinationFillerData = abi.decode(\n            fillerData,\n            (AcrossDestinationFillerData)\n        );\n\n        // Must do a delegatecall because the function requires the inputs to be calldata.\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(\n                V3SpokePoolInterface.fillRelay,\n                (relayData, destinationFillerData.repaymentChainId, msg.sender.toBytes32())\n            )\n        );\n        if (!success) {\n            revert LowLevelCallFailed(data);\n        }\n    }\n\n    /**************************************\n     *         DATA WORKER FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\n     * @dev Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to\n     * double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed\n     * like any other fill sent through a fill method.\n     * @dev There is no relayer credited with filling this relay since funds are sent directly out of this contract.\n     * @param slowFillLeaf Contains all data necessary to uniquely identify a relay for this chain. This struct is\n     * hashed and included in a merkle root that is relayed to all spoke pools.\n     * - relayData: struct containing all the data needed to identify the original deposit to be slow filled.\n     * - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's\n     * chainId, then this function will revert.\n     * - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently\n     * from relayData.outputAmount to charge a different fee because this deposit was \"slow\" filled. Usually,\n     * this will be set higher to reimburse the recipient for waiting for the slow fill.\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\n     */\n    function executeSlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) public override nonReentrant {\n        V3RelayData memory relayData = slowFillLeaf.relayData;\n\n        _preExecuteLeafHook(relayData.outputToken.toAddress());\n\n        // @TODO In the future consider allowing way for slow fill leaf to be created with updated\n        // deposit params like outputAmount, message and recipient.\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: slowFillLeaf.updatedOutputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: EMPTY_REPAYMENT_CHAIN_ID // Repayment not relevant for slow fills.\n        });\n\n        _verifyV3SlowFill(relayExecution, rootBundleId, proof);\n\n        // - No relayer to refund for slow fill executions.\n        _fillRelayV3(relayExecution, EMPTY_RELAYER, true);\n    }\n\n    /**\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\n     * sent to the recipient plus a relayer fee.\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\n     */\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable virtual override nonReentrant {\n        _preExecuteLeafHook(relayerRefundLeaf.l2TokenAddress);\n\n        if (relayerRefundLeaf.chainId != chainId()) revert InvalidChainId();\n\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Check that proof proves that relayerRefundLeaf is contained within the relayer refund root.\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\n        if (!MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof)) {\n            revert InvalidMerkleProof();\n        }\n\n        _setClaimedLeaf(rootBundleId, relayerRefundLeaf.leafId);\n\n        bool deferredRefunds = _distributeRelayerRefunds(\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.refundAmounts,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses\n        );\n\n        emit ExecutedRelayerRefundRoot(\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.refundAmounts,\n            rootBundleId,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses,\n            deferredRefunds,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Enables a relayer to claim outstanding repayments. Should virtually never be used, unless for some reason\n     * relayer repayment transfer fails for reasons such as token transfer reverts due to blacklisting. In this case,\n     * the relayer can still call this method and claim the tokens to a new address.\n     * @param l2TokenAddress Address of the L2 token to claim refunds for.\n     * @param refundAddress Address to send the refund to.\n     */\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external {\n        uint256 refund = relayerRefund[l2TokenAddress.toAddress()][msg.sender];\n        if (refund == 0) revert NoRelayerRefundToClaim();\n        relayerRefund[l2TokenAddress.toAddress()][msg.sender] = 0;\n        IERC20Upgradeable(l2TokenAddress.toAddress()).safeTransfer(refundAddress.toAddress(), refund);\n\n        emit ClaimedRelayerRefund(l2TokenAddress, refundAddress, refund, msg.sender);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns chain ID for this network.\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\n     */\n    function chainId() public view virtual override returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the deposit ID for an unsafe deposit. This function is used to compute the deposit ID\n     * in unsafeDeposit and is provided as a convenience.\n     * @dev msgSender and depositor are both used as inputs to allow passthrough depositors to create unique\n     * deposit hash spaces for unique depositors.\n     * @param msgSender The caller of the transaction used as input to produce the deposit ID.\n     * @param depositor The depositor address used as input to produce the deposit ID.\n     * @param depositNonce The nonce used as input to produce the deposit ID.\n     * @return The deposit ID for the unsafe deposit.\n     */\n    function getUnsafeDepositId(\n        address msgSender,\n        bytes32 depositor,\n        uint256 depositNonce\n    ) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(msgSender, depositor, depositNonce)));\n    }\n\n    function getRelayerRefund(address l2TokenAddress, address refundAddress) public view returns (uint256) {\n        return relayerRefund[l2TokenAddress][refundAddress];\n    }\n\n    function getV3RelayHash(V3RelayData memory relayData) public view returns (bytes32) {\n        return keccak256(abi.encode(relayData, chainId()));\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    function _depositV3(DepositV3Params memory params) internal {\n        // Verify depositor is a valid EVM address.\n        params.depositor.checkAddress();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits/fills if this is undesirable.\n        // This will underflow if quoteTimestamp is more than depositQuoteTimeBuffer;\n        // this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        uint256 currentTime = getCurrentTime();\n        if (currentTime < params.quoteTimestamp || currentTime - params.quoteTimestamp > depositQuoteTimeBuffer)\n            revert InvalidQuoteTimestamp();\n\n        // fillDeadline is relative to the destination chain.\n        // Dont allow fillDeadline to be more than several bundles into the future.\n        // This limits the maximum required lookback for dataworker and relayer instances.\n        if (params.fillDeadline > currentTime + fillDeadlineBuffer) revert InvalidFillDeadline();\n\n        // There are three cases for setting the exclusivity deadline using the exclusivity parameter:\n        // 1. If this parameter is 0, then there is no exclusivity period and emit 0 for the deadline. This\n        //    means that fillers of this deposit do not have to worry about the block.timestamp of this event changing\n        //    due to re-orgs when filling this deposit.\n        // 2. If the exclusivity parameter is less than or equal to MAX_EXCLUSIVITY_PERIOD_SECONDS, then the exclusivity\n        //    deadline is set to the block.timestamp of this event plus the exclusivity parameter. This means that the\n        //    filler of this deposit assumes re-org risk when filling this deposit because the block.timestamp of this\n        //    event affects the exclusivity deadline.\n        // 3. Otherwise, interpret this parameter as a timestamp and emit it as the exclusivity deadline. This means\n        //    that the filler of this deposit will not assume re-org risk related to the block.timestamp of this\n        //    event changing.\n        uint32 exclusivityDeadline = params.exclusivityParameter;\n        if (exclusivityDeadline > 0) {\n            if (exclusivityDeadline <= MAX_EXCLUSIVITY_PERIOD_SECONDS) {\n                exclusivityDeadline += uint32(currentTime);\n            }\n\n            // As a safety measure, prevent caller from inadvertently locking funds during exclusivity period\n            //  by forcing them to specify an exclusive relayer.\n            if (params.exclusiveRelayer == bytes32(0)) revert InvalidExclusiveRelayer();\n        }\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending the native token. In this case, the native token should be\n        // wrapped.\n        if (params.inputToken == address(wrappedNativeToken).toBytes32() && msg.value > 0) {\n            if (msg.value != params.inputAmount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the caller as per normal.\n            // Note: this includes the case where the L2 caller has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            // msg.value should be 0 if input token isn't the wrapped native token.\n            if (msg.value != 0) revert MsgValueDoesNotMatchInputAmount();\n            IERC20Upgradeable(params.inputToken.toAddress()).safeTransferFrom(\n                msg.sender,\n                address(this),\n                params.inputAmount\n            );\n        }\n\n        emit FundsDeposited(\n            params.inputToken,\n            params.outputToken,\n            params.inputAmount,\n            params.outputAmount,\n            params.destinationChainId,\n            params.depositId,\n            params.quoteTimestamp,\n            params.fillDeadline,\n            exclusivityDeadline,\n            params.depositor,\n            params.recipient,\n            params.exclusiveRelayer,\n            params.message\n        );\n    }\n\n    function _deposit(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message\n    ) internal {\n        // We limit the relay fees to prevent the user spending all their funds on fees.\n        if (SignedMath.abs(relayerFeePct) >= 0.5e18) revert InvalidRelayerFeePct();\n        if (amount > MAX_TRANSFER_SIZE) revert MaxTransferSizeExceeded();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits if this is undesirable. This will underflow if\n        // quoteTimestamp is more than depositQuoteTimeBuffer; this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        if (getCurrentTime() - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\n        uint32 newDepositId = numberOfDeposits++;\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.\n        if (originToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != amount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            IERC20Upgradeable(originToken).safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit FundsDeposited(\n            originToken.toBytes32(), // inputToken\n            bytes32(0), // outputToken. Setting this to 0x0 means that the outputToken should be assumed to be the\n            // canonical token for the destination chain matching the inputToken. Therefore, this deposit\n            // can always be slow filled.\n            // - setting token to 0x0 will signal to off-chain validator that the \"equivalent\"\n            // token as the inputToken for the destination chain should be replaced here.\n            amount, // inputAmount\n            _computeAmountPostFees(amount, relayerFeePct), // outputAmount\n            // - output amount will be the deposit amount less relayerFeePct, which should now be set\n            // equal to realizedLpFeePct + gasFeePct + capitalCostFeePct where (gasFeePct + capitalCostFeePct)\n            // is equal to the old usage of `relayerFeePct`.\n            destinationChainId,\n            newDepositId,\n            quoteTimestamp,\n            INFINITE_FILL_DEADLINE, // fillDeadline. Default to infinite expiry because\n            // expired deposits refunds could be a breaking change for existing users of this function.\n            0, // exclusivityDeadline. Setting this to 0 along with the exclusiveRelayer to 0x0 means that there\n            // is no exclusive deadline\n            depositor.toBytes32(),\n            recipient.toBytes32(),\n            bytes32(0), // exclusiveRelayer. Setting this to 0x0 will signal to off-chain validator that there\n            // is no exclusive relayer.\n            message\n        );\n    }\n\n    function _distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) internal returns (bool deferredRefunds) {\n        uint256 numRefunds = refundAmounts.length;\n        if (refundAddresses.length != numRefunds) revert InvalidMerkleLeaf();\n\n        if (numRefunds > 0) {\n            uint256 spokeStartBalance = IERC20Upgradeable(l2TokenAddress).balanceOf(address(this));\n            uint256 totalRefundedAmount = 0; // Track the total amount refunded.\n\n            // Send each relayer refund address the associated refundAmount for the L2 token address.\n            // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\n            for (uint256 i = 0; i < numRefunds; ++i) {\n                if (refundAmounts[i] > 0) {\n                    totalRefundedAmount += refundAmounts[i];\n\n                    // Only if the total refunded amount exceeds the spoke starting balance, should we revert. This\n                    // ensures that bundles are atomic, if we have sufficient balance to refund all relayers and\n                    // prevents can only re-pay some of the relayers.\n                    if (totalRefundedAmount > spokeStartBalance) revert InsufficientSpokePoolBalanceToExecuteLeaf();\n\n                    bool success = _noRevertTransfer(l2TokenAddress, refundAddresses[i], refundAmounts[i]);\n\n                    // If the transfer failed then track a deferred transfer for the relayer. Given this function would\n                    // have reverted if there was insufficient balance, this will only happen if the transfer call\n                    // reverts. This will only occur if the underlying transfer method on the l2Token reverts due to\n                    // recipient blacklisting or other related modifications to the l2Token.transfer method.\n                    if (!success) {\n                        relayerRefund[l2TokenAddress][refundAddresses[i]] += refundAmounts[i];\n                        deferredRefunds = true;\n                    }\n                }\n            }\n        }\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\n        // chain-specific bridging method.\n        if (amountToReturn > 0) {\n            _bridgeTokensToHubPool(amountToReturn, l2TokenAddress);\n\n            emit TokensBridged(amountToReturn, _chainId, leafId, l2TokenAddress.toBytes32(), msg.sender);\n        }\n    }\n\n    // Re-implementation of OZ _callOptionalReturnBool to use private logic. Function executes a transfer and returns a\n    // bool indicating if the external call was successful, rather than reverting. Original method:\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/28aed34dc5e025e61ea0390c18cac875bfde1a78/contracts/token/ERC20/utils/SafeERC20.sol#L188\n    function _noRevertTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        bytes memory data = abi.encodeCall(IERC20Upgradeable.transfer, (to, amount));\n        assembly {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\n        if (newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = newCrossDomainAdmin;\n        emit SetXDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function _setWithdrawalRecipient(address newWithdrawalRecipient) internal {\n        if (newWithdrawalRecipient == address(0)) revert InvalidWithdrawalRecipient();\n        withdrawalRecipient = newWithdrawalRecipient;\n        emit SetWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    function _preExecuteLeafHook(address) internal virtual {\n        // This method by default is a no-op. Different child spoke pools might want to execute functionality here\n        // such as wrapping any native tokens owned by the contract into wrapped tokens before proceeding with\n        // executing the leaf.\n    }\n\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual;\n\n    function _setClaimedLeaf(uint32 rootBundleId, uint32 leafId) internal {\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Verify the leafId in the leaf has not yet been claimed.\n        if (MerkleLib.isClaimed(rootBundle.claimedBitmap, leafId)) revert ClaimedMerkleLeaf();\n\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, leafId);\n    }\n\n    function _verifyUpdateV3DepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature,\n        bytes32 hashType\n    ) internal view {\n        // A depositor can request to modify an un-relayed deposit by signing a hash containing the updated\n        // details and information uniquely identifying the deposit to relay. This information ensures\n        // that this signature cannot be re-used for other deposits.\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    hashType,\n                    depositId,\n                    originChainId,\n                    updatedOutputAmount,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\n    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting\n    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the\n    // potential to forge a signature from the depositor using a different private key than the original depositor's.\n    function _verifyDepositorSignature(\n        address depositor,\n        bytes32 ethSignedMessageHash,\n        bytes memory depositorSignature\n    ) internal view virtual {\n        // Note:\n        // - We don't need to worry about re-entrancy from a contract deployed at the depositor address since the method\n        //   `SignatureChecker.isValidSignatureNow` is a view method. Re-entrancy can happen, but it cannot affect state.\n        // - EIP-1271 signatures are supported. This means that a signature valid now, may not be valid later and vice-versa.\n        // - For an EIP-1271 signature to work, the depositor contract address must map to a deployed contract on the destination\n        //   chain that can validate the signature.\n        // - Regular signatures from an EOA are also supported.\n        bool isValid = SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature);\n        if (!isValid) revert InvalidDepositorSignature();\n    }\n\n    function _verifyV3SlowFill(\n        V3RelayExecutionParams memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        V3SlowFill memory slowFill = V3SlowFill({\n            relayData: relayExecution.relay,\n            chainId: chainId(),\n            updatedOutputAmount: relayExecution.updatedOutputAmount\n        });\n\n        if (!MerkleLib.verifyV3SlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof)) {\n            revert InvalidMerkleProof();\n        }\n    }\n\n    function _computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.\n    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {\n        if (address(to).isContract()) {\n            IERC20Upgradeable(address(wrappedNativeToken)).safeTransfer(to, amount);\n        } else {\n            wrappedNativeToken.withdraw(amount);\n            AddressLibUpgradeable.sendValue(to, amount);\n        }\n    }\n\n    // @param relayer: relayer who is actually credited as filling this deposit. Can be different from\n    // exclusiveRelayer if passed exclusivityDeadline or if slow fill.\n    function _fillRelayV3(\n        V3RelayExecutionParams memory relayExecution,\n        bytes32 relayer,\n        bool isSlowFill\n    ) internal {\n        V3RelayData memory relayData = relayExecution.relay;\n\n        if (relayData.fillDeadline < getCurrentTime()) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = relayExecution.relayHash;\n\n        // If a slow fill for this fill was requested then the relayFills value for this hash will be\n        // FillStatus.RequestedSlowFill. Therefore, if this is the status, then this fast fill\n        // will be replacing the slow fill. If this is a slow fill execution, then the following variable\n        // is trivially true. We'll emit this value in the FilledRelay\n        // event to assist the Dataworker in knowing when to return funds back to the HubPool that can no longer\n        // be used for a slow fill execution.\n        FillType fillType = isSlowFill\n            ? FillType.SlowFill // The following is true if this is a fast fill that was sent after a slow fill request.\n            : (\n                fillStatuses[relayExecution.relayHash] == uint256(FillStatus.RequestedSlowFill)\n                    ? FillType.ReplacedSlowFill\n                    : FillType.FastFill\n            );\n\n        // @dev This function doesn't support partial fills. Therefore, we associate the relay hash with\n        // an enum tracking its fill status. All filled relays, whether slow or fast fills, are set to the Filled\n        // status. However, we also use this slot to track whether this fill had a slow fill requested. Therefore\n        // we can include a bool in the FilledRelay event making it easy for the dataworker to compute if this\n        // fill was a fast fill that replaced a slow fill and therefore this SpokePool has excess funds that it\n        // needs to send back to the HubPool.\n        if (fillStatuses[relayHash] == uint256(FillStatus.Filled)) revert RelayFilled();\n        fillStatuses[relayHash] = uint256(FillStatus.Filled);\n\n        // @dev Before returning early, emit events to assist the dataworker in being able to know which fills were\n        // successful.\n        emit FilledRelay(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayExecution.repaymentChainId,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayer,\n            relayData.depositor,\n            relayData.recipient,\n            _hashNonEmptyMessage(relayData.message),\n            V3RelayExecutionEventInfo({\n                updatedRecipient: relayExecution.updatedRecipient,\n                updatedMessageHash: _hashNonEmptyMessage(relayExecution.updatedMessage),\n                updatedOutputAmount: relayExecution.updatedOutputAmount,\n                fillType: fillType\n            })\n        );\n\n        address outputToken = relayData.outputToken.toAddress();\n        uint256 amountToSend = relayExecution.updatedOutputAmount;\n        address recipientToSend = relayExecution.updatedRecipient.toAddress();\n        // If relay token is wrappedNativeToken then unwrap and send native token.\n        // Stack too deep.\n        if (relayData.outputToken.toAddress() == address(wrappedNativeToken)) {\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\n            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the\n            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll\n            // need to unwrap it to native token before sending to the user.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, address(this), amountToSend);\n            _unwrapwrappedNativeTokenTo(payable(recipientToSend), amountToSend);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else {\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, recipientToSend, amountToSend);\n            else IERC20Upgradeable(outputToken).safeTransfer(recipientToSend, amountToSend);\n        }\n\n        bytes memory updatedMessage = relayExecution.updatedMessage;\n        if (updatedMessage.length > 0 && recipientToSend.isContract()) {\n            AcrossMessageHandler(recipientToSend).handleV3AcrossMessage(\n                outputToken,\n                amountToSend,\n                msg.sender,\n                updatedMessage\n            );\n        }\n    }\n\n    // Determine whether the exclusivityDeadline implies active exclusivity.\n    function _fillIsExclusive(uint32 exclusivityDeadline, uint32 currentTime) internal pure returns (bool) {\n        return exclusivityDeadline >= currentTime;\n    }\n\n    // Helper for emitting message hash. For easier easier human readability we return bytes32(0) for empty message.\n    function _hashNonEmptyMessage(bytes memory message) internal pure returns (bytes32) {\n        if (message.length == 0) return bytes32(0);\n        else return keccak256(message);\n    }\n\n    function _setOftMessenger(address _token, address _messenger) internal {\n        if (IOFT(_messenger).token() != _token) {\n            revert OFTTokenMismatch();\n        }\n        oftMessengers[_token] = _messenger;\n        emit SetOFTMessenger(_token, _messenger);\n    }\n\n    function _getOftMessenger(address _token) internal view returns (address) {\n        return oftMessengers[_token];\n    }\n\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\n    // L1, this would just be the same admin of the HubPool.\n    function _requireAdminSender() internal virtual;\n\n    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.\n    receive() external payable {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[997] private __gap;\n}\n"
    }
}