{
    "vfp_id": "vfp_00350",
    "project_name": "2025-04-reserve-folio-solidity-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "GovernanceDeployer does not enforce minimum values for timelock contract",
            "description": "The GovernanceDeployer contract does not enforce minimum values for the governance executor timelock contract, which is a critical component for preventing malicious governance proposals. The lack of enforced minimums allows potentially unsafe configurations where the timelock delay could be set too low, reducing the window for guardians to detect and cancel malicious proposals. An attacker could exploit this by creating a Folio with a very short timelock, accelerating the execution of a malicious governance action. This could lead to insufficient response time for guardians, increasing the risk of fund loss or protocol manipulation. This issue arises because the GovernanceDeployer contract does not enforce minimum values for parameters such as minimum delay or grace period, undermining the security purpose of the timelock mechanism. An attacker with governance control could potentially expedite malicious proposals by reducing the timelock duration. The impact includes reduced resilience against malicious governance actions and increased risk of rapid, unchallenged execution of harmful changes.\n",
            "severity": "Informational",
            "location": [
                "contracts/deployer/GovernanceDeployer.sol",
                "GovernanceDeployer"
            ],
            "files": [
                "reserve-index-dtf/contracts/deployer/GovernanceDeployer.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "Fully on-chain governance creates existential governance attack risks",
            "description": "Folios created via deployGovernedFolio are owned by a timelock-governed contract, giving complete control over the Folio, including the ability to upgrade and potentially steal funds. This creates an existential risk where an attacker could accumulate governance tokens, pass a malicious proposal, and upgrade the contract if not canceled by the guardian. The only defense is the guardian role, which lacks documented automation or availability guarantees. If guardians are offline or the project is abandoned, users have no protection. This undermines the security model and exposes users to total loss of funds in the event of a successful governance attack. The system relies entirely on on-chain governance, which exposes it to potential attacks such as vote manipulation, sybil attacks, or governance takeovers via token accumulation. Without off-chain checks or timelock safeguards, critical system parameters can be changed rapidly if an attacker gains token majority. The cause is the design choice to centralize all governance decisions on-chain without additional risk mitigation layers. This could allow an attacker to reconfigure core protocol functions, leading to potential loss of funds or protocol shutdown.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "reserve-index-dtf/contracts/deployer/GovernanceDeployer.sol",
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Users do not receive shares for low mint requests",
            "description": "The Folio.mint() function rounds down the number of shares minted, causing deposits of very low amounts (e.g., 1 wei) to result in zero shares. While the collateral is transferred to the contract, no shares are minted in return, effectively causing the user to lose their funds. This is due to integer division truncation in the share calculation logic. An attacker could exploit this by encouraging users to make small deposits, leading to irreversible loss. The impact is limited to small amounts per transaction but could affect many users and erode trust in the protocol's fairness. The root cause is the absence of a check to revert or enforce a minimum share amount when minting. An attacker could exploit this by probing the system with small deposits to understand rounding behavior, though the direct impact is primarily user experience and fairness. This issue has been resolved by reverting mint calls that would result in zero shares.\n",
            "severity": "Informational",
            "location": [
                "contracts/Folio.sol#314-321",
                "Folio contract::mint"
            ],
            "files": [
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Missing slippage protection on the Folio contract’s mint function",
            "description": "The mint function lacks slippage protection, meaning users cannot specify a minimum number of shares they expect to receive. The amount of shares minted depends on dynamic fees (totalFeeShares), which can change between transaction submission and execution. If fees increase just before minting, users receive fewer shares than expected. This creates a front-running risk where an attacker can manipulate fees or exploit timing to cause user losses. The impact includes financial loss for users and reduced confidence in the predictability of minting operations. The cause is the absence of a minSharesOut parameter or similar safeguard. An attacker could exploit this by sandwiching transactions to extract value. This issue has been resolved by adding a minSharesOut parameter.\n",
            "severity": "Medium",
            "location": [
                "contracts/Folio.sol#326",
                "Folio contract::mint"
            ],
            "files": [
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Denial of service vulnerability via configurable initial supply",
            "description": "The Folio contract is vulnerable to a denial-of-service attack due to an overflow in the _getPendingFeeShares calculation. If the initial supply is set too high (close to 2^256), arithmetic operations will overflow, causing all contract functions to revert. A malicious actor can exploit this by minting a large number of shares, freezing the Folio and preventing users from redeeming or interacting with their funds. This could be combined with a governance attack to maximize damage. The impact is a complete loss of functionality for the affected Folio, leading to user fund lockup. The root cause is the lack of validation on the initial supply parameter during contract initialization. An attacker could exploit this during deployment to disrupt token operations or cause miscalculations in share pricing. This has been resolved by using a factory contract to enforce valid supply ranges.\n",
            "severity": "Medium",
            "location": [
                "contracts/Folio.sol"
            ],
            "files": [
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "ERC-777 compatibility issue",
            "description": "The Folio contract does not support ERC-777 tokens because it is not registered in the ERC-1820 registry as an ERC777TokensRecipient, causing transfers from ERC-777 tokens to revert. Additionally, the contract does not handle token granularity, meaning transfers of amounts not divisible by the token's granularity will fail. This creates a denial-of-service risk when interacting with ERC-777 tokens. Users or the protocol may be unable to deposit or manage such tokens, limiting interoperability and potentially disrupting operations. The lack of support contradicts documentation claiming ERC-777 compatibility. The root cause is the integration of a token standard that allows arbitrary code execution during transfers. An attacker could exploit this by crafting a malicious ERC-777 token that calls back into the protocol during a transfer, manipulating state or extracting funds. The impact includes potential reentrancy and logic flaws. This has been resolved by disallowing ERC-777 tokens as collateral.\n",
            "severity": "Medium",
            "location": [
                "contracts/Folio.sol"
            ],
            "files": [
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Folio.bid() is vulnerable to denial of service through 1 wei donation attack",
            "description": "The bid() function reverts if the contract's buy token balance exceeds maxBuyBal. An attacker can front-run a bid that would exactly match maxBuyBal by donating 1 wei, causing the user's transaction to revert. The user must then rebid with a lower amount, potentially losing the auction or being outbid. This denial-of-service attack exploits a race condition in balance validation. The impact includes disrupted auction participation, financial loss from missed opportunities, and potential manipulation of auction outcomes by malicious actors. The root cause is the reliance on the contract's balance being zero or within a known range for correct operation. An attacker could exploit this by sending a minimal amount of ETH to block legitimate bids. The risk has been accepted by the team, citing low MEV incentive.\n",
            "severity": "Medium",
            "location": [
                "contracts/Folio.sol#650",
                "Folio.bid()"
            ],
            "files": [
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Wei loss occurs when transferring stETH rebasing tokens",
            "description": "Due to stETH's rebasing behavior and a known 1–2 wei rounding issue, transfers involving stETH result in a slight loss of wei because balance calculations round down. This behavior is similar to fee-on-transfer tokens. While the impact per transfer is minimal, repeated transfers accumulate small losses. The root cause is the use of integer math without accounting for rounding discrepancies. Users experience a minor but irreversible loss of funds during transfers. This affects user trust and highlights integration risks with rebasing tokens, especially when precision is critical. When transferring stETH (a rebasing token), precision loss can occur due to rounding errors in share calculations, resulting in a small amount of wei being lost or not accounted for. The root cause is the mismatch between the rebasing mechanics of stETH and the fixed-point arithmetic used in the protocol. An attacker could potentially amplify this over many transactions, though the per-transaction loss is minimal. The impact is minor financial loss due to rounding errors during transfers of rebasing tokens. The risk has been accepted.\n",
            "severity": "Informational",
            "location": [
                "contracts/Folio.sol",
                "stETH transfer handling"
            ],
            "files": [
                "reserve-index-dtf/contracts/Folio.sol"
            ]
        }
    ],
    "affected_files": {
        "Folio.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { UD60x18, powu, pow } from \"@prb/math/src/UD60x18.sol\";\nimport { SD59x18, exp, intoUint256 } from \"@prb/math/src/SD59x18.sol\";\n\nimport { Versioned } from \"@utils/Versioned.sol\";\n\nimport { IFolioDAOFeeRegistry } from \"@interfaces/IFolioDAOFeeRegistry.sol\";\nimport { IFolio } from \"@interfaces/IFolio.sol\";\n\n/// Optional bidder interface for callback\ninterface IBidderCallee {\n    /// @param buyAmount {qBuyTok}\n    function bidCallback(address buyToken, uint256 buyAmount, bytes calldata data) external;\n}\n\nuint256 constant MAX_TVL_FEE = 0.1e18; // D18{1/year} 10% annually\nuint256 constant MAX_MINT_FEE = 0.05e18; // D18{1} 5%\nuint256 constant MIN_AUCTION_LENGTH = 60; // {s} 1 min\nuint256 constant MAX_AUCTION_LENGTH = 604800; // {s} 1 week\nuint256 constant MAX_AUCTION_DELAY = 604800; // {s} 1 week\nuint256 constant MAX_FEE_RECIPIENTS = 64;\nuint256 constant MAX_TTL = 604800 * 4; // {s} 4 weeks\nuint256 constant MAX_RATE = 1e54; // D18{buyTok/sellTok}\nuint256 constant MAX_PRICE_RANGE = 1e9; // {1}\n\nUD60x18 constant ANNUALIZER = UD60x18.wrap(31709791983); // D18{1/s} 1e18 / 31536000\n\nuint256 constant D18 = 1e18; // D18\nuint256 constant D27 = 1e27; // D27\n\n/**\n * @title Folio\n * @author akshatmittal, julianmrodri, pmckelvy1, tbrent\n * @notice Folio is a backed ERC20 token with permissionless minting/redemption and rebalancing via dutch auction\n *\n * There are 3 main roles:\n *   1. DEFAULT_ADMIN_ROLE: can add/remove erc20 assets, set fees, auction length, auction delay, and close auctions\n *   2. AUCTION_APPROVER: can approve auctions\n *   3. AUCTION_LAUNCHER: can open auctions, optionally providing some amount of additional detail\n *\n * Permissionless execution is available after a delay if the AUCTION_LAUNCHER is not online or the Folio is configured\n * without an AUCTION_LAUNCHER.\n *\n * Auction lifecycle:\n *   approveAuction() -> openAuction() -> bid() -> [optional] closeAuction()\n *\n * Auctions will attempt to close themselves once the sell token's balance reaches the sellLimit. However, they can\n * also be closed by *any* of the 3 roles, if it is discovered one of the exchange rates has been set incorrectly.\n *\n * A Folio is backed by aa flexible number of ERC20 tokens of any denomination/price (within assumed ranges, see README)\n * All tokens tracked by the Folio are required to issue/redeem. This forms the basket.\n *\n * Rebalancing targets are defined in terms of basket ratios: ratio of token to the Folio share, units D27{tok/share}.\n *\n * Fees:\n *   - TVL fee: fee per unit time\n *   - Mint fee: fee on mint\n *\n * After both fees have been applied, the DAO takes a cut based on the configuration of the FolioDAOFeeRegistry.\n * The remaining portion is distributed to the Folio's fee recipients.\n */\ncontract Folio is\n    IFolio,\n    Initializable,\n    ERC20Upgradeable,\n    AccessControlEnumerableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Versioned\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    IFolioDAOFeeRegistry public daoFeeRegistry;\n\n    /**\n     * Roles\n     */\n    bytes32 public constant AUCTION_APPROVER = keccak256(\"AUCTION_APPROVER\"); // expected to be trading governance's timelock\n    bytes32 public constant AUCTION_LAUNCHER = keccak256(\"AUCTION_LAUNCHER\"); // optional: EOA or multisig\n    bytes32 public constant BRAND_MANAGER = keccak256(\"BRAND_MANAGER\"); // optional: no permissions\n\n    /**\n     * Mandate\n     */\n    string public mandate; // mutable field that describes mission/brand of the Folio\n\n    /**\n     * Basket\n     */\n    EnumerableSet.AddressSet private basket;\n\n    /**\n     * Fees\n     */\n    FeeRecipient[] public feeRecipients;\n    uint256 public tvlFee; // D18{1/s} demurrage fee on AUM\n    uint256 public mintFee; // D18{1} fee on mint\n\n    /**\n     * System\n     */\n    uint256 public lastPoke; // {s}\n    uint256 public daoPendingFeeShares; // {share} shares pending to be distributed ONLY to the DAO\n    uint256 public feeRecipientsPendingFeeShares; // {share} shares pending to be distributed ONLY to fee recipients\n    bool public isKilled; // {bool} If true, Folio goes into redemption-only mode\n\n    /**\n     * Rebalancing\n     *   APPROVED -> OPEN -> CLOSED\n     *   - Approved auctions have a delay before they can be opened, that AUCTION_LAUNCHER can bypass\n     *   - Multiple auctions can be open at once, though a token cannot be bought and sold simultaneously\n     *   - Multiple bids can be executed against the same auction\n     *   - All auctions are dutch auctions with the same price curve, but it's possible to pass startPrice = endPrice\n     */\n    Auction[] public auctions;\n    mapping(address => uint256) public sellEnds; // {s} timestamp of latest ongoing auction for sells\n    mapping(address => uint256) public buyEnds; // {s} timestamp of latest ongoing auction for buys\n    uint256 public auctionDelay; // {s} delay in the APPROVED state before an auction can be permissionlessly opened\n    uint256 public auctionLength; // {s} length of an auction\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        FolioBasicDetails calldata _basicDetails,\n        FolioAdditionalDetails calldata _additionalDetails,\n        address _creator,\n        address _daoFeeRegistry\n    ) external initializer {\n        __ERC20_init(_basicDetails.name, _basicDetails.symbol);\n        __AccessControlEnumerable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setFeeRecipients(_additionalDetails.feeRecipients);\n        _setTVLFee(_additionalDetails.tvlFee);\n        _setMintFee(_additionalDetails.mintFee);\n        _setAuctionDelay(_additionalDetails.auctionDelay);\n        _setAuctionLength(_additionalDetails.auctionLength);\n        _setMandate(_additionalDetails.mandate);\n\n        daoFeeRegistry = IFolioDAOFeeRegistry(_daoFeeRegistry);\n\n        require(_basicDetails.initialShares != 0, Folio__ZeroInitialShares());\n\n        uint256 assetLength = _basicDetails.assets.length;\n        require(assetLength != 0, Folio__EmptyAssets());\n\n        for (uint256 i; i < assetLength; i++) {\n            require(_basicDetails.assets[i] != address(0), Folio__InvalidAsset());\n\n            uint256 assetBalance = IERC20(_basicDetails.assets[i]).balanceOf(address(this));\n            require(assetBalance != 0, Folio__InvalidAssetAmount(_basicDetails.assets[i]));\n\n            _addToBasket(_basicDetails.assets[i]);\n        }\n\n        lastPoke = block.timestamp;\n        _mint(_creator, _basicDetails.initialShares);\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev Testing function, no production use\n    function poke() external nonReentrant {\n        _poke();\n    }\n\n    // ==== Governance ====\n\n    /// Escape hatch function to be used when tokens get acquired not through an auction but\n    /// through any other means and should become part of the Folio.\n    /// @dev Does not require a token balance\n    /// @param token The token to add to the basket\n    function addToBasket(IERC20 token) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_addToBasket(address(token)), Folio__BasketModificationFailed());\n    }\n\n    /// @dev Enables removal of tokens with nonzero balance\n    function removeFromBasket(IERC20 token) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_removeFromBasket(address(token)), Folio__BasketModificationFailed());\n    }\n\n    /// An annual tvl fee below the DAO fee floor will result in the entirety of the fee being sent to the DAO\n    /// @dev Non-reentrant via distributeFees()\n    /// @param _newFee D18{1/s} Fee per second on AUM\n    function setTVLFee(uint256 _newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setTVLFee(_newFee);\n    }\n\n    /// A minting fee below the DAO fee floor will result in the entirety of the fee being sent to the DAO\n    /// @dev Non-reentrant via distributeFees()\n    /// @param _newFee D18{1} Fee on mint\n    function setMintFee(uint256 _newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setMintFee(_newFee);\n    }\n\n    /// @dev Non-reentrant via distributeFees()\n    /// @dev Fee recipients must be unique and sorted by address, and sum to 1e18\n    function setFeeRecipients(FeeRecipient[] memory _newRecipients) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributeFees();\n\n        _setFeeRecipients(_newRecipients);\n    }\n\n    /// @param _newDelay {s} Delay after a auction has been approved before it can be permissionlessly opened\n    function setAuctionDelay(uint256 _newDelay) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setAuctionDelay(_newDelay);\n    }\n\n    /// @param _newLength {s} Length of an auction\n    function setAuctionLength(uint256 _newLength) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setAuctionLength(_newLength);\n    }\n\n    function setMandate(string calldata _newMandate) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setMandate(_newMandate);\n    }\n\n    /// Kill the Folio, callable only by the admin\n    /// @dev Folio cannot be issued and auctions cannot be approved, opened, or bid on\n    function killFolio() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isKilled = true;\n\n        emit FolioKilled();\n    }\n\n    // ==== Share + Asset Accounting ====\n\n    /// @dev Contains all pending fee shares\n    function totalSupply() public view virtual override(ERC20Upgradeable) returns (uint256) {\n        (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares) = _getPendingFeeShares();\n        return super.totalSupply() + _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n    }\n\n    /// @return _assets\n    /// @return _amounts {tok}\n    function folio() external view returns (address[] memory _assets, uint256[] memory _amounts) {\n        return toAssets(10 ** decimals(), Math.Rounding.Floor);\n    }\n\n    /// @return _assets\n    /// @return _amounts {tok}\n    function totalAssets() external view returns (address[] memory _assets, uint256[] memory _amounts) {\n        _assets = basket.values();\n\n        uint256 assetLength = _assets.length;\n        _amounts = new uint256[](assetLength);\n        for (uint256 i; i < assetLength; i++) {\n            _amounts[i] = IERC20(_assets[i]).balanceOf(address(this));\n        }\n    }\n\n    /// @param shares {share}\n    /// @return _assets\n    /// @return _amounts {tok}\n    function toAssets(\n        uint256 shares,\n        Math.Rounding rounding\n    ) public view returns (address[] memory _assets, uint256[] memory _amounts) {\n        require(!_reentrancyGuardEntered(), ReentrancyGuardReentrantCall());\n\n        return _toAssets(shares, rounding);\n    }\n\n    /// @param shares {share} Amount of shares to redeem\n    /// @return _assets\n    /// @return _amounts {tok}\n    /// @dev Use allowances to set slippage limits\n    /// @dev Minting has 3 share-portions: (i) receiver shares, (ii) DAO fee shares, (iii) fee recipients shares\n    function mint(\n        uint256 shares,\n        address receiver\n    ) external nonReentrant returns (address[] memory _assets, uint256[] memory _amounts) {\n        require(!isKilled, Folio__FolioKilled());\n\n        _poke();\n\n        // === Calculate fee shares ===\n\n        (, uint256 daoFeeNumerator, uint256 daoFeeDenominator, uint256 daoFeeFloor) = daoFeeRegistry.getFeeDetails(\n            address(this)\n        );\n\n        // {share} = {share} * D18{1} / D18\n        uint256 totalFeeShares = (shares * mintFee + D18 - 1) / D18;\n        uint256 daoFeeShares = (totalFeeShares * daoFeeNumerator + daoFeeDenominator - 1) / daoFeeDenominator;\n\n        // ensure DAO's portion of fees is at least the DAO feeFloor\n        uint256 minDaoShares = (shares * daoFeeFloor + D18 - 1) / D18;\n        daoFeeShares = daoFeeShares < minDaoShares ? minDaoShares : daoFeeShares;\n\n        // 100% to DAO, if necessary\n        totalFeeShares = totalFeeShares < daoFeeShares ? daoFeeShares : totalFeeShares;\n\n        // === Transfer assets in ===\n\n        (_assets, _amounts) = _toAssets(shares, Math.Rounding.Ceil);\n\n        uint256 assetLength = _assets.length;\n        for (uint256 i; i < assetLength; i++) {\n            if (_amounts[i] != 0) {\n                SafeERC20.safeTransferFrom(IERC20(_assets[i]), msg.sender, address(this), _amounts[i]);\n            }\n        }\n\n        // === Mint shares ===\n\n        _mint(receiver, shares - totalFeeShares);\n\n        // defer fee handouts until distributeFees()\n        daoPendingFeeShares += daoFeeShares;\n        feeRecipientsPendingFeeShares += totalFeeShares - daoFeeShares;\n    }\n\n    /// @param shares {share} Amount of shares to redeem\n    /// @param assets Assets to receive, must match basket exactly\n    /// @param minAmountsOut {tok} Minimum amounts of each asset to receive\n    /// @return _amounts {tok} Actual amounts transferred of each asset\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address[] calldata assets,\n        uint256[] calldata minAmountsOut\n    ) external nonReentrant returns (uint256[] memory _amounts) {\n        _poke();\n\n        address[] memory _assets;\n        (_assets, _amounts) = _toAssets(shares, Math.Rounding.Floor);\n\n        // === Burn shares ===\n\n        _burn(msg.sender, shares);\n\n        // === Transfer assets out ===\n\n        uint256 len = _assets.length;\n        require(len == assets.length && len == minAmountsOut.length, Folio__InvalidArrayLengths());\n\n        for (uint256 i; i < len; i++) {\n            require(_assets[i] == assets[i], Folio__InvalidAsset());\n            require(_amounts[i] >= minAmountsOut[i], Folio__InvalidAssetAmount(_assets[i]));\n\n            if (_amounts[i] != 0) {\n                SafeERC20.safeTransfer(IERC20(_assets[i]), receiver, _amounts[i]);\n            }\n        }\n    }\n\n    // ==== Fee Shares ====\n\n    /// @return {share} Up-to-date sum of DAO and fee recipients pending fee shares\n    function getPendingFeeShares() public view returns (uint256) {\n        (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares) = _getPendingFeeShares();\n        return _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n    }\n\n    /// Distribute all pending fee shares\n    /// @dev Recipients: DAO and fee recipients\n    /// @dev Pending fee shares are already reflected in the total supply, this function only concretizes balances\n    function distributeFees() public nonReentrant {\n        _poke();\n        // daoPendingFeeShares and feeRecipientsPendingFeeShares are up-to-date\n\n        // === Fee recipients ===\n\n        uint256 _feeRecipientsPendingFeeShares = feeRecipientsPendingFeeShares;\n        feeRecipientsPendingFeeShares = 0;\n        uint256 feeRecipientsTotal;\n\n        uint256 len = feeRecipients.length;\n        for (uint256 i; i < len; i++) {\n            // {share} = {share} * D18{1} / D18\n            uint256 shares = (_feeRecipientsPendingFeeShares * feeRecipients[i].portion) / D18;\n            feeRecipientsTotal += shares;\n\n            _mint(feeRecipients[i].recipient, shares);\n\n            emit FolioFeePaid(feeRecipients[i].recipient, shares);\n        }\n\n        // === DAO ===\n\n        // {share}\n        uint256 daoShares = daoPendingFeeShares + _feeRecipientsPendingFeeShares - feeRecipientsTotal;\n\n        (address daoRecipient, , , ) = daoFeeRegistry.getFeeDetails(address(this));\n        _mint(daoRecipient, daoShares);\n        emit ProtocolFeePaid(daoRecipient, daoShares);\n\n        daoPendingFeeShares = 0;\n    }\n\n    // ==== Rebalancing ====\n\n    function nextAuctionId() external view returns (uint256) {\n        return auctions.length;\n    }\n\n    /// The amount on sale in an auction\n    /// @dev Can be bid on in chunks\n    /// @dev Fluctuates changes over time as price changes (can go up or down)\n    /// @return sellAmount {sellTok} The amount of sell token on sale in the auction at a given timestamp\n    function lot(uint256 auctionId, uint256 timestamp) external view returns (uint256 sellAmount) {\n        Auction storage auction = auctions[auctionId];\n\n        uint256 _totalSupply = totalSupply();\n        uint256 sellBal = auction.sell.balanceOf(address(this));\n        uint256 buyBal = auction.buy.balanceOf(address(this));\n\n        // {sellTok} = D27{sellTok/share} * {share} / D27\n        uint256 minSellBal = Math.mulDiv(auction.sellLimit.spot, _totalSupply, D27, Math.Rounding.Ceil);\n        uint256 sellAvailable = sellBal > minSellBal ? sellBal - minSellBal : 0;\n\n        // {buyTok} = D27{buyTok/share} * {share} / D27\n        uint256 maxBuyBal = Math.mulDiv(auction.buyLimit.spot, _totalSupply, D27, Math.Rounding.Floor);\n        uint256 buyAvailable = buyBal < maxBuyBal ? maxBuyBal - buyBal : 0;\n\n        // avoid overflow\n        if (buyAvailable > MAX_RATE) {\n            return sellAvailable;\n        }\n\n        // D27{buyTok/sellTok}\n        uint256 price = _price(auction, timestamp);\n\n        // {sellTok} = {buyTok} * D27 / D27{buyTok/sellTok}\n        uint256 sellAvailableFromBuy = Math.mulDiv(buyAvailable, D27, price, Math.Rounding.Floor);\n        sellAmount = Math.min(sellAvailable, sellAvailableFromBuy);\n    }\n\n    /// @return D27{buyTok/sellTok} The price at the given timestamp as an 27-decimal fixed point\n    function getPrice(uint256 auctionId, uint256 timestamp) external view returns (uint256) {\n        return _price(auctions[auctionId], timestamp);\n    }\n\n    /// Get the bid amount required to purchase the sell amount\n    /// @param sellAmount {sellTok} The amount of sell tokens the bidder is offering the protocol\n    /// @return bidAmount {buyTok} The amount of buy tokens required to bid in the auction at a given timestamp\n    function getBid(\n        uint256 auctionId,\n        uint256 timestamp,\n        uint256 sellAmount\n    ) external view returns (uint256 bidAmount) {\n        uint256 price = _price(auctions[auctionId], timestamp);\n\n        // {buyTok} = {sellTok} * D27{buyTok/sellTok} / D27\n        bidAmount = Math.mulDiv(sellAmount, price, D27, Math.Rounding.Ceil);\n    }\n\n    /// Approve an auction to run\n    /// @param sell The token to sell, from the perspective of the Folio\n    /// @param buy The token to buy, from the perspective of the Folio\n    /// @param sellLimit D27{sellTok/share} min ratio of sell token to shares allowed, inclusive, 1e54 max\n    /// @param buyLimit D27{buyTok/share} max balance-ratio to shares allowed, exclusive, 1e54 max\n    /// @param prices D27{buyTok/sellTok} Price range\n    /// @param ttl {s} How long a auction can exist in an APPROVED state until it can no longer be OPENED\n    ///     (once opened, it always finishes).\n    ///     Must be longer than auctionDelay if intended to be permissionlessly available.\n    function approveAuction(\n        IERC20 sell,\n        IERC20 buy,\n        BasketRange calldata sellLimit,\n        BasketRange calldata buyLimit,\n        Prices calldata prices,\n        uint256 ttl\n    ) external nonReentrant onlyRole(AUCTION_APPROVER) {\n        require(!isKilled, Folio__FolioKilled());\n\n        require(\n            address(sell) != address(0) && address(buy) != address(0) && address(sell) != address(buy),\n            Folio__InvalidAuctionTokens()\n        );\n\n        require(\n            sellLimit.high <= MAX_RATE && sellLimit.low <= sellLimit.spot && sellLimit.high >= sellLimit.spot,\n            Folio__InvalidSellLimit()\n        );\n\n        require(\n            buyLimit.low != 0 &&\n                buyLimit.high <= MAX_RATE &&\n                buyLimit.low <= buyLimit.spot &&\n                buyLimit.high >= buyLimit.spot,\n            Folio__InvalidBuyLimit()\n        );\n\n        require(prices.start >= prices.end, Folio__InvalidPrices());\n\n        require(ttl <= MAX_TTL, Folio__InvalidAuctionTTL());\n\n        Auction memory auction = Auction({\n            id: auctions.length,\n            sell: sell,\n            buy: buy,\n            sellLimit: sellLimit,\n            buyLimit: buyLimit,\n            prices: prices,\n            availableAt: block.timestamp + auctionDelay,\n            launchTimeout: block.timestamp + ttl,\n            start: 0,\n            end: 0,\n            k: 0\n        });\n\n        auctions.push(auction);\n\n        emit AuctionApproved(auction.id, address(sell), address(buy), auction);\n    }\n\n    /// Open an auction as the auction launcher\n    /// @param sellLimit D27{sellTok/share} min ratio of sell token to shares allowed, inclusive, 1e54 max\n    /// @param buyLimit D27{buyTok/share} max balance-ratio to shares allowed, exclusive, 1e54 max\n    /// @param startPrice D27{buyTok/sellTok} 1e54 max\n    /// @param endPrice D27{buyTok/sellTok} 1e54 max\n    function openAuction(\n        uint256 auctionId,\n        uint256 sellLimit,\n        uint256 buyLimit,\n        uint256 startPrice,\n        uint256 endPrice\n    ) external nonReentrant onlyRole(AUCTION_LAUNCHER) {\n        Auction storage auction = auctions[auctionId];\n\n        // auction launcher can:\n        //   - select a sell limit within the approved range\n        //   - select a buy limit within the approved range\n        //   - raise starting price by up to 100x\n        //   - raise ending price arbitrarily (can cause auction not to clear, same as closing auction)\n\n        require(\n            startPrice >= auction.prices.start &&\n                endPrice >= auction.prices.end &&\n                (auction.prices.start == 0 || startPrice <= 100 * auction.prices.start),\n            Folio__InvalidPrices()\n        );\n\n        require(sellLimit >= auction.sellLimit.low && sellLimit <= auction.sellLimit.high, Folio__InvalidSellLimit());\n\n        require(buyLimit >= auction.buyLimit.low && buyLimit <= auction.buyLimit.high, Folio__InvalidBuyLimit());\n\n        auction.sellLimit.spot = sellLimit;\n        auction.buyLimit.spot = buyLimit;\n        auction.prices.start = startPrice;\n        auction.prices.end = endPrice;\n        // more price checks in _openAuction()\n\n        _openAuction(auction);\n    }\n\n    /// Open an auction permissionlessly\n    /// @dev Permissionless, callable only after the auction delay\n    function openAuctionPermissionlessly(uint256 auctionId) external nonReentrant {\n        Auction storage auction = auctions[auctionId];\n\n        // only open auctions that have not timed out (ttl check)\n        require(block.timestamp >= auction.availableAt, Folio__AuctionCannotBeOpenedPermissionlesslyYet());\n\n        _openAuction(auction);\n    }\n\n    /// Bid in an ongoing auction\n    ///   If withCallback is true, caller must adhere to IBidderCallee interface and receives a callback\n    ///   If withCallback is false, caller must have provided an allowance in advance\n    /// @dev Permissionless\n    /// @param sellAmount {sellTok} Sell token, the token the bidder receives\n    /// @param maxBuyAmount {buyTok} Max buy token, the token the bidder provides\n    /// @param withCallback If true, caller must adhere to IBidderCallee interface and transfers tokens via callback\n    /// @param data Arbitrary data to pass to the callback\n    /// @return boughtAmt {buyTok} The amount bidder receives\n    function bid(\n        uint256 auctionId,\n        uint256 sellAmount,\n        uint256 maxBuyAmount,\n        bool withCallback,\n        bytes calldata data\n    ) external nonReentrant returns (uint256 boughtAmt) {\n        require(!isKilled, Folio__FolioKilled());\n        Auction storage auction = auctions[auctionId];\n\n        // checks auction is ongoing\n        // D27{buyTok/sellTok}\n        uint256 price = _price(auction, block.timestamp);\n\n        // {buyTok} = {sellTok} * D27{buyTok/sellTok} / D27\n        boughtAmt = Math.mulDiv(sellAmount, price, D27, Math.Rounding.Ceil);\n        require(boughtAmt <= maxBuyAmount, Folio__SlippageExceeded());\n\n        // totalSupply inflates over time due to TVL fee, causing buyLimits/sellLimits to be slightly stale\n        uint256 _totalSupply = totalSupply();\n        uint256 sellBal = auction.sell.balanceOf(address(this));\n\n        // {sellTok} = D27{sellTok/share} * {share} / D27\n        uint256 minSellBal = Math.mulDiv(auction.sellLimit.spot, _totalSupply, D27, Math.Rounding.Ceil);\n        uint256 sellAvailable = sellBal > minSellBal ? sellBal - minSellBal : 0;\n\n        // ensure auction is large enough to cover bid\n        require(sellAmount <= sellAvailable, Folio__InsufficientBalance());\n\n        // put buy token in basket\n        _addToBasket(address(auction.buy));\n\n        // pay bidder\n        auction.sell.safeTransfer(msg.sender, sellAmount);\n\n        emit AuctionBid(auctionId, sellAmount, boughtAmt);\n\n        // QoL: close auction if we have reached the sell limit\n        sellBal = auction.sell.balanceOf(address(this));\n        if (sellBal <= minSellBal) {\n            auction.end = block.timestamp;\n            // cannot update sellEnds/buyEnds due to possibility of parallel auctions\n\n            if (sellBal == 0) {\n                _removeFromBasket(address(auction.sell));\n            }\n        }\n\n        // collect payment from bidder\n        if (withCallback) {\n            uint256 balBefore = auction.buy.balanceOf(address(this));\n\n            IBidderCallee(msg.sender).bidCallback(address(auction.buy), boughtAmt, data);\n\n            require(auction.buy.balanceOf(address(this)) - balBefore >= boughtAmt, Folio__InsufficientBid());\n        } else {\n            auction.buy.safeTransferFrom(msg.sender, address(this), boughtAmt);\n        }\n\n        // D27{buyTok/share} = D27{buyTok/share} * {share} / D27\n        uint256 maxBuyBal = Math.mulDiv(auction.buyLimit.spot, _totalSupply, D27, Math.Rounding.Floor);\n\n        // ensure post-bid buy balance does not exceed max\n        require(auction.buy.balanceOf(address(this)) <= maxBuyBal, Folio__ExcessiveBid());\n    }\n\n    /// Close an auction\n    /// A auction can be closed from anywhere in its lifecycle, and cannot be restarted\n    /// @dev Callable by AUCTION_APPROVER or AUCTION_LAUNCHER or ADMIN\n    function closeAuction(uint256 auctionId) external nonReentrant {\n        require(\n            hasRole(AUCTION_APPROVER, msg.sender) ||\n                hasRole(AUCTION_LAUNCHER, msg.sender) ||\n                hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n            Folio__Unauthorized()\n        );\n\n        // do not revert, to prevent griefing\n        auctions[auctionId].end = 1;\n\n        emit AuctionClosed(auctionId);\n    }\n\n    // ==== Internal ====\n\n    /// @param shares {share}\n    /// @return _assets\n    /// @return _amounts {tok}\n    function _toAssets(\n        uint256 shares,\n        Math.Rounding rounding\n    ) internal view returns (address[] memory _assets, uint256[] memory _amounts) {\n        uint256 _totalSupply = totalSupply();\n\n        _assets = basket.values();\n\n        uint256 len = _assets.length;\n        _amounts = new uint256[](len);\n        for (uint256 i; i < len; i++) {\n            uint256 assetBal = IERC20(_assets[i]).balanceOf(address(this));\n\n            // {tok} = {share} * {tok} / {share}\n            _amounts[i] = Math.mulDiv(shares, assetBal, _totalSupply, rounding);\n        }\n    }\n\n    function _openAuction(Auction storage auction) internal {\n        require(!isKilled, Folio__FolioKilled());\n\n        // only open APPROVED auctions\n        require(auction.start == 0 && auction.end == 0, Folio__AuctionCannotBeOpened());\n\n        // do not open auctions that have timed out from ttl\n        require(block.timestamp <= auction.launchTimeout, Folio__AuctionTimeout());\n\n        // ensure no conflicting tokens across auctions (same sell or sell buy is okay)\n        // necessary to prevent dutch auctions from taking losses\n        require(\n            block.timestamp > sellEnds[address(auction.buy)] && block.timestamp > buyEnds[address(auction.sell)],\n            Folio__AuctionCollision()\n        );\n\n        sellEnds[address(auction.sell)] = Math.max(sellEnds[address(auction.sell)], block.timestamp + auctionLength);\n        buyEnds[address(auction.buy)] = Math.max(buyEnds[address(auction.buy)], block.timestamp + auctionLength);\n\n        // ensure valid price range (startPrice == endPrice is valid)\n        require(\n            auction.prices.start >= auction.prices.end &&\n                auction.prices.end != 0 &&\n                auction.prices.start <= MAX_RATE &&\n                auction.prices.start / auction.prices.end <= MAX_PRICE_RANGE,\n            Folio__InvalidPrices()\n        );\n\n        auction.start = block.timestamp;\n        auction.end = block.timestamp + auctionLength;\n\n        emit AuctionOpened(auction.id, auction);\n\n        // D18{1}\n        // k = ln(P_0 / P_t) / t\n        auction.k = UD60x18.wrap((auction.prices.start * D18) / auction.prices.end).ln().unwrap() / auctionLength;\n        // gas optimization to avoid recomputing k on every bid\n    }\n\n    /// @return p D27{buyTok/sellTok}\n    function _price(Auction storage auction, uint256 timestamp) internal view returns (uint256 p) {\n        // ensure auction is ongoing\n        require(timestamp >= auction.start && timestamp <= auction.end, Folio__AuctionNotOngoing());\n\n        if (timestamp == auction.start) {\n            return auction.prices.start;\n        }\n        if (timestamp == auction.end) {\n            return auction.prices.end;\n        }\n\n        uint256 elapsed = timestamp - auction.start;\n\n        // P_t = P_0 * e ^ -kt\n        // D27{buyTok/sellTok} = D27{buyTok/sellTok} * D18{1} / D18\n        p = (auction.prices.start * intoUint256(exp(SD59x18.wrap(-1 * int256(auction.k * elapsed))))) / D18;\n        if (p < auction.prices.end) {\n            p = auction.prices.end;\n        }\n    }\n\n    /// @return _daoPendingFeeShares {share}\n    /// @return _feeRecipientsPendingFeeShares {share}\n    function _getPendingFeeShares()\n        internal\n        view\n        returns (uint256 _daoPendingFeeShares, uint256 _feeRecipientsPendingFeeShares)\n    {\n        _daoPendingFeeShares = daoPendingFeeShares;\n        _feeRecipientsPendingFeeShares = feeRecipientsPendingFeeShares;\n\n        uint256 supply = super.totalSupply() + _daoPendingFeeShares + _feeRecipientsPendingFeeShares;\n        uint256 elapsed = block.timestamp - lastPoke;\n\n        (, uint256 daoFeeNumerator, uint256 daoFeeDenominator, uint256 daoFeeFloor) = daoFeeRegistry.getFeeDetails(\n            address(this)\n        );\n\n        // convert annual percentage to per-second for comparison with stored tvlFee\n        // = 1 - (1 - feeFloor) ^ (1 / 31536000)\n        // D18{1/s} = D18{1} - D18{1} * D18{1} ^ D18{1/s}\n        uint256 feeFloor = D18 - UD60x18.wrap(D18 - daoFeeFloor).pow(ANNUALIZER).unwrap();\n\n        // D18{1/s}\n        uint256 _tvlFee = feeFloor > tvlFee ? feeFloor : tvlFee;\n\n        // {share} += {share} * D18 / D18{1/s} ^ {s} - {share}\n        uint256 feeShares = (supply * D18) / UD60x18.wrap(D18 - _tvlFee).powu(elapsed).unwrap() - supply;\n\n        // D18{1} = D18{1/s} * D18 / D18{1/s}\n        uint256 correction = (feeFloor * D18 + _tvlFee - 1) / _tvlFee;\n\n        // {share} = {share} * D18{1} / D18\n        uint256 daoShares = (correction > (daoFeeNumerator * D18 + daoFeeDenominator - 1) / daoFeeDenominator)\n            ? (feeShares * correction + D18 - 1) / D18\n            : (feeShares * daoFeeNumerator + daoFeeDenominator - 1) / daoFeeDenominator;\n\n        _daoPendingFeeShares += daoShares;\n        _feeRecipientsPendingFeeShares += feeShares - daoShares;\n    }\n\n    /// Set TVL fee by annual percentage. Different from how it is stored!\n    /// @param _newFeeAnnually D18{1}\n    function _setTVLFee(uint256 _newFeeAnnually) internal {\n        require(_newFeeAnnually <= MAX_TVL_FEE, Folio__TVLFeeTooHigh());\n\n        // convert annual percentage to per-second\n        // = 1 - (1 - _newFeeAnnually) ^ (1 / 31536000)\n        // D18{1/s} = D18{1} - D18{1} ^ {s}\n        tvlFee = D18 - UD60x18.wrap(D18 - _newFeeAnnually).pow(ANNUALIZER).unwrap();\n\n        require(_newFeeAnnually == 0 || tvlFee != 0, Folio__TVLFeeTooLow());\n\n        emit TVLFeeSet(tvlFee, _newFeeAnnually);\n    }\n\n    /// Set mint fee\n    /// @param _newFee D18{1}\n    function _setMintFee(uint256 _newFee) internal {\n        require(_newFee <= MAX_MINT_FEE, Folio__MintFeeTooHigh());\n\n        mintFee = _newFee;\n        emit MintFeeSet(_newFee);\n    }\n\n    function _setFeeRecipients(FeeRecipient[] memory _feeRecipients) internal {\n        // Clear existing fee table\n        uint256 len = feeRecipients.length;\n        for (uint256 i; i < len; i++) {\n            feeRecipients.pop();\n        }\n\n        // Add new items to the fee table\n        uint256 total;\n        len = _feeRecipients.length;\n        require(len <= MAX_FEE_RECIPIENTS, Folio__TooManyFeeRecipients());\n\n        address previousRecipient;\n\n        for (uint256 i; i < len; i++) {\n            require(_feeRecipients[i].recipient > previousRecipient, Folio__FeeRecipientInvalidAddress());\n            require(_feeRecipients[i].portion != 0, Folio__FeeRecipientInvalidFeeShare());\n\n            total += _feeRecipients[i].portion;\n            previousRecipient = _feeRecipients[i].recipient;\n            feeRecipients.push(_feeRecipients[i]);\n            emit FeeRecipientSet(_feeRecipients[i].recipient, _feeRecipients[i].portion);\n        }\n\n        // ensure table adds up to 100%\n        require(total == D18, Folio__BadFeeTotal());\n    }\n\n    /// @param _newDelay {s}\n    function _setAuctionDelay(uint256 _newDelay) internal {\n        require(_newDelay <= MAX_AUCTION_DELAY, Folio__InvalidAuctionDelay());\n\n        auctionDelay = _newDelay;\n        emit AuctionDelaySet(_newDelay);\n    }\n\n    /// @param _newLength {s}\n    function _setAuctionLength(uint256 _newLength) internal {\n        require(_newLength >= MIN_AUCTION_LENGTH && _newLength <= MAX_AUCTION_LENGTH, Folio__InvalidAuctionLength());\n\n        auctionLength = _newLength;\n        emit AuctionLengthSet(auctionLength);\n    }\n\n    function _setMandate(string memory _newMandate) internal {\n        mandate = _newMandate;\n        emit MandateSet(_newMandate);\n    }\n\n    /// @dev After: daoPendingFeeShares and feeRecipientsPendingFeeShares are up-to-date\n    function _poke() internal {\n        if (lastPoke == block.timestamp) {\n            return;\n        }\n\n        (daoPendingFeeShares, feeRecipientsPendingFeeShares) = _getPendingFeeShares();\n        lastPoke = block.timestamp;\n    }\n\n    function _addToBasket(address token) internal returns (bool) {\n        require(token != address(0), Folio__InvalidAsset());\n        emit BasketTokenAdded(token);\n\n        return basket.add(token);\n    }\n\n    function _removeFromBasket(address token) internal returns (bool) {\n        emit BasketTokenRemoved(token);\n\n        return basket.remove(token);\n    }\n}\n",
        "GovernanceDeployer.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { TimelockControllerUpgradeable } from \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\nimport { IGovernanceDeployer } from \"@interfaces/IGovernanceDeployer.sol\";\nimport { FolioGovernor } from \"@gov/FolioGovernor.sol\";\nimport { StakingVault } from \"@staking/StakingVault.sol\";\nimport { Versioned } from \"@utils/Versioned.sol\";\n\n/**\n * @title Governance Deployer\n * @author akshatmittal, julianmrodri, pmckelvy1, tbrent\n */\ncontract GovernanceDeployer is IGovernanceDeployer, Versioned {\n    uint256 constant DEFAULT_REWARD_PERIOD = 3.5 days;\n    uint256 constant DEFAULT_UNSTAKING_DELAY = 1 weeks;\n\n    event DeployedGovernedStakingToken(\n        address indexed underlying,\n        address indexed stToken,\n        address governor,\n        address timelock\n    );\n    event DeployedGovernance(address indexed stToken, address governor, address timelock);\n\n    address public immutable governorImplementation;\n    address public immutable timelockImplementation;\n\n    constructor(address _governorImplementation, address _timelockImplementation) {\n        governorImplementation = _governorImplementation;\n        timelockImplementation = _timelockImplementation;\n    }\n\n    /// Deploys a StakingVault owned by a Governor with Timelock\n    /// @param name Name of the staking vault\n    /// @param symbol Symbol of the staking vault\n    /// @param underlying Underlying token for the staking vault\n    /// @param govParams Governance parameters for the governor\n    /// @param deploymentNonce Nonce for the deployment salt\n    /// @return stToken A staking vault that can be used with multiple governors\n    /// @return governor A governor responsible for the staking vault\n    /// @return timelock Timelock for the governor, owns staking vault\n    function deployGovernedStakingToken(\n        string memory name,\n        string memory symbol,\n        IERC20 underlying,\n        IGovernanceDeployer.GovParams calldata govParams,\n        bytes32 deploymentNonce\n    ) external returns (StakingVault stToken, address governor, address timelock) {\n        bytes32 deploymentSalt = keccak256(abi.encode(name, symbol, underlying, govParams, deploymentNonce));\n\n        stToken = new StakingVault{ salt: deploymentSalt }(\n            name,\n            symbol,\n            underlying,\n            address(this), // temporary admin\n            DEFAULT_REWARD_PERIOD,\n            DEFAULT_UNSTAKING_DELAY\n        );\n\n        (governor, timelock) = deployGovernanceWithTimelock(govParams, IVotes(stToken), deploymentSalt);\n\n        stToken.transferOwnership(timelock);\n\n        emit DeployedGovernedStakingToken(address(underlying), address(stToken), governor, timelock);\n    }\n\n    function deployGovernanceWithTimelock(\n        IGovernanceDeployer.GovParams calldata govParams,\n        IVotes stToken,\n        bytes32 deploymentNonce\n    ) public returns (address governor, address timelock) {\n        bytes32 deploymentSalt = keccak256(abi.encode(govParams, stToken, deploymentNonce));\n\n        governor = Clones.cloneDeterministic(governorImplementation, deploymentSalt);\n        timelock = Clones.cloneDeterministic(timelockImplementation, deploymentSalt);\n\n        TimelockControllerUpgradeable timelockController = TimelockControllerUpgradeable(payable(timelock));\n\n        FolioGovernor(payable(governor)).initialize(\n            stToken,\n            timelockController,\n            govParams.votingDelay,\n            govParams.votingPeriod,\n            govParams.proposalThreshold,\n            govParams.quorumPercent\n        );\n\n        address[] memory proposersAndExecutors = new address[](1);\n        proposersAndExecutors[0] = governor;\n\n        timelockController.initialize(\n            govParams.timelockDelay,\n            proposersAndExecutors, // Proposer Role\n            proposersAndExecutors, // Executor Role\n            address(this) // temporary admin\n        );\n\n        for (uint256 i; i < govParams.guardians.length; i++) {\n            timelockController.grantRole(timelockController.CANCELLER_ROLE(), govParams.guardians[i]);\n        }\n\n        timelockController.renounceRole(timelockController.DEFAULT_ADMIN_ROLE(), address(this));\n\n        emit DeployedGovernance(address(stToken), governor, timelock);\n    }\n}\n"
    }
}