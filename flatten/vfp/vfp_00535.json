{
    "vfp_id": "vfp_00535",
    "project_name": "CapyFi Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Unlimited DEFAULT_ADMIN_ROLE Power Over ADMIN_ROLE and WHITELISTED_ROLE",
            "description": "The Whitelist contract implements a role-based access control system using OpenZeppelin's AccessControlUpgradeable, defining ADMIN_ROLE and WHITELISTED_ROLE. The intended design restricts role management to users with ADMIN_ROLE via custom functions (addAdmin, removeAdmin, addWhitelisted, removeWhitelisted). However, because the default admin role (DEFAULT_ADMIN_ROLE) is set as the admin for both roles, any account with DEFAULT_ADMIN_ROLE can bypass these custom functions and directly call the public grantRole and revokeRole functions to manage both roles without requiring ADMIN_ROLE.\n\nThis occurs due to the inheritance model and default behavior of AccessControlUpgradeable, where DEFAULT_ADMIN_ROLE holds overarching authority unless explicitly restricted. As a result, the access control hierarchy is weakened, allowing unintended privilege escalation paths.\n\nAn attacker or malicious actor with DEFAULT_ADMIN_ROLE could arbitrarily add or remove admins and whitelisted users, effectively taking control over who can mint cTokens and manage the whitelist system. This undermines the intended security model and could lead to unauthorized access or denial of service for legitimate users.\n\nThe impact is considered low severity because the DEFAULT_ADMIN_ROLE is typically tightly controlled and not intended for regular use. However, if compromised or misconfigured, it could lead to full control over the whitelist mechanism.\n",
            "severity": "Low",
            "location": [
                "Whitelist.sol::addAdmin#109-111",
                "Whitelist.sol::removeAdmin#117-119",
                "Whitelist.sol::addWhitelisted#125-127",
                "Whitelist.sol::removeWhitelisted#133-135",
                "AccessControlUpgradeable.sol::grantRole#136-138",
                "AccessControlUpgradeable.sol::revokeRole#149-151"
            ],
            "files": [
                "capyfi-sc/src/contracts/Access/Whitelist.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unsafe Casting in getAnswer Function",
            "description": "The getAnswer function in the CapyfiAggregatorV3 contract accepts a uint256 parameter for roundId and attempts to cast it to uint80 when used in internal lookups. When the provided roundId exceeds the maximum value of uint80 (approximately 1.2e24), the function will revert due to type casting constraints.\n\nThe root cause is the unsafe downcast of roundId to uint80 within the error message construction, even though the function will already revert due to the type mismatch. This leads to incorrect or misleading error reporting, as the cast itself may not reflect the actual input value.\n\nAn attacker could exploit this by providing extremely large roundId values to trigger reverts with potentially confusing error messages, complicating debugging and integration efforts.\n\nThe impact is low, as this does not lead to loss of funds or direct manipulation of state, but it affects the reliability and clarity of error handling, which could hinder integrators and monitoring systems.\n",
            "severity": "Low",
            "location": [
                "CapyfiAggregatorV3.sol::getAnswer#148"
            ],
            "files": [
                "capyfi-sc/src/contracts/PriceOracle/CapyfiAggregatorV3.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Differences Between CapyFi And Chainlink Oracles",
            "description": "The CapyFiAggregatorV3 contract, while implementing the Chainlink AggregatorV3Interface, exhibits several behavioral differences from Chainlink's oracle implementation. These include: (1) roundId starts at 1 instead of a packed phaseId/originalId structure; (2) requests for non-existent rounds revert instead of returning zero values; (3) no minimum or maximum price bounds; and (4) startedAt and updatedAt timestamps are identical upon update, unlike Chainlink's delayed aggregation model.\n\nThese differences stem from CapyFi's centralized, permissioned oracle design versus Chainlink's decentralized model. The cause is a lack of strict adherence to Chainlink's expected behavior despite interface compatibility.\n\nExternal integrators relying on Chainlink-like behavior may experience unexpected reverts or incorrect assumptions about price staleness and historical data availability. For example, attempting to fetch round 1 from a Chainlink-style client would fail on CapyFi's oracle.\n\nThe impact is low, as it does not introduce direct financial risk, but it poses integration risks and could lead to service disruptions if not properly documented and understood by developers.\n",
            "severity": "Low",
            "location": [
                "CapyfiAggregatorV3.sol#61",
                "CapyfiAggregatorV3.sol#116",
                "CapyfiAggregatorV3.sol::getAnswer",
                "CapyfiAggregatorV3.sol::getRoundData"
            ],
            "files": [
                "capyfi-sc/src/contracts/PriceOracle/CapyfiAggregatorV3.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing State Change Validation",
            "description": "Several functions in the codebase fail to validate whether a new value differs from the current state before performing a state update. This affects the activate and deactivate functions in Whitelist.sol, and the addAuthorizedAddress and removeAuthorizedAddress functions in CapyfiAggregatorV3.sol.\n\nThe root cause is the absence of require() guards checking that the new value is different from the existing one. This leads to unnecessary state writes even when no effective change occurs.\n\nAn attacker could exploit this by repeatedly calling these functions with the same value, leading to wasteful gas consumption and bloating the blockchain with redundant transactions. While not directly harmful, it increases operational costs and reduces efficiency.\n\nThe impact is low, as it does not compromise security or lead to fund loss, but it affects gas efficiency and contract maintainability.\n",
            "severity": "Low",
            "location": [
                "Whitelist.sol::activate#89",
                "Whitelist.sol::deactivate#98",
                "CapyfiAggregatorV3.sol::addAuthorizedAddress#70",
                "CapyfiAggregatorV3.sol::removeAuthorizedAddress#80"
            ],
            "files": [
                "capyfi-sc/src/contracts/Access/Whitelist.sol",
                "capyfi-sc/src/contracts/PriceOracle/CapyfiAggregatorV3.sol"
            ]
        }
    ],
    "affected_files": {
        "CapyfiAggregatorV3.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { Ownable2Step } from \"openzeppelin-contracts/access/Ownable2Step.sol\";\nimport { AggregatorV2V3Interface } from \"./AggregatorV3Interface.sol\";\n\ncontract CapyfiAggregatorV3 is AggregatorV2V3Interface, Ownable2Step {\n    \n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    uint8 private _decimals;\n    string private _description;\n    uint256 private _version;\n    \n    uint80 private nextRoundId;\n    mapping(uint80 => RoundData) private rounds;\n    RoundData private _latestRound;\n    \n    mapping(address => bool) public authorizedAddresses;\n\n    // Additional events for access control\n    event AuthorizedAddressAdded(address indexed addr);\n    event AuthorizedAddressRemoved(address indexed addr);\n\n    error UnauthorizedCaller(address caller);\n    error InvalidAddress(address addr);\n    error InvalidPrice(int256 price);\n    error RoundNotFound(uint80 roundId);\n    error NoRoundsAvailable();\n\n    modifier onlyAuthorized() {\n        if (msg.sender != owner() && !authorizedAddresses[msg.sender]) {\n            revert UnauthorizedCaller(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Deploy the contract with initial parameters\n     * @param decimals_ Number of decimals for the price feed\n     * @param description_ Description of what this aggregator represents\n     * @param version_ Version of the aggregator\n     * @param initialPrice Initial price to set (cannot be 0)\n     */\n    constructor(\n        uint8 decimals_,\n        string memory description_,\n        uint256 version_,\n        int256 initialPrice\n    ) {\n        if (initialPrice <= 0) revert InvalidPrice(initialPrice);\n        _decimals = decimals_;\n        _description = description_;\n        _version = version_;\n        nextRoundId = 1;\n        \n        _updateAnswer(initialPrice);\n    }\n\n    /**\n     * @notice Add an authorized address that can update prices\n     * @param addr Address to authorize\n     */\n    function addAuthorizedAddress(address addr) external onlyOwner {\n        if (addr == address(0)) revert InvalidAddress(addr);\n        authorizedAddresses[addr] = true;\n        emit AuthorizedAddressAdded(addr);\n    }\n\n    /**\n     * @notice Remove an authorized address\n     * @param addr Address to remove authorization from\n     */\n    function removeAuthorizedAddress(address addr) external onlyOwner {\n        if (!authorizedAddresses[addr]) revert InvalidAddress(addr);\n        authorizedAddresses[addr] = false;\n        emit AuthorizedAddressRemoved(addr);\n    }\n\n    /**\n     * @notice Update the price (only owner or authorized addresses)\n     * @param newAnswer New price to set\n     */\n    function updateAnswer(int256 newAnswer) external onlyAuthorized {\n        if (newAnswer <= 0) revert InvalidPrice(newAnswer);\n        _updateAnswer(newAnswer);\n    }\n\n    /**\n     * @notice Internal function to update the answer and create a new round\n     * @param newAnswer New price to set\n     */\n    function _updateAnswer(int256 newAnswer) internal {\n        uint256 timestamp = block.timestamp;\n        \n        RoundData memory newRound = RoundData({\n            roundId: nextRoundId,\n            answer: newAnswer,\n            startedAt: timestamp,\n            updatedAt: timestamp,\n            answeredInRound: nextRoundId\n        });\n        \n        rounds[nextRoundId] = newRound;\n        _latestRound = newRound;\n        \n        emit AnswerUpdated(newAnswer, nextRoundId, timestamp);\n        emit NewRound(nextRoundId, msg.sender, timestamp);\n        \n        nextRoundId++;\n    }\n\n    // AggregatorInterface (V2) implementation\n    \n    /**\n     * @notice Get the latest answer without round data\n     */\n    function latestAnswer() external view override returns (int256) {\n        if (_latestRound.roundId == 0) revert NoRoundsAvailable();\n        return _latestRound.answer;\n    }\n\n    /**\n     * @notice Get the timestamp of the latest update\n     */\n    function latestTimestamp() external view override returns (uint256) {\n        if (_latestRound.roundId == 0) revert NoRoundsAvailable();\n        return _latestRound.updatedAt;\n    }\n\n    /**\n     * @notice Get the latest round ID\n     */\n    function latestRound() external view override returns (uint256) {\n        return nextRoundId - 1; // Return current round ID\n    }\n\n    /**\n     * @notice Get the answer for a specific round\n     * @param roundId The round ID to get the answer for\n     */\n    function getAnswer(uint256 roundId) external view override returns (int256) {\n        if (roundId == 0 || roundId >= nextRoundId) revert RoundNotFound(uint80(roundId));\n        return rounds[uint80(roundId)].answer;\n    }\n\n    /**\n     * @notice Get the timestamp for a specific round\n     * @param roundId The round ID to get the timestamp for\n     */\n    function getTimestamp(uint256 roundId) external view override returns (uint256) {\n        if (roundId == 0 || roundId >= nextRoundId) revert RoundNotFound(uint80(roundId));\n        return rounds[uint80(roundId)].updatedAt;\n    }\n\n    // AggregatorV3Interface implementation\n\n    /**\n     * @notice Returns the number of decimals\n     */\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @notice Returns the description\n     */\n    function description() external view override returns (string memory) {\n        return _description;\n    }\n\n    /**\n     * @notice Returns the version\n     */\n    function version() external view override returns (uint256) {\n        return _version;\n    }\n\n    /**\n     * @notice Get data from a specific round\n     * @param roundId The round ID to retrieve data for\n     */\n    function getRoundData(uint80 roundId) \n        external \n        view \n        override \n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        ) \n    {\n        if (roundId == 0 || roundId >= nextRoundId) revert RoundNotFound(roundId);\n        \n        RoundData memory round = rounds[roundId];\n        return (\n            round.roundId,\n            round.answer,\n            round.startedAt,\n            round.updatedAt,\n            round.answeredInRound\n        );\n    }\n\n    /**\n     * @notice Get data from the latest round\n     */\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        )\n    {\n        if (_latestRound.roundId == 0) revert NoRoundsAvailable();\n        \n        return (\n            _latestRound.roundId,\n            _latestRound.answer,\n            _latestRound.startedAt,\n            _latestRound.updatedAt,\n            _latestRound.answeredInRound\n        );\n    }\n} ",
        "Whitelist.sol": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {WhitelistAccess} from \"./WhitelistAccess.sol\";\n\n/**\n * @title Whitelist\n * @dev Whitelist contract with UUPS upgradeability pattern\n */\ncontract Whitelist is \n    Initializable, \n    AccessControlEnumerableUpgradeable, \n    UUPSUpgradeable,\n    WhitelistAccess \n{\n    // Constants\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    \n    // State variables\n    bool private _active;\n    \n    // Events\n    event WhitelistActivated(address admin);\n    event WhitelistDeactivated(address admin);\n    event WhitelistUpgraded(address implementation);\n\n    /**\n     * @dev Prevent implementation contract from being initialized\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /**\n     * @dev Initializer function, used instead of constructor for upgradeable contracts\n     * @param admin Address to be assigned admin roles\n     */\n    function initialize(address admin) public initializer {\n        __AccessControlEnumerable_init();\n        __UUPSUpgradeable_init();\n\n        // Grant roles to the admin\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n        \n        // Set active state to true\n        _active = true;\n    }\n\n    /**\n     * @dev Restricts function to admin only\n     */\n    modifier onlyAdmin() {\n        require(\n            hasRole(ADMIN_ROLE, msg.sender),\n            \"WhitelistAccess: caller does not have the ADMIN_ROLE\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Restricts function to whitelisted users only\n     */\n    modifier onlyWhitelisted() {\n        require(\n            hasRole(WHITELISTED_ROLE, msg.sender), \n            \"WhitelistAccess: caller does not have the WHITELISTED_ROLE role\"\n        );\n        _;\n    }\n\n    // External functions\n\n    /**\n     * @notice Check if the whitelist is active\n     * @return Boolean indicating if the whitelist is active\n     */\n    function isActive() external view override returns (bool) {\n        return _active;\n    }\n    \n    /**\n     * @notice Activate the whitelist, enforcing whitelist checks\n     * @dev Can only be called by an admin\n     */\n    function activate() external onlyAdmin {\n        _active = true;\n        emit WhitelistActivated(msg.sender);\n    }\n    \n    /**\n     * @notice Deactivate the whitelist, allowing all accounts to pass checks\n     * @dev Can only be called by an admin\n     */\n    function deactivate() external onlyAdmin {\n        _active = false;\n        emit WhitelistDeactivated(msg.sender);\n    }\n\n    // Public functions\n\n    /**\n     * @notice Add a new admin\n     * @param account Address to grant admin role to\n     */\n    function addAdmin(address account) public onlyAdmin {\n        _grantRole(ADMIN_ROLE, account);\n    }\n\n    /**\n     * @notice Remove an admin\n     * @param account Address to revoke admin role from\n     */\n    function removeAdmin(address account) public onlyAdmin {\n        _revokeRole(ADMIN_ROLE, account);\n    }\n\n    /**\n     * @notice Add an address to the whitelist\n     * @param account Address to whitelist\n     */\n    function addWhitelisted(address account) public onlyAdmin {\n        _grantRole(WHITELISTED_ROLE, account);\n    }\n\n    /**\n     * @notice Remove an address from the whitelist\n     * @param account Address to remove from whitelist\n     */\n    function removeWhitelisted(address account) public onlyAdmin {\n        _revokeRole(WHITELISTED_ROLE, account);\n    }\n\n    /**\n     * @notice Check if an account is whitelisted\n     * @param account The address to check\n     * @return Boolean indicating if the address is whitelisted\n     */\n    function isWhitelisted(address account) public view override returns (bool) {\n        return hasRole(WHITELISTED_ROLE, account);\n    }\n\n    /**\n     * @notice Check if an account is an admin\n     * @param account The address to check\n     * @return Boolean indicating if the address is an admin\n     */\n    function isAdmin(address account) public view returns (bool) {\n        return hasRole(ADMIN_ROLE, account);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract.\n     * Called by {upgradeTo} and {upgradeToAndCall}.\n     * @param newImplementation The address of the new implementation contract\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(ADMIN_ROLE) {\n        emit WhitelistUpgraded(newImplementation);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    }
}