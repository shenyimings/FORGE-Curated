{
    "vfp_id": "vfp_00100",
    "project_name": "cantina_euler_pr111_oct2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Default fee recipient can be set to zero address",
            "description": "The function setDefaultRecipient in EulerSwapProtocolFeeConfig.sol assigns the defaultRecipient without validating that the provided address is non-zero. This allows the default fee recipient to be set to the zero address, which may result in fees being burned instead of being sent to a valid recipient. This behavior breaks compatibility with the previous implementation, where fees sent to address(0) were deposited into the Euler account, thereby increasing the account's NAV. By allowing address(0), the system now risks losing fees permanently and disrupting expected economic flows.\nThe root cause is the lack of input validation in the setDefaultRecipient function. An attacker or misconfigured admin could set the recipient to address(0), leading to irreversible loss of fees collected from pools that rely on the default configuration.\nThis could be exploited by a malicious or compromised admin setting the default recipient to zero, or by accidental misconfiguration during deployment or updates.\nThe impact includes potential loss of protocol and liquidity provider fees, reduced trust in the system's economic model, and deviation from expected behavior in fee distribution.\n",
            "severity": "Low",
            "location": [
                "EulerSwapProtocolFeeConfig.sol#L56"
            ],
            "files": [
                "euler-swap/src/EulerSwapProtocolFeeConfig.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing events for administrative state changes",
            "description": "The functions setAdmin, setDefault, setOverride, and removeOverride in EulerSwapProtocolFeeConfig.sol modify critical administrative state without emitting corresponding events. This omission reduces on-chain observability, making it difficult for external systems such as indexers, monitoring tools, and auditors to track configuration changes over time. Without events, detecting unauthorized or erroneous changes becomes significantly harder, increasing the risk during incident response and post-mortem analysis.\nThe root cause is the absence of event emissions in these functions, which is a deviation from standard smart contract design patterns that emphasize transparency and traceability.\nAn attacker who gains temporary admin access could make stealthy changes that are hard to detect, or legitimate changes could go unnoticed by governance or monitoring systems.\nThe impact is reduced transparency and auditability, which weakens operational security and complicates compliance and forensic investigations.\n",
            "severity": "Low",
            "location": [
                "EulerSwapProtocolFeeConfig.sol#L48-L65"
            ],
            "files": [
                "euler-swap/src/EulerSwapProtocolFeeConfig.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Do not use EVC sub-accounts as fee recipients",
            "description": "The functions setDefault and setOverride in EulerSwapProtocolFeeConfig, along with fee transfer logic in SwapLib, allow EVC sub-accounts to be set as fee recipients without remapping them to their owner addresses. Unlike other parts of the system (e.g., bond redemption), fee transfers use the recipient address directly, which means fees sent to an EVC sub-account may be lost because such accounts lack control keys.\nThe root cause is the lack of validation or remapping logic for EVC sub-accounts in the fee distribution path.\nAn admin could accidentally or intentionally set a sub-account as a fee recipient, resulting in irreversible loss of fees. This could be exploited by a malicious actor with admin privileges to drain protocol revenue.\nThe impact includes potential loss of LP and protocol fees, reduced trust in the system, and operational risk due to misconfiguration.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "euler-swap/src/EulerSwapProtocolFeeConfig.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Admin address must not be an EVC sub-account",
            "description": "The setAdmin function in EulerSwapProtocolFeeConfig allows the admin to be set to an EVC sub-account, which cannot authenticate via standard mechanisms. The onlyAdmin modifier uses _authenticateCallerWithStandardContextState(true), which fails if the caller is a sub-account, effectively bricking administrative functions.\nThe root cause is the absence of validation to prevent EVC sub-accounts from being assigned as admin.\nIf the admin is set to a sub-account, critical administrative functions become permanently inaccessible, leading to a loss of governance control over the contract.\nThe impact is potential permanent loss of administrative control, rendering the contract immutable and unable to respond to emergencies or upgrades.\n",
            "severity": "Informational",
            "location": [
                "EulerSwapProtocolFeeConfig.sol#L38-L50"
            ],
            "files": [
                "euler-swap/src/EulerSwapProtocolFeeConfig.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Protocol fee override can target non existent pool",
            "description": "The setOverride function in EulerSwapProtocolFeeConfig allows setting fee overrides for any address, without verifying that the target is a valid EulerSwap pool. This enables the creation of configuration entries for non-existent or stale pool addresses, leading to cluttered and potentially misleading configuration state.\nThe root cause is the lack of validation against the pool registry or factory to confirm pool existence before storing an override.\nWhile not directly exploitable for financial gain, this could be used to create confusion during audits or operations, or to waste gas on无效 configurations.\nThe impact is operational complexity, increased risk of misconfiguration, and reduced clarity in fee configuration management.\n",
            "severity": "Informational",
            "location": [
                "EulerSwapProtocolFeeConfig.sol#L61-L65"
            ],
            "files": [
                "euler-swap/src/EulerSwapProtocolFeeConfig.sol"
            ]
        }
    ],
    "affected_files": {
        "EulerSwapProtocolFeeConfig.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IEulerSwapProtocolFeeConfig} from \"./interfaces/IEulerSwapProtocolFeeConfig.sol\";\nimport {EVCUtil} from \"evc/utils/EVCUtil.sol\";\n\n/// @title EulerSwapProtocolFeeConfig contract\n/// @custom:security-contact security@euler.xyz\n/// @author Euler Labs (https://www.eulerlabs.com/)\ncontract EulerSwapProtocolFeeConfig is IEulerSwapProtocolFeeConfig, EVCUtil {\n    /// @dev Protocol fee admin\n    address public admin;\n\n    /// @dev Admin is not allowed to set a protocol fee larger than this\n    uint64 public constant MAX_PROTOCOL_FEE = 0.15e18;\n\n    /// @dev Destination of collected protocol fees, unless overridden\n    address public defaultRecipient;\n    /// @dev Default protocol fee, 1e18-scale\n    uint64 public defaultFee;\n\n    struct Override {\n        bool exists;\n        address recipient;\n        uint64 fee;\n    }\n\n    /// @dev EulerSwap-instance specific fee override\n    mapping(address pool => Override) public overrides;\n\n    error Unauthorized();\n    error InvalidProtocolFee();\n\n    constructor(address evc, address admin_) EVCUtil(evc) {\n        admin = admin_;\n    }\n\n    modifier onlyAdmin() {\n        // Ensures that the caller is not an operator, controller, etc\n        _authenticateCallerWithStandardContextState(true);\n\n        require(_msgSender() == admin, Unauthorized());\n\n        _;\n    }\n\n    /// @inheritdoc IEulerSwapProtocolFeeConfig\n    function setAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @inheritdoc IEulerSwapProtocolFeeConfig\n    function setDefault(address recipient, uint64 fee) external onlyAdmin {\n        require(fee <= MAX_PROTOCOL_FEE, InvalidProtocolFee());\n\n        defaultRecipient = recipient;\n        defaultFee = fee;\n    }\n\n    /// @inheritdoc IEulerSwapProtocolFeeConfig\n    function setOverride(address pool, address recipient, uint64 fee) external onlyAdmin {\n        require(fee <= MAX_PROTOCOL_FEE, InvalidProtocolFee());\n\n        overrides[pool] = Override({exists: true, recipient: recipient, fee: fee});\n    }\n\n    /// @inheritdoc IEulerSwapProtocolFeeConfig\n    function removeOverride(address pool) external onlyAdmin {\n        delete overrides[pool];\n    }\n\n    /// @inheritdoc IEulerSwapProtocolFeeConfig\n    function getProtocolFee(address pool) external view returns (address recipient, uint64 fee) {\n        Override memory o = overrides[pool];\n\n        if (o.exists) {\n            recipient = o.recipient;\n            fee = o.fee;\n\n            if (recipient == address(0)) recipient = defaultRecipient;\n        } else {\n            recipient = defaultRecipient;\n            fee = defaultFee;\n        }\n    }\n}\n"
    }
}