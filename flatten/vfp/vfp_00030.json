{
    "vfp_id": "vfp_00030",
    "project_name": "2025.03.10 - Final - Symmio, Staking and Vesting Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Incorrect initializer modifier in Vesting contract prevents proper initialization",
            "description": "The Vesting contract uses the `initializer` modifier in its `__vesting_init` function, which is incorrect when used in a parent contract within an inheritance chain. According to OpenZeppelin's best practices, parent contracts should use `onlyInitializing` instead to allow proper initialization when inherited. The current use of `initializer` sets a flag that prevents any other initializer-modified function (including those in child contracts like SymmVesting) from executing, thereby blocking full initialization. This could lead to deployment failures or improperly initialized contracts, severely impacting protocol functionality. The exploitation does not require active attack but occurs naturally during contract deployment, resulting in a broken system state.\n",
            "severity": "Medium",
            "location": [
                "Vesting.sol::__vesting_init#76"
            ],
            "files": [
                "token/contracts/vesting/Vesting.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "Bad check in Vesting.sol::_resetVestingPlans will prevent users from adding additional liquidity in SymmVesting.sol",
            "description": "The `_resetVestingPlans` function in Vesting.sol contains a flawed validation check that reverts if the new amount being set is less than the already unlocked amount, using `if (amount < vestingPlan.unlockedAmount()) revert AlreadyClaimedMoreThanThis();`. This prevents users from increasing their locked liquidity if the new amount does not exceed the currently unlocked portion, even if they are adding more tokens. The root cause is a logical error in the condition, which incorrectly assumes that any new amount not exceeding unlocked tokens is invalid. This is not an exploit by attackers but a functional bug that blocks legitimate user actions. As a result, users who have partially unlocked their tokens are unable to add more liquidity, limiting protocol usability and user flexibility.\n",
            "severity": "Medium",
            "location": [
                "Vesting.sol::_resetVestingPlans#231"
            ],
            "files": [
                "token/contracts/vesting/Vesting.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Double spending attack in the Vesting contract",
            "description": "The resetVestingPlans function in the Vesting contract allows an administrator to reset vesting plans for specified users, setting their claimedAmount to zero after validating that the new amount is at least the previously claimed amount. The vulnerability arises because the function does not account for the possibility that a user may have claimed their tokens via penalty withdrawal in a transaction that is mined just before the reset. Since the reset does not verify the current state of claims at the time of execution, a user could claim their tokens before the reset and then claim them again afterward, leading to double spending. This race condition enables a user to withdraw more tokens than allocated, resulting in a direct loss of funds from the protocol and potentially affecting the availability of rewards for other legitimate users.\n",
            "severity": "Medium",
            "location": [
                "Vesting.sol::resetVestingPlans#222-237",
                "LibVestingPlan::resetAmount"
            ],
            "files": [
                "token/contracts/vesting/Vesting.sol"
            ]
        }
    ],
    "affected_files": {
        "Vesting.sol": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.18;\n\nimport \"./libraries/LibVestingPlan.sol\";\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n/// @title Vesting Contract\ncontract Vesting is Initializable, AccessControlEnumerableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n\tusing SafeERC20 for IERC20;\n\tusing VestingPlanOps for VestingPlan;\n\n\t//--------------------------------------------------------------------------\n\t// Errors\n\t//--------------------------------------------------------------------------\n\n\terror MismatchArrays();\n\terror AlreadyClaimedMoreThanThis();\n\terror InvalidAmount();\n\terror ZeroAddress();\n\n\t//--------------------------------------------------------------------------\n\t// Events\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Emitted when a vesting plan is set up.\n\tevent VestingPlanSetup(address indexed token, address indexed user, uint256 amount, uint256 startTime, uint256 endTime);\n\n\t/// @notice Emitted when a vesting plan is reset.\n\tevent VestingPlanReset(address indexed token, address indexed user, uint256 newAmount);\n\n\t/// @notice Emitted when unlocked tokens are claimed.\n\tevent UnlockedTokenClaimed(address indexed token, address indexed user, uint256 amount);\n\n\t/// @notice Emitted when locked tokens are claimed.\n\tevent LockedTokenClaimed(address indexed token, address indexed user, uint256 amount, uint256 penalty);\n\n\t//--------------------------------------------------------------------------\n\t// Roles\n\t//--------------------------------------------------------------------------\n\n\tbytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\n\tbytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\tbytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\tbytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n\t//--------------------------------------------------------------------------\n\t// State Variables\n\t//--------------------------------------------------------------------------\n\n\t// Mapping: token => user => vesting plan\n\tmapping(address => mapping(address => VestingPlan)) public vestingPlans;\n\n\t// Mapping: token => total vested amount of that token in the contract\n\tmapping(address => uint256) public totalVested;\n\n\tuint256 public lockedClaimPenalty;\n\taddress public lockedClaimPenaltyReceiver;\n\n\t/// @dev This reserved space is put in place to allow future versions to add new variables\n\t/// without shifting down storage in the inheritance chain.\n\tuint256[50] private __gap;\n\n\t//--------------------------------------------------------------------------\n\t// Initialization\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Initializes the vesting contract.\n\t/// @param admin Address to receive the admin and role assignments.\n\t/// @param _lockedClaimPenalty Penalty rate (scaled by 1e18) for locked token claims.\n\t/// @param _lockedClaimPenaltyReceiver Address that receives the penalty.\n\tfunction __vesting_init(address admin, uint256 _lockedClaimPenalty, address _lockedClaimPenaltyReceiver) public initializer {\n\t\t__AccessControlEnumerable_init();\n\t\t__Pausable_init();\n\t\t__ReentrancyGuard_init();\n\n\t\tlockedClaimPenalty = _lockedClaimPenalty;\n\t\tlockedClaimPenaltyReceiver = _lockedClaimPenaltyReceiver;\n\n\t\tif (admin == address(0) || _lockedClaimPenaltyReceiver == address(0)) revert ZeroAddress();\n\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, admin);\n\t\t_grantRole(SETTER_ROLE, admin);\n\t\t_grantRole(PAUSER_ROLE, admin);\n\t\t_grantRole(UNPAUSER_ROLE, admin);\n\t\t_grantRole(OPERATOR_ROLE, admin);\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Pausing / Unpausing\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Pauses the contract, restricting state-changing functions.\n\t/// @dev Only accounts with PAUSER_ROLE can call this function.\n\tfunction pause() external onlyRole(PAUSER_ROLE) {\n\t\t_pause();\n\t}\n\n\t/// @notice Unpauses the contract, allowing state-changing functions.\n\t/// @dev Only accounts with UNPAUSER_ROLE can call this function.\n\tfunction unpause() external onlyRole(UNPAUSER_ROLE) {\n\t\t_unpause();\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Vesting Plan Functions\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Resets vesting plans for multiple users.\n\t/// @dev Reverts if the users and amounts arrays have different lengths or if any user's claimed amount exceeds the new amount.\n\t/// @param token Address of the token.\n\t/// @param users Array of user addresses.\n\t/// @param amounts Array of new token amounts.\n\tfunction resetVestingPlans(\n\t\taddress token,\n\t\taddress[] memory users,\n\t\tuint256[] memory amounts\n\t) external onlyRole(SETTER_ROLE) whenNotPaused nonReentrant {\n\t\t_resetVestingPlans(token, users, amounts);\n\t}\n\n\t/// @notice Sets up vesting plans for multiple users.\n\t/// @dev Reverts if the users and amounts arrays have different lengths.\n\t/// @param token Address of the token.\n\t/// @param startTime Vesting start time.\n\t/// @param endTime Vesting end time.\n\t/// @param users Array of user addresses.\n\t/// @param amounts Array of token amounts.\n\tfunction setupVestingPlans(\n\t\taddress token,\n\t\tuint256 startTime,\n\t\tuint256 endTime,\n\t\taddress[] memory users,\n\t\tuint256[] memory amounts\n\t) external onlyRole(SETTER_ROLE) whenNotPaused nonReentrant {\n\t\t_setupVestingPlans(token, startTime, endTime, users, amounts);\n\t}\n\n\t/// @notice Claims unlocked tokens for the caller.\n\t/// @param token Address of the token.\n\tfunction claimUnlockedToken(address token) external whenNotPaused nonReentrant {\n\t\t_claimUnlockedToken(token, msg.sender);\n\t}\n\n\t/// @notice Claims unlocked tokens for a specified user.\n\t/// @dev Only accounts with OPERATOR_ROLE can call this function.\n\t/// @param token Address of the token.\n\t/// @param user Address of the user.\n\tfunction claimUnlockedTokenFor(address token, address user) external onlyRole(OPERATOR_ROLE) whenNotPaused nonReentrant {\n\t\t_claimUnlockedToken(token, user);\n\t}\n\n\t/// @notice Claims locked tokens for the caller.\n\t/// @param token Address of the token.\n\t/// @param amount Amount of locked tokens to claim.\n\tfunction claimLockedToken(address token, uint256 amount) external whenNotPaused nonReentrant {\n\t\t_claimLockedToken(token, msg.sender, amount);\n\t}\n\n\t/// @notice Claims locked tokens for the caller by percentage.\n\t/// @param token Address of the token.\n\t/// @param percentage Percentage of locked tokens to claim (between 0 and 1 -- 1 for 100%).\n\tfunction claimLockedTokenByPercentage(address token, uint256 percentage) external whenNotPaused nonReentrant {\n\t\t_claimLockedToken(token, msg.sender, (getLockedAmountsForToken(msg.sender, token) * percentage) / 1e18);\n\t}\n\n\t/// @notice Claims locked tokens for a specified user.\n\t/// @dev Only accounts with OPERATOR_ROLE can call this function.\n\t/// @param token Address of the token.\n\t/// @param user Address of the user.\n\t/// @param amount Amount of locked tokens to claim.\n\tfunction claimLockedTokenFor(address token, address user, uint256 amount) external onlyRole(OPERATOR_ROLE) whenNotPaused nonReentrant {\n\t\t_claimLockedToken(token, user, amount);\n\t}\n\n\t/// @notice Claims locked tokens for a specified user by percentage.\n\t/// @dev Only accounts with OPERATOR_ROLE can call this function.\n\t/// @param token Address of the token.\n\t/// @param user Address of the user.\n\t/// @param percentage Percentage of locked tokens to claim (between 0 and 1 -- 1 for 100%).\n\tfunction claimLockedTokenForByPercentage(\n\t\taddress token,\n\t\taddress user,\n\t\tuint256 percentage\n\t) external onlyRole(OPERATOR_ROLE) whenNotPaused nonReentrant {\n\t\t_claimLockedToken(token, user, (getLockedAmountsForToken(user, token) * percentage) / 1e18);\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Internal Functions\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Internal function to set up vesting plans for multiple users.\n\t/// @dev Reverts if the users and amounts arrays have different lengths.\n\t/// @param token Address of the token.\n\t/// @param startTime Vesting start time.\n\t/// @param endTime Vesting end time.\n\t/// @param users Array of user addresses.\n\t/// @param amounts Array of token amounts.\n\tfunction _setupVestingPlans(address token, uint256 startTime, uint256 endTime, address[] memory users, uint256[] memory amounts) internal {\n\t\tif (users.length != amounts.length) revert MismatchArrays();\n\t\tuint256 len = users.length;\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\taddress user = users[i];\n\t\t\tuint256 amount = amounts[i];\n\t\t\ttotalVested[token] += amount;\n\t\t\tVestingPlan storage vestingPlan = vestingPlans[token][user];\n\t\t\tvestingPlan.setup(amount, startTime, endTime);\n\t\t\temit VestingPlanSetup(token, user, amount, startTime, endTime);\n\t\t}\n\t}\n\n\t/// @notice Internal function to reset vesting plans for multiple users.\n\t/// @dev Reverts if the users and amounts arrays have different lengths or if any user's claimed amount exceeds the new amount.\n\t/// @param token Address of the token.\n\t/// @param users Array of user addresses.\n\t/// @param amounts Array of new token amounts.\n\tfunction _resetVestingPlans(address token, address[] memory users, uint256[] memory amounts) internal {\n\t\tif (users.length != amounts.length) revert MismatchArrays();\n\t\tuint256 len = users.length;\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\taddress user = users[i];\n\t\t\tuint256 amount = amounts[i];\n\t\t\t// Claim any unlocked tokens before resetting.\n\t\t\t_claimUnlockedToken(token, user);\n\t\t\tVestingPlan storage vestingPlan = vestingPlans[token][user];\n\t\t\tif (amount < vestingPlan.unlockedAmount()) revert AlreadyClaimedMoreThanThis();\n\t\t\tuint256 oldTotal = vestingPlan.lockedAmount();\n\t\t\tvestingPlan.resetAmount(amount);\n\t\t\ttotalVested[token] = totalVested[token] - oldTotal + amount;\n\t\t\temit VestingPlanReset(token, user, amount);\n\t\t}\n\t}\n\n\t/// @notice Checks if the contract holds enough of the token, and if not, calls a minting hook.\n\t/// @param token The address of the token.\n\t/// @param amount The required amount.\n\tfunction _ensureSufficientBalance(address token, uint256 amount) internal virtual {\n\t\tuint256 currentBalance = IERC20(token).balanceOf(address(this));\n\t\tif (currentBalance < amount) {\n\t\t\tuint256 deficit = amount - currentBalance;\n\t\t\t// This hook can be overridden to mint the token.\n\t\t\t_mintTokenIfPossible(token, deficit);\n\t\t}\n\t}\n\n\t/// @notice Virtual hook to mint tokens if the token supports minting. In the parent, this is a no-op.\n\t/// @param token The address of the token.\n\t/// @param amount The amount to mint.\n\tfunction _mintTokenIfPossible(address token, uint256 amount) internal virtual {\n\t\t// Default implementation does nothing.\n\t}\n\n\t/// @notice Internal function to claim unlocked tokens.\n\t/// @param token Address of the token.\n\t/// @param user Address of the user.\n\tfunction _claimUnlockedToken(address token, address user) internal {\n\t\tVestingPlan storage vestingPlan = vestingPlans[token][user];\n\t\tuint256 claimableAmount = vestingPlan.claimable();\n\n\t\t// Adjust the vesting plan\n\t\ttotalVested[token] -= claimableAmount;\n\t\tvestingPlan.claimedAmount += claimableAmount;\n\n\t\t// Ensure sufficient balance (minting if necessary)\n\t\t_ensureSufficientBalance(token, claimableAmount);\n\n\t\tIERC20(token).transfer(user, claimableAmount);\n\n\t\temit UnlockedTokenClaimed(token, user, claimableAmount);\n\t}\n\n\t/// @notice Internal function to claim locked tokens.\n\t/// @param token Address of the token.\n\t/// @param user Address of the user.\n\t/// @param amount Amount of locked tokens to claim.\n\tfunction _claimLockedToken(address token, address user, uint256 amount) internal {\n\t\t// First, claim any unlocked tokens.\n\t\t_claimUnlockedToken(token, user);\n\t\tVestingPlan storage vestingPlan = vestingPlans[token][user];\n\t\tif (vestingPlan.lockedAmount() < amount) revert InvalidAmount();\n\n\t\t// Adjust the vesting plan\n\t\tvestingPlan.resetAmount(vestingPlan.lockedAmount() - amount);\n\t\ttotalVested[token] -= amount;\n\t\tuint256 penalty = (amount * lockedClaimPenalty) / 1e18;\n\n\t\t// Ensure sufficient balance (minting if necessary)\n\t\t_ensureSufficientBalance(token, amount);\n\n\t\tIERC20(token).transfer(user, amount - penalty);\n\t\tIERC20(token).transfer(lockedClaimPenaltyReceiver, penalty);\n\n\t\temit LockedTokenClaimed(token, user, amount, penalty);\n\t}\n\n\t//--------------------------------------------------------------------------\n\t// Views\n\t//--------------------------------------------------------------------------\n\n\t/// @notice Returns the amount of tokens that are still locked for a user\n\t/// @param user Address of the user to check\n\t/// @param token Address of the token\n\t/// @return The amount of tokens still locked in the user's vesting schedule\n\tfunction getLockedAmountsForToken(address user, address token) public view returns (uint256) {\n\t\treturn vestingPlans[token][user].lockedAmount();\n\t}\n\n\t/// @notice Returns the amount of tokens that are currently claimable by a user\n\t/// @param user Address of the user to check\n\t/// @param token Address of the token\n\t/// @return The amount of tokens that can be claimed right now\n\tfunction getClaimableAmountsForToken(address user, address token) public view returns (uint256) {\n\t\treturn vestingPlans[token][user].claimable();\n\t}\n\n\t/// @notice Returns the amount of tokens that have been unlocked according to the vesting schedule\n\t/// @param user Address of the user to check\n\t/// @param token Address of the token\n\t/// @return The total amount of tokens that have been unlocked (claimed and unclaimed)\n\tfunction getUnlockedAmountForToken(address user, address token) public view returns (uint256) {\n\t\treturn vestingPlans[token][user].unlockedAmount();\n\t}\n}\n"
    }
}