{
    "vfp_id": "vfp_00004",
    "project_name": "Zenith - SSI Protocol Audit Report.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "addMintRequest() user may pay fees more than expected",
            "description": "1. **Description:** The addMintRequest function may cause users to pay higher fees than intended due to miscalculation or lack of fee capping.\n2. **Cause:** Insufficient fee validation or calculation logic.\n3. **Exploitation:** Users could be overcharged during minting requests.\n4. **Impact:** Financial loss for users and potential trust issues with the protocol.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetIssuer.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-250"
                ]
            },
            "title": "addMintRequest() gives swap maximum allowance, may be a security risk",
            "description": "1. **Description:** The addMintRequest function grants maximum ERC20 allowance to the swap contract, posing a security risk if the contract is compromised.\n2. **Cause:** Use of approve with max uint256 instead of precise amount.\n3. **Exploitation:** If the swap contract is exploited, an attacker could drain all of the user's tokens.\n4. **Impact:** Full loss of user funds associated with the approved token.\n",
            "severity": "Low",
            "location": [
                "AssetIssuer.sol::confirmMintRequest"
            ],
            "files": [
                "ssi-protocol/src/AssetIssuer.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "when status is CANCEL reject redeem request, May result in failure to close the request",
            "description": "1. **Description:** When a request is in CANCEL status, redeem requests are not properly rejected, potentially leaving requests open.\n2. **Cause:** Incomplete state handling for CANCEL status in redeem logic.\n3. **Exploitation:** Users may attempt to redeem on canceled requests, causing system errors or inconsistent state.\n4. **Impact:** State inconsistency and potential failure to finalize requests properly.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetIssuer.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Lack of zero value check for `issueFee` could DoS minting/redeeming",
            "description": "1. **Description:** The issueFee parameter is not checked for zero value, which could lead to denial of service in minting or redeeming functions.\n2. **Cause:** Missing input validation for issueFee.\n3. **Exploitation:** Setting issueFee to zero could disable minting or redeeming by breaking expected logic flows.\n4. **Impact:** Users may be unable to mint or redeem tokens, resulting in a denial of service.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ssi-protocol/src/AssetIssuer.sol"
            ]
        }
    ],
    "affected_files": {
        "AssetIssuer.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport \"./Interface.sol\";\nimport {AssetController} from \"./AssetController.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {EnumerableMap} from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Utils} from './Utils.sol';\n\nimport \"forge-std/console.sol\";\n\ncontract AssetIssuer is AssetController, IAssetIssuer {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IAssetToken;\n    // participians\n    using EnumerableSet for EnumerableSet.AddressSet;\n    mapping(uint256 assetID => EnumerableSet.AddressSet) private _participants;\n    using EnumerableMap for EnumerableMap.UintToUintMap;\n    // issue fee\n    EnumerableMap.UintToUintMap private _issueFees;\n    // issue min amount\n    EnumerableMap.UintToUintMap private _minAmounts;\n    // issue max amount\n    EnumerableMap.UintToUintMap private _maxAmounts;\n\n    Request[] mintRequests;\n    Request[] redeemRequests;\n\n    uint256 public feeDecimals = 8;\n\n    event SetIssueAmountRange(uint indexed assetID, uint min, uint max);\n    event SetIssueFee(uint indexed assetID, uint issueFee);\n    event AddParticipant(uint indexed assetID, address participant);\n    event RemoveParticipant(uint indexed assetID, address participant);\n    event AddMintRequest(uint nonce);\n    event RejectMintRequest(uint nonce);\n    event ConfirmMintRequest(uint nonce);\n    event AddRedeemRequest(uint nonce);\n    event RejectRedeemRequest(uint nonce);\n    event ConfirmRedeemRequest(uint nonce);\n\n    constructor(address owner, address factoryAddress_)\n        AssetController(owner, factoryAddress_) {\n    }\n\n    function getIssueAmountRange(uint256 assetID) external view returns (Range memory) {\n        require(_minAmounts.contains(assetID) && _maxAmounts.contains(assetID), \"issue amount range not set\");\n        return Range({\n            min: _minAmounts.get(assetID),\n            max: _maxAmounts.get(assetID)\n        });\n    }\n\n    function setIssueAmountRange(uint256 assetID, Range calldata issueAmountRange) external onlyOwner {\n        require(issueAmountRange.min <= issueAmountRange.max && issueAmountRange.max > 0 && issueAmountRange.min > 0, \"wrong range\");\n        _minAmounts.set(assetID, issueAmountRange.min);\n        _maxAmounts.set(assetID, issueAmountRange.max);\n        emit SetIssueAmountRange(assetID, _minAmounts.get(assetID), _maxAmounts.get(assetID));\n    }\n\n    function getIssueFee(uint256 assetID) external view returns (uint256) {\n        require(_issueFees.contains(assetID), \"issue fee not set\");\n        return _issueFees.get(assetID);\n    }\n\n    function setIssueFee(uint256 assetID, uint256 issueFee) external onlyOwner {\n        require(issueFee < 10**feeDecimals, \"issueFee should less than 1\");\n        _issueFees.set(assetID, issueFee);\n        emit SetIssueFee(assetID, _issueFees.get(assetID));\n    }\n\n    // mint\n    function getMintRequestLength() external view returns (uint256) {\n        return mintRequests.length;\n    }\n\n    function getMintRequest(uint256 nonce) external view returns (Request memory) {\n        return mintRequests[nonce];\n    }\n\n    function addMintRequest(uint256 assetID, OrderInfo memory orderInfo) external whenNotPaused returns (uint) {\n        require(_participants[assetID].contains(msg.sender), \"msg sender not a participant\");\n        require(_minAmounts.contains(assetID) && _maxAmounts.contains(assetID), \"issue amount range not set\");\n        require(_issueFees.contains(assetID), \"issue fee not set\");\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        address assetTokenAddress = factory.assetTokens(assetID);\n        IAssetToken assetToken = IAssetToken(assetTokenAddress);\n        address swapAddress = factory.swap();\n        ISwap swap = ISwap(swapAddress);\n        require(assetToken.feeCollected(), \"has fee not collect\");\n        require(assetToken.rebalancing() == false, \"is rebalancing\");\n        require(swap.checkOrderInfo(orderInfo) == 0, \"order not valid\");\n        Order memory order = orderInfo.order;\n        require(keccak256(abi.encode(assetToken.getTokenset())) == keccak256(abi.encode(order.outTokenset)), \"tokenset not match\");\n        require(order.outAmount >= _minAmounts.get(assetID) && order.outAmount <= _maxAmounts.get(assetID), \"mint amount not in range\");\n        Token[] memory inTokenset = order.inTokenset;\n        uint256 issueFee = _issueFees.get(assetID);\n        for (uint i = 0; i < inTokenset.length; i++) {\n            require(bytes32(bytes(inTokenset[i].chain)) == bytes32(bytes(factory.chain())), \"chain not match\");\n            address tokenAddress = Utils.stringToAddress(inTokenset[i].addr);\n            IERC20 inToken = IERC20(tokenAddress);\n            uint inTokenAmount = inTokenset[i].amount * order.inAmount / 10**8;\n            uint feeTokenAmount = inTokenAmount * issueFee / 10**feeDecimals;\n            uint transferAmount = inTokenAmount + feeTokenAmount;\n            require(inToken.balanceOf(msg.sender) >= transferAmount, \"not enough balance\");\n            require(inToken.allowance(msg.sender, address(this)) >= transferAmount, \"not enough allowance\");\n            if (inToken.allowance(address(this), swapAddress) < inTokenAmount) {\n                inToken.forceApprove(swapAddress, type(uint256).max);\n            }\n            inToken.safeTransferFrom(msg.sender, address(this), transferAmount);\n        }\n        swap.addSwapRequest(orderInfo, true, false);\n        mintRequests.push(Request({\n            nonce: mintRequests.length,\n            requester: msg.sender,\n            assetTokenAddress: assetTokenAddress,\n            amount: order.outAmount,\n            swapAddress: swapAddress,\n            orderHash: orderInfo.orderHash,\n            status: RequestStatus.PENDING,\n            requestTimestamp: block.timestamp,\n            issueFee: issueFee\n        }));\n        assetToken.lockIssue();\n        emit AddMintRequest(mintRequests.length-1);\n        return mintRequests.length-1;\n    }\n\n    function rejectMintRequest(uint nonce, OrderInfo memory orderInfo) external onlyOwner {\n        require(nonce < mintRequests.length);\n        Request memory mintRequest = mintRequests[nonce];\n        checkRequestOrderInfo(mintRequest, orderInfo);\n        require(mintRequest.status == RequestStatus.PENDING);\n        ISwap swap = ISwap(mintRequest.swapAddress);\n        SwapRequest memory swapRequest = swap.getSwapRequest(mintRequest.orderHash);\n        require(swapRequest.status == SwapRequestStatus.REJECTED || swapRequest.status == SwapRequestStatus.CANCEL);\n        Order memory order = orderInfo.order;\n        Token[] memory inTokenset = order.inTokenset;\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        for (uint i = 0; i < inTokenset.length; i++) {\n            require(bytes32(bytes(inTokenset[i].chain)) == bytes32(bytes(factory.chain())), \"chain not match\");\n            address tokenAddress = Utils.stringToAddress(inTokenset[i].addr);\n            IERC20 inToken = IERC20(tokenAddress);\n            uint inTokenAmount = inTokenset[i].amount * order.inAmount / 10**8;\n            uint feeTokenAmount = inTokenAmount * mintRequest.issueFee / 10**feeDecimals;\n            uint transferAmount = inTokenAmount + feeTokenAmount;\n            require(inToken.balanceOf(address(this)) >= transferAmount, \"not enough balance\");\n            inToken.safeTransfer(mintRequest.requester, transferAmount);\n        }\n        IAssetToken assetToken = IAssetToken(mintRequest.assetTokenAddress);\n        assetToken.unlockIssue();\n        mintRequests[nonce].status = RequestStatus.REJECTED;\n        emit RejectMintRequest(nonce);\n    }\n\n    function confirmMintRequest(uint nonce, OrderInfo memory orderInfo, bytes[] memory inTxHashs) external onlyOwner {\n        require(nonce < mintRequests.length);\n        Request memory mintRequest = mintRequests[nonce];\n        checkRequestOrderInfo(mintRequest, orderInfo);\n        require(mintRequest.status == RequestStatus.PENDING);\n        ISwap swap = ISwap(mintRequest.swapAddress);\n        SwapRequest memory swapRequest = swap.getSwapRequest(mintRequest.orderHash);\n        require(swapRequest.status == SwapRequestStatus.MAKER_CONFIRMED);\n        swap.confirmSwapRequest(orderInfo, inTxHashs);\n        Token[] memory inTokenset = orderInfo.order.inTokenset;\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        address vault = factory.vault();\n        string memory chain = factory.chain();\n        Order memory order = orderInfo.order;\n        for (uint i = 0; i < inTokenset.length; i++) {\n            require(bytes32(bytes(inTokenset[i].chain)) == bytes32(bytes(chain)), \"chain not match\");\n            address tokenAddress = Utils.stringToAddress(inTokenset[i].addr);\n            IERC20 inToken = IERC20(tokenAddress);\n            uint inTokenAmount = inTokenset[i].amount * order.inAmount / 10**8;\n            uint feeTokenAmount = inTokenAmount * mintRequest.issueFee / 10**feeDecimals;\n            require(inToken.balanceOf(address(this)) >= feeTokenAmount, \"not enough balance\");\n            inToken.safeTransfer(vault, feeTokenAmount);\n        }\n        IAssetToken assetToken = IAssetToken(mintRequest.assetTokenAddress);\n        assetToken.mint(mintRequest.requester, mintRequest.amount);\n        mintRequests[nonce].status = RequestStatus.CONFIRMED;\n        assetToken.unlockIssue();\n        emit ConfirmMintRequest(nonce);\n    }\n\n    // redeem\n\n    function getRedeemRequestLength() external view returns (uint256) {\n        return redeemRequests.length;\n    }\n\n    function getRedeemRequest(uint256 nonce) external view returns (Request memory) {\n        return redeemRequests[nonce];\n    }\n\n    function addRedeemRequest(uint256 assetID, OrderInfo memory orderInfo) external whenNotPaused returns (uint256) {\n        require(_participants[assetID].contains(msg.sender), \"msg sender not a participant\");\n        require(_minAmounts.contains(assetID) && _maxAmounts.contains(assetID), \"issue amount range not set\");\n        require(_issueFees.contains(assetID), \"issue fee not set\");\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        address assetTokenAddress = factory.assetTokens(assetID);\n        IAssetToken assetToken = IAssetToken(assetTokenAddress);\n        address swapAddress = factory.swap();\n        ISwap swap = ISwap(swapAddress);\n        require(assetToken.hasRole(assetToken.ISSUER_ROLE(), address(this)), \"not a issuer\");\n        require(assetToken.feeCollected(), \"has fee not collect\");\n        require(assetToken.rebalancing() == false, \"is rebalancing\");\n        require(swap.checkOrderInfo(orderInfo) == 0, \"order not valid\");\n        Order memory order = orderInfo.order;\n        require(keccak256(abi.encode(assetToken.getTokenset())) == keccak256(abi.encode(order.inTokenset)), \"tokenset not match\");\n        require(order.inAmount >= _minAmounts.get(assetID) && order.inAmount <= _maxAmounts.get(assetID), \"redeem amount not in range\");\n        require(assetToken.balanceOf(msg.sender) >= order.inAmount, \"not enough asset token balance\");\n        require(assetToken.allowance(msg.sender, address(this)) >= order.inAmount, \"not enough asset token allowance\");\n        Token[] memory outTokenset = order.outTokenset;\n        for (uint i = 0; i < outTokenset.length; i++) {\n            require(bytes32(bytes(outTokenset[i].chain)) == bytes32(bytes(factory.chain())), \"chain not match\");\n            require(Utils.stringToAddress(order.outAddressList[i]) == address(this), \"out address not valid\");\n        }\n        assetToken.safeTransferFrom(msg.sender, address(this), order.inAmount);\n        swap.addSwapRequest(orderInfo, false, true);\n        redeemRequests.push(Request({\n            nonce: redeemRequests.length,\n            requester: msg.sender,\n            assetTokenAddress: assetTokenAddress,\n            amount: order.inAmount,\n            swapAddress: swapAddress,\n            orderHash: orderInfo.orderHash,\n            status: RequestStatus.PENDING,\n            requestTimestamp: block.timestamp,\n            issueFee: _issueFees.get(assetID)\n        }));\n        assetToken.lockIssue();\n        emit AddRedeemRequest(redeemRequests.length - 1);\n        return redeemRequests.length - 1;\n    }\n\n    function rejectRedeemRequest(uint nonce) external onlyOwner {\n        require(nonce < redeemRequests.length, \"nonce too large\");\n        Request memory redeemRequest = redeemRequests[nonce];\n        require(redeemRequest.status == RequestStatus.PENDING, \"redeem request is not pending\");\n        ISwap swap = ISwap(redeemRequest.swapAddress);\n        SwapRequest memory swapRequest = swap.getSwapRequest(redeemRequest.orderHash);\n        require(swapRequest.status == SwapRequestStatus.REJECTED, \"swap request is not rejected\");\n        IAssetToken assetToken = IAssetToken(redeemRequest.assetTokenAddress);\n        require(assetToken.balanceOf(address(this)) >= redeemRequest.amount, \"not enough asset token to transfer\");\n        assetToken.safeTransfer(redeemRequest.requester, redeemRequest.amount);\n        redeemRequests[nonce].status = RequestStatus.REJECTED;\n        assetToken.unlockIssue();\n        emit RejectRedeemRequest(nonce);\n    }\n\n    function confirmRedeemRequest(uint nonce, OrderInfo memory orderInfo, bytes[] memory inTxHashs) external onlyOwner {\n        require(nonce < redeemRequests.length);\n        Request memory redeemRequest = redeemRequests[nonce];\n        checkRequestOrderInfo(redeemRequest, orderInfo);\n        require(redeemRequest.status == RequestStatus.PENDING);\n        ISwap swap = ISwap(redeemRequest.swapAddress);\n        SwapRequest memory swapRequest = swap.getSwapRequest(redeemRequest.orderHash);\n        require(swapRequest.status == SwapRequestStatus.MAKER_CONFIRMED);\n        swap.confirmSwapRequest(orderInfo, inTxHashs);\n        IAssetToken assetToken = IAssetToken(redeemRequest.assetTokenAddress);\n        require(assetToken.balanceOf(address(this)) >= redeemRequest.amount, \"not enough asset token to burn\");\n        Order memory order = orderInfo.order;\n        Token[] memory outTokenset = order.outTokenset;\n        address vault = IAssetFactory(factoryAddress).vault();\n        for (uint i = 0; i < outTokenset.length; i++) {\n            address tokenAddress = Utils.stringToAddress(outTokenset[i].addr);\n            IERC20 outToken = IERC20(tokenAddress);\n            uint outTokenAmount = outTokenset[i].amount * order.outAmount / 10**8;\n            uint feeTokenAmount = outTokenAmount * redeemRequest.issueFee / 10**feeDecimals;\n            uint transferAmount = outTokenAmount - feeTokenAmount;\n            require(outToken.balanceOf(address(this)) >= outTokenAmount, \"not enough balance\");\n            outToken.safeTransfer(redeemRequest.requester, transferAmount);\n            outToken.safeTransfer(vault, feeTokenAmount);\n        }\n        assetToken.burn(redeemRequest.amount);\n        redeemRequests[nonce].status = RequestStatus.CONFIRMED;\n        assetToken.unlockIssue();\n        emit ConfirmRedeemRequest(nonce);\n    }\n\n    function isParticipant(uint256 assetID, address participant) external view returns (bool) {\n        return _participants[assetID].contains(participant);\n    }\n\n    function getParticipants(uint256 assetID) external view returns (address[] memory) {\n        address[] memory participants = new address[](_participants[assetID].length());\n        for (uint i = 0; i < participants.length; i++) {\n            participants[i] = _participants[assetID].at(i);\n        }\n        return participants;\n    }\n\n    function getParticipantLength(uint256 assetID) external view returns (uint256) {\n        return _participants[assetID].length();\n    }\n\n    function getParticipant(uint256 assetID, uint256 idx) external view returns (address) {\n        require(idx < _participants[assetID].length(), \"out of range\");\n        return _participants[assetID].at(idx);\n    }\n\n    function addParticipant(uint256 assetID, address participant) external onlyOwner {\n        if (_participants[assetID].add(participant)) {\n            emit AddParticipant(assetID, participant);\n        }\n    }\n\n    function removeParticipant(uint256 assetID, address participant) external onlyOwner {\n        if (_participants[assetID].remove(participant)) {\n            emit RemoveParticipant(assetID, participant);\n        }\n    }\n\n    function withdraw(address[] memory tokenAddresses) external onlyOwner {\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        uint256[] memory assetIDs = factory.getAssetIDs();\n        for (uint i = 0; i < assetIDs.length; i++) {\n            IAssetToken assetToken = IAssetToken(factory.assetTokens(assetIDs[i]));\n            require(!assetToken.issuing(), \"is issuing\");\n        }\n        for (uint i = 0; i < tokenAddresses.length; i++) {\n            if (tokenAddresses[i] != address(0)) {\n                IERC20 token = IERC20(tokenAddresses[i]);\n                token.safeTransfer(owner(), token.balanceOf(address(this)));\n            }\n        }\n    }\n\n    function burnFor(uint256 assetID, uint256 amount) external whenNotPaused {\n        IAssetFactory factory = IAssetFactory(factoryAddress);\n        IAssetToken assetToken = IAssetToken(factory.assetTokens(assetID));\n        require(assetToken.allowance(msg.sender, address(this)) >= amount, \"not enough allowance\");\n        assetToken.lockIssue();\n        assetToken.safeTransferFrom(msg.sender, address(this), amount);\n        assetToken.burn(amount);\n        assetToken.unlockIssue();\n    }\n}"
    }
}