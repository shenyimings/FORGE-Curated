{
    "vfp_id": "vfp_00242",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "A Transaction Can Be Canceled After Execution",
            "description": "The Timelock contract allows calling cancelTransaction on an already executed transaction, which emits a misleading CancelTransaction event.\nCause: The function does not check the state of the transaction before allowing cancellation.\nExploitation: An attacker or user could cancel an already executed transaction, resulting in a confusing event log that suggests a transaction was canceled when it was already completed.\nImpact: While the underlying state is not altered, the emitted event can mislead off-chain monitoring tools and create confusion in governance tracking.\n",
            "severity": "Low",
            "location": [
                "Timelock::cancelTransaction"
            ],
            "files": [
                "permissionless/contracts/market/TimeLock.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Timelock Transactions Can Be Executed Before the ETA",
            "description": "The Timelock.executeTransaction() function incorrectly checks that the current block timestamp is <= ETA, allowing execution only before the scheduled time. This is the opposite of intended behavior, where execution should only occur after ETA. An attacker with access to the timelock (e.g., via governance) could execute transactions prematurely. The impact includes bypassing the timelock delay, undermining governance security and enabling rushed malicious changes.\n",
            "severity": "High",
            "location": [
                "Timelock.sol::executeTransaction"
            ],
            "files": [
                "permissionless/contracts/market/TimeLock.sol"
            ]
        }
    ],
    "affected_files": {
        "TimeLock.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {ITimeLock} from \"../interfaces/ITimeLock.sol\";\n\ncontract TimeLock is ITimeLock {\n    uint256 public constant override GRACE_PERIOD = 14 days;\n    uint256 public constant override MINIMUM_DELAY = 1 days;\n    uint256 public constant override MAXIMUM_DELAY = 30 days;\n\n    address public immutable override admin;\n    uint256 public override delay;\n\n    mapping(bytes32 txHash => bool) public override queuedTransactions;\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert CallerIsNotSelfException(msg.sender);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert CallerIsNotAdminException(msg.sender);\n        _;\n    }\n\n    constructor(address admin_, uint256 delay_) {\n        if (delay_ < MINIMUM_DELAY || delay_ > MAXIMUM_DELAY) revert IncorrectDelayException();\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 newDelay) external override onlySelf {\n        if (newDelay < MINIMUM_DELAY || newDelay > MAXIMUM_DELAY) revert IncorrectDelayException();\n        delay = newDelay;\n\n        emit NewDelay(newDelay);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta)\n        external\n        onlyAdmin\n        returns (bytes32)\n    {\n        if (eta < block.timestamp + delay) revert DelayNotSatisfiedException();\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta)\n        external\n        onlyAdmin\n    {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta)\n        external\n        payable\n        onlyAdmin\n        returns (bytes memory)\n    {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (!queuedTransactions[txHash]) revert TransactionIsNotQueuedException(txHash);\n        if (block.timestamp > eta) revert TimelockNotSurpassedException();\n        if (block.timestamp > eta + GRACE_PERIOD) revert StaleTransactionException(txHash);\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        if (!success) revert TransactionExecutionRevertedException(txHash);\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n}\n"
    }
}