{
    "vfp_id": "vfp_00601",
    "project_name": "Lido V3 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing `requestFeeLimit` Validation for EIP-7002 and EIP-7251",
            "description": "The `triggerValidatorWithdrawals` and `addConsolidationRequest` functions do not enforce a maximum `requestFeeLimit` as defined in EIP-7002 and EIP-7251, allowing excessive fees to be submitted.\n\nThe root cause is the absence of a fee cap check, enabling users to submit arbitrarily high fees that are partially refunded, creating a griefing vector.\n\nAn attacker could exploit this by submitting thousands of withdrawal requests with high fees, causing exponential fee growth in the queue and blocking legitimate exits, especially during a depeg event.\n\nThe impact is denial of service for validator exits, potential loss of user funds due to excessive fee burns, and systemic instability during critical periods.\n",
            "severity": "Medium",
            "location": [
                "StakingVault.sol::triggerValidatorWithdrawals#L370-L379",
                "ValidatorConsolidationRequests.sol::addConsolidationRequest#L122-L132"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/StakingVault.sol"
            ]
        }
    ],
    "affected_files": {
        "StakingVault.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {OwnableUpgradeable} from \"contracts/openzeppelin/5.2/upgradeable/access/OwnableUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"contracts/openzeppelin/5.2/upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {TriggerableWithdrawals} from \"contracts/common/lib/TriggerableWithdrawals.sol\";\nimport {IDepositContract} from \"contracts/common/interfaces/IDepositContract.sol\";\n\nimport {PinnedBeaconUtils} from \"./lib/PinnedBeaconUtils.sol\";\nimport {IStakingVault} from \"./interfaces/IStakingVault.sol\";\n\n/**\n * @title StakingVault\n * @author Lido\n * @notice\n *\n * StakingVault is a contract which is designed to be used as withdrawal credentials\n * to stake ETH with a designated node operator, while being able to mint stETH.\n *\n * The StakingVault can be used as a backing for minting new stETH through integration with the VaultHub.\n * When minting stETH backed by the StakingVault, the VaultHub designates a portion of the StakingVault's\n * total value as locked, which cannot be withdrawn by the owner. This locked portion represents the\n * collateral for the minted stETH.\n *\n * PinnedBeaconProxy\n * The contract is designed as an extended beacon proxy implementation, allowing individual StakingVault instances\n * to be ossified (pinned) to prevent future upgrades. The implementation is petrified (non-initializable)\n * and contains immutable references to the beacon chain deposit contract.\n */\ncontract StakingVault is IStakingVault, Ownable2StepUpgradeable {\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            CONSTANTS                         │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Version of the contract on the implementation\n     *         The implementation is petrified to this version\n     */\n    uint64 private constant _VERSION = 1;\n\n    /**\n     * @notice The type of withdrawal credentials for the validators deposited from this `StakingVault`.\n     */\n    uint256 private constant WC_0X02_PREFIX = 0x02 << 248;\n\n    /**\n     * @notice The length of the public key in bytes\n     */\n    uint256 private constant PUBLIC_KEY_LENGTH = 48;\n\n    /**\n     * @notice Storage offset slot for ERC-7201 namespace\n     *         The storage namespace is used to prevent upgrade collisions\n     *         `keccak256(abi.encode(uint256(keccak256(\"Lido.Vaults.StakingVault\")) - 1)) & ~bytes32(uint256(0xff))`\n     */\n    bytes32 private constant ERC7201_SLOT = 0x2ec50241a851d8d3fea472e7057288d4603f7a7f78e6d18a9c12cad84552b100;\n\n    /**\n     * @notice Address of `BeaconChainDepositContract`\n     *         Set immutably in the constructor to avoid storage costs\n     */\n    IDepositContract public immutable DEPOSIT_CONTRACT;\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            STATE                             │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @dev ERC-7201: Namespaced Storage Layout\n     */\n    struct Storage {\n        address nodeOperator;\n        address depositor;\n        bool beaconChainDepositsPaused;\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            INITIALIZATION                    │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @dev Fixes the deposit contract address. Disables reinitialization of the implementation.\n     */\n    constructor(address _beaconChainDepositContract) {\n        if (_beaconChainDepositContract == address(0)) revert ZeroArgument(\"_beaconChainDepositContract\");\n        DEPOSIT_CONTRACT = IDepositContract(_beaconChainDepositContract);\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes `StakingVault` with an owner, node operator, and depositor\n     * @param _owner Address of the owner\n     * @param _nodeOperator Address of the node operator\n     * @param _depositor Address of the depositor\n     */\n    function initialize(address _owner, address _nodeOperator, address _depositor) external initializer {\n        if (_nodeOperator == address(0)) revert ZeroArgument(\"_nodeOperator\");\n\n        __Ownable_init(_owner);\n        __Ownable2Step_init();\n        _setDepositor(_depositor);\n        _storage().nodeOperator = _nodeOperator;\n\n        emit NodeOperatorSet(_nodeOperator);\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            VIEW FUNCTIONS                    │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Returns the highest version that has been initialized as uint64\n     */\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /**\n     * @notice Returns the version of the contract as uint64\n     */\n    function version() external pure returns (uint64) {\n        return _VERSION;\n    }\n\n    /**\n     * @notice Returns owner of the contract\n     * @dev Fixes solidity interface inference\n     */\n    function owner() public view override(IStakingVault, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    /**\n     * @notice Returns the pending owner of the contract\n     * @dev Fixes solidity interface inference\n     */\n    function pendingOwner() public view override(IStakingVault, Ownable2StepUpgradeable) returns (address) {\n        return Ownable2StepUpgradeable.pendingOwner();\n    }\n\n    /**\n     * @notice Returns the node operator address\n     * @return Address of the node operator\n     */\n    function nodeOperator() public view returns (address) {\n        return _storage().nodeOperator;\n    }\n\n    /**\n     * @notice Returns the depositor address\n     * @return Address of the depositor\n     */\n    function depositor() public view returns (address) {\n        return _storage().depositor;\n    }\n\n    /**\n     * @notice Returns whether the vault is ossified\n     * @return True if the vault is ossified, false otherwise\n     */\n    function isOssified() public view returns (bool) {\n        return PinnedBeaconUtils.ossified();\n    }\n\n    /**\n     * @notice Returns the 0x02-type withdrawal credentials for the validators deposited from this `StakingVault`\n     *         All consensus layer rewards are sent to this contract. Only 0x02-type withdrawal credentials are supported\n     * @return Bytes32 value of the withdrawal credentials\n     */\n    function withdrawalCredentials() public view returns (bytes32) {\n        return bytes32(WC_0X02_PREFIX | uint160(address(this)));\n    }\n\n    /**\n     * @notice Calculates the total fee required for EIP-7002 withdrawals for a given number of validator keys\n     * @param _numberOfKeys Number of validators' public keys\n     * @return Total fee amount to pass as `msg.value` (wei)\n     * @dev    The fee may change from block to block\n     */\n    function calculateValidatorWithdrawalFee(uint256 _numberOfKeys) external view returns (uint256) {\n        return _numberOfKeys * TriggerableWithdrawals.getWithdrawalRequestFee();\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            BALANCE OPERATIONS                │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @dev Transfers ether directly to the `StakingVault`\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Funds the `StakingVault` with ether\n     */\n    function fund() external payable onlyOwner {\n        if (msg.value == 0) revert ZeroArgument(\"msg.value\");\n\n        emit EtherFunded(msg.value);\n    }\n\n    /**\n     * @notice Withdraws ether from the vault\n     * @param _recipient Address to send the ether to\n     * @param _ether Amount of ether to withdraw\n     */\n    function withdraw(address _recipient, uint256 _ether) external onlyOwner {\n        if (_recipient == address(0)) revert ZeroArgument(\"_recipient\");\n        if (_ether == 0) revert ZeroArgument(\"_ether\");\n        if (_ether > address(this).balance) revert InsufficientBalance(address(this).balance, _ether);\n\n        (bool success, ) = _recipient.call{value: _ether}(\"\");\n        if (!success) revert TransferFailed(_recipient, _ether);\n\n        emit EtherWithdrawn(_recipient, _ether);\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            BEACON CHAIN DEPOSITS             │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Returns whether the beacon chain deposits are paused\n     */\n    function beaconChainDepositsPaused() external view returns (bool) {\n        return _storage().beaconChainDepositsPaused;\n    }\n\n    /**\n     * @notice Pauses deposits to beacon chain\n     */\n    function pauseBeaconChainDeposits() external onlyOwner {\n        Storage storage $ = _storage();\n        if ($.beaconChainDepositsPaused) revert BeaconChainDepositsAlreadyPaused();\n\n        $.beaconChainDepositsPaused = true;\n\n        emit BeaconChainDepositsPaused();\n    }\n\n    /**\n     * @notice Resumes deposits to beacon chain\n     */\n    function resumeBeaconChainDeposits() external onlyOwner {\n        Storage storage $ = _storage();\n        if (!$.beaconChainDepositsPaused) revert BeaconChainDepositsAlreadyResumed();\n\n        $.beaconChainDepositsPaused = false;\n\n        emit BeaconChainDepositsResumed();\n    }\n\n    /**\n     * @notice Performs deposits to the beacon chain\n     * @param _deposits Array of validator deposits\n     */\n    function depositToBeaconChain(Deposit[] calldata _deposits) external {\n        if (_deposits.length == 0) revert ZeroArgument(\"_deposits\");\n        Storage storage $ = _storage();\n        if ($.beaconChainDepositsPaused) revert BeaconChainDepositsOnPause();\n        if (msg.sender != $.depositor) revert SenderNotDepositor();\n\n        uint256 numberOfDeposits = _deposits.length;\n\n        uint256 totalAmount;\n        for (uint256 i = 0; i < numberOfDeposits; i++) {\n            totalAmount += _deposits[i].amount;\n        }\n\n        if (totalAmount > address(this).balance) revert InsufficientBalance(address(this).balance, totalAmount);\n\n        bytes memory withdrawalCredentials_ = bytes.concat(withdrawalCredentials());\n\n        for (uint256 i = 0; i < numberOfDeposits; i++) {\n            Deposit calldata deposit = _deposits[i];\n\n            DEPOSIT_CONTRACT.deposit{value: deposit.amount}(\n                deposit.pubkey,\n                withdrawalCredentials_,\n                deposit.signature,\n                deposit.depositDataRoot\n            );\n        }\n\n        emit DepositedToBeaconChain(numberOfDeposits, totalAmount);\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │          BEACON CHAIN WITHDRAWALS            │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Requests node operator to exit validators from the beacon chain\n     *         It does not directly trigger exits - node operators must monitor for these events and handle the exits\n     * @param _pubkeys Concatenated validator public keys, each 48 bytes long\n     */\n    function requestValidatorExit(bytes calldata _pubkeys) external onlyOwner {\n        if (_pubkeys.length == 0) revert ZeroArgument(\"_pubkeys\");\n        if (_pubkeys.length % PUBLIC_KEY_LENGTH != 0) {\n            revert InvalidPubkeysLength();\n        }\n\n        uint256 keysCount = _pubkeys.length / PUBLIC_KEY_LENGTH;\n        for (uint256 i = 0; i < keysCount; i++) {\n            bytes memory pubkey = _pubkeys[i * PUBLIC_KEY_LENGTH:(i + 1) * PUBLIC_KEY_LENGTH];\n            emit ValidatorExitRequested(/* indexed */ pubkey, pubkey);\n        }\n    }\n\n    /**\n     * @notice Triggers validator withdrawals from the beacon chain using EIP-7002 triggerable withdrawals.\n     *         A general-purpose function for withdrawing ether from the beacon chain by the owner.\n     *         If the amount of ether to withdraw is not specified, the full balance of the validator is withdrawn.\n     * @param _pubkeys Concatenated validators public keys, each 48 bytes long\n     * @param _amounts Amounts of ether to withdraw. If array is empty or amount value is zero, triggers full withdrawals.\n     * @param _excessRefundRecipient Address to receive any excess withdrawal fee\n     * @dev    The caller must provide sufficient fee via msg.value to cover the withdrawal request costs\n     * @dev    You can use `calculateValidatorWithdrawalFee` to calculate the fee but it's accurate only for the block\n     *         it's called. The fee may change from block to block, so it's recommended to send fee with some surplus.\n     *         The excess amount will be refunded.\n     */\n    function triggerValidatorWithdrawals(\n        bytes calldata _pubkeys,\n        uint64[] calldata _amounts,\n        address _excessRefundRecipient\n    ) external payable onlyOwner {\n        if (msg.value == 0) revert ZeroArgument(\"msg.value\");\n        if (_pubkeys.length == 0) revert ZeroArgument(\"_pubkeys\");\n        if (_pubkeys.length % PUBLIC_KEY_LENGTH != 0) revert InvalidPubkeysLength();\n\n        // If amounts array is not empty, validate its length matches pubkeys\n        if (_amounts.length > 0 && _pubkeys.length / PUBLIC_KEY_LENGTH != _amounts.length) {\n            revert PubkeyLengthDoesNotMatchAmountLength();\n        }\n\n        // If the refund recipient is not set, use the sender as the refund recipient\n        if (_excessRefundRecipient == address(0)) _excessRefundRecipient = msg.sender;\n\n        uint256 feePerRequest = TriggerableWithdrawals.getWithdrawalRequestFee();\n        uint256 totalFee = (_pubkeys.length / PUBLIC_KEY_LENGTH) * feePerRequest;\n        if (msg.value < totalFee) revert InsufficientValidatorWithdrawalFee(msg.value, totalFee);\n\n        // If amounts array is empty, trigger full withdrawals, otherwise use amount-driven withdrawal types\n        if (_amounts.length == 0) {\n            TriggerableWithdrawals.addFullWithdrawalRequests(_pubkeys, feePerRequest);\n        } else {\n            TriggerableWithdrawals.addWithdrawalRequests(_pubkeys, _amounts, feePerRequest);\n        }\n\n        uint256 excess = msg.value - totalFee;\n        if (excess > 0) {\n            (bool success, ) = _excessRefundRecipient.call{value: excess}(\"\");\n            if (!success) revert TransferFailed(_excessRefundRecipient, excess);\n        }\n\n        emit ValidatorWithdrawalsTriggered(_pubkeys, _amounts, excess, _excessRefundRecipient);\n    }\n\n    /**\n     * @notice Triggers EIP-7002 validator exits by the node operator.\n     *         Because the node operator cannot ensure that all the associated validators are under control,\n     *         the node operator has the ability to forcefully eject validators.\n     * @param _pubkeys Concatenated validators public keys, each 48 bytes long\n     * @param _refundRecipient Address to receive the fee refund, if zero, refunds go to msg.sender\n     * @dev    The caller must provide sufficient fee via msg.value to cover the withdrawal request costs\n     * @dev    Use `calculateValidatorWithdrawalFee` to calculate the fee\n     */\n    function ejectValidators(bytes calldata _pubkeys, address _refundRecipient) external payable {\n        if (msg.value == 0) revert ZeroArgument(\"msg.value\");\n        if (_pubkeys.length == 0) revert ZeroArgument(\"_pubkeys\");\n        if (_pubkeys.length % PUBLIC_KEY_LENGTH != 0) revert InvalidPubkeysLength();\n        if (msg.sender != _storage().nodeOperator) revert SenderNotNodeOperator();\n\n        // If the refund recipient is not set, use the sender as the refund recipient\n        if (_refundRecipient == address(0)) _refundRecipient = msg.sender;\n\n        uint256 feePerRequest = TriggerableWithdrawals.getWithdrawalRequestFee();\n        uint256 totalFee = (_pubkeys.length / PUBLIC_KEY_LENGTH) * feePerRequest;\n        if (msg.value < totalFee) revert InsufficientValidatorWithdrawalFee(msg.value, totalFee);\n\n        TriggerableWithdrawals.addFullWithdrawalRequests(_pubkeys, feePerRequest);\n\n        uint256 excess = msg.value - totalFee;\n        if (excess > 0) {\n            (bool success, ) = _refundRecipient.call{value: excess}(\"\");\n            if (!success) revert TransferFailed(_refundRecipient, excess);\n        }\n\n        emit ValidatorEjectionsTriggered(_pubkeys, excess, _refundRecipient);\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │           ADMINISTRATIVE FUNCTIONS           │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Accepts the pending owner\n     * @dev Fixes solidity interface inference\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() public override(IStakingVault, Ownable2StepUpgradeable) {\n        Ownable2StepUpgradeable.acceptOwnership();\n    }\n\n    /**\n     * @notice Transfers the ownership of the contract to a new owner\n     * @param _newOwner Address of the new owner\n     * @dev Fixes solidity interface inference\n     * @dev Can only be called by the owner\n     */\n    function transferOwnership(address _newOwner) public override(IStakingVault, Ownable2StepUpgradeable) {\n        Ownable2StepUpgradeable.transferOwnership(_newOwner);\n    }\n\n    /**\n     * @notice Sets the depositor address\n     * @param _depositor Address of the new depositor\n     */\n    function setDepositor(address _depositor) external onlyOwner {\n        _setDepositor(_depositor);\n    }\n\n    /**\n     * @notice Ossifies the current implementation. WARNING: This operation is irreversible.\n     * @dev vault can't be connected to the hub after ossification\n     */\n    function ossify() external onlyOwner {\n        if (isOssified()) revert VaultOssified();\n\n        PinnedBeaconUtils.ossify();\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │            INTERNAL FUNCTIONS                │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @dev Returns the storage struct for the ERC-7201 namespace\n     * @return $ storage struct for the ERC-7201 namespace\n     */\n    function _storage() private pure returns (Storage storage $) {\n        assembly {\n            $.slot := ERC7201_SLOT\n        }\n    }\n\n    /**\n     * @dev Sets the depositor address in the `StakingVault`\n     * @param _depositor Address of the new depositor\n     */\n    function _setDepositor(address _depositor) internal {\n        if (_depositor == address(0)) revert ZeroArgument(\"_depositor\");\n        if (_depositor == _storage().depositor) revert NewDepositorSameAsPrevious();\n        address previousDepositor = _storage().depositor;\n        _storage().depositor = _depositor;\n        emit DepositorSet(previousDepositor, _depositor);\n    }\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │                EVENTS                        │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Emitted when ether is funded to the `StakingVault`\n     * @param amount Amount of ether funded\n     */\n    event EtherFunded(uint256 amount);\n\n    /**\n     * @notice Emitted when ether is withdrawn from the `StakingVault`\n     * @param recipient Address that received the ether\n     * @param amount Amount of ether withdrawn\n     */\n    event EtherWithdrawn(address indexed recipient, uint256 amount);\n\n    /**\n     * @notice Emitted when the node operator is set in the `StakingVault`\n     * @param nodeOperator Address of the node operator\n     */\n    event NodeOperatorSet(address indexed nodeOperator);\n\n    /**\n     * @notice Emitted when the depositor is set in the `StakingVault`\n     * @param previousDepositor Previous depositor\n     * @param newDepositor New depositor\n     */\n    event DepositorSet(address indexed previousDepositor, address indexed newDepositor);\n\n    /**\n     * @notice Emitted when the beacon chain deposits are paused\n     */\n    event BeaconChainDepositsPaused();\n\n    /**\n     * @notice Emitted when the beacon chain deposits are resumed\n     */\n    event BeaconChainDepositsResumed();\n\n    /**\n     * @notice Emitted when ether is deposited to `DepositContract`.\n     * @param _deposits Number of validator deposits made.\n     * @param _totalAmount Total amount of ether deposited.\n     */\n    event DepositedToBeaconChain(uint256 _deposits, uint256 _totalAmount);\n\n    /**\n     * @notice Emitted when vault owner requests node operator to exit validators from the beacon chain\n     * @param pubkey Indexed public key of the validator to exit\n     * @param pubkeyRaw Raw public key of the validator to exit\n     * @dev    Signals to node operators that they should exit this validator from the beacon chain\n     */\n    event ValidatorExitRequested(bytes indexed pubkey, bytes pubkeyRaw);\n\n    /**\n     * @notice Emitted when validator withdrawals are requested via EIP-7002\n     * @param pubkeys Concatenated public keys of the validators to withdraw\n     * @param amounts Amounts of ether to withdraw per validator\n     * @param refundRecipient Address to receive any excess withdrawal fee\n     * @param excess Amount of excess fee refunded to recipient\n     */\n    event ValidatorWithdrawalsTriggered(\n        bytes pubkeys,\n        uint64[] amounts,\n        uint256 excess,\n        address indexed refundRecipient\n    );\n\n    /**\n     * @notice Emitted when validator ejections are triggered\n     * @param pubkeys Concatenated public keys of the validators to eject\n     * @param excess Amount of excess fee refunded to recipient\n     * @param refundRecipient Address to receive any excess withdrawal fee\n     */\n    event ValidatorEjectionsTriggered(\n        bytes pubkeys,\n        uint256 excess,\n        address indexed refundRecipient\n    );\n\n    /*\n     * ╔══════════════════════════════════════════════════╗\n     * ║ ┌──────────────────────────────────────────────┐ ║\n     * ║ │                ERRORS                        │ ║\n     * ║ └──────────────────────────────────────────────┘ ║\n     * ╚══════════════════════════════════════════════════╝\n     */\n\n    /**\n     * @notice Thrown when an invalid zero value is passed\n     * @param name Name of the argument that was zero\n     */\n    error ZeroArgument(string name);\n\n    /**\n     * @notice Thrown when the balance of the vault is insufficient\n     * @param _balance Balance of the vault\n     * @param _required Amount of ether required\n     */\n    error InsufficientBalance(uint256 _balance, uint256 _required);\n\n    /**\n     * @notice Thrown when the transfer of ether to a recipient fails\n     * @param recipient Address that was supposed to receive the transfer\n     * @param amount Amount that failed to transfer\n     */\n    error TransferFailed(address recipient, uint256 amount);\n\n    /**\n     * @notice Thrown when the new depositor is the same as the previous depositor\n     */\n    error NewDepositorSameAsPrevious();\n\n    /**\n     * @notice Thrown when the beacon chain deposits are already paused\n     */\n    error BeaconChainDepositsAlreadyPaused();\n\n    /**\n     * @notice Thrown when the beacon chain deposits are already resumed\n     */\n    error BeaconChainDepositsAlreadyResumed();\n\n    /**\n     * @notice Thrown when the beacon chain deposits are on pause\n     */\n    error BeaconChainDepositsOnPause();\n\n    /**\n     * @notice Thrown when the sender is not set as the depositor\n     */\n    error SenderNotDepositor();\n\n    /**\n     * @notice Thrown when the sender is not the node operator\n     */\n    error SenderNotNodeOperator();\n\n    /**\n     * @notice Thrown when the length of the validator public keys is invalid\n     */\n    error InvalidPubkeysLength();\n\n    /**\n     * @notice Thrown when the validator withdrawal fee is insufficient\n     * @param _passed Amount of ether passed to the function\n     * @param _required Amount of ether required to cover the fee\n     */\n    error InsufficientValidatorWithdrawalFee(uint256 _passed, uint256 _required);\n\n    /**\n     * @notice Thrown when the vault is already ossified\n     */\n    error VaultOssified();\n\n    /**\n     * @notice Thrown when the length of the validator public keys does not match the length of the amounts\n     */\n    error PubkeyLengthDoesNotMatchAmountLength();\n}\n"
    }
}