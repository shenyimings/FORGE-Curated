{
    "vfp_id": "vfp_00064",
    "project_name": "2025-01-bacon-labs-bunniv2-securityreview.pdf",
    "findings": [
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "cumulativeAmount0 can be greater than the cumulative amount computed through inverse functionality for certain LDFs",
            "description": "For certain Liquidity Density Functions (LDFs), the cumulativeAmount0 value can exceed the result of its inverse calculation, indicating a logical inconsistency. This is caused by imprecise or incorrect mathematical implementations in the LDF libraries, particularly in LibUniformDistribution. The current fix returns zero when the value exceeds a threshold, acting as a band-aid rather than a root-cause solution. An attacker could exploit this by manipulating tick values or pool states to trigger incorrect cumulative calculations, potentially affecting TWAP-based pricing or rebalance logic. The impact includes incorrect state representation and potential financial loss.\n",
            "severity": "Informational",
            "location": [
                "LibUniformDistribution.sol::cumulativeAmount0",
                "LibUniformDistribution.sol::inverseCumulativeAmount0"
            ],
            "files": [
                "7faae4718eecda1b33dc3abd894431ed2d16c929/bunni-v2/src/ldf/LibUniformDistribution.sol"
            ]
        }
    ],
    "affected_files": {
        "LibUniformDistribution.sol": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {console2} from \"forge-std/console2.sol\";\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {SqrtPriceMath} from \"@uniswap/v4-core/src/libraries/SqrtPriceMath.sol\";\n\nimport \"./ShiftMode.sol\";\nimport \"../lib/Math.sol\";\nimport \"../base/Constants.sol\";\n\nlibrary LibUniformDistribution {\n    using TickMath for int24;\n    using TickMath for uint160;\n    using FixedPointMathLib for *;\n    using SafeCastLib for uint256;\n\n    /// @dev (1 / SQRT_PRICE_MAX_REL_ERROR) is the maximum relative error allowed for TickMath.getSqrtPriceAtTick()\n    uint256 internal constant SQRT_PRICE_MAX_REL_ERROR = 1e8;\n\n    /// @dev Queries the liquidity density and the cumulative amounts at the given rounded tick.\n    /// @param roundedTick The rounded tick to query\n    /// @param tickSpacing The spacing of the ticks\n    /// @return liquidityDensityX96_ The liquidity density at the given rounded tick. Range is [0, 1]. Scaled by 2^96.\n    /// @return cumulativeAmount0DensityX96 The cumulative amount of token0 in the rounded ticks [roundedTick + tickSpacing, tickUpper)\n    /// @return cumulativeAmount1DensityX96 The cumulative amount of token1 in the rounded ticks [tickLower, roundedTick - tickSpacing]\n    function query(int24 roundedTick, int24 tickSpacing, int24 tickLower, int24 tickUpper)\n        internal\n        pure\n        returns (uint256 liquidityDensityX96_, uint256 cumulativeAmount0DensityX96, uint256 cumulativeAmount1DensityX96)\n    {\n        // compute liquidityDensityX96\n        liquidityDensityX96_ = liquidityDensityX96(roundedTick, tickSpacing, tickLower, tickUpper);\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint128 liquidity = uint128(Q96 / length);\n\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n\n        // compute cumulativeAmount0DensityX96 for the rounded tick to the right of the rounded current tick\n        if (roundedTick + tickSpacing >= tickUpper) {\n            // cumulativeAmount0DensityX96 is just 0\n            cumulativeAmount0DensityX96 = 0;\n        } else if (roundedTick + tickSpacing <= tickLower) {\n            cumulativeAmount0DensityX96 =\n                SqrtPriceMath.getAmount0Delta(sqrtRatioTickLower, sqrtRatioTickUpper, liquidity, false);\n        } else {\n            cumulativeAmount0DensityX96 = SqrtPriceMath.getAmount0Delta(\n                (roundedTick + tickSpacing).getSqrtPriceAtTick(), sqrtRatioTickUpper, liquidity, false\n            );\n        }\n\n        // compute cumulativeAmount1DensityX96 for the rounded tick to the left of the rounded current tick\n        if (roundedTick - tickSpacing < tickLower) {\n            // cumulativeAmount1DensityX96 is just 0\n            cumulativeAmount1DensityX96 = 0;\n        } else if (roundedTick >= tickUpper) {\n            cumulativeAmount1DensityX96 =\n                SqrtPriceMath.getAmount1Delta(sqrtRatioTickLower, sqrtRatioTickUpper, liquidity, false);\n        } else {\n            cumulativeAmount1DensityX96 =\n                SqrtPriceMath.getAmount1Delta(sqrtRatioTickLower, roundedTick.getSqrtPriceAtTick(), liquidity, false);\n        }\n    }\n\n    /// @dev Computes the cumulative amount of token0 in the rounded ticks [roundedTick, tickUpper).\n    function cumulativeAmount0(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint256 amount0) {\n        if (roundedTick >= tickUpper || tickLower >= tickUpper) {\n            // cumulativeAmount0DensityX96 is just 0\n            return 0;\n        } else if (roundedTick < tickLower) {\n            roundedTick = tickLower;\n        }\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint128 liquidity = (totalLiquidity / length).toUint128();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n        amount0 = SqrtPriceMath.getAmount0Delta(roundedTick.getSqrtPriceAtTick(), sqrtRatioTickUpper, liquidity, false);\n    }\n\n    /// @dev Computes the cumulative amount of token1 in the rounded ticks [tickLower, roundedTick].\n    function cumulativeAmount1(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint256 amount1) {\n        if (roundedTick < tickLower || tickLower >= tickUpper) {\n            // cumulativeAmount1DensityX96 is just 0\n            return 0;\n        } else if (roundedTick > tickUpper - tickSpacing) {\n            roundedTick = tickUpper - tickSpacing;\n        }\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint128 liquidity = (totalLiquidity / length).toUint128();\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        amount1 = SqrtPriceMath.getAmount1Delta(\n            sqrtRatioTickLower, (roundedTick + tickSpacing).getSqrtPriceAtTick(), liquidity, false\n        );\n    }\n\n    /// @dev Given a cumulativeAmount0, computes the rounded tick whose cumulativeAmount0 is closest to the input. Range is [tickLower, tickUpper].\n    ///      The returned tick will be the smallest rounded tick whose cumulativeAmount0 is less than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount0 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount0(\n        uint256 cumulativeAmount0_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bool success, int24 roundedTick) {\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint128 liquidity = (totalLiquidity / length).toUint128();\n\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n        uint160 sqrtPrice =\n            SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(sqrtRatioTickUpper, liquidity, cumulativeAmount0_, true);\n        if (sqrtPrice < sqrtRatioTickLower) {\n            return (false, 0);\n        }\n        int24 tick = sqrtPrice.getTickAtSqrtPrice();\n        if (tick % tickSpacing == 0) {\n            uint160 sqrtPriceAtTick = tick.getSqrtPriceAtTick();\n            if (\n                sqrtPrice - sqrtPriceAtTick > 1\n                    && (sqrtPrice - sqrtPriceAtTick).mulDiv(SQRT_PRICE_MAX_REL_ERROR, sqrtPrice) > 1\n            ) {\n                // getTickAtSqrtPrice erroneously rounded down to the rounded tick boundary\n                // need to round up to the next rounded tick\n                tick += tickSpacing;\n            } else {\n                tick += tickSpacing - 1;\n            }\n        } else {\n            tick += tickSpacing - 1;\n        }\n        success = true;\n        roundedTick = roundTickSingle(tick, tickSpacing);\n\n        // ensure roundedTick is within the valid range\n        if (roundedTick < tickLower || roundedTick > tickUpper) {\n            return (false, 0);\n        }\n    }\n\n    /// @dev Given a cumulativeAmount1, computes the rounded tick whose cumulativeAmount1 is closest to the input. Range is [tickLower - tickSpacing, tickUpper - tickSpacing].\n    ///      The returned tick will be the smallest rounded tick whose cumulativeAmount1 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount1 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount1(\n        uint256 cumulativeAmount1_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bool success, int24 roundedTick) {\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint128 liquidity = (totalLiquidity / length).toUint128();\n\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n        uint160 sqrtPrice = SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown(\n            sqrtRatioTickLower, liquidity, cumulativeAmount1_, true\n        );\n        if (sqrtPrice > sqrtRatioTickUpper) {\n            return (false, 0);\n        }\n        int24 tick = sqrtPrice.getTickAtSqrtPrice();\n        // handle the edge case where cumulativeAmount1_ is exactly the\n        // cumulative amount in [tickLower, tickUpper]\n        if (tick == tickUpper) {\n            tick -= 1;\n        }\n        success = true;\n        roundedTick = roundTickSingle(tick, tickSpacing);\n\n        // ensure roundedTick is within the valid range\n        if (roundedTick < tickLower - tickSpacing || roundedTick >= tickUpper) {\n            return (false, 0);\n        }\n\n        // ensure that roundedTick is not (tickLower - tickSpacing) when cumulativeAmount1_ is non-zero and rounding up\n        // this can happen if the corresponding cumulative density is too small\n        if (roundedTick == tickLower - tickSpacing && cumulativeAmount1_ != 0) {\n            return (true, tickLower);\n        }\n    }\n\n    function liquidityDensityX96(int24 roundedTick, int24 tickSpacing, int24 tickLower, int24 tickUpper)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (roundedTick < tickLower || roundedTick >= tickUpper) {\n            // roundedTick is outside of the distribution\n            return 0;\n        }\n        uint256 length = uint24((tickUpper - tickLower) / tickSpacing);\n        return Q96 / length;\n    }\n\n    /// @dev Combines several operations used during a swap into one function to save gas.\n    ///      Given a cumulative amount, it computes its inverse to find the closest rounded tick, then computes the cumulative amount at that tick,\n    ///      and finally computes the liquidity of the tick that will handle the remainder of the swap.\n    function computeSwap(\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bool success, int24 roundedTick, uint256 cumulativeAmount, uint256 swapLiquidity) {\n        if (exactIn == zeroForOne) {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round up to the rounded tick to the right\n            // e.g. go from 1.5 to 2\n            //       input\n            //      ├──────┤\n            // ┌──┬──┬──┬──┐\n            // │  │ █│██│██│\n            // │  │ █│██│██│\n            // └──┴──┴──┴──┘\n            // 0  1  2  3  4\n            //       │\n            //       ▼\n            //      rick\n            (success, roundedTick) = inverseCumulativeAmount0(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, tickLower, tickUpper\n            );\n            if (!success) return (false, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that (input - cum) is the remainder of the swap that will be handled by Uniswap math\n            //         cum\n            //       ├─────┤\n            // ┌──┬──┬──┬──┐\n            // │  │ █│██│██│\n            // │  │ █│██│██│\n            // └──┴──┴──┴──┘\n            // 0  1  2  3  4\n            //       │\n            //       ▼\n            //      rick\n            cumulativeAmount = cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, tickLower, tickUpper);\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            // because we got rick by rounding up, the liquidity of (rick - tickSpacing) is used by the Uniswap math\n            //    liq\n            //    ├──┤\n            // ┌──┬──┬──┬──┐\n            // │  │ █│██│██│\n            // │  │ █│██│██│\n            // └──┴──┴──┴──┘\n            // 0  1  2  3  4\n            //    │\n            //    ▼\n            //   rick - tickSpacing\n            swapLiquidity = (\n                liquidityDensityX96(roundedTick - tickSpacing, tickSpacing, tickLower, tickUpper) * totalLiquidity\n            ) >> 96;\n        } else {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round up to the rounded tick to the right\n            // e.g. go from 1.5 to 2\n            //  input\n            // ├──────┤\n            // ┌──┬──┬──┬──┐\n            // │██│██│█ │  │\n            // │██│██│█ │  │\n            // └──┴──┴──┴──┘\n            // 0  1  2  3  4\n            //       │\n            //       ▼\n            //      rick\n            (success, roundedTick) = inverseCumulativeAmount1(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, tickLower, tickUpper\n            );\n            if (!success) return (false, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that (input - cum) is the remainder of the swap that will be handled by Uniswap math\n            //   cum\n            // ├─────┤\n            // ┌──┬──┬──┬──┐\n            // │██│██│█ │  │\n            // │██│██│█ │  │\n            // └──┴──┴──┴──┘\n            // 0  1  2  3  4\n            //    │\n            //    ▼\n            //   rick - tickSpacing\n            cumulativeAmount =\n                cumulativeAmount1(roundedTick - tickSpacing, totalLiquidity, tickSpacing, tickLower, tickUpper);\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //       liq\n            //       ├──┤\n            // ┌──┬──┬──┬──┐\n            // │██│██│█ │  │\n            // │██│██│█ │  │\n            // └──┴──┴──┴──┘\n            // 0  1  2  3  4\n            //       │\n            //       ▼\n            //      rick\n            swapLiquidity = (liquidityDensityX96(roundedTick, tickSpacing, tickLower, tickUpper) * totalLiquidity) >> 96;\n        }\n    }\n\n    function isValidParams(int24 tickSpacing, uint24 twapSecondsAgo, bytes32 ldfParams) internal pure returns (bool) {\n        uint8 shiftMode = uint8(bytes1(ldfParams)); // use uint8 since we don't know if the value is in range yet\n        if (shiftMode != uint8(ShiftMode.STATIC)) {\n            // Shifting\n            // | shiftMode - 1 byte | offset - 3 bytes | length - 3 bytes |\n            int24 offset = int24(uint24(bytes3(ldfParams << 8))); // offset (in rounded ticks) of tickLower from the twap tick\n            int24 length = int24(uint24(bytes3(ldfParams << 32))); // length of the position in rounded ticks\n\n            return twapSecondsAgo != 0 && length > 0 && offset % tickSpacing == 0\n                && int256(length) * int256(tickSpacing) <= type(int24).max && shiftMode <= uint8(type(ShiftMode).max);\n        } else {\n            // Static\n            // | shiftMode - 1 byte | tickLower - 3 bytes | tickUpper - 3 bytes |\n            int24 tickLower = int24(uint24(bytes3(ldfParams << 8)));\n            int24 tickUpper = int24(uint24(bytes3(ldfParams << 32)));\n            (int24 minUsableTick, int24 maxUsableTick) =\n                (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n            return tickLower % tickSpacing == 0 && tickUpper % tickSpacing == 0 && tickLower < tickUpper\n                && tickLower >= minUsableTick && tickUpper <= maxUsableTick;\n        }\n    }\n\n    /// @return tickLower The lower tick of the distribution\n    /// @return tickUpper The upper tick of the distribution\n    function decodeParams(int24 twapTick, int24 tickSpacing, bytes32 ldfParams)\n        internal\n        pure\n        returns (int24 tickLower, int24 tickUpper, ShiftMode shiftMode)\n    {\n        shiftMode = ShiftMode(uint8(bytes1(ldfParams)));\n\n        if (shiftMode != ShiftMode.STATIC) {\n            // | shiftMode - 1 byte | offset - 3 bytes | length - 3 bytes |\n            int24 offset = int24(uint24(bytes3(ldfParams << 8))); // offset of tickLower from the twap tick\n            int24 length = int24(uint24(bytes3(ldfParams << 32))); // length of the position in rounded ticks\n            tickLower = roundTickSingle(twapTick + offset, tickSpacing);\n            tickUpper = tickLower + length * tickSpacing;\n\n            // bound distribution to be within the range of usable ticks\n            (int24 minUsableTick, int24 maxUsableTick) =\n                (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n            if (tickLower < minUsableTick) {\n                int24 tickLength = tickUpper - tickLower;\n                tickLower = minUsableTick;\n                tickUpper = int24(FixedPointMathLib.min(tickLower + tickLength, maxUsableTick));\n            } else if (tickUpper > maxUsableTick) {\n                int24 tickLength = tickUpper - tickLower;\n                tickUpper = maxUsableTick;\n                tickLower = int24(FixedPointMathLib.max(tickUpper - tickLength, minUsableTick));\n            }\n        } else {\n            // | shiftMode - 1 byte | tickLower - 3 bytes | tickUpper - 3 bytes |\n            tickLower = int24(uint24(bytes3(ldfParams << 8)));\n            tickUpper = int24(uint24(bytes3(ldfParams << 32)));\n        }\n    }\n}\n"
    }
}