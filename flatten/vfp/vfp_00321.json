{
    "vfp_id": "vfp_00321",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for upgradeveto.quorum and upgrade.delay can affect protocol upgrades",
            "description": "The protocol does not enforce guardrails on the upgradeveto.quorum and upgrade.delay parameters, allowing them to be set to arbitrary values by governance.\n\nThe root cause is the lack of validation in the DAO settings contracts, which permit pDAO to modify these values without bounds. According to RPIP-60, the intended values are 33% quorum and 1 week delay, but no technical constraints enforce this.\n\nA malicious pDAO could increase upgrade.delay to an extremely high value, effectively stalling any unwanted protocol upgrades indefinitely. Alternatively, reducing upgrade.delay to zero would allow immediate execution of upgrades without giving the Security Council time to review and veto malicious changes.\n\nThe impact is a compromise of the protocol's upgrade safety mechanisms, potentially leading to governance attacks, stalled improvements, or forced deployment of harmful changes.\n",
            "severity": "Medium",
            "location": [
                "RocketDAONodeTrustedUpgrade.sol#55-57",
                "RocketDAONodeTrustedUpgrade.sol#206-218",
                "RocketDAOProtocolSettingsSecurity.sol#21-22",
                "RocketDAOProtocolSettingsSecurity.sol#43-66"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedUpgrade.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAONodeTrustedUpgrade.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../../interface/RocketStorageInterface.sol\";\nimport {RocketDAONodeTrustedUpgradeInterface} from \"../../../interface/dao/node/RocketDAONodeTrustedUpgradeInterface.sol\";\nimport {RocketDAOProtocolSettingsSecurityInterface} from \"../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsSecurityInterface.sol\";\nimport {RocketBase} from \"../../RocketBase.sol\";\n\n/// @notice Handles network contract upgrades\ncontract RocketDAONodeTrustedUpgrade is RocketBase, RocketDAONodeTrustedUpgradeInterface {\n    // Events\n    event UpgradePending(uint256 upgradeProposalID, bytes32 indexed upgradeType, bytes32 indexed name, uint256 time);\n    event UpgradeVetoed(uint256 upgradeProposalID, uint256 time);\n    event ContractUpgraded(bytes32 indexed name, address indexed oldAddress, address indexed newAddress, uint256 time);\n    event ContractAdded(bytes32 indexed name, address indexed newAddress, uint256 time);\n    event ABIUpgraded(bytes32 indexed name, uint256 time);\n    event ABIAdded(bytes32 indexed name, uint256 time);\n\n    // The namespace for any storage data used by this contract\n    string constant private daoUpgradeNameSpace = \"dao.upgrade.\";\n\n    // Immutables\n    bytes32 immutable internal daoTrustedBootstrapKey;\n    bytes32 immutable internal typeUpgradeContract;\n    bytes32 immutable internal typeAddContract;\n    bytes32 immutable internal typeUpgradeABI;\n    bytes32 immutable internal typeAddABI;\n\n    // Only allow bootstrapping when enabled\n    modifier onlyBootstrapMode() {\n        require(getBool(daoTrustedBootstrapKey) == false, \"Bootstrap mode not engaged\");\n        _;\n    }\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 2;\n        // Precompute keys\n        typeUpgradeContract = keccak256(abi.encodePacked(\"upgradeContract\"));\n        typeAddContract = keccak256(abi.encodePacked(\"addContract\"));\n        typeUpgradeABI = keccak256(abi.encodePacked(\"upgradeABI\"));\n        typeAddABI = keccak256(abi.encodePacked(\"addABI\"));\n        daoTrustedBootstrapKey = keccak256(abi.encodePacked(\"dao.trustednodes.\", \"bootstrapmode.disabled\"));\n    }\n\n    /// @notice Called when an upgrade proposal is executed, creates an upgrade proposal that can be vetoed by the\n    ///         security council or executed after the upgrade delay period has passed\n    /// @param _type Type of upgrade (valid values: \"upgradeContract\", \"addContract\", \"upgradeABI\", \"addABI\")\n    /// @param _name Contract name to upgrade\n    /// @param _contractAbi ABI of the upgraded contract\n    /// @param _contractAddress Address of the upgraded contract\n    function upgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) override external onlyLatestContract(\"rocketDAONodeTrustedProposals\", msg.sender) {\n        uint256 upgradeProposalID = getTotal() + 1;\n        // Compute when the proposal can be executed if not vetoed by the security council\n        uint256 startTime = block.timestamp;\n        RocketDAOProtocolSettingsSecurityInterface rocketDAOProtocolSettingsSecurity = RocketDAOProtocolSettingsSecurityInterface(getContractAddress(\"rocketDAOProtocolSettingsSecurity\"));\n        uint256 endTime = startTime + rocketDAOProtocolSettingsSecurity.getUpgradeDelay();\n        // Store data\n        bytes32 typeHash = keccak256(abi.encodePacked(_type));\n        setBytes32(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"type\", upgradeProposalID)), typeHash);\n        setString(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"name\", upgradeProposalID)), _name);\n        setString(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"abi\", upgradeProposalID)), _contractAbi);\n        setAddress(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"address\", upgradeProposalID)), _contractAddress);\n        setUint(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"end\", upgradeProposalID)), endTime);\n        addUint(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"total\")), 1);\n        // Emit event\n        emit UpgradePending(upgradeProposalID, typeHash, keccak256(abi.encodePacked(_name)), block.timestamp);\n    }\n\n    /// @notice Called by the proposal contract when a veto passes\n    /// @param _upgradeProposalID ID of the upgrade proposal to veto\n    function veto(uint256 _upgradeProposalID) override external onlyLatestContract(\"rocketDAOSecurityUpgrade\", msg.sender) {\n        // Validate proposal state\n        require(getState(_upgradeProposalID) == UpgradeProposalState.Pending, \"Proposal has already succeeded, expired, or executed\");\n        // Mark the upgrade as vetoed\n        setBool(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"vetoed\", _upgradeProposalID)), true);\n        // Emit event\n        emit UpgradeVetoed(_upgradeProposalID, block.timestamp);\n    }\n\n    /// @notice Called after upgrade delay has passed to perform the upgrade\n    /// @param _upgradeProposalID ID of the upgrade proposal to execute\n    /// @dev Must be called by a registered trusted node\n    function execute(uint256 _upgradeProposalID) override external onlyTrustedNode(msg.sender) {\n        // Validate proposal state\n        require(getState(_upgradeProposalID) == UpgradeProposalState.Succeeded, \"Proposal has not succeeded or has been vetoed or executed\");\n        // Mark as executed\n        setBool(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"executed\", _upgradeProposalID)), true);\n        // Execute the upgrade\n        _execute(getType(_upgradeProposalID), getName(_upgradeProposalID), getUpgradeABI(_upgradeProposalID), getUpgradeAddress(_upgradeProposalID));\n    }\n\n    /// @notice Immediately execute an upgrade if bootstrap mode is still enabled\n    /// @param _type Type of upgrade (valid values: \"upgradeContract\", \"addContract\", \"upgradeABI\", \"addABI\")\n    /// @param _name Contract name to upgrade\n    /// @param _contractAbi ABI of the upgraded contract\n    /// @param _contractAddress Address of the upgraded contract\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) override external onlyGuardian onlyBootstrapMode {\n        bytes32 typeHash = keccak256(abi.encodePacked(_type));\n        _execute(typeHash, _name, _contractAbi, _contractAddress);\n    }\n\n    /// @dev Internal implementation of the execution process\n    function _execute(bytes32 _typeHash, string memory _name, string memory _contractAbi, address _contractAddress) internal {\n        if (_typeHash == typeUpgradeContract) _upgradeContract(_name, _contractAddress, _contractAbi);\n        else if (_typeHash == typeAddContract) _addContract(_name, _contractAddress, _contractAbi);\n        else if (_typeHash == typeUpgradeABI) _upgradeABI(_name, _contractAbi);\n        else if (_typeHash == typeAddABI) _addABI(_name, _contractAbi);\n        else revert(\"Invalid upgrade type\");\n    }\n\n    /// @dev Performs an update to a contract and ABI simultaneously\n    function _upgradeContract(string memory _name, address _contractAddress, string memory _contractAbi) internal {\n        // Check contract being upgraded\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        require(nameHash != keccak256(abi.encodePacked(\"rocketVault\")), \"Cannot upgrade the vault\");\n        require(nameHash != keccak256(abi.encodePacked(\"rocketTokenRETH\")), \"Cannot upgrade token contracts\");\n        require(nameHash != keccak256(abi.encodePacked(\"rocketTokenRPL\")), \"Cannot upgrade token contracts\");\n        require(nameHash != keccak256(abi.encodePacked(\"rocketTokenRPLFixedSupply\")), \"Cannot upgrade token contracts\");\n        require(nameHash != keccak256(abi.encodePacked(\"casperDeposit\")), \"Cannot upgrade the casper deposit contract\");\n        require(nameHash != keccak256(abi.encodePacked(\"rocketMinipoolPenalty\")), \"Cannot upgrade minipool penalty contract\");\n        // Get old contract address & check contract exists\n        address oldContractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _name)));\n        require(oldContractAddress != address(0x0), \"Contract does not exist\");\n        // Check new contract address\n        require(_contractAddress != address(0x0), \"Invalid contract address\");\n        require(_contractAddress != oldContractAddress, \"The contract address cannot be set to its current address\");\n        require(!getBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress))), \"Contract address is already in use\");\n        // Check ABI isn't empty\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        // Register new contract\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), _name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", _name)), _contractAddress);\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n        // Deregister old contract\n        deleteString(keccak256(abi.encodePacked(\"contract.name\", oldContractAddress)));\n        deleteBool(keccak256(abi.encodePacked(\"contract.exists\", oldContractAddress)));\n        // Emit contract upgraded event\n        emit ContractUpgraded(nameHash, oldContractAddress, _contractAddress, block.timestamp);\n    }\n\n    /// @dev Adds a new contract to the protocol\n    function _addContract(string memory _name, address _contractAddress, string memory _contractAbi) internal {\n        // Check contract name\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        require(bytes(_name).length > 0, \"Invalid contract name\");\n        // Cannot add contract if it already exists (use upgradeContract instead)\n        require(getAddress(keccak256(abi.encodePacked(\"contract.address\", _name))) == address(0x0), \"Contract name is already in use\");\n        // Cannot add contract if already in use as ABI only\n        string memory existingAbi = getString(keccak256(abi.encodePacked(\"contract.abi\", _name)));\n        require(bytes(existingAbi).length == 0, \"Contract name is already in use\");\n        // Check contract address\n        require(_contractAddress != address(0x0), \"Invalid contract address\");\n        require(!getBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress))), \"Contract address is already in use\");\n        // Check ABI isn't empty\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        // Register contract\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), _name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", _name)), _contractAddress);\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n        // Emit contract added event\n        emit ContractAdded(nameHash, _contractAddress, block.timestamp);\n    }\n\n    /// @dev Upgrades an existing ABI\n    function _upgradeABI(string memory _name, string memory _contractAbi) internal {\n        // Check ABI exists\n        string memory existingAbi = getString(keccak256(abi.encodePacked(\"contract.abi\", _name)));\n        require(bytes(existingAbi).length > 0, \"ABI does not exist\");\n        // Sanity checks\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        require(keccak256(bytes(existingAbi)) != keccak256(bytes(_contractAbi)), \"ABIs are identical\");\n        // Set ABI\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n        // Emit ABI upgraded event\n        emit ABIUpgraded(keccak256(abi.encodePacked(_name)), block.timestamp);\n    }\n\n    /// @dev Adds a new ABI to the protocol\n    function _addABI(string memory _name, string memory _contractAbi) internal {\n        // Check ABI name\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        require(bytes(_name).length > 0, \"Invalid ABI name\");\n        // Sanity check\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        // Cannot add ABI if name is already used for an existing network contract\n        require(getAddress(keccak256(abi.encodePacked(\"contract.address\", _name))) == address(0x0), \"ABI name is already in use\");\n        // Cannot add ABI if ABI already exists for this name (use upgradeABI instead)\n        string memory existingAbi = getString(keccak256(abi.encodePacked(\"contract.abi\", _name)));\n        require(bytes(existingAbi).length == 0, \"ABI name is already in use\");\n        // Set ABI\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n        // Emit ABI added event\n        emit ABIAdded(nameHash, block.timestamp);\n    }\n\n    /// @notice Get the total number of upgrade proposals\n    function getTotal() override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"total\")));\n    }\n\n    /// @notice Return the state of the specified upgrade proposal\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getState(uint256 _upgradeProposalID) override public view returns (UpgradeProposalState) {\n        // Check the proposal ID is legit\n        require(getTotal() >= _upgradeProposalID && _upgradeProposalID > 0, \"Invalid upgrade proposal ID\");\n        if (getVetoed(_upgradeProposalID)) {\n            return UpgradeProposalState.Vetoed;\n        } else if (getExecuted(_upgradeProposalID)) {\n            return UpgradeProposalState.Executed;\n        } else if (block.timestamp < getEnd(_upgradeProposalID)) {\n            return UpgradeProposalState.Pending;\n        } else {\n            return UpgradeProposalState.Succeeded;\n        }\n    }\n\n    /// @notice Get the end time of this proposal (when the upgrade delay ends)\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getEnd(uint256 _upgradeProposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"end\", _upgradeProposalID)));\n    }\n\n    /// @notice Get whether the proposal has been executed\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getExecuted(uint256 _upgradeProposalID) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"executed\", _upgradeProposalID)));\n    }\n\n    /// @notice Get whether the proposal has been vetoed\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getVetoed(uint256 _upgradeProposalID) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"vetoed\", _upgradeProposalID)));\n    }\n\n    /// @notice Get the proposal type\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getType(uint256 _upgradeProposalID) override public view returns (bytes32) {\n        return getBytes32(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"type\", _upgradeProposalID)));\n    }\n\n    /// @notice Get the proposed upgrade contract name\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getName(uint256 _upgradeProposalID) override public view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"name\", _upgradeProposalID)));\n    }\n\n    /// @notice Get the proposed upgrade contract address\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getUpgradeAddress(uint256 _upgradeProposalID) override public view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"address\", _upgradeProposalID)));\n    }\n\n    /// @notice Get the proposed upgrade contract ABI\n    /// @param _upgradeProposalID ID of the upgrade proposal to query\n    function getUpgradeABI(uint256 _upgradeProposalID) override public view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(daoUpgradeNameSpace, \"abi\", _upgradeProposalID)));\n    }\n}\n"
    }
}