{
    "vfp_id": "vfp_00499",
    "project_name": "cantina_centrifuge_aug2025.pdf",
    "findings": [
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Could use abi.encodeCall()",
            "description": "Several functions use abi.encodeWithSignature() where abi.encodeCall() could be used instead. The latter provides compile-time type checking, reducing the risk of signature mismatches. The cause is use of a less safe ABI encoding method. While both produce the same output, abi.encodeCall() catches errors at compile time, such as incorrect function signatures or parameter types. This improves code safety and maintainability, preventing potential runtime failures due to typos or refactoring errors.\n",
            "severity": null,
            "location": [
                "_safeGetAssetDecimals"
            ],
            "files": [
                "protocol-v3/src/spoke/Spoke.sol"
            ]
        }
    ],
    "affected_files": {
        "Spoke.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Price} from \"./types/Price.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IShareToken} from \"./interfaces/IShareToken.sol\";\nimport {IVaultManager} from \"./interfaces/IVaultManager.sol\";\nimport {ITokenFactory} from \"./factories/interfaces/ITokenFactory.sol\";\nimport {IVaultFactory} from \"./factories/interfaces/IVaultFactory.sol\";\nimport {AssetIdKey, Pool, ShareClassDetails, VaultDetails, ISpoke} from \"./interfaces/ISpoke.sol\";\n\nimport {Auth} from \"../misc/Auth.sol\";\nimport {D18} from \"../misc/types/D18.sol\";\nimport {Recoverable} from \"../misc/Recoverable.sol\";\nimport {CastLib} from \"../misc/libraries/CastLib.sol\";\nimport {MathLib} from \"../misc/libraries/MathLib.sol\";\nimport {BytesLib} from \"../misc/libraries/BytesLib.sol\";\nimport {IERC165} from \"../misc/interfaces/IERC7575.sol\";\nimport {IERC20Metadata} from \"../misc/interfaces/IERC20.sol\";\nimport {IERC6909MetadataExt} from \"../misc/interfaces/IERC6909.sol\";\nimport {ReentrancyProtection} from \"../misc/ReentrancyProtection.sol\";\n\nimport {PoolId} from \"../common/types/PoolId.sol\";\nimport {IGateway} from \"../common/interfaces/IGateway.sol\";\nimport {ShareClassId} from \"../common/types/ShareClassId.sol\";\nimport {newAssetId, AssetId} from \"../common/types/AssetId.sol\";\nimport {IPoolEscrow} from \"../common/interfaces/IPoolEscrow.sol\";\nimport {ITransferHook} from \"../common/interfaces/ITransferHook.sol\";\nimport {IRequestManager} from \"../common/interfaces/IRequestManager.sol\";\nimport {ISpokeMessageSender} from \"../common/interfaces/IGatewaySenders.sol\";\nimport {ISpokeGatewayHandler} from \"../common/interfaces/IGatewayHandlers.sol\";\nimport {VaultUpdateKind, MessageLib} from \"../common/libraries/MessageLib.sol\";\nimport {IPoolEscrowFactory} from \"../common/factories/interfaces/IPoolEscrowFactory.sol\";\n\n/// @title  Spoke\n/// @notice This contract manages which pools & share classes exist, controlling allowed pool currencies,\n///         initiating cross-chain transfers for tokens, and registering and linking vaults.\ncontract Spoke is Auth, Recoverable, ReentrancyProtection, ISpoke, ISpokeGatewayHandler {\n    using CastLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using MathLib for uint256;\n\n    uint8 internal constant MIN_DECIMALS = 2;\n    uint8 internal constant MAX_DECIMALS = 18;\n\n    IGateway public gateway;\n    ITokenFactory public tokenFactory;\n    ISpokeMessageSender public sender;\n    IPoolEscrowFactory public poolEscrowFactory;\n\n    uint64 internal _assetCounter;\n\n    mapping(PoolId poolId => Pool) public pools;\n\n    mapping(IVault => VaultDetails) internal _vaultDetails;\n    mapping(AssetId assetId => AssetIdKey) internal _idToAsset;\n    mapping(address asset => mapping(uint256 tokenId => AssetId assetId)) internal _assetToId;\n\n    constructor(ITokenFactory tokenFactory_, address deployer) Auth(deployer) {\n        tokenFactory = tokenFactory_;\n    }\n\n    modifier payTransaction() {\n        gateway.startTransactionPayment{value: msg.value}(msg.sender);\n        _;\n        gateway.endTransactionPayment();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISpoke\n    function file(bytes32 what, address data) external auth {\n        if (what == \"gateway\") gateway = IGateway(data);\n        else if (what == \"sender\") sender = ISpokeMessageSender(data);\n        else if (what == \"tokenFactory\") tokenFactory = ITokenFactory(data);\n        else if (what == \"poolEscrowFactory\") poolEscrowFactory = IPoolEscrowFactory(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISpoke\n    function crosschainTransferShares(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        bytes32 receiver,\n        uint128 amount,\n        uint128 remoteExtraGasLimit\n    ) external payable payTransaction protected {\n        IShareToken share = IShareToken(shareToken(poolId, scId));\n        require(centrifugeId != sender.localCentrifugeId(), LocalTransferNotAllowed());\n        require(\n            share.checkTransferRestriction(msg.sender, address(uint160(centrifugeId)), amount),\n            CrossChainTransferNotAllowed()\n        );\n\n        share.authTransferFrom(msg.sender, msg.sender, address(this), amount);\n        share.burn(address(this), amount);\n\n        emit InitiateTransferShares(centrifugeId, poolId, scId, msg.sender, receiver, amount);\n        sender.sendInitiateTransferShares(centrifugeId, poolId, scId, receiver, amount, remoteExtraGasLimit);\n    }\n\n    /// @inheritdoc ISpoke\n    function registerAsset(uint16 centrifugeId, address asset, uint256 tokenId)\n        external\n        payable\n        payTransaction\n        protected\n        returns (AssetId assetId)\n    {\n        string memory name;\n        string memory symbol;\n        uint8 decimals;\n\n        decimals = _safeGetAssetDecimals(asset, tokenId);\n        require(decimals >= MIN_DECIMALS, TooFewDecimals());\n        require(decimals <= MAX_DECIMALS, TooManyDecimals());\n\n        if (tokenId == 0) {\n            IERC20Metadata meta = IERC20Metadata(asset);\n            name = meta.name();\n            symbol = meta.symbol();\n        } else {\n            IERC6909MetadataExt meta = IERC6909MetadataExt(asset);\n            name = meta.name(tokenId);\n            symbol = meta.symbol(tokenId);\n        }\n\n        assetId = _assetToId[asset][tokenId];\n        bool isInitialization = assetId.raw() == 0;\n        if (isInitialization) {\n            _assetCounter++;\n            assetId = newAssetId(sender.localCentrifugeId(), _assetCounter);\n\n            _idToAsset[assetId] = AssetIdKey(asset, tokenId);\n            _assetToId[asset][tokenId] = assetId;\n        }\n\n        emit RegisterAsset(assetId, asset, tokenId, name, symbol, decimals, isInitialization);\n        sender.sendRegisterAsset(centrifugeId, assetId, decimals);\n    }\n\n    /// @inheritdoc ISpoke\n    function request(PoolId poolId, ShareClassId scId, AssetId assetId, bytes memory payload) external {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        require(msg.sender == address(shareClass.asset[assetId].manager), NotAuthorized());\n\n        sender.sendRequest(poolId, scId, assetId, payload);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Pool & token management\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function addPool(PoolId poolId) public auth {\n        Pool storage pool = pools[poolId];\n        require(pool.createdAt == 0, PoolAlreadyAdded());\n        pool.createdAt = block.timestamp;\n\n        IPoolEscrow escrow = poolEscrowFactory.escrow(poolId);\n        if (address(escrow).code.length == 0) {\n            poolEscrowFactory.newEscrow(poolId);\n            gateway.setRefundAddress(poolId, escrow);\n        }\n\n        emit AddPool(poolId);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function addShareClass(\n        PoolId poolId,\n        ShareClassId scId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 salt,\n        address hook\n    ) public auth {\n        require(isPoolActive(poolId), InvalidPool());\n        require(decimals >= MIN_DECIMALS, TooFewDecimals());\n        require(decimals <= MAX_DECIMALS, TooManyDecimals());\n        require(address(pools[poolId].shareClasses[scId].shareToken) == address(0), ShareClassAlreadyRegistered());\n\n        // Hook can be address zero if the share token is fully permissionless and has no custom logic\n        require(hook == address(0) || _isValidHook(hook), InvalidHook());\n\n        IShareToken shareToken_ = tokenFactory.newToken(name, symbol, decimals, salt);\n        if (hook != address(0)) shareToken_.file(\"hook\", hook);\n        linkToken(poolId, scId, shareToken_);\n    }\n\n    /// @inheritdoc ISpoke\n    function linkToken(PoolId poolId, ShareClassId scId, IShareToken shareToken_) public auth {\n        pools[poolId].shareClasses[scId].shareToken = shareToken_;\n        emit AddShareClass(poolId, scId, shareToken_);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function setRequestManager(PoolId poolId, ShareClassId scId, AssetId assetId, IRequestManager manager)\n        public\n        auth\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        require(shareClass.asset[assetId].numVaults == 0, MoreThanZeroLinkedVaults());\n        shareClass.asset[assetId].manager = manager;\n        emit SetRequestManager(poolId, scId, assetId, manager);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function updateShareMetadata(PoolId poolId, ShareClassId scId, string memory name, string memory symbol)\n        public\n        auth\n    {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n        require(\n            keccak256(bytes(shareToken_.name())) != keccak256(bytes(name))\n                || keccak256(bytes(shareToken_.symbol())) != keccak256(bytes(symbol)),\n            OldMetadata()\n        );\n\n        shareToken_.file(\"name\", name);\n        shareToken_.file(\"symbol\", symbol);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function updateShareHook(PoolId poolId, ShareClassId scId, address hook) public auth {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n        require(hook != shareToken_.hook(), OldHook());\n        shareToken_.file(\"hook\", hook);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function updateRestriction(PoolId poolId, ShareClassId scId, bytes memory update) public auth {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n        address hook = shareToken_.hook();\n        require(hook != address(0), InvalidHook());\n        ITransferHook(hook).updateRestriction(address(shareToken_), update);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function executeTransferShares(PoolId poolId, ShareClassId scId, bytes32 receiver, uint128 amount) public auth {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n        shareToken_.mint(receiver.toAddress(), amount);\n        emit ExecuteTransferShares(poolId, scId, receiver.toAddress(), amount);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Price management\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function updatePricePoolPerShare(PoolId poolId, ShareClassId scId, D18 price, uint64 computedAt) public auth {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        Price storage poolPerShare = shareClass.pricePoolPerShare;\n        require(computedAt >= shareClass.pricePoolPerShare.computedAt, CannotSetOlderPrice());\n\n        // Disable expiration of the price if never initialized\n        if (poolPerShare.computedAt == 0 && poolPerShare.maxAge == 0) {\n            poolPerShare.maxAge = type(uint64).max;\n        }\n\n        poolPerShare.price = price;\n        poolPerShare.computedAt = computedAt;\n        emit UpdateSharePrice(poolId, scId, price, computedAt);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function updatePricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 price, uint64 computedAt)\n        public\n        auth\n    {\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        Price storage poolPerAsset = shareClass.asset[assetId].pricePoolPerAsset;\n        require(computedAt >= poolPerAsset.computedAt, CannotSetOlderPrice());\n\n        // Disable expiration of the price if never initialized\n        if (poolPerAsset.computedAt == 0 && poolPerAsset.maxAge == 0) {\n            poolPerAsset.maxAge = type(uint64).max;\n        }\n\n        poolPerAsset.price = price;\n        poolPerAsset.computedAt = computedAt;\n        emit UpdateAssetPrice(poolId, scId, asset, tokenId, price, computedAt);\n    }\n\n    function setMaxSharePriceAge(PoolId poolId, ShareClassId scId, uint64 maxPriceAge) external auth {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        shareClass.pricePoolPerShare.maxAge = maxPriceAge;\n        emit UpdateMaxSharePriceAge(poolId, scId, maxPriceAge);\n    }\n\n    function setMaxAssetPriceAge(PoolId poolId, ShareClassId scId, AssetId assetId, uint64 maxPriceAge) external auth {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        shareClass.asset[assetId].pricePoolPerAsset.maxAge = maxPriceAge;\n        emit UpdateMaxAssetPriceAge(poolId, scId, asset, tokenId, maxPriceAge);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Vault management\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function requestCallback(PoolId poolId, ShareClassId scId, AssetId assetId, bytes memory payload) external auth {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        IRequestManager manager = shareClass.asset[assetId].manager;\n        require(address(manager) != address(0), InvalidRequestManager());\n\n        manager.callback(poolId, scId, assetId, payload);\n    }\n\n    /// @inheritdoc ISpokeGatewayHandler\n    function updateVault(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address vaultOrFactory,\n        VaultUpdateKind kind\n    ) external auth {\n        if (kind == VaultUpdateKind.DeployAndLink) {\n            IVault vault = deployVault(poolId, scId, assetId, IVaultFactory(vaultOrFactory));\n            linkVault(poolId, scId, assetId, vault);\n        } else {\n            IVault vault = IVault(vaultOrFactory);\n\n            // Needed as safeguard against non-validated vaults\n            // I.e. we only accept vaults that have been deployed by the pool manager\n            require(_vaultDetails[vault].asset != address(0), UnknownVault());\n\n            if (kind == VaultUpdateKind.Link) linkVault(poolId, scId, assetId, vault);\n            else if (kind == VaultUpdateKind.Unlink) unlinkVault(poolId, scId, assetId, vault);\n            else revert MalformedVaultUpdateMessage(); // Unreachable due the enum check\n        }\n    }\n\n    /// @inheritdoc ISpoke\n    function deployVault(PoolId poolId, ShareClassId scId, AssetId assetId, IVaultFactory factory)\n        public\n        auth\n        returns (IVault)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        IVault vault = factory.newVault(poolId, scId, asset, tokenId, shareClass.shareToken, new address[](0));\n\n        _vaultDetails[vault] = VaultDetails(assetId, asset, tokenId, false);\n        emit DeployVault(poolId, scId, asset, tokenId, factory, vault, vault.vaultKind());\n\n        return vault;\n    }\n\n    /// @inheritdoc ISpoke\n    function linkVault(PoolId poolId, ShareClassId scId, AssetId assetId, IVault vault) public auth {\n        require(vault.poolId() == poolId, InvalidVault());\n        require(vault.scId() == scId, InvalidVault());\n\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        VaultDetails storage vaultDetails_ = _vaultDetails[vault];\n        require(!vaultDetails_.isLinked, AlreadyLinkedVault());\n\n        IVaultManager manager = vault.manager();\n        manager.addVault(poolId, scId, assetId, vault, asset, tokenId);\n\n        shareClass.asset[assetId].numVaults++;\n        vaultDetails_.isLinked = true;\n\n        if (tokenId == 0) {\n            shareClass.shareToken.updateVault(asset, address(vault));\n        }\n\n        emit LinkVault(poolId, scId, asset, tokenId, vault);\n    }\n\n    /// @inheritdoc ISpoke\n    function unlinkVault(PoolId poolId, ShareClassId scId, AssetId assetId, IVault vault) public auth {\n        require(vault.poolId() == poolId, InvalidVault());\n        require(vault.scId() == scId, InvalidVault());\n\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        VaultDetails storage vaultDetails_ = _vaultDetails[vault];\n        require(vaultDetails_.isLinked, AlreadyUnlinkedVault());\n\n        IVaultManager manager = vault.manager();\n        manager.removeVault(poolId, scId, assetId, vault, asset, tokenId);\n\n        shareClass.asset[assetId].numVaults--;\n        vaultDetails_.isLinked = false;\n\n        if (tokenId == 0) {\n            shareClass.shareToken.updateVault(asset, address(0));\n        }\n\n        emit UnlinkVault(poolId, scId, asset, tokenId, vault);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISpoke\n    function isPoolActive(PoolId poolId) public view returns (bool) {\n        return pools[poolId].createdAt > 0;\n    }\n\n    /// @inheritdoc ISpoke\n    function shareToken(PoolId poolId, ShareClassId scId) public view returns (IShareToken) {\n        return _shareClass(poolId, scId).shareToken;\n    }\n\n    /// @inheritdoc ISpoke\n    function idToAsset(AssetId assetId) public view returns (address asset, uint256 tokenId) {\n        AssetIdKey memory assetIdKey = _idToAsset[assetId];\n        require(assetIdKey.asset != address(0), UnknownAsset());\n        return (assetIdKey.asset, assetIdKey.tokenId);\n    }\n\n    /// @inheritdoc ISpoke\n    function assetToId(address asset, uint256 tokenId) public view returns (AssetId assetId) {\n        assetId = _assetToId[asset][tokenId];\n        require(assetId.raw() != 0, UnknownAsset());\n    }\n\n    /// @inheritdoc ISpoke\n    function pricePoolPerShare(PoolId poolId, ShareClassId scId, bool checkValidity) public view returns (D18 price) {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        require(!checkValidity || shareClass.pricePoolPerShare.isValid(), InvalidPrice());\n\n        return shareClass.pricePoolPerShare.price;\n    }\n\n    /// @inheritdoc ISpoke\n    function pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        public\n        view\n        returns (D18 price)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        Price memory poolPerAsset = shareClass.asset[assetId].pricePoolPerAsset;\n        require(!checkValidity || poolPerAsset.isValid(), InvalidPrice());\n\n        return poolPerAsset.price;\n    }\n\n    /// @inheritdoc ISpoke\n    function pricesPoolPer(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        public\n        view\n        returns (D18 pricePoolPerAsset_, D18 pricePoolPerShare_)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n        Price memory poolPerAsset = shareClass.asset[assetId].pricePoolPerAsset;\n        Price memory poolPerShare = shareClass.pricePoolPerShare;\n\n        require(!checkValidity || poolPerAsset.isValid() && poolPerShare.isValid(), InvalidPrice());\n\n        return (poolPerAsset.price, poolPerShare.price);\n    }\n\n    /// @inheritdoc ISpoke\n    function markersPricePoolPerShare(PoolId poolId, ShareClassId scId)\n        external\n        view\n        returns (uint64 computedAt, uint64 maxAge, uint64 validUntil)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        computedAt = shareClass.pricePoolPerShare.computedAt;\n        maxAge = shareClass.pricePoolPerShare.maxAge;\n        validUntil = shareClass.pricePoolPerShare.validUntil();\n    }\n\n    /// @inheritdoc ISpoke\n    function markersPricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        view\n        returns (uint64 computedAt, uint64 maxAge, uint64 validUntil)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        Price memory poolPerAsset = shareClass.asset[assetId].pricePoolPerAsset;\n        computedAt = poolPerAsset.computedAt;\n        maxAge = poolPerAsset.maxAge;\n        validUntil = poolPerAsset.validUntil();\n    }\n\n    /// @inheritdoc ISpoke\n    function vaultDetails(IVault vault) public view returns (VaultDetails memory details) {\n        details = _vaultDetails[vault];\n        require(details.asset != address(0), UnknownVault());\n    }\n\n    /// @inheritdoc ISpoke\n    function isLinked(IVault vault) public view returns (bool) {\n        return _vaultDetails[vault].isLinked;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal methods\n    //----------------------------------------------------------------------------------------------\n\n    function _safeGetAssetDecimals(address asset, uint256 tokenId) private view returns (uint8) {\n        bytes memory callData;\n\n        if (tokenId == 0) {\n            callData = abi.encodeWithSignature(\"decimals()\");\n        } else {\n            callData = abi.encodeWithSignature(\"decimals(uint256)\", tokenId);\n        }\n\n        (bool success, bytes memory data) = asset.staticcall(callData);\n        require(success && data.length >= 32, AssetMissingDecimals());\n\n        return abi.decode(data, (uint8));\n    }\n\n    function _isValidHook(address hook) internal view returns (bool) {\n        (bool success, bytes memory data) =\n            hook.staticcall(abi.encodeWithSelector(IERC165.supportsInterface.selector, type(ITransferHook).interfaceId));\n\n        return success && data.length == 32 && abi.decode(data, (bool));\n    }\n\n    function _shareClass(PoolId poolId, ShareClassId scId)\n        internal\n        view\n        returns (ShareClassDetails storage shareClass)\n    {\n        shareClass = pools[poolId].shareClasses[scId];\n        require(address(shareClass.shareToken) != address(0), ShareTokenDoesNotExist());\n    }\n}\n"
    }
}