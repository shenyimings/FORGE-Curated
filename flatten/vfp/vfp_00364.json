{
    "vfp_id": "vfp_00364",
    "project_name": "2025-04-reserve-folio-solidity-securityreview.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "StakingVault is vulnerable to ERC-4626 griefing attack",
            "description": "The StakingVault contract inherits from ERC-4626 but does not generate yield, making price-per-share tracking unnecessary. However, it remains vulnerable to an inflation attack where an attacker can manipulate share issuance by donating assets. The root cause lies in the use of totalAssets() in share calculations without overriding it to reflect a fixed rate. An attacker can front-run a large deposit by donating a small amount, causing subsequent depositors to receive disproportionately few shares. Upon redemption, both the attacker and victim receive a large amount of assets relative to their share count, resulting in a loss for the protocol and unfair distribution. This leads to economic loss for legitimate users and undermines trust in the vault's fairness. Additionally, the contract is susceptible to a griefing attack where a malicious user can deposit a very small amount of assets that results in negligible or zero shares being minted, wasting gas for other users during pro-rata calculations or reward distribution. The root cause is the lack of a minimum deposit threshold or proper handling of near-zero share calculations. An attacker could exploit this by repeatedly making tiny deposits, increasing the computational cost of future operations. The impact includes degraded performance and increased gas costs for legitimate users.\n",
            "severity": "Low",
            "location": [
                "contracts/staking/StakingVault.sol",
                "StakingVault"
            ],
            "files": [
                "reserve-index-dtf/contracts/staking/StakingVault.sol"
            ]
        }
    ],
    "affected_files": {
        "StakingVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport { ERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport { ERC20Votes } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Nonces } from \"@openzeppelin/contracts/utils/Nonces.sol\";\nimport { Time } from \"@openzeppelin/contracts/utils/types/Time.sol\";\n\nimport { UD60x18 } from \"@prb/math/src/UD60x18.sol\";\n\nimport { UnstakingManager } from \"./UnstakingManager.sol\";\n\nuint256 constant MAX_UNSTAKING_DELAY = 4 weeks; // {s}\nuint256 constant MAX_REWARD_HALF_LIFE = 2 weeks; // {s}\nuint256 constant MIN_REWARD_HALF_LIFE = 1 days; // {s}\n\nuint256 constant LN_2 = 0.693147180559945309e18; // D18{1} ln(2e18)\n\nuint256 constant SCALAR = 1e18; // D18\n\n/**\n * @title StakingVault\n * @author akshatmittal, julianmrodri, pmckelvy1, tbrent\n * @notice StakingVault is a transferrable 1:1 wrapping of an underlying token that uses the ERC4626 interface.\n *         It earns the holder a claimable stream of multi rewards and enables them to vote in (external) governance.\n *         Unstaking is gated by a delay, implemented by an UnstakingManager.\n */\ncontract StakingVault is ERC4626, ERC20Permit, ERC20Votes, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private rewardTokens;\n    uint256 public rewardRatio; // D18{1}\n\n    UnstakingManager public immutable unstakingManager;\n    uint256 public unstakingDelay; // {s}\n\n    struct RewardInfo {\n        uint256 payoutLastPaid; // {s}\n        uint256 rewardIndex; // D18+decimals{reward/share}\n        //\n        uint256 balanceAccounted; // {reward}\n        uint256 balanceLastKnown; // {reward}\n        uint256 totalClaimed; // {reward}\n    }\n\n    struct UserRewardInfo {\n        uint256 lastRewardIndex; // D18+decimals{reward/share}\n        uint256 accruedRewards; // {reward}\n    }\n\n    mapping(address token => RewardInfo rewardInfo) public rewardTrackers;\n    mapping(address token => bool isDisallowed) public disallowedRewardTokens;\n    mapping(address token => mapping(address user => UserRewardInfo userReward)) public userRewardTrackers;\n\n    error Vault__InvalidRewardToken(address rewardToken);\n    error Vault__DisallowedRewardToken(address rewardToken);\n    error Vault__RewardAlreadyRegistered();\n    error Vault__RewardNotRegistered();\n    error Vault__InvalidUnstakingDelay();\n    error Vault__InvalidRewardsHalfLife();\n\n    event UnstakingDelaySet(uint256 delay);\n    event RewardTokenAdded(address rewardToken);\n    event RewardTokenRemoved(address rewardToken);\n    event RewardsClaimed(address user, address rewardToken, uint256 amount);\n    event RewardRatioSet(uint256 rewardRatio, uint256 halfLife);\n\n    /// @param _name Name of the vault\n    /// @param _symbol Symbol of the vault\n    /// @param _underlying Underlying token deposited during staking\n    /// @param _initialOwner Initial owner of the vault\n    /// @param _rewardPeriod {s} Half life of the reward handout rate\n    /// @param _unstakingDelay {s} Delay after unstaking before user receives their deposit\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        IERC20 _underlying,\n        address _initialOwner,\n        uint256 _rewardPeriod,\n        uint256 _unstakingDelay\n    ) ERC4626(_underlying) ERC20(_name, _symbol) ERC20Permit(_name) Ownable(_initialOwner) {\n        _setRewardRatio(_rewardPeriod);\n        _setUnstakingDelay(_unstakingDelay);\n\n        unstakingManager = new UnstakingManager(_underlying);\n    }\n\n    /**\n     * Deposit & Delegate\n     */\n    function depositAndDelegate(uint256 assets) external returns (uint256 shares) {\n        shares = deposit(assets, msg.sender);\n\n        _delegate(msg.sender, msg.sender);\n    }\n\n    /**\n     * Withdraw Logic\n     */\n    function _withdraw(\n        address _caller,\n        address _receiver,\n        address _owner,\n        uint256 _assets,\n        uint256 _shares\n    ) internal override {\n        if (unstakingDelay == 0) {\n            super._withdraw(_caller, _receiver, _owner, _assets, _shares);\n        } else {\n            // Since we can't use the builtin `_withdraw`, we need to take care of the entire flow here.\n            if (_caller != _owner) {\n                _spendAllowance(_owner, _caller, _shares);\n            }\n\n            // Burn the shares first.\n            _burn(_owner, _shares);\n\n            SafeERC20.forceApprove(IERC20(asset()), address(unstakingManager), _assets);\n            unstakingManager.createLock(_receiver, _assets, block.timestamp + unstakingDelay);\n\n            emit Withdraw(_caller, _receiver, _owner, _assets, _shares);\n        }\n    }\n\n    /// @param _delay {s} New unstaking delay\n    function setUnstakingDelay(uint256 _delay) external onlyOwner {\n        _setUnstakingDelay(_delay);\n    }\n\n    /// @param _delay {s} New unstaking delay\n    function _setUnstakingDelay(uint256 _delay) internal {\n        require(_delay <= MAX_UNSTAKING_DELAY, Vault__InvalidUnstakingDelay());\n\n        unstakingDelay = _delay;\n        emit UnstakingDelaySet(_delay);\n    }\n\n    /**\n     * Reward Management Logic\n     */\n    /// @param _rewardToken Reward token to add\n    function addRewardToken(address _rewardToken) external onlyOwner {\n        require(_rewardToken != address(this) && _rewardToken != asset(), Vault__InvalidRewardToken(_rewardToken));\n\n        require(!disallowedRewardTokens[_rewardToken], Vault__DisallowedRewardToken(_rewardToken));\n\n        require(rewardTokens.add(_rewardToken), Vault__RewardAlreadyRegistered());\n\n        RewardInfo storage rewardInfo = rewardTrackers[_rewardToken];\n\n        rewardInfo.payoutLastPaid = block.timestamp;\n        rewardInfo.balanceLastKnown = IERC20(_rewardToken).balanceOf(address(this));\n\n        emit RewardTokenAdded(_rewardToken);\n    }\n\n    /// @param _rewardToken Reward token to remove\n    function removeRewardToken(address _rewardToken) external onlyOwner {\n        disallowedRewardTokens[_rewardToken] = true;\n\n        require(rewardTokens.remove(_rewardToken), Vault__RewardNotRegistered());\n\n        emit RewardTokenRemoved(_rewardToken);\n    }\n\n    /// Allows to claim rewards\n    /// Supports claiming accrued rewards for disallowed/removed tokens\n    /// @param _rewardTokens Array of reward tokens to claim\n    /// @return claimableRewards Amount claimed for each rewardToken\n    function claimRewards(\n        address[] calldata _rewardTokens\n    ) external accrueRewards(msg.sender, msg.sender) returns (uint256[] memory claimableRewards) {\n        claimableRewards = new uint256[](_rewardTokens.length);\n\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            address _rewardToken = _rewardTokens[i];\n\n            RewardInfo storage rewardInfo = rewardTrackers[_rewardToken];\n            UserRewardInfo storage userRewardTracker = userRewardTrackers[_rewardToken][msg.sender];\n\n            claimableRewards[i] = userRewardTracker.accruedRewards;\n\n            if (claimableRewards[i] != 0) {\n                // {reward} += {reward}\n                rewardInfo.totalClaimed += claimableRewards[i];\n                userRewardTracker.accruedRewards = 0;\n\n                SafeERC20.safeTransfer(IERC20(_rewardToken), msg.sender, claimableRewards[i]);\n\n                emit RewardsClaimed(msg.sender, _rewardToken, claimableRewards[i]);\n            }\n        }\n    }\n\n    function getAllRewardTokens() external view returns (address[] memory) {\n        return rewardTokens.values();\n    }\n\n    /**\n     * Reward Accrual Logic\n     */\n    /// @param rewardHalfLife {s}\n    function setRewardRatio(uint256 rewardHalfLife) external onlyOwner {\n        _setRewardRatio(rewardHalfLife);\n    }\n\n    /// @param _rewardHalfLife {s}\n    function _setRewardRatio(uint256 _rewardHalfLife) internal accrueRewards(msg.sender, msg.sender) {\n        require(\n            _rewardHalfLife <= MAX_REWARD_HALF_LIFE && _rewardHalfLife >= MIN_REWARD_HALF_LIFE,\n            Vault__InvalidRewardsHalfLife()\n        );\n\n        // D18{1/s} = D18{1} / {s}\n        rewardRatio = LN_2 / _rewardHalfLife;\n\n        emit RewardRatioSet(rewardRatio, _rewardHalfLife);\n    }\n\n    function poke() external accrueRewards(msg.sender, msg.sender) {}\n\n    modifier accrueRewards(address _caller, address _receiver) {\n        _accrueRewards(_caller, _receiver);\n        _;\n    }\n\n    function _accrueRewards(address _caller, address _receiver) internal {\n        address[] memory _rewardTokens = rewardTokens.values();\n        uint256 _rewardTokensLength = _rewardTokens.length;\n\n        for (uint256 i; i < _rewardTokensLength; i++) {\n            address rewardToken = _rewardTokens[i];\n\n            _accrueRewards(rewardToken);\n            _accrueUser(_receiver, rewardToken);\n\n            // If a deposit/withdraw operation gets called for another user we should\n            // accrue for both of them to avoid potential issues\n            // This is important for accruing for \"from\" and \"to\" in a transfer.\n            if (_receiver != _caller) {\n                _accrueUser(_caller, rewardToken);\n            }\n        }\n    }\n\n    function _accrueRewards(address _rewardToken) internal {\n        RewardInfo storage rewardInfo = rewardTrackers[_rewardToken];\n\n        uint256 balanceLastKnown = rewardInfo.balanceLastKnown;\n        rewardInfo.balanceLastKnown = IERC20(_rewardToken).balanceOf(address(this)) + rewardInfo.totalClaimed;\n\n        uint256 elapsed = block.timestamp - rewardInfo.payoutLastPaid;\n        if (elapsed == 0) {\n            return;\n        }\n\n        uint256 unaccountedBalance = balanceLastKnown - rewardInfo.balanceAccounted;\n        uint256 handoutPercentage = 1e18 - UD60x18.wrap(1e18 - rewardRatio).powu(elapsed).unwrap() - 1; // rounds down\n\n        // {reward} = {reward} * D18{1} / D18\n        uint256 tokensToHandout = (unaccountedBalance * handoutPercentage) / 1e18;\n\n        uint256 supplyTokens = totalSupply();\n\n        if (supplyTokens != 0) {\n            // D18+decimals{reward/share} = D18 * {reward} * decimals / {share}\n            uint256 deltaIndex = (SCALAR * tokensToHandout * uint256(10 ** decimals())) / supplyTokens;\n\n            // D18+decimals{reward/share} += D18+decimals{reward/share}\n            rewardInfo.rewardIndex += deltaIndex;\n            rewardInfo.balanceAccounted += tokensToHandout;\n        }\n        // @todo Add a test case for when supplyTokens is 0 for a while, the rewards are paid out correctly.\n\n        rewardInfo.payoutLastPaid = block.timestamp;\n    }\n\n    function _accrueUser(address _user, address _rewardToken) internal {\n        if (_user == address(0)) {\n            return;\n        }\n\n        RewardInfo memory rewardInfo = rewardTrackers[_rewardToken];\n        UserRewardInfo storage userRewardTracker = userRewardTrackers[_rewardToken][_user];\n\n        // D18+decimals{reward/share}\n        uint256 deltaIndex = rewardInfo.rewardIndex - userRewardTracker.lastRewardIndex;\n\n        if (deltaIndex != 0) {\n            // Accumulate rewards by multiplying user tokens by index and adding on unclaimed\n            // {reward} = {share} * D18+decimals{reward/share} / decimals / D18\n            uint256 supplierDelta = (balanceOf(_user) * deltaIndex) / uint256(10 ** decimals()) / SCALAR;\n\n            // {reward} += {reward}\n            userRewardTracker.accruedRewards += supplierDelta;\n            userRewardTracker.lastRewardIndex = rewardInfo.rewardIndex;\n        }\n    }\n\n    /**\n     * Overrides\n     */\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override(ERC20, ERC20Votes) accrueRewards(from, to) {\n        super._update(from, to, value);\n    }\n\n    function nonces(address _owner) public view override(ERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(_owner);\n    }\n\n    function decimals() public view virtual override(ERC20, ERC4626) returns (uint8) {\n        return super.decimals();\n    }\n\n    /**\n     * ERC5805 Clock\n     */\n    function clock() public view override returns (uint48) {\n        return Time.timestamp();\n    }\n\n    function CLOCK_MODE() public pure override returns (string memory) {\n        return \"mode=timestamp\";\n    }\n}\n"
    }
}