{
    "vfp_id": "vfp_00200",
    "project_name": "cantina_managed_sky_chief_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Improvement on the Lift event",
            "description": "1. **Description:** The Lift event in the lift function currently only emits the address of the entity being lifted (whom), but does not include the quantity of approvals associated with the action. This limits the usefulness of the event for off-chain monitoring and analytics tools.\n2. **Cause:** The event definition omits a parameter for the number of approvals, which is available in the function's logic but not exposed in the emitted event.\n3. **Exploitation:** This is not directly exploitable, but it reduces transparency, as external systems cannot easily determine the approval weight behind a lift action without additional on-chain queries.\n4. **Impact:** Reduced observability and potential inefficiencies for off-chain services relying on event data for decision-making or reporting.\n",
            "severity": "Informational",
            "location": [
                "Chief.sol::L145"
            ],
            "files": [
                "chief/src/Chief.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Missing return parameter name",
            "description": "1. **Description:** Several functions in the Chief contract (length, GOV, MAX_YAYS) do not name their return parameters, while the rest of the codebase follows the convention of naming them.\n2. **Cause:** Inconsistent coding style within the same contract, likely due to oversight during development.\n3. **Exploitation:** This issue cannot be exploited by an attacker, as it does not affect runtime behavior or security.\n4. **Impact:** Reduced code readability and maintainability, making it slightly harder for developers and auditors to understand the purpose of return values.\n",
            "severity": "Informational",
            "location": [
                "Chief.sol::L78"
            ],
            "files": [
                "chief/src/Chief.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "yay execution order per slate is non-deterministic",
            "description": "1. **Description:** When a slate contains multiple yays and surpasses the current hat in approval count, any caller can trigger the lift function with any of the yays in the slate, leading to non-deterministic execution order.\n2. **Cause:** The contract does not enforce a specific order for processing yays, leaving the choice to the external caller.\n3. **Exploitation:** A malicious or strategic actor could choose the order in which yays are executed to influence outcomes, especially if the sequence of actions matters (e.g., dependent spells).\n4. **Impact:** Potential manipulation of execution flow, which could lead to unexpected or undesirable state changes if the order of operations is significant.\n",
            "severity": "Informational",
            "location": [
                "Chief.sol::L64-L142"
            ],
            "files": [
                "chief/src/Chief.sol"
            ]
        }
    ],
    "affected_files": {
        "Chief.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// Chief.sol - select an authority by consensus\n\n// Copyright (C) 2017 DappHub, LLC\n// Copyright (C) 2023 Dai Foundation\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.21;\n\ninterface DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) external view returns (bool);\n}\n\ninterface GemLike {\n    function transfer(address, uint256) external;\n    function transferFrom(address, address, uint256) external;\n}\n\ncontract Chief is DSAuthority {\n    uint256                                  public live;\n    address                                  public hat;\n    mapping(bytes32 slate => address[] yays) public slates;\n    mapping(address usr   => bytes32 slate)  public votes;\n    mapping(address yay   => uint256 amt)    public approvals;\n    mapping(address usr   => uint256 amt)    public deposits;\n    uint256                                  public last;\n\n    GemLike public immutable gov;\n    uint256 public immutable maxYays;\n    uint256 public immutable launchThreshold;\n    uint256 public immutable liftCooldown;\n\n    bytes32 public constant EMPTY_SLATE   = keccak256(abi.encodePacked(new address[](0)));\n\n    event Launch();\n    event Lock(address indexed usr, uint256 wad);\n    event Free(address indexed usr, uint256 wad);\n    event Etch(bytes32 indexed slate, address[] yays);\n    event Vote(address indexed usr, bytes32 indexed slate);\n    event Lift(address indexed whom);\n\n    constructor(address gov_, uint256 maxYays_, uint256 launchThreshold_, uint256 liftCooldown_) {\n        gov = GemLike(gov_);\n        maxYays = maxYays_;\n        launchThreshold = launchThreshold_;\n        liftCooldown = liftCooldown_;\n    }\n\n    function _addWeight(uint256 weight, bytes32 slate) internal {\n        address[] memory yays = slates[slate];\n        for (uint256 i = 0; i < yays.length;) {\n            approvals[yays[i]] += weight;\n            unchecked { ++i; } // bounded by max array length\n        }\n    }\n\n    function _subWeight(uint256 weight, bytes32 slate) internal {\n        address[] memory yays = slates[slate];\n        for (uint256 i = 0; i < yays.length;) {\n            approvals[yays[i]] -= weight;\n            unchecked { ++i; } // bounded by max array length\n        }\n    }\n\n    function length(bytes32 slate) external view returns (uint256) {\n        return slates[slate].length;\n    }\n\n    function canCall(address caller, address, bytes4) external view returns (bool ok) {\n        ok = live == 1 && caller == hat;\n    }\n\n    function launch() external {\n        require(live == 0, \"Chief/already-live\");\n        require(hat == address(0), \"Chief/not-address-zero\");\n        require(approvals[address(0)] >= launchThreshold, \"Chief/less-than-threshold\");\n        live = 1;\n        last = block.number;\n        emit Launch();\n    }\n\n    function lock(uint256 wad) external {\n        gov.transferFrom(msg.sender, address(this), wad);\n        deposits[msg.sender] += wad;\n        _addWeight(wad, votes[msg.sender]);\n        emit Lock(msg.sender, wad);\n    }\n\n    function free(uint256 wad) external {\n        require(block.number > last, \"Chief/cant-free-same-block\");\n        deposits[msg.sender] -= wad;\n        _subWeight(wad, votes[msg.sender]);\n        gov.transfer(msg.sender, wad);\n        emit Free(msg.sender, wad);\n    }\n\n    function etch(address[] calldata yays) public returns (bytes32 slate) {\n        require(yays.length <= maxYays, \"Chief/greater-max-yays\");\n        if (yays.length > 1) {\n            unchecked { // bounded by min and max array length\n                for (uint256 i = 0; i < yays.length - 1;) {\n                    // strict inequality ensures both ordering and uniqueness\n                    require(yays[i] < yays[i + 1], \"Chief/yays-not-ordered\");\n                    ++i;\n                }\n            }\n        }\n        slate = keccak256(abi.encodePacked(yays));\n        slates[slate] = yays;\n        emit Etch(slate, yays);\n    }\n\n    function vote(address[] calldata yays) external returns (bytes32 slate) {\n        slate = etch(yays);\n        vote(slate);\n    }\n\n    function vote(bytes32 slate) public {\n        require(slates[slate].length > 0 || slate == EMPTY_SLATE, \"Chief/invalid-slate\");\n        uint256 weight = deposits[msg.sender];\n        _subWeight(weight, votes[msg.sender]);\n        votes[msg.sender] = slate;\n        _addWeight(weight, slate);\n        emit Vote(msg.sender, slate);\n    }\n\n    function lift(address whom) external {\n        require(block.number == last || block.number > last + liftCooldown, \"Chief/cant-lift-again-yet\");\n        require(approvals[whom] > approvals[hat], \"Chief/not-higher-current-hat\");\n        hat = whom;\n        last = block.number;\n        emit Lift(whom);\n    }\n\n    // Compatibility with old getters\n\n    function GOV() external view returns (address) {\n        return address(gov);\n    }\n\n    function MAX_YAYS() external view returns (uint256) {\n        return maxYays;\n    }\n}\n"
    }
}