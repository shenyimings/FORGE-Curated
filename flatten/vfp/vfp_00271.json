{
    "vfp_id": "vfp_00271",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect debt repayment order in BorrowLogic",
            "description": "The repay function in BorrowLogic.sol pays principal first, then restaker debt, and interest last, which contradicts its own documentation stating that interest should be paid first. The root cause is a logic inconsistency between implementation and documentation. This could lead to incorrect debt accounting, especially in edge cases like liquidations or partial repayments. Users or external systems relying on the documented behavior may experience unexpected outcomes. The impact includes financial discrepancies, reduced trust in the protocol, and potential for disputes or exploits if attackers can manipulate repayment sequences.\n",
            "severity": null,
            "location": [
                "contracts/lendingPool/libraries/BorrowLogic.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/BorrowLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "BorrowLogic.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IDebtToken } from \"../../interfaces/IDebtToken.sol\";\nimport { IDelegation } from \"../../interfaces/IDelegation.sol\";\nimport { ILender } from \"../../interfaces/ILender.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { ViewLogic } from \"./ViewLogic.sol\";\nimport { AgentConfiguration } from \"./configuration/AgentConfiguration.sol\";\n\n/// @title BorrowLogic\n/// @author kexley, @capLabs\n/// @notice Logic for borrowing and repaying assets from the Lender\n/// @dev Interest rates for borrowing are not based on utilization like other lending markets.\n/// Instead the rates are based on a benchmark rate per asset set by an admin or an alternative\n/// lending market rate, whichever is higher. Indexes representing the increase of interest over\n/// time are pulled from an oracle. A separate interest rate is set by admin per agent which is\n/// paid to the restakers that guarantee the agent.\nlibrary BorrowLogic {\n    using SafeERC20 for IERC20;\n    using AgentConfiguration for ILender.AgentConfigurationMap;\n\n    /// @dev An agent has borrowed an asset from the Lender\n    event Borrow(address indexed asset, address indexed agent, uint256 amount);\n\n    /// @dev An agent, or someone on behalf of an agent, has repaid\n    event Repay(address indexed asset, address indexed agent, uint256 repaid);\n\n    /// @dev An agent has totally repaid their debt of an asset including all interests\n    event TotalRepayment(address indexed agent, address indexed asset);\n\n    /// @dev Realize interest before it is repaid by agents\n    event RealizeInterest(address indexed asset, uint256 realizedInterest, address interestReceiver);\n\n    /// @dev Trying to realize zero interest\n    error ZeroRealization();\n\n    /// @notice Borrow an asset from the Lender, minting a debt token which must be repaid\n    /// @dev Interest debt token is updated before principal token is minted to bring index up to date.\n    /// Restaker debt token is updated after so the new principal debt can be used in calculations\n    /// @param $ Lender storage\n    /// @param params Parameters to borrow an asset\n    function borrow(ILender.LenderStorage storage $, ILender.BorrowParams memory params) external {\n        /// Realize restaker interest before borrowing\n        realizeRestakerInterest($, params.agent, params.asset);\n\n        ValidationLogic.validateBorrow($, params);\n\n        ILender.ReserveData storage reserve = $.reservesData[params.asset];\n        if (!$.agentConfig[params.agent].isBorrowing(reserve.id)) {\n            $.agentConfig[params.agent].setBorrowing(reserve.id, true);\n        }\n\n        IVault(reserve.vault).borrow(params.asset, params.amount, params.receiver);\n\n        IDebtToken(reserve.debtToken).mint(params.agent, params.amount);\n\n        reserve.debt += params.amount;\n\n        emit Borrow(params.agent, params.asset, params.amount);\n    }\n\n    /// @notice Repay an asset, burning the debt token and/or paying down interest\n    /// @dev Only the amount owed or specified will be taken from the repayer, whichever is lower.\n    /// Interest is expected to have been realized so is included in the reserve debt. Once reserve\n    /// debt is paid down the remaining amount is sent to the fee auction.\n    /// @param $ Lender storage\n    /// @param params Parameters to repay a debt\n    /// @return repaid Actual amount repaid\n    function repay(ILender.LenderStorage storage $, ILender.RepayParams memory params)\n        external\n        returns (uint256 repaid)\n    {\n        /// Realize restaker interest before repaying\n        realizeRestakerInterest($, params.agent, params.asset);\n\n        ILender.ReserveData storage reserve = $.reservesData[params.asset];\n\n        /// Can only repay up to the amount owed\n        repaid = Math.min(params.amount, IERC20(reserve.debtToken).balanceOf(params.agent));\n\n        IDebtToken(reserve.debtToken).burn(params.agent, repaid);\n        IERC20(params.asset).safeTransferFrom(params.caller, address(this), repaid);\n\n        if (IERC20(reserve.debtToken).balanceOf(params.agent) == 0) {\n            $.agentConfig[params.agent].setBorrowing(reserve.id, false);\n            emit TotalRepayment(params.agent, params.asset);\n        }\n\n        uint256 remaining = repaid;\n        uint256 interestRepaid;\n        uint256 restakerRepaid;\n\n        if (repaid > reserve.unrealizedInterest[params.agent] + reserve.debt) {\n            interestRepaid = repaid - (reserve.debt + reserve.unrealizedInterest[params.agent]);\n            remaining -= interestRepaid;\n        }\n\n        if (remaining > reserve.unrealizedInterest[params.agent]) {\n            restakerRepaid = reserve.unrealizedInterest[params.agent];\n            remaining -= restakerRepaid;\n        } else {\n            restakerRepaid = remaining;\n            remaining = 0;\n        }\n\n        uint256 vaultRepaid = Math.min(remaining, reserve.debt);\n\n        if (restakerRepaid > 0) {\n            reserve.unrealizedInterest[params.agent] -= restakerRepaid;\n            IERC20(params.asset).safeTransfer($.delegation, restakerRepaid);\n            IDelegation($.delegation).distributeRewards(params.agent, params.asset);\n        }\n\n        if (vaultRepaid > 0) {\n            reserve.debt -= vaultRepaid;\n            IERC20(params.asset).forceApprove(reserve.vault, vaultRepaid);\n            IVault(reserve.vault).repay(params.asset, vaultRepaid);\n        }\n\n        if (interestRepaid > 0) {\n            IERC20(params.asset).safeTransfer(reserve.interestReceiver, interestRepaid);\n        }\n\n        emit Repay(params.agent, params.asset, repaid);\n    }\n\n    /// @notice Realize the interest before it is repaid by borrowing from the vault\n    /// @param $ Lender storage\n    /// @param _asset Asset to realize interest for\n    /// @return realizedInterest Actual realized interest\n    function realizeInterest(ILender.LenderStorage storage $, address _asset)\n        external\n        returns (uint256 realizedInterest)\n    {\n        ILender.ReserveData storage reserve = $.reservesData[_asset];\n        realizedInterest = maxRealization($, _asset);\n        if (realizedInterest == 0) revert ZeroRealization();\n\n        reserve.debt += realizedInterest;\n        IVault(reserve.vault).borrow(_asset, realizedInterest, reserve.interestReceiver);\n        emit RealizeInterest(_asset, realizedInterest, reserve.interestReceiver);\n    }\n\n    /// @notice Realize the restaker interest before it is repaid by borrowing from the vault\n    /// @dev If more interest is owed than available in the vault then some portion is unrealized\n    /// and added to the agent's debt to be paid during repayments.\n    /// @param $ Lender storage\n    /// @param _agent Address of the restaker\n    /// @param _asset Asset to realize restaker interest for\n    /// @return realizedInterest Actual realized restaker interest\n    function realizeRestakerInterest(ILender.LenderStorage storage $, address _agent, address _asset)\n        public\n        returns (uint256 realizedInterest)\n    {\n        ILender.ReserveData storage reserve = $.reservesData[_asset];\n        uint256 unrealizedInterest;\n        (realizedInterest, unrealizedInterest) = maxRestakerRealization($, _agent, _asset);\n        reserve.lastRealizationTime[_agent] = block.timestamp;\n\n        if (realizedInterest == 0 && unrealizedInterest == 0) return 0;\n\n        reserve.debt += realizedInterest;\n        reserve.unrealizedInterest[_agent] += unrealizedInterest;\n\n        IDebtToken(reserve.debtToken).mint(_agent, realizedInterest + unrealizedInterest);\n        IVault(reserve.vault).borrow(_asset, realizedInterest, $.delegation);\n        IDelegation($.delegation).distributeRewards(_agent, _asset);\n        emit RealizeInterest(_asset, realizedInterest, $.delegation);\n    }\n\n    /// @notice Calculate the maximum interest that can be realized\n    /// @param $ Lender storage\n    /// @param _asset Asset to calculate max realization for\n    /// @return realization Maximum interest that can be realized\n    function maxRealization(ILender.LenderStorage storage $, address _asset)\n        internal\n        view\n        returns (uint256 realization)\n    {\n        ILender.ReserveData storage reserve = $.reservesData[_asset];\n        uint256 totalDebt = IERC20(reserve.debtToken).totalSupply();\n        uint256 reserves = IVault(reserve.vault).availableBalance(_asset);\n\n        if (totalDebt > reserve.debt) {\n            realization = totalDebt - reserve.debt;\n        }\n        if (reserves < realization) {\n            realization = reserves;\n        }\n    }\n\n    /// @notice Calculate the maximum interest that can be realized for a restaker\n    /// @param $ Lender storage\n    /// @param _agent Address of the restaker\n    /// @param _asset Asset to calculate max realization for\n    /// @return realization Maximum interest that can be realized\n    /// @return unrealizedInterest Unrealized interest that can be realized\n    function maxRestakerRealization(ILender.LenderStorage storage $, address _agent, address _asset)\n        internal\n        view\n        returns (uint256 realization, uint256 unrealizedInterest)\n    {\n        uint256 accruedInterest = ViewLogic.accruedRestakerInterest($, _agent, _asset);\n        uint256 reserves = IVault($.reservesData[_asset].vault).availableBalance(_asset);\n\n        realization = accruedInterest;\n        if (realization > reserves) {\n            unrealizedInterest = realization - reserves;\n            realization = reserves;\n        }\n    }\n}\n"
    }
}