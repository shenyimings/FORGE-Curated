{
    "vfp_id": "vfp_00317",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Forced Inclusion and Permissionless Fallback Can Be Throttled via `LastProcessedAt` Coupling",
            "description": "The forced inclusion mechanism uses `lastProcessedAt` to determine when a transaction is due, but this value is updated every time any forced inclusion is processed. A malicious proposer can exploit this by processing only one transaction at a time (e.g., `minForcedInclusionCount = 1`), which resets `lastProcessedAt` to the current timestamp, thereby pushing the due time of subsequent transactions forward by another `forcedInclusionDelay`.\n\nThe root cause is the coupling of liveness guarantees to `lastProcessedAt` instead of strictly to submission timestamps. This allows a censoring proposer to throttle the queue clearance rate, making the delay for the k-th transaction approximately `k × forcedInclusionDelay`. The permissionless fallback is similarly weakened because its activation threshold also depends on `lastProcessedAt`, which a malicious proposer can keep recent to prevent the fallback from ever activating.\n\nThe impact is a degraded forced inclusion mechanism that fails to provide strong liveness guarantees under adversarial conditions. Even though the queue is FIFO and censorship is not permanent, users may experience unbounded delays, undermining the safety valve intended for worst-case scenarios like proposer collusion or systemic bugs.\n",
            "severity": "Low",
            "location": [
                "LibForcedInclusion.sol::#172",
                "Inbox.sol::_dequeueAndProcessForcedInclusions#883"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/libs/LibForcedInclusion.sol"
            ]
        }
    ],
    "affected_files": {
        "LibForcedInclusion.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IForcedInclusionStore } from \"../iface/IForcedInclusionStore.sol\";\nimport { LibBlobs } from \"../libs/LibBlobs.sol\";\nimport { LibMath } from \"src/shared/libs/LibMath.sol\";\n\n/// @title LibForcedInclusion\n/// @dev Library for storing and managing forced inclusion requests. Forced inclusions\n/// allow users to pay a fee to ensure their transactions are included in a block. The library\n/// maintains a FIFO queue of inclusion requests.\n/// @dev Inclusion delay is measured in seconds, since we don't have an easy way to get batch number\n/// in the Shasta design.\n/// @dev We only allow one forced inclusion per L1 transaction to avoid spamming the proposer.\n/// @dev Forced inclusions are limited to 1 blob only, and one L2 block only(this and other protocol\n/// constrains are enforced by the node and verified by the prover)\n/// @custom:security-contact security@taiko.xyz\nlibrary LibForcedInclusion {\n    using LibMath for uint48;\n    using LibMath for uint256;\n\n    // ---------------------------------------------------------------\n    //  Structs\n    // ---------------------------------------------------------------\n\n    /// @dev Storage for the forced inclusion queue. This struct uses 2 slots.\n    /// @dev 2 slots used\n    struct Storage {\n        mapping(uint256 id => IForcedInclusionStore.ForcedInclusion inclusion) queue;\n        /// @notice The index of the oldest forced inclusion in the queue. This is where items will\n        /// be dequeued.\n        uint48 head;\n        /// @notice The index of the next free slot in the queue. This is where items will be\n        /// enqueued.\n        uint48 tail;\n        /// @notice The last time a forced inclusion was processed.\n        uint48 lastProcessedAt;\n    }\n\n    // ---------------------------------------------------------------\n    //  Public Functions\n    // ---------------------------------------------------------------\n\n    /// @dev See `IForcedInclusionStore.saveForcedInclusion`\n    function saveForcedInclusion(\n        Storage storage $,\n        uint64 _baseFeeInGwei,\n        uint64 _feeDoubleThreshold,\n        LibBlobs.BlobReference memory _blobReference\n    )\n        public\n        returns (uint256 refund_)\n    {\n        LibBlobs.BlobSlice memory blobSlice = LibBlobs.validateBlobReference(_blobReference);\n\n        uint64 requiredFeeInGwei =\n            getCurrentForcedInclusionFee($, _baseFeeInGwei, _feeDoubleThreshold);\n        uint256 requiredFee = requiredFeeInGwei * 1 gwei;\n        require(msg.value >= requiredFee, InsufficientFee());\n\n        IForcedInclusionStore.ForcedInclusion memory inclusion =\n            IForcedInclusionStore.ForcedInclusion({\n                feeInGwei: requiredFeeInGwei, blobSlice: blobSlice\n            });\n\n        $.queue[$.tail++] = inclusion;\n\n        emit IForcedInclusionStore.ForcedInclusionSaved(inclusion);\n\n        // Calculate and return refund amount\n        unchecked {\n            refund_ = msg.value - requiredFee;\n        }\n    }\n\n    /// @dev See `IForcedInclusionStore.getCurrentForcedInclusionFee`\n    function getCurrentForcedInclusionFee(\n        Storage storage $,\n        uint64 _baseFeeInGwei,\n        uint64 _feeDoubleThreshold\n    )\n        public\n        view\n        returns (uint64 feeInGwei_)\n    {\n        require(_feeDoubleThreshold > 0, InvalidFeeDoubleThreshold());\n\n        (uint48 head, uint48 tail) = ($.head, $.tail);\n        uint256 numPending = uint256(tail - head);\n\n        // Linear scaling formula: fee = baseFee × (threshold + numPending) / threshold\n        // This is mathematically equivalent to: fee = baseFee × (1 + numPending / threshold)\n        // but avoids floating point arithmetic\n        uint256 multipliedFee = _baseFeeInGwei * (_feeDoubleThreshold + numPending);\n        feeInGwei_ = uint64((multipliedFee / _feeDoubleThreshold).min(type(uint64).max));\n    }\n\n    /// @notice Returns forced inclusions stored starting from a given index.\n    /// @dev Returns an empty array if `_start` is outside the valid range [head, tail) or if\n    ///      `_maxCount` is zero. Otherwise returns actual stored entries from the queue.\n    /// @param _start The queue index to start reading from (must be in range [head, tail)).\n    /// @param _maxCount Maximum number of inclusions to return. Passing zero returns an empty array.\n    /// @return inclusions_ Forced inclusions from the queue starting at `_start`. The actual length\n    ///         will be `min(_maxCount, tail - _start)`, or zero if `_start` is out of range.\n    function getForcedInclusions(\n        Storage storage $,\n        uint48 _start,\n        uint48 _maxCount\n    )\n        internal\n        view\n        returns (IForcedInclusionStore.ForcedInclusion[] memory inclusions_)\n    {\n        unchecked {\n            (uint48 head, uint48 tail) = ($.head, $.tail);\n\n            if (_start < head || _start >= tail || _maxCount == 0) {\n                return new IForcedInclusionStore.ForcedInclusion[](0);\n            }\n\n            uint256 count = uint256(tail - _start).min(_maxCount);\n\n            inclusions_ = new IForcedInclusionStore.ForcedInclusion[](count);\n\n            for (uint256 i; i < count; ++i) {\n                inclusions_[i] = $.queue[i + _start];\n            }\n        }\n    }\n\n    /// @dev Returns the queue pointers for the forced inclusion storage.\n    /// @param $ Storage instance tracking the forced inclusion queue.\n    /// @return head_ Index of the next forced inclusion to dequeue.\n    /// @return tail_ Index where the next forced inclusion will be enqueued.\n    /// @return lastProcessedAt_ Timestamp of the most recent forced inclusion processing.\n    function getForcedInclusionState(Storage storage $)\n        internal\n        view\n        returns (uint48 head_, uint48 tail_, uint48 lastProcessedAt_)\n    {\n        (head_, tail_, lastProcessedAt_) = ($.head, $.tail, $.lastProcessedAt);\n    }\n\n    // ---------------------------------------------------------------\n    // Internal functions\n    // ---------------------------------------------------------------\n\n    /// @dev Checks if the oldest remaining forced inclusion is due\n    /// @param $ Storage reference\n    /// @param _head Current queue head position\n    /// @param _tail Current queue tail position\n    /// @param _lastProcessedAt Timestamp of last processing\n    /// @param _forcedInclusionDelay Delay in seconds before inclusion is due\n    /// @return True if the oldest remaining inclusion is due for processing\n    function isOldestForcedInclusionDue(\n        Storage storage $,\n        uint48 _head,\n        uint48 _tail,\n        uint48 _lastProcessedAt,\n        uint16 _forcedInclusionDelay\n    )\n        internal\n        view\n        returns (bool)\n    {\n        unchecked {\n            if (_head == _tail) return false;\n\n            uint256 timestamp = $.queue[_head].blobSlice.timestamp;\n            if (timestamp == 0) return false;\n\n            return block.timestamp >= timestamp.max(_lastProcessedAt) + _forcedInclusionDelay;\n        }\n    }\n\n    // ---------------------------------------------------------------\n    // Errors\n    // ---------------------------------------------------------------\n\n    error InsufficientFee();\n    error InvalidFeeDoubleThreshold();\n}\n"
    }
}