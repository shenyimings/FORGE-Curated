{
    "vfp_id": "vfp_00523",
    "project_name": "SoSoValue - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "The getOrderHashs function returns the array growing indefinitely",
            "description": "The `getOrderHashs` function in the USSI contract returns all stored order hashes by creating an array of the current length and copying each entry. Since the list of order hashes grows with each new order and never expires, the function will eventually consume excessive gas and may revert due to block gas limits.\n\nThe cause is the lack of any pruning mechanism or pagination in the order hash storage. The function attempts to return the entire list in one call, which becomes increasingly expensive over time.\n\nAn attacker could exploit this by flooding the system with orders, forcing the order hash list to grow until the function becomes unusable.\n\nThe impact is that off-chain systems relying on `getOrderHashs` may fail to retrieve data in the future, disrupting monitoring or indexing services. While it does not directly affect on-chain logic, it degrades system usability and reliability.\n",
            "severity": "Low",
            "location": [
                "USSI::getOrderHashs"
            ],
            "files": [
                "ssi-protocol/src/USSI.sol"
            ]
        }
    ],
    "affected_files": {
        "USSI.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.25;\nimport './Interface.sol';\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"forge-std/console.sol\";\n\ncontract USSI is Initializable, OwnableUpgradeable, AccessControlUpgradeable, ERC20Upgradeable, UUPSUpgradeable, PausableUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20 for IERC20;\n\n    enum HedgeOrderType { NONE, MINT, REDEEM }\n    enum HedgeOrderStatus { NONE, PENDING, REJECTED, CONFIRMED }\n\n    struct HedgeOrder {\n        string chain;\n        HedgeOrderType orderType;\n        uint256 assetID;\n        address redeemToken;\n        uint256 nonce;\n        uint256 inAmount;\n        uint256 outAmount;\n        uint256 deadline;\n        address requester;\n        address receiver;\n    }\n\n    EnumerableSet.Bytes32Set orderHashs;\n    mapping(bytes32 => HedgeOrder) public hedgeOrders;\n    mapping(bytes32 => HedgeOrderStatus) public orderStatus;\n    mapping(bytes32 => uint256) public requestTimestamps;\n\n    EnumerableSet.UintSet supportAssetIDs;\n\n    address public redeemToken;\n    address public orderSigner;\n    address public factoryAddress;\n\n    bytes32 public constant PARTICIPANT_ROLE = keccak256(\"PARTICIPANT_ROLE\");\n\n    mapping(bytes32 => bytes32) public redeemTxHashs;\n\n    string public chain;\n\n    event AddAssetID(uint256 assetID);\n    event RemoveAssetID(uint256 assetID);\n    event UpdateOrderSigner(address oldOrderSigner, address orderSigner);\n    event UpdateRedeemToken(address oldRedeemToken, address redeemToken);\n    event ApplyMint(HedgeOrder hedgeOrder);\n    event RejectMint(bytes32 orderHash);\n    event ConfirmMint(bytes32 orderHash);\n    event ApplyRedeem(HedgeOrder hedgeOrder);\n    event RejectRedeem(bytes32 orderHash);\n    event ConfirmRedeem(bytes32 orderHash);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address owner, address orderSigner_, address factoryAddress_, address redeemToken_, string memory chain_) public initializer {\n        __Ownable_init(owner);\n        __AccessControl_init();\n        __ERC20_init(\"USSI\", \"USSI\");\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n        require(factoryAddress_ != address(0), \"zero factory address\");\n        require(redeemToken_ != address(0), \"zero redeem token address\");\n        require(orderSigner_ != address(0), \"zero order signer address\");\n        factoryAddress = factoryAddress_;\n        redeemToken = redeemToken_;\n        orderSigner = orderSigner_;\n        chain = chain_;\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function decimals() public pure override(ERC20Upgradeable) returns (uint8) {\n        return 8;\n    }\n\n    function getSupportAssetIDs() external view returns (uint256[] memory assetIDs) {\n        assetIDs = new uint256[](supportAssetIDs.length());\n        for (uint i = 0; i < assetIDs.length; i++) {\n            assetIDs[i] = supportAssetIDs.at(i);\n        }\n    }\n\n    function addSupportAsset(uint256 assetID) external onlyOwner {\n        require(IAssetFactory(factoryAddress).hasAssetID(assetID), \"asset not exists\");\n        require(!supportAssetIDs.contains(assetID), \"already contains assetID\");\n        supportAssetIDs.add(assetID);\n        emit AddAssetID(assetID);\n    }\n\n    function removeSupportAsset(uint256 assetID) external onlyOwner {\n        require(IAssetFactory(factoryAddress).hasAssetID(assetID), \"asset not exists\");\n        require(supportAssetIDs.contains(assetID), \"assetID is not supported\");\n        supportAssetIDs.remove(assetID);\n        emit RemoveAssetID(assetID);\n    }\n\n    function updateOrderSigner(address orderSigner_) external onlyOwner {\n        address oldOrderSigner = orderSigner;\n        require(orderSigner_ != address(0), \"orderSigner is zero address\");\n        require(orderSigner_ != orderSigner, \"orderSigner not change\");\n        orderSigner = orderSigner_;\n        emit UpdateOrderSigner(oldOrderSigner, orderSigner);\n    }\n\n    function updateRedeemToken(address redeemToken_) external onlyOwner {\n        address oldRedeemToken = redeemToken;\n        require(redeemToken_ != address(0), \"redeem token is zero address\");\n        require(redeemToken_ != redeemToken, \"redeem token not change\");\n        redeemToken = redeemToken_;\n        emit UpdateRedeemToken(oldRedeemToken, redeemToken);\n    }\n\n    function checkHedgeOrder(HedgeOrder calldata hedgeOrder, bytes32 orderHash, bytes calldata orderSignature) public view {\n        require(keccak256(abi.encode(chain)) == keccak256(abi.encode(hedgeOrder.chain)), \"chain not match\");\n        if (hedgeOrder.orderType == HedgeOrderType.MINT) {\n            require(supportAssetIDs.contains(hedgeOrder.assetID), \"assetID not supported\");\n        }\n        if (hedgeOrder.orderType == HedgeOrderType.REDEEM) {\n            require(hedgeOrder.receiver != address(0), \"receiver is zero address\");\n            require(redeemToken == hedgeOrder.redeemToken, \"redeem token not supported\");\n        }\n        require(block.timestamp <= hedgeOrder.deadline, \"expired\");\n        require(!orderHashs.contains(orderHash), \"order already exists\");\n        require(SignatureChecker.isValidSignatureNow(orderSigner, orderHash, orderSignature), \"signature not valid\");\n    }\n\n    function setHedgeOrder(bytes32 orderHash, HedgeOrder calldata hedgeOrder) internal {\n        HedgeOrder storage hedgeOrder_ = hedgeOrders[orderHash];\n        hedgeOrder_.chain = hedgeOrder.chain;\n        hedgeOrder_.orderType = hedgeOrder.orderType;\n        hedgeOrder_.assetID = hedgeOrder.assetID;\n        hedgeOrder_.redeemToken = redeemToken;\n        hedgeOrder_.nonce = hedgeOrder.nonce;\n        hedgeOrder_.inAmount = hedgeOrder.inAmount;\n        hedgeOrder_.outAmount = hedgeOrder.outAmount;\n        hedgeOrder_.deadline = hedgeOrder.deadline;\n        hedgeOrder_.requester = hedgeOrder.requester;\n        hedgeOrder_.receiver = hedgeOrder.receiver;\n        orderHashs.add(orderHash);\n    }\n\n    function applyMint(HedgeOrder calldata hedgeOrder, bytes calldata orderSignature) external onlyRole(PARTICIPANT_ROLE) whenNotPaused {\n        require(hedgeOrder.requester == msg.sender, \"msg sender is not requester\");\n        bytes32 orderHash = keccak256(abi.encode(hedgeOrder));\n        checkHedgeOrder(hedgeOrder, orderHash, orderSignature);\n        require(hedgeOrder.orderType == HedgeOrderType.MINT, \"order type not match\");\n        // cannot hedge when underlying is changing\n        IAssetToken assetToken = IAssetToken(IAssetFactory(factoryAddress).assetTokens(hedgeOrder.assetID));\n        require(!assetToken.rebalancing(), \"asset token is rebalancing\");\n        require(assetToken.feeCollected(), \"asset token has fee not collected\");\n        setHedgeOrder(orderHash, hedgeOrder);\n        orderStatus[orderHash] = HedgeOrderStatus.PENDING;\n        requestTimestamps[orderHash] = block.timestamp;\n        require(IERC20(assetToken).allowance(hedgeOrder.requester, address(this)) >= hedgeOrder.inAmount, \"not enough allowance\");\n        IERC20(assetToken).safeTransferFrom(hedgeOrder.requester, address(this), hedgeOrder.inAmount);\n        emit ApplyMint(hedgeOrder);\n    }\n\n    function rejectMint(bytes32 orderHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.MINT, \"order type not match\");\n        orderStatus[orderHash] = HedgeOrderStatus.REJECTED;\n        IERC20 assetToken = IERC20(IAssetFactory(factoryAddress).assetTokens(hedgeOrder.assetID));\n        assetToken.safeTransfer(hedgeOrder.requester, hedgeOrder.inAmount);\n        emit RejectMint(orderHash);\n    }\n\n    function confirmMint(bytes32 orderHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.MINT, \"order type not match\");\n        _mint(hedgeOrder.requester, hedgeOrder.outAmount);\n        orderStatus[orderHash] = HedgeOrderStatus.CONFIRMED;\n        IERC20 assetToken = IERC20(IAssetFactory(factoryAddress).assetTokens(hedgeOrder.assetID));\n        IAssetIssuer issuer = IAssetIssuer(IAssetFactory(factoryAddress).issuers(hedgeOrder.assetID));\n        if (assetToken.allowance(address(this), address(issuer)) < hedgeOrder.inAmount) {\n            assetToken.forceApprove(address(issuer), hedgeOrder.inAmount);\n        }\n        issuer.burnFor(hedgeOrder.assetID, hedgeOrder.inAmount);\n        emit ConfirmMint(orderHash);\n    }\n\n    function applyRedeem(HedgeOrder calldata hedgeOrder, bytes calldata orderSignature) external onlyRole(PARTICIPANT_ROLE) whenNotPaused {\n        require(hedgeOrder.requester == msg.sender, \"msg sender is not requester\");\n        bytes32 orderHash = keccak256(abi.encode(hedgeOrder));\n        checkHedgeOrder(hedgeOrder, orderHash, orderSignature);\n        require(hedgeOrder.orderType == HedgeOrderType.REDEEM, \"order type not match\");\n        require(allowance(hedgeOrder.requester, address(this)) >= hedgeOrder.inAmount, \"not enough allowance\");\n        setHedgeOrder(orderHash, hedgeOrder);\n        orderStatus[orderHash] = HedgeOrderStatus.PENDING;\n        requestTimestamps[orderHash] = block.timestamp;\n        IERC20(address(this)).safeTransferFrom(hedgeOrder.requester, address(this), hedgeOrder.inAmount);\n        emit ApplyRedeem(hedgeOrder);\n    }\n\n    function rejectRedeem(bytes32 orderHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.REDEEM, \"order type not match\");\n        orderStatus[orderHash] = HedgeOrderStatus.REJECTED;\n        IERC20(address(this)).safeTransfer(hedgeOrder.requester, hedgeOrder.inAmount);\n        emit RejectRedeem(orderHash);\n    }\n\n    function confirmRedeem(bytes32 orderHash, bytes32 txHash) external onlyOwner {\n        require(orderHashs.contains(orderHash), \"order not exists\");\n        require(orderStatus[orderHash] == HedgeOrderStatus.PENDING, \"order is not pending\");\n        HedgeOrder storage hedgeOrder = hedgeOrders[orderHash];\n        require(hedgeOrder.orderType == HedgeOrderType.REDEEM, \"order type not match\");\n        orderStatus[orderHash] = HedgeOrderStatus.CONFIRMED;\n        if (txHash == bytes32(0)) {\n            require(IERC20(hedgeOrder.redeemToken).balanceOf(address(this)) >= hedgeOrder.outAmount, \"not enough redeem token\");\n            IERC20(hedgeOrder.redeemToken).safeTransfer(hedgeOrder.requester, hedgeOrder.outAmount);\n        } else {\n            redeemTxHashs[orderHash] = txHash;\n        }\n        _burn(address(this), hedgeOrder.inAmount);\n        emit ConfirmRedeem(orderHash);\n    }\n\n    function getOrderHashs() external view returns (bytes32[] memory orderHashs_) {\n        orderHashs_ = new bytes32[](orderHashs.length());\n        for (uint i = 0; i < orderHashs.length(); i++) {\n            orderHashs_[i] = orderHashs.at(i);\n        }\n    }\n\n    function getOrderHashLength() external view returns (uint256) {\n        return orderHashs.length();\n    }\n\n    function getOrderHash(uint256 nonce) external view returns (bytes32) {\n        return orderHashs.at(nonce);\n    }\n}"
    }
}