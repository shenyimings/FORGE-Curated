{
    "vfp_id": "vfp_00371",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of Access Control Can Lead to Loss of Contract-Held Funds",
            "description": "The `handleV3AcrossMessage` function in `HyperliquidDepositHandler` is external and lacks access control, allowing any caller to trigger a bridge of the contract's token balance to a user on Hypercore.\nThe root cause is the absence of role-based restrictions on a sensitive function.\nAn attacker can call this function after tokens are mistakenly sent to the contract, draining them to an arbitrary Hypercore account.\nThe impact is loss of any funds that end up in the contract, whether by error or incomplete transactions, due to lack of protection.\n",
            "severity": "High",
            "location": [
                "HyperliquidDepositHandler.sol::handleV3AcrossMessage#93-101"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/handlers/HyperliquidDepositHandler.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Lack of Event Emission",
            "description": "The `addSupportedToken` function in `HyperliquidDepositHandler` modifies state by adding a new token configuration but does not emit an event.\nThe root cause is the omission of an event emission after a state-changing administrative action.\nOff-chain systems such as monitoring tools or front-ends cannot detect when new tokens are added or verify configuration changes.\nThe impact is reduced transparency, auditability, and operational visibility into the contract's configuration history.\n",
            "severity": "Medium",
            "location": [
                "HyperliquidDepositHandler.sol::addSupportedToken#60-72"
            ],
            "files": [
                "758570a9ace4a3c2335d2628342f71a33fbbc908/contracts/contracts/handlers/HyperliquidDepositHandler.sol"
            ]
        }
    ],
    "affected_files": {
        "HyperliquidDepositHandler.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/SpokePoolMessageHandler.sol\";\nimport \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-v4/security/ReentrancyGuard.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts-v4/utils/cryptography/ECDSA.sol\";\nimport { HyperCoreLib } from \"../libraries/HyperCoreLib.sol\";\nimport { Ownable } from \"@openzeppelin/contracts-v4/access/Ownable.sol\";\nimport { DonationBox } from \"../chain-adapters/DonationBox.sol\";\n\n/**\n * @title Allows caller to bridge tokens from HyperEVM to Hypercore and send them to an end user's account\n * on Hypercore.\n * @dev This contract should only be deployed on HyperEVM.\n * @dev This contract can replace a MulticallHandler on HyperEVM if the intent only wants to deposit tokens into\n * Hypercore and bypass the other complex arbitrary calldata logic.\n * @dev This contract can also be called directly to deposit tokens into Hypercore on behalf of an end user.\n */\ncontract HyperliquidDepositHandler is AcrossMessageHandler, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    struct TokenInfo {\n        // HyperEVM token address.\n        address evmAddress;\n        // Hypercore token index.\n        uint64 tokenId;\n        // Activation fee in EVM units. e.g. 1000000 ($1) for USDH.\n        uint256 activationFeeEvm;\n        // coreDecimals - evmDecimals. e.g. -2 for USDH.\n        int8 decimalDiff;\n    }\n\n    // Stores hardcoded Hypercore configurations for tokens that this handler supports.\n    mapping(address => TokenInfo) public supportedTokens;\n\n    // Donation box contract to store funds for account activation fees.\n    DonationBox public immutable donationBox;\n\n    // Address of the signer that will sign the payloads used for calling handleV3AcrossMessage. This signer\n    // should be one controlled by the Across API to prevent griefing attacks that attempt to drain the Donation Box.\n    address public signer;\n\n    // Address of the SpokePool contract that can call handleV3AcrossMessage.\n    address public spokePool;\n\n    // Track which accounts we have already sponsored for activation. Used to prevent griefing attacks when the same account is activated multiple times\n    // due to Hyperliquid's policy of removing dust from small accounts which technically could be taken advantage of by a griefer.\n    mapping(address => bool) public accountsActivated;\n\n    error InsufficientEvmAmountForActivation();\n    error TokenNotSupported();\n    error InvalidSignature();\n    error NotSpokePool();\n    error AccountAlreadyActivated();\n\n    event UserAccountActivated(address user, address indexed token, uint256 amountRequiredToActivate);\n    event AddedSupportedToken(address evmAddress, uint64 tokenId, uint256 activationFeeEvm, int8 decimalDiff);\n    event SignerSet(address signer);\n    event SpokePoolSet(address spokePool);\n\n    /**\n     * @notice Constructor.\n     * @dev Creates a new donation box contract owned by this contract.\n     * @param _signer Address of the signer that will sign the payloads used for calling handleV3AcrossMessage. This signer\n     * should be one controlled by the Across API to prevent griefing attacks that attempt to drain the Donation Box.\n     * @param _spokePool Address of the SpokePool contract that can call handleV3AcrossMessage.\n     */\n    constructor(address _signer, address _spokePool) {\n        donationBox = new DonationBox();\n        signer = _signer;\n        spokePool = _spokePool;\n    }\n\n    modifier onlySpokePool() {\n        if (msg.sender != spokePool) revert NotSpokePool();\n        _;\n    }\n\n    /// -------------------------------------------------------------------------------------------------------------\n    /// - PUBLIC FUNCTIONS -\n    /// -------------------------------------------------------------------------------------------------------------\n\n    /**\n     * @notice Bridges tokens from HyperEVM to Hypercore and sends them to the end user's account on Hypercore.\n     * @dev Requires msg.sender to have approved this contract to spend the tokens.\n     * @param token The address of the token to deposit.\n     * @param amount The amount of tokens on HyperEVM to deposit.\n     * @param user The address of the user on Hypercore to send the tokens to.\n     * @param signature Encoded signed message containing the end user address. The payload is designed to be signed\n     * by the Across API to prevent griefing attacks that attempt to drain the Donation Box.\n     */\n    function depositToHypercore(\n        address token,\n        uint256 amount,\n        address user,\n        bytes memory signature\n    ) external nonReentrant {\n        _verifySignature(user, signature);\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        _depositToHypercore(token, amount, user);\n    }\n\n    /**\n     * @notice Entrypoint function if this contract is called by the SpokePool contract following an intent fill.\n     * @dev Deposits tokens into Hypercore and sends them to the end user's account on Hypercore.\n     * @dev Requires msg.sender to be the SpokePool contract. This prevents someone from calling this function\n     * to drain funds that were accidentally dropped onto this contract.\n     * @param token The address of the token sent.\n     * @param amount The amount of tokens received by this contract.\n     * @param message Encoded signed message containing the end user address. The payload is designed to be signed\n     * by the Across API to prevent griefing attacks that attempt to drain the Donation Box.\n     */\n    function handleV3AcrossMessage(\n        address token,\n        uint256 amount,\n        address /* relayer */,\n        bytes memory message\n    ) external nonReentrant onlySpokePool {\n        (address user, bytes memory signature) = abi.decode(message, (address, bytes));\n        _verifySignature(user, signature);\n        _depositToHypercore(token, amount, user);\n    }\n\n    /// -------------------------------------------------------------------------------------------------------------\n    /// - ONLY OWNER FUNCTIONS -\n    /// -------------------------------------------------------------------------------------------------------------\n\n    /**\n     * @notice Sets the address of the signer that will sign the payloads used for calling handleV3AcrossMessage.\n     * @dev Caller must be owner of this contract.\n     * @param _signer Address of the signer that will sign the payloads used for calling handleV3AcrossMessage. This signer\n     * should be one controlled by the Across API to prevent griefing attacks that attempt to drain the Donation Box.\n     */\n    function setSigner(address _signer) external onlyOwner {\n        signer = _signer;\n        emit SignerSet(signer);\n    }\n\n    /**\n     * @notice Sets the address of the SpokePool contract that can call handleV3AcrossMessage.\n     * @dev Caller must be owner of this contract.\n     * @param _spokePool Address of the SpokePool contract that can call handleV3AcrossMessage.\n     */\n    function setSpokePool(address _spokePool) external onlyOwner {\n        spokePool = _spokePool;\n        emit SpokePoolSet(spokePool);\n    }\n\n    /**\n     * @notice Adds a new token to the supported tokens list.\n     * @dev Caller must be owner of this contract.\n     * @param evmAddress The address of the EVM token.\n     * @param tokenId The index of the Hypercore token.\n     * @param activationFeeEvm The activation fee in EVM units.\n     * @param decimalDiff The difference in decimals between the EVM and Hypercore tokens.\n     */\n    function addSupportedToken(\n        address evmAddress,\n        uint64 tokenId,\n        uint256 activationFeeEvm,\n        int8 decimalDiff\n    ) external onlyOwner {\n        supportedTokens[evmAddress] = TokenInfo({\n            evmAddress: evmAddress,\n            tokenId: tokenId,\n            activationFeeEvm: activationFeeEvm,\n            decimalDiff: decimalDiff\n        });\n        emit AddedSupportedToken(evmAddress, tokenId, activationFeeEvm, decimalDiff);\n    }\n\n    /**\n     * @notice Send Hypercore funds to a user from this contract's Hypercore account\n     * @dev The coreAmount parameter is specified in Hypercore units which often differs from the EVM units for the\n     * same token.\n     * @param token The token address\n     * @param coreAmount The amount of tokens on Hypercore to sweep\n     * @param user The address of the user to send the tokens to\n     */\n    function sweepCoreFundsToUser(address token, uint64 coreAmount, address user) external onlyOwner nonReentrant {\n        uint64 tokenIndex = _getTokenInfo(token).tokenId;\n        HyperCoreLib.transferERC20CoreToCore(tokenIndex, user, coreAmount);\n    }\n\n    /**\n     * @notice Send donation box funds to a user from this contract's address on HyperEVM\n     * @param token The token address\n     * @param amount The amount of tokens to sweep\n     * @param user The address of the user to send the tokens to\n     */\n    function sweepDonationBoxFundsToUser(address token, uint256 amount, address user) external onlyOwner nonReentrant {\n        donationBox.withdraw(IERC20(token), amount);\n        IERC20(token).safeTransfer(user, amount);\n    }\n\n    /**\n     * @notice Send ERC20 tokens to a user from this contract's address on HyperEVM\n     * @param token The token address\n     * @param evmAmount The amount of tokens to sweep\n     * @param user The address of the user to send the tokens to\n     */\n    function sweepERC20ToUser(address token, uint256 evmAmount, address user) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(user, evmAmount);\n    }\n\n    /// -------------------------------------------------------------------------------------------------------------\n    /// - INTERNAL FUNCTIONS -\n    /// -------------------------------------------------------------------------------------------------------------\n\n    function _depositToHypercore(address token, uint256 evmAmount, address user) internal {\n        TokenInfo memory tokenInfo = _getTokenInfo(token);\n        uint64 tokenIndex = tokenInfo.tokenId;\n        int8 decimalDiff = tokenInfo.decimalDiff;\n\n        bool userExists = HyperCoreLib.coreUserExists(user);\n        if (!userExists) {\n            if (accountsActivated[user]) revert AccountAlreadyActivated();\n            accountsActivated[user] = true;\n            // To activate an account, we must pay the activation fee from this contract's core account and then send 1\n            // wei to the user's account, so we pull the activation fee + 1 wei from the donation box. This contract\n            // does not allow the end user subtracting part of their received amount to use for the activation fee.\n            uint256 activationFee = tokenInfo.activationFeeEvm;\n            uint256 amountRequiredToActivate = activationFee + 1;\n            donationBox.withdraw(IERC20(token), amountRequiredToActivate);\n            // Deposit the activation fee + 1 wei into this contract's core account to pay for the user's\n            // account activation.\n            HyperCoreLib.transferERC20EVMToSelfOnCore(token, tokenIndex, amountRequiredToActivate, decimalDiff);\n            HyperCoreLib.transferERC20CoreToCore(tokenIndex, user, 1);\n            emit UserAccountActivated(user, token, amountRequiredToActivate);\n        }\n\n        HyperCoreLib.transferERC20EVMToCore(token, tokenIndex, user, evmAmount, decimalDiff);\n    }\n\n    function _verifySignature(address expectedUser, bytes memory signature) internal view returns (bool) {\n        /// @dev There is no nonce in this signature because an account on Hypercore can only be activated once\n        /// by this contract, so reusing a signature cannot be used to grief the DonationBox.\n        bytes32 expectedHash = keccak256(abi.encode(expectedUser));\n        if (ECDSA.recover(expectedHash, signature) != signer) revert InvalidSignature();\n    }\n\n    function _getTokenInfo(address evmAddress) internal view returns (TokenInfo memory) {\n        if (supportedTokens[evmAddress].evmAddress == address(0)) {\n            revert TokenNotSupported();\n        }\n        return supportedTokens[evmAddress];\n    }\n\n    // Native tokens are not supported by this contract, so there is no fallback function.\n}\n"
    }
}