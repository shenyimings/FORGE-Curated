{
    "vfp_id": "vfp_00371",
    "project_name": "Flare FAsset Review - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "The upgradeWNatContract function must now be called by governance or executor",
            "description": "1. **Description:** The upgradeWNatContract function in AgentCollateralFacet.sol previously allowed any agent vault owner to update the WNAT contract address, creating a risk of inconsistent state updates between the asset manager and collateral pool if the agent failed to act promptly.\n\n2. **Cause:** The access control was too permissive, relying only on onlyAgentVaultOwner, which allowed individual agents to trigger the upgrade. This could lead to accounting discrepancies if the collateral pool was not updated in sync.\n\n3. **Exploitation:** A malicious or negligent agent could delay or manipulate the update of the WNAT address in the collateral pool, leading to incorrect collateral accounting and potential financial loss.\n\n4. **Impact:** The inconsistency between contract states could result in incorrect collateral tracking, potentially leading to under- or over-collateralization and financial risk to the system.\n",
            "severity": "High",
            "location": [
                "AgentCollateralFacet.sol::upgradeWNatContract#(unknown line)"
            ],
            "files": [
                "fassets/contracts/assetManager/facets/AgentCollateralFacet.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Outdated comments",
            "description": "1. **Description:** The inline comments for the upgradeWNatContract function in both AgentCollateralFacet.sol and IIAssetManager.sol still state that the function can only be called by the agent vault owner, which is no longer accurate after the fix.\n\n2. **Cause:** The code was updated to restrict access to onlyImmediateGovernanceOrExecutor, but the associated documentation comments were not updated to reflect this change.\n\n3. **Exploitation:** While not directly exploitable, misleading comments can cause confusion for developers and auditors, potentially leading to incorrect assumptions about access control and introducing bugs during future maintenance.\n\n4. **Impact:** Reduced code clarity and maintainability, increasing the risk of human error during future development or audits.\n",
            "severity": "Informational",
            "location": [
                "AgentCollateralFacet.sol::upgradeWNatContract#(unknown line)",
                "IIAssetManager.sol::upgradeWNatContract#(unknown line)"
            ],
            "files": [
                "fassets/contracts/assetManager/facets/AgentCollateralFacet.sol",
                "fassets/contracts/assetManager/interfaces/IIAssetManager.sol"
            ]
        }
    ],
    "affected_files": {
        "IIAssetManager.sol": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport {IDiamondCut} from \"../../diamond/interfaces/IDiamondCut.sol\";\nimport {IGoverned} from \"../../governance/interfaces/IGoverned.sol\";\nimport {IAssetManager} from \"../../userInterfaces/IAssetManager.sol\";\nimport {IWNat} from \"../../flareSmartContracts/interfaces/IWNat.sol\";\nimport {IISettingsManagement} from \"./IISettingsManagement.sol\";\nimport {CollateralType} from \"../../userInterfaces/data/CollateralType.sol\";\nimport {EmergencyPause} from \"../../userInterfaces/data/EmergencyPause.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * Asset Manager methods used internally in AgentVault, CollateralPool and AssetManagerController.\n */\ninterface IIAssetManager is IAssetManager, IGoverned, IDiamondCut, IISettingsManagement {\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Settings update\n\n    /**\n     * When `attached` is true, asset manager has been added to the asset manager controller.\n     * Even though the asset manager controller address is set at the construction time, the manager may not\n     * be able to be added to the controller immediately because the method addAssetManager must be called\n     * by the governance multisig (with timelock). During this time it is impossible to verify through the\n     * controller that the asset manager is legit.\n     * Therefore creating agents and minting is disabled until the asset manager controller notifies\n     * the asset manager that it has been added.\n     * The `attached` can be set to false when the retired asset manager is removed from the controller.\n     * NOTE: this method will be called automatically when the asset manager is added to a controller\n     *      and cannot be called directly.\n     */\n    function attachController(bool attached) external;\n\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Emergency pause\n\n    /**\n     * Trigger pause of most operations.\n     */\n    function emergencyPause(EmergencyPause.Level _level, bool _byGovernance, uint256 _duration)\n        external;\n\n    /**\n     * Reset total duration of 3rd party pauses, so that they can trigger pause again.\n     * Otherwise, the total duration is automatically reset emergencyPauseDurationResetAfterSeconds after last pause.\n     */\n    function resetEmergencyPauseTotalDuration()\n        external;\n\n    /**\n     * Emergency pause details, useful for monitors.\n     */\n    function emergencyPauseDetails()\n        external view\n        returns (\n            EmergencyPause.Level _level,\n            uint256 _pausedUntil,\n            uint256 _totalPauseDuration,\n            EmergencyPause.Level _governanceLevel,\n            uint256 _governancePausedUntil\n        );\n\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Upgrade\n\n    /**\n     * When asset manager is paused, no new minting can be made.\n     * All other operations continue normally.\n     * NOTE: may not be called directly - only through asset manager controller by governance.\n     */\n    function pauseMinting() external;\n\n    /**\n     * Minting can continue.\n     * NOTE: may not be called directly - only through asset manager controller by governance.\n     */\n    function unpauseMinting() external;\n\n    /**\n     * When agent vault, collateral pool or collateral pool token factory is upgraded, new agent vaults\n     * automatically get the new implementation from the factory. The existing vaults can be batch updated\n     * by this method.\n     * Parameters `_start` and `_end` allow limiting the upgrades to a selection of all agents, to avoid\n     * breaking the block gas limit.\n     * NOTE: may not be called directly - only through asset manager controller by governance.\n     * @param _start the start index of the list of agent vaults (in getAllAgents()) to upgrade\n     * @param _end the end index (exclusive) of the list of agent vaults to upgrade;\n     *  can be larger then the number of agents, if gas is not an issue\n     */\n    function upgradeAgentVaultsAndPools(\n        uint256 _start,\n        uint256 _end\n    ) external;\n\n    /**\n     * When current pool collateral token contract (WNat) is replaced by the method setPoolWNatCollateralType,\n     * pools don't switch automatically. Instead, the agent must call this method that swaps old WNat tokens for\n     * new ones and sets it for use by the pool.\n     * NOTE: may only be called by the agent vault owner.\n     */\n    function upgradeWNatContract(\n        uint256 _start,\n        uint256 _end\n    ) external;\n\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Collateral type management\n\n    /**\n     * Add new vault collateral type (new token type and initial collateral ratios).\n     * NOTE: may not be called directly - only through asset manager controller by governance.\n     */\n    function addCollateralType(\n        CollateralType.Data calldata _data\n    ) external;\n\n    /**\n     * Update collateral ratios for collateral type identified by `_collateralClass` and `_token`.\n     * NOTE: may not be called directly - only through asset manager controller by governance.\n     */\n    function setCollateralRatiosForToken(\n        CollateralType.Class _collateralClass,\n        IERC20 _token,\n        uint256 _minCollateralRatioBIPS,\n        uint256 _safetyMinCollateralRatioBIPS\n    ) external;\n\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Collateral pool redemptions\n\n    /**\n     * Create a redemption from a single agent. Used in self-close exit from the collateral pool.\n     * NOTE: only collateral pool can call this method.\n     */\n    function redeemFromAgent(\n        address _agentVault,\n        address _receiver,\n        uint256 _amountUBA,\n        string memory _receiverUnderlyingAddress,\n        address payable _executor\n    ) external payable;\n\n    /**\n     * Burn fassets from  a single agent and get paid in vault collateral by the agent.\n     * Price is FTSO price, multiplied by factor buyFAssetByAgentFactorBIPS (set by agent).\n     * Used in self-close exit from the collateral pool when requested or when self-close amount is less than 1 lot.\n     * NOTE: only collateral pool can call this method.\n     */\n    function redeemFromAgentInCollateral(\n        address _agentVault,\n        address _receiver,\n        uint256 _amountUBA\n    ) external;\n\n    /**\n     * To avoid unlimited work, the maximum number of redemption tickets closed in redemption, self close\n     * or liquidation is limited. This means that a single redemption/self close/liquidation is limited.\n     * This function calculates the maximum single redemption amount.\n     */\n    function maxRedemptionFromAgent(address _agentVault)\n        external view\n        returns (uint256);\n\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Functions, used by agent vault during collateral deposit/withdraw\n\n    /**\n     * Called by AgentVault when agent calls `withdraw()`.\n     * NOTE: may only be called from an agent vault, not from an EOA address.\n     * @param _valueNATWei the withdrawn amount\n     */\n    function beforeCollateralWithdrawal(\n        IERC20 _token,\n        uint256 _valueNATWei\n    ) external;\n\n    /**\n     * Called by AgentVault when there was a deposit.\n     * May pull agent out of liquidation.\n     * NOTE: may only be called from an agent vault or collateral pool, not from an EOA address.\n     */\n    function updateCollateral(\n        address _agentVault,\n        IERC20 _token\n    ) external;\n\n    ////////////////////////////////////////////////////////////////////////////////////\n    // View functions used internally by agent vault and collateral pool.\n\n    /**\n     * Get current WNat contract set in the asset manager.\n     * Used internally by agent vault and collateral pool.\n     * @return WNat contract\n     */\n    function getWNat()\n        external view\n        returns (IWNat);\n\n    /**\n     * Returns price of asset (UBA) in NAT Wei as a fraction.\n     * Used internally by collateral pool.\n     */\n    function assetPriceNatWei()\n        external view\n        returns (uint256 _multiplier, uint256 _divisor);\n\n    /**\n     * Returns the number of f-assets that the agent's pool identified by `_agentVault` is backing.\n     * This is the same as the number of f-assets the agent is backing, but excluding\n     * f-assets being redeemed by pool self-close redemptions.\n     * Used internally by collateral pool.\n     */\n    function getFAssetsBackedByPool(address _agentVault)\n        external view\n        returns (uint256);\n\n    /**\n     * Returns the duration for which the collateral pool tokens are timelocked after minting.\n     * Timelocking is done to battle sandwich attacks aimed at stealing newly deposited f-asset\n     * fees from the pool.\n     */\n    function getCollateralPoolTokenTimelockSeconds()\n        external view\n        returns (uint256);\n\n    /**\n     * Check if `_token` is either vault collateral token for `_agentVault` or the pool token.\n     * These types of tokens cannot be simply transferred from the agent vault, but can only be\n     * withdrawn after announcement if they are not backing any f-assets.\n     * Used internally by agent vault.\n     */\n    function isLockedVaultToken(address _agentVault, IERC20 _token)\n        external view\n        returns (bool);\n\n    /**\n     * Check if `_token` is any of the vault collateral tokens (including already invalidated).\n     */\n    function isVaultCollateralToken(IERC20 _token)\n        external view\n        returns (bool);\n\n    /**\n     * True if `_address` is either work or management address of the owner of the agent identified by `_agentVault`.\n     * Used internally by agent vault.\n     */\n    function isAgentVaultOwner(address _agentVault, address _address)\n        external view\n        returns (bool);\n\n    /**\n     * Return the work address for the given management address.\n     */\n    function getWorkAddress(address _managementAddress)\n        external view\n        returns (address);\n}\n",
        "AgentCollateralFacet.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ReentrancyGuard} from \"../../openzeppelin/security/ReentrancyGuard.sol\";\nimport {AssetManagerBase} from \"./AssetManagerBase.sol\";\nimport {AgentCollateral} from \"../library/AgentCollateral.sol\";\nimport {Globals} from \"../library/Globals.sol\";\nimport {Liquidation} from \"../library/Liquidation.sol\";\nimport {Agents} from \"../library/Agents.sol\";\nimport {AgentUpdates} from \"../library/AgentUpdates.sol\";\nimport {Agent} from \"../library/data/Agent.sol\";\nimport {AssetManagerState} from \"../library/data/AssetManagerState.sol\";\nimport {Collateral} from \"../library/data/Collateral.sol\";\nimport {IWNat} from \"../../flareSmartContracts/interfaces/IWNat.sol\";\nimport {SafePct} from \"../../utils/library/SafePct.sol\";\nimport {CollateralType} from \"../../userInterfaces/data/CollateralType.sol\";\nimport {AssetManagerSettings} from \"../../userInterfaces/data/AssetManagerSettings.sol\";\nimport {IAssetManagerEvents} from \"../../userInterfaces/IAssetManagerEvents.sol\";\n\n\ncontract AgentCollateralFacet is AssetManagerBase, ReentrancyGuard {\n    using SafePct for uint256;\n    using SafeCast for uint256;\n    using AgentCollateral for Collateral.Data;\n    using Agents for Agent.State;\n    using AgentUpdates for Agent.State;\n\n    error WithdrawalInvalidAgentStatus();\n    error WithdrawalNotAnnounced();\n    error WithdrawalMoreThanAnnounced();\n    error WithdrawalNotAllowedYet();\n    error WithdrawalTooLate();\n    error WithdrawalCRTooLow();\n    error WithdrawalValueTooHigh();\n\n    error OnlyAgentVaultOrPool();\n    error CollateralWithdrawalAnnounced();\n    error FAssetNotTerminated();\n\n    /**\n     * Agent is going to withdraw `_valueNATWei` amount of collateral from agent vault.\n     * This has to be announced and agent must then wait `withdrawalWaitMinSeconds` time.\n     * After that time, agent can call withdraw(_valueNATWei) on agent vault.\n     * NOTE: may only be called by the agent vault owner.\n     * @param _agentVault agent vault address\n     * @param _valueNATWei the amount to be withdrawn\n     * @return _withdrawalAllowedAt the timestamp when the withdrawal can be made\n     */\n    function announceVaultCollateralWithdrawal(\n        address _agentVault,\n        uint256 _valueNATWei\n    )\n        external\n        notEmergencyPaused\n        onlyAgentVaultOwner(_agentVault)\n        returns (uint256 _withdrawalAllowedAt)\n    {\n        return _announceWithdrawal(Collateral.Kind.VAULT, _agentVault, _valueNATWei);\n    }\n\n    /**\n     * Agent is going to withdraw `_valueNATWei` amount of collateral from agent vault.\n     * This has to be announced and agent must then wait `withdrawalWaitMinSeconds` time.\n     * After that time, agent can call withdraw(_valueNATWei) on agent vault.\n     * NOTE: may only be called by the agent vault owner.\n     * @param _agentVault agent vault address\n     * @param _valueNATWei the amount to be withdrawn\n     * @return _redemptionAllowedAt the timestamp when the redemption can be made\n     */\n    function announceAgentPoolTokenRedemption(\n        address _agentVault,\n        uint256 _valueNATWei\n    )\n        external\n        notEmergencyPaused\n        onlyAgentVaultOwner(_agentVault)\n        returns (uint256 _redemptionAllowedAt)\n    {\n        return _announceWithdrawal(Collateral.Kind.AGENT_POOL, _agentVault, _valueNATWei);\n    }\n\n    /**\n     * Called by AgentVault when agent calls `withdraw()`.\n     * NOTE: may only be called from an agent vault, not from an EOA address.\n     * @param _amountWei the withdrawn amount\n     */\n    function beforeCollateralWithdrawal(\n        IERC20 _token,\n        uint256 _amountWei\n    )\n        external\n        notFullyEmergencyPaused\n    {\n        Agent.State storage agent = Agent.get(msg.sender);\n        Collateral.Kind kind;\n        if (_token == agent.getVaultCollateralToken()) {\n            kind = Collateral.Kind.VAULT;\n        } else if (_token == agent.collateralPool.poolToken()) {\n            kind = Collateral.Kind.AGENT_POOL;\n        } else {\n            return;     // we don't care about other token withdrawals from agent vault\n        }\n        Agent.WithdrawalAnnouncement storage withdrawal = agent.withdrawalAnnouncement(kind);\n        Collateral.Data memory collateralData = AgentCollateral.singleCollateralData(agent, kind);\n        // only agents that are not being liquidated can withdraw\n        // however, if the agent is in FULL_LIQUIDATION and totally liquidated,\n        // the withdrawals must still be possible, otherwise the collateral gets locked forever\n        require(agent.status == Agent.Status.NORMAL || agent.totalBackedAMG() == 0, WithdrawalInvalidAgentStatus());\n        require(withdrawal.allowedAt != 0, WithdrawalNotAnnounced());\n        require(_amountWei <= withdrawal.amountWei, WithdrawalMoreThanAnnounced());\n        require(block.timestamp >= withdrawal.allowedAt, WithdrawalNotAllowedYet());\n        AssetManagerSettings.Data storage settings = Globals.getSettings();\n        require(block.timestamp <= withdrawal.allowedAt + settings.agentTimelockedOperationWindowSeconds,\n            WithdrawalTooLate());\n        // Check that withdrawal doesn't reduce CR below mintingCR (withdrawal is not executed yet, but it balances\n        // with the withdrawal announcement that is still in effect).\n        // This would be equivalent to `collateralData.freeCollateralWei >= 0` if freeCollateralWei was signed,\n        // but actually freeCollateralWei always returns positive part, so it cannot be used in this test.\n        require(collateralData.lockedCollateralWei(agent) <= collateralData.fullCollateral, WithdrawalCRTooLow());\n        // (partially) clear withdrawal announcement\n        uint256 remaining = withdrawal.amountWei - _amountWei;    // guarded by above require\n        withdrawal.amountWei = uint128(remaining);\n        if (remaining == 0) {\n            withdrawal.allowedAt = 0;\n        }\n    }\n\n    /**\n     * Called by AgentVault or CollateralPool when there was a deposit.\n     * May pull agent out of liquidation.\n     * NOTE: may only be called from an agent vault or collateral pool, not from an EOA address.\n     */\n    function updateCollateral(\n        address _agentVault,\n        IERC20 _token\n    )\n        // no emergency pause check to allow change token / deposit collateral\n        external\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        require(msg.sender == _agentVault || msg.sender == address(agent.collateralPool),\n            OnlyAgentVaultOrPool());\n        // try to pull agent out of liquidation\n        if (agent.isCollateralToken(_token)) {\n            Liquidation.endLiquidationIfHealthy(agent);\n        }\n    }\n\n    /**\n     * When current pool collateral token contract (WNat) is replaced by the method setPoolWNatCollateralType,\n     * pools don't switch automatically. Instead, the agent must call this method that swaps old WNat tokens for\n     * new ones and sets it for use by the pool.\n     * NOTE: may only be called by the agent vault owner.\n     */\n    function upgradeWNatContract(\n        uint256 _start,\n        uint256 _end\n    )\n        external\n        onlyImmediateGovernanceOrExecutor\n    {\n        (address[] memory agentVaults,) = Agents.getAllAgents(_start, _end);\n        for (uint256 i = 0; i < agentVaults.length; i++) {\n            _upgradeWNatContract(agentVaults[i]);\n        }\n    }\n\n    function _upgradeWNatContract(\n        address _agentVault\n    )\n        private\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        AssetManagerState.State storage state = AssetManagerState.get();\n        IWNat wNat = IWNat(address(state.collateralTokens[state.poolCollateralIndex].token));\n        // upgrade pool wnat\n        if (agent.poolCollateralIndex != state.poolCollateralIndex) {\n            agent.poolCollateralIndex = state.poolCollateralIndex;\n            agent.collateralPool.upgradeWNatContract(wNat);\n            emit IAssetManagerEvents.AgentCollateralTypeChanged(_agentVault,\n                uint8(CollateralType.Class.POOL), address(wNat));\n        }\n    }\n\n    function _announceWithdrawal(\n        Collateral.Kind _kind,\n        address _agentVault,\n        uint256 _amountWei\n    )\n        private\n        returns (uint256)\n    {\n        Agent.State storage agent = Agent.get(_agentVault);\n        // only agents that are not being liquidated can withdraw\n        // however, if the agent is in FULL_LIQUIDATION and totally liquidated,\n        // the withdrawals must still be possible, otherwise the collateral gets locked forever\n        require(agent.status == Agent.Status.NORMAL || agent.totalBackedAMG() == 0, WithdrawalInvalidAgentStatus());\n        Agent.WithdrawalAnnouncement storage withdrawal = agent.withdrawalAnnouncement(_kind);\n        if (_amountWei > withdrawal.amountWei) {\n            AssetManagerSettings.Data storage settings = Globals.getSettings();\n            Collateral.Data memory collateralData = AgentCollateral.singleCollateralData(agent, _kind);\n            // announcement increased - must check there is enough free collateral and then lock it\n            // in this case the wait to withdrawal restarts from this moment\n            uint256 increase = _amountWei - withdrawal.amountWei;\n            require(increase <= collateralData.freeCollateralWei(agent), WithdrawalValueTooHigh());\n            withdrawal.allowedAt = (block.timestamp + settings.withdrawalWaitMinSeconds).toUint64();\n        } else {\n            // announcement decreased or cancelled\n            // if value is 0, we cancel announcement completely (i.e. set announcement time to 0)\n            // otherwise, for decreasing announcement, we can safely leave announcement time unchanged\n            if (_amountWei == 0) {\n                withdrawal.allowedAt = 0;\n            }\n        }\n        withdrawal.amountWei = _amountWei.toUint128();\n        if (_kind == Collateral.Kind.VAULT) {\n            emit IAssetManagerEvents.VaultCollateralWithdrawalAnnounced(_agentVault, _amountWei, withdrawal.allowedAt);\n        } else {\n            emit IAssetManagerEvents.PoolTokenRedemptionAnnounced(_agentVault, _amountWei, withdrawal.allowedAt);\n        }\n        return withdrawal.allowedAt;\n    }\n}"
    }
}