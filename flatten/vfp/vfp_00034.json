{
    "vfp_id": "vfp_00034",
    "project_name": "cantina_sky_spark_alm_controller_oct2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "WSTETH_WITHDRAW_QUEUE withdrawals limits affect the requestWithdrawFromWstETH",
            "description": "1. **Description:** The requestWithdrawFromWstETH function in MainnetController submits withdrawal requests to Lido's WSTETH_WITHDRAW_QUEUE, which enforces per-request limits (minimum 100 stETH, maximum 1000 stETH). The current implementation sends only one request per call, limiting large withdrawals to the maximum per-request amount.\n2. **Cause:** The function does not split large withdrawal amounts into multiple requests, relying instead on external relayers to make multiple calls.\n3. **Exploitation:** While not directly exploitable, this design increases operational complexity and gas costs for large withdrawals, as multiple transactions are required.\n4. **Impact:** Users or relayers must make multiple calls to withdraw large amounts, increasing latency and gas overhead. There is no direct security risk, but it affects usability and efficiency.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L370-L400"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1110"
                ]
            },
            "title": "Quantifying the max loss for an OTC exchange",
            "description": "1. **Description:** OTC exchanges are trusted entities that receive ETH and return stablecoins asynchronously. Two rate limits (global rate limit and net swap limit with recharge) are in place to cap exposure.\n2. **Cause:** The maximum potential loss per exchange is determined by the interplay of LIMIT_OTC_SWAP, rechargeRate, maxSlippage, and time elapsed, but this formula is not formally documented.\n3. **Exploitation:** If an exchange is malicious or compromised, it could fail to return funds up to the net exposure limit. Without clear quantification, risk assessment is less precise.\n4. **Impact:** Lack of documented risk quantification makes it harder for stakeholders to assess the financial risk associated with each OTC partner. No direct exploit, but improves transparency.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L957"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing OTC check in setOTCWhitelistedAsset",
            "description": "1. **Description:** The setOTCWhitelistedAsset function allows setting a whitelisted asset for an OTC exchange even if the OTC entry (buffer) for that exchange has not been initialized.\n2. **Cause:** The function does not validate whether the OTC configuration exists before allowing asset whitelisting.\n3. **Exploitation:** This could lead to configuration inconsistencies where assets are whitelisted for non-existent or inactive exchanges. While not currently exploitable (otcSend fails if buffer is missing), it could cause confusion or future bugs.\n4. **Impact:** Risk of misconfiguration and reduced code clarity. Adding a sanity check would improve robustness and prevent potential future issues.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L278-L286"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "The setOTCBuffer and setOTCRechargeRate could be combined into one function",
            "description": "1. **Description:** Two separate admin functions, setOTCBuffer and setOTCRechargeRate, update fields within the same OTC struct. This leads to redundant function calls and increased contract size.\n2. **Cause:** The functions were implemented separately, possibly for operational flexibility (e.g., frequent updates to rechargeRate).\n3. **Exploitation:** No direct exploit, but inefficient design. Combining them could reduce gas costs for deployments and upgrades.\n4. **Impact:** Slightly higher gas usage and more complex admin operations. The trade-off is that combining them would require specifying both parameters even when only one is being updated.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L255-L276"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Documentation & minor issues",
            "description": "1. **Description:** Several minor documentation and labeling issues were identified across the codebase, including ambiguous variable names (e.g., 'buffer'), missing precision warnings for high-decimal tokens, and potentially incorrect error messages.\n2. **Cause:** Insufficient inline documentation and attention to detail during development.\n3. **Exploitation:** These do not represent security vulnerabilities but could lead to misunderstandings during audits or maintenance, increasing the risk of future bugs.\n4. **Impact:** Reduced code readability and maintainability. Clearer documentation would improve auditability and reduce the chance of human error during future development.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol#L182",
                "MainnetController.sol#L949",
                "MainnetController.sol#L161",
                "MainnetController.sol#L1074"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        }
    ],
    "affected_files": {
        "MainnetController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { AccessControlEnumerable } from \"openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol\";\n\nimport { IERC20 }         from \"openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport { IERC20Metadata } from \"openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol\";\nimport { IERC4626 }       from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\n\nimport { Ethereum } from \"spark-address-registry/Ethereum.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport  \"./interfaces/ILayerZero.sol\";\n\nimport { CCTPLib }                        from \"./libraries/CCTPLib.sol\";\nimport { CurveLib }                       from \"./libraries/CurveLib.sol\";\nimport { IDaiUsdsLike, IPSMLike, PSMLib } from \"./libraries/PSMLib.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ninterface IEthenaMinterLike {\n    function setDelegatedSigner(address delegateSigner) external;\n    function removeDelegatedSigner(address delegateSigner) external;\n}\n\ninterface IFarmLike {\n    function stake(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n}\n\ninterface IMapleTokenLike is IERC4626 {\n    function requestRedeem(uint256 shares, address receiver) external;\n    function removeShares(uint256 shares, address receiver) external;\n}\n\ninterface ISparkVaultLike {\n    function take(uint256 assetAmount) external;\n}\n\ninterface ISUSDELike is IERC4626 {\n    function cooldownAssets(uint256 usdeAmount) external;\n    function cooldownShares(uint256 susdeAmount) external;\n    function unstake(address receiver) external;\n}\n\ninterface IUSTBLike is IERC20 {\n    function subscribe(uint256 inAmount, address stablecoin) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function draw(uint256 usdsAmount) external;\n    function wipe(uint256 usdsAmount) external;\n}\n\ninterface IWETH {\n    function withdraw(uint256 amount) external;\n}\n\ninterface IWithdrawalQueue {\n    function requestWithdrawalsWstETH(uint256[] calldata _amounts, address _owner)\n        external returns (uint256[] memory requestIds);\n    function claimWithdrawal(uint256 _requestId) external;\n}\n\ninterface IWstETHLike {\n    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);\n}\n\nstruct OTC {\n    address buffer;\n    uint256 rechargeRate18;\n    uint256 sent18;\n    uint256 sentTimestamp;\n    uint256 claimed18;\n}\n\ncontract MainnetController is AccessControlEnumerable {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n    event MaxSlippageSet(address indexed pool, uint256 maxSlippage);\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n    event OTCBufferSet(\n        address indexed exchange,\n        address indexed oldOTCBuffer,\n        address indexed newOTCBuffer\n    );\n    event OTCWhitelistedAssetSet(\n        address indexed exchange,\n        address indexed asset,\n        bool            isWhitelisted\n    );\n    event OTCClaimed(\n        address indexed exchange,\n        address indexed buffer,\n        address indexed assetClaimed,\n        uint256         amountClaimed,\n        uint256         amountClaimed18\n    );\n    event OTCRechargeRateSet(address indexed exchange, uint256 oldRate18, uint256 newRate18);\n    event OTCSwapSent(\n        address indexed exchange,\n        address indexed buffer,\n        address indexed tokenSent,\n        uint256         amountSent,\n        uint256         amountSent18\n    );\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public FREEZER = keccak256(\"FREEZER\");\n    bytes32 public RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public LIMIT_4626_DEPOSIT            = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public LIMIT_4626_WITHDRAW           = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public LIMIT_AAVE_DEPOSIT            = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public LIMIT_AAVE_WITHDRAW           = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public LIMIT_ASSET_TRANSFER          = keccak256(\"LIMIT_ASSET_TRANSFER\");\n    bytes32 public LIMIT_CURVE_DEPOSIT           = keccak256(\"LIMIT_CURVE_DEPOSIT\");\n    bytes32 public LIMIT_CURVE_SWAP              = keccak256(\"LIMIT_CURVE_SWAP\");\n    bytes32 public LIMIT_CURVE_WITHDRAW          = keccak256(\"LIMIT_CURVE_WITHDRAW\");\n    bytes32 public LIMIT_FARM_DEPOSIT            = keccak256(\"LIMIT_FARM_DEPOSIT\");\n    bytes32 public LIMIT_FARM_WITHDRAW           = keccak256(\"LIMIT_FARM_WITHDRAW\");\n    bytes32 public LIMIT_LAYERZERO_TRANSFER      = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public LIMIT_MAPLE_REDEEM            = keccak256(\"LIMIT_MAPLE_REDEEM\");\n    bytes32 public LIMIT_OTC_SWAP                = keccak256(\"LIMIT_OTC_SWAP\");\n    bytes32 public LIMIT_SPARK_VAULT_TAKE        = keccak256(\"LIMIT_SPARK_VAULT_TAKE\");\n    bytes32 public LIMIT_SUPERSTATE_SUBSCRIBE    = keccak256(\"LIMIT_SUPERSTATE_SUBSCRIBE\");\n    bytes32 public LIMIT_SUSDE_COOLDOWN          = keccak256(\"LIMIT_SUSDE_COOLDOWN\");\n    bytes32 public LIMIT_USDC_TO_CCTP            = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public LIMIT_USDC_TO_DOMAIN          = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n    bytes32 public LIMIT_USDE_BURN               = keccak256(\"LIMIT_USDE_BURN\");\n    bytes32 public LIMIT_USDE_MINT               = keccak256(\"LIMIT_USDE_MINT\");\n    bytes32 public LIMIT_USDS_MINT               = keccak256(\"LIMIT_USDS_MINT\");\n    bytes32 public LIMIT_USDS_TO_USDC            = keccak256(\"LIMIT_USDS_TO_USDC\");\n    bytes32 public LIMIT_WSTETH_DEPOSIT          = keccak256(\"LIMIT_WSTETH_DEPOSIT\");\n    bytes32 public LIMIT_WSTETH_REQUEST_WITHDRAW = keccak256(\"LIMIT_WSTETH_REQUEST_WITHDRAW\");\n\n    address public buffer;\n\n    IALMProxy         public proxy;\n    ICCTPLike         public cctp;\n    IDaiUsdsLike      public daiUsds;\n    IEthenaMinterLike public ethenaMinter;\n    IPSMLike          public psm;\n    IRateLimits       public rateLimits;\n    IVaultLike        public vault;\n\n    IERC20     public dai;\n    IERC20     public usds;\n    IERC20     public usde;\n    IERC20     public usdc;\n    IUSTBLike  public ustb;\n    ISUSDELike public susde;\n\n    uint256 public psmTo18ConversionFactor;\n\n    mapping(address pool => uint256 maxSlippage) public maxSlippages;  // 1e18 precision\n\n    mapping(uint32 destinationDomain     => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId => bytes32 layerZeroRecipient) public layerZeroRecipients;\n\n    // OTC swap (also uses maxSlippages)\n    mapping(address exchange => OTC otcData) public otcs;\n\n    mapping(address exchange => mapping(address asset => bool)) public otcWhitelistedAssets;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address vault_,\n        address psm_,\n        address daiUsds_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        vault      = IVaultLike(vault_);\n        buffer     = IVaultLike(vault_).buffer();\n        psm        = IPSMLike(psm_);\n        daiUsds    = IDaiUsdsLike(daiUsds_);\n        cctp       = ICCTPLike(cctp_);\n\n        ethenaMinter = IEthenaMinterLike(Ethereum.ETHENA_MINTER);\n\n        susde = ISUSDELike(Ethereum.SUSDE);\n        ustb  = IUSTBLike(Ethereum.USTB);\n        dai   = IERC20(daiUsds.dai());\n        usdc  = IERC20(psm.gem());\n        usds  = IERC20(Ethereum.USDS);\n        usde  = IERC20(Ethereum.USDE);\n\n        psmTo18ConversionFactor = psm.to18ConversionFactor();\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(\n        uint32  destinationEndpointId,\n        bytes32 layerZeroRecipient\n    )\n        external\n    {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    function setMaxSlippage(address pool, uint256 maxSlippage) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n\n        require(pool != address(0), \"MainnetController/pool-zero-address\");\n\n        maxSlippages[pool] = maxSlippage;\n        emit MaxSlippageSet(pool, maxSlippage);\n    }\n\n    function setOTCBuffer(address exchange, address otcBuffer) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n\n        require(exchange != address(0), \"MainnetController/exchange-zero-address\");\n        require(exchange != otcBuffer,  \"MainnetController/exchange-equals-otcBuffer\");\n\n        OTC storage otc = otcs[exchange];\n\n        emit OTCBufferSet(exchange, otc.buffer, otcBuffer);\n        otc.buffer = otcBuffer;\n    }\n\n    function setOTCRechargeRate(address exchange, uint256 rechargeRate18) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n\n        require(exchange != address(0), \"MainnetController/exchange-zero-address\");\n\n        OTC storage otc = otcs[exchange];\n\n        emit OTCRechargeRateSet(exchange, otc.rechargeRate18, rechargeRate18);\n        otc.rechargeRate18 = rechargeRate18;\n    }\n\n    function setOTCWhitelistedAsset(address exchange, address asset, bool isWhitelisted) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n\n        require(exchange != address(0), \"MainnetController/exchange-zero-address\");\n        require(asset    != address(0), \"MainnetController/asset-zero-address\");\n\n        emit OTCWhitelistedAssetSet(exchange, asset, isWhitelisted);\n        otcWhitelistedAssets[exchange][asset] = isWhitelisted;\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external {\n        _checkRole(FREEZER);\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer vault functions                                                                ***/\n    /**********************************************************************************************/\n\n    function mintUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDS_MINT, usdsAmount);\n\n        // Mint USDS into the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.draw, (usdsAmount))\n        );\n\n        // Transfer USDS from the buffer to the proxy\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transferFrom, (buffer, address(proxy), usdsAmount))\n        );\n    }\n\n    function burnUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _cancelRateLimit(LIMIT_USDS_MINT, usdsAmount);\n\n        // Transfer USDS from the proxy to the buffer\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transfer, (buffer, usdsAmount))\n        );\n\n        // Burn USDS from the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.wipe, (usdsAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC20 functions                                                                ***/\n    /**********************************************************************************************/\n\n    function transferAsset(address asset, address destination, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            RateLimitHelpers.makeAddressAddressKey(LIMIT_ASSET_TRANSFER, asset, destination),\n            amount\n        );\n\n        _transfer(asset, destination, amount);\n    }\n\n    /**********************************************************************************************/\n    /*** wstETH Integration                                                                     ***/\n    /**********************************************************************************************/\n\n    function depositToWstETH(uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_WSTETH_DEPOSIT, amount);\n\n        proxy.doCall(\n            Ethereum.WETH,\n            abi.encodeCall((IWETH(Ethereum.WETH)).withdraw, (amount))\n        );\n\n        proxy.doCallWithValue(\n            Ethereum.WSTETH,\n            \"\",\n            amount\n        );\n    }\n\n    function requestWithdrawFromWstETH(uint256 amountToRedeem) external returns (uint256[] memory) {\n        _checkRole(RELAYER);\n        _rateLimited(\n            LIMIT_WSTETH_REQUEST_WITHDRAW,\n            IWstETHLike(Ethereum.WSTETH).getStETHByWstETH(amountToRedeem)\n        );\n\n        proxy.doCall(\n            Ethereum.WSTETH,\n            abi.encodeCall(\n                IERC20(Ethereum.WSTETH).approve,\n                (Ethereum.WSTETH_WITHDRAW_QUEUE, amountToRedeem)\n            )\n        );\n\n        uint256[] memory amountsToRedeem = new uint256[](1);\n        amountsToRedeem[0] = amountToRedeem;\n\n        ( uint256[] memory requestIds ) = abi.decode(\n            proxy.doCall(\n                Ethereum.WSTETH_WITHDRAW_QUEUE,\n                abi.encodeCall(\n                    IWithdrawalQueue(Ethereum.WSTETH_WITHDRAW_QUEUE).requestWithdrawalsWstETH,\n                    (amountsToRedeem, address(proxy))\n                )\n            ),\n            (uint256[])\n        );\n\n        return requestIds;\n    }\n\n    function claimWithdrawalFromWstETH(uint256 requestId) external {\n        _checkRole(RELAYER);\n\n        uint256 initialEthBalance = address(proxy).balance;\n\n        proxy.doCall(\n            Ethereum.WSTETH_WITHDRAW_QUEUE,\n            abi.encodeCall(\n                IWithdrawalQueue(Ethereum.WSTETH_WITHDRAW_QUEUE).claimWithdrawal,\n                (requestId)\n            )\n        );\n\n        uint256 ethReceived = address(proxy).balance - initialEthBalance;\n\n        // Wrap into WETH\n        proxy.doCallWithValue(\n            Ethereum.WETH,\n            \"\",\n            ethReceived\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAddress(LIMIT_4626_DEPOSIT, token, amount);\n\n        require(maxSlippages[token] != 0, \"MainnetController/max-slippage-not-set\");\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n\n        require(\n            IERC4626(token).convertToAssets(shares) >= amount * maxSlippages[token] / 1e18,\n            \"MainnetController/slippage-too-high\"\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAddress(LIMIT_4626_WITHDRAW, token, amount);\n\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        _cancelRateLimit(RateLimitHelpers.makeAddressKey(LIMIT_4626_DEPOSIT, token), amount);\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares) external returns (uint256 assets) {\n        _checkRole(RELAYER);\n\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAddressKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n\n        _cancelRateLimit(RateLimitHelpers.makeAddressKey(LIMIT_4626_DEPOSIT, token), assets);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAddress(LIMIT_AAVE_DEPOSIT, aToken, amount);\n\n        require(maxSlippages[aToken] != 0, \"MainnetController/max-slippage-not-set\");\n\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        uint256 aTokenBalance = IERC20(aToken).balanceOf(address(proxy));\n\n        // Deposit underlying into Aave pool, proxy receives aTokens\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n\n        uint256 newATokens = IERC20(aToken).balanceOf(address(proxy)) - aTokenBalance;\n\n        require(\n            newATokens >= amount * maxSlippages[aToken] / 1e18,\n            \"MainnetController/slippage-too-high\"\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        _checkRole(RELAYER);\n\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAddressKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n\n        _cancelRateLimit(\n            RateLimitHelpers.makeAddressKey(LIMIT_AAVE_DEPOSIT, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Curve StableSwap functions                                                     ***/\n    /**********************************************************************************************/\n\n    function swapCurve(\n        address pool,\n        uint256 inputIndex,\n        uint256 outputIndex,\n        uint256 amountIn,\n        uint256 minAmountOut\n    )\n        external returns (uint256 amountOut)\n    {\n        _checkRole(RELAYER);\n\n        amountOut = CurveLib.swap(CurveLib.SwapCurveParams({\n            proxy        : proxy,\n            rateLimits   : rateLimits,\n            pool         : pool,\n            rateLimitId  : LIMIT_CURVE_SWAP,\n            inputIndex   : inputIndex,\n            outputIndex  : outputIndex,\n            amountIn     : amountIn,\n            minAmountOut : minAmountOut,\n            maxSlippage  : maxSlippages[pool]\n        }));\n    }\n\n    function addLiquidityCurve(\n        address pool,\n        uint256[] memory depositAmounts,\n        uint256 minLpAmount\n    )\n        external returns (uint256 shares)\n    {\n        _checkRole(RELAYER);\n\n        shares = CurveLib.addLiquidity(CurveLib.AddLiquidityParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            pool                    : pool,\n            addLiquidityRateLimitId : LIMIT_CURVE_DEPOSIT,\n            swapRateLimitId         : LIMIT_CURVE_SWAP,\n            minLpAmount             : minLpAmount,\n            maxSlippage             : maxSlippages[pool],\n            depositAmounts          : depositAmounts\n        }));\n    }\n\n    function removeLiquidityCurve(\n        address pool,\n        uint256 lpBurnAmount,\n        uint256[] memory minWithdrawAmounts\n    )\n        external returns (uint256[] memory withdrawnTokens)\n    {\n        _checkRole(RELAYER);\n\n        withdrawnTokens = CurveLib.removeLiquidity(CurveLib.RemoveLiquidityParams({\n            proxy              : proxy,\n            rateLimits         : rateLimits,\n            pool               : pool,\n            rateLimitId        : LIMIT_CURVE_WITHDRAW,\n            lpBurnAmount       : lpBurnAmount,\n            minWithdrawAmounts : minWithdrawAmounts,\n            maxSlippage        : maxSlippages[pool]\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Ethena functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.setDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    function removeDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.removeDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    // Note that Ethena's mint/redeem per-block limits include other users\n    function prepareUSDeMint(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_MINT, usdcAmount);\n        _approve(address(usdc), address(ethenaMinter), usdcAmount);\n    }\n\n    function prepareUSDeBurn(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_BURN, usdeAmount);\n        _approve(address(usde), address(ethenaMinter), usdeAmount);\n    }\n\n    function cooldownAssetsSUSDe(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUSDE_COOLDOWN, usdeAmount);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.cooldownAssets, (usdeAmount))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function cooldownSharesSUSDe(uint256 susdeAmount)\n        external\n        returns (uint256 cooldownAmount)\n    {\n        _checkRole(RELAYER);\n\n        cooldownAmount = abi.decode(\n            proxy.doCall(\n                address(susde),\n                abi.encodeCall(susde.cooldownShares, (susdeAmount))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUSDE_COOLDOWN, cooldownAmount);\n    }\n\n    function unstakeSUSDe() external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.unstake, (address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Maple functions                                                                ***/\n    /**********************************************************************************************/\n\n    function requestMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAddress(\n            LIMIT_MAPLE_REDEEM,\n            mapleToken,\n            IMapleTokenLike(mapleToken).convertToAssets(shares)\n        );\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).requestRedeem, (shares, address(proxy)))\n        );\n    }\n\n    function cancelMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAddressKey(LIMIT_MAPLE_REDEEM, mapleToken));\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).removeShares, (shares, address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Superstate functions                                                           ***/\n    /**********************************************************************************************/\n\n    function subscribeSuperstate(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUPERSTATE_SUBSCRIBE, usdcAmount);\n\n        _approve(address(usdc), address(ustb), usdcAmount);\n\n        proxy.doCall(\n            address(ustb),\n            abi.encodeCall(ustb.subscribe, (usdcAmount, address(usdc)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer DaiUsds functions                                                              ***/\n    /**********************************************************************************************/\n\n    function swapUSDSToDAI(uint256 usdsAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(address(usds), address(daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.usdsToDai, (address(proxy), usdsAmount))\n        );\n    }\n\n    function swapDAIToUSDS(uint256 daiAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(address(dai), address(daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.daiToUsds, (address(proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    // NOTE: The param `usdcAmount` is denominated in 1e6 precision to match how PSM uses\n    //       USDC precision for both `buyGemNoFee` and `sellGemNoFee`\n    function swapUSDSToUSDC(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDSToUSDC(PSMLib.SwapUSDSToUSDCParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            usds                    : usds,\n            dai                     : dai,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    function swapUSDCToUSDS(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDCToUSDS(PSMLib.SwapUSDCToUSDSParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            dai                     : dai,\n            usdc                    : usdc,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external payable\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        // NOTE: Full integration testing of this logic is not possible without OFTs with\n        //       approvalRequired == false. Add integration testing for this case before\n        //       using in production.\n        if (ILayerZero(oftAddress).approvalRequired()) {\n            _approve(ILayerZero(oftAddress).token(), oftAddress, amount);\n        }\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue{value: fee.nativeFee}(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain) external {\n        _checkRole(RELAYER);\n\n        CCTPLib.transferUSDCToCCTP(CCTPLib.TransferUSDCToCCTPParams({\n            proxy             : proxy,\n            rateLimits        : rateLimits,\n            cctp              : cctp,\n            usdc              : usdc,\n            domainRateLimitId : LIMIT_USDC_TO_DOMAIN,\n            cctpRateLimitId   : LIMIT_USDC_TO_CCTP,\n            mintRecipient     : mintRecipients[destinationDomain],\n            destinationDomain : destinationDomain,\n            usdcAmount        : usdcAmount\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer SPK Farm functions                                                             ***/\n    /**********************************************************************************************/\n\n    function depositToFarm(address farm, uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_FARM_DEPOSIT, farm)),\n            usdsAmount\n        );\n\n        _approve(address(usds), farm, usdsAmount);\n\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.stake, (usdsAmount))\n        );\n    }\n\n    function withdrawFromFarm(address farm, uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_FARM_WITHDRAW, farm)),\n            usdsAmount\n        );\n\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.withdraw, (usdsAmount))\n        );\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.getReward, ())\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Spark Vault functions                                                                  ***/\n    /**********************************************************************************************/\n\n    function takeFromSparkVault(address sparkVault, uint256 assetAmount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAddress(LIMIT_SPARK_VAULT_TAKE, sparkVault, assetAmount);\n\n        // Take assets from the vault\n        proxy.doCall(\n            sparkVault,\n            abi.encodeCall(ISparkVaultLike.take, (assetAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** OTC swap functions                                                                     ***/\n    /**********************************************************************************************/\n\n    function otcSend(address exchange, address assetToSend, uint256 amount) external {\n        _checkRole(RELAYER);\n\n        require(assetToSend != address(0), \"MainnetController/asset-to-send-zero\");\n        require(amount > 0,                \"MainnetController/amount-to-send-zero\");\n\n        require(\n            otcWhitelistedAssets[exchange][assetToSend],\n            \"MainnetController/asset-not-whitelisted\"\n        );\n\n        uint256 sent18 = amount * 1e18 / 10 ** IERC20Metadata(assetToSend).decimals();\n\n        _rateLimitedAddress(LIMIT_OTC_SWAP, exchange, sent18);\n\n        OTC storage otc = otcs[exchange];\n\n        // Just to check that OTC buffer exists\n        require(otc.buffer != address(0), \"MainnetController/otc-buffer-not-set\");\n        require(isOtcSwapReady(exchange), \"MainnetController/last-swap-not-returned\");\n\n        otc.sent18        = sent18;\n        otc.sentTimestamp = block.timestamp;\n        otc.claimed18     = 0;\n\n        // NOTE: Reentrancy not relevant here because there are no state changes after this call\n        _transfer(assetToSend, exchange, amount);\n\n        emit OTCSwapSent(exchange, otc.buffer, assetToSend, amount, sent18);\n    }\n\n    function otcClaim(address exchange, address assetToClaim) external {\n        _checkRole(RELAYER);\n\n        address otcBuffer = otcs[exchange].buffer;\n\n        require(assetToClaim != address(0), \"MainnetController/asset-to-claim-zero\");\n        require(otcBuffer    != address(0), \"MainnetController/otc-buffer-not-set\");\n\n        require(\n            otcWhitelistedAssets[exchange][assetToClaim],\n            \"MainnetController/asset-not-whitelisted\"\n        );\n\n        uint256 amountToClaim = IERC20(assetToClaim).balanceOf(otcBuffer);\n\n        // NOTE: This will lose precision for tokens with >18 decimals.\n        uint256 amountToClaim18\n            = amountToClaim * 1e18 / 10 ** IERC20Metadata(assetToClaim).decimals();\n\n        otcs[exchange].claimed18 += amountToClaim18;\n\n        // Transfer assets from the OTC buffer to the proxy\n        // NOTE: Reentrancy not possible here because both are known contracts.\n        _transferFrom(assetToClaim, otcBuffer, address(proxy), amountToClaim);\n\n        emit OTCClaimed(exchange, otcBuffer, assetToClaim, amountToClaim, amountToClaim18);\n    }\n\n    function getOtcClaimWithRecharge(address exchange) public view returns (uint256) {\n        OTC memory otc = otcs[exchange];\n\n        if (otc.sentTimestamp == 0) return 0;\n\n        return otc.claimed18 + (block.timestamp - otc.sentTimestamp) * otc.rechargeRate18;\n    }\n\n    function isOtcSwapReady(address exchange) public view returns (bool) {\n        // If maxSlippages is not set, the exchange is not onboarded.\n        if (maxSlippages[exchange] == 0) return false;\n\n        return getOtcClaimWithRecharge(exchange)\n            >= otcs[exchange].sent18 * maxSlippages[exchange] / 1e18;\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        bytes memory approveCallReturnData;\n\n        if (success) {\n            // Data is the ABI-encoding of the approve call bytes return data, need to\n            // decode it first\n            approveCallReturnData = abi.decode(data, (bytes));\n            // Approve was successful if 1) no return value or 2) true return value\n            if (approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool))) {\n                return;\n            }\n        }\n\n        // If call was unsuccessful, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n\n        approveCallReturnData = proxy.doCall(token, approveData);\n\n        // Revert if approve returns false\n        require(\n            approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool)),\n            \"MainnetController/approve-failed\"\n        );\n    }\n\n    function _transfer(address asset, address destination, uint256 amount) internal {\n        bytes memory returnData = proxy.doCall(\n            asset,\n            abi.encodeCall(IERC20(asset).transfer, (destination, amount))\n        );\n\n        require(\n            returnData.length == 0 || abi.decode(returnData, (bool)),\n            \"MainnetController/transfer-failed\"\n        );\n    }\n\n    function _transferFrom(\n        address asset,\n        address source,\n        address destination,\n        uint256 amount\n    ) internal {\n        bytes memory returnData = proxy.doCall(\n            asset,\n            abi.encodeCall(IERC20(asset).transferFrom, (source, destination, amount))\n        );\n\n        require(\n            returnData.length == 0 || abi.decode(returnData, (bool)),\n            \"MainnetController/transfer-failed\"\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Rate Limit helper functions                                                            ***/\n    /**********************************************************************************************/\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n    function _rateLimitedAddress(bytes32 key, address asset, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAddressKey(key, asset), amount);\n    }\n\n    function _cancelRateLimit(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitIncrease(key, amount);\n    }\n\n    function _rateLimitExists(bytes32 key) internal view {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"MainnetController/invalid-action\"\n        );\n    }\n\n}\n"
    }
}