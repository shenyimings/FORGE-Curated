{
    "vfp_id": "vfp_00066",
    "project_name": "cantina_optimism_op_program_march2025.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Bedrock contracts test setup fails due to incorrect Solady library mapping",
            "description": "The ForkLive.s.sol file imports the Solady library with a path that does not account for Foundry's remapping, which includes the src directory. The cause is a mismatch between the import path and the actual project structure. This is not a security vulnerability per se, but it prevents successful compilation and testing, which could delay development and reduce confidence in the correctness of the deployed system.\n",
            "severity": "Informational",
            "location": [
                "ForkLive.s.sol#L17"
            ],
            "files": [
                "optimism/packages/contracts-bedrock/test/setup/ForkLive.s.sol"
            ]
        }
    ],
    "affected_files": {
        "ForkLive.s.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { console2 as console } from \"forge-std/console2.sol\";\nimport { StdAssertions } from \"forge-std/StdAssertions.sol\";\n\n// Testing\nimport { stdToml } from \"forge-std/StdToml.sol\";\nimport { DisputeGames } from \"test/setup/DisputeGames.sol\";\nimport { PastUpgrades } from \"test/setup/PastUpgrades.sol\";\nimport { FeatureFlags } from \"test/setup/FeatureFlags.sol\";\n\n// Scripts\nimport { Deployer } from \"scripts/deploy/Deployer.sol\";\nimport { Deploy } from \"scripts/deploy/Deploy.s.sol\";\nimport { Config } from \"scripts/libraries/Config.sol\";\n\n// Libraries\nimport { GameTypes, Claim } from \"src/dispute/lib/Types.sol\";\nimport { EIP1967Helper } from \"test/mocks/EIP1967Helper.sol\";\nimport { DevFeatures } from \"src/libraries/DevFeatures.sol\";\nimport { LibString } from \"@solady/utils/LibString.sol\";\nimport { LibGameArgs } from \"src/dispute/lib/LibGameArgs.sol\";\n\n// Interfaces\nimport { ISuperchainConfig } from \"interfaces/L1/ISuperchainConfig.sol\";\n\nimport { IDisputeGameFactory } from \"interfaces/dispute/IDisputeGameFactory.sol\";\nimport { IDelayedWETH } from \"interfaces/dispute/IDelayedWETH.sol\";\nimport { IAddressManager } from \"interfaces/legacy/IAddressManager.sol\";\nimport { ISystemConfig } from \"interfaces/L1/ISystemConfig.sol\";\nimport { IProxyAdmin } from \"interfaces/universal/IProxyAdmin.sol\";\nimport { IOPContractsManager } from \"interfaces/L1/IOPContractsManager.sol\";\nimport { IAnchorStateRegistry } from \"interfaces/dispute/IAnchorStateRegistry.sol\";\nimport { IFaultDisputeGame } from \"interfaces/dispute/IFaultDisputeGame.sol\";\nimport { IETHLockbox } from \"interfaces/L1/IETHLockbox.sol\";\nimport { IOptimismPortal2 } from \"interfaces/L1/IOptimismPortal2.sol\";\nimport { IOPContractsManagerUpgrader } from \"interfaces/L1/IOPContractsManager.sol\";\nimport { IOPContractsManagerV2 } from \"interfaces/L1/opcm/IOPContractsManagerV2.sol\";\nimport { IOPContractsManagerUtils } from \"interfaces/L1/opcm/IOPContractsManagerUtils.sol\";\n\n/// @title ForkLive\n/// @notice This script is called by Setup.sol as a preparation step for the foundry test suite, and is run as an\n///         alternative to Deploy.s.sol, when `FORK_TEST=true` is set in the env.\n///         Like Deploy.s.sol this script saves the system addresses to the Artifacts contract so that they can be\n///         read by other contracts. However, rather than deploying new contracts from the local source code, it\n///         simply reads the addresses from the superchain-registry.\n///         Therefore this script can only be run against a fork of a production network which is listed in the\n///         superchain-registry.\n///         This contract must not have constructor logic because it is set into state using `etch`.\n\ncontract ForkLive is Deployer, StdAssertions, FeatureFlags {\n    using stdToml for string;\n    using LibString for string;\n\n    bool public useOpsRepo;\n\n    /// @notice Returns the base chain name to use for forking\n    /// @return The base chain name as a string\n    function baseChain() internal view returns (string memory) {\n        return Config.forkBaseChain();\n    }\n\n    /// @notice Returns the OP chain name to use for forking\n    /// @return The OP chain name as a string\n    function opChain() internal view returns (string memory) {\n        return Config.forkOpChain();\n    }\n\n    function setUp() public override {\n        super.setUp();\n        resolveFeaturesFromEnv();\n    }\n\n    /// @dev This function sets up the system to test it as follows:\n    ///      1. Check if the SUPERCHAIN_OPS_ALLOCS_PATH environment variable was set from superchain ops.\n    ///      2. If set, load the state from the given path.\n    ///      3. Read the superchain-registry to get the contract addresses we wish to test from that network.\n    ///      4. If the environment variable wasn't set, deploy the updated OPCM and implementations of the contracts.\n    ///      5. Upgrade the system using the OPCM.upgrade() function if useUpgradedFork is true.\n    function run() public {\n        string memory superchainOpsAllocsPath = Config.superchainOpsAllocsPath();\n\n        useOpsRepo = bytes(superchainOpsAllocsPath).length > 0;\n        if (useOpsRepo) {\n            console.log(\"ForkLive: loading state from %s\", superchainOpsAllocsPath);\n            // Set the resultant state from the superchain ops repo upgrades.\n            // The allocs are generated when simulating an upgrade task that runs vm.dumpState.\n            // These allocs represent the state of the EVM after the upgrade has been simulated.\n            vm.loadAllocs(superchainOpsAllocsPath);\n            // Next, fetch the addresses from the superchain registry. This function uses a local EVM\n            // to retrieve implementation addresses by reading from proxy addresses provided by the registry.\n            // Setting the allocs first ensures the correct implementation addresses are retrieved.\n            _readSuperchainRegistry();\n        } else {\n            // Read the superchain registry and save the addresses to the Artifacts contract.\n            _readSuperchainRegistry();\n            // Now deploy the updated OPCM and implementations of the contracts.\n            _deployNewImplementations();\n        }\n\n        // Now upgrade the contracts (if the config is set to do so)\n        if (useOpsRepo) {\n            console.log(\"ForkLive: using ops repo to upgrade\");\n        } else if (cfg.useUpgradedFork()) {\n            console.log(\"ForkLive: upgrading\");\n            _upgrade();\n        }\n    }\n\n    /// @notice Reads the superchain config files and saves the addresses to disk.\n    /// @dev During development of an upgrade which adds a new contract, the contract will not yet be present in the\n    ///      superchain-registry. In this case, the contract will be deployed by the upgrade process, and will need to\n    ///      be stored by artifacts.save() after the call to opcm.upgrade().\n    ///      After the upgrade is complete, the superchain-registry will be updated and the contract will be present. At\n    ///      that point, this function will need to be updated to read the new contract from the superchain-registry\n    ///      using either the `saveProxyAndImpl` or `artifacts.save()` functions.\n    function _readSuperchainRegistry() internal {\n        string memory superchainBasePath = \"./lib/superchain-registry/superchain/configs/\";\n        string memory validationBasePath = \"./lib/superchain-registry/validation/standard/\";\n\n        string memory superchainToml = vm.readFile(string.concat(superchainBasePath, baseChain(), \"/superchain.toml\"));\n        string memory opToml = vm.readFile(string.concat(superchainBasePath, baseChain(), \"/\", opChain(), \".toml\"));\n\n        string memory standardVersionsToml =\n            vm.readFile(string.concat(validationBasePath, \"standard-versions-\", baseChain(), \".toml\"));\n\n        standardVersionsToml = standardVersionsToml.replace('\"op-contracts/v2.0.0-rc.1\"', \"RELEASE\");\n\n        // Slightly hacky, we encode the uint chainId as an address to save it in Artifacts\n        artifacts.save(\"L2ChainId\", address(uint160(vm.parseTomlUint(opToml, \".chain_id\"))));\n        // Superchain shared contracts\n        saveProxyAndImpl(\"SuperchainConfig\", superchainToml, \".superchain_config_addr\");\n        saveProxyAndImpl(\"ProtocolVersions\", superchainToml, \".protocol_versions_addr\");\n        artifacts.save(\n            \"OPContractsManager\", vm.parseTomlAddress(standardVersionsToml, \"$.RELEASE.op_contracts_manager.address\")\n        );\n\n        // Core contracts\n        artifacts.save(\"ProxyAdmin\", vm.parseTomlAddress(opToml, \".addresses.ProxyAdmin\"));\n        saveProxyAndImpl(\"SystemConfig\", opToml, \".addresses.SystemConfigProxy\");\n\n        // Bridge contracts\n        address optimismPortal = vm.parseTomlAddress(opToml, \".addresses.OptimismPortalProxy\");\n        artifacts.save(\"OptimismPortalProxy\", optimismPortal);\n        artifacts.save(\"OptimismPortal2Impl\", EIP1967Helper.getImplementation(optimismPortal));\n\n        // Get the lockbox address from the portal, and save it\n        /// NOTE: Using try catch because this function could be called before or after the upgrade.\n        try IOptimismPortal2(payable(optimismPortal)).ethLockbox() returns (IETHLockbox ethLockbox_) {\n            console.log(\"ForkLive: ETHLockboxProxy found: %s\", address(ethLockbox_));\n            artifacts.save(\"ETHLockboxProxy\", address(ethLockbox_));\n        } catch {\n            console.log(\"ForkLive: ETHLockboxProxy not found\");\n        }\n\n        address addressManager = vm.parseTomlAddress(opToml, \".addresses.AddressManager\");\n        artifacts.save(\"AddressManager\", addressManager);\n        artifacts.save(\n            \"L1CrossDomainMessengerImpl\", IAddressManager(addressManager).getAddress(\"OVM_L1CrossDomainMessenger\")\n        );\n        artifacts.save(\n            \"L1CrossDomainMessengerProxy\", vm.parseTomlAddress(opToml, \".addresses.L1CrossDomainMessengerProxy\")\n        );\n        saveProxyAndImpl(\"OptimismMintableERC20Factory\", opToml, \".addresses.OptimismMintableERC20FactoryProxy\");\n        saveProxyAndImpl(\"L1StandardBridge\", opToml, \".addresses.L1StandardBridgeProxy\");\n        saveProxyAndImpl(\"L1ERC721Bridge\", opToml, \".addresses.L1ERC721BridgeProxy\");\n\n        // Fault proof proxied contracts\n        saveProxyAndImpl(\"AnchorStateRegistry\", opToml, \".addresses.AnchorStateRegistryProxy\");\n        saveProxyAndImpl(\"DisputeGameFactory\", opToml, \".addresses.DisputeGameFactoryProxy\");\n\n        // Fault proof non-proxied contracts\n        // For chains that don't have a permissionless game, we save the dispute game and WETH\n        // addresses as the zero address.\n        artifacts.save(\"PreimageOracle\", vm.parseTomlAddress(opToml, \".addresses.PreimageOracle\"));\n        artifacts.save(\"MipsSingleton\", vm.parseTomlAddress(opToml, \".addresses.MIPS\"));\n        IDisputeGameFactory disputeGameFactory =\n            IDisputeGameFactory(artifacts.mustGetAddress(\"DisputeGameFactoryProxy\"));\n\n        // The PermissionedDisputeGame and PermissionedDelayedWETHProxy are not listed in the registry for OP, so we\n        // look it up onchain\n        IFaultDisputeGame permissionedDisputeGame =\n            IFaultDisputeGame(address(disputeGameFactory.gameImpls(GameTypes.PERMISSIONED_CANNON)));\n        artifacts.save(\"PermissionedDisputeGame\", address(permissionedDisputeGame));\n        artifacts.save(\"PermissionedDelayedWETHProxy\", address(permissionedDisputeGame.weth()));\n\n        // The SR seems out-of-date, so pull the DelayedWETH addresses from the PermissionedDisputeGame.\n        artifacts.save(\"DelayedWETHProxy\", address(permissionedDisputeGame.weth()));\n        artifacts.save(\"DelayedWETHImpl\", EIP1967Helper.getImplementation(address(permissionedDisputeGame.weth())));\n    }\n\n    /// @notice Calls to the Deploy.s.sol contract etched by Setup.sol to a deterministic address, sets up the\n    /// environment, and deploys new implementations.\n    function _deployNewImplementations() internal {\n        Deploy deploy = Deploy(address(uint160(uint256(keccak256(abi.encode(\"optimism.deploy\"))))));\n        deploy.deployImplementations({ _isInterop: false });\n    }\n\n    /// @notice Performs a single OPCM upgrade.\n    /// @param _opcm The OPCM contract to upgrade.\n    /// @param _delegateCaller The address of the upgrader to use for the upgrade.\n    function _doUpgrade(IOPContractsManager _opcm, address _delegateCaller) internal {\n        ISystemConfig systemConfig = ISystemConfig(artifacts.mustGetAddress(\"SystemConfigProxy\"));\n        IOPContractsManager.OpChainConfig[] memory opChains = new IOPContractsManager.OpChainConfig[](1);\n        opChains[0] = IOPContractsManager.OpChainConfig({\n            systemConfigProxy: systemConfig,\n            cannonPrestate: Claim.wrap(bytes32(keccak256(\"cannonPrestate\"))),\n            cannonKonaPrestate: Claim.wrap(bytes32(keccak256(\"cannonKonaPrestate\")))\n        });\n\n        // Execute the SuperchainConfig upgrade.\n        // Always try to upgrade the SuperchainConfig. Not always necessary but easier to do it\n        // every time rather than adding or removing this code for each upgrade.\n        ISuperchainConfig superchainConfig = ISuperchainConfig(artifacts.mustGetAddress(\"SuperchainConfigProxy\"));\n        IProxyAdmin superchainProxyAdmin = IProxyAdmin(EIP1967Helper.getAdmin(address(superchainConfig)));\n        address superchainPAO = superchainProxyAdmin.owner();\n        vm.prank(superchainPAO, true);\n        (bool success, bytes memory reason) =\n            address(_opcm).delegatecall(abi.encodeCall(IOPContractsManager.upgradeSuperchainConfig, (superchainConfig)));\n        if (success == false) {\n            assertTrue(\n                bytes4(reason)\n                    == IOPContractsManagerUpgrader.OPContractsManagerUpgrader_SuperchainConfigAlreadyUpToDate.selector,\n                \"Revert reason other than SuperchainConfigAlreadyUpToDate\"\n            );\n        }\n\n        // Upgrade the chain.\n        vm.prank(_delegateCaller, true);\n        (bool upgradeSuccess,) = address(_opcm).delegatecall(abi.encodeCall(IOPContractsManager.upgrade, (opChains)));\n        assertTrue(upgradeSuccess, \"upgrade failed\");\n    }\n\n    /// @notice Performs a single OPCM V2 upgrade.\n    /// @param _opcm The OPCM V2 contract to upgrade.\n    /// @param _delegateCaller The address of the upgrader to use for the upgrade.\n    function _doUpgradeV2(IOPContractsManagerV2 _opcm, address _delegateCaller) internal {\n        ISystemConfig systemConfig = ISystemConfig(artifacts.mustGetAddress(\"SystemConfigProxy\"));\n\n        // Get the SuperchainPAO address.\n        ISuperchainConfig superchainConfig = ISuperchainConfig(artifacts.mustGetAddress(\"SuperchainConfigProxy\"));\n        IProxyAdmin superchainProxyAdmin = IProxyAdmin(EIP1967Helper.getAdmin(address(superchainConfig)));\n        address superchainPAO = superchainProxyAdmin.owner();\n\n        // Always try to upgrade the SuperchainConfig. Not always necessary but easier to do it\n        // every time rather than adding or removing this code for each upgrade.\n        vm.prank(superchainPAO, true);\n        (bool success, bytes memory reason) = address(_opcm).delegatecall(\n            abi.encodeCall(\n                IOPContractsManagerV2.upgradeSuperchain,\n                (\n                    IOPContractsManagerV2.SuperchainUpgradeInput({\n                        superchainConfig: superchainConfig,\n                        extraInstructions: new IOPContractsManagerUtils.ExtraInstruction[](0)\n                    })\n                )\n            )\n        );\n        if (success == false) {\n            // Only acceptable revert reason is downgrade not allowed.\n            assertTrue(\n                bytes4(reason) == IOPContractsManagerUtils.OPContractsManagerUtils_DowngradeNotAllowed.selector,\n                \"Revert reason other than DowngradeNotAllowed\"\n            );\n        }\n\n        // Grab the existing PermissionedDisputeGame parameters.\n        IDisputeGameFactory disputeGameFactory =\n            IDisputeGameFactory(artifacts.mustGetAddress(\"DisputeGameFactoryProxy\"));\n        address challenger = DisputeGames.permissionedGameChallenger(disputeGameFactory);\n        address proposer = DisputeGames.permissionedGameProposer(disputeGameFactory);\n\n        // Prepare the upgrade input.\n        IOPContractsManagerUtils.DisputeGameConfig[] memory disputeGameConfigs =\n            new IOPContractsManagerUtils.DisputeGameConfig[](3);\n        disputeGameConfigs[0] = IOPContractsManagerUtils.DisputeGameConfig({\n            enabled: true,\n            initBond: disputeGameFactory.initBonds(GameTypes.CANNON),\n            gameType: GameTypes.CANNON,\n            gameArgs: abi.encode(\n                IOPContractsManagerUtils.FaultDisputeGameConfig({\n                    absolutePrestate: Claim.wrap(bytes32(keccak256(\"cannonPrestate\")))\n                })\n            )\n        });\n        disputeGameConfigs[1] = IOPContractsManagerUtils.DisputeGameConfig({\n            enabled: true,\n            initBond: disputeGameFactory.initBonds(GameTypes.PERMISSIONED_CANNON),\n            gameType: GameTypes.PERMISSIONED_CANNON,\n            gameArgs: abi.encode(\n                IOPContractsManagerUtils.PermissionedDisputeGameConfig({\n                    absolutePrestate: Claim.wrap(bytes32(keccak256(\"cannonPrestate\"))),\n                    proposer: proposer,\n                    challenger: challenger\n                })\n            )\n        });\n        disputeGameConfigs[2] = IOPContractsManagerUtils.DisputeGameConfig({\n            enabled: true,\n            initBond: disputeGameFactory.initBonds(GameTypes.CANNON_KONA),\n            gameType: GameTypes.CANNON_KONA,\n            gameArgs: abi.encode(\n                IOPContractsManagerUtils.FaultDisputeGameConfig({\n                    absolutePrestate: Claim.wrap(bytes32(keccak256(\"cannonKonaPrestate\")))\n                })\n            )\n        });\n\n        // Add extra instructions to allow the DelayedWETH proxy to be deployed.\n        IOPContractsManagerUtils.ExtraInstruction[] memory extraInstructions =\n            new IOPContractsManagerUtils.ExtraInstruction[](1);\n        extraInstructions[0] =\n            IOPContractsManagerUtils.ExtraInstruction({ key: \"PermittedProxyDeployment\", data: bytes(\"DelayedWETH\") });\n\n        vm.prank(_delegateCaller, true);\n        (bool upgradeSuccess,) = address(_opcm).delegatecall(\n            abi.encodeCall(\n                IOPContractsManagerV2.upgrade,\n                (\n                    IOPContractsManagerV2.UpgradeInput({\n                        systemConfig: systemConfig,\n                        disputeGameConfigs: disputeGameConfigs,\n                        extraInstructions: extraInstructions\n                    })\n                )\n            )\n        );\n        assertTrue(upgradeSuccess, \"upgrade failed\");\n    }\n\n    /// @notice Upgrades the contracts using the OPCM.\n    function _upgrade() internal {\n        ISystemConfig systemConfig = ISystemConfig(artifacts.mustGetAddress(\"SystemConfigProxy\"));\n        IProxyAdmin proxyAdmin = IProxyAdmin(EIP1967Helper.getAdmin(address(systemConfig)));\n\n        address upgrader = proxyAdmin.owner();\n        vm.label(upgrader, \"ProxyAdmin Owner\");\n\n        // Run past upgrades from the TOML config.\n        IDisputeGameFactory disputeGameFactoryForPastUpgrades =\n            IDisputeGameFactory(artifacts.mustGetAddress(\"DisputeGameFactoryProxy\"));\n        ISuperchainConfig superchainConfig = ISuperchainConfig(artifacts.mustGetAddress(\"SuperchainConfigProxy\"));\n        PastUpgrades.runPastUpgrades(upgrader, systemConfig, superchainConfig, disputeGameFactoryForPastUpgrades);\n\n        // Current upgrade.\n        if (isDevFeatureEnabled(DevFeatures.OPCM_V2)) {\n            IOPContractsManagerV2 opcmV2 = IOPContractsManagerV2(artifacts.mustGetAddress(\"OPContractsManagerV2\"));\n            _doUpgradeV2(opcmV2, upgrader);\n        } else {\n            IOPContractsManager opcm = IOPContractsManager(artifacts.mustGetAddress(\"OPContractsManager\"));\n            _doUpgrade(opcm, upgrader);\n        }\n\n        console.log(\"ForkLive: Saving newly deployed contracts\");\n\n        // A new ASR and new dispute games were deployed, so we need to update them\n        IDisputeGameFactory disputeGameFactory =\n            IDisputeGameFactory(artifacts.mustGetAddress(\"DisputeGameFactoryProxy\"));\n        address permissionedDisputeGame = address(disputeGameFactory.gameImpls(GameTypes.PERMISSIONED_CANNON));\n        artifacts.save(\"PermissionedDisputeGame\", permissionedDisputeGame);\n\n        IAnchorStateRegistry newAnchorStateRegistry = IAnchorStateRegistry(\n            LibGameArgs.decode(disputeGameFactory.gameArgs(GameTypes.PERMISSIONED_CANNON)).anchorStateRegistry\n        );\n        artifacts.save(\"AnchorStateRegistryProxy\", address(newAnchorStateRegistry));\n\n        // Get the lockbox address from the portal, and save it\n        IOptimismPortal2 portal = IOptimismPortal2(artifacts.mustGetAddress(\"OptimismPortalProxy\"));\n        address lockboxAddress = address(portal.ethLockbox());\n        artifacts.save(\"ETHLockboxProxy\", lockboxAddress);\n\n        // Get the new DelayedWETH address and save it (might be a new proxy).\n        IDelayedWETH newDelayedWeth =\n            IDelayedWETH(payable(LibGameArgs.decode(disputeGameFactory.gameArgs(GameTypes.PERMISSIONED_CANNON)).weth));\n        artifacts.save(\"DelayedWETHProxy\", address(newDelayedWeth));\n        artifacts.save(\"DelayedWETHImpl\", EIP1967Helper.getImplementation(address(newDelayedWeth)));\n    }\n\n    /// @notice Saves the proxy and implementation addresses for a contract name\n    /// @param _contractName The name of the contract to save\n    /// @param _tomlPath The path to the superchain config file\n    /// @param _tomlKey The key in the superchain config file to get the proxy address\n    function saveProxyAndImpl(string memory _contractName, string memory _tomlPath, string memory _tomlKey) internal {\n        address proxy = vm.parseTomlAddress(_tomlPath, _tomlKey);\n        artifacts.save(string.concat(_contractName, \"Proxy\"), proxy);\n\n        address impl = EIP1967Helper.getImplementation(proxy);\n        require(impl != address(0), \"Upgrade: Implementation address is zero\");\n        artifacts.save(string.concat(_contractName, \"Impl\"), impl);\n    }\n}\n"
    }
}