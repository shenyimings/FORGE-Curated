{
    "vfp_id": "vfp_00259",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "ZapOFTComposer._lzCompose may fail with USDT",
            "description": "The _lzCompose function uses the standard approve method for ERC20 tokens without handling the special case of tokens like USDT that do not allow changing a non-zero approval to another non-zero value. The root cause is the failure to use SafeERC20's forceApprove function, despite importing the library. This can cause transactions to fail when users attempt to create zaps with multiple USDT inputs, as the approve call will revert if an existing non-zero allowance is present. The impact is a denial of service for users trying to interact with USDT in zap operations, reducing the usability and reliability of the protocol for one of the most widely used stablecoins, despite a safe alternative being available in the codebase.\n",
            "severity": "Informational",
            "location": [
                "contracts/zap/ZapOFTComposer.sol#L39-L55",
                "ZapOFTComposer.sol::_lzCompose"
            ],
            "files": [
                "cap-contracts/contracts/zap/ZapOFTComposer.sol"
            ]
        }
    ],
    "affected_files": {
        "ZapOFTComposer.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.22;\n\nimport { IZapRouter } from \"../interfaces/IZapRouter.sol\";\n\nimport { IZapOFTComposer } from \"../interfaces/IZapOFTComposer.sol\";\nimport { SafeOFTLzComposer } from \"./SafeOFTLzComposer.sol\";\nimport { IOAppCore } from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol\";\nimport { IOFT } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport { OFTComposeMsgCodec } from \"@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title ZapOFTComposer\n/// @author @capLabs\n/// @notice Compose an OFT with Zap capabilities\n/// @dev This contract is used to compose an OFT message with Zap capabilities.\n///      It handles ERC20 approvals, zap execution, and refunds the remaining tokens to the zap recipient.\n///      Expects the funds to be sent to the ZapOFTComposer contract before the message is composed.\ncontract ZapOFTComposer is SafeOFTLzComposer {\n    using SafeERC20 for IERC20;\n\n    /// @notice Store ZapRouter addresses.\n    address public immutable zapRouter;\n    address public immutable zapTokenManager;\n\n    /// @notice Constructs the contract.\n    /// @dev Initializes the contract.\n    /// @param _oApp The address of the OApp that is sending the composed message.\n    /// @param _zapRouter The address of the ZapRouter to use for Zap capabilities.\n    constructor(address _endpoint, address _oApp, address _zapRouter, address _zapTokenManager)\n        SafeOFTLzComposer(_oApp, _endpoint)\n    {\n        zapRouter = _zapRouter;\n        zapTokenManager = _zapTokenManager;\n    }\n\n    /// @notice Handles incoming composed messages from LayerZero OFTs and executes the zap order it represents.\n    function _lzCompose(address, /*_oApp*/ bytes32, /*_guid*/ bytes calldata _message, address, bytes calldata)\n        internal\n        override\n    {\n        // Decode the payload to get the message\n        bytes memory payload = OFTComposeMsgCodec.composeMsg(_message);\n        IZapOFTComposer.ZapMessage memory zapMessage = abi.decode(payload, (IZapOFTComposer.ZapMessage));\n\n        // approve all inputs to the zapTokenManager\n        IZapRouter.Input[] memory inputs = zapMessage.order.inputs;\n        uint256 inputLength = inputs.length;\n        for (uint256 i = 0; i < inputLength; i++) {\n            IZapRouter.Input memory input = inputs[i];\n            if (input.amount > 0) {\n                IERC20(input.token).approve(zapTokenManager, input.amount);\n            }\n        }\n\n        // execute the zap order\n        IZapRouter(zapRouter).executeOrder(zapMessage.order, zapMessage.route);\n    }\n}\n"
    }
}