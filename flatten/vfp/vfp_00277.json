{
    "vfp_id": "vfp_00277",
    "project_name": "MetaMask USD Token _ Consensys Diligence.md",
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Consider Allowing `approve` Even When Contract Is Paused",
            "description": "The `MUSD` contract inherits from OpenZeppelin’s `PausableUpgradeable` and blocks `approve` calls during a paused state via the `_beforeApprove` hook. This behavior differs from standard OpenZeppelin pausable ERC-20 contracts, where `approve` is allowed even when paused. The root cause is the explicit inclusion of `_requireNotPaused()` in the `_beforeApprove` hook. This restriction prevents users from revoking approvals during emergency pauses, which could be security-critical—for example, during an ongoing exploit. An attacker could potentially exploit standing approvals if users are unable to revoke them during a pause. The impact is limited because the contract is pausable by design and administrative controls exist, but it reduces user autonomy in securing their own funds.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::_beforeApprove#101-111"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 1,
            "category": {},
            "title": "Consider Making Forced Transfers Revert for Zero Amount",
            "description": "The `_forceTransfer` function in the `MUSD` contract allows zero-amount forced transfers to succeed, emitting a `ForcedTransfer` event. While this mimics standard ERC-20 behavior for zero-value transfers (which must emit `Transfer`), forced transfers are exceptional administrative actions that move funds from frozen accounts without owner consent. The root cause is the early return when `amount == 0` without reverting. This could lead to misuse or confusion, as a zero-amount forced transfer may indicate a user error or an attempt to test permissions without effect. Although no funds are moved, the event emission could be misleading or abused for log spam. The impact is low, as no economic loss occurs, but it may affect monitoring and incident response systems.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::_forceTransfer#166-178"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 2,
            "category": {},
            "title": "Version Mismatch for `evm-m-extensions` in `mUSD`",
            "description": "The `MUSD` contract depends on the `evm-m-extensions` repository, but the version used in the project (submodule at `90f144de...`) is behind the revision (`011f84f0...`) that was intended for audit. This discrepancy means that the audited logic may not fully reflect the actual deployed or intended behavior, especially since `MUSD` inherits functionality from `evm-m-extensions`. The root cause is a misalignment in submodule versioning, possibly due to deployment or configuration drift. While the audit scope did not include `evm-m-extensions`, this mismatch introduces uncertainty about the correctness and security of inherited behaviors. The impact is informational, but it could mask vulnerabilities in the actual deployed codebase if the older version contains unpatched issues.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 3,
            "category": {},
            "title": "ERC-20 Token Name Not Correct",
            "description": "The ERC-20 token name in the `MUSD` contract is hardcoded as \"MUSD\", but according to the MetaMask team, it should be \"MetaMask USD\". This discrepancy occurs in the initialization of the `MYieldToOne` base contract. The root cause is a mismatch between product branding and on-chain implementation. While this does not introduce a security vulnerability, it affects user experience and trust, as wallet interfaces and exchanges will display the incorrect name. There is no exploitation vector, but it could lead to confusion or reduced confidence in the token's legitimacy. The impact is purely reputational and branding-related.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::initialize#56"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 4,
            "category": {},
            "title": "Cumulative Hooks Should Always Call Their `super`, Even if Currently Empty",
            "description": "The `_beforeClaimYield` hook in `MUSD` overrides a base function but does not call `super._beforeClaimYield()`. Although the base implementation is currently empty and has no functional impact, this pattern violates best practices for cumulative hooks in inheritance hierarchies. The root cause is an omission in the override implementation. If future updates add logic to the base hook, the `MUSD` contract will fail to execute it, potentially bypassing critical checks. This could lead to security gaps if, for example, access control or validation logic is later added to the parent hook. The impact is low in the current state but introduces technical debt and future risk.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::_beforeClaimYield#148-152"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 5,
            "category": {},
            "title": "Several Public Functions Could Be External",
            "description": "The `initialize`, `pause`, and `unpause` functions in `MUSD` are declared as `public` but are never called internally. The root cause is suboptimal function visibility selection. Declaring them as `external` would reduce gas costs for external callers and clarify intent, as these functions are only meant to be called externally. There is no security risk, but it represents a code quality issue. The impact is minimal, limited to inefficiency and slightly higher gas usage, but it does not affect correctness or security.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::initialize#45-52",
                "src/MUSD.sol::MUSD::pause#66",
                "src/MUSD.sol::MUSD::unpause#71"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 6,
            "category": {},
            "title": "initialize Function Should Probably Not Be Virtual",
            "description": "The `initialize` function in `MUSD` is marked as `virtual`, suggesting it can be overridden in derived contracts. However, no other functions in the contract are virtual, and the design does not appear to support inheritance. The root cause is inconsistent design signaling. If the contract is not intended to be inherited, marking `initialize` as `virtual` may mislead developers into thinking extension is supported. This could lead to unsafe inheritance patterns or confusion during code review. The impact is low, as no actual vulnerability exists, but it affects code maintainability and clarity.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::initialize#45-52"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 7,
            "category": {},
            "title": "Inconsistent Order of Functions in Interface and Contract",
            "description": "The `IMUSD` interface defines `forceTransfers` before `forceTransfer`, while the `MUSD` contract implements `forceTransfer` first. This inconsistency does not affect functionality but reduces code readability and maintainability. The root cause is a lack of alignment in source code organization. While Solidity does not require interface and contract function order to match, consistent ordering improves developer experience and reduces the risk of integration errors. The impact is purely code quality and does not pose any security risk.\n",
            "severity": "Low",
            "location": [
                "src/IMUSD.sol::IMUSD::forceTransfers#51-71",
                "src/MUSD.sol::MUSD::forceTransfer#75-97"
            ],
            "files": [
                "mUSD/src/MUSD.sol",
                "mUSD/src/IMUSD.sol"
            ]
        }
    ],
    "affected_files": {
        "IMUSD.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.26;\n\n/**\n * @title  MUSD Interface\n * @author M0 Labs\n *\n */\ninterface IMUSD {\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emitted when tokens are forcefully transferred from a frozen account.\n     * @param  frozenAccount The address of the frozen account.\n     * @param  recipient The address of the recipient.\n     * @param  forcedTransferManager The address of the force transfer manager that triggered the event.\n     * @param  amount The amount of tokens transferred.\n     */\n    event ForcedTransfer(\n        address indexed frozenAccount,\n        address indexed recipient,\n        address indexed forcedTransferManager,\n        uint256 amount\n    );\n\n    /* ============ Custom Errors ============ */\n\n    /// @notice Emitted in constructor if Pauser is 0x0.\n    error ZeroPauser();\n\n    /// @notice Emitted in constructor if Force Transfer Manager is 0x0.\n    error ZeroForcedTransferManager();\n\n    /// @notice Emitted when the length of the input arrays do not match in `forceTransfer` method.\n    error ArrayLengthMismatch();\n\n    /* ============ Interactive Functions ============ */\n\n    /**\n     * @notice Pauses the contract.\n     * @dev    Can only be called by an account with the PAUSER_ROLE.\n     */\n    function pause() external;\n\n    /**\n     * @notice Unpauses the contract.\n     * @dev    Can only be called by an account with the PAUSER_ROLE.\n     */\n    function unpause() external;\n\n    /**\n     * @notice Forcefully transfers tokens from frozen accounts to recipients.\n     * @dev    Can only be called by an account with the FORCED_TRANSFER_MANAGER_ROLE.\n     * @param  frozenAccounts The addresses of the frozen accounts.\n     * @param  recipients The addresses of the recipients.\n     * @param  amounts The amounts of tokens to transfer.\n     */\n    function forceTransfers(\n        address[] calldata frozenAccounts,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external;\n\n    /**\n     * @notice Forcefully transfers tokens from a frozen account to a recipient.\n     * @dev    Can only be called by an account with the FORCED_TRANSFER_MANAGER_ROLE.\n     * @param  frozenAccount The address of the frozen account.\n     * @param  recipient The address of the recipient.\n     * @param  amount The amount of tokens to transfer.\n     */\n    function forceTransfer(address frozenAccount, address recipient, uint256 amount) external;\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @notice The role that can pause and unpause the contract.\n    function PAUSER_ROLE() external view returns (bytes32);\n\n    /// @notice The role that can force transfer tokens from frozen accounts.\n    function FORCED_TRANSFER_MANAGER_ROLE() external view returns (bytes32);\n}\n",
        "MUSD.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.26;\n\nimport { PausableUpgradeable } from \"../lib/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol\";\n\nimport { MYieldToOne } from \"../lib/evm-m-extensions/src/projects/yieldToOne/MYieldToOne.sol\";\n\nimport { IMUSD } from \"./IMUSD.sol\";\n\n/**\n * @title  MUSD\n * @notice M extension for the MUSD token.\n * @author M0 Labs\n */\ncontract MUSD is IMUSD, MYieldToOne, PausableUpgradeable {\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMUSD\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /// @inheritdoc IMUSD\n    bytes32 public constant FORCED_TRANSFER_MANAGER_ROLE = keccak256(\"FORCED_TRANSFER_MANAGER_ROLE\");\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     * @notice Constructs MUSD Implementation contract\n     * @dev    `_disableInitializers()` is called in the inherited MExtension's constructor.\n     * @param  mToken       The address of the MToken\n     * @param  swapFacility The address of the SwapFacility\n     */\n    constructor(address mToken, address swapFacility) MYieldToOne(mToken, swapFacility) {}\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @dev   Initializes the MUSD token.\n     * @param yieldRecipient        The address of a yield destination.\n     * @param admin                 The address of an admin.\n     * @param freezeManager         The address of a freeze manager.\n     * @param yieldRecipientManager The address of a yield recipient setter.\n     * @param pauser                The address of a pauser.\n     */\n    function initialize(\n        address yieldRecipient,\n        address admin,\n        address freezeManager,\n        address yieldRecipientManager,\n        address pauser,\n        address forcedTransferManager\n    ) public virtual initializer {\n        if (pauser == address(0)) revert ZeroPauser();\n        if (forcedTransferManager == address(0)) revert ZeroForcedTransferManager();\n\n        __MYieldToOne_init(\"MUSD\", \"mUSD\", yieldRecipient, admin, freezeManager, yieldRecipientManager);\n        __Pausable_init();\n\n        _grantRole(PAUSER_ROLE, pauser);\n        _grantRole(FORCED_TRANSFER_MANAGER_ROLE, forcedTransferManager);\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMUSD\n    function pause() public onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /// @inheritdoc IMUSD\n    function unpause() public onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    /// @inheritdoc IMUSD\n    function forceTransfer(\n        address frozenAccount,\n        address recipient,\n        uint256 amount\n    ) external onlyRole(FORCED_TRANSFER_MANAGER_ROLE) {\n        _forceTransfer(frozenAccount, recipient, amount);\n    }\n\n    /// @inheritdoc IMUSD\n    function forceTransfers(\n        address[] calldata frozenAccounts,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external onlyRole(FORCED_TRANSFER_MANAGER_ROLE) {\n        if (frozenAccounts.length != recipients.length || frozenAccounts.length != amounts.length) {\n            revert ArrayLengthMismatch();\n        }\n\n        for (uint256 i; i < frozenAccounts.length; ++i) {\n            _forceTransfer(frozenAccounts[i], recipients[i], amounts[i]);\n        }\n    }\n\n    /* ============ Hooks For Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Hook called before approval of mUSD.\n     * @param account The sender's address.\n     * @param spender The spender's address.\n     * @param amount  The amount to be approved.\n     */\n    function _beforeApprove(address account, address spender, uint256 amount) internal view override {\n        _requireNotPaused();\n\n        super._beforeApprove(account, spender, amount);\n    }\n\n    /**\n     * @dev   Hook called before wrapping M into mUSD.\n     * @param account   The account from which M is deposited.\n     * @param recipient The account receiving the minted mUSD.\n     * @param amount    The amount of tokens to wrap.\n     */\n    function _beforeWrap(address account, address recipient, uint256 amount) internal view override {\n        _requireNotPaused();\n\n        super._beforeWrap(account, recipient, amount);\n    }\n\n    /**\n     * @dev   Hook called before unwrapping mUSD.\n     * @param account The account from which mUSD is burned.\n     * @param amount  The amount of tokens to unwrap.\n     */\n    function _beforeUnwrap(address account, uint256 amount) internal view override {\n        _requireNotPaused();\n\n        super._beforeUnwrap(account, amount);\n    }\n\n    /**\n     * @dev   Hook called before transferring mUSD.\n     * @param sender    The address from which the tokens are being transferred.\n     * @param recipient The address to which the tokens are being transferred.\n     * @param amount    The amount of tokens to transfer.\n     */\n    function _beforeTransfer(address sender, address recipient, uint256 amount) internal view override {\n        _requireNotPaused();\n\n        super._beforeTransfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev    Hook called before claiming yield.\n     * @notice MUST only be callable by the YIELD_RECIPIENT_MANAGER_ROLE.\n     */\n    function _beforeClaimYield() internal view override onlyRole(YIELD_RECIPIENT_MANAGER_ROLE) {}\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Internal ERC20 force transfer function to seize funds from a frozen account.\n     * @param frozenAccount The frozen account from which tokens are seized.\n     * @param recipient     The recipient's address.\n     * @param amount        The amount to be transferred.\n     * @dev   Force transfer is only allowed for frozen accounts.\n     * @dev   No `_beforeTransfer` checks apply to forced transfers; ignore checks for paused and frozen states.\n     * @dev   Since this function can only be called by the `FORCED_TRANSFER_MANAGER_ROLE`,\n     *        we do not check if the recipient is frozen.\n     */\n    function _forceTransfer(address frozenAccount, address recipient, uint256 amount) internal {\n        _revertIfInvalidRecipient(recipient);\n        _revertIfNotFrozen(frozenAccount);\n\n        emit Transfer(frozenAccount, recipient, amount);\n        emit ForcedTransfer(frozenAccount, recipient, msg.sender, amount);\n\n        if (amount == 0) return;\n\n        _revertIfInsufficientBalance(frozenAccount, balanceOf(frozenAccount), amount);\n\n        _update(frozenAccount, recipient, amount);\n    }\n}\n"
    }
}