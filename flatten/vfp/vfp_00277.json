{
    "vfp_id": "vfp_00277",
    "project_name": "Morpheus - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Calculation method can be improved to eliminate any chance of overflow",
            "description": "In `RewardPool.sol`, the `_calculateFullPeriodReward` function performs a calculation that multiplies `decreaseAmount_` by `(ip_ * (ip_ - 1))` before dividing by 2. While mathematically correct, this order increases the risk of integer overflow for large values of `decreaseAmount_`. However, since `ip_` and `ip_ - 1` are consecutive integers, one of them is always even, guaranteeing that `(ip_ * (ip_ - 1))` is divisible by 2. Therefore, dividing by 2 first reduces the intermediate value and mitigates overflow risk. The root cause is suboptimal arithmetic ordering. Although no immediate exploit is likely, in edge cases with very large parameters, this could lead to arithmetic overflow and reverted transactions. The impact is informational, as it is a code quality improvement rather than a direct vulnerability, but it enhances robustness.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol"
            ],
            "files": [
                "SmartContracts/contracts/capital-protocol/RewardPool.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardPool.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {LinearDistributionIntervalDecrease} from \"../libs/LinearDistributionIntervalDecrease.sol\";\n\nimport {IRewardPool, IERC165} from \"../interfaces/capital-protocol/IRewardPool.sol\";\n\ncontract RewardPool is IRewardPool, OwnableUpgradeable, UUPSUpgradeable {\n    RewardPool[] public rewardPools;\n\n    /**********************************************************************************************/\n    /*** Init, IERC165                                                                          ***/\n    /**********************************************************************************************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function RewardPool_init(RewardPool[] calldata poolsInfo_) external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        for (uint256 i = 0; i < poolsInfo_.length; i++) {\n            addRewardPool(poolsInfo_[i]);\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId_) external pure returns (bool) {\n        return interfaceId_ == type(IRewardPool).interfaceId || interfaceId_ == type(IERC165).interfaceId;\n    }\n\n    /**********************************************************************************************/\n    /*** Reward pools management, `owner()` functionality                                       ***/\n    /**********************************************************************************************/\n\n    function addRewardPool(RewardPool calldata rewardPool_) public onlyOwner {\n        require(rewardPool_.decreaseInterval > 0, \"RP: invalid decrease interval\");\n\n        rewardPools.push(rewardPool_);\n\n        emit RewardPoolAdded(rewardPools.length - 1, rewardPool_);\n    }\n\n    /**********************************************************************************************/\n    /*** Main getters                                                                           ***/\n    /**********************************************************************************************/\n\n    function isRewardPoolExist(uint256 index_) public view returns (bool) {\n        return index_ < rewardPools.length;\n    }\n\n    function isRewardPoolPublic(uint256 index_) public view returns (bool) {\n        return rewardPools[index_].isPublic;\n    }\n\n    function onlyExistedRewardPool(uint256 index_) external view {\n        require(isRewardPoolExist(index_), \"RP: the reward pool doesn't exist\");\n    }\n\n    function onlyPublicRewardPool(uint256 index_) external view {\n        require(isRewardPoolPublic(index_), \"RP: the pool isn't public\");\n    }\n\n    function onlyNotPublicRewardPool(uint256 index_) external view {\n        require(!isRewardPoolPublic(index_), \"RP: the pool is public\");\n    }\n\n    function getPeriodRewards(uint256 index_, uint128 startTime_, uint128 endTime_) external view returns (uint256) {\n        if (!isRewardPoolExist(index_)) {\n            return 0;\n        }\n\n        RewardPool storage rewardPool = rewardPools[index_];\n\n        return\n            LinearDistributionIntervalDecrease.getPeriodReward(\n                rewardPool.initialReward,\n                rewardPool.rewardDecrease,\n                rewardPool.payoutStart,\n                rewardPool.decreaseInterval,\n                startTime_,\n                endTime_\n            );\n    }\n\n    /**********************************************************************************************/\n    /*** UUPS                                                                                   ***/\n    /**********************************************************************************************/\n\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}\n"
    }
}