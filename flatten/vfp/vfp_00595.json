{
    "vfp_id": "vfp_00595",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Usage of Transient Storage can Lower Gas Costs",
            "description": "The `PegKeeper` contract uses a permanent storage variable `context` to track execution context during `buyback` and `stabilize` calls, which is only needed temporarily. This results in unnecessary gas costs for both setting and clearing storage. The root cause is the use of persistent storage for transient state. By using transient storage (EIP-1153), which is cheaper and automatically cleared after transaction execution, the contract could significantly reduce gas consumption. The impact of not fixing this is higher transaction costs for users, but there is no direct security risk. However, gas inefficiencies can make the protocol less competitive and more expensive to operate.\n",
            "severity": null,
            "location": [
                "PegKeeper.sol#context"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/PegKeeper.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "High Severity: Pricing Scheme Vulnerability",
            "description": "1.  **Description:** The pricing scheme is susceptible to manipulation due to reliance on a single, potentially manipulable liquidity pool.\n2.  **Cause:** The protocol's price determination mechanism does not sufficiently diversify or validate price sources, making it vulnerable to oracle attacks.\n3.  **Exploitation:** An attacker could manipulate the price in the targeted liquidity pool to trigger early or unjustified liquidations of user positions.\n4.  **Impact:** This could lead to unfair liquidations, loss of user funds, and erosion of trust in the system's stability mechanisms.\n",
            "severity": "High",
            "location": [],
            "files": [
                "fx-protocol-contracts/contracts/core/PegKeeper.sol",
                "fx-protocol-contracts/contracts/mocks/MockPriceOracle.sol"
            ]
        }
    ],
    "affected_files": {
        "MockPriceOracle.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { IPriceOracle } from \"../price-oracle/interfaces/IPriceOracle.sol\";\n\ncontract MockPriceOracle is IPriceOracle {\n  uint256 public anchorPrice;\n  uint256 public minPrice;\n  uint256 public maxPrice;\n\n  constructor(uint256 _anchorPrice, uint256 _minPrice, uint256 _maxPrice) {\n    anchorPrice = _anchorPrice;\n    minPrice = _minPrice;\n    maxPrice = _maxPrice;\n  }\n\n  function setPrices(uint256 _anchorPrice, uint256 _minPrice, uint256 _maxPrice) external {\n    anchorPrice = _anchorPrice;\n    minPrice = _minPrice;\n    maxPrice = _maxPrice;\n  }\n\n  function getPrice() public view returns (uint256, uint256, uint256) {\n    return (anchorPrice, minPrice, maxPrice);\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getExchangePrice() public view returns (uint256) {\n    (, uint256 price, ) = getPrice();\n    return price;\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getLiquidatePrice() external view returns (uint256) {\n    return getExchangePrice();\n  }\n\n  /// @inheritdoc IPriceOracle\n  function getRedeemPrice() external view returns (uint256) {\n    (, , uint256 price) = getPrice();\n    return price;\n  }\n}\n",
        "PegKeeper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport { IMultiPathConverter } from \"../helpers/interfaces/IMultiPathConverter.sol\";\nimport { ICurveStableSwapNG } from \"../interfaces/Curve/ICurveStableSwapNG.sol\";\nimport { IFxUSDRegeneracy } from \"../interfaces/IFxUSDRegeneracy.sol\";\nimport { IPegKeeper } from \"../interfaces/IPegKeeper.sol\";\nimport { IFxUSDBasePool } from \"../interfaces/IFxUSDBasePool.sol\";\n\ncontract PegKeeper is AccessControlUpgradeable, IPegKeeper {\n  using SafeERC20 for IERC20;\n\n  /**********\n   * Errors *\n   **********/\n\n  error ErrorNotInCallbackContext();\n\n  error ErrorZeroAddress();\n\n  error ErrorInsufficientOutput();\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev The precision used to compute nav.\n  uint256 private constant PRECISION = 1e18;\n\n  /// @notice The role for buyback.\n  bytes32 public constant BUYBACK_ROLE = keccak256(\"BUYBACK_ROLE\");\n\n  /// @notice The role for stabilize.\n  bytes32 public constant STABILIZE_ROLE = keccak256(\"STABILIZE_ROLE\");\n\n  /// @dev contexts for buyback and stabilize callback\n  uint8 private constant CONTEXT_NO_CONTEXT = 1;\n  uint8 private constant CONTEXT_BUYBACK = 2;\n  uint8 private constant CONTEXT_STABILIZE = 3;\n\n  /***********************\n   * Immutable Variables *\n   ***********************/\n\n  /// @notice The address of fxUSD.\n  address public immutable fxUSD;\n\n  /// @notice The address of stable token.\n  address public immutable stable;\n\n  /// @notice The address of FxUSDBasePool.\n  address public immutable fxBASE;\n\n  /*********************\n   * Storage Variables *\n   *********************/\n\n  /// @dev The context for buyback and stabilize callback.\n  uint8 private context;\n\n  /// @notice The address of MultiPathConverter.\n  address public converter;\n\n  /// @notice The curve pool for stable and fxUSD\n  address public curvePool;\n\n  /// @notice The fxUSD depeg price threshold.\n  uint256 public priceThreshold;\n\n  /*************\n   * Modifiers *\n   *************/\n\n  modifier setContext(uint8 c) {\n    context = c;\n    _;\n    context = CONTEXT_NO_CONTEXT;\n  }\n\n  /***************\n   * Constructor *\n   ***************/\n\n  constructor(address _fxBASE) {\n    fxBASE = _fxBASE;\n    fxUSD = IFxUSDBasePool(_fxBASE).yieldToken();\n    stable = IFxUSDBasePool(_fxBASE).stableToken();\n  }\n\n  function initialize(address admin, address _converter, address _curvePool) external initializer {\n    __Context_init();\n    __ERC165_init();\n    __AccessControl_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n    _updateConverter(_converter);\n    _updateCurvePool(_curvePool);\n    _updatePriceThreshold(995000000000000000); // 0.995\n\n    context = CONTEXT_NO_CONTEXT;\n  }\n\n  /*************************\n   * Public View Functions *\n   *************************/\n\n  /// @inheritdoc IPegKeeper\n  function isBorrowAllowed() external view returns (bool) {\n    return _getFxUSDEmaPrice() >= priceThreshold;\n  }\n\n  /// @inheritdoc IPegKeeper\n  function isFundingEnabled() external view returns (bool) {\n    return _getFxUSDEmaPrice() < priceThreshold;\n  }\n\n  /// @inheritdoc IPegKeeper\n  function getFxUSDPrice() external view returns (uint256) {\n    return _getFxUSDEmaPrice();\n  }\n\n  /****************************\n   * Public Mutated Functions *\n   ****************************/\n\n  /// @inheritdoc IPegKeeper\n  function buyback(\n    uint256 amountIn,\n    bytes calldata data\n  ) external onlyRole(BUYBACK_ROLE) setContext(CONTEXT_BUYBACK) returns (uint256 amountOut, uint256 bonus) {\n    (amountOut, bonus) = IFxUSDRegeneracy(fxUSD).buyback(amountIn, _msgSender(), data);\n  }\n\n  /// @inheritdoc IPegKeeper\n  function stabilize(\n    address srcToken,\n    uint256 amountIn,\n    bytes calldata data\n  ) external onlyRole(STABILIZE_ROLE) setContext(CONTEXT_STABILIZE) returns (uint256 amountOut, uint256 bonus) {\n    (amountOut, bonus) = IFxUSDBasePool(fxBASE).arbitrage(srcToken, amountIn, _msgSender(), data);\n  }\n\n  /// @inheritdoc IPegKeeper\n  /// @dev This function will be called in `buyback`, `stabilize`.\n  function onSwap(\n    address srcToken,\n    address targetToken,\n    uint256 amountIn,\n    bytes calldata data\n  ) external returns (uint256 amountOut) {\n    // check callback validity\n    if (context == CONTEXT_NO_CONTEXT) revert ErrorNotInCallbackContext();\n\n    amountOut = _doSwap(srcToken, amountIn, data);\n    IERC20(targetToken).safeTransfer(_msgSender(), amountOut);\n  }\n\n  /************************\n   * Restricted Functions *\n   ************************/\n\n  /// @notice Update the address of converter.\n  /// @param newConverter The address of converter.\n  function updateConverter(address newConverter) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateConverter(newConverter);\n  }\n\n  /// @notice Update the address of curve pool.\n  /// @param newPool The address of curve pool.\n  function updateCurvePool(address newPool) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updateCurvePool(newPool);\n  }\n\n  /// @notice Update the value of depeg price threshold.\n  /// @param newThreshold The value of new price threshold.\n  function updatePriceThreshold(uint256 newThreshold) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _updatePriceThreshold(newThreshold);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to update the address of converter.\n  /// @param newConverter The address of converter.\n  function _updateConverter(address newConverter) internal {\n    if (newConverter == address(0)) revert ErrorZeroAddress();\n\n    address oldConverter = converter;\n    converter = newConverter;\n\n    emit UpdateConverter(oldConverter, newConverter);\n  }\n\n  /// @dev Internal function to update the address of curve pool.\n  /// @param newPool The address of curve pool.\n  function _updateCurvePool(address newPool) internal {\n    if (newPool == address(0)) revert ErrorZeroAddress();\n\n    address oldPool = curvePool;\n    curvePool = newPool;\n\n    emit UpdateCurvePool(oldPool, newPool);\n  }\n\n  /// @dev Internal function to update the value of depeg price threshold.\n  /// @param newThreshold The value of new price threshold.\n  function _updatePriceThreshold(uint256 newThreshold) internal {\n    uint256 oldThreshold = priceThreshold;\n    priceThreshold = newThreshold;\n\n    emit UpdatePriceThreshold(oldThreshold, newThreshold);\n  }\n\n  /// @dev Internal function to do swap.\n  /// @param srcToken The address of source token.\n  /// @param amountIn The amount of token to use.\n  /// @param data The callback data.\n  /// @return amountOut The amount of token swapped.\n  function _doSwap(address srcToken, uint256 amountIn, bytes calldata data) internal returns (uint256 amountOut) {\n    IERC20(srcToken).forceApprove(converter, amountIn);\n\n    (uint256 minOut, uint256 encoding, uint256[] memory routes) = abi.decode(data, (uint256, uint256, uint256[]));\n    amountOut = IMultiPathConverter(converter).convert(srcToken, amountIn, encoding, routes);\n    if (amountOut < minOut) revert ErrorInsufficientOutput();\n  }\n\n  /// @dev Internal function to get curve ema price for fxUSD.\n  /// @return price The value of ema price, multiplied by 1e18.\n  function _getFxUSDEmaPrice() internal view returns (uint256 price) {\n    address cachedCurvePool = curvePool; // gas saving\n    address firstCoin = ICurveStableSwapNG(cachedCurvePool).coins(0);\n    price = ICurveStableSwapNG(cachedCurvePool).price_oracle(0);\n    if (firstCoin == fxUSD) {\n      price = (PRECISION * PRECISION) / price;\n    }\n  }\n}\n"
    }
}