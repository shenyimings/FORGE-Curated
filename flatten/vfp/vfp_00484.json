{
    "vfp_id": "vfp_00484",
    "project_name": "Zenith Audit Report - Stream Protocol.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Using tokens with 18 decimals leads to significant loss of funds when bridging across chains",
            "description": "1.  **Description:** The vulnerability involves incorrect handling of tokens with 18 decimal places during cross-chain bridging operations.\n2.  **Cause:** The system does not properly normalize or convert decimal differences between tokens, leading to miscalculations.\n3.  **Exploitation:** An attacker could deposit a high-decimal token and trigger a bridge operation, causing a disproportionate withdrawal on the destination chain.\n4.  **Impact:** Users may suffer significant loss of funds due to incorrect amount calculations during cross-chain transfers.\n",
            "severity": "Critical",
            "location": [
                "StableWrapper.sol",
                "StreamVault.sol"
            ],
            "files": [
                "contracts/src/StableWrapper.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "`instantUnstake` and `unstake` can be used to bypass `minimumSupply`",
            "description": "1.  **Description:** The `instantUnstake` and `unstake` functions do not enforce the `minimumSupply` requirement, allowing users to withdraw funds even when doing so would drop the total supply below the intended minimum threshold.\n2.  **Cause:** Missing validation checks in the unstake functions to ensure the `minimumSupply` is maintained after withdrawals.\n3.  **Exploitation:** An attacker could exploit this by rapidly unstaking small amounts to drain the vault below the minimum supply, potentially destabilizing the system.\n4.  **Impact:** The vault may fall below its minimum supply, affecting system stability and economic model integrity.\n",
            "severity": "Medium",
            "location": [
                "StreamVault.sol::instantUnstake",
                "StreamVault.sol::unstake"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "The vault's `cap` can be bypassed, and the `minimumSupply` can be reached earlier than intended",
            "description": "1.  **Description:** There exists a logic flaw that allows the vault's deposit cap to be circumvented, and the minimum supply threshold to be reached prematurely.\n2.  **Cause:** Improper enforcement of deposit limits in certain code paths, possibly through indirect deposits or wrapper contracts.\n3.  **Exploitation:** An attacker could exploit this by routing deposits through alternative functions or contracts that do not enforce the cap or supply checks.\n4.  **Impact:** The vault could exceed its intended capacity or reach minimum supply too early, disrupting yield distribution and economic balance.\n",
            "severity": "Medium",
            "location": [
                "StreamVault.sol",
                "StableWrapper.sol"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Providing yield on the first `rollToNextRound` causes unexpected behavior",
            "description": "1.  **Description:** Yield calculation during the first round transition via `rollToNextRound` leads to incorrect or unexpected state changes.\n2.  **Cause:** The initialization logic does not properly handle the first yield distribution, possibly due to uninitialized price-per-share or zero base values.\n3.  **Exploitation:** An attacker could trigger `rollToNextRound` prematurely or manipulate the timing to receive disproportionate rewards.\n4.  **Impact:** Users may receive incorrect share allocations, leading to unfair distribution and potential loss of funds.\n",
            "severity": "Medium",
            "location": [
                "StreamVault.sol::rollToNextRound"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Short-term DoS in `processWithdrawals` function",
            "description": "1.  **Description:** The `processWithdrawals` function is susceptible to a short-term denial-of-service condition.\n2.  **Cause:** The function may revert under certain conditions, such as empty queues or invalid states, without proper error handling or fallbacks.\n3.  **Exploitation:** An attacker could trigger reverts by manipulating withdrawal queue states, preventing legitimate users from processing withdrawals.\n4.  **Impact:** Temporary disruption of withdrawal functionality, leading to user fund lockup and degraded user experience.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::processWithdrawals"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1285"
                ],
                "4": [
                    "CWE-129"
                ]
            },
            "title": "`getSharesFromReceipt` function should check if the round from stakeReceipt is greater than 1",
            "description": "1.  **Description:** The `getSharesFromReceipt` function does not validate whether the referenced round is valid or initialized.\n2.  **Cause:** Missing boundary checks on the round number in the stake receipt.\n3.  **Exploitation:** Calling the function with an uninitialized or invalid round could return incorrect share values.\n4.  **Impact:** Incorrect share calculations could lead to user confusion or incorrect redemption amounts.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::getSharesFromReceipt"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Setters for key state variables in the `StableWrapper` and `StreamVault` contracts should be considered for removal",
            "description": "1.  **Description:** Public setter functions for critical state variables increase attack surface and risk of accidental or malicious misconfiguration.\n2.  **Cause:** Unnecessary mutability of important parameters after initialization.\n3.  **Exploitation:** If access controls are ever compromised, an attacker could modify key parameters to destabilize the system.\n4.  **Impact:** Potential for governance bypass or parameter manipulation leading to financial loss.\n",
            "severity": "Low",
            "location": [
                "StableWrapper.sol",
                "StreamVault.sol"
            ],
            "files": [
                "contracts/src/StableWrapper.sol",
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing check for non-zero creditor address in `StreamVault::depositAndStake` function",
            "description": "1.  **Description:** The `depositAndStake` function does not validate that the creditor address is not zero.\n2.  **Cause:** Lack of input validation for address parameters.\n3.  **Exploitation:** A call with a zero address could result in lost funds or incorrect state updates.\n4.  **Impact:** Funds may be deposited to a null address, rendering them irrecoverable.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::depositAndStake"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Missing balance cap check in `StreamVault::rollToNextRound` function",
            "description": "1.  **Description:** The `rollToNextRound` function does not enforce the vault's balance cap during round transitions.\n2.  **Cause:** Omission of cap validation before allowing new rounds to begin.\n3.  **Exploitation:** Deposits could push the vault over its intended cap, which is not checked at round rollover.\n4.  **Impact:** The vault may exceed its designed capacity, increasing risk exposure beyond acceptable levels.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::rollToNextRound"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "`rollToNextRound` could revert under certain conditions",
            "description": "1.  **Description:** The `rollToNextRound` function may unexpectedly revert due to unhandled edge cases.\n2.  **Cause:** Lack of defensive checks for zero balances, empty states, or external call failures.\n3.  **Exploitation:** An attacker could manipulate state to trigger reverts, disrupting protocol operations.\n4.  **Impact:** Protocol stalling, delayed round transitions, and user withdrawal delays.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::rollToNextRound"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "`rescueTokens` inside `StreamVault` could cause issues",
            "description": "1.  **Description:** The `rescueTokens` function may allow unintended token recovery or create reentrancy risks.\n2.  **Cause:** Broad token transfer functionality without sufficient restrictions or checks.\n3.  **Exploitation:** Could be abused to drain tokens or interact with malicious contracts.\n4.  **Impact:** Potential loss of rescued tokens or unintended side effects during external calls.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::rescueTokens"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "`transferAsset` inside `StableWrapper` could cause issues",
            "description": "1.  **Description:** The `transferAsset` function lacks safeguards and may lead to incorrect transfers.\n2.  **Cause:** Insufficient validation of recipient or amount.\n3.  **Exploitation:** Could be used to send tokens to invalid addresses or in incorrect amounts.\n4.  **Impact:** Loss of funds or incorrect state updates.\n",
            "severity": "Low",
            "location": [
                "StableWrapper.sol::transferAsset"
            ],
            "files": [
                "contracts/src/StableWrapper.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "`processWithdrawals` has a risk due to the lack of slippage/amount control",
            "description": "1.  **Description:** The `processWithdrawals` function does not enforce minimum amount or slippage tolerance during asset swaps or redemptions.\n2.  **Cause:** Absence of output amount guarantees.\n3.  **Exploitation:** An attacker could manipulate prices to receive less value than expected.\n4.  **Impact:** Users may suffer losses due to unfavorable execution conditions.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::processWithdrawals"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "`StableWrapper` may not work properly when using certain tokens as assets",
            "description": "1.  **Description:** The `StableWrapper` contract may malfunction with non-standard ERC20 tokens.\n2.  **Cause:** Assumptions about token behavior (e.g., no fees on transfer) that do not hold for all tokens.\n3.  **Exploitation:** Using fee-on-transfer or rebasing tokens could break balance tracking.\n4.  **Impact:** Incorrect accounting, loss of funds, or failed transactions.\n",
            "severity": "Low",
            "location": [
                "StableWrapper.sol"
            ],
            "files": [
                "contracts/src/StableWrapper.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Lack of slippage control in `unstake` and `unstakeAndWithdraw`",
            "description": "1.  **Description:** These functions do not enforce minimum output amounts during token unwrapping or withdrawals.\n2.  **Cause:** Missing slippage protection mechanisms.\n3.  **Exploitation:** Users may receive fewer tokens than expected during volatile market conditions.\n4.  **Impact:** Financial loss for users due to poor execution.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::unstake",
                "StreamVault.sol::unstakeAndWithdraw"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Dangerous usage of the `stableWrapper` balance inside `rollToNextRound`",
            "description": "1.  **Description:** The `rollToNextRound` function relies on the `stableWrapper` balance without considering external manipulations.\n2.  **Cause:** Trusting an external balance that could be inflated via minting or other means.\n3.  **Exploitation:** An attacker could inflate the balance to manipulate yield calculations.\n4.  **Impact:** Inflated share prices, unfair distribution, and potential loss of funds.\n",
            "severity": "Low",
            "location": [
                "StreamVault.sol::rollToNextRound"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Lack of time interval restrictions on `rollToNextRound` and `processWithdrawals`",
            "description": "1.  **Description:** These functions can be called repeatedly without enforced time delays.\n2.  **Cause:** Missing rate-limiting or cooldown mechanisms.\n3.  **Exploitation:** Could be spammed or called at inopportune times, disrupting protocol stability.\n4.  **Impact:** Increased gas costs, state instability, and potential manipulation of round timing.\n",
            "severity": "Informational",
            "location": [
                "StreamVault.sol::rollToNextRound",
                "StreamVault.sol::processWithdrawals"
            ],
            "files": [
                "contracts/src/StreamVault.sol"
            ]
        }
    ],
    "affected_files": {
        "StableWrapper.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IStableWrapper} from \"./interfaces/IStableWrapper.sol\";\nimport {OFT} from \"@layerzerolabs/oft-evm/contracts/OFT.sol\";\n\n/**\n * @title StableWrapper\n * @notice A token wrapper that allows users to obtain tokens needed to deposit into a StreamVault.\n * @notice Users receive a Stream token that maps 1:1 to the asset deposited.\n * @notice Initiated withdrawals can be completed after the epoch has passed.\n */\ncontract StableWrapper is OFT, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // #############################################\n    // STATE\n    // #############################################\n\n    /// @notice The asset that the wrapper is wrapping\n    address public asset;\n\n    /// @notice The current epoch number\n    uint32 public currentEpoch;\n\n    /// @notice Whether the wrapper allows independence.\n    /// If false, autostaking is enabled.\n    bool public allowIndependence;\n\n    /// @notice The number of decimals for the underlying asset\n    /// and the wrapped token\n    uint8 public underlyingDecimals;\n\n    /// @notice The address of the keeper\n    address public keeper;\n\n    /// @notice Stores the user's pending withdrawals\n    mapping(address => WithdrawalReceipt) public withdrawalReceipts;\n\n    /// @notice The amount of assets that have been withdrawn\n    uint256 public withdrawalAmountForEpoch;\n\n    /// @notice The amount of assets that have been deposited\n    uint256 public depositAmountForEpoch;\n\n    // #############################################\n    // STRUCTS\n    // #############################################\n\n    /**\n     * @notice Struct representing a withdrawal receipt\n     * @dev Uses packed storage with uint224 for amount and uint32 for epoch\n     * @param amount The amount of tokens requested for withdrawal\n     * @param epoch The epoch during which the withdrawal was initiated\n     */\n    struct WithdrawalReceipt {\n        uint224 amount;\n        uint32 epoch;\n    }\n\n    // #############################################\n    // EVENTS\n    // #############################################\n\n    event Deposit(address indexed from, address indexed to, uint256 amount);\n\n    event DepositToVault(address indexed user, uint256 amount);\n\n    event WithdrawalInitiated(\n        address indexed user,\n        uint224 amount,\n        uint32 epoch\n    );\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    event WithdrawalsProcessed(uint256 withdrawalAmount, uint256 balance, uint32 epoch);\n\n    event AssetTransferred(address indexed to, uint256 amount);\n\n    event PermissionedMint(address indexed to, uint256 amount);\n\n    event PermissionedBurn(address indexed from, uint256 amount);\n\n    event AllowIndependenceSet(bool allowIndependence);\n\n    event KeeperSet(address keeper);\n\n    // #############################################\n    // ERRORS\n    // #############################################\n\n    error IndependenceNotAllowed();\n\n    error AmountMustBeGreaterThanZero();\n\n    error AddressMustBeNonZero();\n\n    error InsufficientBalance();\n\n    error NotKeeper();\n\n    error CannotCompleteWithdrawalInSameEpoch();\n\n    // #############################################\n    // MODIFIERS\n    // #############################################\n\n    /**\n     * @dev Throws if called by any account other than the keeper\n     */\n    modifier onlyKeeper() {\n        if (msg.sender != keeper) revert NotKeeper();\n        _;\n    }\n\n    // #############################################\n    // CONSTRUCTOR & INITIALIZATION\n    // #############################################\n\n    /**\n     * @notice Initializes the contract\n     * @param _asset is the address of the asset to wrap\n     * @param _name is the name of the wrapped ERC-20\n     * @param _symbol is the symbol of the wrapped ERC-20\n     * @param _keeper is the address of the keeper\n     * @param _lzEndpoint is the address of the LayerZero endpoint\n     * @param _delegate is the address of the delegate\n     */\n    constructor(\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _underlyingDecimals,\n        address _keeper,\n        address _lzEndpoint,\n        address _delegate\n    ) OFT(_name, _symbol, _lzEndpoint, _delegate) Ownable(msg.sender) {\n        if (_asset == address(0)) revert AddressMustBeNonZero();\n        if (_keeper == address(0)) revert AddressMustBeNonZero();\n        asset = _asset;\n        currentEpoch = 1;\n        allowIndependence = false;\n        keeper = _keeper;\n        underlyingDecimals = _underlyingDecimals;\n    }\n\n    // #############################################\n    // DEPOSIT\n    // #############################################\n\n    /**\n     * @notice Deposits assets from a specified address and mints equivalent tokens\n     * @param to Address to transfer assets to\n     * @param amount Amount of assets to deposit\n     */\n    function deposit(address to, uint256 amount) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        _mint(to, amount);\n\n        depositAmountForEpoch += amount;\n\n        emit Deposit(msg.sender, to, amount);\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /**\n     * @notice Deposits assets and mints equivalent tokens to the vault\n     * @param amount Amount of assets to deposit\n     */\n    function depositToVault(\n        address from,\n        uint256 amount\n    ) external nonReentrant onlyKeeper {\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        _mint(keeper, amount);\n\n        depositAmountForEpoch += amount;\n\n        emit DepositToVault(from, amount);\n\n        IERC20(asset).safeTransferFrom(from, address(this), amount);\n    }\n\n    // #############################################\n    // WITHDRAWAL\n    // #############################################\n\n    /**\n     * @notice Burns tokens and creates withdrawal receipt\n     * @param amount Amount of tokens to burn for withdrawal\n     */\n    function initiateWithdrawal(uint224 amount) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (balanceOf(msg.sender) < amount) revert InsufficientBalance();\n\n        _burn(msg.sender, amount);\n\n        uint224 currentAmount = withdrawalReceipts[msg.sender].amount;\n\n        withdrawalReceipts[msg.sender] = WithdrawalReceipt({\n            amount: currentAmount + amount,\n            epoch: currentEpoch\n        });\n\n        withdrawalAmountForEpoch += amount;\n\n        emit WithdrawalInitiated(msg.sender, amount, currentEpoch);\n    }\n\n    /**\n     * @notice Burns tokens and creates withdrawal receipt for a specified address\n     * @param from Address to burn tokens from and create withdrawal receipt for\n     * @param amount Amount of tokens to burn for withdrawal\n     */\n    function initiateWithdrawalFromVault(\n        address from,\n        uint224 amount\n    ) external nonReentrant onlyKeeper {\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        _burn(address(this), amount);\n\n        uint224 currentAmount = withdrawalReceipts[from].amount;\n\n        withdrawalReceipts[from] = WithdrawalReceipt({\n            amount: currentAmount + amount,\n            epoch: currentEpoch\n        });\n\n        withdrawalAmountForEpoch += amount;\n\n        emit WithdrawalInitiated(from, amount, currentEpoch);\n    }\n\n    /**\n     * @notice Complete withdrawal if epoch has passed\n     * @param to Address to transfer assets to\n     */\n    function completeWithdrawal(address to) external nonReentrant {\n        WithdrawalReceipt memory receipt = withdrawalReceipts[msg.sender];\n\n        if (receipt.amount == 0) revert AmountMustBeGreaterThanZero();\n        if (receipt.epoch >= currentEpoch)\n            revert CannotCompleteWithdrawalInSameEpoch();\n\n        delete withdrawalReceipts[msg.sender];\n\n        // Cast uint224 to uint256 explicitly for the transfer\n        uint256 amountToTransfer = uint256(receipt.amount);\n\n        emit Withdrawn(to, amountToTransfer);\n\n        IERC20(asset).safeTransfer(to, amountToTransfer);\n    }\n\n    // #############################################\n    // MINT & BURN\n    // #############################################\n\n    /**\n     * @notice Allows owner to mint tokens to a specified address\n     * @param to Address to mint tokens to\n     * @param amount Amount of tokens to mint\n     */\n    function permissionedMint(address to, uint256 amount) external onlyKeeper {\n        _mint(to, amount);\n        emit PermissionedMint(to, amount);\n    }\n\n    /**\n     * @notice Allows owner to burn tokens from a specified address\n     * @param from Address to burn tokens from\n     * @param amount Amount of tokens to burn\n     */\n    function permissionedBurn(\n        address from,\n        uint256 amount\n    ) external onlyKeeper {\n        _burn(from, amount);\n        emit PermissionedBurn(from, amount);\n    }\n\n    // #############################################\n    // PROTOCOL CONTROL\n    // #############################################\n\n    /**\n     * @notice Processes the withdrawal for the current epoch\n     */\n    function processWithdrawals() external onlyOwner nonReentrant {\n\n        if (withdrawalAmountForEpoch > depositAmountForEpoch) {\n            IERC20(asset).safeTransferFrom(owner(), address(this), withdrawalAmountForEpoch - depositAmountForEpoch);\n        } else if (withdrawalAmountForEpoch < depositAmountForEpoch) {\n            IERC20(asset).safeTransfer(owner(), depositAmountForEpoch - withdrawalAmountForEpoch);\n        }\n\n        emit WithdrawalsProcessed(withdrawalAmountForEpoch, depositAmountForEpoch, currentEpoch);\n\n        currentEpoch += 1;\n        withdrawalAmountForEpoch = 0;\n        depositAmountForEpoch = 0;\n    }\n\n    /**\n     * @notice Allows owner to transfer assets to specified address\n     * @param to Address to transfer assets to\n     * @param amount Amount of assets to transfer\n     * @param _token Address of the token to transfer\n     */\n    function transferAsset(\n        address to,\n        uint256 amount,\n        address _token\n    ) external onlyOwner {\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        emit AssetTransferred(to, amount);\n\n        IERC20(_token).safeTransfer(to, amount);\n    }\n\n    // #############################################\n    // SETTERS\n    // #############################################\n\n    /**\n     * @notice Allows keeper to set the keeper address\n     * @param _keeper New keeper address\n     */\n    function setKeeper(address _keeper) external onlyOwner {\n        if (_keeper == address(0)) revert AddressMustBeNonZero();\n        keeper = _keeper;\n        emit KeeperSet(_keeper);\n    }\n\n    /**\n     * @notice Allows owner to set allowIndependence\n     * @param _allowIndependence New allowIndependence value\n     */\n    function setAllowIndependence(bool _allowIndependence) external onlyOwner {\n        allowIndependence = _allowIndependence;\n        emit AllowIndependenceSet(_allowIndependence);\n    }\n\n    /**\n     * @notice Allows keeper to set the asset address\n     * @param _asset New asset address\n     */\n    function setAsset(address _asset) external onlyOwner {\n        if (_asset == address(0)) revert AddressMustBeNonZero();\n        asset = _asset;\n    }\n\n    // #############################################\n    // GETTERS\n    // #############################################\n\n    /**\n     * @notice modify the token decimals\n     */\n    function setDecimals(uint8 _newDecimals) public onlyOwner {\n        underlyingDecimals = _newDecimals;\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return underlyingDecimals;\n    }\n\n    /**\n     * @notice Returns the shared token decimals for OFT\n     */\n    function sharedDecimals() public view virtual override returns (uint8) {\n        return decimals();\n    }\n}\n",
        "StreamVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ShareMath} from \"./lib/ShareMath.sol\";\nimport {Vault} from \"./lib/Vault.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IStableWrapper} from \"./interfaces/IStableWrapper.sol\";\nimport {OFT} from \"@layerzerolabs/oft-evm/contracts/OFT.sol\";\nimport {SendParam, MessagingFee, MessagingReceipt, OFTReceipt} from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\n/**\n * @title StreamVault\n * @notice A vault that allows users to stake and withdraw from an off-chain managed Stream strategy\n * @notice Users receive shares for their stakes, which can be redeemed for assets\n * @notice The rounds will be rolled over on a weekly basis\n */\ncontract StreamVault is ReentrancyGuard, OFT {\n    using SafeERC20 for IERC20;\n    using ShareMath for Vault.StakeReceipt;\n\n    // #############################################\n    // CONSTANTS\n    // #############################################\n    /// @notice Minimum round number for valid stake receipts\n    uint256 private constant MINIMUM_VALID_ROUND = 2;\n\n    // #############################################\n    // STATE\n    // #############################################\n    /// @notice Stores the user's pending stake for the round\n    mapping(address => Vault.StakeReceipt) public stakeReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their StakeReceipt.stakeAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice address of the stable wrapper contract\n    address public stableWrapper;\n\n    /// @notice the total supply of shares across all chains\n    uint256 public omniTotalSupply;\n\n    /// @notice Whether the vault allows independence from the stable wrapper\n    bool public allowIndependence;\n\n    // #############################################\n    // EVENTS\n    // #############################################\n    event Stake(address indexed account, uint256 amount, uint256 round);\n\n    event Unstake(address indexed account, uint256 amount, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event RoundRolled(\n        uint256 round,\n        uint256 pricePerShare,\n        uint256 sharesMinted,\n        uint256 wrappedTokensMinted,\n        uint256 wrappedTokensBurned,\n        uint256 yield,\n        bool isYieldPositive\n    );\n\n    event InstantUnstake(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event AllowIndependenceSet(bool allowIndependence);\n\n    // #############################################\n    // ERRORS\n    // #############################################\n    error IndependenceNotAllowed();\n\n    error AmountMustBeGreaterThanZero();\n\n    error AddressMustBeNonZero();\n\n    error CapExceeded();\n\n    error MinimumSupplyNotMet();\n\n    error RoundMismatch();\n\n    error AmountExceedsReceipt();\n\n    error RoundMustBeGreaterThanOne();\n\n    error InsufficientUnredeemedShares();\n\n    error CapMustBeGreaterThanZero();\n\n    // #############################################\n    // CONSTRUCTOR & INITIALIZATION\n    // #############################################\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _tokenName is the token name of the share ERC-20\n     * @param _tokenSymbol is the token symbol of the share ERC-20\n     * @param _stableWrapper is the address of the stable wrapper contract\n     * @param _lzEndpoint is the address of the LayerZero endpoint\n     * @param _delegate is the address of the delegate\n     * @param _vaultParams is the `VaultParams` struct with general vault data\n     */\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stableWrapper,\n        address _lzEndpoint,\n        address _delegate,\n        Vault.VaultParams memory _vaultParams\n    )\n        ReentrancyGuard()\n        OFT(_tokenName, _tokenSymbol, _lzEndpoint, _delegate)\n        Ownable(msg.sender)\n    {\n        if (_vaultParams.cap == 0) revert CapMustBeGreaterThanZero();\n        if (_stableWrapper == address(0)) revert AddressMustBeNonZero();\n\n        stableWrapper = _stableWrapper;\n        vaultParams = _vaultParams;\n        vaultState.round = 1;\n        allowIndependence = false;\n    }\n    // #############################################\n    // Wrapper functions\n    // #############################################\n\n    /**\n     * @notice Deposits assets and stakes them in a single transaction\n     * @param amount Amount of assets to deposit and stake\n     */\n    function depositAndStake(\n        uint104 amount,\n        address creditor\n    ) external nonReentrant {\n        IStableWrapper(stableWrapper).depositToVault(msg.sender, amount);\n\n        // Then stake the wrapped tokens\n        _stakeInternal(amount, creditor);\n    }\n\n    /**\n     * @notice Unstakes tokens and initiates withdrawal in a single transaction\n     * @param numShares Number of shares to unstake\n     */\n    function unstakeAndWithdraw(uint256 numShares) external nonReentrant {\n        // First unstake the tokens\n        uint256 withdrawAmount = _unstake(numShares, stableWrapper);\n\n        // Then initiate withdrawal in the wrapper\n        IStableWrapper(stableWrapper).initiateWithdrawalFromVault(\n            msg.sender,\n            uint224(withdrawAmount)\n        );\n    }\n\n    /**\n     * @notice Performs instant unstake and initiates withdrawal in a single transaction\n     * @param amount Amount to unstake instantly\n     */\n    function instantUnstakeAndWithdraw(uint104 amount) external nonReentrant {\n        // First perform instant unstake\n        _instantUnstake(amount, stableWrapper);\n\n        // Then initiate withdrawal in the wrapper\n        IStableWrapper(stableWrapper).initiateWithdrawalFromVault(\n            msg.sender,\n            uint224(amount)\n        );\n    }\n\n    function bridgeWithRedeem(\n        SendParam calldata sendParam,\n        MessagingFee calldata fee,\n        address payable refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory) {\n        // First redeem any shares if needed\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[msg.sender];\n        if (stakeReceipt.amount > 0 || stakeReceipt.unredeemedShares > 0) {\n            _redeem(0);\n        }\n\n        // Then call the internal _send\n        return _send(sendParam, fee, refundAddress);\n    }\n\n    // #############################################\n    // PUBLIC STAKING\n    // #############################################\n\n    /**\n     * @notice Stakes the `asset` from msg.sender added to `creditor`'s stake.\n     * @notice Used for vault -> vault stakes on the user's behalf\n     * @param amount is the amount of `asset` to stake\n     * @param creditor is the address that can claim/withdraw staked amount\n     * @dev An approve() by the msg.sender is required beforehand\n     */\n    function stake(uint104 amount, address creditor) public nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (creditor == address(0)) revert AddressMustBeNonZero();\n\n        IERC20(stableWrapper).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _stakeInternal(amount, creditor);\n    }\n\n    /**\n     * @notice Manages the stake receipts for a staker\n     * @param amount is the amount of `asset` staked\n     * @param creditor is the address to receieve the stake\n     * @dev This function should be called after the underlying\n     * token has been transferred to the vault\n     */\n    function _stakeInternal(uint104 amount, address creditor) private {\n        uint16 currentRound = vaultState.round;\n        Vault.VaultParams memory _vaultParams = vaultParams;\n        uint256 totalWithStakedAmount = IERC20(stableWrapper).balanceOf(\n            address(this)\n        );\n\n        if (totalWithStakedAmount > _vaultParams.cap) revert CapExceeded();\n        if (totalWithStakedAmount < _vaultParams.minimumSupply)\n            revert MinimumSupplyNotMet();\n\n        emit Stake(creditor, amount, currentRound);\n\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[creditor];\n\n        // If we have an unprocessed pending stake from the previous rounds, we have to process it.\n        uint256 unredeemedShares = stakeReceipt.getSharesFromReceipt(\n            currentRound,\n            roundPricePerShare[stakeReceipt.round],\n            _vaultParams.decimals\n        );\n\n        uint104 stakeAmount = amount;\n\n        // If we have a pending stake in the current round, we add on to the pending stake\n        if (currentRound == stakeReceipt.round) {\n            stakeAmount = stakeAmount + stakeReceipt.amount;\n        }\n\n        stakeReceipts[creditor] = Vault.StakeReceipt({\n            round: currentRound,\n            amount: stakeAmount,\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        vaultState.totalPending = vaultState.totalPending + amount;\n    }\n\n    // #############################################\n    // WITHDRAWALS\n    // #############################################\n\n    /**\n     * @notice External wrapper for instant unstaking\n     * @param amount is the amount to withdraw\n     */\n    function instantUnstake(uint104 amount) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        _instantUnstake(amount, msg.sender);\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `StakeReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function _instantUnstake(uint104 amount, address to) internal {\n        Vault.StakeReceipt storage stakeReceipt = stakeReceipts[msg.sender];\n\n        uint16 currentRound = vaultState.round;\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (stakeReceipt.round != currentRound) revert RoundMismatch();\n\n        uint104 receiptAmount = stakeReceipt.amount;\n        if (receiptAmount < amount) revert AmountExceedsReceipt();\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        stakeReceipt.amount = receiptAmount - amount;\n        vaultState.totalPending = vaultState.totalPending - amount;\n\n        emit InstantUnstake(msg.sender, amount, currentRound);\n\n        _transferAsset(to, amount);\n    }\n\n    /**\n     * @notice External wrapper for unstaking shares\n     * @param numShares is the number of shares to withdraw and burn\n     */\n    function unstake(uint256 numShares) external nonReentrant {\n        if (!allowIndependence) revert IndependenceNotAllowed();\n        _unstake(numShares, msg.sender);\n    }\n\n    /**\n     * @notice Initiates a withdrawal\n     * @param numShares is the number of shares to withdraw and burn\n     */\n    function _unstake(\n        uint256 numShares,\n        address to\n    ) internal returns (uint256) {\n        if (numShares == 0) revert AmountMustBeGreaterThanZero();\n        if (to == address(0)) revert AddressMustBeNonZero();\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        {\n            Vault.StakeReceipt memory stakeReceipt = stakeReceipts[msg.sender];\n            if (stakeReceipt.amount > 0 || stakeReceipt.unredeemedShares > 0) {\n                _redeem(0);\n            }\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        if (currentRound < MINIMUM_VALID_ROUND)\n            revert RoundMustBeGreaterThanOne();\n\n        uint256 withdrawAmount = ShareMath.sharesToAsset(\n            numShares,\n            roundPricePerShare[currentRound - 1],\n            vaultParams.decimals\n        );\n\n        emit Unstake(msg.sender, withdrawAmount, currentRound);\n\n        _burn(msg.sender, numShares);\n\n        omniTotalSupply = omniTotalSupply - numShares;\n\n        IERC20(stableWrapper).safeTransfer(to, withdrawAmount);\n\n        return withdrawAmount;\n    }\n\n    // #############################################\n    // REDEMPTIONS\n    // #############################################\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        if (numShares == 0) revert AmountMustBeGreaterThanZero();\n\n        _redeem(numShares);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem,\n     * if numShares is 0, it will redeem all unredeemed shares\n     */\n    function _redeem(uint256 numShares) internal {\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares = stakeReceipt.getSharesFromReceipt(\n            currentRound,\n            roundPricePerShare[stakeReceipt.round],\n            vaultParams.decimals\n        );\n\n        numShares = numShares == 0 ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        if (numShares > unredeemedShares) revert InsufficientUnredeemedShares();\n\n        // If we have a stakeReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new stakes, we just zero it out for new stakes.\n        if (stakeReceipt.round < currentRound) {\n            stakeReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n        stakeReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares - numShares\n        );\n\n        emit Redeem(msg.sender, numShares, stakeReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    // #############################################\n    // VAULT OPERATIONS\n    // #############################################\n\n    /**\n     * @notice Rolls to the next round, finalizing prev round pricePerShare and minting new shares\n     * @param yield is the amount of assets earnt or lost in the round\n     * @param isYieldPositive is true if the yield is positive, false if it is negative\n     */\n    function rollToNextRound(\n        uint256 yield,\n        bool isYieldPositive\n    ) external onlyOwner nonReentrant {\n        uint256 balance = IERC20(stableWrapper).balanceOf(address(this));\n        uint256 currentBalance;\n        if (isYieldPositive) {\n            currentBalance = balance + yield;\n        } else {\n            currentBalance = balance - yield;\n        }\n\n        Vault.VaultParams memory _vaultParams = vaultParams;\n        if (currentBalance < uint256(_vaultParams.minimumSupply)) {\n            revert MinimumSupplyNotMet();\n        }\n        Vault.VaultState memory state = vaultState;\n        uint256 currentRound = state.round;\n\n        uint256 newPricePerShare = ShareMath.pricePerShare(\n            omniTotalSupply,\n            currentBalance,\n            state.totalPending,\n            _vaultParams.decimals\n        );\n\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        vaultState.totalPending = 0;\n        vaultState.round = uint16(currentRound + 1);\n\n        uint256 mintShares = ShareMath.assetToShares(\n            state.totalPending,\n            newPricePerShare,\n            _vaultParams.decimals\n        );\n\n        _mint(address(this), mintShares);\n\n        omniTotalSupply = omniTotalSupply + mintShares;\n\n        if (currentBalance > balance) {\n            IStableWrapper(stableWrapper).permissionedMint(\n                address(this),\n                currentBalance - balance\n            );\n            emit RoundRolled(\n                currentRound,\n                newPricePerShare,\n                mintShares,\n                currentBalance - balance,\n                0,\n                yield,\n                isYieldPositive\n            );\n        } else if (currentBalance < balance) {\n            IStableWrapper(stableWrapper).permissionedBurn(\n                address(this),\n                balance - currentBalance\n            );\n            emit RoundRolled(\n                currentRound,\n                newPricePerShare,\n                mintShares,\n                0,\n                balance - currentBalance,\n                yield,\n                isYieldPositive\n            );\n        } else {\n            emit RoundRolled(\n                currentRound,\n                newPricePerShare,\n                mintShares,\n                0,\n                0,\n                yield,\n                isYieldPositive\n            );\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function _transferAsset(address recipient, uint256 amount) internal {\n        IERC20(stableWrapper).safeTransfer(recipient, amount);\n    }\n\n    // #############################################\n    // SETTERS\n    // #############################################\n\n    /**\n     * @notice Sets a new stable wrapper contract address\n     * @param newStableWrapper is the address of the new stable wrapper contract\n     */\n    function setStableWrapper(address newStableWrapper) external onlyOwner {\n        if (newStableWrapper == address(0)) revert AddressMustBeNonZero();\n        stableWrapper = newStableWrapper;\n    }\n\n    /**\n     * @notice Allows owner to set allowIndependence\n     * @param _allowIndependence New allowIndependence value\n     */\n    function setAllowIndependence(bool _allowIndependence) public onlyOwner {\n        allowIndependence = _allowIndependence;\n        emit AllowIndependenceSet(_allowIndependence);\n    }\n\n    /**\n     * @notice Sets a new cap for stakes\n     * @param newCap is the new cap for stakes\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        if (newCap == 0) revert CapMustBeGreaterThanZero();\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /**\n     * @notice Sets the new vault parameters\n     */\n    function setVaultParams(\n        Vault.VaultParams memory newVaultParams\n    ) external onlyOwner {\n        if (newVaultParams.cap == 0) revert CapMustBeGreaterThanZero();\n        vaultParams = newVaultParams;\n    }\n\n    // #############################################\n    // GETTERS\n    // #############################################\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account not accounting for current round stakes\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(\n        address account\n    ) public view returns (uint256) {\n        if (vaultState.round < MINIMUM_VALID_ROUND)\n            revert RoundMustBeGreaterThanOne();\n        uint256 _decimals = vaultParams.decimals;\n        uint256 pricePerShare = roundPricePerShare[vaultState.round - 1];\n        return\n            ShareMath.sharesToAsset(shares(account), pricePerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        uint256 heldByAccount = shareBalancesHeldByAccount(account);\n        uint256 heldByVault = shareBalancesHeldByVault(account);\n        return heldByAccount + heldByVault;\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance held by the account\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     */\n    function shareBalancesHeldByAccount(\n        address account\n    ) public view returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance held by the vault\n     * @param account is the account to lookup share balance for\n     * @return heldByVault is the shares held by the vault (unredeemedShares)\n     */\n    function shareBalancesHeldByVault(\n        address account\n    ) public view returns (uint256) {\n        Vault.StakeReceipt memory stakeReceipt = stakeReceipts[account];\n\n        return\n            stakeReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[stakeReceipt.round],\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    /**\n     * @notice Returns the shared token decimals for OFT\n     */\n    function sharedDecimals() public view virtual override returns (uint8) {\n        return decimals();\n    }\n\n    /**\n     * @notice Returns the maximum amount of wrapped tokens\n     * that can be deposited into the vault\n     */\n    function cap() public view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    /**\n     * @notice Returns the total amount of wrapped tokens\n     * for which share issuance is pending\n     */\n    function totalPending() public view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /**\n     * @notice Returns the current round number\n     */\n    function round() public view returns (uint256) {\n        return vaultState.round;\n    }\n\n    // #############################################\n    // OTHER\n    // #############################################\n\n    /**\n     * @notice Rescues ERC20 tokens stuck in the contract\n     * @param _token The address of the token to rescue\n     * @param amount The amount of tokens to rescue\n     * @dev Only callable by owner\n     */\n    function rescueTokens(address _token, uint256 amount) external onlyOwner {\n        if (_token == address(0)) revert AddressMustBeNonZero();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    }
}