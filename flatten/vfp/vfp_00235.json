{
    "vfp_id": "vfp_00235",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "VLFStrategyExecutor cannot execute certain operations",
            "description": "The `execute` functions in `VLFStrategyExecutor` do not have the `payable` modifier, preventing them from receiving native tokens. Since these functions use `functionCallWithValue` to send value to targets, they must be able to forward native tokens. Without the `payable` modifier, any operation requiring value transfer will fail. This limits the functionality of the executor and prevents legitimate strategies that require sending ETH to external contracts, reducing the composability and utility of the system.\n",
            "severity": "Low",
            "location": [
                "VLFStrategyExecutor.sol#L174-L200"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/strategy/VLFStrategyExecutor.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Unsafe approve pattern in VLFStrategyExecutor",
            "description": "The functions returnLiquidity and settleExtraRewards in VLFStrategyExecutor.sol use a direct approve call without first ensuring the allowance is reset to zero. Certain ERC20 tokens, such as those enforcing the \"safe approve\" rule (e.g., USDT), will revert if an approve is called when the current allowance is non-zero. This creates a risk that the approve call may fail unexpectedly, blocking critical functionality like returning liquidity. The root cause is the use of an unsafe approve pattern instead of a forceApprove mechanism that handles allowance resets. An attacker cannot directly exploit this for theft, but could potentially block operations by setting a non-zero allowance, leading to a denial of service for legitimate users. The impact is limited to operational disruption rather than fund loss.\n",
            "severity": "Informational",
            "location": [
                "VLFStrategyExecutor.sol#L138",
                "VLFStrategyExecutor.sol#L168"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/strategy/VLFStrategyExecutor.sol"
            ]
        }
    ],
    "affected_files": {
        "VLFStrategyExecutor.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { IERC20 } from '@oz/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@oz/token/ERC20/utils/SafeERC20.sol';\nimport { Address } from '@oz/utils/Address.sol';\nimport { ReentrancyGuard } from '@oz/utils/ReentrancyGuard.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\n\nimport { IMitosisVault } from '../../interfaces/branch/IMitosisVault.sol';\nimport { IStrategyExecutor } from '../../interfaces/branch/strategy/IStrategyExecutor.sol';\nimport { IVLFStrategyExecutor } from '../../interfaces/branch/strategy/IVLFStrategyExecutor.sol';\nimport { ITally } from '../../interfaces/branch/strategy/tally/ITally.sol';\nimport { StdError } from '../../lib/StdError.sol';\nimport { Versioned } from '../../lib/Versioned.sol';\nimport { VLFStrategyExecutorStorageV1 } from './VLFStrategyExecutorStorageV1.sol';\n\ncontract VLFStrategyExecutor is\n  IStrategyExecutor,\n  IVLFStrategyExecutor,\n  Ownable2StepUpgradeable,\n  ReentrancyGuard,\n  VLFStrategyExecutorStorageV1,\n  Versioned\n{\n  using SafeERC20 for IERC20;\n  using Address for address;\n\n  //=========== NOTE: INITIALIZATION FUNCTIONS ===========//\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    revert StdError.NotSupported();\n  }\n\n  receive() external payable {\n    Address.sendValue(payable(_getStorageV1().strategist), msg.value);\n  }\n\n  function initialize(IMitosisVault vault_, IERC20 asset_, address hubVLFVault_, address owner_) public initializer {\n    __Ownable2Step_init();\n    __Ownable_init(owner_);\n\n    StorageV1 storage $ = _getStorageV1();\n\n    $.vault = vault_;\n    $.asset = asset_;\n    $.hubVLFVault = hubVLFVault_;\n  }\n\n  //=========== NOTE: VIEW FUNCTIONS ===========//\n\n  function vault() external view returns (IMitosisVault) {\n    return _getStorageV1().vault;\n  }\n\n  function asset() external view returns (IERC20) {\n    return _getStorageV1().asset;\n  }\n\n  function hubVLFVault() external view returns (address) {\n    return _getStorageV1().hubVLFVault;\n  }\n\n  function strategist() external view returns (address) {\n    return _getStorageV1().strategist;\n  }\n\n  function executor() external view returns (address) {\n    return _getStorageV1().executor;\n  }\n\n  function tally() external view returns (ITally) {\n    return _getStorageV1().tally;\n  }\n\n  function totalBalance() external view returns (uint256) {\n    return _totalBalance(_getStorageV1());\n  }\n\n  function storedTotalBalance() external view returns (uint256) {\n    return _getStorageV1().storedTotalBalance;\n  }\n\n  function quoteDeallocateLiquidity(uint256 amount) external view returns (uint256) {\n    StorageV1 memory $ = _getStorageV1();\n    return $.vault.quoteDeallocateVLF($.hubVLFVault, amount);\n  }\n\n  function quoteSettleYield(uint256 amount) external view returns (uint256) {\n    StorageV1 memory $ = _getStorageV1();\n    return $.vault.quoteSettleVLFYield($.hubVLFVault, amount);\n  }\n\n  function quoteSettleLoss(uint256 amount) external view returns (uint256) {\n    StorageV1 memory $ = _getStorageV1();\n    return $.vault.quoteSettleVLFLoss($.hubVLFVault, amount);\n  }\n\n  function quoteSettleExtraRewards(address reward, uint256 amount) external view returns (uint256) {\n    StorageV1 memory $ = _getStorageV1();\n    return $.vault.quoteSettleVLFExtraRewards($.hubVLFVault, reward, amount);\n  }\n\n  //=========== NOTE: STRATEGIST FUNCTIONS ===========//\n\n  function deallocateLiquidity(uint256 amount) external payable {\n    require(amount > 0, StdError.ZeroAmount());\n\n    StorageV1 memory $ = _getStorageV1();\n\n    _assertOnlyStrategist($);\n\n    $.vault.deallocateVLF{ value: msg.value }($.hubVLFVault, amount);\n  }\n\n  function fetchLiquidity(uint256 amount) external {\n    require(amount > 0, StdError.ZeroAmount());\n\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyStrategist($);\n\n    $.vault.fetchVLF($.hubVLFVault, amount);\n    $.storedTotalBalance += amount;\n  }\n\n  function returnLiquidity(uint256 amount) external {\n    require(amount > 0, StdError.ZeroAmount());\n\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyStrategist($);\n\n    $.asset.approve(address($.vault), amount);\n    $.vault.returnVLF($.hubVLFVault, amount);\n    $.storedTotalBalance -= amount;\n  }\n\n  function settle() external payable nonReentrant {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyStrategist($);\n\n    uint256 totalBalance_ = _totalBalance($);\n    uint256 storedTotalBalance_ = $.storedTotalBalance;\n\n    $.storedTotalBalance = totalBalance_;\n\n    if (totalBalance_ >= storedTotalBalance_) {\n      $.vault.settleVLFYield{ value: msg.value }($.hubVLFVault, totalBalance_ - storedTotalBalance_);\n    } else {\n      $.vault.settleVLFLoss{ value: msg.value }($.hubVLFVault, storedTotalBalance_ - totalBalance_);\n    }\n  }\n\n  function settleExtraRewards(address reward, uint256 amount) external payable {\n    require(amount > 0, StdError.ZeroAmount());\n\n    StorageV1 memory $ = _getStorageV1();\n\n    _assertOnlyStrategist($);\n    require(reward != address($.asset), StdError.InvalidAddress('reward'));\n\n    IERC20(reward).approve(address($.vault), amount);\n    $.vault.settleVLFExtraRewards{ value: msg.value }($.hubVLFVault, reward, amount);\n  }\n\n  //=========== NOTE: EXECUTOR FUNCTIONS ===========//\n\n  function execute(address target, bytes calldata data, uint256 value)\n    external\n    nonReentrant\n    returns (bytes memory result)\n  {\n    StorageV1 memory $ = _getStorageV1();\n    _assertOnlyExecutor($);\n\n    result = target.functionCallWithValue(data, value);\n  }\n\n  function execute(address[] calldata targets, bytes[] calldata data, uint256[] calldata values)\n    external\n    nonReentrant\n    returns (bytes[] memory results)\n  {\n    require(targets.length == data.length && data.length == values.length, StdError.InvalidParameter('executeData'));\n\n    StorageV1 memory $ = _getStorageV1();\n    _assertOnlyExecutor($);\n\n    uint256 targetsLength = targets.length;\n    results = new bytes[](targetsLength);\n    for (uint256 i; i < targetsLength; ++i) {\n      results[i] = targets[i].functionCallWithValue(data[i], values[i]);\n    }\n  }\n\n  //=========== NOTE: OWNABLE FUNCTIONS ===========//\n\n  function setTally(address implementation) external onlyOwner {\n    require(implementation.code.length > 0, StdError.InvalidAddress('implementation'));\n\n    StorageV1 storage $ = _getStorageV1();\n    require(\n      address($.tally) == address(0) || _tallyTotalBalance($) == 0,\n      IVLFStrategyExecutor.IVLFStrategyExecutor__TallyTotalBalanceNotZero(implementation)\n    );\n\n    $.tally = ITally(implementation);\n    emit TallySet(implementation);\n  }\n\n  function setStrategist(address strategist_) external onlyOwner {\n    require(strategist_ != address(0), StdError.InvalidAddress('strategist'));\n    _getStorageV1().strategist = strategist_;\n    emit StrategistSet(strategist_);\n  }\n\n  function setExecutor(address executor_) external onlyOwner {\n    require(executor_ != address(0), StdError.InvalidAddress('executor'));\n    _getStorageV1().executor = executor_;\n    emit ExecutorSet(executor_);\n  }\n\n  function unsetStrategist() external onlyOwner {\n    _getStorageV1().strategist = address(0);\n    emit StrategistSet(address(0));\n  }\n\n  function unsetExecutor() external onlyOwner {\n    _getStorageV1().executor = address(0);\n    emit ExecutorSet(address(0));\n  }\n\n  //=========== NOTE: INTERNAL FUNCTIONS ===========//\n\n  function _assertOnlyStrategist(StorageV1 memory $) internal view {\n    address strategist_ = $.strategist;\n    require(strategist_ != address(0), IVLFStrategyExecutor.IVLFStrategyExecutor__StrategistNotSet());\n    require(_msgSender() == strategist_, StdError.Unauthorized());\n  }\n\n  function _assertOnlyExecutor(StorageV1 memory $) internal view {\n    address executor_ = $.executor;\n    require(executor_ != address(0), IVLFStrategyExecutor.IVLFStrategyExecutor__ExecutorNotSet());\n    require(_msgSender() == executor_, StdError.Unauthorized());\n  }\n\n  function _tallyTotalBalance(StorageV1 storage $) internal view returns (uint256) {\n    bytes memory context;\n    return\n      $.tally.pendingDepositBalance(context) + $.tally.totalBalance(context) + $.tally.pendingWithdrawBalance(context);\n  }\n\n  function _totalBalance(StorageV1 storage $) internal view returns (uint256) {\n    return $.asset.balanceOf(address(this)) + _tallyTotalBalance($);\n  }\n}\n"
    }
}