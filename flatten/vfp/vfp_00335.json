{
    "vfp_id": "vfp_00335",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 58,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-250"
                ]
            },
            "title": "Excess caller privileges provided in function access control is risky",
            "description": "Multiple functions grant more access than necessary, such as allowing rocketDAOProtocol or other contracts to call functions they don't need to. Examples include RocketDAOSecurityUpgrade, RocketDAOSecurityProposals, and various setters.\nThe root cause is overly permissive access modifiers that violate the principle of least privilege.\nIf trust assumptions change or contracts are repurposed, these excess privileges could be exploited.\nThe impact is increased attack surface and potential privilege escalation in future upgrades, though current risk is low.\n",
            "severity": "Informational",
            "location": [
                "RocketDAONodeTrustedProposals.sol#L100-L124",
                "RocketDAOSecurityProposals.sol#L29",
                "RocketDAOSecurityUpgrade.sol#L27",
                "RocketMegapoolFactory.sol#L61",
                "RocketMegapoolFactory.sol#L81",
                "RocketNetworkRevenues.sol#L92-L96",
                "RocketNodeDeposit.sol#L35-L36",
                "RocketNodeDeposit.sol#L94-L102",
                "RocketNodeManager.sol#L42-L45",
                "RocketNodeManager.sol#L520",
                "RocketMerkleDistributorMainnet.sol#L242-L243",
                "RocketRewardsPool.sol#L33-L34"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedProposals.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAONodeTrustedProposals.sol": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../RocketBase.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedProposalsInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedActionsInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedUpgradeInterface.sol\";\nimport \"../../../interface/dao/node/settings/RocketDAONodeTrustedSettingsInterface.sol\";\nimport \"../../../interface/dao/node/settings/RocketDAONodeTrustedSettingsProposalsInterface.sol\";\nimport \"../../../interface/dao/RocketDAOProposalInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n// The Trusted Node DAO Proposals \ncontract RocketDAONodeTrustedProposals is RocketBase, RocketDAONodeTrustedProposalsInterface {  \n\n    using SafeMath for uint;\n\n    // The namespace for any data stored in the trusted node DAO (do not change)\n    string constant daoNameSpace = \"dao.trustednodes.\";\n\n    // Only allow certain contracts to execute methods\n    modifier onlyExecutingContracts() {\n        // Methods are either executed by bootstrapping methods in rocketDAONodeTrusted or by people executing passed proposals in rocketDAOProposal\n        require(msg.sender == getContractAddress(\"rocketDAONodeTrusted\") || msg.sender == getContractAddress(\"rocketDAOProposal\"), \"Sender is not permitted to access executing methods\");\n        _;\n    }\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Version\n        version = 1;\n    }\n\n        \n    /*** Proposals **********************/\n\n    // Create a DAO proposal with calldata, if successful will be added to a queue where it can be executed\n    // A general message can be passed by the proposer along with the calldata payload that can be executed if the proposal passes\n    function propose(string memory _proposalMessage, bytes memory _payload) override external onlyTrustedNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedProposals\", address(this)) returns (uint256) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        RocketDAONodeTrustedInterface daoNodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAONodeTrustedSettingsProposalsInterface rocketDAONodeTrustedSettingsProposals = RocketDAONodeTrustedSettingsProposalsInterface(getContractAddress(\"rocketDAONodeTrustedSettingsProposals\"));\n        // Check this user can make a proposal now\n        require(daoNodeTrusted.getMemberLastProposalTime(msg.sender).add(rocketDAONodeTrustedSettingsProposals.getCooldownTime()) <= block.timestamp, \"Member has not waited long enough to make another proposal\");\n        // Require the min amount of members are in to make a proposal\n        require(daoNodeTrusted.getMemberCount() >= daoNodeTrusted.getMemberMinRequired(), \"Min member count not met to allow proposals to be added\");\n        // Record the last time this user made a proposal\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.proposal.lasttime\", msg.sender)), block.timestamp);\n        // Create the proposal\n        return daoProposal.add(msg.sender, \"rocketDAONodeTrustedProposals\", _proposalMessage, block.timestamp.add(rocketDAONodeTrustedSettingsProposals.getVoteDelayTime()), rocketDAONodeTrustedSettingsProposals.getVoteTime(), rocketDAONodeTrustedSettingsProposals.getExecuteTime(), daoNodeTrusted.getMemberQuorumVotesRequired(), _payload);\n    }\n\n    // Vote on a proposal\n    function vote(uint256 _proposalID, bool _support) override external onlyTrustedNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedProposals\", address(this)) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        RocketDAONodeTrustedInterface daoNodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        // Did they join after this proposal was created? If so, they can't vote or it'll throw off the set proposalVotesRequired \n        require(daoNodeTrusted.getMemberJoinedTime(msg.sender) < daoProposal.getCreated(_proposalID), \"Member cannot vote on proposal created before they became a member\");\n        // Vote now, one vote per trusted node member\n        daoProposal.vote(msg.sender, 1 ether, _proposalID, _support);\n    }\n    \n    // Cancel a proposal \n    function cancel(uint256 _proposalID) override external onlyTrustedNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedProposals\", address(this)) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        // Cancel now, will succeed if it is the original proposer\n        daoProposal.cancel(msg.sender, _proposalID);\n    }\n\n    // Execute a proposal \n    function execute(uint256 _proposalID) override external onlyLatestContract(\"rocketDAONodeTrustedProposals\", address(this)) {\n        // Load contracts\n        RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress(\"rocketDAOProposal\"));\n        // Execute now\n        daoProposal.execute(_proposalID);\n    }\n\n\n\n    /*** Proposal - Members **********************/\n\n    // A new DAO member being invited, can only be done via a proposal or in bootstrap mode\n    // Provide an ID that indicates who is running the trusted node and the address of the registered node that they wish to propose joining the dao\n    function proposalInvite(string memory _id, string memory _url, address _nodeAddress) override external onlyExecutingContracts onlyRegisteredNode(_nodeAddress) {\n        // Their proposal executed, record the block\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.executed.time\", \"invited\", _nodeAddress)), block.timestamp);\n        // Ok all good, lets get their invitation and member data setup\n        // They are initially only invited to join, so their membership isn't set as true until they accept it in RocketDAONodeTrustedActions\n        _memberInit(_id, _url, _nodeAddress);\n    }\n\n\n    // A current member proposes leaving the trusted node DAO, when successful they will be allowed to collect their RPL bond\n    function proposalLeave(address _nodeAddress) override external onlyExecutingContracts onlyTrustedNode(_nodeAddress) {\n        // Load contracts\n        RocketDAONodeTrustedInterface daoNodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        // Check this wouldn't dip below the min required trusted nodes (also checked when the node has a successful proposal and attempts to exit)\n        require(daoNodeTrusted.getMemberCount() > daoNodeTrusted.getMemberMinRequired(), \"Member count will fall below min required\");\n        // Their proposal to leave has been accepted, record the block\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.executed.time\", \"leave\", _nodeAddress)), block.timestamp);\n    }\n\n\n    // Propose to kick a current member from the DAO with an optional RPL bond fine\n    function proposalKick(address _nodeAddress, uint256 _rplFine) override external onlyExecutingContracts onlyTrustedNode(_nodeAddress) {\n        // Load contracts\n        RocketDAONodeTrustedInterface daoNodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAONodeTrustedActionsInterface daoActionsContract = RocketDAONodeTrustedActionsInterface(getContractAddress(\"rocketDAONodeTrustedActions\"));\n        // How much is their RPL bond?\n        uint256 rplBondAmount = daoNodeTrusted.getMemberRPLBondAmount(_nodeAddress);\n        // Check fine amount can be covered\n        require(_rplFine <= rplBondAmount, \"RPL Fine must be lower or equal to the RPL bond amount of the node being kicked\");\n        // Set their bond amount minus the fine\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.bond.rpl\", _nodeAddress)), rplBondAmount.sub(_rplFine));\n        // Kick them now\n        daoActionsContract.actionKick(_nodeAddress, _rplFine);\n    }\n\n\n    /*** Proposal - Settings ***************/\n\n    // Change one of the current uint256 settings of the DAO\n    function proposalSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) override external onlyExecutingContracts() {\n        // Load contracts\n        RocketDAONodeTrustedSettingsInterface rocketDAONodeTrustedSettings = RocketDAONodeTrustedSettingsInterface(getContractAddress(_settingContractName));\n        // Lets update\n        rocketDAONodeTrustedSettings.setSettingUint(_settingPath, _value);\n    }\n\n    // Change one of the current bool settings of the DAO\n    function proposalSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) override external onlyExecutingContracts() {\n        // Load contracts\n        RocketDAONodeTrustedSettingsInterface rocketDAONodeTrustedSettings = RocketDAONodeTrustedSettingsInterface(getContractAddress(_settingContractName));\n        // Lets update\n        rocketDAONodeTrustedSettings.setSettingBool(_settingPath, _value);\n    }\n\n\n    /*** Proposal - Upgrades ***************/\n\n    // Upgrade contracts or ABI's if the DAO agrees\n    function proposalUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) override external onlyExecutingContracts() {\n        // Load contracts\n        RocketDAONodeTrustedUpgradeInterface rocketDAONodeTrustedUpgradeInterface = RocketDAONodeTrustedUpgradeInterface(getContractAddress(\"rocketDAONodeTrustedUpgrade\"));\n        // Lets update\n        rocketDAONodeTrustedUpgradeInterface.upgrade(_type, _name, _contractAbi, _contractAddress);\n    }\n\n\n    /*** Internal ***************/\n\n    // Add a new potential members data, they are not official members yet, just propsective\n    function _memberInit(string memory _id, string memory _url, address _nodeAddress) private onlyRegisteredNode(_nodeAddress) {\n        // Load contracts\n        RocketDAONodeTrustedInterface daoNodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        // Check current node status\n        require(!daoNodeTrusted.getMemberIsValid(_nodeAddress), \"This node is already part of the trusted node DAO\");\n        // Verify the ID is min 3 chars\n        require(bytes(_id).length >= 3, \"The ID for this new member must be at least 3 characters\");\n        // Check URL length\n        require(bytes(_url).length >= 6, \"The URL for this new member must be at least 6 characters\");\n        // Member initial data, not official until the bool is flagged as true\n        setBool(keccak256(abi.encodePacked(daoNameSpace, \"member\", _nodeAddress)), false);\n        setAddress(keccak256(abi.encodePacked(daoNameSpace, \"member.address\", _nodeAddress)), _nodeAddress);\n        setString(keccak256(abi.encodePacked(daoNameSpace, \"member.id\", _nodeAddress)), _id);\n        setString(keccak256(abi.encodePacked(daoNameSpace, \"member.url\", _nodeAddress)), _url);\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.bond.rpl\", _nodeAddress)), 0);\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.joined.time\", _nodeAddress)), 0);\n    }\n        \n\n}\n"
    }
}