{
    "vfp_id": "vfp_00121",
    "project_name": "cantina_euler_swap_april2025.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Fee collection in FundsLib.depositAssets() reverts when the protocol fee recipient is the zero address",
            "description": "The depositAssets function in FundsLib attempts to transfer fees to the protocol fee recipient without checking if it is the zero address. If the recipient is address(0) and the fee amount is non-zero, the transfer will revert for most ERC-20 tokens (e.g., OpenZeppelin's ERC20). The root cause is the absence of a zero-address check. An attacker could set the fee recipient to zero, causing all future swaps to revert, resulting in a denial of service. The impact is low as it does not lead to fund loss but disrupts protocol functionality.\n",
            "severity": "Low",
            "location": [
                "FundsLib.sol#L78-L86"
            ],
            "files": [
                "euler-swap/src/libraries/FundsLib.sol"
            ]
        }
    ],
    "affected_files": {
        "FundsLib.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IAllowanceTransfer} from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\n\nimport {IEVC} from \"evc/interfaces/IEthereumVaultConnector.sol\";\nimport {IEVault, IBorrowing, IERC4626, IRiskManager} from \"evk/EVault/IEVault.sol\";\nimport {Errors as EVKErrors} from \"evk/EVault/shared/Errors.sol\";\n\nimport {IEulerSwap} from \"../interfaces/IEulerSwap.sol\";\n\nlibrary FundsLib {\n    using SafeERC20 for IERC20;\n\n    error DepositFailure(bytes reason);\n\n    /// @notice Approves tokens for a given vault, supporting both standard approvals and permit2\n    /// @param vault The address of the vault to approve the token for\n    function approveVault(address vault) internal {\n        address asset = IEVault(vault).asset();\n        address permit2 = IEVault(vault).permit2Address();\n        if (permit2 == address(0)) {\n            IERC20(asset).forceApprove(vault, type(uint256).max);\n        } else {\n            IERC20(asset).forceApprove(permit2, type(uint256).max);\n            IAllowanceTransfer(permit2).approve(asset, vault, type(uint160).max, type(uint48).max);\n        }\n    }\n\n    /// @notice Withdraws assets from a vault, first using available balance and then borrowing if needed\n    /// @param evc EVC instance\n    /// @param p EulerSwap parameters\n    /// @param vault The address of the vault to withdraw from\n    /// @param amount The total amount of assets to withdraw\n    /// @param to The address that will receive the withdrawn assets\n    /// @dev This function first checks if there's an existing balance in the vault.\n    /// @dev If there is, it withdraws the minimum of the requested amount and available balance.\n    /// @dev If more assets are needed after withdrawal, it enables the controller and borrows the remaining amount.\n    function withdrawAssets(address evc, IEulerSwap.Params memory p, address vault, uint256 amount, address to)\n        internal\n    {\n        uint256 balance;\n        {\n            uint256 shares = IEVault(vault).balanceOf(p.eulerAccount);\n            balance = shares == 0 ? 0 : IEVault(vault).convertToAssets(shares);\n        }\n\n        if (balance > 0) {\n            uint256 avail = amount < balance ? amount : balance;\n            IEVC(evc).call(vault, p.eulerAccount, 0, abi.encodeCall(IERC4626.withdraw, (avail, to, p.eulerAccount)));\n            amount -= avail;\n        }\n\n        if (amount > 0) {\n            IEVC(evc).enableController(p.eulerAccount, vault);\n            IEVC(evc).call(vault, p.eulerAccount, 0, abi.encodeCall(IBorrowing.borrow, (amount, to)));\n        }\n    }\n\n    /// @notice Deposits assets into a vault and automatically repays any outstanding debt\n    /// @param evc EVC instance\n    /// @param p EulerSwap parameters\n    /// @param vault The address of the vault to deposit into\n    /// @return The amount of assets successfully deposited\n    /// @dev This function attempts to deposit assets into the specified vault.\n    /// @dev If the deposit fails with E_ZeroShares error, it safely returns 0 (this happens with very small amounts).\n    /// @dev After successful deposit, if the user has any outstanding controller-enabled debt, it attempts to repay it.\n    /// @dev If all debt is repaid, the controller is automatically disabled to reduce gas costs in future operations.\n    function depositAssets(address evc, IEulerSwap.Params memory p, address vault) internal returns (uint256) {\n        address asset = IEVault(vault).asset();\n\n        uint256 amount = IERC20(asset).balanceOf(address(this));\n        if (amount == 0) return 0;\n\n        uint256 feeAmount = amount * p.fee / 1e18;\n\n        {\n            uint256 protocolFeeAmount = feeAmount * p.protocolFee / 1e18;\n\n            if (protocolFeeAmount != 0) {\n                IERC20(asset).transfer(p.protocolFeeRecipient, protocolFeeAmount);\n                amount -= protocolFeeAmount;\n                feeAmount -= protocolFeeAmount;\n            }\n        }\n\n        uint256 deposited;\n\n        if (IEVC(evc).isControllerEnabled(p.eulerAccount, vault)) {\n            uint256 debt = IEVault(vault).debtOf(p.eulerAccount);\n            uint256 repaid = IEVault(vault).repay(amount > debt ? debt : amount, p.eulerAccount);\n\n            amount -= repaid;\n            debt -= repaid;\n            deposited += repaid;\n\n            if (debt == 0) {\n                IEVC(evc).call(vault, p.eulerAccount, 0, abi.encodeCall(IRiskManager.disableController, ()));\n            }\n        }\n\n        if (amount > 0) {\n            try IEVault(vault).deposit(amount, p.eulerAccount) {}\n            catch (bytes memory reason) {\n                require(bytes4(reason) == EVKErrors.E_ZeroShares.selector, DepositFailure(reason));\n                amount = 0;\n            }\n\n            deposited += amount;\n        }\n\n        return deposited > feeAmount ? deposited - feeAmount : 0;\n    }\n}\n"
    }
}