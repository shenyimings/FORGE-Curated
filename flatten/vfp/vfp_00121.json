{
    "vfp_id": "vfp_00121",
    "project_name": "cantina_coinbase_nov2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect NatSpec Comment for Signature Expiration Boundary Condition",
            "description": "1. **Description:** The NatSpec comment for the `SignatureExpired` error incorrectly states that it is thrown when the signature expiry date is greater than or equal to the current block timestamp, while the actual condition only reverts when `expires < block.timestamp`.\n2. **Cause:** The documentation (NatSpec) does not match the implementation logic, creating a discrepancy between expected and actual behavior at the boundary condition where `expires == block.timestamp`.\n3. **Exploitation:** Developers or integrators relying on the incorrect comment might assume signatures are invalid at equality, leading to incorrect assumptions in client-side logic or security reviews.\n4. **Impact:** Misleading documentation can result in integration errors, flawed security analyses, or incorrect handling of signature validity at the exact expiration moment, undermining trust in the codebase.\n",
            "severity": "Informational",
            "location": [
                "SybilResistanceVerifier.sol#L19"
            ],
            "files": [
                "basenames/src/lib/SybilResistanceVerifier.sol"
            ]
        }
    ],
    "affected_files": {
        "SybilResistanceVerifier.sol": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\n\n/// @title Sybil Resistance Verifier\n///\n/// @notice A library for validating signed verifications from the Coinbase Sybil Resistance service.\n///\n/// @author Coinbase (https://github.com/base-org/usernames)\nlibrary SybilResistanceVerifier {\n    /// @notice Thrown when the address for the claimer recovered from `validationData` does not match the address passed\n    ///         to the validator.\n    ///\n    /// @param expectedClaimer The address packed in `validationData` as the expected claimer.\n    /// @param claimer The address that is calling the discounted registration.\n    error ClaimerAddressMismatch(address expectedClaimer, address claimer);\n\n    /// @notice Thrown when the signature expiry date < block.timestamp.\n    error SignatureExpired();\n\n    /// @notice  Generates a hash for signing/verifying.\n    ///\n    /// @dev The message hash should be dervied by: `keccak256(abi.encode(0x1900, trustedSignerAddress, discountClaimerAddress, expiry))`.\n    ///     Compliant with EIP-191 for `Data for intended validator`: https://eips.ethereum.org/EIPS/eip-191#version-0x00 .\n    ///\n    /// @param target The address of the on-chain signature verifier.\n    /// @param claimer The address of the claimer.\n    /// @param expires The date of signature expiry.\n    function _makeSignatureHash(address target, address signer, address claimer, uint64 expires)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(hex\"1900\", target, signer, claimer, expires));\n    }\n\n    /// @notice Verifies that the signature provided matches the expected signer.\n    ///\n    /// @param signer The address of the expected signer.\n    /// @param claimer The address of the address being verified by the sybil resistance service.\n    /// @param validationData Encoded bytes containing: `abi.encode(discountClaimerAddress, expiry, signature_bytes)`\n    function verifySignature(address signer, address claimer, bytes calldata validationData)\n        internal\n        view\n        returns (bool)\n    {\n        (address expectedClaimer, uint64 expires, bytes memory sig) =\n            abi.decode(validationData, (address, uint64, bytes));\n\n        if (expectedClaimer != claimer) revert ClaimerAddressMismatch(expectedClaimer, claimer);\n        if (expires < block.timestamp) revert SignatureExpired();\n        address recoveredSigner = ECDSA.recover(_makeSignatureHash(address(this), signer, claimer, expires), sig);\n        return (recoveredSigner == signer);\n    }\n}\n"
    }
}