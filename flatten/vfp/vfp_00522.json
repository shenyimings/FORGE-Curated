{
    "vfp_id": "vfp_00522",
    "project_name": "Mitosis (May) - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "Uninitialized return value in addStage function",
            "description": "The addStage function in MerkleRewardDistributor.sol declares a named return variable merkleStage of type uint256 but does not assign it any value before returning. In Solidity, unassigned named return variables default to their zero value, so merkleStage will always return 0 regardless of the function's logic. The root cause is a coding oversight where the developer intended to return a meaningful stage identifier but forgot to assign it. An attacker cannot directly exploit this for financial gain, but external callers relying on the return value for state tracking may be misled into thinking the stage ID is 0, potentially causing incorrect downstream behavior. The impact is limited to confusion and incorrect assumptions by integrators, with no direct security risk.\n",
            "severity": "Informational",
            "location": [
                "protocol/src/hub/reward/MerkleRewardDistributor.sol::addStage"
            ],
            "files": [
                "f18b1965c3d5816e422edb206efe598f0fb39899/protocol/src/hub/reward/MerkleRewardDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "MerkleRewardDistributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { IERC20 } from '@oz/interfaces/IERC20.sol';\nimport { SafeERC20 } from '@oz/token/ERC20/utils/SafeERC20.sol';\nimport { MerkleProof } from '@oz/utils/cryptography/MerkleProof.sol';\nimport { AccessControlEnumerableUpgradeable } from '@ozu/access/extensions/AccessControlEnumerableUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { IMerkleRewardDistributor } from '../../interfaces/hub/reward/IMerkleRewardDistributor.sol';\nimport { ITreasury } from '../../interfaces/hub/reward/ITreasury.sol';\nimport { StdError } from '../../lib/StdError.sol';\nimport { MerkleRewardDistributorStorageV1 } from './MerkleRewardDistributorStorageV1.sol';\n\ncontract MerkleRewardDistributor is\n  IMerkleRewardDistributor,\n  AccessControlEnumerableUpgradeable,\n  UUPSUpgradeable,\n  MerkleRewardDistributorStorageV1\n{\n  using SafeERC20 for IERC20;\n  using MerkleProof for bytes32[];\n\n  /// @notice Role for manager (keccak256(\"MANAGER_ROLE\"))\n  bytes32 public constant MANAGER_ROLE = 0x241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08;\n\n  /// @notice Maximum number of rewards that can be claimed in a single call.\n  uint256 public constant MAX_CLAIM_VAULT_SIZE = 100;\n\n  /// @notice Maximum number of batch claims that can be made in a single call.\n  uint256 public constant MAX_CLAIM_STAGES_SIZE = 10;\n\n  //=========== NOTE: INITIALIZATION FUNCTIONS ===========//\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address admin, address treasury_) public initializer {\n    require(admin != address(0), StdError.ZeroAddress('admin'));\n\n    __AccessControlEnumerable_init();\n    __UUPSUpgradeable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _setRoleAdmin(MANAGER_ROLE, DEFAULT_ADMIN_ROLE);\n\n    _setTreasury(_getStorageV1(), treasury_);\n  }\n\n  // ============================ NOTE: VIEW FUNCTIONS ============================ //\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function lastStage() external view returns (uint256) {\n    return _getStorageV1().lastStage;\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function root(uint256 stage_) external view returns (bytes32) {\n    return _stage(_getStorageV1(), stage_).root;\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function rewardInfo(uint256 stage_) external view returns (address[] memory, uint256[] memory) {\n    Stage storage s = _stage(_getStorageV1(), stage_);\n    return (s.rewards, s.amounts);\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function treasury() external view returns (ITreasury) {\n    return _getStorageV1().treasury;\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function encodeLeaf(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external pure returns (bytes32 leaf) {\n    return _leaf(receiver, stage, vault, rewards, amounts);\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claimable(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) external view returns (bool) {\n    return _claimable(receiver, stage, vault, rewards, amounts, proof);\n  }\n\n  // ============================ NOTE: MUTATIVE FUNCTIONS ============================ //\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claim(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) public {\n    _claim(receiver, stage, vault, rewards, amounts, proof);\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claimMultiple(\n    address receiver,\n    uint256 stage,\n    address[] calldata vaults,\n    address[][] calldata rewards,\n    uint256[][] calldata amounts,\n    bytes32[][] calldata proofs\n  ) public {\n    require(vaults.length == rewards.length, StdError.InvalidParameter('rewards.length'));\n    require(vaults.length == amounts.length, StdError.InvalidParameter('amounts.length'));\n    require(vaults.length == proofs.length, StdError.InvalidParameter('proofs.length'));\n    require(vaults.length <= MAX_CLAIM_VAULT_SIZE, StdError.InvalidParameter('vaults.length'));\n\n    for (uint256 i = 0; i < vaults.length; i++) {\n      claim(receiver, stage, vaults[i], rewards[i], amounts[i], proofs[i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IMerkleRewardDistributor\n   */\n  function claimBatch(\n    address receiver,\n    uint256[] calldata stages,\n    address[][] calldata vaults,\n    address[][][] calldata rewards,\n    uint256[][][] calldata amounts,\n    bytes32[][][] calldata proofs\n  ) public {\n    require(stages.length == vaults.length, StdError.InvalidParameter('vaults.length'));\n    require(stages.length == rewards.length, StdError.InvalidParameter('rewards.length'));\n    require(stages.length == amounts.length, StdError.InvalidParameter('amounts.length'));\n    require(stages.length == proofs.length, StdError.InvalidParameter('proofs.length'));\n    require(stages.length <= MAX_CLAIM_STAGES_SIZE, StdError.InvalidParameter('stages.length'));\n\n    for (uint256 i = 0; i < stages.length; i++) {\n      claimMultiple(receiver, stages[i], vaults[i], rewards[i], amounts[i], proofs[i]);\n    }\n  }\n\n  // ============================ NOTE: ADMIN FUNCTIONS ============================ //\n\n  function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }\n\n  // ============================ NOTE: MANAGER FUNCTIONS ============================ //\n\n  function fetchRewards(uint256 stage, uint256 nonce, address vault, address reward, uint256 amount)\n    external\n    onlyRole(MANAGER_ROLE)\n  {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(stage == $.lastStage, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == _stage($, stage).nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n\n    _fetchRewards($, stage, vault, reward, amount);\n  }\n\n  function fetchRewardsMultiple(\n    uint256 stage,\n    uint256 nonce,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external onlyRole(MANAGER_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(stage == $.lastStage, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == _stage($, stage).nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n\n    for (uint256 i = 0; i < rewards.length; i++) {\n      _fetchRewards($, stage, vault, rewards[i], amounts[i]);\n    }\n  }\n\n  function fetchRewardsBatch(\n    uint256 stage,\n    uint256 nonce,\n    address[] calldata vaults,\n    address[][] calldata rewards,\n    uint256[][] calldata amounts\n  ) external onlyRole(MANAGER_ROLE) {\n    StorageV1 storage $ = _getStorageV1();\n\n    require(stage == $.lastStage, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == _stage($, stage).nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n    require(vaults.length == rewards.length, StdError.InvalidParameter('rewards.length'));\n\n    for (uint256 i = 0; i < vaults.length; i++) {\n      for (uint256 j = 0; j < rewards[i].length; j++) {\n        _fetchRewards($, stage, vaults[i], rewards[i][j], amounts[i][j]);\n      }\n    }\n  }\n\n  function addStage(\n    bytes32 merkleRoot,\n    uint256 stage,\n    uint256 nonce,\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external onlyRole(MANAGER_ROLE) returns (uint256 merkleStage) {\n    StorageV1 storage $ = _getStorageV1();\n    Stage storage s = _stage($, stage);\n\n    require(stage == $.lastStage, IMerkleRewardDistributor__NotCurrentStage(stage));\n    require(nonce == s.nonce, IMerkleRewardDistributor__InvalidStageNonce(stage, nonce));\n    require(rewards.length == amounts.length, StdError.InvalidParameter('amounts.length'));\n\n    for (uint256 i = 0; i < rewards.length; i++) {\n      address reward = rewards[i];\n      uint256 amount = amounts[i];\n      require(_availableRewardAmount($, reward) >= amount, IMerkleRewardDistributor__InvalidAmount());\n      $.reservedRewardAmounts[reward] += amount;\n    }\n\n    _addStage($, merkleRoot, rewards, amounts);\n\n    return merkleStage;\n  }\n\n  // ============================ NOTE: INTERNAL FUNCTIONS ============================ //\n\n  function _setTreasury(StorageV1 storage $, address treasury_) internal {\n    require(treasury_.code.length > 0, StdError.InvalidAddress('treasury'));\n\n    ITreasury oldTreasury = $.treasury;\n    $.treasury = ITreasury(treasury_);\n\n    emit TreasuryUpdated(address(oldTreasury), treasury_);\n  }\n\n  function _fetchRewards(StorageV1 storage $, uint256 stage, address vault, address reward, uint256 amount) internal {\n    Stage storage s = _stage($, stage);\n    uint256 nonce = s.nonce++;\n\n    $.treasury.dispatch(vault, reward, amount, address(this));\n\n    emit RewardsFetched(stage, nonce, vault, reward, amount);\n  }\n\n  function _addStage(StorageV1 storage $, bytes32 root_, address[] calldata rewards, uint256[] calldata amounts)\n    internal\n    onlyRole(MANAGER_ROLE)\n    returns (uint256 stage)\n  {\n    $.lastStage += 1;\n    Stage storage s = _stage($, $.lastStage);\n    s.root = root_;\n    s.rewards = rewards;\n    s.amounts = amounts;\n\n    emit StageAdded($.lastStage, root_, rewards, amounts);\n\n    return $.lastStage;\n  }\n\n  function _stage(StorageV1 storage $, uint256 stage) internal view returns (Stage storage) {\n    return $.stages[stage];\n  }\n\n  function _claimable(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) internal view returns (bool) {\n    StorageV1 storage $ = _getStorageV1();\n    Stage storage s = _stage($, stage);\n\n    bytes32 leaf = _leaf(receiver, stage, vault, rewards, amounts);\n\n    return !s.claimed[receiver][vault] && proof.verify(s.root, leaf);\n  }\n\n  function _claim(\n    address receiver,\n    uint256 stage,\n    address vault,\n    address[] calldata rewards,\n    uint256[] calldata amounts,\n    bytes32[] calldata proof\n  ) internal {\n    StorageV1 storage $ = _getStorageV1();\n    Stage storage s = _stage($, stage);\n    require(!s.claimed[receiver][vault], IMerkleRewardDistributor__AlreadyClaimed());\n\n    uint256 rewardsLen = rewards.length;\n    bytes32 leaf = _leaf(receiver, stage, vault, rewards, amounts);\n    require(proof.verify(s.root, leaf), IMerkleRewardDistributor__InvalidProof());\n    require(rewardsLen == amounts.length, StdError.InvalidParameter('amounts.length'));\n\n    s.claimed[receiver][vault] = true;\n    for (uint256 i = 0; i < rewardsLen; i++) {\n      $.reservedRewardAmounts[rewards[i]] -= amounts[i];\n    }\n\n    for (uint256 i = 0; i < rewardsLen; i++) {\n      IERC20(rewards[i]).safeTransfer(receiver, amounts[i]);\n    }\n\n    emit Claimed(receiver, stage, vault, rewards, amounts);\n  }\n\n  function _availableRewardAmount(StorageV1 storage $, address reward) internal view returns (uint256) {\n    return IERC20(reward).balanceOf(address(this)) - $.reservedRewardAmounts[reward];\n  }\n\n  function _leaf(address receiver, uint256 stage, address vault, address[] calldata rewards, uint256[] calldata amounts)\n    internal\n    pure\n    returns (bytes32 leaf)\n  {\n    // double-hashing to prevent second preimage attacks:\n    // https://flawed.net.nz/2018/02/21/attacking-merkle-trees-with-a-second-preimage-attack/\n    return keccak256(bytes.concat(keccak256(abi.encodePacked(receiver, stage, vault, rewards, amounts))));\n  }\n}\n"
    }
}