{
    "vfp_id": "vfp_00492",
    "project_name": "cantina_centrifuge_aug2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Reentrancy protection mechanism in _protected() is ineffective",
            "description": "The Hub contract uses an internal _protected() function intended to prevent reentrancy, but the implementation is flawed because the protected modifier is not directly applied to the function. Instead, _protected() is called internally, which does not enforce the modifier's logic as intended. The modifier relies on a transient _initiator variable to track the initial caller, but when _protected() is called as an internal function, the modifier's checks are bypassed. This allows reentrancy in functions like notifyDeposit() and notifyRedeem(), which depend on this protection. An attacker could exploit this during deposit or redemption callbacks to re-enter critical functions, potentially manipulating state or causing double-processing of transactions, leading to inconsistent accounting or fund loss.\n",
            "severity": null,
            "location": [
                "Hub::_protected",
                "Hub::notifyDeposit",
                "Hub::notifyRedeem"
            ],
            "files": [
                "protocol-v3/src/hub/Hub.sol"
            ]
        }
    ],
    "affected_files": {
        "Hub.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IHoldings} from \"./interfaces/IHoldings.sol\";\nimport {IHubHelpers} from \"./interfaces/IHubHelpers.sol\";\nimport {IHubRegistry} from \"./interfaces/IHubRegistry.sol\";\nimport {IHub, VaultUpdateKind} from \"./interfaces/IHub.sol\";\nimport {IAccounting, JournalEntry} from \"./interfaces/IAccounting.sol\";\nimport {IShareClassManager} from \"./interfaces/IShareClassManager.sol\";\n\nimport {Auth} from \"../misc/Auth.sol\";\nimport {D18} from \"../misc/types/D18.sol\";\nimport {Recoverable} from \"../misc/Recoverable.sol\";\nimport {MathLib} from \"../misc/libraries/MathLib.sol\";\nimport {Multicall, IMulticall} from \"../misc/Multicall.sol\";\n\nimport {PoolId} from \"../common/types/PoolId.sol\";\nimport {AssetId} from \"../common/types/AssetId.sol\";\nimport {AccountId} from \"../common/types/AccountId.sol\";\nimport {IGateway} from \"../common/interfaces/IGateway.sol\";\nimport {ShareClassId} from \"../common/types/ShareClassId.sol\";\nimport {IValuation} from \"../common/interfaces/IValuation.sol\";\nimport {ISnapshotHook} from \"../common/interfaces/ISnapshotHook.sol\";\nimport {IHubMessageSender} from \"../common/interfaces/IGatewaySenders.sol\";\nimport {IHubGatewayHandler} from \"../common/interfaces/IGatewayHandlers.sol\";\nimport {IHubGuardianActions} from \"../common/interfaces/IGuardianActions.sol\";\nimport {RequestCallbackMessageLib} from \"../common/libraries/RequestCallbackMessageLib.sol\";\nimport {IPoolEscrow, IPoolEscrowFactory} from \"../common/factories/interfaces/IPoolEscrowFactory.sol\";\n\n/// @title  Hub\n/// @notice Central pool management contract, that brings together all functions in one place.\n///         Pools can assign hub managers which have full rights over all actions.\n///\n///         Also acts as the central contract that routes messages from other chains to the Hub contracts.\ncontract Hub is Multicall, Auth, Recoverable, IHub, IHubGatewayHandler, IHubGuardianActions {\n    using MathLib for uint256;\n    using RequestCallbackMessageLib for *;\n\n    IGateway public gateway;\n    IHoldings public holdings;\n    IHubHelpers public hubHelpers;\n    IAccounting public accounting;\n    IHubRegistry public hubRegistry;\n    IHubMessageSender public sender;\n    IShareClassManager public shareClassManager;\n    IPoolEscrowFactory public poolEscrowFactory;\n\n    constructor(\n        IGateway gateway_,\n        IHoldings holdings_,\n        IHubHelpers hubHelpers_,\n        IAccounting accounting_,\n        IHubRegistry hubRegistry_,\n        IShareClassManager shareClassManager_,\n        address deployer\n    ) Auth(deployer) {\n        gateway = gateway_;\n        holdings = holdings_;\n        hubHelpers = hubHelpers_;\n        accounting = accounting_;\n        hubRegistry = hubRegistry_;\n        shareClassManager = shareClassManager_;\n    }\n\n    modifier payTransaction() {\n        _startTransactionPayment();\n        _;\n        _endTransactionPayment();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // System methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function file(bytes32 what, address data) external {\n        _auth();\n\n        if (what == \"sender\") sender = IHubMessageSender(data);\n        else if (what == \"holdings\") holdings = IHoldings(data);\n        else if (what == \"hubHelpers\") hubHelpers = IHubHelpers(data);\n        else if (what == \"shareClassManager\") shareClassManager = IShareClassManager(data);\n        else if (what == \"gateway\") gateway = IGateway(data);\n        else if (what == \"poolEscrowFactory\") poolEscrowFactory = IPoolEscrowFactory(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IMulticall\n    /// @notice performs a multicall but all messages sent in the process will be batched\n    function multicall(bytes[] calldata data) public payable override {\n        bool wasBatching = gateway.isBatching();\n        if (!wasBatching) {\n            gateway.startBatching();\n            gateway.startTransactionPayment{value: msg.value}(msg.sender);\n        }\n\n        super.multicall(data);\n\n        if (!wasBatching) {\n            gateway.endBatching();\n            gateway.endTransactionPayment();\n        }\n    }\n\n    /// @inheritdoc IHubGuardianActions\n    function createPool(PoolId poolId, address admin, AssetId currency) external payable {\n        _auth();\n\n        require(poolId.centrifugeId() == sender.localCentrifugeId(), InvalidPoolId());\n        hubRegistry.registerPool(poolId, admin, currency);\n\n        IPoolEscrow escrow = poolEscrowFactory.newEscrow(poolId);\n        gateway.setRefundAddress(poolId, escrow);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Permissionless methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function notifyDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable\n        payTransaction\n    {\n        _protected();\n\n        (uint128 totalPayoutShareAmount, uint128 totalPaymentAssetAmount, uint128 cancelledAssetAmount) =\n            hubHelpers.notifyDeposit(poolId, scId, assetId, investor, maxClaims);\n\n        if (totalPaymentAssetAmount > 0 || cancelledAssetAmount > 0) {\n            sender.sendRequestCallback(\n                poolId,\n                scId,\n                assetId,\n                RequestCallbackMessageLib.FulfilledDepositRequest(\n                    investor, totalPaymentAssetAmount, totalPayoutShareAmount, cancelledAssetAmount\n                ).serialize(),\n                0\n            );\n        }\n    }\n\n    /// @inheritdoc IHub\n    function notifyRedeem(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable\n        payTransaction\n    {\n        _protected();\n\n        (uint128 totalPayoutAssetAmount, uint128 totalPaymentShareAmount, uint128 cancelledShareAmount) =\n            hubHelpers.notifyRedeem(poolId, scId, assetId, investor, maxClaims);\n\n        if (totalPaymentShareAmount > 0 || cancelledShareAmount > 0) {\n            sender.sendRequestCallback(\n                poolId,\n                scId,\n                assetId,\n                RequestCallbackMessageLib.FulfilledRedeemRequest(\n                    investor, totalPayoutAssetAmount, totalPaymentShareAmount, cancelledShareAmount\n                ).serialize(),\n                0\n            );\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Pool admin methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function notifyPool(PoolId poolId, uint16 centrifugeId) external payable payTransaction {\n        _isManager(poolId);\n\n        emit NotifyPool(centrifugeId, poolId);\n        sender.sendNotifyPool(centrifugeId, poolId);\n    }\n\n    /// @inheritdoc IHub\n    function notifyShareClass(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        (string memory name, string memory symbol, bytes32 salt) = shareClassManager.metadata(scId);\n        uint8 decimals = hubRegistry.decimals(poolId);\n\n        emit NotifyShareClass(centrifugeId, poolId, scId);\n        sender.sendNotifyShareClass(centrifugeId, poolId, scId, name, symbol, decimals, salt, hook);\n    }\n\n    /// @inheritdoc IHub\n    function notifyShareMetadata(PoolId poolId, ShareClassId scId, uint16 centrifugeId) public payable payTransaction {\n        _isManager(poolId);\n\n        (string memory name, string memory symbol,) = shareClassManager.metadata(scId);\n\n        emit NotifyShareMetadata(centrifugeId, poolId, scId, name, symbol);\n        sender.sendNotifyShareMetadata(centrifugeId, poolId, scId, name, symbol);\n    }\n\n    /// @inheritdoc IHub\n    function updateShareHook(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook)\n        public\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        emit UpdateShareHook(centrifugeId, poolId, scId, hook);\n        sender.sendUpdateShareHook(centrifugeId, poolId, scId, hook);\n    }\n\n    /// @inheritdoc IHub\n    function notifySharePrice(PoolId poolId, ShareClassId scId, uint16 centrifugeId) public payable payTransaction {\n        _isManager(poolId);\n\n        (, D18 poolPerShare) = shareClassManager.metrics(scId);\n\n        emit NotifySharePrice(centrifugeId, poolId, scId, poolPerShare);\n        sender.sendNotifyPricePoolPerShare(centrifugeId, poolId, scId, poolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function notifyAssetPrice(PoolId poolId, ShareClassId scId, AssetId assetId) public payable payTransaction {\n        _isManager(poolId);\n        D18 pricePoolPerAsset = hubHelpers.pricePoolPerAsset(poolId, scId, assetId);\n        emit NotifyAssetPrice(assetId.centrifugeId(), poolId, scId, assetId, pricePoolPerAsset);\n        sender.sendNotifyPricePoolPerAsset(poolId, scId, assetId, pricePoolPerAsset);\n    }\n\n    /// @inheritdoc IHub\n    function setMaxAssetPriceAge(PoolId poolId, ShareClassId scId, AssetId assetId, uint64 maxPriceAge)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        emit SetMaxAssetPriceAge(poolId, scId, assetId, maxPriceAge);\n        sender.sendMaxAssetPriceAge(poolId, scId, assetId, maxPriceAge);\n    }\n\n    /// @inheritdoc IHub\n    function setMaxSharePriceAge(uint16 centrifugeId, PoolId poolId, ShareClassId scId, uint64 maxPriceAge)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        emit SetMaxSharePriceAge(centrifugeId, poolId, scId, maxPriceAge);\n        sender.sendMaxSharePriceAge(centrifugeId, poolId, scId, maxPriceAge);\n    }\n\n    /// @inheritdoc IHub\n    function setPoolMetadata(PoolId poolId, bytes calldata metadata) external payable {\n        _isManager(poolId);\n\n        hubRegistry.setMetadata(poolId, metadata);\n    }\n\n    /// @inheritdoc IHub\n    function setSnapshotHook(PoolId poolId, ISnapshotHook hook) external payable {\n        _isManager(poolId);\n\n        holdings.setSnapshotHook(poolId, hook);\n    }\n\n    /// @inheritdoc IHub\n    function updateShareClassMetadata(PoolId poolId, ShareClassId scId, string calldata name, string calldata symbol)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        shareClassManager.updateMetadata(poolId, scId, name, symbol);\n    }\n\n    /// @inheritdoc IHub\n    function updateHubManager(PoolId poolId, address who, bool canManage) external payable {\n        _isManager(poolId);\n\n        hubRegistry.updateManager(poolId, who, canManage);\n    }\n\n    /// @inheritdoc IHub\n    function setRequestManager(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 manager)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        sender.sendSetRequestManager(poolId, scId, assetId, manager);\n    }\n\n    /// @inheritdoc IHub\n    function updateBalanceSheetManager(uint16 centrifugeId, PoolId poolId, bytes32 who, bool canManage)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        sender.sendUpdateBalanceSheetManager(centrifugeId, poolId, who, canManage);\n    }\n\n    /// @inheritdoc IHub\n    function addShareClass(PoolId poolId, string calldata name, string calldata symbol, bytes32 salt)\n        external\n        payable\n        returns (ShareClassId scId)\n    {\n        _isManager(poolId);\n\n        return shareClassManager.addShareClass(poolId, name, symbol, salt);\n    }\n\n    /// @inheritdoc IHub\n    function approveDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowDepositEpochId,\n        uint128 approvedAssetAmount\n    ) external payable payTransaction returns (uint128 pendingAssetAmount, uint128 approvedPoolAmount) {\n        _isManager(poolId);\n        D18 pricePoolPerAsset = hubHelpers.pricePoolPerAsset(poolId, scId, depositAssetId);\n        (pendingAssetAmount, approvedPoolAmount) = shareClassManager.approveDeposits(\n            poolId, scId, depositAssetId, nowDepositEpochId, approvedAssetAmount, pricePoolPerAsset\n        );\n\n        sender.sendRequestCallback(\n            poolId,\n            scId,\n            depositAssetId,\n            RequestCallbackMessageLib.ApprovedDeposits(approvedAssetAmount, pricePoolPerAsset.raw()).serialize(),\n            0\n        );\n    }\n\n    /// @inheritdoc IHub\n    function approveRedeems(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRedeemEpochId,\n        uint128 approvedShareAmount\n    ) external payable returns (uint128 pendingShareAmount) {\n        _isManager(poolId);\n\n        D18 price = hubHelpers.pricePoolPerAsset(poolId, scId, payoutAssetId);\n        (pendingShareAmount) =\n            shareClassManager.approveRedeems(poolId, scId, payoutAssetId, nowRedeemEpochId, approvedShareAmount, price);\n    }\n\n    /// @inheritdoc IHub\n    function issueShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowIssueEpochId,\n        D18 navPoolPerShare,\n        uint128 extraGasLimit\n    )\n        external\n        payable\n        payTransaction\n        returns (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount)\n    {\n        _isManager(poolId);\n\n        (issuedShareAmount, depositAssetAmount, depositPoolAmount) =\n            shareClassManager.issueShares(poolId, scId, depositAssetId, nowIssueEpochId, navPoolPerShare);\n\n        sender.sendRequestCallback(\n            poolId,\n            scId,\n            depositAssetId,\n            RequestCallbackMessageLib.IssuedShares(issuedShareAmount, navPoolPerShare.raw()).serialize(),\n            extraGasLimit\n        );\n    }\n\n    /// @inheritdoc IHub\n    function revokeShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRevokeEpochId,\n        D18 navPoolPerShare,\n        uint128 extraGasLimit\n    )\n        external\n        payable\n        payTransaction\n        returns (uint128 revokedShareAmount, uint128 payoutAssetAmount, uint128 payoutPoolAmount)\n    {\n        _isManager(poolId);\n\n        (revokedShareAmount, payoutAssetAmount, payoutPoolAmount) =\n            shareClassManager.revokeShares(poolId, scId, payoutAssetId, nowRevokeEpochId, navPoolPerShare);\n\n        sender.sendRequestCallback(\n            poolId,\n            scId,\n            payoutAssetId,\n            RequestCallbackMessageLib.RevokedShares(payoutAssetAmount, revokedShareAmount, navPoolPerShare.raw())\n                .serialize(),\n            extraGasLimit\n        );\n    }\n\n    /// @inheritdoc IHub\n    function forceCancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        uint128 cancelledAssetAmount =\n            shareClassManager.forceCancelDepositRequest(poolId, scId, investor, depositAssetId);\n\n        // Cancellation might have been queued such that it will be executed in the future during claiming\n        if (cancelledAssetAmount > 0) {\n            sender.sendRequestCallback(\n                poolId,\n                scId,\n                depositAssetId,\n                RequestCallbackMessageLib.FulfilledDepositRequest(investor, 0, 0, cancelledAssetAmount).serialize(),\n                0\n            );\n        }\n    }\n\n    /// @inheritdoc IHub\n    function forceCancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId)\n        external\n        payable\n        payTransaction\n    {\n        _isManager(poolId);\n\n        uint128 cancelledShareAmount = shareClassManager.forceCancelRedeemRequest(poolId, scId, investor, payoutAssetId);\n\n        // Cancellation might have been queued such that it will be executed in the future during claiming\n        if (cancelledShareAmount > 0) {\n            sender.sendRequestCallback(\n                poolId,\n                scId,\n                payoutAssetId,\n                RequestCallbackMessageLib.FulfilledRedeemRequest(investor, 0, 0, cancelledShareAmount).serialize(),\n                0\n            );\n        }\n    }\n\n    /// @inheritdoc IHub\n    function updateRestriction(\n        PoolId poolId,\n        ShareClassId scId,\n        uint16 centrifugeId,\n        bytes calldata payload,\n        uint128 extraGasLimit\n    ) external payable payTransaction {\n        _isManager(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateRestriction(centrifugeId, poolId, scId, payload);\n        sender.sendUpdateRestriction(centrifugeId, poolId, scId, payload, extraGasLimit);\n    }\n\n    /// @inheritdoc IHub\n    function updateVault(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 vaultOrFactory,\n        VaultUpdateKind kind,\n        uint128 extraGasLimit\n    ) external payable payTransaction {\n        _isManager(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateVault(poolId, scId, assetId, vaultOrFactory, kind);\n        sender.sendUpdateVault(poolId, scId, assetId, vaultOrFactory, kind, extraGasLimit);\n    }\n\n    /// @inheritdoc IHub\n    function updateContract(\n        PoolId poolId,\n        ShareClassId scId,\n        uint16 centrifugeId,\n        bytes32 target,\n        bytes calldata payload,\n        uint128 extraGasLimit\n    ) external payable payTransaction {\n        _isManager(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateContract(centrifugeId, poolId, scId, target, payload);\n        sender.sendUpdateContract(centrifugeId, poolId, scId, target, payload, extraGasLimit);\n    }\n\n    /// @inheritdoc IHub\n    function updateSharePrice(PoolId poolId, ShareClassId scId, D18 navPoolPerShare) public payable {\n        _isManager(poolId);\n\n        shareClassManager.updateSharePrice(poolId, scId, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function initializeHolding(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IValuation valuation,\n        AccountId assetAccount,\n        AccountId equityAccount,\n        AccountId gainAccount,\n        AccountId lossAccount\n    ) external payable {\n        _isManager(poolId);\n\n        require(hubRegistry.isRegistered(assetId), IHubRegistry.AssetNotFound());\n        require(\n            assetAccount != equityAccount && assetAccount != gainAccount && assetAccount != lossAccount,\n            IHub.InvalidAccountCombination()\n        );\n        require(\n            accounting.exists(poolId, assetAccount) && accounting.exists(poolId, equityAccount)\n                && accounting.exists(poolId, lossAccount) && accounting.exists(poolId, gainAccount),\n            IAccounting.AccountDoesNotExist()\n        );\n\n        holdings.initialize(\n            poolId,\n            scId,\n            assetId,\n            valuation,\n            false,\n            hubHelpers.holdingAccounts(assetAccount, equityAccount, gainAccount, lossAccount)\n        );\n\n        // If increase/decrease was called before initialize, we add journal entries for this\n        hubHelpers.updateAccountingAmount(poolId, scId, assetId, true, holdings.value(poolId, scId, assetId));\n    }\n\n    /// @inheritdoc IHub\n    function initializeLiability(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IValuation valuation,\n        AccountId expenseAccount,\n        AccountId liabilityAccount\n    ) external payable {\n        _isManager(poolId);\n\n        require(hubRegistry.isRegistered(assetId), IHubRegistry.AssetNotFound());\n        require(expenseAccount != liabilityAccount, IHub.InvalidAccountCombination());\n        require(\n            accounting.exists(poolId, expenseAccount) && accounting.exists(poolId, liabilityAccount),\n            IAccounting.AccountDoesNotExist()\n        );\n\n        holdings.initialize(\n            poolId, scId, assetId, valuation, true, hubHelpers.liabilityAccounts(expenseAccount, liabilityAccount)\n        );\n\n        // If increase/decrease was called before initialize, we add journal entries for this\n        hubHelpers.updateAccountingAmount(poolId, scId, assetId, true, holdings.value(poolId, scId, assetId));\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingValue(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManager(poolId);\n\n        (bool isPositive, uint128 diff) = holdings.update(poolId, scId, assetId);\n        hubHelpers.updateAccountingValue(poolId, scId, assetId, isPositive, diff);\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingValuation(PoolId poolId, ShareClassId scId, AssetId assetId, IValuation valuation)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        holdings.updateValuation(poolId, scId, assetId, valuation);\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingIsLiability(PoolId poolId, ShareClassId scId, AssetId assetId, bool isLiability)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        holdings.updateIsLiability(poolId, scId, assetId, isLiability);\n    }\n\n    /// @inheritdoc IHub\n    function setHoldingAccountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind, AccountId accountId)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        require(accounting.exists(poolId, accountId), IAccounting.AccountDoesNotExist());\n\n        holdings.setAccountId(poolId, scId, assetId, kind, accountId);\n    }\n\n    /// @inheritdoc IHub\n    function createAccount(PoolId poolId, AccountId account, bool isDebitNormal) public payable {\n        _isManager(poolId);\n\n        accounting.createAccount(poolId, account, isDebitNormal);\n    }\n\n    /// @inheritdoc IHub\n    function setAccountMetadata(PoolId poolId, AccountId account, bytes calldata metadata) external payable {\n        _isManager(poolId);\n\n        accounting.setAccountMetadata(poolId, account, metadata);\n    }\n\n    /// @inheritdoc IHub\n    function updateJournal(PoolId poolId, JournalEntry[] memory debits, JournalEntry[] memory credits) external {\n        _isManager(poolId);\n\n        accounting.unlock(poolId);\n        accounting.addJournal(debits, credits);\n        accounting.lock();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway owner methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHubGatewayHandler\n    function registerAsset(AssetId assetId, uint8 decimals) external {\n        _auth();\n\n        hubRegistry.registerAsset(assetId, decimals);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function request(PoolId poolId, ShareClassId scId, AssetId assetId, bytes calldata payload) external payable {\n        _auth();\n\n        hubHelpers.request(poolId, scId, assetId, payload);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function updateHoldingAmount(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease,\n        bool isSnapshot,\n        uint64 nonce\n    ) external {\n        _auth();\n\n        uint128 value = isIncrease\n            ? holdings.increase(poolId, scId, assetId, pricePoolPerAsset, amount)\n            : holdings.decrease(poolId, scId, assetId, pricePoolPerAsset, amount);\n\n        if (holdings.isInitialized(poolId, scId, assetId)) {\n            hubHelpers.updateAccountingAmount(poolId, scId, assetId, isIncrease, value);\n        }\n\n        holdings.setSnapshot(poolId, scId, centrifugeId, isSnapshot, nonce);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function updateShares(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        uint128 amount,\n        bool isIssuance,\n        bool isSnapshot,\n        uint64 nonce\n    ) external {\n        _auth();\n\n        shareClassManager.updateShares(centrifugeId, poolId, scId, amount, isIssuance);\n\n        holdings.setSnapshot(poolId, scId, centrifugeId, isSnapshot, nonce);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function initiateTransferShares(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        bytes32 receiver,\n        uint128 amount,\n        uint128 extraGasLimit\n    ) external {\n        _auth();\n\n        emit ForwardTransferShares(centrifugeId, poolId, scId, receiver, amount);\n        sender.sendExecuteTransferShares(centrifugeId, poolId, scId, receiver, amount, extraGasLimit);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    //  Internal methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev Ensure the sender is authorized\n    function _auth() internal auth {}\n\n    /// @dev Protect against reentrancy\n    function _protected() internal protected {}\n\n    /// @dev Ensure the method can be used without reentrancy issues, and the sender is a pool admin\n    function _isManager(PoolId poolId) internal protected {\n        require(hubRegistry.manager(poolId, msg.sender), IHub.NotManager());\n    }\n\n    /// @notice Send native tokens to the gateway for transaction payment if it's not in a multicall.\n    function _startTransactionPayment() internal {\n        if (!gateway.isBatching()) {\n            gateway.startTransactionPayment{value: msg.value}(msg.sender);\n        }\n    }\n\n    function _endTransactionPayment() internal {\n        if (!gateway.isBatching()) {\n            gateway.endTransactionPayment();\n        }\n    }\n}\n"
    }
}