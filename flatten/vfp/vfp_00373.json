{
    "vfp_id": "vfp_00373",
    "project_name": "Jovay Sequencer System Contracts Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Incorrect Return Value in `getWithdrawEffectiveWindow`",
            "description": "The `getWithdrawEffectiveWindow` function in the `DPoSValidatorManager` contract returns an incorrect value due to two issues. First, it parses a configuration string into a `uint256` using `Strings.parseUint` but then casts the result to `uint8`, which risks truncation if the value exceeds 255. Second, when the requested configuration key does not exist, `SysChainCfg.getChainCfg` returns an empty string, which `parseUint` interprets as 0, causing the function to silently return 0 instead of reverting. The root cause is improper input validation and unsafe type casting. An attacker or misconfiguration could exploit this by setting a high withdrawal window value that gets truncated, or by relying on the silent failure to force a zero value. This could lead to incorrect withdrawal timing logic, potentially allowing premature withdrawals or blocking legitimate ones, undermining the intended security of the staking mechanism.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::getWithdrawEffectiveWindow#2644-2648"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "_transferTo Silently Ignores Failure",
            "description": "The `_transferTo` function in the `DPoSValidatorManager` contract handles transfer failures by emitting an `ErrorOccurred` event but does not revert or return a success status. This means that calling functions cannot detect whether a transfer succeeded or failed, leading to potential state inconsistency. The root cause is the lack of proper error propagation—instead of using `require` or returning a boolean, the function continues execution silently after a failed transfer. An attacker could trigger a transfer to a contract that reverts (e.g., via a malicious fallback) or to an address with insufficient balance, causing funds to be marked as transferred in the system state while no actual transfer occurs. The impact is a loss of funds or incorrect accounting, as the contract assumes the transfer succeeded when it did not.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::_transferTo#2518-2552"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "`view` Functions Return Future-Dated Chain Configuration",
            "description": "The `get_config` and `get_configs` functions in the `ChainCfg` contract return the latest configuration checkpoint without verifying whether it is effective at the current block. Since `set_config` sets `effectiveBlockNum` to `block.number + 1`, the new configuration should only take effect in the next block. However, the getter functions do not enforce this delay and return the new configuration immediately, allowing it to be used in the same block it was set. The root cause is the absence of a check in the getter functions to ensure `effectiveBlockNum <= block.number`. An attacker or front-running bot could exploit this by reading the new configuration in the same block and acting on it before the intended delay, potentially causing inconsistent behavior across system components that rely on the one-block deferral. This undermines the integrity of the configuration update mechanism and could lead to race conditions or incorrect system state.\n",
            "severity": "Medium",
            "location": [
                "sys_chaincfg.sol::get_config#40",
                "sys_chaincfg.sol::get_configs#52",
                "sys_chaincfg.sol::set_config#74"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Native Tokens Can Become Stuck in `DPoSValidatorManager`",
            "description": "The `DPoSValidatorManager` contract has a `receive` function that allows it to accept native token payments, but it lacks any mechanism to withdraw those funds. As a result, any native tokens sent to the contract become permanently locked. The root cause is the presence of a payable `receive` function without corresponding withdrawal logic. An attacker could exploit this by sending small amounts of native tokens to clog the contract or, more critically, users might accidentally send funds that are then irretrievable. The impact is permanent loss of funds and reduced trust in the system, especially if the contract accumulates significant balances over time.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::receive#2657-2665"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Metahash Filter Not Implemented in Rule-Existence Check",
            "description": "The `checkExist` function in the `rule_mng.sol` contract checks for rule existence based only on contract address and selector, ignoring the `metahash` parameter. Although `metahash` is documented as a filter in the `InferRule` struct, it is not used in the existence check, meaning two rules with the same address and selector but different `metahash` values are considered duplicates. The root cause is incomplete logic in `checkExist`, which only validates that `metahash` is non-zero but does not include it in the comparison. An attacker (or legitimate user) cannot create multiple rules differing only by `metahash`, limiting the intended flexibility of the rule system. This contradicts the design specification and reduces the utility of the `metahash` field, potentially leading to confusion and integration errors.\n",
            "severity": "Medium",
            "location": [
                "rule_mng.sol::checkExist#50",
                "rule_mng.sol::InferRule#15",
                "rule_mng.sol::addRule#130"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Missing Rule Manager Epoch Advance",
            "description": "The `advanceEpoch` function in the `DPoSValidatorManager` contract does not call the corresponding `advanceEpoch` function in the `InferRuleManager` contract. This breaks synchronization between validator epochs and rule state transitions, as the `InferRuleManager` relies on its own `advanceEpoch` call to move rules from `INIT`/`UPDATED` to `IN_PROVING` and from `PROVING_SUCCESS` to `IN_USE`. The root cause is the omission of a required cross-contract call. If rule and validator epochs are meant to be aligned, this desynchronization could delay or prevent rule activation, leading to incorrect inference behavior. An attacker could exploit timing gaps to submit transactions that bypass intended rule checks, reducing system security and predictability.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::advanceEpoch#2585",
                "rule_mng.sol::advanceEpoch#318"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol",
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-284"
                ]
            },
            "title": "Unreadable Historical Checkpoints",
            "description": "The `ChainCfg` contract stores configuration checkpoints in the private `configCps` array but only exposes the latest checkpoint via `get_config` and `get_configs`. This makes historical configurations inaccessible, rendering the checkpoint mechanism partially useless for auditing or state recovery. The root cause is the lack of public functions to query past checkpoints. While the data is stored, its inaccessibility defeats the purpose of maintaining a history. This limits the ability to verify past configurations or debug issues, reducing transparency and auditability. The impact is a weakened governance and monitoring system, as stakeholders cannot verify how configurations have evolved over time.\n",
            "severity": "Medium",
            "location": [
                "sys_chaincfg.sol::get_config#40",
                "sys_chaincfg.sol::get_configs#52",
                "sys_chaincfg.sol::configCps"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "`updateValidator` Calls Will Fail",
            "description": "The `updateValidator` function in the `DPoSValidatorManager` contract is public but cannot succeed because there is no way to add validators in the first place—the `validators` mapping remains empty. The function attempts to update a validator that cannot exist, leading to a self-inflicted denial of service. The root cause is missing validator registration logic, likely due to incomplete implementation or removal of staking functionality. An attacker could spam calls to this function, wasting gas, or integrators might误use it under false assumptions. The impact is confusion, wasted resources, and reduced code clarity, as the function appears functional but is guaranteed to fail.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::updateValidator#2554-2577"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Grantees Can Approve or Deny Any Rules in Proving",
            "description": "The `updateProvingResult` function in the `InferRuleManager` contract uses `checkAdminPermission`, which allows both administrators and grantees to approve or reject rule proofs. This enables grantees to bypass the proving process by marking their own rules as `PROVING_SUCCESS` or to grief others by marking their rules as `PROVING_FAILURE`. The root cause is overly permissive access control—the function should only be callable by a trusted administrator or off-chain oracle, not by grantees. An attacker with grantee privileges could exploit this to push malicious rules into production without proper validation, undermining the entire rule verification system and potentially compromising transaction inference integrity.\n",
            "severity": "Medium",
            "location": [
                "rule_mng.sol::updateProvingResult#283-310",
                "rule_mng.sol::checkAdminPermission#89-95"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Metahash Parameter Not Used in Permission Check",
            "description": "The `checkPermission(_metahash)` function in `rule_mng.sol` does not use the `_metahash` parameter for any meaningful authorization logic. It returns `true` if the caller has admin permissions, and otherwise only checks that `_metahash` is non-zero before returning `false`. The root cause is incomplete or abandoned logic—there is no actual metahash-based access control implemented. This suggests the function was intended for future use but was never completed. The impact is confusion and potential misuse, as developers might assume metahash-based permissions are enforced when they are not. It also increases code complexity without benefit.\n",
            "severity": "Medium",
            "location": [
                "rule_mng.sol::checkPermission#97"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "`DPoSValidatorManager` Contains Unnecessary Logic",
            "description": "The `DPoSValidatorManager` contract contains numerous unused functions, state variables, events, and parameters that were left behind after staking functionality was removed. Examples include `hexStringToBytes`, `_transferTo`, `validators`, `MIN_VALIDATOR_STAKE`, and several events. The root cause is incomplete code cleanup after feature removal. This bloats the contract, increases deployment cost, complicates audits, and confuses integrators about the contract’s purpose. While not directly exploitable, it increases maintenance burden and the risk of accidental misuse. The impact is reduced code clarity, higher gas costs, and potential for bugs during future upgrades due to confusion over unused components.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::hexStringToBytes#2442-2465",
                "sys_staking.sol::sliceBytes#2467-2477",
                "sys_staking.sol::fromHexChar#2479-2490",
                "sys_staking.sol::_transferTo#2518-2552",
                "sys_staking.sol::getWithdrawEffectiveWindow#2644-2648",
                "sys_staking.sol::getChainCfg#2650-2655",
                "sys_staking.sol::validators#2353",
                "sys_staking.sol::MIN_VALIDATOR_STAKE#2358",
                "sys_staking.sol::MIN_DELEGATOR_STAKE#2359",
                "sys_staking.sol::MIN_POOL_STAKE#2360",
                "sys_staking.sol::MAX_POOL_STAKE#2361",
                "sys_staking.sol::EPOCH_DURATION#2362",
                "sys_staking.sol::DomainUpdate#2372-2380",
                "sys_staking.sol::ValidatorReward#2390-2398",
                "sys_staking.sol::ValidatorWithdrawStake#2400-2407",
                "sys_staking.sol::StakeAdded#2408-2412",
                "sys_staking.sol::ValidatorRegistered#2413-2416",
                "sys_staking.sol::ValidatorExitRequested#2418",
                "sys_staking.sol::ErrorOcurred#2420-2425",
                "sys_staking.sol::ReentrancyGuard#2336",
                "sys_staking.sol::advanceEpoch#2586-2587",
                "sys_staking.sol::pendingAddPoolIds#2355",
                "sys_staking.sol::pendingExitPoolIds#2356",
                "sys_staking.sol::activePoolIds#2354"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Insufficient Documentation and Comments",
            "description": "The codebase lacks NatSpec documentation and has minimal inline comments, especially in complex contracts like `DPoSValidatorManager`. The root cause is insufficient documentation effort. This makes it difficult to understand the intended behavior of functions and state variables, increasing the risk of misinterpretation during audits or upgrades. The impact is higher chance of bugs being introduced or missed, longer review times, and reduced maintainability.\n",
            "severity": "Low",
            "location": [
                "sys_staking.sol::DPoSValidatorManager#2336"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Code Duplication in `InferRuleManager`",
            "description": "The `InferRuleManager` contract duplicates all functions and events from the `PermissionControl` contract instead of inheriting or importing it, leading to redundant and harder-to-maintain code.\nThe root cause is poor code design and lack of reuse through inheritance or composition.\nThis increases the risk of inconsistencies and bugs if changes are made in one contract but not the other.\nThe impact includes increased maintenance burden, larger contract size, and potential for logic divergence and security inconsistencies.\n",
            "severity": "Low",
            "location": [
                "rule_mng.sol::InferRuleManager"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Incorrect `AdminRevoked` Event Parameter",
            "description": "The `AdminRevoked` event declares a parameter `revoker` but emits the `revoked` address instead of the `msg.sender`.\nThis mismatch causes incorrect off-chain interpretation of who performed the revocation.\nThe cause is a logical error in event emission within the `revokeAdmin` function.\nThe impact includes inaccurate audit trails and potential confusion in monitoring or governance systems.\n",
            "severity": "Low",
            "location": [
                "permission_control.sol::AdminRevoked",
                "permission_control.sol::revokeAdmin#88"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Old Library Version",
            "description": "The `DPoSValidatorManager` contract uses OpenZeppelin version 5.1.0, while 5.4.0 is available with improvements.\nAlthough the `Strings` library was updated, `ReentrancyGuard` was not due to storage compatibility concerns.\nUsing outdated libraries may miss security patches or features.\nThe impact is potential missed gas optimizations or lack of access to improved functionality, though no direct security flaw is introduced.\n",
            "severity": "Low",
            "location": [
                "sys_staking.sol::DPoSValidatorManager"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "Linear Complexity Creates DoS Vectors",
            "description": "Multiple contracts use unbounded arrays with linear search operations (e.g., `ChainCfg.set_config`, `InferRuleManager.checkExist`, `DPoSValidatorManager.isArrayContains`), leading to increasing gas costs.\nAs data grows, these operations may exceed block gas limits, preventing further execution.\nThe cause is the use of arrays instead of mappings or sets for large datasets.\nThe impact is a denial-of-service condition where critical functions become unusable, especially in `ChainCfg` which has quadratic complexity on config updates.\n",
            "severity": "Medium",
            "location": [
                "sys_chaincfg.sol::set_config#60",
                "sys_chaincfg.sol::get_config#40",
                "rule_mng.sol::checkExist#55",
                "rule_mng.sol::delRule#204",
                "rule_mng.sol::updateRule#169",
                "rule_mng.sol::advanceEpoch#322",
                "sys_staking.sol::isArrayContains#2492",
                "permission_control.sol::checkGrantPermission#31",
                "permission_control.sol::revokeAdmin#80"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Variable Could Be `immutable`",
            "description": "The `prove_threshold_` variable in `rule_mng.sol` is set in the constructor and never changed, but is not declared `immutable`.\nThis misses an opportunity for gas savings and clearer code intent.\nThe cause is failure to apply the `immutable` keyword where appropriate.\nThe impact is slightly higher deployment cost and reduced code clarity regarding variable mutability.\n",
            "severity": "Low",
            "location": [
                "rule_mng.sol::prove_threshold_#39"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused Enum",
            "description": "The `CreateMethod` enum in `rule_mng.sol` is defined but not used anywhere in the codebase.\nUnused code elements reduce readability and increase confusion.\nThis may indicate incomplete refactoring or abandoned features.\nThe impact is code bloat and potential misunderstanding of contract functionality.\n",
            "severity": "Low",
            "location": [
                "rule_mng.sol::CreateMethod#7"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-477"
                ]
            },
            "title": "Use Custom Errors",
            "description": "The codebase uses string literals in `require` statements instead of custom errors, which are more gas-efficient and cleaner since Solidity 0.8.4.\nThe cause is outdated error handling patterns.\nThis increases gas costs for failed transactions and reduces clarity in revert reasons.\nThe impact includes higher transaction costs and less efficient error reporting for users and tools.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol",
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol",
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Function With `internal` or `private` Visibility",
            "description": "The `checkAdminPermission` function in `permission_control.sol` is defined but not called anywhere.\nUnused functions increase contract size and attack surface without benefit.\nThis may be dead code from prior development phases.\nThe impact includes unnecessary gas costs on deployment and potential confusion during audits.\n",
            "severity": "Low",
            "location": [
                "permission_control.sol::checkAdminPermission#22-28"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Lack of Indexed Event Parameters",
            "description": "Multiple events such as `SuperTransferred`, `AdminGranted`, and `RuleAdded` do not have any indexed parameters, making them difficult to query off-chain.\nThe cause is failure to use the `indexed` keyword on important event fields.\nThis hinders event filtering and monitoring by external services like indexers or frontends.\nThe impact is degraded observability and increased cost for event-based applications.\n",
            "severity": "Low",
            "location": [
                "permission_control.sol::SuperTransferred",
                "permission_control.sol::AdminGranted",
                "permission_control.sol::AdminRevoked",
                "rule_mng.sol::RuleAdded",
                "rule_mng.sol::RuleUpdated",
                "rule_mng.sol::RuleDeleted",
                "rule_mng.sol::ProvingResultUpdated",
                "rule_mng.sol::SuperTransferred",
                "rule_mng.sol::AdminGranted",
                "rule_mng.sol::AdminRevoked"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "State Variable Visibility Not Explicitly Declared",
            "description": "The `configCps` state variable in `sys_chaincfg.sol` does not explicitly declare its visibility.\nWhile Solidity defaults to private for state variables, explicit declaration improves code clarity.\nThe cause is omission of the visibility keyword.\nThe impact is reduced readability and potential confusion about access control.\n",
            "severity": "Low",
            "location": [
                "sys_chaincfg.sol::configCps#17"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Use of `uint/int` Instead of `uint256/int256`",
            "description": "Multiple instances of `uint` are used instead of the explicit `uint256`, which is the full form and recommended for clarity.\nAlthough functionally equivalent, this reduces consistency and readability.\nThe cause is use of type aliases instead of explicit types.\nThe impact is minor, but it may confuse developers unfamiliar with the aliasing behavior in Solidity.\n",
            "severity": "Low",
            "location": [
                "rule_mng.sol#204",
                "rule_mng.sol#224",
                "sys_staking.sol#2423",
                "sys_staking.sol#2456",
                "sys_staking.sol#2469",
                "sys_staking.sol#2470",
                "sys_staking.sol#2473",
                "sys_staking.sol#2496",
                "sys_staking.sol#2518",
                "sys_staking.sol#2520",
                "sys_staking.sol#2538"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Function Visibility Overly Permissive",
            "description": "Several functions across multiple contracts are declared with more permissive visibility than necessary, which could potentially allow unintended access from derived contracts or external callers. The root cause is the use of `internal` or `public` visibility when `private` or `external` would be sufficient based on the function's intended use. For instance, utility functions like `_fromHexChar` and `sliceBytes` are marked `internal` but are only used within their defining contract, making them candidates for `private`. Similarly, getter functions like `getSuperAdmin` are `public` but could be `external` to save gas. While this does not directly lead to fund loss, it increases the attack surface and reduces code clarity. An attacker could potentially exploit overly public functions if future code changes introduce vulnerabilities in those entry points. The impact is primarily on code maintainability, gas efficiency, and security hygiene.\n",
            "severity": "Medium",
            "location": [
                "permission_control.sol::checkSuperPermission#14-20",
                "permission_control.sol::checkAdminPermission#22-28",
                "permission_control.sol::checkGrantPermission#30-38",
                "permission_control.sol::getSuperAdmin#54-56",
                "permission_control.sol::getGranteeAdmin#59-61",
                "rule_mng.sol::addRule#128-144",
                "rule_mng.sol::updateRule#158-190",
                "rule_mng.sol::delRule#196-242",
                "rule_mng.sol::getAllRules#245-259",
                "rule_mng.sol::getNextId#262-264",
                "rule_mng.sol::getContractRules#267-275",
                "rule_mng.sol::updateProvingResult#283-310",
                "rule_mng.sol::getSuperAdmin#372-374",
                "rule_mng.sol::getGranteeAdmin#377-379",
                "sys_chaincfg.sol::changeSys#33-38",
                "sys_chaincfg.sol::get_config#40-50",
                "sys_chaincfg.sol::get_configs#52-58",
                "sys_staking.sol::hexStringToBytes#2442-2465",
                "sys_staking.sol::sliceBytes#2467-2477",
                "sys_staking.sol::_fromHexChar#2479-2490",
                "sys_staking.sol::isArrayContains#2492-2502",
                "sys_staking.sol::isValidatorPendingExit#2512-2516",
                "sys_staking.sol::_transferTo#2518-2552",
                "sys_staking.sol::advanceEpoch#2579-2583",
                "sys_staking.sol::setChainEpochBlock#2606-2622",
                "sys_staking.sol::getWithdrawEffectiveWindow#2644-2648",
                "sys_staking.sol::getChainCfg#2650-2655"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1115"
                ]
            },
            "title": "Lack of SPDX License Identifier",
            "description": "The file `rule_mng.sol` does not contain an SPDX license identifier, which is a comment specifying the license under which the smart contract code is released. The absence of such an identifier creates legal ambiguity regarding the usage and distribution of the code. The root cause is simply the omission of the SPDX comment at the top of the file. While this does not pose a direct security risk to the functionality of the contract, it can lead to compliance and licensing issues for developers or organizations wishing to use or audit the code. The impact is primarily legal and reputational, as open-source best practices recommend clear licensing. This issue was resolved by removing the file.\n",
            "severity": "Informational",
            "location": [
                "rule_mng.sol#1"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/rule_mng.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Security Contact",
            "description": "None of the sequencer contracts include a security contact, such as an email or ENS name, via a NatSpec `@custom:security-contact` tag. This omission makes it difficult for security researchers or auditors to responsibly disclose potential vulnerabilities. The root cause is the lack of standardized security disclosure practices in the codebase. Without a clear channel, critical issues might go unreported or be disclosed publicly without coordination, increasing the risk of exploitation. The impact is on the project's ability to respond to future security issues in a timely and coordinated manner. This is a best practice issue that affects the long-term security posture of the project.\n",
            "severity": "Informational",
            "location": [
                "permission_control.sol",
                "rule_mng.sol",
                "sys_chaincfg.sol",
                "sys_staking.sol"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1078"
                ]
            },
            "title": "Inconsistent Order Within Contracts",
            "description": "The contracts in the codebase do not follow the recommended function ordering as defined in the Solidity Style Guide, which suggests a specific layout (e.g., constructor, fallback, external, public, internal, private). The root cause is inconsistent development practices across the team or lack of code review enforcement. This reduces code readability and maintainability, making it harder for auditors and developers to understand the control flow and identify potential issues. While this does not introduce a direct security vulnerability, it increases the cognitive load during audits and raises the risk of missing subtle bugs. The impact is on code quality and long-term maintainability.\n",
            "severity": "Informational",
            "location": [
                "permission_control.sol",
                "rule_mng.sol",
                "sys_chaincfg.sol",
                "sys_staking.sol"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Constants Not Using UPPER_CASE Format",
            "description": "Several constant variables in the codebase are not named using the recommended `UPPER_CASE_WITH_UNDERSCORES` convention, such as `sysStaking` and `intrinsicSys`. The root cause is deviation from the Solidity Style Guide, which recommends uppercase naming for constants to distinguish them from regular variables. This inconsistency reduces code readability and can lead to confusion about which variables are intended to be immutable. While this has no direct security impact, it affects code clarity and professionalism. The impact is primarily on maintainability and adherence to community standards.\n",
            "severity": "Informational",
            "location": [
                "sys_chaincfg.sol#22",
                "sys_chaincfg.sol#23",
                "sys_staking.sol#2367",
                "sys_staking.sol#2369"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Use calldata Instead of memory",
            "description": "Parameters of external functions in `sys_chaincfg.sol` and `sys_staking.sol` are declared with `memory` data location when they should use `calldata`. Since `calldata` is a read-only and non-modifiable area that directly references transaction data, using it for external function parameters avoids the cost of copying data to memory. The root cause is inefficient coding practice. This leads to unnecessary gas consumption during function calls, increasing transaction costs for users. An attacker cannot exploit this for direct harm, but it represents an economic inefficiency. The impact is increased gas fees for legitimate users, reducing the cost-effectiveness of interacting with the contracts.\n",
            "severity": "Low",
            "location": [
                "sys_chaincfg.sol::keys#60",
                "sys_chaincfg.sol::values#60",
                "sys_staking.sol::_description#2556",
                "sys_staking.sol::_endpoint#2557"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_chaincfg.sol",
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "updateValidator Requires Redundant Inputs",
            "description": "The `updateValidator` function in `sys_staking.sol` requires all parameters to be provided even if only one field is being updated, forcing callers to supply existing values for unchanged fields. The root cause is poor function design that does not support partial updates. This increases the risk of accidental modification, especially since `_description` and `_endpoint` lack validation (e.g., non-empty checks). A user might unintentionally overwrite a field with an empty value. While `_new_owner` is checked against `address(0)`, the other fields are not, increasing the chance of misuse. The impact is potential unintended state changes due to user error, though no direct fund loss is implied. This issue was resolved by removing the function.\n",
            "severity": "Medium",
            "location": [
                "sys_staking.sol::updateValidator#2554-2559"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/sys_staking.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typographical Errors",
            "description": "The codebase contains typographical errors that can mislead developers and auditors. The `getGranteeAdmin` function has a comment stating it returns \"administrator_\" when it actually returns `grantees_`, which is misleading. Additionally, the word \"selector\" is misspelled as \"selctor\" in the `InferRule` struct and the `addRuleEvent` event. The root cause is lack of proofreading or automated linting. These errors reduce code clarity and can cause confusion during development or auditing. While they do not introduce functional bugs, they affect the professionalism and reliability of the codebase. The impact is on code readability and maintainability, potentially leading to misunderstandings.\n",
            "severity": "Informational",
            "location": [
                "permission_control.sol::getGranteeAdmin#58",
                "rule_mng.sol::InferRule#12",
                "rule_mng.sol::addRuleEvent#123"
            ],
            "files": [
                "jovay-contracts/sequencer_contracts/sys_contract/artifact_src/solidity/permission_control.sol"
            ]
        }
    ],
    "affected_files": {
        "sys_staking.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// node_modules/@openzeppelin/contracts/utils/Panic.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(\n        bool condition,\n        int256 a,\n        int256 b\n    ) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(\n        bool condition,\n        uint256 a,\n        uint256 b\n    ) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(\n                    ternary(\n                        denominator == 0,\n                        Panic.DIVISION_BY_ZERO,\n                        Panic.UNDER_OVERFLOW\n                    )\n                );\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        return\n            mulDiv(x, y, denominator) +\n            SafeCast.toUint(\n                unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0\n            );\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(\n        uint256 b,\n        uint256 e,\n        uint256 m\n    ) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(\n        uint256 b,\n        uint256 e,\n        uint256 m\n    ) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(\n                gas(),\n                0x05,\n                dataPtr,\n                mload(result),\n                dataPtr,\n                mLen\n            )\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(\n        uint256 a,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return\n                result +\n                SafeCast.toUint(\n                    unsignedRoundsUp(rounding) && result * result < a\n                );\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return\n                result +\n                SafeCast.toUint(\n                    unsignedRoundsUp(rounding) && 1 << result < value\n                );\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return\n                result +\n                SafeCast.toUint(\n                    unsignedRoundsUp(rounding) && 10 ** result < value\n                );\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return\n                result +\n                SafeCast.toUint(\n                    unsignedRoundsUp(rounding) && 1 << (result << 3) < value\n                );\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(\n        int256 value\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                value < 0 ? \"-\" : \"\",\n                toString(SignedMath.abs(value))\n            );\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(\n        address addr\n    ) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(\n        string memory a,\n        string memory b\n    ) internal pure returns (bool) {\n        return\n            bytes(a).length == bytes(b).length &&\n            keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input\n    ) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(\n        bytes memory buffer,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n// import \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract ReentrancyGuard {\n    /**\n     * @dev We use a single lock for the whole contract.\n     */\n    bool private reentrancyLock = false;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * @notice If you mark a function `nonReentrant`, you should also\n     * mark it `external`. Calling one nonReentrant function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and a `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        require(!reentrancyLock);\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n}\n\ninterface SysChainCfg {\n    function set_config(string[] memory keys, string[] memory values) external;\n    function get_config(\n        string memory key\n    ) external view returns (string memory);\n}\n\ncontract DPoSValidatorManager is ReentrancyGuard {\n    struct Validator {\n        string description;\n        string publicKey;\n        string publicKeyPop;\n        string blsPublicKey;\n        string blsPublicKeyPop;\n        string endpoint;\n        uint8 status;\n        bytes32 poolId;\n        uint256 totalStake;\n        address owner;\n        uint256 stakeSnapshot;\n        uint256 pendingWithdrawStake;\n        uint8 pendingWithdrawWindow;\n    }\n\n    mapping(bytes32 => Validator) public validators;\n    bytes32[] public activePoolIds;\n    bytes32[] public pendingAddPoolIds;\n    bytes32[] public pendingExitPoolIds;\n\n    uint256 public constant MIN_VALIDATOR_STAKE = 1 ether;\n    uint256 public constant MIN_DELEGATOR_STAKE = 1 ether;\n    uint256 public constant MIN_POOL_STAKE = 1 ether;\n    uint256 public constant MAX_POOL_STAKE = 100000 ether;\n    uint256 public constant EPOCH_DURATION = 6 hours;\n\n    uint256 public currentEpoch;\n    uint256 public totalStake;\n\n    address public constant sysChainCfg =\n        0x3100000000000000000000000000000000000000;\n    address public constant intrinsicSys =\n        0x1111111111111111111111111111111111111111;\n\n    event DomainUpdate(\n        bytes32 indexed poolId,\n        string description,\n        string publicKey,\n        string blsPublicKey,\n        string endpoint,\n        uint64 effectiveBlockNum,\n        uint8 status\n    );\n\n    event EpochChange(\n        uint256 indexed epochNumber,\n        uint256 indexed blockNumber,\n        uint256 timestamp,\n        uint256 totalStake,\n        bytes32[] activeValidators\n    );\n\n    event ValidatorReward(\n        bytes32 indexed poolId,\n        address indexed owner,\n        uint256 indexed epochNumber,\n        uint256 blockNumber,\n        uint256 baseReward,\n        uint256 feeReward,\n        uint256 totalReward\n    );\n\n    event ValidatorWithdrawStake(\n        bytes32 indexed poolId,\n        uint256 indexed epochNumber,\n        uint256 indexed blockNumber,\n        uint256 totalStake,\n        uint256 withdrawStake\n    );\n\n    event StakeAdded(\n        address indexed delegator,\n        bytes32 indexed poolId,\n        uint256 amount\n    );\n    event ValidatorRegistered(\n        address indexed validator,\n        bytes32 indexed poolId\n    );\n    event ValidatorUpdated(bytes32 indexed poolId);\n    event ValidatorExitRequested(bytes32 indexed poolId);\n\n    event ErrorOccurred(\n        uint256 indexed epochNumber,\n        uint256 indexed blockNumber,\n        uint indexed errorCode,\n        bytes errorData\n    );\n\n    event BalanceReceived(\n        uint256 indexed epochNumber,\n        uint256 indexed blockNumber,\n        address indexed sender,\n        uint256 amount,\n        uint256 totalBalance\n    );\n\n    constructor() {}\n\n    modifier onlyOwner() {\n        require(msg.sender == intrinsicSys, \"Not owner\");\n        _;\n    }\n\n    function hexStringToBytes(\n        string memory str\n    ) public pure returns (bytes memory) {\n        bytes memory strBytes = bytes(str);\n\n        // Check and strip the '0x' prefix if it exists\n        if (strBytes.length >= 2 && strBytes[0] == \"0\" && strBytes[1] == \"x\") {\n            strBytes = sliceBytes(strBytes, 2, strBytes.length);\n        }\n\n        require(strBytes.length % 2 == 0, \"Invalid hex string length\");\n\n        bytes memory result = new bytes(strBytes.length / 2);\n\n        for (uint i = 0; i < strBytes.length / 2; i++) {\n            result[i] = bytes1(\n                _fromHexChar(strBytes[2 * i]) *\n                    16 +\n                    _fromHexChar(strBytes[2 * i + 1])\n            );\n        }\n\n        return result;\n    }\n\n    function sliceBytes(\n        bytes memory data,\n        uint start,\n        uint end\n    ) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(end - start);\n        for (uint i = start; i < end; i++) {\n            result[i - start] = data[i];\n        }\n        return result;\n    }\n\n    function _fromHexChar(bytes1 c) internal pure returns (uint8) {\n        uint8 charCode = uint8(c);\n        if (charCode >= 48 && charCode <= 57) {\n            return charCode - 48; // '0'-'9'\n        } else if (charCode >= 97 && charCode <= 102) {\n            return charCode - 87; // 'a'-'f'\n        } else if (charCode >= 65 && charCode <= 70) {\n            return charCode - 55; // 'A'-'F'\n        } else {\n            revert(\"Invalid hex character\");\n        }\n    }\n\n    function isArrayContains(\n        bytes32[] memory array,\n        bytes32 element\n    ) internal pure returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isValidatorActive(bytes32 _poolId) public view returns (bool) {\n        return isArrayContains(activePoolIds, _poolId);\n    }\n\n    function isValidatorPendingAdd(bytes32 _poolId) public view returns (bool) {\n        return isArrayContains(pendingAddPoolIds, _poolId);\n    }\n\n    function isValidatorPendingExit(\n        bytes32 _poolId\n    ) public view returns (bool) {\n        return isArrayContains(pendingExitPoolIds, _poolId);\n    }\n\n    function _transferTo(address recipient, uint amount) internal {\n        if (amount > address(this).balance) {\n            uint error_code = 1;\n            bytes memory errorData = abi.encode(\n                recipient,\n                amount,\n                address(this).balance\n            );\n            emit ErrorOccurred(\n                currentEpoch,\n                block.number,\n                error_code,\n                errorData\n            );\n            return;\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n\n        if (!success) {\n            uint error_code = 2;\n            bytes memory errorData = abi.encode(\n                recipient,\n                amount,\n                address(this).balance\n            );\n            emit ErrorOccurred(\n                currentEpoch,\n                block.number,\n                error_code,\n                errorData\n            );\n            return;\n        }\n    }\n\n    function updateValidator(\n        bytes32 _poolId,\n        string memory _description,\n        string memory _endpoint,\n        address _new_owner\n    ) external {\n        require(validators[_poolId].poolId != 0, \"Validator does not exist\");\n        require(\n            validators[_poolId].owner == msg.sender,\n            \"Validator does not exist\"\n        );\n        require(\n            isValidatorActive(_poolId) || isValidatorPendingAdd(_poolId),\n            \"Validator status invalid\"\n        );\n        require(_new_owner != address(0), \"Invalid new address\");\n        // Add more checks here to ensure only the validator can update their info\n\n        validators[_poolId].description = _description;\n        validators[_poolId].endpoint = _endpoint;\n        validators[_poolId].owner = _new_owner;\n\n        emit ValidatorUpdated(_poolId);\n    }\n\n    function advanceEpoch() public onlyOwner {\n        bytes32[] memory _poolIds = new bytes32[](0);\n        uint256[] memory _priority_fees = new uint256[](0);\n        advanceEpoch(_poolIds, _priority_fees);\n    }\n\n    function advanceEpoch(\n        bytes32[] memory _poolIds,\n        uint256[] memory _priority_fees\n    ) public onlyOwner {\n        require(\n            _poolIds.length == _priority_fees.length,\n            \"PoolId Fees not match\"\n        );\n\n        setChainEpochBlock();\n        currentEpoch++;\n\n        emit EpochChange(\n            currentEpoch,\n            block.number,\n            block.timestamp,\n            totalStake,\n            activePoolIds\n        );\n    }\n\n    function setChainEpochBlock() internal {\n        SysChainCfg sys_chain_cfg = SysChainCfg(sysChainCfg);\n        string[] memory keys = new string[](2);\n        string[] memory values = new string[](2);\n\n        string memory epoch_num_key = \"chain.epoch_start_block\";\n        string memory epoch_num_value = Strings.toString(block.number);\n        keys[0] = epoch_num_key;\n        values[0] = epoch_num_value;\n\n        string memory epoch_time_key = \"chain.epoch_start_timestamp\";\n        string memory epoch_time_value = Strings.toString(block.timestamp);\n        keys[1] = epoch_time_key;\n        values[1] = epoch_time_value;\n\n        sys_chain_cfg.set_config(keys, values);\n    }\n\n    function getActiveValidators() external view returns (bytes32[] memory) {\n        return activePoolIds;\n    }\n\n    function getPendingAddValidators()\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return pendingAddPoolIds;\n    }\n\n    function getPendingExitValidators()\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return pendingExitPoolIds;\n    }\n\n    function getWithdrawEffectiveWindow() internal view returns (uint8) {\n        string memory key = \"staking.withdraw_effective_epoch\";\n        string memory value = getChainCfg(key);\n        return uint8(Strings.parseUint(value));\n    }\n\n    function getChainCfg(\n        string memory key\n    ) internal view returns (string memory) {\n        SysChainCfg sys_chain_cfg = SysChainCfg(sysChainCfg);\n        return sys_chain_cfg.get_config(key);\n    }\n\n    receive() external payable {\n        emit BalanceReceived(\n            currentEpoch,\n            block.number,\n            msg.sender,\n            msg.value,\n            address(this).balance\n        );\n    }\n}",
        "rule_mng.sol": "\npragma solidity ^0.8.20;\n\n\ncontract InferRuleManager {\n\n    enum CreateMethod { Create, Create2 }\n    enum RuleState { INIT, UPDATED, IN_PROVING, PROVING_SUCCESS, PROVING_FAILURE, IN_USE}\n\n    struct InferRule {\n        uint64 id_;                 // unque id for InferRule\n        bytes4 selctor_;            // filter: selctor\n        address contract_;          // filter: contract\n\n        bytes32 metahash_;          // filter: metadata_hash https://solidity-cn.readthedocs.io/zh/develop/metadata.html#id2\n\n        address adder_;             // rule adder address\n        uint32 type_;               // see: infer type define\n        uint32 prove_threshold_;    // rule state change threshold of verified txs\n        RuleState state_;           // 0=INIT,1=UPDATED,2=IN_PROVING,3=PROVING_SUCCESS,4=PROVING_FAILURE,5=IN_USE\n\n        bytes code_;                // user defined infer rule\n    }\n\n    // slot 0\n    mapping(uint64 => InferRule) private rules_;\n    // slot 1\n    mapping(address => uint64 []) private contract_rules_;\n    // slot 2\n    uint64 [] private active_ids_;\n    // slot 3\n    uint64 [] private wait_prove_rules_;\n    // slot 4\n    uint64 [] private success_rules_;\n\n    // slot 5\n    address private administrator_;\n    uint64 private next_id_;\n    uint32 private prove_threshold_; // Number of verified transactions required for rule from IN_PROVING to PROVING_SUCCESS\n\n    // grantees were grant admin permission\n    address [] private grantees_;\n\n    constructor(uint32 _prove_threshold) {\n        administrator_ = msg.sender;\n        next_id_ = 1;\n        prove_threshold_ = _prove_threshold;\n    }\n\n    function checkExist(address _addr, bytes4 _selector, bytes32 _metahash) private view returns(bool) {\n        require(_addr != address(0) || _metahash != bytes32(0), \"InferRule address AND metahash is 0.\");\n        if (contract_rules_[_addr].length == 0) {\n            return false;\n        }\n        for (uint64 i = 0; i < contract_rules_[_addr].length; ++i) {\n            if (rules_[contract_rules_[_addr][i]].selctor_ == _selector) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function checkExist(uint64 _id) private view returns(bool) {\n        if (rules_[_id].id_ == uint64(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    function checkSuperPermission(address _addr) private view returns(bool) {\n        if (_addr == administrator_ || _addr == address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function checkGrantPermission(address _addr) private view returns(bool) {\n        for (uint256 i = 0; i < grantees_.length; i++) {\n            if (grantees_[i] == _addr) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    function checkAdminPermission(address _addr) private view returns(bool) {\n        if (checkSuperPermission(_addr) || checkGrantPermission(_addr)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function checkPermission(bytes32 _metahash) private view returns(bool) {\n        if (checkAdminPermission(msg.sender)) {\n            return true;\n        }\n        if (_metahash != bytes32(0)) {\n            return false;\n        }\n\n        return false;\n    }\n\n    function checkPermission(address _adder) private view returns(bool) {\n        if (checkAdminPermission(msg.sender) || msg.sender == _adder) {\n            return true;\n        }\n\n        return false;\n    }\n\n    event RuleAdded(\n        address from_,\n        uint64 id_,\n        uint32 type_,\n        uint32 prove_threshold_,\n        RuleState state_,\n        address contract_,\n        bytes4 selctor_,\n        bytes32 metahash_,\n        bytes code_\n    );\n\n    function addRule(uint32 _type, address _addr, bytes4 _selector, bytes32 _metahash, bytes calldata _code) public returns (uint64) {\n        require(checkPermission(_metahash), \"Permission denied: Only chairpersons can add rule.\");\n        require(!checkExist(_addr, _selector, _metahash), \"InferRule already exist\");\n\n        uint64 _id = next_id_++;\n\n        rules_[_id] = InferRule(_id, _selector, _addr, _metahash, msg.sender, _type, prove_threshold_, RuleState.INIT, _code);\n\n        active_ids_.push(_id);\n        contract_rules_[_addr].push(_id);\n\n        // update to wait_prove_rules_\n        wait_prove_rules_.push(_id);\n\n        emit RuleAdded(msg.sender, _id, _type, prove_threshold_, RuleState.INIT, _addr, _selector, _metahash, _code);\n        return _id;\n    }\n\n    event RuleUpdated(\n        address from_,\n        uint64 id_,\n        uint32 type_,\n        uint32 prove_threshold_,\n        RuleState state_,\n        address contract_,\n        bytes4 selctor_,\n        bytes32 metahash_,\n        bytes code_\n    );\n\n    function updateRule(uint64 _id, uint32 _type, address _addr, bytes4 _selector, bytes32 _metahash, bytes calldata _code) public returns (uint64) {\n        require(checkExist(_id), \"InferRule not exist\");\n        require(checkPermission(rules_[_id].adder_), \"Permission denied: Only chairpersons can update rule.\");\n        require((rules_[_id].contract_ == _addr) && (rules_[_id].selctor_ == _selector) && (rules_[_id].metahash_ == _metahash), \"Can't update rule filters\");\n\n        rules_[_id].type_ = _type;\n        rules_[_id].code_ = _code;\n        rules_[_id].state_ = RuleState.UPDATED;\n\n        // update to wait_prove_rules_\n        bool contain = false;\n        for (uint256 i = 0; i < wait_prove_rules_.length; i++) {\n            if (wait_prove_rules_[i] == _id) {\n                contain = true;\n                break;\n            }\n        }\n        if (!contain) {\n            wait_prove_rules_.push(_id);\n        }\n\n        // clear success_rules_ ids\n        for (uint256 i = 0; i < success_rules_.length; i++) {\n            if (success_rules_[i] == _id) {\n                success_rules_[i] = success_rules_[success_rules_.length - 1];\n                success_rules_.pop();\n                break;\n            }\n        }\n\n        emit RuleUpdated(msg.sender, _id, _type, prove_threshold_, rules_[_id].state_, _addr, _selector, _metahash, _code);\n        return _id;\n    }\n\n    event RuleDeleted(\n        address from_,\n        uint64 id_\n    );\n    function delRule(uint64 _id) public {\n        require(checkExist(_id), \"InferRule not exist\");\n        require(checkPermission(rules_[_id].adder_), \"Permission denied: Only chairpersons can delete rule.\");\n\n        InferRule memory rule = rules_[_id];\n        uint64[] storage contract_ids = contract_rules_[rule.contract_];\n\n        // clear contract index ids\n        for (uint i = 0; i < contract_ids.length; ++i) {\n            if (contract_ids[i] == _id) {\n                contract_ids[i] = contract_ids[contract_ids.length - 1];\n                contract_ids.pop();\n                break;\n            }\n        }\n        if (contract_ids.length == 0) {\n            delete contract_rules_[rule.contract_];\n        }\n\n        // clear active_ids ids\n        for (uint256 i = 0; i < active_ids_.length; i++) {\n            if (active_ids_[i] == _id) {\n                active_ids_[i] = active_ids_[active_ids_.length - 1];\n                active_ids_.pop();\n                break;\n            }\n        }\n        // clear wait_prove_rules_\n        for (uint i = 0; i < wait_prove_rules_.length; ++i) {\n            if (wait_prove_rules_[i] == _id) {\n                wait_prove_rules_[i] = wait_prove_rules_[wait_prove_rules_.length - 1];\n                wait_prove_rules_.pop();\n                break;\n            }\n        }\n        // clear success_rules_ ids\n        for (uint256 i = 0; i < success_rules_.length; i++) {\n            if (success_rules_[i] == _id) {\n                success_rules_[i] = success_rules_[success_rules_.length - 1];\n                success_rules_.pop();\n                break;\n            }\n        }\n\n        delete rules_[_id];\n        emit RuleDeleted(msg.sender, _id);\n    }\n\n    // return all register rules\n    function getAllRules() public view returns (InferRule[] memory) {\n        uint256 count = active_ids_.length;\n        InferRule[] memory allRules = new InferRule[](count);\n        uint64 index = 0;\n\n        for (uint256 i = 0; i < count; i++) {\n            uint64 id = active_ids_[i];\n            if (rules_[id].id_ != 0) {\n                allRules[index] = rules_[id];\n                index++;\n            }\n        }\n\n        return allRules;\n    }\n\n    // return next_id_\n    function getNextId() public view returns (uint64) {\n        return next_id_;\n    }\n\n    // return spec contract register rules\n    function getContractRules(address _addr) public view returns (InferRule[] memory) {\n        uint64[] storage ids = contract_rules_[_addr];\n        InferRule[] memory contractSpecificRules = new InferRule[](ids.length);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            contractSpecificRules[i] = rules_[ids[i]];\n        }\n        return contractSpecificRules;\n    }\n\n    event ProvingResultUpdated  (\n        address from_,\n        uint64[] success_ids_,\n        uint64[] fail_ids_\n    );\n\n    function updateProvingResult(uint64[] calldata _success_ids, uint64[] calldata _fail_ids) public {\n        require(checkAdminPermission(msg.sender), \"Only administrator can execute this.\");\n\n        // update success rule state\n        for (uint256 i = 0; i < _success_ids.length; i++) {\n            uint64 id = _success_ids[i];\n            require(checkExist(id), \"InferRule not exist\");\n\n            InferRule storage rule = rules_[id];\n            require(rule.state_ == RuleState.IN_PROVING, \"Invalid state transition\");\n            rule.state_ = RuleState.PROVING_SUCCESS;\n\n            // add to success list, and will change to IN_USE next epoch\n            success_rules_.push(id);\n        }\n\n        // update fails rule state\n        for (uint256 i = 0; i < _fail_ids.length; i++) {\n            uint64 id = _fail_ids[i];\n            require(checkExist(id), \"InferRule not exist\");\n\n            InferRule storage rule = rules_[id];\n            require(rule.state_ == RuleState.IN_PROVING, \"Invalid state transition\");\n            rule.state_ = RuleState.PROVING_FAILURE;\n        }\n\n        emit ProvingResultUpdated(msg.sender, _success_ids, _fail_ids);\n    }\n\n    event RuleInProving(\n        uint64[] ids_\n    );\n    event RuleInUse  (\n        uint64[] ids_\n    );\n    function advanceEpoch() external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        uint64[] memory wait_prove_ids = new uint64[](wait_prove_rules_.length);\n        uint256 count = 0;\n        for (uint256 i = 0; i < wait_prove_rules_.length; i++) {\n            uint64 id = wait_prove_rules_[i];\n            if (checkExist(id)) {\n                InferRule storage rule = rules_[id];\n                if (rule.state_ == RuleState.INIT || rule.state_ == RuleState.UPDATED) {\n                    rule.state_ = RuleState.IN_PROVING;\n                    wait_prove_ids[count] = id;\n                    count++;\n                }\n            }\n        }\n\n        if (count > 0) {\n            uint64[] memory proving_ids = new uint64[](count);\n            for (uint256 j = 0; j < count; j++) {\n                proving_ids[j] = wait_prove_ids[j];\n            }\n            emit RuleInProving(proving_ids);\n            delete wait_prove_rules_;\n        }\n\n        if (success_rules_.length > 0) {\n            for (uint256 i = 0; i < success_rules_.length; i++) {\n                uint64 id = success_rules_[i];\n                if (checkExist(id)) {\n                    InferRule storage rule = rules_[id];\n                    if (rule.state_ == RuleState.PROVING_SUCCESS) {\n                        rule.state_ = RuleState.IN_USE;\n                    }\n                }\n            }\n            emit RuleInUse(success_rules_);\n            delete success_rules_;\n        }\n    }\n\n    event SuperTransferred(\n        address old_administrator_,\n        address new_administrator_\n    );\n    function tranferSuperAdmin(address _new_admin) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(administrator_ != _new_admin, \"Permission denied, same address\");\n\n        address old_admin = administrator_;\n        administrator_ = _new_admin;\n        emit SuperTransferred(old_admin, _new_admin);\n    }\n\n    // return administrator_\n    function getSuperAdmin() public view returns (address) {\n        return administrator_;\n    }\n\n    // return administrator_\n    function getGranteeAdmin() public view returns ( address[] memory) {\n        return grantees_;\n    }\n\n    event AdminGranted(\n        address grantee\n    );\n    function grantAdmin(address _addr) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(!checkGrantPermission(_addr), \"Address already exist in grantees\");\n\n        grantees_.push(_addr);\n        emit AdminGranted(_addr);\n    }\n    event AdminRevoked(\n        address revoker\n    );\n    function revokeAdmin(address _addr) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(checkGrantPermission(_addr), \"Address not exist in grantees\");\n\n        for (uint256 i = 0; i < grantees_.length; i++) {\n            if (grantees_[i] == _addr) {\n                grantees_[i] = grantees_[grantees_.length - 1];\n                grantees_.pop();\n                break;\n            }\n        }\n\n        emit AdminRevoked(_addr);\n    }\n}\n",
        "permission_control.sol": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.20;\n\ncontract PermissionControl {\n    address private administrator_;\n    // todo add grants admin\n    address [] private grantees_;\n\n    constructor() {\n        administrator_ = msg.sender;\n    }\n\n    function checkSuperPermission(address _addr) internal view returns(bool) {\n        if (_addr == administrator_ || _addr == address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function checkAdminPermission(address _addr) internal view returns(bool) {\n        if (checkSuperPermission(_addr) || checkGrantPermission(_addr)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function checkGrantPermission(address _addr) internal view returns(bool) {\n        for (uint256 i = 0; i < grantees_.length; i++) {\n            if (grantees_[i] == _addr) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    event SuperTransferred(\n        address old_administrator_,\n        address new_administrator_\n    );\n    function tranferSuperAdmin(address _new_admin) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(administrator_ != _new_admin, \"Permission denied, same address\");\n\n        address old_admin = administrator_;\n        administrator_ = _new_admin;\n        emit SuperTransferred(old_admin, _new_admin);\n    }\n\n    // return administrator_\n    function getSuperAdmin() public view returns (address) {\n        return administrator_;\n    }\n\n    // return administrator_\n    function getGranteeAdmin() public view returns ( address[] memory) {\n        return grantees_;\n    }\n\n    event AdminGranted(\n        address grantee\n    );\n    function grantAdmin(address _addr) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(!checkGrantPermission(_addr), \"Address already exist in grantees\");\n\n        grantees_.push(_addr);\n        emit AdminGranted(_addr);\n    }\n    event AdminRevoked(\n        address revoker\n    );\n    function revokeAdmin(address _addr) external {\n        require(checkSuperPermission(msg.sender), \"Permission denied\");\n        require(checkGrantPermission(_addr), \"Address not exist in grantees\");\n\n        for (uint256 i = 0; i < grantees_.length; i++) {\n            if (grantees_[i] == _addr) {\n                grantees_[i] = grantees_[grantees_.length - 1];\n                grantees_.pop();\n                break;\n            }\n        }\n\n        emit AdminRevoked(_addr);\n    }\n}",
        "sys_chaincfg.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ChainCfg {\n    struct Config {\n        string key;\n        string value;\n    }\n\n    struct ConfigCheckpoint {\n        uint64 blockNum;\n        uint64 effectiveBlockNum;\n        Config[] configs;\n    }\n\n\n    ConfigCheckpoint[] configCps;\n\n    event ConfigUpdate(uint64 indexed blockNum, uint64 indexed effectiveBlockNum, string[] keys, string[] values);\n    \n    address public rootSys;\n    address public constant sysStaking = 0x4100000000000000000000000000000000000000;\n    address public constant intrinsicSys = 0x1111111111111111111111111111111111111111;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == rootSys || msg.sender == sysStaking || msg.sender == intrinsicSys, \"Not owner\");\n        _;\n    }\n\n    function changeSys(address _newOwner)\n        public\n        onlyOwner\n    {\n        rootSys = _newOwner;\n    }\n\n    function get_config(string memory key) public view returns (string memory) {\n        if (configCps.length != 0) {\n            for (uint256 i = 0; i < configCps[configCps.length - 1].configs.length; i++) {\n                Config storage conf = configCps[configCps.length - 1].configs[i];\n                if (keccak256(abi.encodePacked(key)) == keccak256(abi.encodePacked(conf.key))) {\n                    return conf.value;\n                }\n            }\n        }\n        return \"\";\n    }\n\n    function get_configs() public view returns (Config[] memory) {\n        if (configCps.length != 0) {\n            return configCps[configCps.length - 1].configs;\n        }\n        Config[] memory configs;\n        return configs;\n    }\n\n    function set_config(string[] memory keys, string[] memory values) external onlyOwner {\n        require(keys.length == values.length, \"KVs are not match\");\n        if (configCps.length == 3) {\n            delete configCps[0];\n            for (uint256 i = 1; i < configCps.length; i++) {\n                configCps[i - 1] = configCps[i];\n            }\n            configCps.pop(); \n        }\n\n        uint256 old_config_cps_number = configCps.length;\n\n        ConfigCheckpoint storage cfgCp = configCps.push();\n        cfgCp.blockNum = uint64(block.number);\n        cfgCp.effectiveBlockNum = uint64(block.number + 1);\n\n        if (old_config_cps_number != 0) {\n            require(configCps[configCps.length - 2].effectiveBlockNum <= block.number, \"INVALID_STATE\");\n\n            for (uint256 i = 0; i < configCps[configCps.length - 2].configs.length; i++) {\n                Config storage conf = configCps[configCps.length - 2].configs[i];\n                bool found = false;\n                for (uint256 j = 0; j < keys.length; j++) {\n                    if (keccak256(abi.encodePacked(conf.key)) == keccak256(abi.encodePacked(keys[j]))) {\n                        found = true; \n                        break;\n                    }\n                }\n                if (!found) {\n                    cfgCp.configs.push(Config({\n                        key: conf.key,\n                        value: conf.value\n                    }));\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            cfgCp.configs.push(Config({\n                key: keys[i],\n                value: values[i]\n            }));\n        }\n\n        emit ConfigUpdate(uint64(block.number), uint64(block.number + 1), keys, values);\n    }\n}"
    }
}