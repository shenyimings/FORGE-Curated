{
    "vfp_id": "vfp_00586",
    "project_name": "cantina_generic_money_nov2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Message id's are not strictly unique which potentially prevents rollbacks",
            "description": "Message IDs are generated using target chain ID, bridge type, timestamp, and nonce, but do not include the source chain ID. This can result in ID collisions if two adapters on different chains create messages with identical parameters. Since rollback mechanisms rely on unique message IDs, a collision could overwrite failure records, allowing only the last failed message to be rolled back. This undermines the reliability of the rollback system and could prevent recovery from failed cross-chain messages, leading to inconsistent state or loss of message integrity.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "7a6c887b/generic-bridging/src/BridgeCoordinatorL1.sol",
                "7a6c887b/generic-bridging/src/BridgeCoordinatorL2.sol"
            ]
        }
    ],
    "affected_files": {
        "BridgeCoordinatorL2.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { BridgeCoordinator } from \"./coordinator/BridgeCoordinator.sol\";\nimport { IERC20Mintable } from \"./interfaces/IERC20Mintable.sol\";\nimport { IWhitelabeledUnit } from \"./interfaces/IWhitelabeledUnit.sol\";\n\n/**\n * @title BridgeCoordinatorL2\n * @notice L2-specific implementation of bridge coordinator that burns/mints units instead of transferring\n * @dev Extends BridgeCoordinator with proper token lifecycle management for L2 deployments.\n * Burns units when bridging out and mints units when bridging in, maintaining total supply consistency.\n */\ncontract BridgeCoordinatorL2 is BridgeCoordinator {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Burns units when bridging out from L2\n     * @dev Overrides base implementation to burn units\n     * @param whitelabel The whitelabeled unit token address, or zero address for native unit token\n     * @param owner The address that owns the units to be burned\n     * @param amount The amount of units to burn\n     */\n    function _restrictUnits(address whitelabel, address owner, uint256 amount) internal override {\n        if (whitelabel == address(0)) {\n            IERC20Mintable(genericUnit).burn(owner, address(this), amount);\n        } else {\n            IWhitelabeledUnit(whitelabel).unwrap(owner, address(this), amount);\n            IERC20Mintable(genericUnit).burn(address(this), address(this), amount);\n        }\n\n        // Note: Burn would fail if unwrapping did not transfer the correct amount\n    }\n\n    /**\n     * @notice Mints units when bridging in to L2\n     * @dev Overrides base implementation to mint new units\n     * @param whitelabel The whitelabeled unit token address, or zero address for native unit token\n     * @param receiver The address that should receive the newly minted units\n     * @param amount The amount of units to mint\n     */\n    function _releaseUnits(address whitelabel, address receiver, uint256 amount) internal override {\n        if (whitelabel == address(0)) {\n            IERC20Mintable(genericUnit).mint(receiver, amount);\n        } else {\n            IERC20Mintable(genericUnit).mint(address(this), amount);\n            IERC20(genericUnit).forceApprove(address(whitelabel), amount);\n            IWhitelabeledUnit(whitelabel).wrap(receiver, amount);\n        }\n    }\n}\n",
        "BridgeCoordinatorL1.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { BridgeCoordinator } from \"./coordinator/BridgeCoordinator.sol\";\nimport { PredepositCoordinator } from \"./coordinator/PredepositCoordinator.sol\";\nimport { IWhitelabeledUnit } from \"./interfaces/IWhitelabeledUnit.sol\";\n\n/**\n * @title BridgeCoordinatorL1\n * @notice L1-specific BridgeCoordinator that includes predeposit functionality and handles units locking/unlocking\n * @dev Inherits from BridgeCoordinator and PredepositCoordinator to provide full bridge coordination\n * capabilities along with predeposit handling on Layer 1. Implements unit restriction and release logic\n * by transferring units to/from the coordinator contract, with support for whitelabeled units.\n */\ncontract BridgeCoordinatorL1 is BridgeCoordinator, PredepositCoordinator {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Thrown when the amount of unit tokens restricted does not match the expected amount\n     */\n    error IncorrectEscrowBalance();\n\n    /**\n     * @notice Lock units when bridging out\n     * @dev This function implements additional validation layers since whitelabel units could potentially\n     * be malicious or poorly implemented.\n     * @param whitelabel The whitelabeled unit token address, or zero address for native unit token\n     * @param owner The address that owns the units to be restricted\n     * @param amount The amount of units to restrict\n     */\n    function _restrictUnits(address whitelabel, address owner, uint256 amount) internal override {\n        uint256 escrowBalance = IERC20(genericUnit).balanceOf(address(this));\n        if (whitelabel == address(0)) {\n            IERC20(genericUnit).safeTransferFrom(owner, address(this), amount);\n        } else {\n            IWhitelabeledUnit(whitelabel).unwrap(owner, address(this), amount);\n        }\n\n        // Note: Sanity check that the expected amount of units were actually transferred\n        // Whitelabeled units could have faulty implementations that do not transfer the correct amount\n        require(IERC20(genericUnit).balanceOf(address(this)) == escrowBalance + amount, IncorrectEscrowBalance());\n    }\n\n    /**\n     * @notice Unlock units when bridging in\n     * @param whitelabel The whitelabeled unit token address, or zero address for native unit token\n     * @param receiver The address that should receive the released units\n     * @param amount The amount of units to release\n     */\n    function _releaseUnits(address whitelabel, address receiver, uint256 amount) internal override {\n        if (whitelabel == address(0)) {\n            IERC20(genericUnit).safeTransfer(receiver, amount);\n        } else {\n            IERC20(genericUnit).forceApprove(address(whitelabel), amount);\n            IWhitelabeledUnit(whitelabel).wrap(receiver, amount);\n        }\n    }\n}\n"
    }
}