{
    "vfp_id": "vfp_00430",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "W5: Node operators can self-refer",
            "description": "The CSVettedGate and CSModule contracts allow a node operator to set their own address as the referrer, enabling self-referral. While this is intended in CSModule.sol, it was not intended in CSVettedGate.sol, where it could distort referral incentives. The root cause is the absence of a self-reference check in CSVettedGate. This is a logic error that could be exploited to game referral rewards. The issue was partially fixed by adding a check in CSVettedGate, but self-referral remains allowed in CSModule as intended.\n",
            "severity": "Informational",
            "location": [
                "CSVettedGate.sol",
                "CSModule.sol"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/VettedGate.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ],
                "3": [
                    "CWE-483"
                ]
            },
            "title": "W10: Unconditional emission of ReferralRecorded event",
            "description": "The `VettedGate.recordReferral` function unconditionally emits the `ReferralRecorded` event, even when the referral season is inactive or the referrer is invalid. This occurs because the event emission is placed outside the conditional block that checks `isReferralProgramSeasonActive`. The cause is incorrect placement of event emission logic. Off-chain systems that listen for this event may incorrectly interpret it as a valid referral, leading to inaccurate tracking and potential misuse of referral data. While this does not directly affect on-chain state or fund security, it compromises the integrity of referral analytics and may mislead integrators relying on event logs for business logic.\n",
            "severity": "Informational",
            "location": [
                "VettedGate.sol::_bumpReferralCount#388"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/VettedGate.sol"
            ]
        }
    ],
    "affected_files": {
        "VettedGate.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport { AssetRecoverer } from \"./abstract/AssetRecoverer.sol\";\n\nimport { PausableUntil } from \"./lib/utils/PausableUntil.sol\";\n\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSModule, NodeOperatorManagementProperties } from \"./interfaces/ICSModule.sol\";\nimport { IVettedGate } from \"./interfaces/IVettedGate.sol\";\n\ncontract VettedGate is\n    IVettedGate,\n    AccessControlEnumerableUpgradeable,\n    PausableUntil,\n    AssetRecoverer\n{\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n    bytes32 public constant SET_TREE_ROLE = keccak256(\"SET_TREE_ROLE\");\n    bytes32 public constant START_REFERRAL_SEASON_ROLE =\n        keccak256(\"START_REFERRAL_SEASON_ROLE\");\n    bytes32 public constant END_REFERRAL_SEASON_ROLE =\n        keccak256(\"END_REFERRAL_SEASON_ROLE\");\n\n    /// @dev Address of the Staking Module\n    ICSModule public immutable MODULE;\n\n    /// @dev Address of the CS Accounting\n    ICSAccounting public immutable ACCOUNTING;\n\n    /// @dev Id of the bond curve to be assigned for the eligible members\n    uint256 public curveId;\n\n    /// @dev Root of the eligible members Merkle Tree\n    bytes32 public treeRoot;\n\n    /// @dev CID of the eligible members Merkle Tree\n    string public treeCid;\n\n    mapping(address => bool) internal _consumedAddresses;\n\n    /////////////////////////////////\n    /// Optional referral program ///\n    /////////////////////////////////\n\n    bool public isReferralProgramSeasonActive;\n\n    uint256 public referralProgramSeasonNumber;\n\n    /// @dev Id of the bond curve for referral program\n    uint256 public referralCurveId;\n\n    /// @dev Number of referrals required for bond curve claim\n    uint256 public referralsThreshold;\n\n    /// @dev Referral counts for referrers for seasons\n    mapping(bytes32 => uint256) internal _referralCounts;\n\n    mapping(bytes32 => bool) internal _consumedReferrers;\n\n    constructor(address module) {\n        if (module == address(0)) {\n            revert ZeroModuleAddress();\n        }\n\n        MODULE = ICSModule(module);\n        ACCOUNTING = ICSAccounting(MODULE.accounting());\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 _curveId,\n        bytes32 _treeRoot,\n        string calldata _treeCid,\n        address admin\n    ) external initializer {\n        __AccessControlEnumerable_init();\n\n        if (_curveId == ACCOUNTING.DEFAULT_BOND_CURVE_ID()) {\n            revert InvalidCurveId();\n        }\n\n        // @dev there is no check for curve existence as this contract might be created before the curve is added\n        curveId = _curveId;\n\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        _setTreeParams(_treeRoot, _treeCid);\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IVettedGate\n    function resume() external onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /// @inheritdoc IVettedGate\n    function pauseFor(uint256 duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(duration);\n    }\n\n    /// @inheritdoc IVettedGate\n    function startNewReferralProgramSeason(\n        uint256 _referralCurveId,\n        uint256 _referralsThreshold\n    ) external onlyRole(START_REFERRAL_SEASON_ROLE) returns (uint256 season) {\n        if (isReferralProgramSeasonActive) {\n            revert ReferralProgramIsActive();\n        }\n        if (_referralCurveId == ACCOUNTING.DEFAULT_BOND_CURVE_ID()) {\n            revert InvalidCurveId();\n        }\n        if (_referralsThreshold == 0) {\n            revert InvalidReferralsThreshold();\n        }\n\n        referralCurveId = _referralCurveId;\n        referralsThreshold = _referralsThreshold;\n        isReferralProgramSeasonActive = true;\n\n        season = referralProgramSeasonNumber + 1;\n        referralProgramSeasonNumber = season;\n\n        emit ReferralProgramSeasonStarted(\n            season,\n            _referralCurveId,\n            _referralsThreshold\n        );\n    }\n\n    /// @inheritdoc IVettedGate\n    function endCurrentReferralProgramSeason()\n        external\n        onlyRole(END_REFERRAL_SEASON_ROLE)\n    {\n        if (\n            !isReferralProgramSeasonActive || referralProgramSeasonNumber == 0\n        ) {\n            revert ReferralProgramIsNotActive();\n        }\n\n        isReferralProgramSeasonActive = false;\n\n        emit ReferralProgramSeasonEnded(referralProgramSeasonNumber);\n    }\n\n    /// @inheritdoc IVettedGate\n    function addNodeOperatorETH(\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        NodeOperatorManagementProperties calldata managementProperties,\n        bytes32[] calldata proof,\n        address referrer\n    ) external payable whenResumed returns (uint256 nodeOperatorId) {\n        _consume(proof);\n\n        nodeOperatorId = MODULE.createNodeOperator({\n            from: msg.sender,\n            managementProperties: managementProperties,\n            referrer: referrer\n        });\n        ACCOUNTING.setBondCurve(nodeOperatorId, curveId);\n        MODULE.addValidatorKeysETH{ value: msg.value }({\n            from: msg.sender,\n            nodeOperatorId: nodeOperatorId,\n            keysCount: keysCount,\n            publicKeys: publicKeys,\n            signatures: signatures\n        });\n\n        _bumpReferralCount(referrer, nodeOperatorId);\n    }\n\n    /// @inheritdoc IVettedGate\n    function addNodeOperatorStETH(\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        NodeOperatorManagementProperties calldata managementProperties,\n        ICSAccounting.PermitInput calldata permit,\n        bytes32[] calldata proof,\n        address referrer\n    ) external whenResumed returns (uint256 nodeOperatorId) {\n        _consume(proof);\n\n        nodeOperatorId = MODULE.createNodeOperator({\n            from: msg.sender,\n            managementProperties: managementProperties,\n            referrer: referrer\n        });\n        ACCOUNTING.setBondCurve(nodeOperatorId, curveId);\n        MODULE.addValidatorKeysStETH({\n            from: msg.sender,\n            nodeOperatorId: nodeOperatorId,\n            keysCount: keysCount,\n            publicKeys: publicKeys,\n            signatures: signatures,\n            permit: permit\n        });\n\n        _bumpReferralCount(referrer, nodeOperatorId);\n    }\n\n    /// @inheritdoc IVettedGate\n    function addNodeOperatorWstETH(\n        uint256 keysCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures,\n        NodeOperatorManagementProperties calldata managementProperties,\n        ICSAccounting.PermitInput calldata permit,\n        bytes32[] calldata proof,\n        address referrer\n    ) external whenResumed returns (uint256 nodeOperatorId) {\n        _consume(proof);\n\n        nodeOperatorId = MODULE.createNodeOperator({\n            from: msg.sender,\n            managementProperties: managementProperties,\n            referrer: referrer\n        });\n        ACCOUNTING.setBondCurve(nodeOperatorId, curveId);\n        MODULE.addValidatorKeysWstETH({\n            from: msg.sender,\n            nodeOperatorId: nodeOperatorId,\n            keysCount: keysCount,\n            publicKeys: publicKeys,\n            signatures: signatures,\n            permit: permit\n        });\n\n        _bumpReferralCount(referrer, nodeOperatorId);\n    }\n\n    /// @inheritdoc IVettedGate\n    function claimBondCurve(\n        uint256 nodeOperatorId,\n        bytes32[] calldata proof\n    ) external whenResumed {\n        _onlyNodeOperatorOwner(nodeOperatorId);\n\n        _consume(proof);\n\n        ACCOUNTING.setBondCurve(nodeOperatorId, curveId);\n    }\n\n    /// @inheritdoc IVettedGate\n    function claimReferrerBondCurve(\n        uint256 nodeOperatorId,\n        bytes32[] calldata proof\n    ) external whenResumed {\n        _onlyNodeOperatorOwner(nodeOperatorId);\n\n        // @dev Only members from the current merkle tree can claim the referral bond curve\n        if (!verifyProof(msg.sender, proof)) {\n            revert InvalidProof();\n        }\n\n        if (!isReferralProgramSeasonActive) {\n            revert ReferralProgramIsNotActive();\n        }\n\n        uint256 season = referralProgramSeasonNumber;\n        bytes32 referrer = _seasonedAddress(msg.sender, season);\n\n        if (_referralCounts[referrer] < referralsThreshold) {\n            revert NotEnoughReferrals();\n        }\n\n        if (_consumedReferrers[referrer]) {\n            revert AlreadyConsumed();\n        }\n\n        _consumedReferrers[referrer] = true;\n\n        emit ReferrerConsumed(msg.sender, season);\n\n        ACCOUNTING.setBondCurve(nodeOperatorId, referralCurveId);\n    }\n\n    /// @inheritdoc IVettedGate\n    function setTreeParams(\n        bytes32 _treeRoot,\n        string calldata _treeCid\n    ) external onlyRole(SET_TREE_ROLE) {\n        _setTreeParams(_treeRoot, _treeCid);\n    }\n\n    /// @inheritdoc IVettedGate\n    function getReferralsCount(\n        address referrer\n    ) external view returns (uint256) {\n        return _referralCounts[_seasonedAddress(referrer)];\n    }\n\n    /// @inheritdoc IVettedGate\n    function getReferralsCount(\n        address referrer,\n        uint256 season\n    ) external view returns (uint256) {\n        return _referralCounts[_seasonedAddress(referrer, season)];\n    }\n\n    /// @inheritdoc IVettedGate\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /// @inheritdoc IVettedGate\n    function isReferrerConsumed(address referrer) external view returns (bool) {\n        return _consumedReferrers[_seasonedAddress(referrer)];\n    }\n\n    /// @inheritdoc IVettedGate\n    function isConsumed(address member) public view returns (bool) {\n        return _consumedAddresses[member];\n    }\n\n    /// @inheritdoc IVettedGate\n    function verifyProof(\n        address member,\n        bytes32[] calldata proof\n    ) public view returns (bool) {\n        return MerkleProof.verifyCalldata(proof, treeRoot, hashLeaf(member));\n    }\n\n    /// @inheritdoc IVettedGate\n    function hashLeaf(address member) public pure returns (bytes32) {\n        return keccak256(bytes.concat(keccak256(abi.encode(member))));\n    }\n\n    function _consume(bytes32[] calldata proof) internal {\n        if (isConsumed(msg.sender)) {\n            revert AlreadyConsumed();\n        }\n\n        if (!verifyProof(msg.sender, proof)) {\n            revert InvalidProof();\n        }\n\n        _consumedAddresses[msg.sender] = true;\n\n        emit Consumed(msg.sender);\n    }\n\n    function _setTreeParams(\n        bytes32 _treeRoot,\n        string calldata _treeCid\n    ) internal {\n        if (_treeRoot == bytes32(0)) {\n            revert InvalidTreeRoot();\n        }\n        if (_treeRoot == treeRoot) {\n            revert InvalidTreeRoot();\n        }\n\n        if (bytes(_treeCid).length == 0) {\n            revert InvalidTreeCid();\n        }\n        if (keccak256(bytes(_treeCid)) == keccak256(bytes(treeCid))) {\n            revert InvalidTreeCid();\n        }\n\n        treeRoot = _treeRoot;\n        treeCid = _treeCid;\n\n        emit TreeSet(_treeRoot, _treeCid);\n    }\n\n    function _bumpReferralCount(\n        address referrer,\n        uint256 referralNodeOperatorId\n    ) internal {\n        uint256 season = referralProgramSeasonNumber;\n        if (isReferralProgramSeasonActive && referrer != address(0)) {\n            _referralCounts[_seasonedAddress(referrer, season)] += 1;\n        }\n        emit ReferralRecorded(referrer, season, referralNodeOperatorId);\n    }\n\n    function _seasonedAddress(\n        address referrer\n    ) internal view returns (bytes32) {\n        return _seasonedAddress(referrer, referralProgramSeasonNumber);\n    }\n\n    /// @dev Verifies that the sender is the owner of the node operator\n    function _onlyNodeOperatorOwner(uint256 nodeOperatorId) internal view {\n        address owner = MODULE.getNodeOperatorOwner(nodeOperatorId);\n        if (owner == address(0)) {\n            revert NodeOperatorDoesNotExist();\n        }\n        if (owner != msg.sender) {\n            revert NotAllowedToClaim();\n        }\n    }\n\n    function _onlyRecoverer() internal view override {\n        _checkRole(RECOVERER_ROLE);\n    }\n\n    function _seasonedAddress(\n        address referrer,\n        uint256 season\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(referrer, season));\n    }\n}\n"
    }
}