{
    "vfp_id": "vfp_00384",
    "project_name": "cantina_coinbase_flywheel_sep2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Excessive fees can prevent users from receiving bridged funds immediately",
            "description": "The BridgeRewards hook reverts if the feeBps exceeds a limit, which locks user funds in the bridge until the issue is resolved. The root cause is a strict validation that reverts instead of capping the fee. There is no direct exploitation path, but malicious or misconfigured fee settings could delay fund delivery. The impact is temporary fund lockup, degrading user experience and trust in the bridging mechanism.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "flywheel/src/hooks/BridgeRewards.sol"
            ]
        }
    ],
    "affected_files": {
        "BridgeRewards.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {BuilderCodes} from \"../BuilderCodes.sol\";\nimport {CampaignHooks} from \"../CampaignHooks.sol\";\nimport {Flywheel} from \"../Flywheel.sol\";\n\n/// @title BridgeRewards\n///\n/// @notice This contract is used to configure bridge rewards for Base builder codes. It is expected to be used in\n///         conjunction with the BuilderCodes contract that manages codes registration. Once registered, this contract\n///         allows the builder to start receiving rewards for each usage of the code during a bridge operation that\n///         involves a transfer of tokens.\ncontract BridgeRewards is CampaignHooks {\n    /// @notice ERC-7528 address for native token\n    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Maximum fee basis points (2.00%)\n    uint256 public constant MAX_FEE_BASIS_POINTS = 2_00;\n\n    /// @notice Address of the BuilderCodes contract\n    BuilderCodes public immutable builderCodes;\n\n    /// @notice Metadata URI for the campaign\n    string public metadataURI;\n\n    /// @notice Error thrown to enforce only one campaign can be initialized\n    error InvalidCampaignInitialization();\n\n    /// @notice Error thrown when the balance is zero\n    error ZeroAmount();\n\n    /// @notice Error thrown when the fee basis points is too high\n    error FeeBasisPointsTooHigh();\n\n    /// @notice Error thrown when the builder code is not registered\n    error BuilderCodeNotRegistered();\n\n    /// @notice Hooks constructor\n    ///\n    /// @param flywheel_ Address of the flywheel contract\n    constructor(address flywheel_, address builderCodes_, string memory metadataURI_) CampaignHooks(flywheel_) {\n        builderCodes = BuilderCodes(builderCodes_);\n        metadataURI = metadataURI_;\n    }\n\n    /// @inheritdoc CampaignHooks\n    function campaignURI(address campaign) external view override returns (string memory uri) {\n        return metadataURI;\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onCreateCampaign(address campaign, uint256 nonce, bytes calldata hookData) internal override {\n        if (nonce != 0 || hookData.length > 0) revert InvalidCampaignInitialization();\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onSend(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        returns (\n            Flywheel.Payout[] memory payouts,\n            Flywheel.Payout[] memory immediateFees,\n            Flywheel.Allocation[] memory /*delayedFees*/\n        )\n    {\n        (address user, bytes32 code, uint16 feeBps) = abi.decode(hookData, (address, bytes32, uint16));\n\n        // Check balance is nonzero\n        uint256 balance = token == NATIVE_TOKEN ? campaign.balance : IERC20(token).balanceOf(campaign);\n        require(balance > 0, ZeroAmount());\n\n        // Check builder code is registered\n        require(builderCodes.ownerOf(uint256(code)) != address(0), BuilderCodeNotRegistered());\n\n        // Compute fee amount\n        require(feeBps <= MAX_FEE_BASIS_POINTS, FeeBasisPointsTooHigh());\n        uint256 feeAmount = (balance * feeBps) / 1e4;\n\n        // Prepare payout\n        payouts = new Flywheel.Payout[](1);\n        payouts[0] =\n            Flywheel.Payout({recipient: user, amount: balance - feeAmount, extraData: abi.encode(code, feeAmount)});\n\n        // Prepare fee if applicable\n        if (feeAmount > 0) {\n            immediateFees = new Flywheel.Payout[](1);\n            immediateFees[0] = Flywheel.Payout({\n                recipient: builderCodes.payoutAddress(uint256(code)), // if payoutAddress misconfigured, builder loses their fee\n                amount: feeAmount,\n                extraData: \"\"\n            });\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onWithdrawFunds(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        override\n        returns (Flywheel.Payout memory payout)\n    {\n        // Intended use is for funds to be sent into the campaign and atomically sent out to recipients\n        // If tokens are sent into the campaign outside of this scope on accident, anyone can take them (no access control for `onSend` hook)\n        // To keep the event feed clean for payouts/fees, we leave open the ability to withdraw funds directly\n        // Those wishing to take accidental tokens left in the campaign should find this function easier\n        payout = abi.decode(hookData, (Flywheel.Payout));\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onUpdateStatus(\n        address sender,\n        address campaign,\n        Flywheel.CampaignStatus oldStatus,\n        Flywheel.CampaignStatus newStatus,\n        bytes calldata hookData\n    ) internal override {\n        // This is a perpetual campaign, so it should always be active\n        // Campaigns are created as INACTIVE, so still need to let someone turn it on\n        if (newStatus != Flywheel.CampaignStatus.ACTIVE) revert Flywheel.InvalidCampaignStatus();\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onUpdateMetadata(address sender, address campaign, bytes calldata hookData) internal override {\n        // Anyone can prompt metadata cache updates\n        // Even though metadataURI is fixed, its returned data may change over time\n    }\n}\n"
    }
}