{
    "vfp_id": "vfp_00234",
    "project_name": "Mitosis - Zenith Audit Report (September).pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Too large Cap in VLFVaultCapped will block mint()",
            "description": "The `VLFVaultCapped` contract uses `maxDeposit` and `maxMint` to enforce deposit limits. However, if `Cap` is set to `type(uint256).max` to indicate unlimited minting, the `convertToShares` function can overflow during the `fullMulDiv` calculation when converting assets to shares. Although `fullMulDiv` prevents overflow in multiplication, the division step can still overflow due to large intermediate values (e.g., when scaling with decimals). This causes `maxMint` to revert, effectively blocking all minting operations even when intended to be unlimited. This creates an unintended denial-of-service condition for legitimate users.\n",
            "severity": "Low",
            "location": [
                "VLFVaultCapped.sol#L97-L99"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/vlf/VLFVaultCapped.sol"
            ]
        }
    ],
    "affected_files": {
        "VLFVaultCapped.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.28;\n\nimport { IERC20Metadata } from '@oz/interfaces/IERC20Metadata.sol';\nimport { Math } from '@oz/utils/math/Math.sol';\nimport { EnumerableSet } from '@oz/utils/structs/EnumerableSet.sol';\n\nimport { IAssetManager } from '../../interfaces/hub/core/IAssetManager.sol';\nimport { ERC7201Utils } from '../../lib/ERC7201Utils.sol';\nimport { StdError } from '../../lib/StdError.sol';\nimport { VLFVault } from './VLFVault.sol';\n\n/**\n * @title VLFVaultCapped\n * @notice VLFVault with a cap system\n */\ncontract VLFVaultCapped is VLFVault {\n  using ERC7201Utils for string;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  /// @custom:storage-location mitosis.storage.VLFVaultCapped\n  struct VLFVaultCappedStorage {\n    uint256 cap;\n    uint256 softCap;\n    EnumerableSet.UintSet preferredChainIds;\n  }\n\n  event CapSet(address indexed setter, uint256 prevCap, uint256 newCap);\n  event SoftCapSet(uint256 prevSoftCap, uint256 newSoftCap);\n  event PreferredChainAdded(uint256 indexed chainId);\n  event PreferredChainRemoved(uint256 indexed chainId);\n\n  modifier onlyLiquidityManager() {\n    require(_getStorageV1().assetManager.isLiquidityManager(_msgSender()), StdError.Unauthorized());\n    _;\n  }\n\n  // =========================== NOTE: STORAGE DEFINITIONS =========================== //\n\n  string private constant _NAMESPACE = 'mitosis.storage.VLFVaultCapped';\n  bytes32 private immutable _slot = _NAMESPACE.storageSlot();\n\n  function _getVLFVaultCappedStorage() private view returns (VLFVaultCappedStorage storage $) {\n    bytes32 slot = _slot;\n    // slither-disable-next-line assembly\n    assembly {\n      $.slot := slot\n    }\n  }\n\n  // ============================ NOTE: INITIALIZATION FUNCTIONS ============================ //\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address assetManager_, IERC20Metadata asset_, string memory name, string memory symbol)\n    public\n    virtual\n    initializer\n  {\n    __VLFVault_init(assetManager_, asset_, name, symbol);\n  }\n\n  // ============================ NOTE: VIEW FUNCTIONS ============================ //\n\n  function loadCap() external view returns (uint256) {\n    return _getVLFVaultCappedStorage().cap;\n  }\n\n  function loadSoftCap() external view returns (uint256) {\n    return _getVLFVaultCappedStorage().softCap;\n  }\n\n  function isPreferredChain(uint256 chainId) external view returns (bool) {\n    return _getVLFVaultCappedStorage().preferredChainIds.contains(chainId);\n  }\n\n  function preferredChainIds() external view returns (uint256[] memory) {\n    return _getVLFVaultCappedStorage().preferredChainIds.values();\n  }\n\n  function maxDeposit(address) public view virtual override returns (uint256 maxAssets) {\n    return _maxDepositForAllCaps(_getVLFVaultCappedStorage());\n  }\n\n  function maxDepositFromChainId(address, /*receiver*/ uint256 chainId) public view virtual override returns (uint256) {\n    VLFVaultCappedStorage storage $ = _getVLFVaultCappedStorage();\n\n    if ($.preferredChainIds.contains(chainId)) {\n      return _maxDepositForHardCap($);\n    } else {\n      return _maxDepositForAllCaps($);\n    }\n  }\n\n  function maxMint(address account) public view override returns (uint256 maxShares) {\n    return convertToShares(maxDeposit(account));\n  }\n\n  // ============================ NOTE: MUTATIVE FUNCTIONS ============================ //\n\n  function setCap(uint256 newCap) external onlyLiquidityManager {\n    _setCap(_getVLFVaultCappedStorage(), newCap);\n  }\n\n  function setSoftCap(uint256 newSoftCap) external onlyLiquidityManager {\n    _setSoftCap(_getVLFVaultCappedStorage(), newSoftCap);\n  }\n\n  function addPreferredChainId(uint256 chainId) external onlyLiquidityManager {\n    _addPreferredChainId(_getVLFVaultCappedStorage(), chainId);\n  }\n\n  function removePreferredChainId(uint256 chainId) external onlyLiquidityManager {\n    _removePreferredChainId(_getVLFVaultCappedStorage(), chainId);\n  }\n\n  // ============================ NOTE: INTERNAL FUNCTIONS ============================ //\n\n  function _maxDepositForAllCaps(VLFVaultCappedStorage storage $) internal view returns (uint256) {\n    uint256 currentAssets = totalAssets();\n    uint256 capLimit = currentAssets >= $.cap ? 0 : $.cap - currentAssets;\n    uint256 softCapLimit = currentAssets >= $.softCap ? 0 : $.softCap - currentAssets;\n    return Math.min(capLimit, softCapLimit);\n  }\n\n  function _maxDepositForHardCap(VLFVaultCappedStorage storage $) internal view returns (uint256) {\n    uint256 currentAssets = totalAssets();\n    return currentAssets >= $.cap ? 0 : $.cap - currentAssets;\n  }\n\n  function _setCap(VLFVaultCappedStorage storage $, uint256 newCap) internal {\n    uint256 prevCap = $.cap;\n    $.cap = newCap;\n    emit CapSet(_msgSender(), prevCap, newCap);\n  }\n\n  function _setSoftCap(VLFVaultCappedStorage storage $, uint256 newSoftCap) internal {\n    uint256 prevSoftCap = $.softCap;\n    $.softCap = newSoftCap;\n    emit SoftCapSet(prevSoftCap, newSoftCap);\n  }\n\n  function _addPreferredChainId(VLFVaultCappedStorage storage $, uint256 chainId) internal {\n    if ($.preferredChainIds.add(chainId)) {\n      emit PreferredChainAdded(chainId);\n    }\n  }\n\n  function _removePreferredChainId(VLFVaultCappedStorage storage $, uint256 chainId) internal {\n    if ($.preferredChainIds.remove(chainId)) {\n      emit PreferredChainRemoved(chainId);\n    }\n  }\n}\n"
    }
}