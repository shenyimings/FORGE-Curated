{
    "vfp_id": "vfp_00357",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect Execution Context for Transfer on Core When Finalizing a Swap",
            "description": "The `finalizeSwapFlows` function in `HyperCoreFlowExecutor.sol` attempts to transfer final tokens from a `SwapHandler` back to the user by calling `HyperCoreLib.transferERC20CoreToCore` directly. However, this call is executed from the context of the `HyperCoreFlowExecutor` contract, not the `SwapHandler` contract that holds the funds. Since the `HyperCoreFlowExecutor` does not own the tokens, the transfer fails and reverts.\n\nThe root cause is a logic error in the execution context: the transfer is not delegated to the `SwapHandler`, which is the rightful owner of the swapped assets. An attacker cannot directly exploit this, but any user attempting to finalize a swap will face a transaction revert.\n\nThis results in a permanent denial-of-service (DoS) for all swap finalizations, freezing user funds in their respective `SwapHandler` contracts. Only a privileged administrator can manually recover the funds, which undermines the protocol's self-service design and availability.\n\nThis issue was resolved in pull request #29 by modifying `_finalizeSingleSwap` to delegate the transfer call to the correct `SwapHandler`.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::finalizeSwapFlows#558",
                "HyperCoreFlowExecutor.sol::_finalizeSingleSwap#670",
                "HyperCoreLib.transferERC20CoreToCore"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol",
                "contracts/contracts/libraries/HyperCoreLib.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Token Index Prevents Asset Rescue",
            "description": "The `sweepOnCoreFromSwapHandler` function in `HyperCoreFlowExecutor.sol` is the only administrative mechanism to withdraw assets from a `SwapHandler` on the HyperCore layer. However, it incorrectly uses a market-specific `assetIndex` instead of the required token-specific `coreIndex` when calling `transferFundsToUserOnCore`.\n\nThis flaw stems from a mismatch in index types: `assetIndex` is used in the context of trading markets, while `coreIndex` is required for token identification on HyperCore. If these indices collide, the function may transfer the wrong asset.\n\nAn attacker could potentially manipulate market configurations to cause index collisions, leading to incorrect asset sweeps. More critically, if funds become stuck in a `SwapHandler` due to other failures, this function cannot reliably rescue them, rendering the assets permanently trapped.\n\nThis issue was resolved in pull request #30 by correcting the index to `coreTokenInfos[token].coreIndex`.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::sweepOnCoreFromSwapHandler#940",
                "SwapHandler.sol::transferFundsToUserOnCore"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/SwapHandler.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Partial Conversion of Initial Token Leads to Stranded Funds",
            "description": "The `_executeFlow` function in `ArbitraryEVMFlowExecutor.sol` uses balance snapshots before and after a multicall execution to determine the outcome. It assumes that the `initialToken` is either fully consumed or fully refunded, and only accounts for the resulting `finalToken`.\n\nThe root cause is an incorrect assumption about the behavior of arbitrary execution sequences. Many valid swap paths may only partially convert the `initialToken`, returning the remainder to the executor. The function interprets any decrease in the `initialToken` balance as a full conversion, ignoring the leftover amount.\n\nAn attacker cannot directly exploit this, but users may lose funds if the execution flow leaves behind partial `initialToken` balances. These leftover tokens become permanently stranded on the `ArbitraryEVMFlowExecutor` contract, as there is no mechanism to return them.\n\nThe issue was acknowledged but not resolved. The team argued that it is the API's responsibility to ensure no leftover tokens are created and that `drainLeftoverTokens` can be used to handle such cases.\n",
            "severity": "High",
            "location": [
                "ArbitraryEVMFlowExecutor.sol::_executeFlow#56-114"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect `finalToken` in `HyperEVMFallback`",
            "description": "In the `_initiateSwapFlow` function, if a user's HyperCore account is not activated and the swap is not sponsored, the flow diverts to `_fallbackHyperEVMFlow`. However, the `params` object passed to the fallback still contains the user's intended `finalToken`, not the `initialToken` they provided.\n\nThe cause is a logic error in parameter handling: the fallback mechanism is meant to refund the input token, but it attempts to transfer the output token instead. If the contract holds any balance of the `finalToken`, it will try to send it to the user.\n\nThis can lead to failed transactions if the contract does not hold the `finalToken`, causing the `safeTransfer` call to revert. In the worst case, if the contract does hold the `finalToken`, it may send an incorrect token to the user, leading to confusion and potential loss.\n\nThis issue was resolved in pull request #28 by setting `params.finalToken` to `initialToken` before calling the fallback function.\n",
            "severity": "Medium",
            "location": [
                "HyperCoreFlowExecutor.sol::_initiateSwapFlow#445",
                "HyperCoreFlowExecutor.sol::_fallbackHyperEVMFlow"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Stranded `baseToken` Dust in `SwapHandler` Contracts",
            "description": "The `HyperCoreFlowExecutor` transfers the entire `baseToken` amount to a `SwapHandler` for external swaps. Due to exchange precision limits (e.g., tick size, fees), small amounts of `baseToken` dust may remain in the `SwapHandler` after a swap.\n\nThe root cause is the lack of a mechanism to recover this dust. The existing `sweepOnCoreFromSwapHandler` function only sweeps the `finalToken`, not the `baseToken`. Over time, this leads to a cumulative loss of funds across multiple `SwapHandler` instances.\n\nWhile not directly exploitable, this results in inefficient capital use and commingling of user funds. A privileged role cannot recover the dust, increasing reliance on off-chain bots to manage residual balances.\n\nThis issue was resolved in pull request #40 by updating `sweepOnCoreFromSwapHandler` to sweep both `finalToken` and `baseToken`.\n",
            "severity": "Medium",
            "location": [
                "HyperCoreFlowExecutor.sol::_initiateSwapFlow#549",
                "HyperCoreFlowExecutor.sol::sweepOnCoreFromSwapHandler#934"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Native Tokens Are Irrecoverable",
            "description": "The `ArbitraryEVMFlowExecutor.sol` contract has a `receive() payable` function, allowing it to accept native HYPE tokens. However, there is no mechanism to withdraw these native tokens once received.\n\nThe cause is a missing administrative function for native token recovery. While ERC-20 sweep functions exist, no equivalent exists for native currency. This creates a risk that funds sent by mistake or as part of a malicious deposit become permanently locked.\n\nAn attacker could grief the system by sending small amounts of native tokens to prevent clean contract state, or users could lose funds if they accidentally send native tokens. The impact is limited to the value of the native tokens sent.\n\nThis issue was resolved in pull request #41 by implementing a guarded withdrawal function for privileged roles.\n",
            "severity": "Medium",
            "location": [
                "ArbitraryEVMFlowExecutor.sol::receive#180",
                "HyperCoreFlowExecutor.sol"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unsafe ABI Encoding",
            "description": "The codebase uses `abi.encodeWithSelector` in multiple locations, which is not type-safe and can lead to incorrect calldata encoding if the function signature does not match the intended target. This is used in functions such as `_buildMulticallInstructions`, `receiveMessage`, `lzCompose`, and others across several contracts.\nThe root cause is the manual construction of function selectors without compile-time type checking, increasing the risk of silent failures or unintended behavior during low-level calls.\nAn attacker could potentially exploit this if a mismatched selector leads to a call to an unintended function, especially in delegatecall contexts, though the direct exploitability depends on the target contract's logic.\nThe impact includes potential incorrect execution, loss of funds, or unexpected state changes due to malformed calldata, especially during upgrades or integrations with external contracts.\n",
            "severity": "Medium",
            "location": [
                "ArbitraryEVMFlowExecutor.sol::_buildMulticallInstructions#142-146",
                "SponsoredCCTPDstPeriphery.sol::receiveMessage#141-146",
                "SponsoredCCTPDstPeriphery.sol::_executeWithEVMFlow#166-171",
                "DstOFTHandler.sol::lzCompose#163",
                "DstOFTHandler.sol::_executeWithEVMFlow#173-178"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/sponsored-cctp/SponsoredCCTPDstPeriphery.sol",
                "contracts/contracts/periphery/mintburn/sponsored-oft/DstOFTHandler.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Unchecked Return Value of `transfer` Call",
            "description": "The `sweepErc20` function in the `SwapHandler` contract calls `transfer` on an ERC-20 token but does not check its boolean return value. Some ERC-20 tokens return `false` on failure instead of reverting, which would cause the transfer to fail silently while the transaction succeeds.\nThe root cause is the direct use of the `transfer` function without proper error handling or use of a safe library.\nAn attacker could exploit this by using a non-compliant token that returns `false` on failure, leading to a successful transaction that does not actually transfer funds.\nThe impact is that users may believe funds were withdrawn when they were not, leading to loss of funds or incorrect accounting.\n",
            "severity": "Medium",
            "location": [
                "SwapHandler.sol::sweepErc20#66-69",
                "SwapHandler.sol::transfer#67"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/SwapHandler.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Finalize Swap Flow Lacks Configuration Check for Final Token",
            "description": "The `finalizeSwapFlows` function in `HyperCoreFlowExecutor` reads `FinalTokenInfo` from a mapping without validating whether the token is configured. If an unconfigured token is passed, the `swapHandler` will be address(0), leading to a balance check on the zero address, which may return a non-zero balance and prevent finalization.\nThe root cause is the absence of a validation check before using the `FinalTokenInfo` struct.\nA permissioned bot could accidentally pass an unconfigured token, or an attacker could attempt to manipulate the flow with invalid inputs, though the function is permissioned.\nThe impact is that legitimate swap flows may fail to finalize, leading to user fund delays or denial of service for valid transactions.\n",
            "severity": "Medium",
            "location": [
                "HyperCoreFlowExecutor.sol::finalizeSwapFlows#564-633",
                "HyperCoreFlowExecutor.sol::FinalTokenInfo#573",
                "HyperCoreFlowExecutor.sol::_getExistingFinalTokenInfo#223-228"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Application Payloads Lack Versioning",
            "description": "The system uses custom-encoded payloads (`composeMsg` and `hookData`) to pass data between chains, but these payloads do not include a version number.\nThe root cause is the absence of a versioning mechanism in the payload structure.\nIf the payload format is changed on the source chain before the destination is updated, the destination will fail to parse the message, likely causing a revert.\nThe impact is that user funds could become stranded on the destination chain due to parsing failures during upgrades, especially in unsynchronized deployments.\n",
            "severity": "Medium",
            "location": [
                "SponsoredOFTSrcPeriphery.sol::composeMsg#107-116",
                "SponsoredCCTPQuoteLib.sol::hookData#78-87"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/sponsored-oft/SponsoredOFTSrcPeriphery.sol",
                "contracts/contracts/periphery/mintburn/sponsored-cctp/SponsoredCCTPDstPeriphery.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Inconsistent Storage Layout Pattern",
            "description": "The contracts use a hybrid storage model combining Solidity's default state variable layout with a namespaced storage pattern using EIP-7201.\nThe root cause is an attempt to manage contract size while minimizing refactoring, leading to mixed patterns.\nThis complexity increases the risk of storage collisions or developer errors during future upgrades.\nThe impact is reduced code readability, higher maintenance burden, and increased risk of storage-related vulnerabilities in future development.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unused Variables",
            "description": "Multiple state and local variables are declared but never used in the codebase, such as `BPS_DECIMALS`, `PX_D`, and `accountActivationFeeToken`.\nThe root cause is leftover or obsolete code from development or refactoring.\nWhile not directly exploitable, these variables increase code complexity and reduce clarity.\nThe impact is reduced code readability and maintainability, potentially leading to confusion for auditors and developers.\n",
            "severity": "Informational",
            "location": [
                "ArbitraryEVMFlowExecutor.sol::BPS_DECIMALS#43",
                "HyperCoreFlowExecutor.sol::PX_D#29",
                "HyperCoreFlowExecutor.sol::accountActivationFeeToken#282-313"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Errors",
            "description": "Several custom errors are defined but never used, including `TransferAmtExceedsAssetBridgeBalance`, `InsufficientFinalBalance`, and `DonationBoxInsufficientFundsError`.\nThe root cause is likely incomplete implementation or removal of logic that used these errors.\nUnused errors clutter the code and may mislead developers into thinking certain checks are in place.\nThe impact is reduced code clarity and potential confusion about the actual error handling behavior.\n",
            "severity": "Informational",
            "location": [
                "HyperCoreLib.sol::TransferAmtExceedsAssetBridgeBalance#68",
                "ArbitraryEVMFlowExecutor.sol::InsufficientFinalBalance#40",
                "HyperCoreFlowExecutor.sol::DonationBoxInsufficientFundsError#178"
            ],
            "files": [
                "contracts/contracts/libraries/HyperCoreLib.sol",
                "contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Prefix Increment Operator (`++i`) Can Save Gas in Loops",
            "description": "The loop in `MulticallHandler.sol` uses the postfix increment operator (`i++`), which creates a temporary copy of the value before incrementing.\nThe root cause is the use of a less gas-efficient increment pattern.\nIn loops with many iterations, this can lead to unnecessary gas costs.\nThe impact is higher transaction costs than necessary, reducing economic efficiency.\n",
            "severity": "Informational",
            "location": [
                "MulticallHandler.sol#133"
            ],
            "files": [
                "contracts/contracts/handlers/MulticallHandler.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1084"
                ]
            },
            "title": "Multiple Optimizable State Reads",
            "description": "The `coreTokenInfo` struct is read multiple times from storage in the `_executeSimpleTransferFlow` function without caching.\nThe root cause is repeated SLOAD operations instead of caching the struct in memory.\nEach storage read consumes significant gas, so redundant reads increase execution cost.\nThe impact is higher gas consumption than necessary, leading to more expensive transactions.\n",
            "severity": "Informational",
            "location": [
                "HyperCoreFlowExecutor.sol::coreTokenInfo#348",
                "HyperCoreFlowExecutor.sol::_executeSimpleTransferFlow#346-429"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Incomplete Docstrings",
            "description": "Multiple functions and events across several contracts lack proper NatSpec documentation for parameters and return values, making it difficult for developers and auditors to understand the intended behavior.\nThe cause is developers omitting or incompletely filling out documentation comments (e.g., @param, @return) for public and external API elements.\nWhile not directly exploitable, incomplete documentation increases the risk of incorrect integration or modification by developers, potentially leading to logic errors or security vulnerabilities.\nThe impact is reduced code maintainability, increased risk of integration errors, and hindered auditability due to lack of clarity on function and event behavior.\n",
            "severity": "Informational",
            "location": [
                "MulticallHandler.sol::handleV3AcrossMessage",
                "PermissionedMulticallHandler.sol::CallerWhitelisted",
                "PermissionedMulticallHandler.sol::CallerRemovedFromWhitelist",
                "ArbitraryEVMFlowExecutor.sol::ArbitraryActionsExecuted",
                "HyperCoreFlowExecutor.sol::DonationBoxInsufficientFunds",
                "HyperCoreFlowExecutor.sol::AccountNotActivated",
                "HyperCoreFlowExecutor.sol::SimpleTransferFlowCompleted",
                "HyperCoreFlowExecutor.sol::FallbackHyperEVMFlowCompleted",
                "HyperCoreFlowExecutor.sol::SwapFlowInitialized",
                "HyperCoreFlowExecutor.sol::SwapFlowFinalized",
                "HyperCoreFlowExecutor.sol::CancelledLimitOrder",
                "HyperCoreFlowExecutor.sol::SubmittedLimitOrder",
                "HyperCoreFlowExecutor.sol::SwapFlowTooExpensive",
                "HyperCoreFlowExecutor.sol::UnsafeToBridge",
                "HyperCoreFlowExecutor.sol::SponsoredAccountActivation",
                "HyperCoreFlowExecutor.sol::SetCoreTokenInfo",
                "HyperCoreFlowExecutor.sol::setCoreTokenInfo",
                "HyperCoreFlowExecutor.sol::predictSwapHandler",
                "HyperCoreFlowExecutor.sol::finalizeSwapFlows",
                "HyperCoreFlowExecutor.sol::cancelLimitOrderByCloid",
                "HyperCoreFlowExecutor.sol::sendSponsorshipFundsToSwapHandler",
                "DstOFTHandler.sol::SetAuthorizedPeriphery",
                "DstOFTHandler.sol::lzCompose",
                "SponsoredOFTSrcPeriphery.sol::SponsoredOFTSend",
                "SponsoredOFTSrcPeriphery.sol::deposit"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol",
                "contracts/contracts/handlers/MulticallHandler.sol",
                "contracts/contracts/periphery/mintburn/sponsored-oft/DstOFTHandler.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Boolean Comparisons Reduce Readability",
            "description": "The codebase uses explicit comparisons of boolean variables to `false` (e.g., `x == false`) instead of the more idiomatic and readable `!x`.\nThe cause is non-standard coding style that deviates from common Solidity conventions.\nThis is not a security vulnerability and cannot be exploited. However, it reduces code clarity and increases the chance of logical errors during maintenance.\nThe impact is lower code readability and maintainability, potentially leading to mistakes during future development or audits.\n",
            "severity": "Informational",
            "location": [
                "HyperCoreFlowExecutor.sol#714",
                "DstOFTHandler.sol#105"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/sponsored-oft/DstOFTHandler.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typographical Errors",
            "description": "Several spelling mistakes were found in comments and potentially in code (e.g., 'Calcualtes', 'form', 'revover', 'receipent').\nThe cause is typos introduced during development without subsequent review.\nThese errors do not introduce security vulnerabilities but can mislead developers reading the code or documentation.\nThe impact is reduced code professionalism and clarity, potentially causing confusion during development or auditing.\n",
            "severity": "Informational",
            "location": [
                "ArbitraryEVMFlowExecutor.sol#159",
                "HyperCoreFlowExecutor.sol#547",
                "DstOFTHandler.sol#104",
                "SponsoredCCTPDstPeriphery.sol#97"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/ArbitraryEVMFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol",
                "contracts/contracts/periphery/mintburn/sponsored-oft/DstOFTHandler.sol",
                "contracts/contracts/periphery/mintburn/sponsored-cctp/SponsoredCCTPDstPeriphery.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Documentation",
            "description": "A comment in `SponsoredCCTPDstPeriphery.sol` incorrectly states that funds will be minted to the contract itself, when in fact they are minted directly to the specified `mintRecipient`.\nThe cause is outdated or incorrect inline documentation that does not reflect the actual behavior of the external contract call.\nDevelopers relying on the comment may misunderstand the flow of funds, potentially leading to incorrect assumptions in integrations or security analyses.\nThe impact is risk of incorrect integration logic or flawed security assessments due to reliance on inaccurate documentation.\n",
            "severity": "Informational",
            "location": [
                "SponsoredCCTPDstPeriphery.sol#84-85"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/sponsored-cctp/SponsoredCCTPDstPeriphery.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Unaddressed TODO Comments",
            "description": "TODO comments in the codebase (e.g., in `SponsoredCCTPInterface.sol` and `HyperCoreLib.sol`) indicate incomplete or pending work that has not been resolved before audit.\nThe cause is development tasks were left incomplete and tracked only in code comments rather than in a formal issue tracker.\nIf the TODOs relate to security-critical functionality, their neglect could lead to vulnerabilities. Even if not, they indicate technical debt.\nThe impact is increased risk of forgotten security considerations, reduced code maturity, and potential for future bugs if not properly tracked and resolved.\n",
            "severity": "Informational",
            "location": [
                "SponsoredCCTPInterface.sol#59",
                "HyperCoreLib.sol#48"
            ],
            "files": [
                "contracts/contracts/interfaces/SponsoredCCTPInterface.sol",
                "contracts/contracts/libraries/HyperCoreLib.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1053"
                ]
            },
            "title": "Lack of Documentation",
            "description": "The `HyperCoreFlowExecutor` contract lacks documentation stating that it is intended to be used only via `delegatecall` from periphery contracts and should not be called directly.\nThe cause is missing architectural documentation in the contract's NatSpec or comments.\nA developer might call a function like `predictSwapHandler` directly on the `HyperCoreFlowExecutor` contract, causing it to use the wrong context (`address(this)`) and return incorrect results.\nThe impact is potential for incorrect behavior or integration failures if the contract is used in an unintended manner due to lack of guidance.\n",
            "severity": "Informational",
            "location": [
                "HyperCoreFlowExecutor.sol"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unoptimized USDC Transfer to HyperCore",
            "description": "The `HyperCoreLib` library uses a two-step process to transfer USDC to HyperCore, first depositing to its own account and then transferring to the final recipient, instead of using a single `depositFor` call.\nThe cause is suboptimal implementation that does not leverage the full functionality of the `ICoreDepositWallet` contract.\nThis inefficiency increases gas costs and transaction complexity for USDC transfers, though it does not lead to fund loss.\nThe impact is higher transaction costs and reduced efficiency for USDC transfers, negatively affecting user experience and economic efficiency.\n",
            "severity": "Low",
            "location": [
                "HyperCoreLib.sol::transferERC20EVMToCore"
            ],
            "files": [
                "contracts/contracts/libraries/HyperCoreLib.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Not Forwarding The Exact OFT Messaging Fees",
            "description": "The `deposit` function in `SponsoredOFTSrcPeriphery` forwards the entire `msg.value` to the LayerZero messenger without validating it against the calculated fee, which may cause reverts if the amount is not exact.\nThe cause is lack of input validation and fee adjustment logic; the underlying LayerZero contract enforces strict fee equality.\nUsers who send more or less than the exact fee will have their transactions reverted, leading to a denial of service.\nThe impact is poor user experience and potential loss of transaction fees due to failed transactions.\n",
            "severity": "High",
            "location": [
                "SponsoredOFTSrcPeriphery.sol::deposit"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/sponsored-oft/SponsoredOFTSrcPeriphery.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect Spot Price Decimal Conversion",
            "description": "The `_getApproxRealizedPrice` function assumes a fixed 8-decimal precision for spot prices from HyperCore, but the actual precision depends on the asset's `szDecimals`.\nThe cause is hardcoded decimal assumption without accounting for asset-specific scaling.\nPrice and slippage calculations will be incorrect, potentially leading to unfavorable trades or failed swaps.\nThe impact is incorrect pricing logic could result in financial loss for users due to miscalculated slippage or execution prices.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::_getApproxRealizedPrice"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Market Index for Limit Orders",
            "description": "The market index for limit orders is incorrectly set to the asset index instead of `10000 + asset index`, as required by the HyperCore system.\nThe cause is logic error in the `submitLimitOrderFromBot` and `cancelLimitOrderByCloid` functions.\nLimit orders will be submitted to an incorrect market index, likely causing them to fail or be placed in the wrong market.\nThe impact is failed or misrouted limit orders, leading to loss of user funds or failed transactions.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::submitLimitOrderFromBot",
                "HyperCoreFlowExecutor.sol::cancelLimitOrderByCloid"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Incorrect Handling Of The Sponsored Account Activation Fee",
            "description": "The `activateUserAccount` function incorrectly transfers the activation fee directly to the user's HyperCore account instead of having the sponsor's account cover the fee during activation.\nThe cause is misunderstanding of the HyperCore account activation mechanism, which deducts fees from the sponsor's balance when the user performs an action.\nThe activation may fail or behave incorrectly because the system expects the sponsor to have sufficient balance, not the recipient.\nThe impact is risk of failed account activations and stranded user funds, undermining the sponsorship mechanism.\n",
            "severity": "High",
            "location": [
                "HyperCoreFlowExecutor.sol::activateUserAccount"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/HyperCoreFlowExecutor.sol"
            ]
        }
    ],
    "affected_files": {
        "SponsoredCCTPInterface.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n/**\n * @title SponsoredCCTPInterface\n * @notice Interface for the SponsoredCCTP contract\n * @custom:security-contact bugs@across.to\n */\ninterface SponsoredCCTPInterface {\n    // Error thrown when the signature is invalid.\n    error InvalidSignature();\n\n    // Error thrown when the nonce is invalid.\n    error InvalidNonce();\n\n    // Error thrown when the deadline is invalid.\n    error InvalidDeadline();\n\n    // Error thrown when the source domain is invalid.\n    error InvalidSourceDomain();\n\n    event SponsoredDepositForBurn(\n        bytes32 indexed quoteNonce,\n        address indexed originSender,\n        bytes32 indexed finalRecipient,\n        uint256 quoteDeadline,\n        uint256 maxBpsToSponsor,\n        uint256 maxUserSlippageBps,\n        bytes32 finalToken,\n        bytes signature\n    );\n\n    event SimpleTansferToCore(\n        address indexed finalToken,\n        address indexed finalRecipient,\n        uint256 finalAmount,\n        uint256 maxAmountToSponsor\n    );\n\n    // Execution modes for the sponsored CCTP flow\n    enum ExecutionMode {\n        // Send to core and perform swap (if needed) there.\n        DirectToCore,\n        // Execute arbitrary actions (like a swap) on HyperEVM, then transfer to HyperCore\n        ArbitraryActionsToCore,\n        // Execute arbitrary actions on HyperEVM only (no HyperCore transfer)\n        ArbitraryActionsToEVM\n    }\n\n    // Params that will be used to create a sponsored CCTP quote and deposit for burn.\n    struct SponsoredCCTPQuote {\n        // The domain ID of the source chain.\n        uint32 sourceDomain;\n        // The domain ID of the destination chain.\n        uint32 destinationDomain;\n        // The recipient of the minted USDC on the destination chain.\n        bytes32 mintRecipient;\n        // The amount that the user pays on the source chain.\n        // TODO: rename this to indicate source amount\n        uint256 amount;\n        // The token that will be burned on the source chain.\n        bytes32 burnToken;\n        // The caller of the destination chain.\n        bytes32 destinationCaller;\n        // Maximum fee to pay on the destination domain, specified in units of burnToken\n        uint256 maxFee;\n        // Minimum finality threshold before allowed to attest\n        uint32 minFinalityThreshold;\n        // Nonce is used to prevent replay attacks.\n        bytes32 nonce;\n        // Timestamp of the quote after which it can no longer be used.\n        uint256 deadline;\n        // The maximum basis points of the amount that can be sponsored.\n        uint256 maxBpsToSponsor;\n        // Slippage tolerance for the fees on the destination. Used in swap flow, enforced on destination\n        uint256 maxUserSlippageBps;\n        // The final recipient of the sponsored deposit. This is needed as the mintRecipient will be the\n        // handler contract address instead of the final recipient.\n        bytes32 finalRecipient;\n        // The final token that final recipient will receive. This is needed as it can be different from the burnToken\n        // in which case we perform a swap on the destination chain.\n        bytes32 finalToken;\n        // Execution mode: DirectToCore, ArbitraryActionsToCore, or ArbitraryActionsToEVM\n        uint8 executionMode;\n        // Encoded action data for arbitrary execution. Empty for DirectToCore mode.\n        bytes actionData;\n    }\n}\n",
        "SwapHandler.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { HyperCoreLib } from \"../../libraries/HyperCoreLib.sol\";\nimport { FinalTokenInfo } from \"./Structs.sol\";\n\ncontract SwapHandler {\n    address public immutable parentHandler;\n\n    constructor() {\n        parentHandler = msg.sender;\n    }\n\n    modifier onlyParentHandler() {\n        require(msg.sender == parentHandler, \"Not parent handler\");\n        _;\n    }\n\n    function activateCoreAccount(\n        address erc20EVMAddress,\n        uint64 erc20CoreIndex,\n        uint256 amountEVM,\n        int8 decimalDiff\n    ) external onlyParentHandler {\n        HyperCoreLib.transferERC20EVMToSelfOnCore(erc20EVMAddress, erc20CoreIndex, amountEVM, decimalDiff);\n    }\n\n    function transferFundsToSelfOnCore(\n        address erc20EVMAddress,\n        uint64 erc20CoreIndex,\n        uint256 amountEVM,\n        int8 decimalDiff\n    ) external onlyParentHandler {\n        HyperCoreLib.transferERC20EVMToSelfOnCore(erc20EVMAddress, erc20CoreIndex, amountEVM, decimalDiff);\n    }\n\n    function transferFundsToUserOnCore(\n        uint64 erc20CoreIndex,\n        address to,\n        uint64 amountCore\n    ) external onlyParentHandler {\n        HyperCoreLib.transferERC20CoreToCore(erc20CoreIndex, to, amountCore);\n    }\n\n    function submitLimitOrder(\n        FinalTokenInfo memory finalTokenInfo,\n        uint64 limitPriceX1e8,\n        uint64 sizeX1e8,\n        uint128 cloid\n    ) external onlyParentHandler {\n        HyperCoreLib.submitLimitOrder(\n            finalTokenInfo.assetIndex,\n            finalTokenInfo.isBuy,\n            limitPriceX1e8,\n            sizeX1e8,\n            false,\n            HyperCoreLib.Tif.GTC,\n            cloid\n        );\n    }\n\n    function cancelOrderByCloid(uint32 assetIndex, uint128 cloid) external onlyParentHandler {\n        HyperCoreLib.cancelOrderByCloid(assetIndex, cloid);\n    }\n\n    function sweepErc20(address token, uint256 amount) external onlyParentHandler {\n        IERC20(token).transfer(msg.sender, amount);\n    }\n}\n",
        "SponsoredOFTSrcPeriphery.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport { Quote } from \"./Structs.sol\";\nimport { QuoteSignLib } from \"./QuoteSignLib.sol\";\nimport { ComposeMsgCodec } from \"./ComposeMsgCodec.sol\";\n\nimport { IOFT, IOAppCore, SendParam, MessagingFee } from \"../../../interfaces/IOFT.sol\";\nimport { AddressToBytes32 } from \"../../../libraries/AddressConverters.sol\";\nimport { MinimalLZOptions } from \"../../../external/libraries/MinimalLZOptions.sol\";\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice Source chain periphery contract for users to interact with to start a sponsored or a non-sponsored flow\n/// that allows custom Accross-supported flows on destination chain. Uses LayzerZero's OFT as an underlying bridge\ncontract SponsoredOFTSrcPeriphery is Ownable {\n    using AddressToBytes32 for address;\n    using MinimalLZOptions for bytes;\n    using SafeERC20 for IERC20;\n\n    bytes public constant EMPTY_OFT_COMMAND = new bytes(0);\n\n    /// @notice Token that's being sent by an OFT bridge\n    address public immutable TOKEN;\n    /// @notice OFT contract to interact with to initiate the bridge\n    address public immutable OFT_MESSENGER;\n\n    /// @notice Source endpoint id\n    uint32 public immutable SRC_EID;\n\n    /// @notice Signer public key to check the signed quote against\n    address public signer;\n\n    /// @notice A mapping to enforce only a single usage per quote\n    mapping(bytes32 => bool) public quoteNonces;\n\n    /// @notice Event with auxiliary information. To be used in concert with OftSent event to get relevant quote details\n    event SponsoredOFTSend(\n        bytes32 indexed quoteNonce,\n        address indexed originSender,\n        bytes32 indexed finalRecipient,\n        bytes32 destinationHandler,\n        uint256 quoteDeadline,\n        uint256 maxBpsToSponsor,\n        uint256 maxUserSlippageBps,\n        bytes32 finalToken,\n        bytes sig\n    );\n\n    /// @notice Thrown when the source eid of the ioft messenger does not match the src eid supplied\n    error IncorrectSrcEid();\n    /// @notice Thrown when the supplied token does not match the supplied ioft messenger\n    error TokenIOFTMismatch();\n    /// @notice Thrown when the signer for quote does not match `signer`\n    error IncorrectSignature();\n    /// @notice Thrown if Quote has expired\n    error QuoteExpired();\n    /// @notice Thrown if Quote nonce was already used\n    error NonceAlreadyUsed();\n\n    constructor(address _token, address _oftMessenger, uint32 _srcEid, address _signer) {\n        TOKEN = _token;\n        OFT_MESSENGER = _oftMessenger;\n        SRC_EID = _srcEid;\n        if (IOAppCore(_oftMessenger).endpoint().eid() != _srcEid) {\n            revert IncorrectSrcEid();\n        }\n        if (IOFT(_oftMessenger).token() != _token) {\n            revert TokenIOFTMismatch();\n        }\n        signer = _signer;\n    }\n\n    /// @notice Main entrypoint function to start the user flow\n    function deposit(Quote calldata quote, bytes calldata signature) external payable {\n        // Step 1: validate quote and mark quote nonce used\n        _validateQuote(quote, signature);\n        quoteNonces[quote.signedParams.nonce] = true;\n\n        // Step 2: build oft send params from quote\n        (SendParam memory sendParam, MessagingFee memory fee, address refundAddress) = _buildOftTransfer(quote);\n\n        // Step 3: pull tokens from user and apporove OFT messenger\n        IERC20(TOKEN).safeTransferFrom(msg.sender, address(this), quote.signedParams.amountLD);\n        IERC20(TOKEN).forceApprove(address(OFT_MESSENGER), quote.signedParams.amountLD);\n\n        // Step 4: send oft transfer and emit event with auxiliary data\n        IOFT(OFT_MESSENGER).send{ value: msg.value }(sendParam, fee, refundAddress);\n        emit SponsoredOFTSend(\n            quote.signedParams.nonce,\n            msg.sender,\n            quote.signedParams.finalRecipient,\n            quote.signedParams.destinationHandler,\n            quote.signedParams.deadline,\n            quote.signedParams.maxBpsToSponsor,\n            quote.unsignedParams.maxUserSlippageBps,\n            quote.signedParams.finalToken,\n            signature\n        );\n    }\n\n    function _buildOftTransfer(\n        Quote calldata quote\n    ) internal view returns (SendParam memory, MessagingFee memory, address) {\n        bytes memory composeMsg = ComposeMsgCodec._encode(\n            quote.signedParams.nonce,\n            quote.signedParams.deadline,\n            quote.signedParams.maxBpsToSponsor,\n            quote.unsignedParams.maxUserSlippageBps,\n            quote.signedParams.finalRecipient,\n            quote.signedParams.finalToken,\n            quote.signedParams.executionMode,\n            quote.signedParams.actionData\n        );\n\n        bytes memory extraOptions = MinimalLZOptions\n            .newOptions()\n            .addExecutorLzReceiveOption(uint128(quote.signedParams.lzReceiveGasLimit), uint128(0))\n            .addExecutorLzComposeOption(uint16(0), uint128(quote.signedParams.lzComposeGasLimit), uint128(0));\n\n        SendParam memory sendParam = SendParam(\n            quote.signedParams.dstEid,\n            quote.signedParams.destinationHandler,\n            // Only support OFT sends that don't take fees in sent token. Set `minAmountLD = amountLD` to enforce this\n            quote.signedParams.amountLD,\n            quote.signedParams.amountLD,\n            extraOptions,\n            composeMsg,\n            // Only support empty OFT commands\n            EMPTY_OFT_COMMAND\n        );\n\n        MessagingFee memory fee = IOFT(OFT_MESSENGER).quoteSend(sendParam, false);\n\n        return (sendParam, fee, quote.unsignedParams.refundRecipient);\n    }\n\n    function _validateQuote(Quote calldata quote, bytes calldata signature) internal view {\n        if (!QuoteSignLib.isSignatureValid(signer, quote.signedParams, signature)) {\n            revert IncorrectSignature();\n        }\n        if (quote.signedParams.deadline < block.timestamp) {\n            revert QuoteExpired();\n        }\n        if (quote.signedParams.srcEid != SRC_EID) {\n            revert IncorrectSrcEid();\n        }\n        if (quoteNonces[quote.signedParams.nonce]) {\n            revert NonceAlreadyUsed();\n        }\n    }\n\n    function setSigner(address _newSigner) external onlyOwner {\n        signer = _newSigner;\n    }\n}\n",
        "HyperCoreLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface ICoreWriter {\n    function sendRawAction(bytes calldata data) external;\n}\n\nlibrary HyperCoreLib {\n    using SafeERC20 for IERC20;\n\n    // Time-in-Force order types\n    enum Tif {\n        None, // invalid\n        ALO, // Add Liquidity Only\n        GTC, // Good-Till-Cancel\n        IOC // Immediate-or-Cancel\n    }\n\n    struct SpotBalance {\n        uint64 total;\n        uint64 hold; // Unused in this implementation\n        uint64 entryNtl; // Unused in this implementation\n    }\n\n    struct TokenInfo {\n        string name;\n        uint64[] spots;\n        uint64 deployerTradingFeeShare;\n        address deployer;\n        address evmContract;\n        uint8 szDecimals;\n        uint8 weiDecimals;\n        int8 evmExtraWeiDecimals;\n    }\n\n    struct CoreUserExists {\n        bool exists;\n    }\n\n    // Base asset bridge addresses\n    address public constant BASE_ASSET_BRIDGE_ADDRESS = 0x2000000000000000000000000000000000000000;\n    uint256 public constant BASE_ASSET_BRIDGE_ADDRESS_UINT256 = uint256(uint160(BASE_ASSET_BRIDGE_ADDRESS));\n\n    // Precompile addresses\n    // TODO: maybe we should be using https://github.com/hyperliquid-dev/hyper-evm-lib instead?\n    address public constant SPOT_BALANCE_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000801;\n    address public constant SPOT_PX_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000808;\n    address public constant CORE_USER_EXISTS_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000810;\n    address public constant TOKEN_INFO_PRECOMPILE_ADDRESS = 0x000000000000000000000000000000000000080C;\n    address public constant CORE_WRITER_PRECOMPILE_ADDRESS = 0x3333333333333333333333333333333333333333;\n\n    // CoreWriter action headers\n    bytes4 public constant LIMIT_ORDER_HEADER = 0x01000001; // version=1, action=1\n    bytes4 public constant SPOT_SEND_HEADER = 0x01000006; // version=1, action=6\n    bytes4 public constant CANCEL_BY_CLOID_HEADER = 0x0100000B; // version=1, action=11\n\n    // Errors\n    error LimitPxIsZero();\n    error OrderSizeIsZero();\n    error InvalidTif();\n    error SpotBalancePrecompileCallFailed();\n    error CoreUserExistsPrecompileCallFailed();\n    error TokenInfoPrecompileCallFailed();\n    error SpotPxPrecompileCallFailed();\n    error TransferAmtExceedsAssetBridgeBalance(uint256 amt, uint256 maxAmt);\n\n    /**\n     * @notice Transfer `amountEVM` from HyperEVM to `to` on HyperCore.\n     * @dev Returns the amount credited on Core in Core units (post conversion).\n     * @param erc20EVMAddress The address of the ERC20 token on HyperEVM\n     * @param erc20CoreIndex The HyperCore index id of the token to transfer\n     * @param to The address to receive tokens on HyperCore\n     * @param amountEVM The amount to transfer on HyperEVM\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMSent The amount sent on HyperEVM\n     * @return amountCoreToReceive The amount credited on Core in Core units (post conversion)\n     */\n    function transferERC20EVMToCore(\n        address erc20EVMAddress,\n        uint64 erc20CoreIndex,\n        address to,\n        uint256 amountEVM,\n        int8 decimalDiff\n    ) internal returns (uint256 amountEVMSent, uint64 amountCoreToReceive) {\n        // if the transfer amount exceeds the bridge balance, this wil revert\n        (uint256 _amountEVMToSend, uint64 _amountCoreToReceive) = maximumEVMSendAmountToAmounts(amountEVM, decimalDiff);\n\n        if (_amountEVMToSend != 0) {\n            // Transfer the tokens to this contract's address on HyperCore\n            IERC20(erc20EVMAddress).safeTransfer(toAssetBridgeAddress(erc20CoreIndex), _amountEVMToSend);\n\n            // Transfer the tokens from this contract on HyperCore to the `to` address on HyperCore\n            transferERC20CoreToCore(erc20CoreIndex, to, _amountCoreToReceive);\n        }\n\n        return (_amountEVMToSend, _amountCoreToReceive);\n    }\n\n    /**\n     * @notice Bridges `amountEVM` of `erc20` from this address on HyperEVM to this address on HyperCore.\n     * @dev Returns the amount credited on Core in Core units (post conversion).\n     * @dev The decimal difference is evmDecimals - coreDecimals\n     * @param erc20EVMAddress The address of the ERC20 token on HyperEVM\n     * @param erc20CoreIndex The HyperCore index id of the token to transfer\n     * @param amountEVM The amount to transfer on HyperEVM\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMSent The amount sent on HyperEVM\n     * @return amountCoreToReceive The amount credited on Core in Core units (post conversion)\n     */\n    function transferERC20EVMToSelfOnCore(\n        address erc20EVMAddress,\n        uint64 erc20CoreIndex,\n        uint256 amountEVM,\n        int8 decimalDiff\n    ) internal returns (uint256 amountEVMSent, uint64 amountCoreToReceive) {\n        (uint256 _amountEVMToSend, uint64 _amountCoreToReceive) = maximumEVMSendAmountToAmounts(amountEVM, decimalDiff);\n\n        if (_amountEVMToSend != 0) {\n            // Transfer the tokens to this contract's address on HyperCore\n            IERC20(erc20EVMAddress).safeTransfer(toAssetBridgeAddress(erc20CoreIndex), _amountEVMToSend);\n        }\n\n        return (_amountEVMToSend, _amountCoreToReceive);\n    }\n\n    /**\n     * @notice Transfers tokens from this contract on HyperCore to the `to` address on HyperCore\n     * @param erc20CoreIndex The HyperCore index id of the token\n     * @param to The address to receive tokens on HyperCore\n     * @param amountCore The amount to transfer on HyperCore\n     */\n    function transferERC20CoreToCore(uint64 erc20CoreIndex, address to, uint64 amountCore) internal {\n        bytes memory action = abi.encode(to, erc20CoreIndex, amountCore);\n        bytes memory payload = abi.encodePacked(SPOT_SEND_HEADER, action);\n\n        ICoreWriter(CORE_WRITER_PRECOMPILE_ADDRESS).sendRawAction(payload);\n    }\n\n    /**\n     * @notice Submit a limit order on HyperCore.\n     * @dev Expects price & size already scaled by 1e8 per HyperCore spec.\n     * @param asset The asset index of the order\n     * @param isBuy Whether the order is a buy order\n     * @param limitPriceX1e8 The limit price of the order scaled by 1e8\n     * @param sizeX1e8 The size of the order scaled by 1e8\n     * @param reduceOnly If true, only reduce existing position rather than opening a new opposing order\n     * @param tif Time-in-Force: ALO, GTC, IOC (None invalid)\n     * @param cloid The client order id of the order, 0 means no cloid\n     */\n    function submitLimitOrder(\n        uint32 asset,\n        bool isBuy,\n        uint64 limitPriceX1e8,\n        uint64 sizeX1e8,\n        bool reduceOnly,\n        Tif tif,\n        uint128 cloid\n    ) internal {\n        // Basic sanity checks\n        if (limitPriceX1e8 == 0) revert LimitPxIsZero();\n        if (sizeX1e8 == 0) revert OrderSizeIsZero();\n        if (tif == Tif.None || uint8(tif) > uint8(type(Tif).max)) revert InvalidTif();\n\n        // Encode the action\n        bytes memory encodedAction = abi.encode(asset, isBuy, limitPriceX1e8, sizeX1e8, reduceOnly, uint8(tif), cloid);\n\n        // Prefix with the limit-order header\n        bytes memory data = abi.encodePacked(LIMIT_ORDER_HEADER, encodedAction);\n\n        // Enqueue limit order to HyperCore via CoreWriter precompile\n        ICoreWriter(CORE_WRITER_PRECOMPILE_ADDRESS).sendRawAction(data);\n    }\n\n    /**\n     * @notice Enqueue a cancel-order-by-CLOID for a given asset.\n     * @param asset The asset index of the order\n     * @param cloid The client order id of the order\n     */\n    function cancelOrderByCloid(uint32 asset, uint128 cloid) internal {\n        // Encode the action\n        bytes memory encodedAction = abi.encode(asset, cloid);\n\n        // Prefix with the cancel-by-cloid header\n        bytes memory data = abi.encodePacked(CANCEL_BY_CLOID_HEADER, encodedAction);\n\n        // Enqueue cancel order by CLOID to HyperCore via CoreWriter precompile\n        ICoreWriter(CORE_WRITER_PRECOMPILE_ADDRESS).sendRawAction(data);\n    }\n\n    /**\n     * @notice Get the balance of the specified ERC20 for `account` on HyperCore.\n     * @param account The address of the account to get the balance of\n     * @param token The token to get the balance of\n     * @return balance The balance of the specified ERC20 for `account` on HyperCore\n     */\n    function spotBalance(address account, uint64 token) internal view returns (uint64 balance) {\n        (bool success, bytes memory result) = SPOT_BALANCE_PRECOMPILE_ADDRESS.staticcall(abi.encode(account, token));\n        if (!success) revert SpotBalancePrecompileCallFailed();\n        SpotBalance memory _spotBalance = abi.decode(result, (SpotBalance));\n        return _spotBalance.total;\n    }\n\n    /**\n     * @notice Checks if the user exists / has been activated on HyperCore.\n     * @param user The address of the user to check if they exist on HyperCore\n     * @return exists True if the user exists on HyperCore, false otherwise\n     */\n    function coreUserExists(address user) internal view returns (bool) {\n        (bool success, bytes memory result) = CORE_USER_EXISTS_PRECOMPILE_ADDRESS.staticcall(abi.encode(user));\n        if (!success) revert CoreUserExistsPrecompileCallFailed();\n        CoreUserExists memory _coreUserExists = abi.decode(result, (CoreUserExists));\n        return _coreUserExists.exists;\n    }\n\n    /**\n     * @notice Get the spot price of the specified asset on HyperCore.\n     * @param index The asset index to get the spot price of\n     * @return spotPx The spot price of the specified asset on HyperCore scaled by 1e8\n     */\n    function spotPx(uint32 index) internal view returns (uint64) {\n        (bool success, bytes memory result) = SPOT_PX_PRECOMPILE_ADDRESS.staticcall(abi.encode(index));\n        if (!success) revert SpotPxPrecompileCallFailed();\n        return abi.decode(result, (uint64));\n    }\n\n    /**\n     * @notice Get the info of the specified token on HyperCore.\n     * @param erc20CoreIndex The token to get the info of\n     * @return tokenInfo The info of the specified token on HyperCore\n     */\n    function tokenInfo(uint32 erc20CoreIndex) internal view returns (TokenInfo memory) {\n        (bool success, bytes memory result) = TOKEN_INFO_PRECOMPILE_ADDRESS.staticcall(abi.encode(erc20CoreIndex));\n        if (!success) revert TokenInfoPrecompileCallFailed();\n        TokenInfo memory _tokenInfo = abi.decode(result, (TokenInfo));\n        return _tokenInfo;\n    }\n\n    /**\n     * @notice Checks if an amount is safe to bridge from HyperEVM to HyperCore\n     * @dev Verifies that the asset bridge has sufficient balance to cover the amount plus a buffer\n     * @param erc20CoreIndex The HyperCore index id of the token\n     * @param coreAmount The amount that the bridging should result in on HyperCore\n     * @param coreBufferAmount The minimum buffer amount that should remain on HyperCore after bridging\n     * @return True if the bridge has enough balance to safely bridge the amount, false otherwise\n     */\n    function isCoreAmountSafeToBridge(\n        uint64 erc20CoreIndex,\n        uint64 coreAmount,\n        uint64 coreBufferAmount\n    ) internal view returns (bool) {\n        address bridgeAddress = toAssetBridgeAddress(erc20CoreIndex);\n        uint64 currentBridgeBalance = spotBalance(bridgeAddress, erc20CoreIndex);\n\n        // Return true if currentBridgeBalance >= coreAmount + coreBufferAmount\n        return currentBridgeBalance >= coreAmount + coreBufferAmount;\n    }\n\n    /**\n     * @notice Converts a core index id to an asset bridge address\n     * @param erc20CoreIndex The core token index id to convert\n     * @return assetBridgeAddress The asset bridge address\n     */\n    function toAssetBridgeAddress(uint64 erc20CoreIndex) internal pure returns (address) {\n        return address(uint160(BASE_ASSET_BRIDGE_ADDRESS_UINT256 + erc20CoreIndex));\n    }\n\n    /**\n     * @notice Converts an asset bridge address to a core index id\n     * @param assetBridgeAddress The asset bridge address to convert\n     * @return erc20CoreIndex The core token index id\n     */\n    function toTokenId(address assetBridgeAddress) internal pure returns (uint64) {\n        return uint64(uint160(assetBridgeAddress) - BASE_ASSET_BRIDGE_ADDRESS_UINT256);\n    }\n\n    /**\n     * @notice Returns an amount to send on HyperEVM to receive AT LEAST the minimumCoreReceiveAmount on HyperCore\n     * @param minimumCoreReceiveAmount The minimum amount desired to receive on HyperCore\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMToSend The amount to send on HyperEVM to receive at least minimumCoreReceiveAmount on HyperCore\n     * @return amountCoreToReceive The amount that will be received on core if the amountEVMToSend is sent from HyperEVM\n     */\n    function minimumCoreReceiveAmountToAmounts(\n        uint64 minimumCoreReceiveAmount,\n        int8 decimalDiff\n    ) internal pure returns (uint256 amountEVMToSend, uint64 amountCoreToReceive) {\n        if (decimalDiff == 0) {\n            // Same decimals between HyperEVM and HyperCore\n            amountEVMToSend = uint256(minimumCoreReceiveAmount);\n            amountCoreToReceive = minimumCoreReceiveAmount;\n        } else if (decimalDiff > 0) {\n            // EVM token has more decimals than Core\n            // Scale up to represent the same value in higher-precision EVM units\n            amountEVMToSend = uint256(minimumCoreReceiveAmount) * (10 ** uint8(decimalDiff));\n            amountCoreToReceive = minimumCoreReceiveAmount;\n        } else {\n            // Core token has more decimals than EVM\n            // Scale down, rounding UP to avoid shortfall on Core\n            uint256 scaleDivisor = 10 ** uint8(-decimalDiff);\n            amountEVMToSend = (uint256(minimumCoreReceiveAmount) + scaleDivisor - 1) / scaleDivisor; // ceil division\n            amountCoreToReceive = uint64(amountEVMToSend * scaleDivisor);\n        }\n    }\n\n    /**\n     * @notice Converts a maximum EVM amount to send into an EVM amount to send to avoid loss to dust,\n     * @notice and the corresponding amount that will be recieved on Core.\n     * @param maximumEVMSendAmount The maximum amount to send on HyperEVM\n     * @param decimalDiff The decimal difference of evmDecimals - coreDecimals\n     * @return amountEVMToSend The amount to send on HyperEVM\n     * @return amountCoreToReceive The amount that will be received on HyperCore if the amountEVMToSend is sent\n     */\n    function maximumEVMSendAmountToAmounts(\n        uint256 maximumEVMSendAmount,\n        int8 decimalDiff\n    ) internal pure returns (uint256 amountEVMToSend, uint64 amountCoreToReceive) {\n        /// @dev HyperLiquid decimal conversion: Scale EVM (u256,evmDecimals) -> Core (u64,coreDecimals)\n        /// @dev Core amount is guaranteed to be within u64 range.\n        if (decimalDiff == 0) {\n            amountEVMToSend = maximumEVMSendAmount;\n            amountCoreToReceive = uint64(amountEVMToSend);\n        } else if (decimalDiff > 0) {\n            // EVM token has more decimals than Core\n            uint256 scale = 10 ** uint8(decimalDiff);\n            amountEVMToSend = maximumEVMSendAmount - (maximumEVMSendAmount % scale); // Safe: dustAmount = maximumEVMSendAmount % scale, so dust <= maximumEVMSendAmount\n\n            /// @dev Safe: Guaranteed to be in the range of [0, u64.max] because it is upperbounded by uint64 maxAmt\n            amountCoreToReceive = uint64(amountEVMToSend / scale);\n        } else {\n            // Core token has more decimals than EVM\n            uint256 scale = 10 ** uint8(-1 * decimalDiff);\n            amountEVMToSend = maximumEVMSendAmount;\n\n            /// @dev Safe: Guaranteed to be in the range of [0, u64.max] because it is upperbounded by uint64 maxAmt\n            amountCoreToReceive = uint64(amountEVMToSend * scale);\n        }\n    }\n\n    function convertCoreDecimalsSimple(\n        uint64 amountDecimalsFrom,\n        uint8 decimalsFrom,\n        uint8 decimalsTo\n    ) internal pure returns (uint64) {\n        if (decimalsFrom == decimalsTo) {\n            return amountDecimalsFrom;\n        } else if (decimalsFrom < decimalsTo) {\n            return uint64(amountDecimalsFrom * 10 ** (decimalsTo - decimalsFrom));\n        } else {\n            // round down\n            return uint64(amountDecimalsFrom / 10 ** (decimalsFrom - decimalsTo));\n        }\n    }\n}\n",
        "HyperCoreFlowExecutor.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { DonationBox } from \"../../chain-adapters/DonationBox.sol\";\nimport { HyperCoreLib } from \"../../libraries/HyperCoreLib.sol\";\nimport { CoreTokenInfo } from \"./Structs.sol\";\nimport { FinalTokenInfo } from \"./Structs.sol\";\nimport { SwapHandler } from \"./SwapHandler.sol\";\nimport { BPS_SCALAR, BPS_DECIMALS } from \"./Constants.sol\";\nimport { Lockable } from \"../../Lockable.sol\";\nimport { CommonFlowParams } from \"./Structs.sol\";\n\n/**\n * @title HyperCoreFlowExecutor\n * @notice Contract handling HyperCore interactions for transfer-to-core or swap-with-core actions after stablecoin bridge transactions\n * @dev This contract is designed to work with stablecoins. baseToken and every finalToken should all be stablecoins.\n * @custom:security-contact bugs@across.to\n */\ncontract HyperCoreFlowExecutor is AccessControl, Lockable {\n    using SafeERC20 for IERC20;\n\n    // Common decimals scalars\n    uint256 public constant PPM_DECIMALS = 6;\n    uint256 public constant PPM_SCALAR = 10 ** PPM_DECIMALS;\n    // Decimals to use for Price calculations in limit order-related calculation functions\n    uint8 public constant PX_D = 8;\n    uint64 public constant ONEX1e8 = 10 ** 8;\n\n    // Roles\n    bytes32 public constant PERMISSIONED_BOT_ROLE = keccak256(\"PERMISSIONED_BOT_ROLE\");\n    bytes32 public constant FUNDS_SWEEPER_ROLE = keccak256(\"FUNDS_SWEEPER_ROLE\");\n\n    /// @notice The donation box contract.\n    DonationBox public immutable donationBox;\n\n    /// @notice A mapping of token addresses to their core token info.\n    mapping(address => CoreTokenInfo) public coreTokenInfos;\n\n    /// @notice A mapping of token address to additional relevan info for final tokens, like Hyperliquid market params\n    mapping(address => FinalTokenInfo) public finalTokenInfos;\n\n    /// @notice All operations performed in this contract are relative to this baseToken\n    address public immutable baseToken;\n\n    /// @notice The block number of the last funds pull action per final token: either as a part of finalizing pending swaps,\n    /// or an admin funds pull\n    mapping(address finalToken => uint256 lastPullFundsBlock) public lastPullFundsBlock;\n\n    /// @notice A struct used for storing state of a swap flow that has been initialized, but not yet finished\n    struct SwapFlowState {\n        address finalRecipient;\n        address finalToken;\n        uint64 minAmountToSend; // for sponsored: one to one, non-sponsored: one to one minus slippage\n        uint64 maxAmountToSend; // for sponsored: one to one (from total bridged amt), for non-sponsored: one to one, less bridging fees incurred\n        bool isSponsored;\n        bool finalized;\n    }\n\n    /// @notice A mapping containing the pending state between initializing the swap flow and finalizing it\n    mapping(bytes32 quoteNonce => SwapFlowState swap) public swaps;\n\n    /// @notice The cumulative amount of funds sponsored for each final token.\n    mapping(address => uint256) public cumulativeSponsoredAmount;\n    /// @notice The cumulative amount of activation fees sponsored for each final token.\n    mapping(address => uint256) public cumulativeSponsoredActivationFee;\n\n    /**************************************\n     *            EVENTS               *\n     **************************************/\n\n    /// @notice Emitted when the donation box is insufficient funds.\n    event DonationBoxInsufficientFunds(bytes32 indexed quoteNonce, address token, uint256 amount, uint256 balance);\n\n    /// @notice Emitted whenever the account is not activated in the non-sponsored flow. We fall back to HyperEVM flow in that case\n    event AccountNotActivated(bytes32 indexed quoteNonce, address user);\n\n    /// @notice Emitted when a simple transfer to core is executed.\n    event SimpleTransferFlowCompleted(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // All amounts are in finalToken\n        uint256 evmAmountIn,\n        uint256 bridgingFeesIncurred,\n        uint256 evmAmountSponsored\n    );\n\n    /// @notice Emitted upon successful completion of fallback HyperEVM flow\n    event FallbackHyperEVMFlowCompleted(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // All amounts are in finalToken\n        uint256 evmAmountIn,\n        uint256 bridgingFeesIncurred,\n        uint256 evmAmountSponsored\n    );\n\n    /// @notice Emitted when a swap flow is initialized\n    event SwapFlowInitialized(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // In baseToken\n        uint256 evmAmountIn,\n        uint256 bridgingFeesIncurred,\n        // In finalToken\n        uint256 coreAmountIn,\n        uint64 minAmountToSend,\n        uint64 maxAmountToSend\n    );\n\n    /// @notice Emitted when a swap flow is finalized\n    event SwapFlowFinalized(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed finalToken,\n        // In finalToken\n        uint64 totalSent,\n        // In EVM finalToken\n        uint256 evmAmountSponsored\n    );\n\n    /// @notice Emitted upon cancelling a Limit order\n    event CancelledLimitOrder(address indexed token, uint128 indexed cloid);\n\n    /// @notice Emitted upon cancelling a Limit order\n    event SubmittedLimitOrder(address indexed token, uint64 priceX1e8, uint64 sizeX1e8, uint128 indexed cloid);\n\n    /// @notice Emitted when we have to fall back from the swap flow because it's too expensive (either to sponsor or the slippage is too big)\n    event SwapFlowTooExpensive(\n        bytes32 indexed quoteNonce,\n        address indexed finalToken,\n        uint256 estBpsSlippage,\n        uint256 maxAllowableBpsSlippage\n    );\n\n    /// @notice Emitted when we can't bridge some token from HyperEVM to HyperCore\n    event UnsafeToBridge(bytes32 indexed quoteNonce, address indexed token, uint64 amount);\n\n    /// @notice Emitted whenever donationBox funds are used for activating a user account\n    event SponsoredAccountActivation(\n        bytes32 indexed quoteNonce,\n        address indexed finalRecipient,\n        address indexed fundingToken,\n        uint256 evmAmountSponsored\n    );\n\n    /// @notice Emitted whenever a new CoreTokenInfo is configured\n    event SetCoreTokenInfo(\n        address indexed token,\n        uint32 coreIndex,\n        bool canBeUsedForAccountActivation,\n        uint64 accountActivationFeeCore,\n        uint64 bridgeSafetyBufferCore\n    );\n\n    /// @notice Emitted when we do an ad-hoc send of sponsorship funds to one of the Swap Handlers\n    event SentSponsorshipFundsToSwapHandler(address indexed token, uint256 evmAmountSponsored);\n\n    /**************************************\n     *            ERRORS               *\n     **************************************/\n\n    /// @notice Thrown when an attempt to finalize a non-existing swap is made\n    error SwapDoesNotExist();\n\n    /// @notice Thrown when an attemp to finalize an already finalized swap is made\n    error SwapAlreadyFinalized();\n\n    /// @notice Thrown when trying to finalize a quoteNonce, calling a finalizeSwapFlows with an incorrect token\n    error WrongSwapFinalizationToken(bytes32 quoteNonce);\n\n    /// @notice Emitted when the donation box is insufficient funds and we can't proceed.\n    error DonationBoxInsufficientFundsError(address token, uint256 amount);\n\n    /// @notice Emitted when we're inside the sponsored flow and a user doesn't have a HyperCore account activated. The\n    /// bot should activate user's account first by calling `activateUserAccount`\n    error AccountNotActivatedError(address user);\n\n    /// @notice Thrown when we can't bridge some token from HyperEVM to HyperCore\n    error UnsafeToBridgeError(address token, uint64 amount);\n\n    /**************************************\n     *            MODIFIERS               *\n     **************************************/\n\n    modifier onlyDefaultAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not default admin\");\n        _;\n    }\n\n    modifier onlyPermissionedBot() {\n        require(hasRole(PERMISSIONED_BOT_ROLE, msg.sender), \"Not limit order updater\");\n        _;\n    }\n\n    modifier onlyFundsSweeper() {\n        require(hasRole(FUNDS_SWEEPER_ROLE, msg.sender), \"Not funds sweeper\");\n        _;\n    }\n\n    modifier onlyExistingCoreToken(address evmTokenAddress) {\n        _getExistingCoreTokenInfo(evmTokenAddress);\n        _;\n    }\n\n    /// @notice Reverts if the token is not configured\n    function _getExistingCoreTokenInfo(\n        address evmTokenAddress\n    ) internal view returns (CoreTokenInfo memory coreTokenInfo) {\n        coreTokenInfo = coreTokenInfos[evmTokenAddress];\n        require(\n            coreTokenInfo.tokenInfo.evmContract != address(0) && coreTokenInfo.tokenInfo.weiDecimals != 0,\n            \"CoreTokenInfo not set\"\n        );\n    }\n\n    /// @notice Reverts if the token is not configured\n    function _getExistingFinalTokenInfo(\n        address evmTokenAddress\n    ) internal view returns (FinalTokenInfo memory finalTokenInfo) {\n        finalTokenInfo = finalTokenInfos[evmTokenAddress];\n        require(address(finalTokenInfo.swapHandler) != address(0), \"FinalTokenInfo not set\");\n    }\n\n    /**\n     *\n     * @param _donationBox Sponsorship funds live here\n     * @param _baseToken Main token used with this Forwarder\n     */\n    constructor(address _donationBox, address _baseToken) {\n        donationBox = DonationBox(_donationBox);\n        baseToken = _baseToken;\n\n        // AccessControl setup\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(PERMISSIONED_BOT_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(FUNDS_SWEEPER_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n\n    /**************************************\n     *      CONFIGURATION FUNCTIONS       *\n     **************************************/\n\n    /**\n     * @notice Set or update information for the token to use it in this contract\n     * @dev To be able to use the token in the swap flow, FinalTokenInfo has to be set as well\n     * @dev Setting core token info to incorrect values can lead to loss of funds. Should NEVER be unset while the\n     * finalTokenParams are not unset\n     */\n    function setCoreTokenInfo(\n        address token,\n        uint32 coreIndex,\n        bool canBeUsedForAccountActivation,\n        uint64 accountActivationFeeCore,\n        uint64 bridgeSafetyBufferCore\n    ) external nonReentrant onlyDefaultAdmin {\n        _setCoreTokenInfo(\n            token,\n            coreIndex,\n            canBeUsedForAccountActivation,\n            accountActivationFeeCore,\n            bridgeSafetyBufferCore\n        );\n    }\n\n    /**\n     * @notice Sets the parameters for a final token.\n     * @dev This function deploys a new SwapHandler contract if one is not already set. If the final token\n     * can't be used for account activation, the handler will be left unactivated and would need to be activated by the caller.\n     * @param finalToken The address of the final token.\n     * @param assetIndex The index of the asset in the Hyperliquid market.\n     * @param isBuy Whether the final token is a buy or a sell.\n     * @param feePpm The fee in parts per million.\n     * @param suggestedDiscountBps The suggested slippage in basis points.\n     * @param accountActivationFeeToken A token to pay account activation fee in. Only used if adding a new final token\n     */\n    function setFinalTokenInfo(\n        address finalToken,\n        uint32 assetIndex,\n        bool isBuy,\n        uint32 feePpm,\n        uint32 suggestedDiscountBps,\n        address accountActivationFeeToken\n    )\n        external\n        nonReentrant\n        onlyExistingCoreToken(finalToken)\n        onlyExistingCoreToken(accountActivationFeeToken)\n        onlyDefaultAdmin\n    {\n        SwapHandler swapHandler = finalTokenInfos[finalToken].swapHandler;\n        if (address(swapHandler) == address(0)) {\n            bytes32 salt = _swapHandlerSalt(finalToken);\n            swapHandler = new SwapHandler{ salt: salt }();\n        }\n\n        finalTokenInfos[finalToken] = FinalTokenInfo({\n            assetIndex: assetIndex,\n            isBuy: isBuy,\n            feePpm: feePpm,\n            swapHandler: swapHandler,\n            suggestedDiscountBps: suggestedDiscountBps\n        });\n\n        // We don't allow SwapHandler accounts to be uninitiated. That could lead to loss of funds. They instead should\n        // be pre-funded using `predictSwapHandler` to predict their address\n        require(HyperCoreLib.coreUserExists(address(swapHandler)), \"SwapHandler @ core doesn't exist\");\n    }\n\n    /// @notice Predicts the deterministic address of a SwapHandler for a given finalToken using CREATE2\n    function predictSwapHandler(address finalToken) public view returns (address) {\n        bytes32 salt = _swapHandlerSalt(finalToken);\n        bytes32 initCodeHash = keccak256(type(SwapHandler).creationCode);\n        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash)))));\n    }\n\n    /// @notice Returns the salt to use when creating a SwapHandler via CREATE2\n    function _swapHandlerSalt(address finalToken) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), finalToken));\n    }\n\n    /**************************************\n     *            FLOW FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice This function is to be called by an inheriting contract. It is to be called after the child contract\n     * checked the API signature and made sure that the params passed here have been verified by either the underlying\n     * bridge mechanics, or API signaure, or both.\n     */\n    function _executeFlow(CommonFlowParams memory params, uint256 maxUserSlippageBps) internal {\n        if (params.finalToken == baseToken) {\n            _executeSimpleTransferFlow(params);\n        } else {\n            _initiateSwapFlow(params, maxUserSlippageBps);\n        }\n    }\n\n    /// @notice Execute a simple transfer flow in which we transfer `finalToken` to the user on HyperCore after receiving\n    /// an amount of finalToken from the user on HyperEVM\n    function _executeSimpleTransferFlow(CommonFlowParams memory params) internal virtual {\n        address finalToken = params.finalToken;\n        CoreTokenInfo storage coreTokenInfo = coreTokenInfos[finalToken];\n\n        // Check account activation\n        if (!HyperCoreLib.coreUserExists(params.finalRecipient)) {\n            if (params.maxBpsToSponsor > 0) {\n                revert AccountNotActivatedError(params.finalRecipient);\n            } else {\n                emit AccountNotActivated(params.quoteNonce, params.finalRecipient);\n                _fallbackHyperEVMFlow(params);\n                return;\n            }\n        }\n\n        // Calculate sponsorship amount in scope\n        uint256 amountToSponsor;\n        {\n            uint256 maxEvmAmountToSponsor = ((params.amountInEVM + params.extraFeesIncurred) * params.maxBpsToSponsor) /\n                BPS_SCALAR;\n            amountToSponsor = params.extraFeesIncurred;\n            if (amountToSponsor > maxEvmAmountToSponsor) {\n                amountToSponsor = maxEvmAmountToSponsor;\n            }\n\n            if (amountToSponsor > 0) {\n                if (!_availableInDonationBox(params.quoteNonce, coreTokenInfo.tokenInfo.evmContract, amountToSponsor)) {\n                    amountToSponsor = 0;\n                }\n            }\n        }\n\n        // Calculate quoted amounts and check safety\n        uint256 quotedEvmAmount;\n        uint64 quotedCoreAmount;\n        {\n            uint256 finalAmount = params.amountInEVM + amountToSponsor;\n            (quotedEvmAmount, quotedCoreAmount) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n                finalAmount,\n                coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n            );\n            // If there are no funds left on the destination side of the bridge, the funds will be lost in the\n            // bridge. We check send safety via `isCoreAmountSafeToBridge`\n            if (\n                !HyperCoreLib.isCoreAmountSafeToBridge(\n                    coreTokenInfo.coreIndex,\n                    quotedCoreAmount,\n                    coreTokenInfo.bridgeSafetyBufferCore\n                )\n            ) {\n                // If the amount is not safe to bridge because the bridge doesn't have enough liquidity,\n                // fall back to sending user funds on HyperEVM.\n                _fallbackHyperEVMFlow(params);\n                emit UnsafeToBridge(params.quoteNonce, finalToken, quotedCoreAmount);\n                return;\n            }\n        }\n\n        if (amountToSponsor > 0) {\n            // This will succeed because we checked the balance earlier\n            donationBox.withdraw(IERC20(coreTokenInfo.tokenInfo.evmContract), amountToSponsor);\n        }\n\n        cumulativeSponsoredAmount[finalToken] += amountToSponsor;\n\n        // There is a very slim change that someone is sending > buffer amount in the same EVM block and the balance of\n        // the bridge is not enough to cover our transfer, so the funds are lost.\n        HyperCoreLib.transferERC20EVMToCore(\n            finalToken,\n            coreTokenInfo.coreIndex,\n            params.finalRecipient,\n            quotedEvmAmount,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        emit SimpleTransferFlowCompleted(\n            params.quoteNonce,\n            params.finalRecipient,\n            finalToken,\n            params.amountInEVM,\n            params.extraFeesIncurred,\n            amountToSponsor\n        );\n    }\n\n    /**\n     * @notice Initiates the swap flow. Sends the funds received on EVM side over to a SwapHandler corresponding to a\n     * finalToken. This is the first leg of the swap flow. Next, the bot should submit a limit order through a `submitLimitOrder`\n     * function, and then settle the flow via a `finalizeSwapFlows` function\n     * @dev Only works for stable -> stable swap flows (or equivalent token flows. Price between tokens is supposed to be approximately one to one)\n     * @param maxUserSlippageBps Describes a configured user setting. Slippage here is wrt the one to one exchange\n     */\n    function _initiateSwapFlow(CommonFlowParams memory params, uint256 maxUserSlippageBps) internal {\n        // Check account activation\n        if (!HyperCoreLib.coreUserExists(params.finalRecipient)) {\n            if (params.maxBpsToSponsor > 0) {\n                revert AccountNotActivatedError(params.finalRecipient);\n            } else {\n                emit AccountNotActivated(params.quoteNonce, params.finalRecipient);\n                _fallbackHyperEVMFlow(params);\n                return;\n            }\n        }\n\n        address initialToken = baseToken;\n        CoreTokenInfo memory initialCoreTokenInfo = coreTokenInfos[initialToken];\n        CoreTokenInfo memory finalCoreTokenInfo = coreTokenInfos[params.finalToken];\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(params.finalToken);\n\n        // Calculate limit order amounts and check if feasible\n        uint64 minAllowableAmountToForwardCore;\n        uint64 maxAllowableAmountToForwardCore;\n        // Estimated slippage in ppm, as compared to a one-to-one totalBridgedAmount -> finalAmount conversion\n        uint256 estSlippagePpm;\n        {\n            // In finalToken\n            (minAllowableAmountToForwardCore, maxAllowableAmountToForwardCore) = _calcAllowableAmtsSwapFlow(\n                params.amountInEVM,\n                params.extraFeesIncurred,\n                initialCoreTokenInfo,\n                finalCoreTokenInfo,\n                params.maxBpsToSponsor > 0,\n                maxUserSlippageBps\n            );\n\n            uint64 approxExecutionPriceX1e8 = _getApproxRealizedPrice(finalTokenInfo);\n            uint256 maxAllowableBpsDeviation = params.maxBpsToSponsor > 0 ? params.maxBpsToSponsor : maxUserSlippageBps;\n            if (finalTokenInfo.isBuy) {\n                if (approxExecutionPriceX1e8 < ONEX1e8) {\n                    estSlippagePpm = 0;\n                } else {\n                    // ceil\n                    estSlippagePpm = ((approxExecutionPriceX1e8 - ONEX1e8) * PPM_SCALAR + (ONEX1e8 - 1)) / ONEX1e8;\n                }\n            } else {\n                if (approxExecutionPriceX1e8 > ONEX1e8) {\n                    estSlippagePpm = 0;\n                } else {\n                    // ceil\n                    estSlippagePpm = ((ONEX1e8 - approxExecutionPriceX1e8) * PPM_SCALAR + (ONEX1e8 - 1)) / ONEX1e8;\n                }\n            }\n            // Add `extraFeesIncurred` to \"slippage from one to one\"\n            estSlippagePpm +=\n                (params.extraFeesIncurred * PPM_SCALAR + (params.amountInEVM + params.extraFeesIncurred) - 1) /\n                (params.amountInEVM + params.extraFeesIncurred);\n\n            if (estSlippagePpm > maxAllowableBpsDeviation * 10 ** (PPM_DECIMALS - BPS_DECIMALS)) {\n                emit SwapFlowTooExpensive(\n                    params.quoteNonce,\n                    params.finalToken,\n                    (estSlippagePpm + 10 ** (PPM_DECIMALS - BPS_DECIMALS) - 1) / 10 ** (PPM_DECIMALS - BPS_DECIMALS),\n                    maxAllowableBpsDeviation\n                );\n                params.finalToken = initialToken;\n                _executeSimpleTransferFlow(params);\n                return;\n            }\n        }\n\n        (uint256 tokensToSendEvm, uint64 coreAmountIn) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n            params.amountInEVM,\n            initialCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        // Check that we can safely bridge to HCore (for the trade amount actually needed)\n        bool isSafeToBridgeMainToken = HyperCoreLib.isCoreAmountSafeToBridge(\n            initialCoreTokenInfo.coreIndex,\n            coreAmountIn,\n            initialCoreTokenInfo.bridgeSafetyBufferCore\n        );\n\n        if (!isSafeToBridgeMainToken) {\n            emit UnsafeToBridge(params.quoteNonce, initialToken, coreAmountIn);\n            params.finalToken = initialToken;\n            _fallbackHyperEVMFlow(params);\n            return;\n        }\n\n        // Finalize swap flow setup by updating state and funding SwapHandler\n        // State changes\n        swaps[params.quoteNonce] = SwapFlowState({\n            finalRecipient: params.finalRecipient,\n            finalToken: params.finalToken,\n            minAmountToSend: minAllowableAmountToForwardCore,\n            maxAmountToSend: maxAllowableAmountToForwardCore,\n            isSponsored: params.maxBpsToSponsor > 0,\n            finalized: false\n        });\n\n        emit SwapFlowInitialized(\n            params.quoteNonce,\n            params.finalRecipient,\n            params.finalToken,\n            params.amountInEVM,\n            params.extraFeesIncurred,\n            coreAmountIn,\n            minAllowableAmountToForwardCore,\n            maxAllowableAmountToForwardCore\n        );\n\n        // Send amount received form user to a corresponding SwapHandler\n        SwapHandler swapHandler = finalTokenInfo.swapHandler;\n        IERC20(initialToken).safeTransfer(address(swapHandler), tokensToSendEvm);\n        swapHandler.transferFundsToSelfOnCore(\n            initialToken,\n            initialCoreTokenInfo.coreIndex,\n            tokensToSendEvm,\n            initialCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n    }\n\n    /**\n     * @notice Finalizes multiple swap flows associated with a final token, subject to the L1 Hyperliquid balance\n     * @dev Caller is responsible for providing correct limitOrderOutput amounts per assosicated swap flow. The caller\n     * has to estimate how much final tokens it received on core based on the input of the corresponding quote nonce\n     * swap flow\n     */\n    function finalizeSwapFlows(\n        address finalToken,\n        bytes32[] calldata quoteNonces,\n        uint64[] calldata limitOrderOuts\n    ) external onlyPermissionedBot returns (uint256 finalized) {\n        require(quoteNonces.length == limitOrderOuts.length, \"length\");\n        require(lastPullFundsBlock[finalToken] < block.number, \"too soon\");\n\n        CoreTokenInfo memory finalCoreTokenInfo = _getExistingCoreTokenInfo(finalToken);\n        FinalTokenInfo memory finalTokenInfo = finalTokenInfos[finalToken];\n\n        uint64 availableBalance = HyperCoreLib.spotBalance(\n            address(finalTokenInfo.swapHandler),\n            finalCoreTokenInfo.coreIndex\n        );\n        uint64 totalAdditionalToSend = 0;\n        for (; finalized < quoteNonces.length; ++finalized) {\n            bool success;\n            uint64 additionalToSend;\n            (success, additionalToSend, availableBalance) = _finalizeSingleSwap(\n                quoteNonces[finalized],\n                limitOrderOuts[finalized],\n                finalCoreTokenInfo,\n                availableBalance\n            );\n            if (!success) {\n                break;\n            }\n            totalAdditionalToSend += additionalToSend;\n        }\n\n        if (finalized > 0) {\n            lastPullFundsBlock[finalToken] = block.number;\n        } else {\n            return 0;\n        }\n\n        if (totalAdditionalToSend > 0) {\n            (uint256 totalAdditionalToSendEVM, uint64 totalAdditionalReceivedCore) = HyperCoreLib\n                .minimumCoreReceiveAmountToAmounts(\n                    totalAdditionalToSend,\n                    finalCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n                );\n\n            if (\n                !HyperCoreLib.isCoreAmountSafeToBridge(\n                    finalCoreTokenInfo.coreIndex,\n                    totalAdditionalReceivedCore,\n                    finalCoreTokenInfo.bridgeSafetyBufferCore\n                )\n            ) {\n                // We expect this situation to be so rare and / or intermittend that we're willing to rely on admin to sweep the funds if this leads to\n                // swaps being impossible to finalize\n                revert UnsafeToBridgeError(finalCoreTokenInfo.tokenInfo.evmContract, totalAdditionalToSend);\n            }\n\n            cumulativeSponsoredAmount[finalToken] += totalAdditionalToSendEVM;\n\n            // ! Notice: as per HyperEVM <> HyperCore rules, this amount will land on HyperCore *before* all of the core > core sends get executed\n            // Get additional amount to send from donation box, and send it to self on core\n            donationBox.withdraw(IERC20(finalToken), totalAdditionalToSendEVM);\n            IERC20(finalToken).safeTransfer(address(finalTokenInfo.swapHandler), totalAdditionalToSendEVM);\n            finalTokenInfo.swapHandler.transferFundsToSelfOnCore(\n                finalToken,\n                finalCoreTokenInfo.coreIndex,\n                totalAdditionalToSendEVM,\n                finalCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n            );\n        }\n    }\n\n    /// @notice Finalizes a single swap flow, sending the tokens to user on core. Relies on caller to send the `additionalToSend`\n    function _finalizeSingleSwap(\n        bytes32 quoteNonce,\n        uint64 limitOrderOut,\n        CoreTokenInfo memory finalCoreTokenInfo,\n        uint64 availableBalance\n    ) internal returns (bool success, uint64 additionalToSend, uint64 balanceRemaining) {\n        SwapFlowState storage swap = swaps[quoteNonce];\n        if (swap.finalRecipient == address(0)) revert SwapDoesNotExist();\n        if (swap.finalized) revert SwapAlreadyFinalized();\n        if (swap.finalToken != finalCoreTokenInfo.tokenInfo.evmContract) revert WrongSwapFinalizationToken(quoteNonce);\n\n        uint64 totalToSend;\n        (totalToSend, additionalToSend) = _calcSwapFlowSendAmounts(\n            limitOrderOut,\n            swap.minAmountToSend,\n            swap.maxAmountToSend,\n            swap.isSponsored\n        );\n\n        // `additionalToSend` will land on HCore before this core > core send will need to be executed\n        balanceRemaining = availableBalance + additionalToSend;\n        if (totalToSend > balanceRemaining) {\n            return (false, 0, availableBalance);\n        }\n\n        swap.finalized = true;\n        success = true;\n        balanceRemaining -= totalToSend;\n\n        (uint256 additionalToSendEVM, ) = HyperCoreLib.minimumCoreReceiveAmountToAmounts(\n            additionalToSend,\n            finalCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        HyperCoreLib.transferERC20CoreToCore(finalCoreTokenInfo.coreIndex, swap.finalRecipient, totalToSend);\n        emit SwapFlowFinalized(quoteNonce, swap.finalRecipient, swap.finalToken, totalToSend, additionalToSendEVM);\n    }\n\n    /// @notice Forwards `amount` plus potential sponsorship funds (for bridging fee) to user on HyperEVM\n    function _fallbackHyperEVMFlow(CommonFlowParams memory params) internal virtual {\n        uint256 maxEvmAmountToSponsor = ((params.amountInEVM + params.extraFeesIncurred) * params.maxBpsToSponsor) /\n            BPS_SCALAR;\n        uint256 sponsorshipFundsToForward = params.extraFeesIncurred > maxEvmAmountToSponsor\n            ? maxEvmAmountToSponsor\n            : params.extraFeesIncurred;\n\n        if (!_availableInDonationBox(params.quoteNonce, params.finalToken, sponsorshipFundsToForward)) {\n            sponsorshipFundsToForward = 0;\n        }\n        if (sponsorshipFundsToForward > 0) {\n            donationBox.withdraw(IERC20(params.finalToken), sponsorshipFundsToForward);\n        }\n        uint256 totalAmountToForward = params.amountInEVM + sponsorshipFundsToForward;\n        IERC20(params.finalToken).safeTransfer(params.finalRecipient, totalAmountToForward);\n        cumulativeSponsoredAmount[params.finalToken] += sponsorshipFundsToForward;\n        emit FallbackHyperEVMFlowCompleted(\n            params.quoteNonce,\n            params.finalRecipient,\n            params.finalToken,\n            params.amountInEVM,\n            params.extraFeesIncurred,\n            sponsorshipFundsToForward\n        );\n    }\n\n    /**\n     * @notice Activates a user account on Core by funding the account activation fee.\n     * @param quoteNonce The nonce of the quote that is used to identify the user.\n     * @param finalRecipient The address of the recipient of the funds.\n     * @param fundingToken The address of the token that is used to fund the account activation fee.\n     */\n    function activateUserAccount(\n        bytes32 quoteNonce,\n        address finalRecipient,\n        address fundingToken\n    ) external nonReentrant onlyPermissionedBot {\n        CoreTokenInfo memory coreTokenInfo = _getExistingCoreTokenInfo(fundingToken);\n        bool coreUserExists = HyperCoreLib.coreUserExists(finalRecipient);\n        require(coreUserExists == false, \"Can't fund account activation for existing user\");\n        require(coreTokenInfo.canBeUsedForAccountActivation, \"Token can't be used for this\");\n        bool safeToBridge = HyperCoreLib.isCoreAmountSafeToBridge(\n            coreTokenInfo.coreIndex,\n            coreTokenInfo.accountActivationFeeCore,\n            coreTokenInfo.bridgeSafetyBufferCore\n        );\n        require(safeToBridge, \"Not safe to bridge\");\n        uint256 activationFeeEvm = coreTokenInfo.accountActivationFeeEVM;\n        cumulativeSponsoredActivationFee[fundingToken] += activationFeeEvm;\n\n        // donationBox @ evm -> Handler @ evm\n        donationBox.withdraw(IERC20(fundingToken), activationFeeEvm);\n        // Handler @ evm -> Handler @ core -> finalRecipient @ core\n        HyperCoreLib.transferERC20EVMToCore(\n            fundingToken,\n            coreTokenInfo.coreIndex,\n            finalRecipient,\n            activationFeeEvm,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n\n        emit SponsoredAccountActivation(quoteNonce, finalRecipient, fundingToken, activationFeeEvm);\n    }\n\n    /// @notice Cancells a pending limit order by `cloid` with an intention to submit a new limit order in its place. To\n    /// be used for stale limit orders to speed up executing user transactions\n    function cancelLimitOrderByCloid(address finalToken, uint128 cloid) external nonReentrant onlyPermissionedBot {\n        FinalTokenInfo memory finalTokenInfo = finalTokenInfos[finalToken];\n        finalTokenInfo.swapHandler.cancelOrderByCloid(finalTokenInfo.assetIndex, cloid);\n\n        emit CancelledLimitOrder(finalToken, cloid);\n    }\n\n    function submitLimitOrderFromBot(\n        address finalToken,\n        uint64 priceX1e8,\n        uint64 sizeX1e8,\n        uint128 cloid\n    ) external nonReentrant onlyPermissionedBot {\n        FinalTokenInfo memory finalTokenInfo = finalTokenInfos[finalToken];\n        finalTokenInfo.swapHandler.submitLimitOrder(finalTokenInfo, priceX1e8, sizeX1e8, cloid);\n\n        emit SubmittedLimitOrder(finalToken, priceX1e8, sizeX1e8, cloid);\n    }\n\n    function _setCoreTokenInfo(\n        address token,\n        uint32 coreIndex,\n        bool canBeUsedForAccountActivation,\n        uint64 accountActivationFeeCore,\n        uint64 bridgeSafetyBufferCore\n    ) internal {\n        HyperCoreLib.TokenInfo memory tokenInfo = HyperCoreLib.tokenInfo(coreIndex);\n        require(tokenInfo.evmContract == token, \"Token mismatch\");\n\n        (uint256 accountActivationFeeEVM, ) = HyperCoreLib.minimumCoreReceiveAmountToAmounts(\n            accountActivationFeeCore,\n            tokenInfo.evmExtraWeiDecimals\n        );\n\n        coreTokenInfos[token] = CoreTokenInfo({\n            tokenInfo: tokenInfo,\n            coreIndex: coreIndex,\n            canBeUsedForAccountActivation: canBeUsedForAccountActivation,\n            accountActivationFeeEVM: accountActivationFeeEVM,\n            accountActivationFeeCore: accountActivationFeeCore,\n            bridgeSafetyBufferCore: bridgeSafetyBufferCore\n        });\n\n        emit SetCoreTokenInfo(\n            token,\n            coreIndex,\n            canBeUsedForAccountActivation,\n            accountActivationFeeCore,\n            bridgeSafetyBufferCore\n        );\n    }\n\n    /**\n     * @notice Used for ad-hoc sends of sponsorship funds to associated SwapHandler @ HyperCore\n     * @param token The final token for which we want to fund the SwapHandler\n     */\n    function sendSponsorshipFundsToSwapHandler(address token, uint256 amount) external onlyPermissionedBot {\n        CoreTokenInfo memory coreTokenInfo = _getExistingCoreTokenInfo(token);\n        FinalTokenInfo memory finalTokenInfo = _getExistingFinalTokenInfo(token);\n        (uint256 amountEVMToSend, uint64 amountCoreToReceive) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n            amount,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n        if (\n            !HyperCoreLib.isCoreAmountSafeToBridge(\n                coreTokenInfo.coreIndex,\n                amountCoreToReceive,\n                coreTokenInfo.bridgeSafetyBufferCore\n            )\n        ) {\n            revert UnsafeToBridgeError(token, amountCoreToReceive);\n        }\n\n        cumulativeSponsoredAmount[token] += amountEVMToSend;\n\n        emit SentSponsorshipFundsToSwapHandler(token, amountEVMToSend);\n\n        donationBox.withdraw(IERC20(token), amountEVMToSend);\n        IERC20(token).safeTransfer(address(finalTokenInfo.swapHandler), amountEVMToSend);\n        finalTokenInfo.swapHandler.transferFundsToSelfOnCore(\n            token,\n            coreTokenInfo.coreIndex,\n            amountEVMToSend,\n            coreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n    }\n\n    /// @notice Checks if `amount` of `token` is available to withdraw from donationBox\n    function _availableInDonationBox(\n        bytes32 quoteNonce,\n        address token,\n        uint256 amount\n    ) internal returns (bool available) {\n        uint256 balance = IERC20(token).balanceOf(address(donationBox));\n        available = balance >= amount;\n        if (!available) {\n            emit DonationBoxInsufficientFunds(quoteNonce, token, amount, balance);\n        }\n    }\n\n    function _calcAllowableAmtsSwapFlow(\n        uint256 amount,\n        uint256 extraFeesIncurred,\n        CoreTokenInfo memory initialCoreTokenInfo,\n        CoreTokenInfo memory finalCoreTokenInfo,\n        bool isSponsoredFlow,\n        uint256 maxUserSlippageBps\n    ) internal pure returns (uint64 minAllowableAmountToForwardCore, uint64 maxAllowableAmountToForwardCore) {\n        (, uint64 feelessAmountCoreInitialToken) = HyperCoreLib.maximumEVMSendAmountToAmounts(\n            amount + extraFeesIncurred,\n            initialCoreTokenInfo.tokenInfo.evmExtraWeiDecimals\n        );\n        uint64 feelessAmountCoreFinalToken = HyperCoreLib.convertCoreDecimalsSimple(\n            feelessAmountCoreInitialToken,\n            initialCoreTokenInfo.tokenInfo.weiDecimals,\n            finalCoreTokenInfo.tokenInfo.weiDecimals\n        );\n        if (isSponsoredFlow) {\n            minAllowableAmountToForwardCore = feelessAmountCoreFinalToken;\n            maxAllowableAmountToForwardCore = feelessAmountCoreFinalToken;\n        } else {\n            minAllowableAmountToForwardCore = uint64(\n                (feelessAmountCoreFinalToken * (BPS_SCALAR - maxUserSlippageBps)) / BPS_SCALAR\n            );\n            // Maximum allowable amount to forward is a one-to-one equivalent of `amount`\n            maxAllowableAmountToForwardCore = uint64(\n                (feelessAmountCoreFinalToken * amount) / (amount + extraFeesIncurred)\n            );\n        }\n    }\n\n    /**\n     * @return totalToSend What we will forward to user on HCore\n     * @return additionalToSend What we will send from donationBox right now\n     */\n    function _calcSwapFlowSendAmounts(\n        uint64 limitOrderOut,\n        uint64 minAmountToSend,\n        uint64 maxAmountToSend,\n        bool isSponsored\n    ) internal pure returns (uint64 totalToSend, uint64 additionalToSend) {\n        // What we will send from donationBox right now\n        // What we will forward to user on HCore\n        if (limitOrderOut >= maxAmountToSend || isSponsored) {\n            totalToSend = maxAmountToSend;\n        } else {\n            if (limitOrderOut < minAmountToSend) {\n                additionalToSend = minAmountToSend - limitOrderOut;\n            }\n\n            // Give user a fair deal, which is the max of:\n            // - limitOrderOut\n            // - minAmountToSend\n            totalToSend = limitOrderOut + additionalToSend;\n        }\n    }\n\n    /// @notice Reads the current spot price from HyperLiquid and applies a configured suggested discount for faster execution\n    /// @dev Includes HyperLiquid fees\n    function _getApproxRealizedPrice(\n        FinalTokenInfo memory finalTokenInfo\n    ) internal view returns (uint64 limitPriceX1e8) {\n        uint64 spotX1e8 = HyperCoreLib.spotPx(finalTokenInfo.assetIndex);\n        // Buy above spot, sell below spot\n        uint256 adjPpm = finalTokenInfo.isBuy\n            ? (PPM_SCALAR + finalTokenInfo.suggestedDiscountBps * 10 ** 2 + finalTokenInfo.feePpm)\n            : (PPM_SCALAR - finalTokenInfo.suggestedDiscountBps * 10 ** 2 - finalTokenInfo.feePpm);\n        limitPriceX1e8 = uint64((uint256(spotX1e8) * adjPpm) / PPM_SCALAR);\n    }\n\n    /**************************************\n     *            SWEEP FUNCTIONS         *\n     **************************************/\n\n    function sweepErc20(address token, uint256 amount) external nonReentrant onlyFundsSweeper {\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function sweepErc20FromDonationBox(address token, uint256 amount) external nonReentrant onlyFundsSweeper {\n        donationBox.withdraw(IERC20(token), amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function sweepERC20FromSwapHandler(address token, uint256 amount) external nonReentrant onlyFundsSweeper {\n        SwapHandler swapHandler = finalTokenInfos[token].swapHandler;\n        swapHandler.sweepErc20(token, amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function sweepOnCore(address token, uint64 amount) external nonReentrant onlyFundsSweeper {\n        HyperCoreLib.transferERC20CoreToCore(coreTokenInfos[token].coreIndex, msg.sender, amount);\n    }\n\n    function sweepOnCoreFromSwapHandler(address token, uint64 amount) external nonReentrant onlyDefaultAdmin {\n        // Prevent pulling fantom funds (e.g. if finalizePendingSwaps reads stale balance because of this fund pull)\n        require(lastPullFundsBlock[token] < block.number, \"Can't pull funds twice in the same block\");\n        lastPullFundsBlock[token] = block.number;\n\n        SwapHandler swapHandler = finalTokenInfos[token].swapHandler;\n        swapHandler.transferFundsToUserOnCore(finalTokenInfos[token].assetIndex, msg.sender, amount);\n    }\n}\n",
        "DstOFTHandler.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport { ILayerZeroComposer } from \"../../../external/interfaces/ILayerZeroComposer.sol\";\nimport { OFTComposeMsgCodec } from \"../../../external/libraries/OFTComposeMsgCodec.sol\";\nimport { ComposeMsgCodec } from \"./ComposeMsgCodec.sol\";\nimport { ExecutionMode } from \"./Structs.sol\";\nimport { AddressToBytes32, Bytes32ToAddress } from \"../../../libraries/AddressConverters.sol\";\nimport { IOFT, IOAppCore } from \"../../../interfaces/IOFT.sol\";\nimport { HyperCoreFlowExecutor } from \"../HyperCoreFlowExecutor.sol\";\nimport { ArbitraryEVMFlowExecutor } from \"../ArbitraryEVMFlowExecutor.sol\";\nimport { CommonFlowParams, EVMFlowParams } from \"../Structs.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice Handler that receives funds from LZ system, checks authorizations(both against LZ system and src chain\n/// sender), and forwards authorized params to the `_executeFlow` function\ncontract DstOFTHandler is ILayerZeroComposer, HyperCoreFlowExecutor, ArbitraryEVMFlowExecutor {\n    using ComposeMsgCodec for bytes;\n    using Bytes32ToAddress for bytes32;\n    using AddressToBytes32 for address;\n    using SafeERC20 for IERC20;\n\n    /// @notice We expect bridge amount that comes through to this Handler to be 1:1 with the src send amount, and we\n    /// require our src handler to ensure that it is. We don't sponsor extra bridge fees in this handler\n    uint256 public constant EXTRA_FEES_TO_SPONSOR = 0;\n\n    address public immutable OFT_ENDPOINT_ADDRESS;\n    address public immutable IOFT_ADDRESS;\n\n    /// @notice A mapping used to validate an incoming message against a list of authorized src periphery contracts. In\n    /// bytes32 to support non-EVM src chains\n    mapping(uint64 eid => bytes32 authorizedSrcPeriphery) public authorizedSrcPeripheryContracts;\n\n    /// @notice A mapping used for nonce uniqueness checks. Our src periphery and LZ should have prevented this already,\n    /// but I guess better safe than sorry\n    mapping(bytes32 quoteNonce => bool used) public usedNonces;\n\n    /// @notice Emitted when a new authorized src periphery is configured\n    event SetAuthorizedPeriphery(uint32 srcEid, bytes32 srcPeriphery);\n\n    /// @notice Thrown when trying to call lzCompose from a source periphery that's not been configured in `authorizedSrcPeripheryContracts`\n    error AuthorizedPeripheryNotSet(uint32 _srcEid);\n    /// @notice Thrown when source chain recipient is not authorized periphery contract\n    error UnauthorizedSrcPeriphery(uint32 _srcEid);\n    /// @notice Thrown when the supplied token does not match the supplied ioft messenger\n    error TokenIOFTMismatch();\n    /// @notice Thrown when the supplied ioft address does not match the supplied endpoint address\n    error IOFTEndpointMismatch();\n    /// @notice Thrown if Quote nonce was already used\n    error NonceAlreadyUsed();\n    /// @notice Thrown if supplied OApp is not configured ioft\n    error InvalidOApp();\n    /// @notice Thrown if called by an unauthorized endpoint\n    error UnauthorizedEndpoint();\n    /// @notice Thrown when supplied _composeMsg format is unexpected\n    error InvalidComposeMsgFormat();\n\n    constructor(\n        address _oftEndpoint,\n        address _ioft,\n        address _donationBox,\n        address _baseToken,\n        address _multicallHandler\n    ) HyperCoreFlowExecutor(_donationBox, _baseToken) ArbitraryEVMFlowExecutor(_multicallHandler) {\n        // baseToken is assigned on `HyperCoreFlowExecutor` creation\n        if (baseToken != IOFT(_ioft).token()) {\n            revert TokenIOFTMismatch();\n        }\n\n        OFT_ENDPOINT_ADDRESS = _oftEndpoint;\n        IOFT_ADDRESS = _ioft;\n        if (address(IOAppCore(IOFT_ADDRESS).endpoint()) != address(OFT_ENDPOINT_ADDRESS)) {\n            revert IOFTEndpointMismatch();\n        }\n    }\n\n    function setAuthorizedPeriphery(uint32 srcEid, bytes32 srcPeriphery) external nonReentrant onlyDefaultAdmin {\n        authorizedSrcPeripheryContracts[srcEid] = srcPeriphery;\n        emit SetAuthorizedPeriphery(srcEid, srcPeriphery);\n    }\n\n    /**\n     * @notice Handles incoming composed messages from LayerZero.\n     * @dev Ensures the message comes from the correct OApp and is sent through the authorized endpoint.\n     *\n     * @param _oApp The address of the OApp that is sending the composed message.\n     */\n    function lzCompose(\n        address _oApp,\n        bytes32 /* _guid */,\n        bytes calldata _message,\n        address /* _executor */,\n        bytes calldata /* _extraData */\n    ) external payable override nonReentrant {\n        _requireAuthorizedMessage(_oApp, _message);\n\n        // Decode the actual `composeMsg` payload to extract the recipient address\n        bytes memory composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n\n        // This check is a safety mechanism against blackholing funds. The funds were sent by the authorized periphery\n        // contract, but if the length is unexpected, we require funds be rescued, this is not a situation we aim to\n        // revover from in `lzCompose` call\n        if (composeMsg._isValidComposeMsgBytelength() == false) {\n            revert InvalidComposeMsgFormat();\n        }\n\n        bytes32 quoteNonce = composeMsg._getNonce();\n        if (usedNonces[quoteNonce]) {\n            revert NonceAlreadyUsed();\n        }\n        usedNonces[quoteNonce] = true;\n\n        uint256 amountLD = OFTComposeMsgCodec.amountLD(_message);\n        uint256 maxBpsToSponsor = composeMsg._getMaxBpsToSponsor();\n        uint256 maxUserSlippageBps = composeMsg._getMaxUserSlippageBps();\n        address finalRecipient = composeMsg._getFinalRecipient().toAddress();\n        address finalToken = composeMsg._getFinalToken().toAddress();\n        uint8 executionMode = composeMsg._getExecutionMode();\n        bytes memory actionData = composeMsg._getActionData();\n\n        CommonFlowParams memory commonParams = CommonFlowParams({\n            amountInEVM: amountLD,\n            quoteNonce: quoteNonce,\n            finalRecipient: finalRecipient,\n            finalToken: finalToken,\n            maxBpsToSponsor: maxBpsToSponsor,\n            extraFeesIncurred: EXTRA_FEES_TO_SPONSOR\n        });\n\n        // Route to appropriate execution based on executionMode\n        if (\n            executionMode == uint8(ExecutionMode.ArbitraryActionsToCore) ||\n            executionMode == uint8(ExecutionMode.ArbitraryActionsToEVM)\n        ) {\n            // Execute flow with arbitrary evm actions\n            _executeWithEVMFlow(\n                EVMFlowParams({\n                    commonParams: commonParams,\n                    initialToken: baseToken,\n                    actionData: actionData,\n                    transferToCore: executionMode == uint8(ExecutionMode.ArbitraryActionsToCore)\n                })\n            );\n        } else {\n            // Execute standard HyperCore flow (default)\n            HyperCoreFlowExecutor._executeFlow(commonParams, maxUserSlippageBps);\n        }\n    }\n\n    function _executeWithEVMFlow(EVMFlowParams memory params) internal {\n        params.commonParams = ArbitraryEVMFlowExecutor._executeFlow(params);\n\n        // Route to appropriate destination based on transferToCore flag\n        (params.transferToCore ? _executeSimpleTransferFlow : _fallbackHyperEVMFlow)(params.commonParams);\n    }\n\n    /// @notice Checks that message was authorized by LayerZero's identity system and that it came from authorized src periphery\n    function _requireAuthorizedMessage(address _oApp, bytes calldata _message) internal view {\n        if (_oApp != IOFT_ADDRESS) {\n            revert InvalidOApp();\n        }\n        if (msg.sender != OFT_ENDPOINT_ADDRESS) {\n            revert UnauthorizedEndpoint();\n        }\n        _requireAuthorizedPeriphery(_message);\n    }\n\n    /// @dev Checks that _message came from the authorized src periphery contract stored in `authorizedSrcPeripheryContracts`\n    function _requireAuthorizedPeriphery(bytes calldata _message) internal view {\n        uint32 _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        bytes32 authorizedPeriphery = authorizedSrcPeripheryContracts[_srcEid];\n        if (authorizedPeriphery == bytes32(0)) {\n            revert AuthorizedPeripheryNotSet(_srcEid);\n        }\n\n        // Decode original sender\n        bytes32 _composeFromBytes32 = OFTComposeMsgCodec.composeFrom(_message);\n\n        // We don't allow arbitrary src chain callers. If such a caller does send a message to this handler, the funds\n        // will remain in this contract and will have to be rescued by an admin rescue function\n        if (authorizedPeriphery != _composeFromBytes32) {\n            revert UnauthorizedSrcPeriphery(_srcEid);\n        }\n    }\n}\n",
        "ArbitraryEVMFlowExecutor.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Import MulticallHandler\nimport { MulticallHandler } from \"../../handlers/MulticallHandler.sol\";\nimport { EVMFlowParams, CommonFlowParams } from \"./Structs.sol\";\n\n/**\n * @title ArbitraryEVMFlowExecutor\n * @notice Base contract for executing arbitrary action sequences using MulticallHandler\n * @dev This contract provides shared functionality for both OFT and CCTP handlers to execute\n * arbitrary actions on HyperEVM via MulticallHandler, returning information about the resulting token amount\n * @custom:security-contact bugs@across.to\n */\nabstract contract ArbitraryEVMFlowExecutor {\n    using SafeERC20 for IERC20;\n\n    /// @notice Compressed call struct (no value field to save gas)\n    struct CompressedCall {\n        address target;\n        bytes callData;\n    }\n\n    /// @notice MulticallHandler contract instance\n    address public immutable multicallHandler;\n\n    /// @notice Emitted when arbitrary actions are executed successfully\n    event ArbitraryActionsExecuted(\n        bytes32 indexed quoteNonce,\n        address indexed initialToken,\n        uint256 initialAmount,\n        address indexed finalToken,\n        uint256 finalAmount\n    );\n\n    /// @notice Error thrown when final balance is insufficient\n    error InsufficientFinalBalance(address token, uint256 expected, uint256 actual);\n\n    uint256 private constant BPS_TOTAL_PRECISION = 18;\n    uint256 private constant BPS_DECIMALS = 4;\n    uint256 private constant BPS_PRECISION_SCALAR = 10 ** BPS_TOTAL_PRECISION;\n\n    constructor(address _multicallHandler) {\n        multicallHandler = _multicallHandler;\n    }\n\n    /**\n     * @notice Executes arbitrary actions by transferring tokens to MulticallHandler\n     * @dev Decompresses CompressedCall[] to MulticallHandler.Call[] format (adds value: 0)\n     * @param params Parameters of HyperEVM execution\n     * @return commonParams Parameters to continue sponsored execution to transfer funds to final recipient at correct destination\n     */\n    function _executeFlow(EVMFlowParams memory params) internal returns (CommonFlowParams memory commonParams) {\n        // Decode the compressed action data\n        CompressedCall[] memory compressedCalls = abi.decode(params.actionData, (CompressedCall[]));\n\n        // Snapshot balances\n        uint256 initialAmountSnapshot = IERC20(params.initialToken).balanceOf(address(this));\n        uint256 finalAmountSnapshot = IERC20(params.commonParams.finalToken).balanceOf(address(this));\n\n        // Transfer tokens to MulticallHandler\n        IERC20(params.initialToken).safeTransfer(multicallHandler, params.commonParams.amountInEVM);\n\n        // Build instructions for MulticallHandler\n        bytes memory instructions = _buildMulticallInstructions(\n            compressedCalls,\n            params.commonParams.finalToken,\n            address(this) // Send leftover tokens back to this contract\n        );\n\n        // Execute via MulticallHandler\n        MulticallHandler(payable(multicallHandler)).handleV3AcrossMessage(\n            params.initialToken,\n            params.commonParams.amountInEVM,\n            address(this),\n            instructions\n        );\n\n        uint256 finalAmount;\n        // This means the swap (if one was intended) didn't happen (action failed), so we use the initial token as the final token.\n        if (initialAmountSnapshot == IERC20(params.initialToken).balanceOf(address(this))) {\n            params.commonParams.finalToken = params.initialToken;\n            finalAmount = params.commonParams.amountInEVM;\n        } else {\n            uint256 finalBalance = IERC20(params.commonParams.finalToken).balanceOf(address(this));\n            if (finalBalance >= finalAmountSnapshot) {\n                // This means the swap did happen, so we check the balance of the output token and send it.\n                finalAmount = finalBalance - finalAmountSnapshot;\n            } else {\n                // If we somehow lost final tokens, just set the finalAmount to 0.\n                finalAmount = 0;\n            }\n        }\n\n        params.commonParams.extraFeesIncurred = _calcExtraFeesFinal(\n            params.commonParams.amountInEVM,\n            params.commonParams.extraFeesIncurred,\n            finalAmount\n        );\n        params.commonParams.amountInEVM = finalAmount;\n\n        emit ArbitraryActionsExecuted(\n            params.commonParams.quoteNonce,\n            params.initialToken,\n            params.commonParams.amountInEVM,\n            params.commonParams.finalToken,\n            finalAmount\n        );\n\n        return params.commonParams;\n    }\n\n    /**\n     * @notice Builds MulticallHandler Instructions from compressed calls\n     * @dev Decompresses calls by adding value: 0, and adds drainLeftoverTokens call at the end\n     */\n    function _buildMulticallInstructions(\n        CompressedCall[] memory compressedCalls,\n        address finalToken,\n        address fallbackRecipient\n    ) internal view returns (bytes memory) {\n        uint256 callCount = compressedCalls.length;\n\n        // Create Call[] array with value: 0 for each call, plus one for drainLeftoverTokens\n        MulticallHandler.Call[] memory calls = new MulticallHandler.Call[](callCount + 1);\n\n        // Decompress: add value: 0 to each call\n        for (uint256 i = 0; i < callCount; ++i) {\n            calls[i] = MulticallHandler.Call({\n                target: compressedCalls[i].target,\n                callData: compressedCalls[i].callData,\n                value: 0\n            });\n        }\n\n        // Add final call to drain leftover tokens back to this contract\n        calls[callCount] = MulticallHandler.Call({\n            target: multicallHandler,\n            callData: abi.encodeWithSelector(\n                MulticallHandler.drainLeftoverTokens.selector,\n                finalToken,\n                fallbackRecipient\n            ),\n            value: 0\n        });\n\n        // Build Instructions struct\n        MulticallHandler.Instructions memory instructions = MulticallHandler.Instructions({\n            calls: calls,\n            fallbackRecipient: fallbackRecipient\n        });\n\n        return abi.encode(instructions);\n    }\n\n    /// @notice Calcualtes proportional fees to sponsor in finalToken, given the fees to sponsor in initial token and initial amount\n    function _calcExtraFeesFinal(\n        uint256 amount,\n        uint256 extraFeesToSponsorTokenIn,\n        uint256 finalAmount\n    ) internal pure returns (uint256 extraFeesToSponsorFinalToken) {\n        // Total amount to sponsor is the extra fees to sponsor, ceiling division.\n        uint256 bpsToSponsor;\n        {\n            uint256 totalAmount = amount + extraFeesToSponsorTokenIn;\n            bpsToSponsor = ((extraFeesToSponsorTokenIn * BPS_PRECISION_SCALAR) + totalAmount - 1) / totalAmount;\n        }\n\n        // Apply the bps to sponsor to the final amount to get the amount to sponsor, ceiling division.\n        uint256 bpsToSponsorAdjusted = BPS_PRECISION_SCALAR - bpsToSponsor;\n        extraFeesToSponsorFinalToken =\n            (((finalAmount * BPS_PRECISION_SCALAR) + bpsToSponsorAdjusted - 1) / bpsToSponsorAdjusted) -\n            finalAmount;\n    }\n\n    /// @notice Allow contract to receive native tokens for arbitrary action execution\n    receive() external payable virtual {}\n}\n",
        "MulticallHandler.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/SpokePoolMessageHandler.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title Across Multicall contract that allows a user to specify a series of calls that should be made by the handler\n * via the message field in the deposit.\n * @dev This contract makes the calls blindly. The contract will send any remaining tokens The caller should ensure that the tokens recieved by the handler are completely consumed.\n */\ncontract MulticallHandler is AcrossMessageHandler, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    struct Call {\n        address target;\n        bytes callData;\n        uint256 value;\n    }\n\n    struct Replacement {\n        address token;\n        uint256 offset;\n    }\n\n    struct Instructions {\n        //  Calls that will be attempted.\n        Call[] calls;\n        // Where the tokens go if any part of the call fails.\n        // Leftover tokens are sent here as well if the action succeeds.\n        address fallbackRecipient;\n    }\n\n    // Emitted when one of the calls fails. Note: all calls are reverted in this case.\n    event CallsFailed(Call[] calls, address indexed fallbackRecipient);\n\n    // Emitted when there are leftover tokens that are sent to the fallbackRecipient.\n    event DrainedTokens(address indexed recipient, address indexed token, uint256 indexed amount);\n\n    // Errors\n    error CallReverted(uint256 index, Call[] calls);\n    error NotSelf();\n    error InvalidCall(uint256 index, Call[] calls);\n    error ReplacementCallFailed(bytes callData);\n    error CalldataTooShort(uint256 callDataLength, uint256 offset);\n\n    modifier onlySelf() {\n        _requireSelf();\n        _;\n    }\n\n    /**\n     * @notice Main entrypoint for the handler called by the SpokePool contract.\n     * @dev This will execute all calls encoded in the msg. The caller is responsible for making sure all tokens are\n     * drained from this contract by the end of the series of calls. If not, they can be stolen.\n     * A drainLeftoverTokens call can be included as a way to drain any remaining tokens from this contract.\n     * @param message abi encoded array of Call structs, containing a target, callData, and value for each call that\n     * the contract should make.\n     */\n    function handleV3AcrossMessage(address token, uint256, address, bytes memory message) public virtual nonReentrant {\n        Instructions memory instructions = abi.decode(message, (Instructions));\n\n        // If there is no fallback recipient, call and revert if the inner call fails.\n        if (instructions.fallbackRecipient == address(0)) {\n            this.attemptCalls(instructions.calls);\n            return;\n        }\n\n        // Otherwise, try the call and send to the fallback recipient if any tokens are leftover.\n        (bool success, ) = address(this).call(abi.encodeCall(this.attemptCalls, (instructions.calls)));\n        if (!success) emit CallsFailed(instructions.calls, instructions.fallbackRecipient);\n\n        // If there are leftover tokens, send them to the fallback recipient regardless of execution success.\n        _drainRemainingTokens(token, payable(instructions.fallbackRecipient));\n    }\n\n    function attemptCalls(Call[] memory calls) external onlySelf {\n        uint256 length = calls.length;\n        for (uint256 i = 0; i < length; ++i) {\n            Call memory call = calls[i];\n\n            // If we are calling an EOA with calldata, assume target was incorrectly specified and revert.\n            if (call.callData.length > 0 && call.target.code.length == 0) {\n                revert InvalidCall(i, calls);\n            }\n\n            (bool success, ) = call.target.call{ value: call.value }(call.callData);\n            if (!success) revert CallReverted(i, calls);\n        }\n    }\n\n    function drainLeftoverTokens(address token, address payable destination) external onlySelf {\n        _drainRemainingTokens(token, destination);\n    }\n\n    function _drainRemainingTokens(address token, address payable destination) internal {\n        if (token != address(0)) {\n            // ERC20 token.\n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                IERC20(token).safeTransfer(destination, amount);\n                emit DrainedTokens(destination, token, amount);\n            }\n        } else {\n            // Send native token\n            uint256 amount = address(this).balance;\n            if (amount > 0) {\n                destination.sendValue(amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Executes a call while replacing specified calldata offsets with current token/native balances.\n     * @dev Modifies calldata in-place using OR operations. Target calldata positions must be zeroed out.\n     * Cannot handle negative balances, making it incompatible with DEXs requiring negative input amounts.\n     * For native balance (token = address(0)), the entire balance is used as call value.\n     * @param target The contract address to call\n     * @param callData The calldata to execute, with zero values at replacement positions\n     * @param value The native token value to send (ignored if native balance replacement is used)\n     * @param replacement Array of Replacement structs specifying token addresses and byte offsets for balance injection\n     */\n    function makeCallWithBalance(\n        address target,\n        bytes memory callData,\n        uint256 value,\n        Replacement[] calldata replacement\n    ) external onlySelf {\n        for (uint256 i = 0; i < replacement.length; i++) {\n            uint256 bal = 0;\n            if (replacement[i].token != address(0)) {\n                bal = IERC20(replacement[i].token).balanceOf(address(this));\n            } else {\n                bal = address(this).balance;\n\n                // If we're using the native balance, we assume that the caller wants to send the full value to the target.\n                value = bal;\n            }\n\n            // + 32 to skip the length of the calldata\n            uint256 offset = replacement[i].offset + 32;\n\n            // 32 has already been added to the offset, and the replacement value is 32 bytes long, so\n            // we don't need to add 32 here. We just directly compare the offset with the length of the calldata.\n            if (offset > callData.length) revert CalldataTooShort(callData.length, offset);\n\n            assembly (\"memory-safe\") {\n                // Get the pointer to the offset that the caller wants to overwrite.\n                let ptr := add(callData, offset)\n                // Get the current value at the offset.\n                let current := mload(ptr)\n                // Or the current value with the new value.\n                // Reasoning:\n                // - caller should 0-out any portion that they want overwritten.\n                // - if the caller is representing the balance in a smaller integer, like a uint160 or uint128,\n                //   the higher bits will be 0 and not overwrite any other data in the calldata assuming\n                //   the balance is small enough to fit in the smaller integer.\n                // - The catch: the smaller integer where they want to store the balance must end no\n                //   earlier than the 32nd byte in their calldata. Otherwise, this would require a\n                //   negative offset, which is not possible.\n                let val := or(bal, current)\n                // Store the new value at the offset.\n                mstore(ptr, val)\n            }\n        }\n\n        (bool success, ) = target.call{ value: value }(callData);\n        if (!success) revert ReplacementCallFailed(callData);\n    }\n\n    function _requireSelf() internal view {\n        // Must be called by this contract to ensure that this cannot be triggered without the explicit consent of the\n        // depositor (for a valid relay).\n        if (msg.sender != address(this)) revert NotSelf();\n    }\n\n    // Used if the caller is trying to unwrap the native token to this contract.\n    receive() external payable {}\n}\n",
        "SponsoredCCTPDstPeriphery.sol": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IMessageTransmitterV2 } from \"../../../external/interfaces/CCTPInterfaces.sol\";\nimport { SponsoredCCTPQuoteLib } from \"../../../libraries/SponsoredCCTPQuoteLib.sol\";\nimport { SponsoredCCTPInterface } from \"../../../interfaces/SponsoredCCTPInterface.sol\";\nimport { Bytes32ToAddress } from \"../../../libraries/AddressConverters.sol\";\nimport { HyperCoreFlowExecutor } from \"../HyperCoreFlowExecutor.sol\";\nimport { ArbitraryEVMFlowExecutor } from \"../ArbitraryEVMFlowExecutor.sol\";\nimport { CommonFlowParams, EVMFlowParams } from \"../Structs.sol\";\n\n/**\n * @title SponsoredCCTPDstPeriphery\n * @notice Destination chain periphery contract that supports sponsored/non-sponsored CCTP deposits.\n * @dev This contract is used to receive tokens via CCTP and execute the flow accordingly.\n */\ncontract SponsoredCCTPDstPeriphery is SponsoredCCTPInterface, HyperCoreFlowExecutor, ArbitraryEVMFlowExecutor {\n    using SafeERC20 for IERC20Metadata;\n    using Bytes32ToAddress for bytes32;\n\n    /// @notice The CCTP message transmitter contract.\n    IMessageTransmitterV2 public immutable cctpMessageTransmitter;\n\n    /// @notice The public key of the signer that was used to sign the quotes.\n    address public signer;\n\n    /// @notice Allow a buffer for quote deadline validation. CCTP transfer might have taken a while to finalize\n    uint256 public quoteDeadlineBuffer = 30 minutes;\n\n    /// @notice A mapping of used nonces to prevent replay attacks.\n    mapping(bytes32 => bool) public usedNonces;\n\n    /**\n     * @notice Constructor for the SponsoredCCTPDstPeriphery contract.\n     * @param _cctpMessageTransmitter The address of the CCTP message transmitter contract.\n     * @param _signer The address of the signer that was used to sign the quotes.\n     * @param _donationBox The address of the donation box contract. This is used to store funds that are used for sponsored flows.\n     * @param _baseToken The address of the base token which would be the USDC on HyperEVM.\n     * @param _multicallHandler The address of the multicall handler contract.\n     */\n    constructor(\n        address _cctpMessageTransmitter,\n        address _signer,\n        address _donationBox,\n        address _baseToken,\n        address _multicallHandler\n    ) HyperCoreFlowExecutor(_donationBox, _baseToken) ArbitraryEVMFlowExecutor(_multicallHandler) {\n        cctpMessageTransmitter = IMessageTransmitterV2(_cctpMessageTransmitter);\n        signer = _signer;\n    }\n\n    /**\n     * @notice Sets the signer address that is used to validate the signatures of the quotes.\n     * @param _signer The new signer address.\n     */\n    function setSigner(address _signer) external nonReentrant onlyDefaultAdmin {\n        signer = _signer;\n    }\n\n    /**\n     * @notice Sets the quote deadline buffer. This is used to prevent the quote from being used after it has expired.\n     * @param _quoteDeadlineBuffer The new quote deadline buffer.\n     */\n    function setQuoteDeadlineBuffer(uint256 _quoteDeadlineBuffer) external nonReentrant onlyDefaultAdmin {\n        quoteDeadlineBuffer = _quoteDeadlineBuffer;\n    }\n\n    /**\n     * @notice Receives a message from CCTP and executes the flow accordingly. This function first calls the\n     * CCTP message transmitter to receive the funds before validating the quote and executing the flow.\n     * @param message The message that is received from CCTP.\n     * @param attestation The attestation that is received from CCTP.\n     * @param signature The signature of the quote.\n     */\n    function receiveMessage(\n        bytes memory message,\n        bytes memory attestation,\n        bytes memory signature\n    ) external nonReentrant {\n        cctpMessageTransmitter.receiveMessage(message, attestation);\n\n        // If the hook data is invalid or the mint recipient is not this contract we cannot process the message\n        // and therefore we exit. In this case the funds will be kept in this contract.\n        if (!SponsoredCCTPQuoteLib.validateMessage(message)) {\n            return;\n        }\n\n        // Extract the quote and the fee that was executed from the message.\n        (SponsoredCCTPInterface.SponsoredCCTPQuote memory quote, uint256 feeExecuted) = SponsoredCCTPQuoteLib\n            .getSponsoredCCTPQuoteData(message);\n\n        // Validate the quote and the signature.\n        bool isQuoteValid = _isQuoteValid(quote, signature);\n        if (isQuoteValid) {\n            usedNonces[quote.nonce] = true;\n        }\n\n        uint256 amountAfterFees = quote.amount - feeExecuted;\n\n        CommonFlowParams memory commonParams = CommonFlowParams({\n            amountInEVM: amountAfterFees,\n            quoteNonce: quote.nonce,\n            finalRecipient: quote.finalRecipient.toAddress(),\n            // If the quote is invalid we don't want to swap, so we use the base token as the final token\n            finalToken: isQuoteValid ? quote.finalToken.toAddress() : baseToken,\n            // If the quote is invalid we don't sponsor the flow or the extra fees\n            maxBpsToSponsor: isQuoteValid ? quote.maxBpsToSponsor : 0,\n            extraFeesIncurred: feeExecuted\n        });\n\n        // Route to appropriate execution based on executionMode\n        if (\n            isQuoteValid &&\n            (quote.executionMode == uint8(ExecutionMode.ArbitraryActionsToCore) ||\n                quote.executionMode == uint8(ExecutionMode.ArbitraryActionsToEVM))\n        ) {\n            // Execute flow with arbitrary evm actions\n            _executeWithEVMFlow(\n                EVMFlowParams({\n                    commonParams: commonParams,\n                    initialToken: baseToken,\n                    actionData: quote.actionData,\n                    transferToCore: quote.executionMode == uint8(ExecutionMode.ArbitraryActionsToCore)\n                })\n            );\n        } else {\n            // Execute standard HyperCore flow (default)\n            HyperCoreFlowExecutor._executeFlow(commonParams, quote.maxUserSlippageBps);\n        }\n    }\n\n    function _isQuoteValid(\n        SponsoredCCTPInterface.SponsoredCCTPQuote memory quote,\n        bytes memory signature\n    ) internal view returns (bool) {\n        return\n            SponsoredCCTPQuoteLib.validateSignature(signer, quote, signature) &&\n            !usedNonces[quote.nonce] &&\n            quote.deadline + quoteDeadlineBuffer >= block.timestamp;\n    }\n\n    function _executeWithEVMFlow(EVMFlowParams memory params) internal {\n        params.commonParams = ArbitraryEVMFlowExecutor._executeFlow(params);\n\n        // Route to appropriate destination based on transferToCore flag\n        (params.transferToCore ? _executeSimpleTransferFlow : _fallbackHyperEVMFlow)(params.commonParams);\n    }\n}\n"
    }
}