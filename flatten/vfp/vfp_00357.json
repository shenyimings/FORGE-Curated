{
    "vfp_id": "vfp_00357",
    "project_name": "Sponsored Periphery Audit.md",
    "findings": [
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Imports",
            "description": "The `Structs.sol` file imports `SendParam` and `MessagingFee` from `IOFT.sol` but does not use them.\nThe root cause is an unnecessary import that was not cleaned up.\nUnused imports increase compilation cost and reduce code clarity.\nThe impact is minor but contributes to technical debt and reduces code quality.\n",
            "severity": "Informational",
            "location": [
                "Structs.sol::import#4"
            ],
            "files": [
                "contracts/contracts/periphery/mintburn/Structs.sol"
            ]
        }
    ],
    "affected_files": {
        "Structs.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { HyperCoreLib } from \"../../libraries/HyperCoreLib.sol\";\nimport { SwapHandler } from \"./SwapHandler.sol\";\n\n// Info about the token on HyperCore.\nstruct CoreTokenInfo {\n    // The token info on HyperCore.\n    HyperCoreLib.TokenInfo tokenInfo;\n    // The HyperCore index id of the token.\n    uint64 coreIndex;\n    // Whether the token can be used for account activation fee.\n    bool canBeUsedForAccountActivation;\n    // The account activation fee for the token.\n    uint256 accountActivationFeeEVM;\n    // The account activation fee for the token on Core.\n    uint64 accountActivationFeeCore;\n    // Bridge buffer to use when checking safety of bridging evm -> core. In core units\n    uint64 bridgeSafetyBufferCore;\n}\n\nstruct FinalTokenInfo {\n    // The index of the market where we're going to swap baseToken -> finalToken\n    uint32 assetIndex;\n    // To go baseToken -> finalToken, do we have to enqueue a buy or a sell?\n    bool isBuy;\n    // The fee Hyperliquid charges for Limit orders in the market; in parts per million, e.g. 1.4 bps = 140 ppm\n    uint32 feePpm;\n    // When enqueuing a limit order, use this to set a price \"a bit worse than market\" for faster execution\n    uint32 suggestedDiscountBps;\n    // Contract where the accounting for all baseToken -> finalToken accounting happens. One pre finalToken\n    SwapHandler swapHandler;\n}\n\n/// @notice Common parameters shared across flow execution functions\nstruct CommonFlowParams {\n    uint256 amountInEVM;\n    bytes32 quoteNonce;\n    address finalRecipient;\n    address finalToken;\n    uint256 maxBpsToSponsor;\n    uint256 extraFeesIncurred;\n}\n\n/// @notice Parameters for executing flows with arbitrary EVM actions\nstruct EVMFlowParams {\n    CommonFlowParams commonParams;\n    address initialToken;\n    bytes actionData;\n    bool transferToCore;\n}\n"
    }
}