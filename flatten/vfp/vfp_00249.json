{
    "vfp_id": "vfp_00249",
    "project_name": "Vicuna Finance - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Missing state and interest rate updates in setReserveInterestRateStrategyAddress",
            "description": "The `setReserveInterestRateStrategyAddress` function in Pool.sol fails to update the reserve's state and interest rates after changing the interest rate strategy address. This omission can lead to inconsistent reserve state and incorrect interest rate calculations, as the new strategy is not immediately applied. The root cause is the absence of calls to `reserve.updateState` and `reserve.updateInterestRates` within the function. An attacker could potentially exploit timing windows where outdated rates are used, leading to incorrect yield calculations or unfair advantages in borrowing/lending. The impact is low, as it affects accuracy rather than leading to direct fund loss.\n",
            "severity": "Low",
            "location": [
                "Pool.sol#L628"
            ],
            "files": [
                "Vicuna-core-bl/contracts/protocol/pool/Pool.sol"
            ]
        }
    ],
    "affected_files": {
        "Pool.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {PoolLogic} from '../libraries/logic/PoolLogic.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {EModeLogic} from '../libraries/logic/EModeLogic.sol';\nimport {SupplyLogic} from '../libraries/logic/SupplyLogic.sol';\nimport {FlashLoanLogic} from '../libraries/logic/FlashLoanLogic.sol';\nimport {BorrowLogic} from '../libraries/logic/BorrowLogic.sol';\nimport {LiquidationLogic} from '../libraries/logic/LiquidationLogic.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\nimport {BridgeLogic} from '../libraries/logic/BridgeLogic.sol';\nimport {IERC20WithPermit} from '../../interfaces/IERC20WithPermit.sol';\nimport {IPoolAddressesProvider} from '../../interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '../../interfaces/IPool.sol';\nimport {IACLManager} from '../../interfaces/IACLManager.sol';\nimport {PoolStorage} from './PoolStorage.sol';\n\n/**\n * @title Pool contract\n * @author Aave\n * @notice Main point of interaction with an Aave protocol's market\n * - Users can:\n *   # Supply\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Swap their loans between variable and stable rate\n *   # Enable/disable their supplied assets as collateral rebalance stable rate borrow positions\n *   # Liquidate positions\n *   # Execute Flash Loans\n * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market\n * @dev All admin functions are callable by the PoolConfigurator contract defined also in the\n *   PoolAddressesProvider\n */\ncontract Pool is VersionedInitializable, PoolStorage, IPool {\n  using ReserveLogic for DataTypes.ReserveData;\n\n  uint256 public constant POOL_REVISION = 0x1;\n  IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n  /**\n   * @dev Only pool configurator can call functions marked by this modifier.\n   */\n  modifier onlyPoolConfigurator() {\n    _onlyPoolConfigurator();\n    _;\n  }\n\n  /**\n   * @dev Only pool admin can call functions marked by this modifier.\n   */\n  modifier onlyPoolAdmin() {\n    _onlyPoolAdmin();\n    _;\n  }\n\n  /**\n   * @dev Only bridge can call functions marked by this modifier.\n   */\n  modifier onlyBridge() {\n    _onlyBridge();\n    _;\n  }\n\n  function _onlyPoolConfigurator() internal view virtual {\n    require(\n      ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender,\n      Errors.CALLER_NOT_POOL_CONFIGURATOR\n    );\n  }\n\n  function _onlyPoolAdmin() internal view virtual {\n    require(\n      IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(msg.sender),\n      Errors.CALLER_NOT_POOL_ADMIN\n    );\n  }\n\n  function _onlyBridge() internal view virtual {\n    require(\n      IACLManager(ADDRESSES_PROVIDER.getACLManager()).isBridge(msg.sender),\n      Errors.CALLER_NOT_BRIDGE\n    );\n  }\n\n  function getRevision() internal pure virtual override returns (uint256) {\n    return POOL_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param provider The address of the PoolAddressesProvider contract\n   */\n  constructor(IPoolAddressesProvider provider) {\n    ADDRESSES_PROVIDER = provider;\n  }\n\n  /**\n   * @notice Initializes the Pool.\n   * @dev Function is invoked by the proxy contract when the Pool contract is added to the\n   * PoolAddressesProvider of the market.\n   * @dev Caching the address of the PoolAddressesProvider in order to reduce gas consumption on subsequent operations\n   * @param provider The address of the PoolAddressesProvider\n   */\n  function initialize(IPoolAddressesProvider provider) external virtual initializer {\n    require(provider == ADDRESSES_PROVIDER, Errors.INVALID_ADDRESSES_PROVIDER);\n    _maxStableRateBorrowSizePercent = 0.25e4;\n  }\n\n  /// @inheritdoc IPool\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external virtual override onlyBridge {\n    BridgeLogic.executeMintUnbacked(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      asset,\n      amount,\n      onBehalfOf,\n      referralCode\n    );\n  }\n\n  /// @inheritdoc IPool\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external virtual override onlyBridge returns (uint256) {\n    return\n      BridgeLogic.executeBackUnbacked(_reserves[asset], asset, amount, fee, _bridgeProtocolFee);\n  }\n\n  /// @inheritdoc IPool\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) public virtual override {\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) public virtual override {\n    IERC20WithPermit(asset).permit(\n      msg.sender,\n      address(this),\n      amount,\n      deadline,\n      permitV,\n      permitR,\n      permitS\n    );\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) public virtual override returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        _reservesList,\n        _eModeCategories,\n        _usersConfig[msg.sender],\n        DataTypes.ExecuteWithdrawParams({\n          asset: asset,\n          amount: amount,\n          to: to,\n          reservesCount: _reservesCount,\n          oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n          userEModeCategory: _usersEModeCategory[msg.sender]\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) public virtual override {\n    BorrowLogic.executeBorrow(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteBorrowParams({\n        asset: asset,\n        user: msg.sender,\n        onBehalfOf: onBehalfOf,\n        amount: amount,\n        interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n        referralCode: referralCode,\n        releaseUnderlying: true,\n        maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,\n        reservesCount: _reservesCount,\n        oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        userEModeCategory: _usersEModeCategory[onBehalfOf],\n        priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) public virtual override returns (uint256) {\n    return\n      BorrowLogic.executeRepay(\n        _reserves,\n        _reservesList,\n        _usersConfig[onBehalfOf],\n        DataTypes.ExecuteRepayParams({\n          asset: asset,\n          amount: amount,\n          interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n          onBehalfOf: onBehalfOf,\n          useATokens: false\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) public virtual override returns (uint256) {\n    {\n      IERC20WithPermit(asset).permit(\n        msg.sender,\n        address(this),\n        amount,\n        deadline,\n        permitV,\n        permitR,\n        permitS\n      );\n    }\n    {\n      DataTypes.ExecuteRepayParams memory params = DataTypes.ExecuteRepayParams({\n        asset: asset,\n        amount: amount,\n        interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n        onBehalfOf: onBehalfOf,\n        useATokens: false\n      });\n      return BorrowLogic.executeRepay(_reserves, _reservesList, _usersConfig[onBehalfOf], params);\n    }\n  }\n\n  /// @inheritdoc IPool\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) public virtual override returns (uint256) {\n    return\n      BorrowLogic.executeRepay(\n        _reserves,\n        _reservesList,\n        _usersConfig[msg.sender],\n        DataTypes.ExecuteRepayParams({\n          asset: asset,\n          amount: amount,\n          interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n          onBehalfOf: msg.sender,\n          useATokens: true\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) public virtual override {\n    BorrowLogic.executeSwapBorrowRateMode(\n      _reserves[asset],\n      _usersConfig[msg.sender],\n      asset,\n      DataTypes.InterestRateMode(interestRateMode)\n    );\n  }\n\n  /// @inheritdoc IPool\n  function rebalanceStableBorrowRate(address asset, address user) public virtual override {\n    BorrowLogic.executeRebalanceStableBorrowRate(_reserves[asset], asset, user);\n  }\n\n  /// @inheritdoc IPool\n  function setUserUseReserveAsCollateral(\n    address asset,\n    bool useAsCollateral\n  ) public virtual override {\n    SupplyLogic.executeUseReserveAsCollateral(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig[msg.sender],\n      asset,\n      useAsCollateral,\n      _reservesCount,\n      ADDRESSES_PROVIDER.getPriceOracle(),\n      _usersEModeCategory[msg.sender]\n    );\n  }\n\n  /// @inheritdoc IPool\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) public virtual override {\n    LiquidationLogic.executeLiquidationCall(\n      _reserves,\n      _reservesList,\n      _usersConfig,\n      _eModeCategories,\n      DataTypes.ExecuteLiquidationCallParams({\n        reservesCount: _reservesCount,\n        debtToCover: debtToCover,\n        collateralAsset: collateralAsset,\n        debtAsset: debtAsset,\n        user: user,\n        receiveAToken: receiveAToken,\n        priceOracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        userEModeCategory: _usersEModeCategory[user],\n        priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) public virtual override {\n    DataTypes.FlashloanParams memory flashParams = DataTypes.FlashloanParams({\n      receiverAddress: receiverAddress,\n      assets: assets,\n      amounts: amounts,\n      interestRateModes: interestRateModes,\n      onBehalfOf: onBehalfOf,\n      params: params,\n      referralCode: referralCode,\n      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,\n      flashLoanPremiumTotal: _flashLoanPremiumTotal,\n      maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,\n      reservesCount: _reservesCount,\n      addressesProvider: address(ADDRESSES_PROVIDER),\n      userEModeCategory: _usersEModeCategory[onBehalfOf],\n      isAuthorizedFlashBorrower: IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(\n        msg.sender\n      )\n    });\n\n    FlashLoanLogic.executeFlashLoan(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig[onBehalfOf],\n      flashParams\n    );\n  }\n\n  /// @inheritdoc IPool\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) public virtual override {\n    DataTypes.FlashloanSimpleParams memory flashParams = DataTypes.FlashloanSimpleParams({\n      receiverAddress: receiverAddress,\n      asset: asset,\n      amount: amount,\n      params: params,\n      referralCode: referralCode,\n      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,\n      flashLoanPremiumTotal: _flashLoanPremiumTotal\n    });\n    FlashLoanLogic.executeFlashLoanSimple(_reserves[asset], flashParams);\n  }\n\n  /// @inheritdoc IPool\n  function mintToTreasury(address[] calldata assets) external virtual override {\n    PoolLogic.executeMintToTreasury(_reserves, assets);\n  }\n\n  /// @inheritdoc IPool\n  function getReserveData(\n    address asset\n  ) external view virtual override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /// @inheritdoc IPool\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    virtual\n    override\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    return\n      PoolLogic.executeGetUserAccountData(\n        _reserves,\n        _reservesList,\n        _eModeCategories,\n        DataTypes.CalculateUserAccountDataParams({\n          userConfig: _usersConfig[user],\n          reservesCount: _reservesCount,\n          user: user,\n          oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n          userEModeCategory: _usersEModeCategory[user]\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function getConfiguration(\n    address asset\n  ) external view virtual override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /// @inheritdoc IPool\n  function getUserConfiguration(\n    address user\n  ) external view virtual override returns (DataTypes.UserConfigurationMap memory) {\n    return _usersConfig[user];\n  }\n\n  /// @inheritdoc IPool\n  function getReserveNormalizedIncome(\n    address asset\n  ) external view virtual override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /// @inheritdoc IPool\n  function getReserveNormalizedVariableDebt(\n    address asset\n  ) external view virtual override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /// @inheritdoc IPool\n  function getReservesList() external view virtual override returns (address[] memory) {\n    uint256 reservesListCount = _reservesCount;\n    uint256 droppedReservesCount = 0;\n    address[] memory reservesList = new address[](reservesListCount);\n\n    for (uint256 i = 0; i < reservesListCount; i++) {\n      if (_reservesList[i] != address(0)) {\n        reservesList[i - droppedReservesCount] = _reservesList[i];\n      } else {\n        droppedReservesCount++;\n      }\n    }\n\n    // Reduces the length of the reserves array by `droppedReservesCount`\n    assembly {\n      mstore(reservesList, sub(reservesListCount, droppedReservesCount))\n    }\n    return reservesList;\n  }\n\n  /// @inheritdoc IPool\n  function getReserveAddressById(uint16 id) external view returns (address) {\n    return _reservesList[id];\n  }\n\n  /// @inheritdoc IPool\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view virtual override returns (uint256) {\n    return _maxStableRateBorrowSizePercent;\n  }\n\n  /// @inheritdoc IPool\n  function BRIDGE_PROTOCOL_FEE() public view virtual override returns (uint256) {\n    return _bridgeProtocolFee;\n  }\n\n  /// @inheritdoc IPool\n  function FLASHLOAN_PREMIUM_TOTAL() public view virtual override returns (uint128) {\n    return _flashLoanPremiumTotal;\n  }\n\n  /// @inheritdoc IPool\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() public view virtual override returns (uint128) {\n    return _flashLoanPremiumToProtocol;\n  }\n\n  /// @inheritdoc IPool\n  function MAX_NUMBER_RESERVES() public view virtual override returns (uint16) {\n    return ReserveConfiguration.MAX_RESERVES_COUNT;\n  }\n\n  /// @inheritdoc IPool\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external virtual override {\n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.CALLER_NOT_ATOKEN);\n    SupplyLogic.executeFinalizeTransfer(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig,\n      DataTypes.FinalizeTransferParams({\n        asset: asset,\n        from: from,\n        to: to,\n        amount: amount,\n        balanceFromBefore: balanceFromBefore,\n        balanceToBefore: balanceToBefore,\n        reservesCount: _reservesCount,\n        oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        fromEModeCategory: _usersEModeCategory[from]\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external virtual override onlyPoolConfigurator {\n    if (\n      PoolLogic.executeInitReserve(\n        _reserves,\n        _reservesList,\n        DataTypes.InitReserveParams({\n          asset: asset,\n          aTokenAddress: aTokenAddress,\n          stableDebtAddress: stableDebtAddress,\n          variableDebtAddress: variableDebtAddress,\n          interestRateStrategyAddress: interestRateStrategyAddress,\n          reservesCount: _reservesCount,\n          maxNumberReserves: MAX_NUMBER_RESERVES()\n        })\n      )\n    ) {\n      _reservesCount++;\n    }\n  }\n\n  /// @inheritdoc IPool\n  function dropReserve(address asset) external virtual override onlyPoolConfigurator {\n    PoolLogic.executeDropReserve(_reserves, _reservesList, asset);\n  }\n\n  /// @inheritdoc IPool\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external virtual override onlyPoolConfigurator {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    require(_reserves[asset].id != 0 || _reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n  }\n\n  /// @inheritdoc IPool\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external virtual override onlyPoolConfigurator {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    require(_reserves[asset].id != 0 || _reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n    _reserves[asset].configuration = configuration;\n  }\n\n  /// @inheritdoc IPool\n  function updateBridgeProtocolFee(\n    uint256 protocolFee\n  ) external virtual override onlyPoolConfigurator {\n    _bridgeProtocolFee = protocolFee;\n  }\n\n  /// @inheritdoc IPool\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external virtual override onlyPoolConfigurator {\n    _flashLoanPremiumTotal = flashLoanPremiumTotal;\n    _flashLoanPremiumToProtocol = flashLoanPremiumToProtocol;\n  }\n\n  /// @inheritdoc IPool\n  function configureEModeCategory(\n    uint8 id,\n    DataTypes.EModeCategory memory category\n  ) external virtual override onlyPoolConfigurator {\n    // category 0 is reserved for volatile heterogeneous assets and it's always disabled\n    require(id != 0, Errors.EMODE_CATEGORY_RESERVED);\n    _eModeCategories[id] = category;\n  }\n\n  /// @inheritdoc IPool\n  function getEModeCategoryData(\n    uint8 id\n  ) external view virtual override returns (DataTypes.EModeCategory memory) {\n    return _eModeCategories[id];\n  }\n\n  /// @inheritdoc IPool\n  function setUserEMode(uint8 categoryId) external virtual override {\n    EModeLogic.executeSetUserEMode(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersEModeCategory,\n      _usersConfig[msg.sender],\n      DataTypes.ExecuteSetUserEModeParams({\n        reservesCount: _reservesCount,\n        oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        categoryId: categoryId\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function getUserEMode(address user) external view virtual override returns (uint256) {\n    return _usersEModeCategory[user];\n  }\n\n  /// @inheritdoc IPool\n  function resetIsolationModeTotalDebt(\n    address asset\n  ) external virtual override onlyPoolConfigurator {\n    PoolLogic.executeResetIsolationModeTotalDebt(_reserves, asset);\n  }\n\n  /// @inheritdoc IPool\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external virtual override onlyPoolAdmin {\n    PoolLogic.executeRescueTokens(token, to, amount);\n  }\n\n  /// @inheritdoc IPool\n  /// @dev Deprecated: maintained for compatibility purposes\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external virtual override {\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n}\n"
    }
}