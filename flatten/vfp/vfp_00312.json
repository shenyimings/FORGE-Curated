{
    "vfp_id": "vfp_00312",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Linked list data structure in LinkedListStorage can be corrupted",
            "description": "The vulnerability exists in the LinkedListStorage._dequeueItem() function, where certain storage variables are not properly cleared when removing the first item from the queue. Specifically, namespace.next and namespace.item are not reset, even though they should be to prevent stale data from being misinterpreted.\n\nThe root cause is incomplete cleanup of storage slots during dequeue operations. While namespace.prev is correctly left as zero for the first item, namespace.next is not cleared, and namespace.item remains set. This is problematic because _enqueueItem() does not always set .next for new items, especially when the queue is empty.\n\nAn attacker can manipulate the dangling next pointer to corrupt the internal state of the linked list. For example, by crafting a scenario where a dequeued item's next pointer still points to a previous location, subsequent calls to peekItem() may return incorrect values. Additionally, since namespace.item is not cleared, functions like getItem() and scan() can return items that have already been removed.\n\nThe impact is corruption of critical data structures, leading to incorrect behavior in any contract relying on this linked list for state management, potentially resulting in loss of funds or denial of service.\n",
            "severity": "Critical",
            "location": [
                "LinkedListStorage.sol::_dequeueItem#134-164",
                "LinkedListStorage.sol::_removeItem#95-102"
            ],
            "files": [
                "rocketpool/contracts/contract/util/LinkedListStorage.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect/repeated withdrawal from rocketSmoothingPool in executeRewardSnapshot() will lead to loss of ETH rewards",
            "description": "The vulnerability involves a redundant and incorrect withdrawal call in the _executeRewardSnapshot() function of RocketRewardsPool.sol, where ETH is withdrawn twice from the rocketSmoothingPool for the same reward distribution.\n\nThe root cause is a logic error where, after already withdrawing smoothingPoolETH into the contract, the function attempts to withdraw the same amount again directly to the relay. This second withdrawal is unnecessary and dangerous because it assumes the smoothing pool still has sufficient balance.\n\nAn attacker cannot directly exploit this, but the protocol itself will fail during reward distribution if the smoothing pool lacks sufficient balance, causing the entire transaction to revert. More likely, if the first withdrawal succeeds but the second is skipped due to logic flaws, ETH may become stuck in RocketRewardsPool.\n\nThe impact is a loss of ETH rewards for node operators who participate in the smoothing pool, as funds either get stuck or cause transaction reverts, disrupting the reward distribution process in every cycle.\n",
            "severity": "High",
            "location": [
                "RocketRewardsPool.sol::_executeRewardSnapshot#254-256",
                "RocketRewardsPool.sol::_executeRewardSnapshot#302-305"
            ],
            "files": [
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing sanity check for _stakingEth <= _totalEth could cause unexpected behavior",
            "description": "A sanity check for _stakingEth <= _totalEth is implemented in executeUpdateBalances() but missing in submitBalances(). This inconsistency allows potentially invalid values of _stakingEth and _totalEth to be submitted directly via submitBalances(), which can trigger updateBalances() with incorrect data.\nThe root cause is the absence of a validation guard in submitBalances(), which is a trusted function called by oDAO members. An attacker (malicious or compromised oDAO member) could submit unbalanced values where _stakingEth exceeds _totalEth.\nThis could be exploited by submitting a vote with out-of-bounds values, leading to incorrect network balance calculations and potentially affecting reward distributions or system state integrity.\nThe impact is considered low risk as it relies on trusted actors to submit data, but incorrect values could still cause unexpected behavior or inconsistencies in the protocol's financial accounting.\n",
            "severity": "Low",
            "location": [
                "RocketNetworkBalances.sol#L82-L111",
                "RocketNetworkBalances.sol#L122"
            ],
            "files": [
                "rocketpool/contracts/contract/network/RocketNetworkBalances.sol"
            ]
        },
        {
            "id": 60,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Use of pragma abicoder v2 is unnecessary",
            "description": "The pragma abicoder v2 directive is used in some contracts but is redundant because Solidity 0.8.0+ defaults to ABI coder v2.\nThe cause is outdated boilerplate code.\nThis has no functional impact but may confuse developers or suggest intentional use where none is needed.\nThe impact is purely code cleanliness and maintainability.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "rocketpool/contracts/interface/minipool/RocketMinipoolBondReducerInterface.sol",
                "rocketpool/contracts/interface/minipool/RocketMinipoolManagerInterface.sol",
                "rocketpool/contracts/interface/util/LinkedListStorageInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsRelayInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketSmoothingPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/claims/RocketClaimDAOInterface.sol",
                "rocketpool/contracts/interface/network/RocketNetworkBalancesInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityProposalsInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityUpgradeInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeManagerInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeDepositInterface.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolManager.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolBondReducer.sol",
                "rocketpool/contracts/contract/util/LinkedListStorage.sol",
                "rocketpool/contracts/contract/util/LinkedListStorageHelper.sol",
                "rocketpool/contracts/contract/rewards/RocketClaimDAO.sol",
                "rocketpool/contracts/contract/rewards/RocketSmoothingPool.sol",
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol",
                "rocketpool/contracts/contract/network/RocketNetworkBalances.sol",
                "rocketpool/contracts/contract/dao/protocol/RocketDAOProtocol.sol",
                "rocketpool/contracts/contract/node/RocketNodeManager.sol"
            ]
        },
        {
            "id": 61,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary pragma abicoder v2",
            "description": "The contracts use `pragma abicoder v2`, which is enabled by default in Solidity 0.8.0 and later versions. \nThe root cause is redundant compiler directive specification, which does not introduce a security risk but adds unnecessary code. \nThis can be exploited by increasing code complexity and potentially confusing developers into thinking special ABI encoding is required. \nThe impact is limited to code maintainability and readability, with no direct security consequences.\n",
            "severity": "Informational",
            "location": [
                "RocketDAOProtocol.sol#L3",
                "RocketNetworkBalances.sol#L3",
                "RocketClaimDAO.sol#L3",
                "RocketRewardsPool.sol#L3"
            ],
            "files": [
                "rocketpool/contracts/interface/minipool/RocketMinipoolBondReducerInterface.sol",
                "rocketpool/contracts/interface/minipool/RocketMinipoolManagerInterface.sol",
                "rocketpool/contracts/interface/util/LinkedListStorageInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsRelayInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketSmoothingPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/claims/RocketClaimDAOInterface.sol",
                "rocketpool/contracts/interface/network/RocketNetworkBalancesInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityProposalsInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityUpgradeInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeManagerInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeDepositInterface.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolManager.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolBondReducer.sol",
                "rocketpool/contracts/contract/util/LinkedListStorage.sol",
                "rocketpool/contracts/contract/util/LinkedListStorageHelper.sol",
                "rocketpool/contracts/contract/rewards/RocketClaimDAO.sol",
                "rocketpool/contracts/contract/rewards/RocketSmoothingPool.sol",
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol",
                "rocketpool/contracts/contract/network/RocketNetworkBalances.sol",
                "rocketpool/contracts/contract/dao/protocol/RocketDAOProtocol.sol",
                "rocketpool/contracts/contract/node/RocketNodeManager.sol"
            ]
        }
    ],
    "affected_files": {
        "LinkedListStorageHelper.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {LinkedListStorage} from \"./LinkedListStorage.sol\";\n\n/// @notice A linked list storage helper to test internal functions\ncontract LinkedListStorageHelper is LinkedListStorage {\n    \n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) LinkedListStorage(_rocketStorageAddress) {\n        version = 1;\n    }\n\n    /// @notice Add an item to the end of the list. Requires that the item does not exist in the list\n    /// @param _namespace defines the queue to be used\n    /// @param _item the deposit queue item\n    function enqueueItem(bytes32 _namespace, DepositQueueValue memory _item) public override {\n        _enqueueItem(_namespace, _item);\n    }\n\n    /// @notice Remove an item from the start of a queue and return it. Requires that the queue is not empty\n    /// @param _namespace defines the queue to be used\n    function dequeueItem(bytes32 _namespace) public virtual override  returns (DepositQueueValue memory item) {\n        return _dequeueItem(_namespace);\n    }\n\n    /// @notice Removes an item from a queue. Requires that the item exists in the queue\n    /// @param _namespace to be used\n    /// @param _key to be removed from the queue\n    function removeItem(bytes32 _namespace,  DepositQueueKey memory _key) public virtual override {\n        return _removeItem(_namespace, _key);\n    }\n\n    function packItem(DepositQueueValue memory _item) public pure returns (uint256 packed) {\n        return _packItem(_item);\n    }\n\n    function unpackItem(uint256 _item) public pure returns (DepositQueueValue memory item) {\n        return _unpackItem(_item);\n    }\n}",
        "RocketDAOSecurityProposalsInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\n\ninterface RocketDAOSecurityProposalsInterface {\n    function propose(string memory _proposalMessage, bytes memory _payload) external returns (uint256);\n    function vote(uint256 _proposalID, bool _support) external;\n    function cancel(uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n\n    function proposalSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function proposalSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function proposalSettingAddress(string memory _settingContractName, string memory _settingPath, address _value) external;\n\n    function proposalInvite(string memory _id, address _memberAddress) external;\n    function proposalKick(address _memberAddress) external;\n    function proposalKickMulti(address[] calldata _memberAddresses) external;\n    function proposalReplace(address _existingMemberAddress, string calldata _newMemberId, address _newMemberAddress) external;\n}\n",
        "RocketRewardsPoolInterface.sol": "pragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../types/RewardSubmission.sol\";\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketRewardsPoolInterface {\n    function getEthBalance() external view returns (uint256);\n    function getRewardIndex() external view returns(uint256);\n    function getRPLBalance() external view returns(uint256);\n    function getPendingRPLRewards() external view returns (uint256);\n    function getPendingETHRewards() external view returns (uint256);\n    function getPendingVoterShare() external view returns (uint256);\n    function getClaimIntervalTimeStart() external view returns(uint256);\n    function getClaimIntervalTime() external view returns(uint256);\n    function getClaimIntervalsPassed() external view returns(uint256);\n    function getClaimIntervalExecutionBlock(uint256 _interval) external view returns(uint256);\n    function getClaimIntervalExecutionAddress(uint256 _interval) external view returns(address);\n    function getClaimingContractPerc(string memory _claimingContract) external view returns(uint256);\n    function getClaimingContractsPerc(string[] memory _claimingContracts) external view returns (uint256[] memory);\n    function getTrustedNodeSubmitted(address _trustedNodeAddress, uint256 _rewardIndex) external view returns (bool);\n    function getSubmissionFromNodeExists(address _trustedNodeAddress, RewardSubmission calldata _submission) external view returns (bool);\n    function getSubmissionCount(RewardSubmission calldata _submission) external view returns (uint256);\n    function submitRewardSnapshot(RewardSubmission calldata _submission) external;\n    function executeRewardSnapshot(RewardSubmission calldata _submission) external;\n    function depositVoterShare() payable external;\n}\n",
        "RocketSmoothingPool.sol": "pragma solidity 0.7.6;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/rewards/RocketSmoothingPoolInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/*\nReceives priority fees and MEV via fee_recipient\n\nNOTE: This contract intentionally does not use RocketVault to store ETH because there is no way to account for ETH being\nadded to this contract via fee_recipient. This also means if this contract is upgraded, the ETH must be manually\ntransferred from this contract to the upgraded one.\n*/\n\ncontract RocketSmoothingPool is RocketBase, RocketSmoothingPoolInterface {\n\n    // Libs\n    using SafeMath for uint256;\n\n    // Events\n    event EtherWithdrawn(string indexed by, address indexed to, uint256 amount, uint256 time);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Version\n        version = 1;\n    }\n\n    // Allow receiving ETH\n    receive() payable external {}\n\n    // Withdraws ETH to given address\n    // Only accepts calls from Rocket Pool network contracts\n    function withdrawEther(address _to, uint256 _amount) override external onlyLatestNetworkContract {\n        // Valid amount?\n        require(_amount > 0, \"No valid amount of ETH given to withdraw\");\n        // Get contract name\n        string memory contractName = getContractName(msg.sender);\n        // Send the ETH\n        (bool result,) = _to.call{value: _amount}(\"\");\n        require(result, \"Failed to withdraw ETH\");\n        // Emit ether withdrawn event\n        emit EtherWithdrawn(contractName, _to, _amount, block.timestamp);\n    }\n}\n",
        "RocketNodeManagerInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../types/NodeDetails.sol\";\n\ninterface RocketNodeManagerInterface {\n\n    // Structs\n    struct TimezoneCount {\n        string timezone;\n        uint256 count;\n    }\n\n    function getNodeCount() external view returns (uint256);\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddressIsSet(address _nodeAddress) external view returns (bool);\n    function unsetRPLWithdrawalAddress(address _nodeAddress) external;\n    function setRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress, bool _confirm) external;\n    function confirmRPLWithdrawalAddress(address _nodeAddress) external;\n    function getNodePendingRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\n    function registerNode(string calldata _timezoneLocation) external;\n    function getNodeRegistrationTime(address _nodeAddress) external view returns (uint256);\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\n    function setRewardNetwork(address _nodeAddress, uint256 network) external;\n    function getRewardNetwork(address _nodeAddress) external view returns (uint256);\n    function getFeeDistributorInitialised(address _nodeAddress) external view returns (bool);\n    function initialiseFeeDistributor() external;\n    function getAverageNodeFee(address _nodeAddress) external view returns (uint256);\n    function setSmoothingPoolRegistrationState(bool _state) external;\n    function getSmoothingPoolRegistrationState(address _nodeAddress) external returns (bool);\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) external returns (uint256);\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) external view returns (uint256);\n    function getNodeAddresses(uint256 _offset, uint256 _limit) external view returns (address[] memory);\n    function deployMegapool() external returns (address);\n    function getExpressTicketCount(address _nodeAddress) external view returns (uint256);\n    function useExpressTicket(address _nodeAddress) external;\n    function provisionExpressTickets(address _nodeAddress) external;\n    function refundExpressTicket(address _nodeAddress) external;\n    function getMegapoolAddress(address _nodeAddress) external view returns (address);\n    function getUnclaimedRewards(address _nodeAddress) external view returns (uint256);\n    function addUnclaimedRewards(address _nodeAddress) external payable;\n    function claimUnclaimedRewards(address _nodeAddress) external;\n}\n",
        "RocketDAOProtocolProposalInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\nimport \"./RocketDAOProtocolVerifierInterface.sol\";\n\ninterface RocketDAOProtocolProposalInterface {\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        ActivePhase1,\n        ActivePhase2,\n        Destroyed,\n        Vetoed,\n        QuorumNotMet,\n        Defeated,\n        Succeeded,\n        Expired,\n        Executed\n    }\n\n    enum VoteDirection {\n        NoVote,\n        Abstain,\n        For,\n        Against,\n        AgainstWithVeto\n    }\n\n    function getTotal() external view returns (uint256);\n    function getProposer(uint256 _proposalID) external view returns (address);\n    function getMessage(uint256 _proposalID) external view returns (string memory);\n    function getStart(uint256 _proposalID) external view returns (uint256);\n    function getPhase1End(uint256 _proposalID) external view returns (uint256);\n    function getPhase2End(uint256 _proposalID) external view returns (uint256);\n    function getExpires(uint256 _proposalID) external view returns (uint256);\n    function getCreated(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerFor(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerAgainst(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerVeto(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerAbstained(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerRequired(uint256 _proposalID) external view returns (uint256);\n    function getDestroyed(uint256 _proposalID) external view returns (bool);\n    function getFinalised(uint256 _proposalID) external view returns (bool);\n    function getExecuted(uint256 _proposalID) external view returns (bool);\n    function getVetoQuorum(uint256 _proposalID) external view returns (uint256);\n    function getVetoed(uint256 _proposalID) external view returns (bool);\n    function getPayload(uint256 _proposalID) external view returns (bytes memory);\n    function getReceiptHasVoted(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptHasVotedPhase1(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptDirection(uint256 _proposalID, address _nodeAddress) external view returns (VoteDirection);\n    function getState(uint256 _proposalID) external view returns (ProposalState);\n\n    function getProposalBlock(uint256 _proposalID) external view returns (uint256);\n    function getProposalVetoQuorum(uint256 _proposalID) external view returns (uint256);\n\n    function propose(string memory _proposalMessage, bytes memory _payload, uint32 _blockNumber, Types.Node[] calldata _treeNodes) external returns (uint256);\n    function vote(uint256 _proposalID, VoteDirection _vote, uint256 _votingPower, uint256 _nodeIndex, Types.Node[] calldata _witness) external;\n    function overrideVote(uint256 _proposalID, VoteDirection _voteDirection) external;\n    function finalise(uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n    function destroy(uint256 _proposalID) external;\n}\n",
        "RocketRewardsPool.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketVaultInterface} from \"../../interface/RocketVaultInterface.sol\";\nimport {RocketDAONodeTrustedInterface} from \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport {RocketDAOProtocolSettingsNetworkInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport {RocketDAOProtocolSettingsRewardsInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol\";\nimport {RocketRewardsPoolInterface} from \"../../interface/rewards/RocketRewardsPoolInterface.sol\";\nimport {RocketRewardsRelayInterface} from \"../../interface/rewards/RocketRewardsRelayInterface.sol\";\nimport {RocketSmoothingPoolInterface} from \"../../interface/rewards/RocketSmoothingPoolInterface.sol\";\nimport {RocketTokenRPLInterface} from \"../../interface/token/RocketTokenRPLInterface.sol\";\nimport {IERC20} from \"../../interface/util/IERC20.sol\";\nimport {RewardSubmission} from \"../../types/RewardSubmission.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketVaultWithdrawerInterface} from \"../../interface/RocketVaultWithdrawerInterface.sol\";\n\n/// @notice Holds RPL and ETH generated by the network for distribution each reward cycle\ncontract RocketRewardsPool is RocketBase, RocketRewardsPoolInterface, RocketVaultWithdrawerInterface {\n    // Events\n    event RewardSnapshotSubmitted(address indexed from, uint256 indexed rewardIndex, RewardSubmission submission, uint256 time);\n    event RewardSnapshot(uint256 indexed rewardIndex, RewardSubmission submission, uint256 intervalStartTime, uint256 intervalEndTime, uint256 time);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 5;\n    }\n\n    /// @dev Needs to freely accept ETH withdrawn from the smoothing pool\n    receive() payable external {}\n\n    /// @dev Needs to freely accept ETH withdrawn from the vault\n    function receiveVaultWithdrawalETH() external payable {}\n\n    /// @notice Accepts incoming ETH from megapool distributions for voter share into vault\n    function depositVoterShare() override payable external {\n        // Transfer incoming ETH directly to the vault\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.depositEther{value: msg.value}();\n    }\n\n    /// @notice Returns the amount of ETH rewards waiting to be distributed\n    function getEthBalance() override external view returns (uint256) {\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        return rocketVault.balanceOf(\"rocketRewardsPool\");\n    }\n\n    /// @notice Get the reward index\n    function getRewardIndex() override public view returns (uint256) {\n        return getUint(keccak256(\"rewards.snapshot.index\"));\n    }\n\n    /// @notice Increment the reward index\n    function incrementRewardIndex() private {\n        addUint(keccak256(\"rewards.snapshot.index\"), 1);\n    }\n\n    /// @notice Get how much RPL the Rewards Pool contract currently has assigned to it as a whole\n    /// @return uint256 Returns rpl balance of rocket rewards contract\n    function getRPLBalance() override public view returns (uint256) {\n        // Get the vault contract instance\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Check contract RPL balance\n        return rocketVault.balanceOfToken(\"rocketRewardsPool\", IERC20(getContractAddress(\"rocketTokenRPL\")));\n    }\n\n    /// @notice Returns the total amount of RPL that needs to be distributed to claimers at the current block\n    function getPendingRPLRewards() override public view returns (uint256) {\n        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress(\"rocketTokenRPL\"));\n        uint256 pendingInflation = rplContract.inflationCalculate();\n        // Any inflation that has accrued so far plus any amount that would be minted if we called it now\n        return getRPLBalance() + pendingInflation;\n    }\n\n    /// @notice Returns the total amount of ETH in the smoothing pool ready to be distributed\n    function getPendingETHRewards() override public view returns (uint256) {\n        address rocketSmoothingPoolAddress = getContractAddress(\"rocketSmoothingPool\");\n        return rocketSmoothingPoolAddress.balance;\n    }\n\n    /// @notice Returns the amount of pending voter share ETH ready to be distributed\n    function getPendingVoterShare() override public view returns (uint256) {\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        return rocketVault.balanceOf(\"rocketRewardsPool\");\n    }\n\n    /// @notice Get the last set interval start time\n    /// @return uint256 Last set start timestamp for a claim interval\n    function getClaimIntervalTimeStart() override public view returns (uint256) {\n        return getUint(keccak256(\"rewards.pool.claim.interval.time.start\"));\n    }\n\n    /// @notice Get how many seconds in a claim interval\n    /// @return uint256 Number of seconds in a claim interval\n    function getClaimIntervalTime() override public view returns (uint256) {\n        // Get from the DAO settings\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        return daoSettingsRewards.getRewardsClaimIntervalTime();\n    }\n\n    /// @notice Compute intervals since last claim period\n    /// @return uint256 Time intervals since last update\n    function getClaimIntervalsPassed() override public view returns (uint256) {\n        return (block.timestamp - getClaimIntervalTimeStart()) / getClaimIntervalTime();\n    }\n\n    /// @notice Returns the block number that the given claim interval was executed at\n    /// @param _interval The interval for which to grab the execution block of\n    function getClaimIntervalExecutionBlock(uint256 _interval) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.block\", _interval)));\n    }\n\n    /// @notice Returns the address of the contract which was used to execute this reward interval\n    /// @param _interval The interval for which to grab the address of\n    function getClaimIntervalExecutionAddress(uint256 _interval) override external view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.address\", _interval)));\n    }\n\n    /// @notice Get the percentage this contract can claim in this interval\n    /// @return uint256 Rewards percentage this contract can claim in this interval\n    function getClaimingContractPerc(string memory _claimingContract) override public view returns (uint256) {\n        // Load contract\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        // Get the % amount allocated to this claim contract\n        return daoSettingsRewards.getRewardsClaimerPerc(_claimingContract);\n    }\n\n    /// @notice Get an array of percentages that the given contracts can claim in this interval\n    /// @return uint256[] Array of percentages in the order of the supplied contract names\n    function getClaimingContractsPerc(string[] memory _claimingContracts) override external view returns (uint256[] memory) {\n        // Load contract\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        // Get the % amount allocated to this claim contract\n        uint256[] memory percentages = new uint256[](_claimingContracts.length);\n        for (uint256 i = 0; i < _claimingContracts.length; ++i) {\n            percentages[i] = daoSettingsRewards.getRewardsClaimerPerc(_claimingContracts[i]);\n        }\n        return percentages;\n    }\n\n    /// @notice Returns whether a trusted node has submitted for a given reward index\n    function getTrustedNodeSubmitted(address _trustedNodeAddress, uint256 _rewardIndex) override external view returns (bool) {\n        return getBool(keccak256(abi.encode(\"rewards.snapshot.submitted.node\", _trustedNodeAddress, _rewardIndex)));\n    }\n\n    /// @notice Returns whether a trusted node has submitted a specific RewardSubmission\n    function getSubmissionFromNodeExists(address _trustedNodeAddress, RewardSubmission calldata _submission) override external view returns (bool) {\n        return getBool(keccak256(abi.encode(\"rewards.snapshot.submitted.node.key\", _trustedNodeAddress, _submission)));\n    }\n\n    /// @notice Returns the number of trusted nodes who have agreed to the given submission\n    function getSubmissionCount(RewardSubmission calldata _submission) override external view returns (uint256) {\n        return getUint(keccak256(abi.encode(\"rewards.snapshot.submitted.count\", _submission)));\n    }\n\n    /// @notice Submit a reward snapshot. Only accepts calls from trusted (oracle) nodes\n    function submitRewardSnapshot(RewardSubmission calldata _submission) override external onlyLatestContract(\"rocketRewardsPool\", address(this)) onlyTrustedNode(msg.sender) {\n        // Get contracts\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        // Check submission is currently enabled\n        require(rocketDAOProtocolSettingsNetwork.getSubmitRewardsEnabled(), \"Submitting rewards is currently disabled\");\n        // Validate inputs\n        uint256 rewardIndex = getRewardIndex();\n        require(_submission.rewardIndex <= rewardIndex, \"Can only submit snapshot for periods up to next\");\n        require(_submission.intervalsPassed > 0, \"Invalid number of intervals passed\");\n        require(_submission.nodeRPL.length == _submission.trustedNodeRPL.length && _submission.trustedNodeRPL.length == _submission.nodeETH.length, \"Invalid array length\");\n        // Calculate RPL reward total and validate\n        { // Scope to prevent stack too deep\n            uint256 totalRewardsRPL = _submission.treasuryRPL;\n            for (uint256 i = 0; i < _submission.nodeRPL.length; ++i) {\n                totalRewardsRPL = totalRewardsRPL + _submission.nodeRPL[i];\n            }\n            for (uint256 i = 0; i < _submission.trustedNodeRPL.length; ++i) {\n                totalRewardsRPL = totalRewardsRPL + _submission.trustedNodeRPL[i];\n            }\n            require(totalRewardsRPL <= getPendingRPLRewards(), \"Invalid RPL rewards\");\n        }\n        // Calculate ETH reward total and validate\n        { // Scope to prevent stack too deep\n            uint256 totalRewardsETH = _submission.treasuryETH + _submission.userETH;\n            for (uint256 i = 0; i < _submission.nodeETH.length; ++i) {\n                totalRewardsETH = totalRewardsETH + _submission.nodeETH[i];\n            }\n            uint256 smoothingPoolBalance = getPendingETHRewards();\n            require(totalRewardsETH <= smoothingPoolBalance + getPendingVoterShare(), \"Invalid ETH rewards\");\n            require(_submission.smoothingPoolETH <= smoothingPoolBalance, \"Invalid smoothing pool balance\");\n        }\n        // Store and increment vote\n        uint256 submissionCount;\n        { // Scope to prevent stack too deep\n            // Check & update node submission status\n            bytes32 nodeSubmissionKey = keccak256(abi.encode(\"rewards.snapshot.submitted.node.key\", msg.sender, _submission));\n            require(!getBool(nodeSubmissionKey), \"Duplicate submission from node\");\n            setBool(nodeSubmissionKey, true);\n            setBool(keccak256(abi.encode(\"rewards.snapshot.submitted.node\", msg.sender, _submission.rewardIndex)), true);\n        }\n        { // Scope to prevent stack too deep\n            // Increment submission count\n            bytes32 submissionCountKey = keccak256(abi.encode(\"rewards.snapshot.submitted.count\", _submission));\n            submissionCount = getUint(submissionCountKey) + 1;\n            setUint(submissionCountKey, submissionCount);\n        }\n        // Emit snapshot submitted event\n        emit RewardSnapshotSubmitted(msg.sender, _submission.rewardIndex, _submission, block.timestamp);\n        // Return if already executed\n        if (_submission.rewardIndex != rewardIndex) {\n            return;\n        }\n        // If consensus is reached, execute the snapshot\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        if (calcBase * submissionCount / rocketDAONodeTrusted.getMemberCount() >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n            _executeRewardSnapshot(_submission);\n        }\n    }\n\n    /// @notice Executes reward snapshot if consensus threshold is reached\n    function executeRewardSnapshot(RewardSubmission calldata _submission) override external onlyLatestContract(\"rocketRewardsPool\", address(this)) {\n        // Validate reward index of submission\n        require(_submission.rewardIndex == getRewardIndex(), \"Can only execute snapshot for next period\");\n        // Get submission count\n        bytes32 submissionCountKey = keccak256(abi.encode(\"rewards.snapshot.submitted.count\", _submission));\n        uint256 submissionCount = getUint(submissionCountKey);\n        // Confirm consensus and execute\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        require(calcBase * submissionCount / rocketDAONodeTrusted.getMemberCount() >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold(), \"Consensus has not been reached\");\n        _executeRewardSnapshot(_submission);\n    }\n\n    /// @notice Executes reward snapshot and sends assets to the relays for distribution to reward recipients\n    function _executeRewardSnapshot(RewardSubmission calldata _submission) private {\n        // Get contract\n        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress(\"rocketTokenRPL\"));\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Execute inflation if required\n        rplContract.inflationMintTokens();\n        // Increment the reward index and update the claim interval timestamp\n        incrementRewardIndex();\n        uint256 claimIntervalTimeStart = getClaimIntervalTimeStart();\n        uint256 claimIntervalTimeEnd = claimIntervalTimeStart + (getClaimIntervalTime() * _submission.intervalsPassed);\n        // Emit reward snapshot event\n        emit RewardSnapshot(_submission.rewardIndex, _submission, claimIntervalTimeStart, claimIntervalTimeEnd, block.timestamp);\n        setUint(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.block\", _submission.rewardIndex)), block.number);\n        setAddress(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.address\", _submission.rewardIndex)), address(this));\n        setUint(keccak256(\"rewards.pool.claim.interval.time.start\"), claimIntervalTimeEnd);\n        // Send out the treasury rewards\n        if (_submission.treasuryRPL > 0) {\n            rocketVault.transferToken(\"rocketClaimDAO\", rplContract, _submission.treasuryRPL);\n        }\n        // Get the smoothing pool instance\n        RocketSmoothingPoolInterface rocketSmoothingPool = RocketSmoothingPoolInterface(getContractAddress(\"rocketSmoothingPool\"));\n        // Send deposit pool user's ETH\n        if (_submission.smoothingPoolETH > 0) {\n            rocketSmoothingPool.withdrawEther(address(this), _submission.smoothingPoolETH);\n        }\n        // Calculate total amount of ETH required for this reward interval\n        uint256 totalETH = _submission.userETH + _submission.treasuryETH;\n        for (uint i = 0; i < _submission.nodeETH.length; ++i) {\n            totalETH += _submission.nodeETH[i];\n        }\n        // Withdraw required amount from the vault\n        uint256 vaultBalance = totalETH - _submission.smoothingPoolETH;\n        if (vaultBalance > 0) {\n            rocketVault.withdrawEther(vaultBalance);\n        }\n        // Send user share to rETH contract\n        if (_submission.userETH > 0) {\n            address rocketTokenRETHAddress = getContractAddress(\"rocketTokenRETH\");\n            (bool result,) = rocketTokenRETHAddress.call{value: _submission.userETH}(\"\");\n            require(result, \"Failed to send voter rewards\");\n        }\n        // Send pDAO share to treasury\n        if (_submission.treasuryETH > 0) {\n            address payable rocketClaimDAO = payable(getContractAddress(\"rocketClaimDAO\"));\n            (bool result,) = rocketClaimDAO.call{value: _submission.treasuryETH}(\"\");\n            require(result, \"Failed to send pDAO rewards\");\n        }\n        // Loop over each network and distribute rewards\n        for (uint i = 0; i < _submission.nodeRPL.length; ++i) {\n            // Quick out if no rewards for this network\n            uint256 rewardsRPL = _submission.nodeRPL[i] + _submission.trustedNodeRPL[i];\n            uint256 rewardsETH = _submission.nodeETH[i];\n            if (rewardsRPL == 0 && rewardsETH == 0) {\n                continue;\n            }\n            // Grab the relay address\n            RocketRewardsRelayInterface relay;\n            { // Scope to prevent stack too deep\n                address networkRelayAddress;\n                bytes32 networkRelayKey = keccak256(abi.encodePacked(\"rewards.relay.address\", i));\n                networkRelayAddress = getAddress(networkRelayKey);\n                // Validate network is valid\n                require(networkRelayAddress != address(0), \"Snapshot contains rewards for invalid network\");\n                relay = RocketRewardsRelayInterface(networkRelayAddress);\n            }\n            // Transfer rewards\n            if (rewardsRPL > 0) {\n                // RPL rewards are withdrawn from the vault\n                rocketVault.withdrawToken(address(relay), rplContract, rewardsRPL);\n            }\n            if (rewardsETH > 0) {\n                // ETH rewards are withdrawn from the smoothing pool\n                rocketSmoothingPool.withdrawEther(address(relay), rewardsETH);\n            }\n            // Call into relay contract to handle distribution of rewards\n            relay.relayRewards(_submission.rewardIndex, _submission.merkleRoot, rewardsRPL, rewardsETH);\n        }\n    }\n}\n",
        "RocketRewardsRelayInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nstruct Claim {\n    uint256 rewardIndex;\n    uint256 amountRPL;\n    uint256 amountSmoothingPoolETH;\n    uint256 amountVoterETH;\n    bytes32[] merkleProof;\n}\n\ninterface RocketRewardsRelayInterface {\n    function relayRewards(uint256 _intervalIndex, bytes32 _merkleRoot, uint256 _rewardsRPL, uint256 _rewardsETH) external;\n    function claim(address _nodeAddress, Claim[] calldata _claims) external;\n    function claimAndStake(address _nodeAddress, Claim[] calldata _claims, uint256 _stakeAmount) external;\n    function isClaimed(uint256 _intervalIndex, address _claimer) external view returns (bool);\n}\n",
        "RocketMinipoolManagerInterface.sol": "pragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"./RocketMinipoolInterface.sol\";\n\ninterface RocketMinipoolManagerInterface {\n    function getMinipoolCount() external view returns (uint256);\n    function getStakingMinipoolCount() external view returns (uint256);\n    function getFinalisedMinipoolCount() external view returns (uint256);\n    function getActiveMinipoolCount() external view returns (uint256);\n    function getMinipoolRPLSlashed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function getPrelaunchMinipools(uint256 offset, uint256 limit) external view returns (address[] memory);\n    function getMinipoolAt(uint256 _index) external view returns (address);\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) external view returns (uint256);\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\n    function getMinipoolDestroyed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) external;\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) external pure returns (bytes memory);\n    function createMinipool(address _nodeAddress, uint256 _salt) external returns (RocketMinipoolInterface);\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) external returns (RocketMinipoolInterface);\n    function removeVacantMinipool() external;\n    function getVacantMinipoolCount() external view returns (uint256);\n    function getVacantMinipoolAt(uint256 _index) external view returns (address);\n    function destroyMinipool() external;\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function tryDistribute(address _nodeAddress) external;\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\n    function getMinipoolDepositType(address _minipoolAddress) external view returns (MinipoolDeposit);\n}\n",
        "RocketDAOProtocolProposalsInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\n\ninterface RocketDAOProtocolProposalsInterface {\n    function proposalSettingMulti(string[] memory _settingContractNames, string[] memory _settingPaths, SettingType[] memory _types, bytes[] memory _data) external;\n    function proposalSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function proposalSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function proposalSettingAddress(string memory _settingContractName, string memory _settingPath, address _value) external;\n    function proposalSettingAddressList(string memory _settingContractName, string memory _settingPath, address[] calldata _value) external;\n    function proposalSettingRewardsClaimers(uint256 _trustedNodePercent, uint256 _protocolPercent, uint256 _nodePercent) external;\n\n    function proposalTreasuryOneTimeSpend(string memory _invoiceID, address _recipientAddress, uint256 _amount) external;\n    function proposalTreasuryNewContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _startTime, uint256 _numPeriods) external;\n    function proposalTreasuryUpdateContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _numPeriods) external;\n\n    function proposalSecurityInvite(string memory _id, address _memberAddress) external;\n    function proposalSecurityKick(address _memberAddress) external;\n    function proposalSecurityKickMulti(address[] calldata _memberAddresses) external;\n    function proposalSecurityReplace(address _existingMemberAddress, string calldata _id, address _newMemberAddress) external;\n}\n",
        "RocketMinipoolBondReducer.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketMinipoolInterface} from \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport {RocketMinipoolBondReducerInterface} from \"../../interface/minipool/RocketMinipoolBondReducerInterface.sol\";\nimport {RocketNodeDepositInterface} from \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport {RocketDAONodeTrustedSettingsMinipoolInterface} from \"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol\";\nimport {RocketDAONodeTrustedInterface} from \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport {RocketDAOProtocolSettingsRewardsInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol\";\nimport {RocketDAOProtocolSettingsMinipoolInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport {RocketMinipoolManagerInterface} from \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\n\n/// @notice Handles bond reduction window and trusted node cancellation\ncontract RocketMinipoolBondReducer is RocketBase, RocketMinipoolBondReducerInterface {\n    // Events\n    event CancelReductionVoted(address indexed minipool, address indexed member, uint256 time);\n    event ReductionCancelled(address indexed minipool, uint256 time);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 2;\n    }\n\n    /// @notice Always reverts\n    function beginReduceBondAmount(address _minipoolAddress, uint256 _newBondAmount) override external onlyLatestContract(\"rocketMinipoolBondReducer\", address(this)) {\n        revert(\"Minipool bond reductions are no longer available\");\n    }\n\n    /// @notice Always reverts\n    function reduceBondAmount() override external onlyRegisteredMinipool(msg.sender) onlyLatestContract(\"rocketMinipoolBondReducer\", address(this)) returns (uint256) {\n        revert(\"Minipool bond reductions are no longer available\");\n    }\n\n    /// @notice Always reverts\n    function voteCancelReduction(address _minipoolAddress) override external onlyTrustedNode(msg.sender) onlyLatestContract(\"rocketMinipoolBondReducer\", address(this)) {\n        revert(\"Minipool bond reductions are no longer available\");\n    }\n\n    /// @notice Returns the timestamp of when a given minipool began their bond reduction waiting period\n    /// @param _minipoolAddress Address of the minipool to query\n    function getReduceBondTime(address _minipoolAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"minipool.bond.reduction.time\", _minipoolAddress)));\n    }\n\n    /// @notice Returns the new bond that a given minipool has indicated they are reducing to\n    /// @param _minipoolAddress Address of the minipool to query\n    function getReduceBondValue(address _minipoolAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"minipool.bond.reduction.value\", _minipoolAddress)));\n    }\n\n    /// @notice Returns true if the given minipool has had it's bond reduction cancelled by the oDAO\n    /// @param _minipoolAddress Address of the minipool to query\n    function getReduceBondCancelled(address _minipoolAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.bond.reduction.cancelled\", address(_minipoolAddress))));\n    }\n\n    /// @notice Always returns false\n    /// @param _minipoolAddress Address of the minipool\n    function canReduceBondAmount(address _minipoolAddress) override public view returns (bool) {\n        return false;\n    }\n\n    /// @notice Returns a timestamp of when the given minipool last performed a bond reduction\n    /// @param _minipoolAddress The address of the minipool to query\n    /// @return Unix timestamp of last bond reduction (or 0 if never reduced)\n    function getLastBondReductionTime(address _minipoolAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"minipool.last.bond.reduction.time\", _minipoolAddress)));\n    }\n\n    /// @notice Returns the previous bond value of the given minipool on their last bond reduction\n    /// @param _minipoolAddress The address of the minipool to query\n    /// @return Previous bond value in wei (or 0 if never reduced)\n    function getLastBondReductionPrevValue(address _minipoolAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"minipool.last.bond.reduction.prev.value\", _minipoolAddress)));\n    }\n\n    /// @notice Returns the previous node fee of the given minipool on their last bond reduction\n    /// @param _minipoolAddress The address of the minipool to query\n    /// @return Previous node fee\n    function getLastBondReductionPrevNodeFee(address _minipoolAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"minipool.last.bond.reduction.prev.fee\", _minipoolAddress)));\n    }\n}\n",
        "RocketNetworkBalances.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/network/RocketNetworkBalancesInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\n\n/// @notice Oracle contract for network balance data\ncontract RocketNetworkBalances is RocketBase, RocketNetworkBalancesInterface {\n    // Events\n    event BalancesSubmitted(address indexed from, uint256 block, uint256 slotTimestamp, uint256 totalEth, uint256 stakingEth, uint256 rethSupply, uint256 blockTimestamp);\n    event BalancesUpdated(uint256 indexed block, uint256 slotTimestamp, uint256 totalEth, uint256 stakingEth, uint256 rethSupply, uint256 blockTimestamp);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 4;\n    }\n\n    /// @notice The block number which balances are current for\n    function getBalancesBlock() override public view returns (uint256) {\n        return getUint(keccak256(\"network.balances.updated.block\"));\n    }\n\n    /// @notice Sets the block number which balances are current for\n    function setBalancesBlock(uint256 _value) private {\n        setUint(keccak256(\"network.balances.updated.block\"), _value);\n    }\n\n    /// @notice Get the timestamp for the last balance update\n    function getBalancesTimestamp() override public view returns (uint256) {\n        return getUint(keccak256(\"network.balances.updated.timestamp\"));\n    }\n\n    /// @notice Sets the timestamp of the last balance update\n    function setBalancesTimestamp(uint256 _value) private {\n        setUint(keccak256(\"network.balances.updated.timestamp\"), _value);\n    }\n\n    /// @notice The current RP network total ETH balance\n    function getTotalETHBalance() override public view returns (uint256) {\n        return getUint(keccak256(\"network.balance.total\"));\n    }\n\n    /// @notice Sets the current RP network total ETH balance\n    function setTotalETHBalance(uint256 _value) private {\n        setUint(keccak256(\"network.balance.total\"), _value);\n    }\n\n    /// @notice The current RP network staking ETH balance\n    function getStakingETHBalance() override public view returns (uint256) {\n        return getUint(keccak256(\"network.balance.staking\"));\n    }\n\n    /// @notice Sets the current RP network staking ETH balance\n    function setStakingETHBalance(uint256 _value) private {\n        setUint(keccak256(\"network.balance.staking\"), _value);\n    }\n\n    /// @notice The current RP network total rETH supply\n    function getTotalRETHSupply() override public view returns (uint256) {\n        return getUint(keccak256(\"network.balance.reth.supply\"));\n    }\n\n    /// @notice Sets the current RP network total rETH supply\n    function setTotalRETHSupply(uint256 _value) private {\n        setUint(keccak256(\"network.balance.reth.supply\"), _value);\n    }\n\n    /// @notice Get the current RP network ETH utilization rate as a fraction of 1 ETH\n    ///         Represents what % of the network's balance is actively earning rewards\n    function getETHUtilizationRate() override external view returns (uint256) {\n        uint256 totalEthBalance = getTotalETHBalance();\n        uint256 stakingEthBalance = getStakingETHBalance();\n        if (totalEthBalance == 0) { return calcBase; }\n        return calcBase * stakingEthBalance / totalEthBalance;\n    }\n\n    /// @notice Submit network balances for a block.\n    ///         Only accepts calls from trusted (oracle) nodes.\n    function submitBalances(uint256 _block, uint256 _slotTimestamp, uint256 _totalEth, uint256 _stakingEth, uint256 _rethSupply) override external onlyLatestContract(\"rocketNetworkBalances\", address(this)) onlyTrustedNode(msg.sender) {\n        // Check settings\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        require(rocketDAOProtocolSettingsNetwork.getSubmitBalancesEnabled(), \"Submitting balances is currently disabled\");\n        // Check block\n        require(_block < block.number, \"Balances can not be submitted for a future block\");\n        uint256 lastBalancesBlock = getBalancesBlock();\n        require(_block >= lastBalancesBlock, \"Network balances for a higher block are set\");\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(abi.encodePacked(\"network.balances.submitted.node\", msg.sender, _block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply));\n        bytes32 submissionCountKey = keccak256(abi.encodePacked(\"network.balances.submitted.count\", _block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply));\n        // Check & update node submission status\n        require(!getBool(nodeSubmissionKey), \"Duplicate submission from node\");\n        setBool(nodeSubmissionKey, true);\n        setBool(keccak256(abi.encodePacked(\"network.balances.submitted.node\", msg.sender, _block)), true);\n        // Increment submission count\n        uint256 submissionCount = getUint(submissionCountKey) + 1;\n        setUint(submissionCountKey, submissionCount);\n        // Emit balances submitted event\n        emit BalancesSubmitted(msg.sender, _block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply, block.timestamp);\n        // If voting past consensus, return\n        if (_block == lastBalancesBlock) {\n            return;\n        }\n        // Check submission count & update network balances\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        if (calcBase * submissionCount / rocketDAONodeTrusted.getMemberCount() >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n            updateBalances(_block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply);\n        }\n    }\n\n    /// @notice Executes updateBalances if consensus threshold is reached\n    function executeUpdateBalances(uint256 _block, uint256 _slotTimestamp, uint256 _totalEth, uint256 _stakingEth, uint256 _rethSupply) override external onlyLatestContract(\"rocketNetworkBalances\", address(this)) {\n        // Check settings\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        require(rocketDAOProtocolSettingsNetwork.getSubmitBalancesEnabled(), \"Submitting balances is currently disabled\");\n        // Check block\n        require(_block < block.number, \"Balances can not be submitted for a future block\");\n        require(_block > getBalancesBlock(), \"Network balances for an equal or higher block are set\");\n        // Check balances\n        require(_stakingEth <= _totalEth, \"Invalid network balances\");\n        // Get submission keys\n        bytes32 submissionCountKey = keccak256(abi.encodePacked(\"network.balances.submitted.count\", _block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply));\n        // Get submission count\n        uint256 submissionCount = getUint(submissionCountKey);\n        // Check submission count & update network balances\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        require(calcBase * submissionCount / rocketDAONodeTrusted.getMemberCount() >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold(), \"Consensus has not been reached\");\n        updateBalances(_block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply);\n    }\n\n    /// @dev Internal method to update network balances\n    function updateBalances(uint256 _block, uint256 _slotTimestamp, uint256 _totalEth, uint256 _stakingEth, uint256 _rethSupply) private {\n        // Check enough time has passed (RPIP-61)\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        uint256 frequency = rocketDAOProtocolSettingsNetwork.getSubmitBalancesFrequency();\n        uint256 lastTimestamp = getBalancesTimestamp();\n        uint256 minimumTimestamp = lastTimestamp + (frequency * 95 / 100);\n        require(block.timestamp >= minimumTimestamp, \"Not enough time has passed\");\n        setBalancesTimestamp(block.timestamp);\n        // Check rETH delta is within allowed range (RPIP-61)\n        uint256 currentTotalEthBalance = getTotalETHBalance();\n        // Bypass the delta restriction on first balance update\n        if (currentTotalEthBalance > 0) {\n            uint256 currentRethSupply = getTotalRETHSupply();\n            uint256 currentRatio = calcBase * currentTotalEthBalance / currentRethSupply;\n            uint256 newRatio = calcBase * _totalEth / _rethSupply;\n            uint256 maxChangePercent = rocketDAOProtocolSettingsNetwork.getMaxRethDelta();\n            uint256 maxChange = currentRatio * maxChangePercent / calcBase;\n            // Limit change per RPIP-61\n            if (newRatio > currentRatio) {\n                require(newRatio - currentRatio <= maxChange, \"Change exceeds maximum\");\n            } else {\n                require(currentRatio - newRatio <= maxChange, \"Change exceeds maximum\");\n            }\n        }\n        // Update balances\n        setBalancesBlock(_block);\n        setTotalETHBalance(_totalEth);\n        setStakingETHBalance(_stakingEth);\n        setTotalRETHSupply(_rethSupply);\n        // Emit balances updated event\n        emit BalancesUpdated(_block, _slotTimestamp, _totalEth, _stakingEth, _rethSupply, block.timestamp);\n    }\n}\n",
        "RocketNodeManager.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketVaultInterface} from \"../../interface/RocketVaultInterface.sol\";\nimport {RocketVaultWithdrawerInterface} from \"../../interface/RocketVaultWithdrawerInterface.sol\";\nimport {RocketDAONodeTrustedSettingsRewardsInterface} from \"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsRewardsInterface.sol\";\nimport {RocketDAOProtocolSettingsDepositInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport {RocketDAOProtocolSettingsMinipoolInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport {RocketDAOProtocolSettingsNodeInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport {RocketDAOProtocolSettingsRewardsInterface} from \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol\";\nimport {RocketMegapoolFactoryInterface} from \"../../interface/megapool/RocketMegapoolFactoryInterface.sol\";\nimport {RocketMinipoolInterface} from \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport {RocketMinipoolManagerInterface} from \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport {RocketNetworkSnapshotsInterface} from \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\nimport {RocketNodeDistributorFactoryInterface} from \"../../interface/node/RocketNodeDistributorFactoryInterface.sol\";\nimport {RocketNodeManagerInterface} from \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport {RocketNodeStakingInterface} from \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport {AddressSetStorageInterface} from \"../../interface/util/AddressSetStorageInterface.sol\";\nimport {MinipoolStatus} from \"../../types/MinipoolStatus.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\n\npragma abicoder v2;\n\n/// @notice Node registration and management\ncontract RocketNodeManager is RocketBase, RocketNodeManagerInterface, RocketVaultWithdrawerInterface {\n\n    // Events\n    event NodeRegistered(address indexed node, uint256 time);\n    event NodeTimezoneLocationSet(address indexed node, uint256 time);\n    event NodeRewardNetworkChanged(address indexed node, uint256 network);\n    event NodeSmoothingPoolStateChanged(address indexed node, bool state);\n    event NodeRPLWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event NodeRPLWithdrawalAddressUnset(address indexed node, uint256 time);\n    event NodeUnclaimedRewardsAdded(address indexed node, uint256 amount, uint256 time);\n    event NodeUnclaimedRewardsClaimed(address indexed node, uint256 amount, uint256 time);\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 5;\n    }\n\n    /// @notice Accepts ETH withdrawn from the vault\n    function receiveVaultWithdrawalETH() external payable {\n        // Do nothing\n    }\n\n    /// @notice Get the number of nodes in the network\n    function getNodeCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"nodes.index\")));\n    }\n\n    /// @notice Get a breakdown of the number of nodes per timezone\n    /// @dev Iterating the entire set may exceed gas limit so caller can paginate using _offset and _limit\n    function getNodeCountPerTimezone(uint256 _offset, uint256 _limit) override external view returns (TimezoneCount[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute node key\n        bytes32 nodeKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        // Calculate range\n        uint256 totalNodes = addressSetStorage.getCount(nodeKey);\n        uint256 max = _offset + _limit;\n        if (max > totalNodes || _limit == 0) {max = totalNodes;}\n        // Create an array with as many elements as there are potential values to return\n        TimezoneCount[] memory counts = new TimezoneCount[](max - _offset);\n        uint256 uniqueTimezoneCount = 0;\n        // Iterate the minipool range\n        for (uint256 i = _offset; i < max; ++i) {\n            address nodeAddress = addressSetStorage.getItem(nodeKey, i);\n            string memory timezone = getString(keccak256(abi.encodePacked(\"node.timezone.location\", nodeAddress)));\n            // Find existing entry in our array\n            bool existing = false;\n            for (uint256 j = 0; j < uniqueTimezoneCount; ++j) {\n                if (keccak256(bytes(counts[j].timezone)) == keccak256(bytes(timezone))) {\n                    existing = true;\n                    // Increment the counter\n                    counts[j].count++;\n                    break;\n                }\n            }\n            // Entry was not found, so create a new one\n            if (!existing) {\n                counts[uniqueTimezoneCount].timezone = timezone;\n                counts[uniqueTimezoneCount].count = 1;\n                uniqueTimezoneCount++;\n            }\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(counts, uniqueTimezoneCount)\n        }\n        return counts;\n    }\n\n    /// @notice Get a node address by index\n    function getNodeAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"nodes.index\")), _index);\n    }\n\n    /// @notice Check whether a node exists\n    function getNodeExists(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)));\n    }\n\n    /// @notice Get a node's current withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) override public view returns (address) {\n        return rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n    }\n\n    /// @notice Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) override public view returns (address) {\n        return rocketStorage.getNodePendingWithdrawalAddress(_nodeAddress);\n    }\n\n    /// @notice Get a node's current RPL withdrawal address\n    function getNodeRPLWithdrawalAddress(address _nodeAddress) override public view returns (address) {\n        address withdrawalAddress = getAddress(keccak256(abi.encodePacked(\"node.rpl.withdrawal.address\", _nodeAddress)));\n        if (withdrawalAddress == address(0)) {\n            // Defaults to current withdrawal address if unset\n            return rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        }\n        return withdrawalAddress;\n    }\n\n    /// @notice Get a node's pending RPL withdrawal address\n    /// @param _nodeAddress Address of the node to query\n    function getNodePendingRPLWithdrawalAddress(address _nodeAddress) override public view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(\"node.pending.rpl.withdrawal.address\", _nodeAddress)));\n    }\n\n    /// @notice Returns true if a node has set an RPL withdrawal address\n    /// @param _nodeAddress Address of the node to query\n    function getNodeRPLWithdrawalAddressIsSet(address _nodeAddress) override external view returns (bool) {\n        return (getAddress(keccak256(abi.encodePacked(\"node.rpl.withdrawal.address\", _nodeAddress))) != address(0));\n    }\n\n    /// @notice Unsets a node operator's RPL withdrawal address returning it to the default\n    /// @param _nodeAddress Address of the node to query\n    function unsetRPLWithdrawalAddress(address _nodeAddress) external override onlyRegisteredNode(_nodeAddress) {\n        bytes32 addressKey = keccak256(abi.encodePacked(\"node.rpl.withdrawal.address\", _nodeAddress));\n        // Confirm the transaction is from the node's current RPL withdrawal address\n        require(getAddress(addressKey) == msg.sender, \"Only a tx from a node's RPL withdrawal address can unset it\");\n        // Unset the address\n        deleteAddress(addressKey);\n        // Emit withdrawal address unset event\n        emit NodeRPLWithdrawalAddressUnset(_nodeAddress, block.timestamp);\n    }\n\n    // @notice Set a node's RPL withdrawal address\n    /// @param _nodeAddress Address of the node to set RPL withdrawal address for\n    /// @param _newRPLWithdrawalAddress The new RPL withdrawal address to set\n    /// @param _confirm Whether to instantly make the change or requires a confirmation from the new address\n    function setRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress, bool _confirm) external override onlyRegisteredNode(_nodeAddress) {\n        // Check new RPL withdrawal address\n        require(_newRPLWithdrawalAddress != address(0x0), \"Invalid RPL withdrawal address\");\n        // Confirm the transaction is from the node's current RPL withdrawal address\n        address withdrawalAddress = getNodeRPLWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's RPL withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            // Delete any existing pending update\n            deleteAddress(keccak256(abi.encodePacked(\"node.pending.rpl.withdrawal.address\", _nodeAddress)));\n            // Perform the update\n            updateRPLWithdrawalAddress(_nodeAddress, _newRPLWithdrawalAddress);\n        }\n        else {\n            // Set pending withdrawal address immediately\n            setAddress(keccak256(abi.encodePacked(\"node.pending.rpl.withdrawal.address\", _nodeAddress)), _newRPLWithdrawalAddress);\n        }\n    }\n\n    /// @notice Confirm a node's new RPL withdrawal address\n    /// @param _nodeAddress Address of the node to confirm new RPL withdrawal address for\n    function confirmRPLWithdrawalAddress(address _nodeAddress) external override onlyRegisteredNode(_nodeAddress) {\n        bytes32 pendingKey = keccak256(abi.encodePacked(\"node.pending.rpl.withdrawal.address\", _nodeAddress));\n        // Get node by pending withdrawal address\n        require(getAddress(pendingKey) == msg.sender, \"Confirmation must come from the pending RPL withdrawal address\");\n        deleteAddress(pendingKey);\n        // Update withdrawal address\n        updateRPLWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    /// @dev Internal implementation of updating a node's RPL withdrawal address\n    /// @param _nodeAddress Address of the node to set RPL withdrawal address for\n    /// @param _newRPLWithdrawalAddress The new RPL withdrawal address to set\n    function updateRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress) private {\n        // Set new withdrawal address\n        setAddress(keccak256(abi.encodePacked(\"node.rpl.withdrawal.address\", _nodeAddress)), _newRPLWithdrawalAddress);\n        // Emit withdrawal address set event\n        emit NodeRPLWithdrawalAddressSet(_nodeAddress, _newRPLWithdrawalAddress, block.timestamp);\n    }\n\n    /// @notice Get a node's timezone location\n    /// @param _nodeAddress Address of the node to query\n    function getNodeTimezoneLocation(address _nodeAddress) override public view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(\"node.timezone.location\", _nodeAddress)));\n    }\n\n    /// @notice Register a new node with Rocket Pool\n    /// @param _timezoneLocation Timezone of the node operator (used only as a hint to the protocol about its geographic diversity)\n    function registerNode(string calldata _timezoneLocation) override external onlyLatestContract(\"rocketNodeManager\", address(this)) {\n        // Load contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Check node settings\n        require(rocketDAOProtocolSettingsNode.getRegistrationEnabled(), \"Rocket Pool node registrations are currently disabled\");\n        // Check timezone location\n        require(bytes(_timezoneLocation).length >= 4, \"The timezone location is invalid\");\n        // Initialise node data\n        setBool(keccak256(abi.encodePacked(\"node.exists\", msg.sender)), true);\n        setBool(keccak256(abi.encodePacked(\"node.voting.enabled\", msg.sender)), true);\n        setString(keccak256(abi.encodePacked(\"node.timezone.location\", msg.sender)), _timezoneLocation);\n        setBool(keccak256(abi.encodePacked(\"node.express.provisioned\", msg.sender)), true);\n        setUint(keccak256(abi.encodePacked(\"node.express.tickets\", msg.sender)), rocketDAOProtocolSettingsDeposit.getExpressQueueTicketsBaseProvision());\n        // Add node to index\n        bytes32 nodeIndexKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        addressSetStorage.addItem(nodeIndexKey, msg.sender);\n        // Set node registration time (uses old storage key name for backwards compatibility)\n        setUint(keccak256(abi.encodePacked(\"rewards.pool.claim.contract.registered.time\", \"rocketClaimNode\", msg.sender)), block.timestamp);\n        // Update count\n        rocketNetworkSnapshots.push(keccak256(abi.encodePacked(\"node.count\")), uint224(addressSetStorage.getCount(nodeIndexKey)));\n        // Default voting delegate to themself\n        rocketNetworkSnapshots.push(keccak256(abi.encodePacked(\"node.delegate\", msg.sender)), uint224(uint160(msg.sender)));\n        // Emit node registered event\n        emit NodeRegistered(msg.sender, block.timestamp);\n    }\n\n    /// @notice Gets the timestamp of when a node was registered\n    /// @param _nodeAddress Address of the node to query\n    function getNodeRegistrationTime(address _nodeAddress) onlyRegisteredNode(_nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"rewards.pool.claim.contract.registered.time\", \"rocketClaimNode\", _nodeAddress)));\n    }\n\n    /// @notice Set a node's timezone location\n    /// @param _timezoneLocation New timezone of the node operator\n    function setTimezoneLocation(string calldata _timezoneLocation) override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Check timezone location\n        require(bytes(_timezoneLocation).length >= 4, \"The timezone location is invalid\");\n        // Set timezone location\n        setString(keccak256(abi.encodePacked(\"node.timezone.location\", msg.sender)), _timezoneLocation);\n        // Emit node timezone location set event\n        emit NodeTimezoneLocationSet(msg.sender, block.timestamp);\n    }\n\n    /// @notice Returns true if node has initialised their fee distributor contract\n    /// @param _nodeAddress Address of the node to query\n    function getFeeDistributorInitialised(address _nodeAddress) override public view returns (bool) {\n        // Load contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        // Get distributor address\n        address contractAddress = rocketNodeDistributorFactory.getProxyAddress(_nodeAddress);\n        // Check if contract exists at that address\n        uint32 codeSize;\n        assembly {\n            codeSize := extcodesize(contractAddress)\n        }\n        return codeSize > 0;\n    }\n\n    /// @notice Node operators created before the distributor was implemented must call this to setup their distributor contract\n    /// @dev Fee distributor is no longer used but this function is provided for backwards compatibility for existing node operators who never initialised theirs\n    function initialiseFeeDistributor() override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Prevent multiple calls\n        require(!getFeeDistributorInitialised(msg.sender), \"Already initialised\");\n        // Load contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Calculate and set current average fee numerator\n        uint256 count = rocketMinipoolManager.getNodeMinipoolCount(msg.sender);\n        if (count > 0) {\n            uint256 numerator = 0;\n            // Note: this loop is safe as long as all current node operators at the time of upgrade have few enough minipools\n            for (uint256 i = 0; i < count; ++i) {\n                RocketMinipoolInterface minipool = RocketMinipoolInterface(rocketMinipoolManager.getNodeMinipoolAt(msg.sender, i));\n                if (minipool.getStatus() == MinipoolStatus.Staking) {\n                    numerator = numerator + minipool.getNodeFee();\n                }\n            }\n            setUint(keccak256(abi.encodePacked(\"node.average.fee.numerator\", msg.sender)), numerator);\n        }\n        // Create the distributor contract\n        _initialiseFeeDistributor(msg.sender);\n    }\n\n    /// @dev Deploys the fee distributor contract for a given node\n    function _initialiseFeeDistributor(address _nodeAddress) internal {\n        // Load contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        // Create the distributor proxy\n        rocketNodeDistributorFactory.createProxy(_nodeAddress);\n    }\n\n    /// @notice Calculates a node's average node fee (for minipools)\n    /// @param _nodeAddress Address of the node to query\n    function getAverageNodeFee(address _nodeAddress) override external view returns (uint256) {\n        // Load contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Get valid deposit amounts\n        uint256[2] memory depositSizes;\n        depositSizes[0] = 16 ether;\n        depositSizes[1] = 8 ether;\n        // Setup memory for calculations\n        uint256[] memory depositWeights = new uint256[](depositSizes.length);\n        uint256[] memory depositCounts = new uint256[](depositSizes.length);\n        uint256 depositWeightTotal;\n        uint256 totalCount;\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n        // Retrieve the number of staking minipools per deposit size\n        for (uint256 i = 0; i < depositSizes.length; ++i) {\n            depositCounts[i] = rocketMinipoolManager.getNodeStakingMinipoolCountBySize(_nodeAddress, depositSizes[i]);\n            totalCount = totalCount + depositCounts[i];\n        }\n        if (totalCount == 0) {\n            return 0;\n        }\n        // Calculate the weights of each deposit size\n        for (uint256 i = 0; i < depositSizes.length; ++i) {\n            depositWeights[i] = (launchAmount - depositSizes[i]) * depositCounts[i];\n            depositWeightTotal = depositWeightTotal + depositWeights[i];\n        }\n        for (uint256 i = 0; i < depositSizes.length; ++i) {\n            depositWeights[i] = depositWeights[i] * calcBase / depositWeightTotal;\n        }\n        // Calculate the weighted average\n        uint256 weightedAverage = 0;\n        for (uint256 i = 0; i < depositSizes.length; ++i) {\n            if (depositCounts[i] > 0) {\n                bytes32 numeratorKey;\n                if (depositSizes[i] == 16 ether) {\n                    numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n                } else {\n                    numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSizes[i]));\n                }\n                uint256 numerator = getUint(numeratorKey);\n                weightedAverage = weightedAverage + (numerator * depositWeights[i] / depositCounts[i]);\n            }\n        }\n        return weightedAverage / calcBase;\n    }\n\n    /// @notice Designates which network a node would like their rewards relayed to\n    /// @param _nodeAddress Address of the node to set reward network for\n    /// @param _network ID of the network\n    function setRewardNetwork(address _nodeAddress, uint256 _network) override external onlyLatestContract(\"rocketNodeManager\", address(this)) {\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can change reward network\");\n        // Check network is enabled\n        RocketDAONodeTrustedSettingsRewardsInterface rocketDAONodeTrustedSettingsRewards = RocketDAONodeTrustedSettingsRewardsInterface(getContractAddress(\"rocketDAONodeTrustedSettingsRewards\"));\n        require(rocketDAONodeTrustedSettingsRewards.getNetworkEnabled(_network), \"Network is not enabled\");\n        // Set the network\n        setUint(keccak256(abi.encodePacked(\"node.reward.network\", _nodeAddress)), _network);\n        // Emit event\n        emit NodeRewardNetworkChanged(_nodeAddress, _network);\n    }\n\n    /// @notice Returns which network a node has designated as their desired reward network\n    /// @param _nodeAddress Address of the node to query\n    function getRewardNetwork(address _nodeAddress) override public view onlyLatestContract(\"rocketNodeManager\", address(this)) returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.reward.network\", _nodeAddress)));\n    }\n\n    /// @notice Allows a node to register or deregister from the smoothing pool\n    /// @param _state True to opt in to the smoothing pool or false otherwise\n    function setSmoothingPoolRegistrationState(bool _state) override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Ensure registration is enabled\n        RocketDAOProtocolSettingsNodeInterface daoSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        require(daoSettingsNode.getSmoothingPoolRegistrationEnabled(), \"Smoothing pool registrations are not active\");\n        // Precompute storage keys\n        bytes32 changeKey = keccak256(abi.encodePacked(\"node.smoothing.pool.changed.time\", msg.sender));\n        bytes32 stateKey = keccak256(abi.encodePacked(\"node.smoothing.pool.state\", msg.sender));\n        // Get from the DAO settings\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        uint256 rewardInterval = daoSettingsRewards.getRewardsClaimIntervalTime();\n        // Ensure node operator has waited the required time\n        uint256 lastChange = getUint(changeKey);\n        require(block.timestamp >= lastChange + rewardInterval, \"Not enough time has passed since changing state\");\n        // Ensure state is actually changing\n        require(getBool(stateKey) != _state, \"Invalid state change\");\n        // Update registration state\n        setUint(changeKey, block.timestamp);\n        setBool(stateKey, _state);\n        // Emit state change event\n        emit NodeSmoothingPoolStateChanged(msg.sender, _state);\n    }\n\n    /// @notice Returns whether a node is registered or not from the smoothing pool\n    /// @param _nodeAddress Address of the node to query\n    function getSmoothingPoolRegistrationState(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.smoothing.pool.state\", _nodeAddress)));\n    }\n\n    /// @notice Returns the timestamp of when the node last changed their smoothing pool registration state\n    /// @param _nodeAddress Address of the node to query\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.smoothing.pool.changed.time\", _nodeAddress)));\n    }\n\n    /// @notice Returns the sum of nodes that are registered for the smoothing pool between _offset and (_offset + _limit)\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) override external view returns (uint256) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute node key\n        bytes32 nodeKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalNodes = getNodeCount();\n        uint256 max = _offset + _limit;\n        if (max > totalNodes || _limit == 0) {max = totalNodes;}\n        uint256 count = 0;\n        for (uint256 i = _offset; i < max; ++i) {\n            address nodeAddress = addressSetStorage.getItem(nodeKey, i);\n            if (getSmoothingPoolRegistrationState(nodeAddress)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /// @notice Returns a slice of the node operator address set\n    /// @param _offset The starting point for the slice\n    /// @param _limit The maximum number of results to return in the slice\n    function getNodeAddresses(uint256 _offset, uint256 _limit) override external view returns (address[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute node key\n        bytes32 nodeKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalNodes = getNodeCount();\n        uint256 max = _offset + _limit;\n        if (max > totalNodes || _limit == 0) {max = totalNodes;}\n        // Create array big enough for every minipool\n        address[] memory nodes = new address[](max - _offset);\n        uint256 total = 0;\n        for (uint256 i = _offset; i < max; ++i) {\n            nodes[total] = addressSetStorage.getItem(nodeKey, i);\n            total++;\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(nodes, total)\n        }\n        return nodes;\n    }\n\n    /// @notice Deploys a single Megapool contract for the calling node operator\n    function deployMegapool() override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) returns (address) {\n        RocketMegapoolFactoryInterface rocketMegapool = RocketMegapoolFactoryInterface(getContractAddress(\"rocketMegapoolFactory\"));\n        require(!rocketMegapool.getMegapoolDeployed(msg.sender), \"Megapool already deployed for this node\");\n        return rocketMegapool.deployContract(msg.sender);\n    }\n\n    /// @notice Returns the number of express tickets the given node has\n    /// @param _nodeAddress Address of the node operator to query\n    function getExpressTicketCount(address _nodeAddress) public override view returns (uint256) {\n        bool provisioned = getBool(keccak256(abi.encodePacked(\"node.express.provisioned\", _nodeAddress)));\n        uint256 expressTickets = 0;\n        if (!provisioned) {\n            // Nodes prior to Saturn should receive 2 express tickets (initial value of `express_queue_tickets_base_provision`)\n            expressTickets += 2;\n            // Each node SHALL be provided additional express_queue_tickets equal to (bonded ETH in legacy minipools)/4\n            RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n            uint256 bondedETH = rocketNodeStaking.getNodeETHBonded(_nodeAddress);\n            expressTickets += bondedETH / 4 ether;\n        }\n        expressTickets += getUint(keccak256(abi.encodePacked(\"node.express.tickets\", _nodeAddress)));\n        return expressTickets;\n    }\n\n    /// @notice Consumes an express ticket for the given node operator\n    /// @param _nodeAddress Address of the node operator to consume express ticket for\n    function useExpressTicket(address _nodeAddress) external override onlyLatestContract(\"rocketNodeManager\", address(this)) onlyLatestContract(\"rocketDepositPool\", msg.sender) {\n        uint256 tickets = getExpressTicketCount(_nodeAddress);\n        require(tickets > 0, \"No express tickets\");\n        tickets -= 1;\n        setBool(keccak256(abi.encodePacked(\"node.express.provisioned\", _nodeAddress)), true);\n        setUint(keccak256(abi.encodePacked(\"node.express.tickets\", _nodeAddress)), tickets);\n    }\n\n    /// @notice Calculates a node operator's entitled express tickets and stores them\n    /// @param _nodeAddress Address of the node operator to provision\n    function provisionExpressTickets(address _nodeAddress) external override onlyLatestContract(\"rocketNodeManager\", address(this)) onlyLatestContract(\"rocketDepositPool\", msg.sender) {\n        bytes32 provisionedKey = keccak256(abi.encodePacked(\"node.express.provisioned\", _nodeAddress));\n        if (getBool(provisionedKey)) {\n            return;\n        }\n        uint256 tickets = getExpressTicketCount(_nodeAddress);\n        setBool(provisionedKey, true);\n        setUint(keccak256(abi.encodePacked(\"node.express.tickets\", _nodeAddress)), tickets);\n    }\n\n    /// @notice Refunds an express ticket for the given node operator\n    /// @param _nodeAddress Address of the node operator to refund express ticket for\n    function refundExpressTicket(address _nodeAddress) external override onlyLatestContract(\"rocketNodeManager\", address(this)) onlyLatestContract(\"rocketDepositPool\", msg.sender) {\n        // Refunds can only occur after the use of a ticket which guarantees tickets were provisioned\n        addUint(keccak256(abi.encodePacked(\"node.express.tickets\", _nodeAddress)), 1);\n    }\n\n    /// @notice Convenience function to return the megapool address for a node if it is deployed, otherwise null address\n    /// @param _nodeAddress Address of the node to query\n    function getMegapoolAddress(address _nodeAddress) override external view returns (address) {\n        RocketMegapoolFactoryInterface rocketMegapoolFactory = RocketMegapoolFactoryInterface(getContractAddress(\"rocketMegapoolFactory\"));\n        if (rocketMegapoolFactory.getMegapoolDeployed(_nodeAddress)) {\n            return rocketMegapoolFactory.getExpectedAddress(_nodeAddress);\n        }\n        return address(0x0);\n    }\n\n    /// @notice Returns the amount of unclaimed ETH rewards for a given node operator\n    /// @param _nodeAddress Address of the node operator\n    function getUnclaimedRewards(address _nodeAddress) external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.unclaimed.rewards\", _nodeAddress)));\n    }\n\n    /// @notice Add funds to a node's unclaimed balance\n    /// @dev Used when a withdrawal address is unable to accept ETH rewards and allows node operator to claim them later\n    /// @param _nodeAddress Address of the node operator to increase unclaimed rewards for\n    function addUnclaimedRewards(address _nodeAddress) external payable {\n        // Deposit funds into vault and increase balance\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.depositEther{value: msg.value}();\n        addUint(keccak256(abi.encodePacked(\"node.unclaimed.rewards\", _nodeAddress)), msg.value);\n        // Emit event\n        emit NodeUnclaimedRewardsAdded(_nodeAddress, msg.value, block.timestamp);\n    }\n\n    /// @notice Sends any unclaimed rewards to node operator's withdrawal address\n    /// @param _nodeAddress Address of the node operator\n    function claimUnclaimedRewards(address _nodeAddress) external onlyRegisteredNode(_nodeAddress) {\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        require(msg.sender == _nodeAddress || msg.sender == withdrawalAddress, \"Only node can claim\");\n        // Retrieve unclaimed rewards amount and reset balance\n        bytes32 key = keccak256(abi.encodePacked(\"node.unclaimed.rewards\", _nodeAddress));\n        uint256 amount = getUint(key);\n        setUint(key, 0);\n        // Withdraw ETH from vault\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.withdrawEther(amount);\n        // Transfer to node operator's withdrawal address\n        (bool success,) = withdrawalAddress.call{value: amount}(\"\");\n        require(success, \"Failed to send funds to withdrawal address\");\n        // Emit event\n        emit NodeUnclaimedRewardsClaimed(_nodeAddress, amount, block.timestamp);\n    }\n}\n",
        "LinkedListStorageInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface LinkedListStorageInterface {\n    struct DepositQueueValue {\n        address receiver;      // the address that will receive the requested value\n        uint32 validatorId;    // internal validator id\n        uint32 suppliedValue;  // in milliether\n        uint32 requestedValue; // in milliether\n    }\n\n    struct DepositQueueKey {\n        address receiver;      // the address that will receive the requested value\n        uint32 validatorId;    // internal validator id\n    }\n\n    function getLength(bytes32 _namespace) external view returns (uint256);\n    function getItem(bytes32 _namespace, uint256 _index) external view returns (DepositQueueValue memory);\n    function peekItem(bytes32 _namespace) external view returns (DepositQueueValue memory);\n    function getIndexOf(bytes32 _namespace, DepositQueueKey memory _key) external view returns (uint256);\n    function getHeadIndex(bytes32 _namespace) external view returns (uint256);\n    function enqueueItem(bytes32 _namespace, DepositQueueValue memory _value) external;\n    function dequeueItem(bytes32 _namespace) external returns (DepositQueueValue memory);\n    function removeItem(bytes32 _namespace, DepositQueueKey memory _key) external;\n    function scan(bytes32 _namespace, uint256 _startIndex, uint256 _count) external view returns (DepositQueueValue[] memory entries, uint256 nextIndex);\n}\n",
        "RocketMinipoolManager.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport \"../RocketBase.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/util/AddressSetStorageInterface.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/network/RocketNetworkPricesInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolFactoryInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorFactoryInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorInterface.sol\";\nimport \"../../interface/network/RocketNetworkPenaltiesInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\";\nimport \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport \"../network/RocketNetworkSnapshots.sol\";\nimport \"../node/RocketNodeStaking.sol\";\n\n/// @notice Minipool creation, removal and management\ncontract RocketMinipoolManager is RocketBase, RocketMinipoolManagerInterface {\n\n    // Events\n    event MinipoolCreated(address indexed minipool, address indexed node, uint256 time);\n    event MinipoolDestroyed(address indexed minipool, address indexed node, uint256 time);\n    event BeginBondReduction(address indexed minipool, uint256 time);\n    event CancelReductionVoted(address indexed minipool, address indexed member, uint256 time);\n    event ReductionCancelled(address indexed minipool, uint256 time);\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 5;\n    }\n\n    /// @notice Get the number of minipools in the network\n    function getMinipoolCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(bytes(\"minipools.index\")));\n    }\n\n    /// @notice Get the number of minipools in the network in the Staking state\n    function getStakingMinipoolCount() override public view returns (uint256) {\n        return getUint(keccak256(bytes(\"minipools.staking.count\")));\n    }\n\n    /// @notice Get the number of finalised minipools in the network\n    function getFinalisedMinipoolCount() override external view returns (uint256) {\n        return getUint(keccak256(bytes(\"minipools.finalised.count\")));\n    }\n\n    /// @notice Get the number of active minipools in the network\n    function getActiveMinipoolCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        uint256 total = addressSetStorage.getCount(keccak256(bytes(\"minipools.index\")));\n        uint256 finalised = getUint(keccak256(bytes(\"minipools.finalised.count\")));\n        return total - finalised;\n    }\n\n    /// @notice Returns true if a minipool has had an RPL slashing\n    function getMinipoolRPLSlashed(address _minipoolAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.rpl.slashed\", _minipoolAddress)));\n    }\n\n    /// @notice Get the number of minipools in each status.\n    ///         Returns the counts for Initialised, Prelaunch, Staking, Withdrawable, and Dissolved in that order.\n    /// @param _offset The offset into the minipool set to start\n    /// @param _limit The maximum number of minipools to iterate\n    function getMinipoolCountPerStatus(uint256 _offset, uint256 _limit) override external view\n    returns (uint256 initialisedCount, uint256 prelaunchCount, uint256 stakingCount, uint256 withdrawableCount, uint256 dissolvedCount) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute minipool key\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\"minipools.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalMinipools = getMinipoolCount();\n        uint256 max = _offset + _limit;\n        if (max > totalMinipools || _limit == 0) { max = totalMinipools; }\n        for (uint256 i = _offset; i < max; ++i) {\n            // Get the minipool at index i\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\n            // Get the minipool's status, and update the appropriate counter\n            MinipoolStatus status = minipool.getStatus();\n            if (status == MinipoolStatus.Initialised) {\n                initialisedCount++;\n            }\n            else if (status == MinipoolStatus.Prelaunch) {\n                prelaunchCount++;\n            }\n            else if (status == MinipoolStatus.Staking) {\n                stakingCount++;\n            }\n            else if (status == MinipoolStatus.Withdrawable) {\n                withdrawableCount++;\n            }\n            else if (status == MinipoolStatus.Dissolved) {\n                dissolvedCount++;\n            }\n        }\n    }\n\n    /// @notice Returns an array of all minipools in the prelaunch state\n    /// @param _offset The offset into the minipool set to start iterating\n    /// @param _limit The maximum number of minipools to iterate over\n    function getPrelaunchMinipools(uint256 _offset, uint256 _limit) override external view\n    returns (address[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute minipool key\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\"minipools.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalMinipools = getMinipoolCount();\n        uint256 max = _offset + _limit;\n        if (max > totalMinipools || _limit == 0) { max = totalMinipools; }\n        // Create array big enough for every minipool\n        address[] memory minipools = new address[](max - _offset);\n        uint256 total = 0;\n        for (uint256 i = _offset; i < max; ++i) {\n            // Get the minipool at index i\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\n            // Get the minipool's status, and to array if it's in prelaunch\n            MinipoolStatus status = minipool.getStatus();\n            if (status == MinipoolStatus.Prelaunch) {\n                minipools[total] = address(minipool);\n                total++;\n            }\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(minipools, total)\n        }\n        return minipools;\n    }\n\n    /// @notice Get a network minipool address by index\n    /// @param _index Index into the minipool set to return\n    function getMinipoolAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"minipools.index\")), _index);\n    }\n\n    /// @notice Get the number of minipools owned by a node\n    /// @param _nodeAddress The node operator to query the count of minipools of\n    function getNodeMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)));\n    }\n\n    /// @notice Get the number of minipools owned by a node that are not finalised\n    /// @param _nodeAddress The node operator to query the count of active minipools of\n    function getNodeActiveMinipoolCount(address _nodeAddress) override public view returns (uint256) {\n        bytes32 key = keccak256(abi.encodePacked(\"minipools.active.count\", _nodeAddress));\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        (bool exists,, uint224 count) = rocketNetworkSnapshots.latest(key);\n        if (!exists){\n            // Fallback to old value\n            AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n            uint256 finalised = getUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)));\n            uint256 total = addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)));\n            return total - finalised;\n        }\n        return uint256(count);\n    }\n\n    /// @notice Get the number of minipools owned by a node that are finalised\n    /// @param _nodeAddress The node operator to query the count of finalised minipools of\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)));\n    }\n\n    /// @notice Get the number of minipools owned by a node that are in staking status\n    /// @param _nodeAddress The node operator to query the count of staking minipools of\n    function getNodeStakingMinipoolCount(address _nodeAddress) override public view returns (uint256) {\n        // Get valid deposit amounts\n        uint256[2] memory depositSizes;\n        depositSizes[0] = 16 ether;\n        depositSizes[1] = 8 ether;\n        uint256 total;\n        for (uint256 i = 0; i < depositSizes.length; ++i){\n            total = total + getNodeStakingMinipoolCountBySize(_nodeAddress, depositSizes[i]);\n        }\n        return total;\n    }\n\n    /// @notice Get the number of minipools owned by a node that are in staking status\n    /// @param _nodeAddress The node operator to query the count of minipools by desposit size of\n    /// @param _depositSize The deposit size to filter result by\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) override public view returns (uint256) {\n        bytes32 nodeKey;\n        if (_depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, _depositSize));\n        }\n        return getUint(nodeKey);\n    }\n\n    /// @notice Get a node minipool address by index\n    /// @param _nodeAddress The node operator to query the minipool of\n    /// @param _index Index into the node operator's set of minipools\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)), _index);\n    }\n\n    /// @notice Get the number of validating minipools owned by a node\n    /// @param _nodeAddress The node operator to query the count of validating minipools of\n    function getNodeValidatingMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.validating.index\", _nodeAddress)));\n    }\n\n    /// @notice Get a validating node minipool address by index\n    /// @param _nodeAddress The node operator to query the validating minipool of\n    /// @param _index Index into the node operator's set of validating minipools\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"node.minipools.validating.index\", _nodeAddress)), _index);\n    }\n\n    /// @notice Get a minipool address by validator pubkey\n    /// @param _pubkey The pubkey to query\n    function getMinipoolByPubkey(bytes memory _pubkey) override public view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(\"validator.minipool\", _pubkey)));\n    }\n\n    /// @notice Returns true if a minipool exists\n    /// @param _minipoolAddress The address of the minipool to check the existence of\n    function getMinipoolExists(address _minipoolAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress)));\n    }\n\n    /// @notice Returns true if a minipool previously existed at the given address\n    /// @param _minipoolAddress The address to check the previous existence of a minipool at\n    function getMinipoolDestroyed(address _minipoolAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.destroyed\", _minipoolAddress)));\n    }\n\n    /// @notice Returns a minipool's validator pubkey\n    /// @param _minipoolAddress The minipool to query the pubkey of\n    function getMinipoolPubkey(address _minipoolAddress) override public view returns (bytes memory) {\n        return getBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", _minipoolAddress)));\n    }\n\n    /// @notice Calculates what the withdrawal credentials of a minipool should be set to\n    /// @param _minipoolAddress The minipool to calculate the withdrawal credentials for\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) override public pure returns (bytes memory) {\n        return abi.encodePacked(bytes1(0x01), bytes11(0x0), address(_minipoolAddress));\n    }\n\n    /// @notice Decrements a node operator's number of staking minipools based on the minipools prior bond amount and\n    ///         increments it based on their new bond amount.\n    /// @param _previousBond The minipool's previous bond value\n    /// @param _newBond The minipool's new bond value\n    /// @param _previousFee The fee of the minipool prior to the bond change\n    /// @param _newFee The fee of the minipool after the bond change\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        address nodeAddress = minipool.getNodeAddress();\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(nodeAddress);\n        // Decrement previous bond count\n        if (_previousBond == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress, _previousBond));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress, _previousBond));\n        }\n        subUint(nodeKey, 1);\n        subUint(numeratorKey, _previousFee);\n        // Increment new bond count\n        if (_newBond == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress, _newBond));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress, _newBond));\n        }\n        addUint(nodeKey, 1);\n        addUint(numeratorKey, _newFee);\n    }\n\n    /// @dev Increments a node operator's number of staking minipools and calculates updated average node fee.\n    ///      Must be called from the minipool itself as msg.sender is used to query the minipool's node fee\n    /// @param _nodeAddress The node address to increment the number of staking minipools of\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(_nodeAddress);\n        // Update the node specific count\n        uint256 depositSize = minipool.getNodeDepositBalance();\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        if (depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, depositSize));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSize));\n        }\n        uint256 nodeValue = getUint(nodeKey);\n        setUint(nodeKey, nodeValue + 1);\n        // Update the total count\n        bytes32 totalKey = keccak256(abi.encodePacked(\"minipools.staking.count\"));\n        uint256 totalValue = getUint(totalKey);\n        setUint(totalKey, totalValue + 1);\n        // Update node fee average\n        addUint(numeratorKey, minipool.getNodeFee());\n    }\n\n    /// @dev Decrements a node operator's number of minipools in staking status and calculates updated average node fee.\n    ///      Must be called from the minipool itself as msg.sender is used to query the minipool's node fee\n    /// @param _nodeAddress The node address to decrement the number of staking minipools of\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(_nodeAddress);\n        // Update the node specific count\n        uint256 depositSize = minipool.getNodeDepositBalance();\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        if (depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, depositSize));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSize));\n        }\n        uint256 nodeValue = getUint(nodeKey);\n        setUint(nodeKey, nodeValue - 1);\n        // Update the total count\n        bytes32 totalKey = keccak256(abi.encodePacked(\"minipools.staking.count\"));\n        uint256 totalValue = getUint(totalKey);\n        setUint(totalKey, totalValue - 1);\n        // Update node fee average\n        subUint(numeratorKey, minipool.getNodeFee());\n    }\n\n    /// @notice Calls distribute on the given node's distributor if it has a balance and has been initialised\n    /// @dev Reverts if node has not initialised their distributor\n    /// @param _nodeAddress The node operator to try distribute rewards for\n    function tryDistribute(address _nodeAddress) override external {\n        _tryDistribute(_nodeAddress);\n    }\n\n    /// @dev Calls distribute on the given node's distributor if it has a balance and has been initialised\n    /// @param _nodeAddress The node operator to try distribute rewards for\n    function _tryDistribute(address _nodeAddress) internal {\n        // Get contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        address distributorAddress = rocketNodeDistributorFactory.getProxyAddress(_nodeAddress);\n        // If there are funds to distribute than call distribute\n        if (distributorAddress.balance > 0) {\n            // Get contracts\n            RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n            // Ensure distributor has been initialised\n            require(rocketNodeManager.getFeeDistributorInitialised(_nodeAddress), \"Distributor not initialised\");\n            RocketNodeDistributorInterface distributor = RocketNodeDistributorInterface(distributorAddress);\n            distributor.distribute();\n        }\n    }\n\n    /// @dev Increments a node operator's number of minipools that have been finalised\n    /// @param _nodeAddress The node operator to increment finalised minipool count for\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get active minipool count (before increasing finalised count in case of fallback calculation)\n        uint256 activeMinipoolCount = getNodeActiveMinipoolCount(_nodeAddress);\n        // Can only finalise a minipool once\n        bytes32 finalisedKey = keccak256(abi.encodePacked(\"node.minipools.finalised\", msg.sender));\n        require(!getBool(finalisedKey), \"Minipool has already been finalised\");\n        setBool(finalisedKey, true);\n        // Update the node specific count\n        addUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)), 1);\n        // Update the total count\n        addUint(keccak256(bytes(\"minipools.finalised.count\")), 1);\n        // Update ETH matched\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"eth.matched.node.amount\", _nodeAddress));\n        uint256 ethMatched = rocketNetworkSnapshots.latestValue(key);\n        ethMatched -= RocketMinipoolInterface(msg.sender).getUserDepositBalance();\n        rocketNetworkSnapshots.push(key, uint224(ethMatched));\n        // Decrement active count\n        key = keccak256(abi.encodePacked(\"minipools.active.count\", _nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(activeMinipoolCount - 1));\n    }\n\n    /// @dev Create a minipool. Only accepts calls from the RocketNodeDeposit contract\n    /// @param _nodeAddress The owning node operator's address\n    /// @param _salt A salt used in determining the minipool's address\n    function createMinipool(address _nodeAddress, uint256 _salt) override public onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyLatestContract(\"rocketNodeDeposit\", msg.sender) returns (RocketMinipoolInterface) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Check node minipool limit based on RPL stake\n        { // Local scope to prevent stack too deep error\n          RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n          // Check global minipool limit\n          uint256 totalActiveMinipoolCount = getActiveMinipoolCount();\n          require(totalActiveMinipoolCount + 1 <= rocketDAOProtocolSettingsMinipool.getMaximumCount(), \"Global minipool limit reached\");\n        }\n        // Get current active minipool count for this node operator (before we insert into address set in case it uses fallback calc)\n        uint256 activeMinipoolCount = getNodeActiveMinipoolCount(_nodeAddress);\n        // Create minipool contract\n        address contractAddress = deployContract(_nodeAddress, _salt);\n        // Initialise minipool data\n        setBool(keccak256(abi.encodePacked(\"minipool.exists\", contractAddress)), true);\n        // Add minipool to indexes\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"minipools.index\")), contractAddress);\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)), contractAddress);\n        // Increment active count\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"minipools.active.count\", _nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(activeMinipoolCount + 1));\n        // Emit minipool created event\n        emit MinipoolCreated(contractAddress, _nodeAddress, block.timestamp);\n        // Return created minipool address\n        return RocketMinipoolInterface(contractAddress);\n    }\n\n    /// @notice Creates a vacant minipool that can be promoted by changing the given validator's withdrawal credentials\n    /// @param _nodeAddress Address of the owning node operator\n    /// @param _salt A salt used in determining the minipool's address\n    /// @param _validatorPubkey A validator pubkey that the node operator intends to migrate the withdrawal credentials of\n    /// @param _bondAmount The bond amount selected by the node operator\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyLatestContract(\"rocketNodeDeposit\", msg.sender) returns (RocketMinipoolInterface) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Create the minipool\n        RocketMinipoolInterface minipool = createMinipool(_nodeAddress, _salt);\n        // Prepare the minipool\n        minipool.prepareVacancy(_bondAmount, _currentBalance);\n        // Set the minipool's validator pubkey\n        _setMinipoolPubkey(address(minipool), _validatorPubkey);\n        // Add minipool to the vacant set\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), address(minipool));\n        // Return\n        return minipool;\n    }\n\n    /// @dev Called by minipool to remove from vacant set on promotion or dissolution\n    function removeVacantMinipool() override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Remove from vacant set\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), msg.sender);\n        // If minipool was dissolved, remove mapping of pubkey to minipool to allow NO to try again in future\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        if (minipool.getStatus() == MinipoolStatus.Dissolved) {\n            bytes memory pubkey = getMinipoolPubkey(msg.sender);\n            deleteAddress(keccak256(abi.encodePacked(\"validator.minipool\", pubkey)));\n        }\n    }\n\n    /// @notice Returns the number of minipools in the vacant minipool set\n    function getVacantMinipoolCount() override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"minipools.vacant.index\")));\n    }\n\n    /// @notice Returns the vacant minipool at a given index\n    /// @param _index The index into the vacant minipool set to retrieve\n    function getVacantMinipoolAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), _index);\n    }\n\n    /// @dev Destroy a minipool cleaning up all relevant state. Only accepts calls from registered minipools\n    function destroyMinipool() override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Initialize minipool & get properties\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        address nodeAddress = minipool.getNodeAddress();\n        // Update ETH matched\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"eth.matched.node.amount\", nodeAddress));\n        uint256 ethMatched = uint256(rocketNetworkSnapshots.latestValue(key));\n        ethMatched -= minipool.getUserDepositBalance();\n        rocketNetworkSnapshots.push(key, uint224(ethMatched));\n        // Update minipool data\n        setBool(keccak256(abi.encodePacked(\"minipool.exists\", msg.sender)), false);\n        // Record minipool as destroyed to prevent recreation at same address\n        setBool(keccak256(abi.encodePacked(\"minipool.destroyed\", msg.sender)), true);\n        // Get number of active minipools (before removing from address set in case of fallback calculation)\n        uint256 activeMinipoolCount = getNodeActiveMinipoolCount(nodeAddress);\n        // Remove minipool from indexes\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"minipools.index\")), msg.sender);\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"node.minipools.index\", nodeAddress)), msg.sender);\n        // Clean up pubkey state\n        bytes memory pubkey = getMinipoolPubkey(msg.sender);\n        deleteBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", msg.sender)));\n        deleteAddress(keccak256(abi.encodePacked(\"validator.minipool\", pubkey)));\n        // Decrement active count\n        key = keccak256(abi.encodePacked(\"minipools.active.count\", nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(activeMinipoolCount - 1));\n        // Emit minipool destroyed event\n        emit MinipoolDestroyed(msg.sender, nodeAddress, block.timestamp);\n    }\n\n    /// @dev Set a minipool's validator pubkey. Only accepts calls from registered minipools\n    /// @param _pubkey The pubkey to set for the calling minipool\n    function setMinipoolPubkey(bytes calldata _pubkey) override public onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        _setMinipoolPubkey(msg.sender, _pubkey);\n    }\n\n    /// @dev Internal logic to set a minipool's pubkey, reverts if pubkey already set\n    /// @param _pubkey The pubkey to set for the calling minipool\n    function _setMinipoolPubkey(address _minipool, bytes calldata _pubkey) private {\n        // Check validator pubkey is not in use\n        require(getMinipoolByPubkey(_pubkey) == address(0x0), \"Validator pubkey is in use\");\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Initialise minipool & get properties\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipool);\n        address nodeAddress = minipool.getNodeAddress();\n        // Set minipool validator pubkey & validator minipool address\n        setBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", _minipool)), _pubkey);\n        setAddress(keccak256(abi.encodePacked(\"validator.minipool\", _pubkey)), _minipool);\n        // Add minipool to node validating minipools index\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"node.minipools.validating.index\", nodeAddress)), _minipool);\n    }\n\n    /// @dev Wrapper around minipool getDepositType which handles backwards compatibility with v1 and v2 delegates\n    /// @param _minipoolAddress Minipool address to get the deposit type of\n    function getMinipoolDepositType(address _minipoolAddress) external override view returns (MinipoolDeposit) {\n        RocketMinipoolInterface minipoolInterface = RocketMinipoolInterface(_minipoolAddress);\n        uint8 version = 1;\n\n        // Version 1 minipools did not have a version() function\n        try minipoolInterface.version() returns (uint8 tryVersion) {\n            version = tryVersion;\n        } catch (bytes memory /*lowLevelData*/) {}\n\n        if (version == 1 || version == 2) {\n            try minipoolInterface.getDepositType{gas: 30000}() returns (MinipoolDeposit depositType) {\n                return depositType;\n            } catch (bytes memory /*lowLevelData*/) {\n                return MinipoolDeposit.Variable;\n            }\n        }\n\n        return minipoolInterface.getDepositType();\n    }\n\n    /// @dev Performs a CREATE2 deployment of a minipool contract with given salt\n    /// @param _nodeAddress The owning node operator's address\n    /// @param _salt A salt used in determining the minipool's address\n    function deployContract(address _nodeAddress, uint256 _salt) private returns (address) {\n        RocketMinipoolFactoryInterface rocketMinipoolFactory = RocketMinipoolFactoryInterface(getContractAddress(\"rocketMinipoolFactory\"));\n        return rocketMinipoolFactory.deployContract(_nodeAddress, _salt);\n    }\n}\n",
        "RocketDAOSecurityUpgradeInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\n\ninterface RocketDAOSecurityUpgradeInterface {\n    function proposeVeto(string memory _proposalMessage, uint256 _upgradeProposalId) external returns (uint256);\n    function vote(uint256 _proposalID, bool _support) external;\n    function cancel(uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n\n    function proposalVeto(uint256 _upgradeProposalId) external;\n}\n",
        "RocketNodeDepositInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketNodeDepositInterface {\n    struct NodeDeposit {\n        uint256 bondAmount;\n        bool useExpressTicket;\n        bytes validatorPubkey;\n        bytes validatorSignature;\n        bytes32 depositDataRoot;\n    }\n\n    function getBondRequirement(uint256 _numValidators) external view returns (uint256);\n    function getNodeDepositCredit(address _nodeAddress) external view returns (uint256);\n    function getNodeEthBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeCreditAndBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeUsableCreditAndBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeUsableCredit(address _nodeAddress) external view returns (uint256);\n    function increaseDepositCreditBalance(address _nodeOperator, uint256 _amount) external;\n    function depositEthFor(address _nodeAddress) external payable;\n    function withdrawEth(address _nodeAddress, uint256 _amount) external;\n    function deposit(uint256 _depositAmount, bool _useExpressTicket, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external payable;\n    function depositWithCredit(uint256 _depositAmount, bool _useExpressTicket, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external payable;\n    function depositMulti(NodeDeposit[] calldata _deposits) external payable;\n}\n",
        "RocketDAOProtocolVerifierInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface Types {\n    enum ChallengeState {\n        Unchallenged,\n        Challenged,\n        Responded,\n        Paid\n    }\n\n    struct Proposal {\n        address proposer;\n        uint32 blockNumber;\n        uint128 nodeCount;\n        bytes32 hash;\n        uint256 sum;\n    }\n\n    struct Node {\n        uint256 sum;\n        bytes32 hash;\n    }\n\n    struct Leaf {\n        address nodeAddress;\n        uint256 effectiveRpl;\n    }\n}\n\ninterface RocketDAOProtocolVerifierInterface {\n    function getDefeatIndex(uint256 _proposalID) external view returns (uint256);\n    function getProposalBond(uint256 _proposalID) external view returns (uint256);\n    function getChallengeBond(uint256 _proposalID) external view returns (uint256);\n    function getChallengePeriod(uint256 _proposalID) external view returns (uint256);\n    function getDepthPerRound() external pure returns (uint256);\n    function submitProposalRoot(uint256 _proposalId, address _proposer, uint32 _blockNumber, Types.Node[] memory _treeNodes) external;\n    function burnProposalBond(uint256 _proposalID) external;\n    function createChallenge(uint256 _proposalID, uint256 _index, Types.Node calldata _node, Types.Node[] calldata _witness) external;\n    function submitRoot(uint256 propId, uint256 index, Types.Node[] memory nodes) external;\n    function getChallengeState(uint256 _proposalID, uint256 _index) external view returns (Types.ChallengeState);\n    function verifyVote(address _voter, uint256 _nodeIndex, uint256 _proposalID, uint256 _votingPower, Types.Node[] calldata _witness) external view returns (bool);\n}\n",
        "RocketClaimDAOInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface RocketClaimDAOInterface {\n    // Struct for returning data about a payment contract\n    struct PaymentContract {\n        address recipient;\n        uint256 amountPerPeriod;\n        uint256 periodLength;\n        uint256 lastPaymentTime;\n        uint256 numPeriods;\n        uint256 periodsPaid;\n    }\n\n    function getContractExists(string calldata _contractName) external view returns (bool);\n    function getContract(string calldata _contractName) external view returns (PaymentContract memory);\n    function getBalance(address _recipientAddress) external view returns (uint256);\n    function spend(string memory _invoiceID, address _recipientAddress, uint256 _amount) external;\n    function newContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _startTime, uint256 _numPeriods) external;\n    function updateContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _numPeriods) external;\n    function withdrawBalance(address _recipientAddress) external;\n    function payOutContracts(string[] calldata _contractNames) external;\n    function payOutContractsAndWithdraw(string[] calldata _contractNames) external;\n}\n",
        "RocketMinipoolBondReducerInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface RocketMinipoolBondReducerInterface {\n    function beginReduceBondAmount(address _minipoolAddress, uint256 _newBondAmount) external;\n    function getReduceBondTime(address _minipoolAddress) external view returns (uint256);\n    function getReduceBondValue(address _minipoolAddress) external view returns (uint256);\n    function getReduceBondCancelled(address _minipoolAddress) external view returns (bool);\n    function canReduceBondAmount(address _minipoolAddress) external view returns (bool);\n    function voteCancelReduction(address _minipoolAddress) external;\n    function reduceBondAmount() external returns (uint256);\n    function getLastBondReductionTime(address _minipoolAddress) external view returns (uint256);\n    function getLastBondReductionPrevValue(address _minipoolAddress) external view returns (uint256);\n    function getLastBondReductionPrevNodeFee(address _minipoolAddress) external view returns (uint256);\n}\n",
        "RocketClaimDAO.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\nimport {RocketVaultInterface} from \"../../interface/RocketVaultInterface.sol\";\nimport {RocketRewardsPoolInterface} from \"../../interface/rewards/RocketRewardsPoolInterface.sol\";\nimport {RocketClaimDAOInterface} from \"../../interface/rewards/claims/RocketClaimDAOInterface.sol\";\nimport {IERC20} from \"../../interface/util/IERC20.sol\";\n\n/// @notice Recipient of pDAO RPL from inflation. Performs treasury spends and handles recurring payments.\ncontract RocketClaimDAO is RocketBase, RocketClaimDAOInterface {\n    // Offsets into storage for contract details\n    uint256 constant internal existsOffset = 0;\n    uint256 constant internal recipientOffset = 1;\n    uint256 constant internal amountOffset = 2;\n    uint256 constant internal periodLengthOffset = 3;\n    uint256 constant internal lastPaymentOffset = 4;\n    uint256 constant internal numPeriodsOffset = 5;\n    uint256 constant internal periodsPaidOffset = 6;\n\n    // Events\n    event RPLTokensSentByDAOProtocol(string indexed invoiceID, address indexed from, address indexed to, uint256 amount, uint256 time);\n    event RPLTreasuryContractPayment(string indexed contractName, address indexed recipient, uint256 amount, uint256 time);\n    event RPLTreasuryContractClaimed(address indexed recipient, uint256 amount, uint256 time);\n    event RPLTreasuryContractCreated(string indexed contractName, address indexed recipient, uint256 amountPerPeriod, uint256 startTime, uint256 periodLength, uint256 numPeriods);\n    event RPLTreasuryContractUpdated(string indexed contractName, address indexed recipient, uint256 amountPerPeriod, uint256 periodLength, uint256 numPeriods);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 4;\n    }\n\n    /// @dev Receive pDAO share of rewards from megapool distributions and reward submissions\n    receive() payable external {\n        // Transfer incoming ETH directly to the vault\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.depositEther{value: msg.value}();\n        // Note: There is currently no way to spend this ETH\n    }\n\n    /// @notice Returns whether a contract with the given name exists\n    /// @param _contractName Name of the contract to check existence of\n    function getContractExists(string calldata _contractName) external view returns (bool) {\n        uint256 contractKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.treasury.contract\", _contractName)));\n        return getBool(bytes32(contractKey + existsOffset));\n    }\n\n    /// @notice Gets details about a given payment contract\n    /// @param _contractName Name of the contract to retrieve details for\n    function getContract(string calldata _contractName) override external view returns (PaymentContract memory) {\n        // Compute key\n        uint256 contractKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.treasury.contract\", _contractName)));\n        // Retrieve details\n        PaymentContract memory paymentContract;\n        paymentContract.recipient = getAddress(bytes32(contractKey + recipientOffset));\n        paymentContract.amountPerPeriod = getUint(bytes32(contractKey + amountOffset));\n        paymentContract.periodLength = getUint(bytes32(contractKey + periodLengthOffset));\n        paymentContract.lastPaymentTime = getUint(bytes32(contractKey + lastPaymentOffset));\n        paymentContract.numPeriods = getUint(bytes32(contractKey + numPeriodsOffset));\n        paymentContract.periodsPaid = getUint(bytes32(contractKey + periodsPaidOffset));\n        return paymentContract;\n    }\n\n    /// @notice Gets the outstanding balance owed to a given recipient\n    /// @param _recipientAddress The address of the recipient to return the balance of\n    function getBalance(address _recipientAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"dao.protocol.treasury.balance\", _recipientAddress)));\n    }\n\n    /// @notice Spend the network DAOs RPL rewards\n    /// @param _invoiceID A string used to identify this payment (not used internally)\n    /// @param _recipientAddress The address to send the RPL spend to\n    /// @param _amount The amount of RPL to send\n    function spend(string memory _invoiceID, address _recipientAddress, uint256 _amount) override external onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) onlyLatestContract(\"rocketClaimDAO\", address(this)) {\n        // Load contracts\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Addresses\n        IERC20 rplToken = IERC20(getContractAddress(\"rocketTokenRPL\"));\n        // Some initial checks\n        require(_amount > 0 && _amount <= rocketVault.balanceOfToken(\"rocketClaimDAO\", rplToken), \"You cannot send 0 RPL or more than the DAO has in its account\");\n        // Send now\n        rocketVault.withdrawToken(_recipientAddress, rplToken, _amount);\n        // Log it\n        emit RPLTokensSentByDAOProtocol(_invoiceID, address(this), _recipientAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Creates a new recurring payment contract\n    /// @param _contractName A string used to identify this payment\n    /// @param _recipientAddress The address which can claim against this recurring payment\n    /// @param _amountPerPeriod The amount of RPL that can be claimed each period\n    /// @param _periodLength The length (in seconds) of periods of this contract\n    /// @param _startTime A unix timestamp of when payments begin\n    /// @param _numPeriods The number of periods this contract pays out for\n    function newContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _startTime, uint256 _numPeriods) override external onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) onlyLatestContract(\"rocketClaimDAO\", address(this)) {\n        uint256 contractKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.treasury.contract\", _contractName)));\n        // Ensure contract name uniqueness\n        require(getBool(bytes32(contractKey + existsOffset)) == false, \"Contract already exists\");\n        // Write to storage\n        setBool(bytes32(contractKey + existsOffset), true);\n        setAddress(bytes32(contractKey + recipientOffset), _recipientAddress);\n        setUint(bytes32(contractKey + amountOffset), _amountPerPeriod);\n        setUint(bytes32(contractKey + periodLengthOffset), _periodLength);\n        setUint(bytes32(contractKey + lastPaymentOffset), _startTime);\n        setUint(bytes32(contractKey + numPeriodsOffset), _numPeriods);\n        // setUint(bytes32(contractKey + periodsPaidOffset), 0);\n        // Log it\n        emit RPLTreasuryContractCreated(_contractName, _recipientAddress, _amountPerPeriod, _startTime, _periodLength, _numPeriods);\n    }\n\n    /// @notice Modifies an existing recurring payment contract\n    /// @param _contractName The contract to modify\n    /// @param _recipientAddress The address which can claim against this recurring payment\n    /// @param _amountPerPeriod The amount of RPL that can be claimed each period\n    /// @param _periodLength The length (in seconds) of periods of this contract\n    /// @param _numPeriods The number of periods this contract pays out for\n    function updateContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _numPeriods) override external onlyLatestContract(\"rocketDAOProtocolProposals\", msg.sender) onlyLatestContract(\"rocketClaimDAO\", address(this)) {\n        uint256 contractKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.treasury.contract\", _contractName)));\n        // Check it exists\n        require(getBool(bytes32(contractKey + existsOffset)) == true, \"Contract does not exist\");\n        // Write to storage\n        uint256 lastPaymentTime = getUint(bytes32(contractKey + lastPaymentOffset));\n        // Payout contract per existing parameters if contract has already started\n        if (block.timestamp > lastPaymentTime) {\n            payOutContract(_contractName);\n        }\n        // Update the contract\n        setAddress(bytes32(contractKey + recipientOffset), _recipientAddress);\n        setUint(bytes32(contractKey + amountOffset), _amountPerPeriod);\n        setUint(bytes32(contractKey + periodLengthOffset), _periodLength);\n        setUint(bytes32(contractKey + numPeriodsOffset), _numPeriods);\n        // Log it\n        emit RPLTreasuryContractUpdated(_contractName, _recipientAddress, _amountPerPeriod, _periodLength, _numPeriods);\n    }\n\n    /// @notice Can be called to withdraw any paid amounts of RPL to the supplied recipient\n    /// @param _recipientAddress The recipient address to claim for\n    function withdrawBalance(address _recipientAddress) override public onlyLatestContract(\"rocketClaimDAO\", address(this)) {\n        // Load contracts\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Addresses\n        IERC20 rplToken = IERC20(getContractAddress(\"rocketTokenRPL\"));\n        // Get pending balance\n        bytes32 balanceKey = keccak256(abi.encodePacked(\"dao.protocol.treasury.balance\", _recipientAddress));\n        uint256 amount = getUint(balanceKey);\n        // Zero out pending balance\n        setUint(balanceKey, 0);\n        // Some initial checks\n        require(amount > 0, \"No balance to withdraw\");\n        require(amount <= rocketVault.balanceOfToken(\"rocketClaimDAO\", rplToken), \"Insufficient treasury balance for withdrawal\");\n        // Send now\n        rocketVault.withdrawToken(_recipientAddress, rplToken, amount);\n        // Log it\n        emit RPLTreasuryContractClaimed(_recipientAddress, amount, block.timestamp);\n    }\n\n    /// @notice Executes payout on the given contracts\n    /// @param _contractNames An array of contract names to execute a payout on\n    function payOutContracts(string[] calldata _contractNames) override external onlyLatestContract(\"rocketClaimDAO\", address(this)) {\n        uint256 contractNamesLength = _contractNames.length;\n        for (uint256 i = 0; i < contractNamesLength; ++i) {\n            payOutContract(_contractNames[i]);\n        }\n    }\n\n    /// @notice Executes a payout on given contracts and withdraws the resulting balance to the recipient\n    /// @param _contractNames An array of contract names to execute a payout and withdraw on\n    function payOutContractsAndWithdraw(string[] calldata _contractNames) override external onlyLatestContract(\"rocketClaimDAO\", address(this)) {\n        uint256 contractNamesLength = _contractNames.length;\n        for (uint256 i = 0; i < contractNamesLength; ++i) {\n            // Payout contract\n            payOutContract(_contractNames[i]);\n            // Withdraw to contract recipient\n            uint256 contractKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.treasury.contract\", _contractNames[i])));\n            address recipient = getAddress(bytes32(contractKey + recipientOffset));\n            withdrawBalance(recipient);\n        }\n    }\n\n    /// @dev Pays out any outstanding amounts to the recipient of a contract\n    function payOutContract(string memory _contractName) internal {\n        uint256 contractKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.treasury.contract\", _contractName)));\n\n        uint256 lastPaymentTime = getUint(bytes32(contractKey + lastPaymentOffset));\n\n        // Payments haven't started yet (nothing to do)\n        if (block.timestamp < lastPaymentTime) {\n            return;\n        }\n\n        uint256 periodLength = getUint(bytes32(contractKey + periodLengthOffset));\n        uint256 periodsToPay = (block.timestamp - lastPaymentTime) / periodLength;\n\n        uint256 periodsPaid = getUint(bytes32(contractKey + periodsPaidOffset));\n        uint256 numPeriods = getUint(bytes32(contractKey + numPeriodsOffset));\n\n        // Calculate how many periods to pay\n        if (periodsToPay + periodsPaid > numPeriods) {\n            periodsToPay = numPeriods - periodsPaid;\n        }\n\n        // Already paid up to date\n        if (periodsToPay == 0) {\n            return;\n        }\n\n        address recipientAddress = getAddress(bytes32(contractKey + recipientOffset));\n        uint256 amountPerPeriod = getUint(bytes32(contractKey + amountOffset));\n        uint256 amountToPay = periodsToPay * amountPerPeriod;\n\n        // Update last paid timestamp and periods paid\n        setUint(bytes32(contractKey + lastPaymentOffset), lastPaymentTime + (periodsToPay * periodLength));\n        setUint(bytes32(contractKey + periodsPaidOffset), periodsPaid + periodsToPay);\n\n        // Add to the recipient's balance\n        addUint(keccak256(abi.encodePacked(\"dao.protocol.treasury.balance\", recipientAddress)), amountToPay);\n\n        // Emit event\n        emit RPLTreasuryContractPayment(_contractName, recipientAddress, amountToPay, block.timestamp);\n    }\n}\n",
        "RocketNetworkBalancesInterface.sol": "pragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNetworkBalancesInterface {\n    function getBalancesTimestamp() external view returns (uint256);\n    function getBalancesBlock() external view returns (uint256);\n    function getTotalETHBalance() external view returns (uint256);\n    function getStakingETHBalance() external view returns (uint256);\n    function getTotalRETHSupply() external view returns (uint256);\n    function getETHUtilizationRate() external view returns (uint256);\n    function submitBalances(uint256 _block, uint256 _slotTimestamp, uint256 _total, uint256 _staking, uint256 _rethSupply) external;\n    function executeUpdateBalances(uint256 _block, uint256 _slotTimestamp, uint256 _totalEth, uint256 _stakingEth, uint256 _rethSupply) external;\n}\n",
        "RocketSmoothingPoolInterface.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface RocketSmoothingPoolInterface {\n    function withdrawEther(address _to, uint256 _amount) external;\n}\n",
        "RocketDAOProtocol.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {RocketStorageInterface} from \"../../../interface/RocketStorageInterface.sol\";\nimport {RocketDAOProtocolInterface} from \"../../../interface/dao/protocol/RocketDAOProtocolInterface.sol\";\nimport {RocketDAOProtocolProposalsInterface} from \"../../../interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol\";\nimport {SettingType} from \"../../../types/SettingType.sol\";\nimport {RocketBase} from \"../../RocketBase.sol\";\n\n/// @notice The Rocket Pool Protocol DAO (pDAO)\ncontract RocketDAOProtocol is RocketBase, RocketDAOProtocolInterface {\n    // Events\n    event BootstrapSettingMulti(string[] settingContractNames, string[] settingPaths, SettingType[] types, bytes[] values, uint256 time);\n    event BootstrapSettingUint(string settingContractName, string settingPath, uint256 value, uint256 time);\n    event BootstrapSettingBool(string settingContractName, string settingPath, bool value, uint256 time);\n    event BootstrapSettingAddress(string settingContractName, string settingPath, address value, uint256 time);\n    event BootstrapSettingAddressList(string settingContractName, string settingPath, address[] value, uint256 time);\n    event BootstrapSettingClaimers(uint256 trustedNodePercent, uint256 protocolPercent, uint256 nodePercent, uint256 time);\n    event BootstrapSpendTreasury(string invoiceID, address recipientAddress, uint256 amount, uint256 time);\n    event BootstrapTreasuryNewContract(string contractName, address recipientAddress, uint256 amountPerPeriod, uint256 periodLength, uint256 startTime, uint256 numPeriods, uint256 time);\n    event BootstrapTreasuryUpdateContract(string contractName, address recipientAddress, uint256 amountPerPeriod, uint256 periodLength, uint256 numPeriods, uint256 time);\n    event BootstrapSecurityInvite(string id, address memberAddress, uint256 time);\n    event BootstrapSecurityKick(address memberAddress, uint256 time);\n    event BootstrapDisabled(uint256 time);\n    event BootstrapProtocolDAOEnabled(uint256 block, uint256 time);\n\n    // The namespace for any data stored in the network DAO (do not change)\n    string constant internal daoNameSpace = \"dao.protocol.\";\n\n    // Only allow bootstrapping when enabled\n    modifier onlyBootstrapMode() {\n        require(getBootstrapModeDisabled() == false, \"Bootstrap mode not engaged\");\n        _;\n    }\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 3;\n    }\n\n    /**** DAO Properties **************/\n\n    /// @notice Returns true if bootstrap mode is disabled\n    function getBootstrapModeDisabled() override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoNameSpace, \"bootstrapmode.disabled\")));\n    }\n\n    /// @notice Get the last time this user made a proposal\n    function getMemberLastProposalTime(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.proposal.lasttime\", _nodeAddress)));\n    }\n\n    /**** Bootstrapping ***************/\n    // While bootstrap mode is engaged, RP can change settings alongside the DAO. When disabled, only DAO will be able to control settings\n\n    /// @notice Bootstrap mode - multi Setting\n    function bootstrapSettingMulti(string[] memory _settingContractNames, string[] memory _settingPaths, SettingType[] memory _types, bytes[] memory _values) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSettingMulti(_settingContractNames, _settingPaths, _types, _values);\n        emit BootstrapSettingMulti(_settingContractNames, _settingPaths, _types, _values, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Uint Setting\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSettingUint(_settingContractName, _settingPath, _value);\n        emit BootstrapSettingUint(_settingContractName, _settingPath, _value, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Bool Setting\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSettingBool(_settingContractName, _settingPath, _value);\n        emit BootstrapSettingBool(_settingContractName, _settingPath, _value, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Address Setting\n    function bootstrapSettingAddress(string memory _settingContractName, string memory _settingPath, address _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSettingAddress(_settingContractName, _settingPath, _value);\n        emit BootstrapSettingAddress(_settingContractName, _settingPath, _value, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Address list Setting\n    function bootstrapSettingAddressList(string memory _settingContractName, string memory _settingPath, address[] calldata _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSettingAddressList(_settingContractName, _settingPath, _value);\n        emit BootstrapSettingAddressList(_settingContractName, _settingPath, _value, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Set a claiming contract to receive a % of RPL inflation rewards\n    function bootstrapSettingClaimers(uint256 _trustedNodePercent, uint256 _protocolPercent, uint256 _nodePercent) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSettingRewardsClaimers(_trustedNodePercent, _protocolPercent, _nodePercent);\n        emit BootstrapSettingClaimers(_trustedNodePercent, _protocolPercent, _nodePercent, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Spend DAO treasury\n    function bootstrapSpendTreasury(string memory _invoiceID, address _recipientAddress, uint256 _amount) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalTreasuryOneTimeSpend(_invoiceID, _recipientAddress, _amount);\n        emit BootstrapSpendTreasury(_invoiceID, _recipientAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - New treasury contract\n    function bootstrapTreasuryNewContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _startTime, uint256 _numPeriods) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalTreasuryNewContract(_contractName, _recipientAddress, _amountPerPeriod, _periodLength, _startTime, _numPeriods);\n        emit BootstrapTreasuryNewContract(_contractName, _recipientAddress, _amountPerPeriod, _periodLength, _startTime, _numPeriods, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Update treasury contract\n    function bootstrapTreasuryUpdateContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _numPeriods) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalTreasuryUpdateContract(_contractName, _recipientAddress, _amountPerPeriod, _periodLength, _numPeriods);\n        emit BootstrapTreasuryUpdateContract(_contractName, _recipientAddress, _amountPerPeriod, _periodLength, _numPeriods, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Invite security council member\n    function bootstrapSecurityInvite(string memory _id, address _memberAddress) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSecurityInvite(_id, _memberAddress);\n        emit BootstrapSecurityInvite(_id, _memberAddress, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Kick security council member\n    function bootstrapSecurityKick(address _memberAddress) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        RocketDAOProtocolProposalsInterface(getContractAddress(\"rocketDAOProtocolProposals\")).proposalSecurityKick(_memberAddress);\n        emit BootstrapSecurityKick(_memberAddress, block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Disable RP Access (only RP can call this to hand over full control to the DAO)\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        // Prevent disabling bootstrap if on-chain governance has not been enabled\n        require(getUint(keccak256(abi.encodePacked(\"protocol.dao.enabled.block\"))) > 0, \"On-chain governance must be enabled first\");\n        // Disable bootstrap\n        require(_confirmDisableBootstrapMode == true, \"You must confirm disabling bootstrap mode, it can only be done once!\");\n        setBool(keccak256(abi.encodePacked(daoNameSpace, \"bootstrapmode.disabled\")), true);\n        emit BootstrapDisabled(block.timestamp);\n    }\n\n    /// @notice Bootstrap mode - Enables on-chain governance proposals\n    function bootstrapEnableGovernance() override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAOProtocol\", address(this)) {\n        setUint(keccak256(abi.encodePacked(\"protocol.dao.enabled.block\")), block.number);\n        emit BootstrapProtocolDAOEnabled(block.number, block.timestamp);\n    }\n}\n",
        "LinkedListStorage.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\npragma abicoder v2;\n\nimport {LinkedListStorageInterface} from \"../../interface/util/LinkedListStorageInterface.sol\";\nimport {RocketBase} from \"../RocketBase.sol\";\nimport {RocketStorageInterface} from \"../../interface/RocketStorageInterface.sol\";\n\n/// @notice A linked list storage helper for the deposit requests queue data\ncontract LinkedListStorage is RocketBase, LinkedListStorageInterface {\n\n    // Constants for packing queue metadata into a single uint256\n    uint256 constant internal startOffset = 256 - 64;\n    uint256 constant internal endOffset = 256 - 128;\n    uint256 constant internal lengthOffset = 256 - 192;\n\n    // Constants for packing a deposit item (struct) into a single uint256\n    uint256 constant internal receiverOffset = 256 - 160;\n    uint256 constant internal indexOffset = 256 - 160 - 32;\n    uint256 constant internal suppliedOffset = 256 - 160 - 32 - 32;\n\n    uint64 constant internal ones64Bits = 0xFFFFFFFFFFFFFFFF;\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 1;\n    }\n\n    /// @notice The number of items in the queue\n    /// @param _namespace defines the queue to be used\n    function getLength(bytes32 _namespace) override public view returns (uint256) {\n        return uint64(getUint(keccak256(abi.encodePacked(_namespace, \".data\"))) >> lengthOffset);\n    }\n\n    /// @notice The item in a queue by index\n    /// @param _namespace defines the queue to be used\n    /// @param _index the item index\n    function getItem(bytes32 _namespace, uint256 _index) override external view returns (DepositQueueValue memory) {\n        uint256 packedValue = getUint(keccak256(abi.encodePacked(_namespace, \".item\", _index)));\n        return _unpackItem(packedValue);\n    }\n\n    /// @notice The index of an item in a queue. Returns 0 if the value is not found\n    /// @param _namespace defines the queue to be used\n    /// @param _key the deposit queue value\n    function getIndexOf(bytes32 _namespace, DepositQueueKey memory _key) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(_namespace, \".index\", _key.receiver, _key.validatorId)));\n    }\n\n    /// @notice Returns the index of the item at the head of the list\n    /// @param _namespace defines the queue to be used\n    function getHeadIndex(bytes32 _namespace) override external view returns (uint256) {\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        return uint64(data >> startOffset);\n    }\n\n    /// @notice Finds an item index in a queue and returns the previous item\n    /// @param _namespace defines the queue to be used\n    /// @param _value the deposit queue value\n    function getPreviousItem(bytes32 _namespace, DepositQueueValue memory _value) external view returns (DepositQueueValue memory previousItem) {\n        uint256 index = getUint(keccak256(abi.encodePacked(_namespace, \".index\", _value.receiver, _value.validatorId)));\n        if (index > 0) {\n            uint256 previousIndex = getUint(keccak256(abi.encodePacked(_namespace, \".prev\", index)));\n            previousItem = _unpackItem(getUint(keccak256(abi.encodePacked(_namespace, \".item\", previousIndex))));\n        }\n    }\n\n    /// @notice Finds an item index in a queue and returns the next item\n    /// @param _namespace defines the queue to be used\n    /// @param _value the deposit queue value\n    function getNextItem(bytes32 _namespace, DepositQueueValue memory _value) external view returns (DepositQueueValue memory nextItem) {\n        uint256 index = getUint(keccak256(abi.encodePacked(_namespace, \".index\", _value.receiver, _value.validatorId)));\n        if (index > 0) {\n            uint256 nextIndex = getUint(keccak256(abi.encodePacked(_namespace, \".next\", index)));\n            nextItem = _unpackItem(getUint(keccak256(abi.encodePacked(_namespace, \".item\", nextIndex))));\n        }\n    }\n\n    /// @notice Add an item to the end of the list. Requires that the item does not exist in the list\n    /// @param _namespace defines the queue to be used\n    /// @param _item the deposit queue item to be added\n    function enqueueItem(bytes32 _namespace, DepositQueueValue memory _item) virtual override external onlyLatestContract(\"linkedListStorage\", address(this)) onlyLatestNetworkContract {\n        _enqueueItem(_namespace, _item);\n    }\n\n    /// @notice Internal function created to allow testing enqueueItem\n    /// @param _namespace defines the queue to be used\n    /// @param _item the deposit queue value\n    function _enqueueItem(bytes32 _namespace, DepositQueueValue memory _item) internal {\n        require(getUint(keccak256(abi.encodePacked(_namespace, \".index\", _item.receiver, _item.validatorId))) == 0, \"Item already exists in queue\");\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        uint256 endIndex = uint64(data >> endOffset);\n        uint256 newIndex = endIndex + 1;\n\n        if (endIndex > 0) {\n            setUint(keccak256(abi.encodePacked(_namespace, \".next\", endIndex)), newIndex);\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", newIndex)), endIndex);\n        } else {\n            // clear the 64 bits used to stored the 'start' pointer\n            data &= ~(uint256(ones64Bits) << startOffset);\n            data |= newIndex << startOffset;\n        }\n\n        setUint(keccak256(abi.encodePacked(_namespace, \".item\", newIndex)), _packItem(_item));\n        setUint(keccak256(abi.encodePacked(_namespace, \".index\", _item.receiver, _item.validatorId)), newIndex);\n        // clear the 64 bits used to stored the 'end' pointer\n        data &= ~(uint256(ones64Bits) << endOffset);\n        data |= newIndex << endOffset;\n\n        // Update the length of the queue\n        uint256 currentLength = uint64(data >> lengthOffset);\n        // clear the 64 bits used to stored the 'length' information\n        data &= ~(uint256(ones64Bits) << lengthOffset);\n        data |= (currentLength + 1) << lengthOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".data\")), data);\n    }\n\n    /// @notice Remove an item from the start of a queue and return it. Requires that the queue is not empty\n    /// @param _namespace defines the queue to be used\n    function dequeueItem(bytes32 _namespace) public virtual override onlyLatestContract(\"linkedListStorage\", address(this)) onlyLatestNetworkContract returns (DepositQueueValue memory item) {\n        return _dequeueItem(_namespace);\n    }\n\n    /// @notice Returns the item from the start of the queue without removing it\n    function peekItem(bytes32 _namespace) public virtual override view returns (DepositQueueValue memory item) {\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        uint256 length = uint64(data >> lengthOffset);\n        require(length > 0, \"Queue can't be empty\");\n        uint256 start = uint64(data >> startOffset);\n        uint256 packedItem = getUint(keccak256(abi.encodePacked(_namespace, \".item\", start)));\n        item = _unpackItem(packedItem);\n    }\n\n    /// @notice Remove an item from the start of a queue and return it. Requires that the queue is not empty\n    /// @param _namespace defines the queue to be used\n    function _dequeueItem(bytes32 _namespace) internal returns (DepositQueueValue memory item) {\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        uint256 length = uint64(data >> lengthOffset);\n        require(length > 0, \"Queue can't be empty\");\n        uint256 start = uint64(data >> startOffset);\n        uint256 packedItem = getUint(keccak256(abi.encodePacked(_namespace, \".item\", start)));\n        item = _unpackItem(packedItem);\n\n        uint256 nextItem = getUint(keccak256(abi.encodePacked(_namespace, \".next\", start)));\n        // clear the 64 bits used to stored the 'start' pointer\n        data &= ~(uint256(ones64Bits) << startOffset);\n        data |= nextItem << startOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".index\", item.receiver, item.validatorId)), 0);\n\n        if (nextItem > 0) {\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", nextItem)), 0);\n        } else {\n            // zero the 64 bits storing the 'end' pointer\n            data &= ~(uint256(ones64Bits) << endOffset);\n        }\n\n        // Update the length of the queue\n        // clear the 64 bits used to stored the 'length' information\n        data &= ~(uint256(ones64Bits) << lengthOffset);\n        data |= (length - 1) << lengthOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".data\")), data);\n\n        return item;\n    }\n\n    /// @notice Removes an item from a queue. Requires that the item exists in the queue\n    /// @param _namespace defines the queue to be used\n    /// @param _key to be removed from the queue\n    function removeItem(bytes32 _namespace, DepositQueueKey memory _key) public virtual override onlyLatestContract(\"linkedListStorage\", address(this)) onlyLatestNetworkContract {\n        _removeItem(_namespace, _key);\n    }\n\n    /// @notice Internal function to remove an item from a queue. Requires that the item exists in the queue\n    /// @param _namespace defines the queue to be used\n    /// @param _key to be removed from the queue\n    function _removeItem(bytes32 _namespace, DepositQueueKey memory _key) internal {\n        uint256 index = getUint(keccak256(abi.encodePacked(_namespace, \".index\", _key.receiver, _key.validatorId)));\n        uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n        require(index > 0, \"Item does not exist in queue\");\n\n        uint256 prevIndex = getUint(keccak256(abi.encodePacked(_namespace, \".prev\", index)));\n        uint256 nextIndex = getUint(keccak256(abi.encodePacked(_namespace, \".next\", index)));\n        if (prevIndex > 0) {\n            // Not the first item\n            setUint(keccak256(abi.encodePacked(_namespace, \".next\", prevIndex)), nextIndex);\n        } else {\n            // First item\n            // clear the 64 bits used to stored the 'start' pointer\n            data &= ~(uint256(ones64Bits) << startOffset);\n            data |= nextIndex << startOffset;\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", nextIndex)), 0);\n        }\n\n        if (nextIndex > 0) {\n            // Not the last item\n            setUint(keccak256(abi.encodePacked(_namespace, \".prev\", nextIndex)), prevIndex);\n        } else {\n            // Last item\n            // clear the 64 bits used to stored the 'end' pointer\n            data &= ~(uint256(ones64Bits) << endOffset);\n            data |= prevIndex << endOffset;\n        }\n\n        setUint(keccak256(abi.encodePacked(_namespace, \".index\", _key.receiver, _key.validatorId)), 0);\n        setUint(keccak256(abi.encodePacked(_namespace, \".next\", index)), 0);\n        setUint(keccak256(abi.encodePacked(_namespace, \".prev\", index)), 0);\n\n        // Update the length of the queue\n        uint256 currentLength = uint64(data >> lengthOffset);\n        // clear the 64 bits used to stored the 'length' information\n        data &= ~(uint256(ones64Bits) << lengthOffset);\n        data |= (currentLength - 1) << lengthOffset;\n        setUint(keccak256(abi.encodePacked(_namespace, \".data\")), data);\n    }\n\n    /// @notice packs a deposit queue value into a single uint256\n    /// @param _item the deposit queue item to be packed\n    function _packItem(DepositQueueValue memory _item) internal pure returns (uint256 packed) {\n        packed |= uint256(uint160(_item.receiver)) << receiverOffset;\n        packed |= uint256(_item.validatorId) << indexOffset;\n        packed |= uint256(_item.suppliedValue) << suppliedOffset;\n        packed |= uint256(_item.requestedValue);\n    }\n\n    /// @notice unpacks an uint256 value into a deposit queue struct \n    /// @param _packedValue the packed deposit queue value \n    function _unpackItem(uint256 _packedValue) internal pure returns (DepositQueueValue memory item) {\n        item.receiver = address(uint160(_packedValue >> receiverOffset));\n        item.validatorId = uint32(_packedValue >> indexOffset);\n        item.suppliedValue = uint32(_packedValue >> suppliedOffset);\n        item.requestedValue = uint32(_packedValue);\n    }\n\n    /// @notice Returns the supplied number of entries starting at the supplied index\n    /// @param _namespace The namespace of the linked list to scan\n    /// @param _start The index to start from, or 0 to start from the start of the first item in the list\n    /// @param _count The maximum number of items to return\n    function scan(bytes32 _namespace, uint256 _start, uint256 _count) override external view returns (DepositQueueValue[] memory entries, uint256 nextIndex) {\n        entries = new DepositQueueValue[](_count);\n        nextIndex = _start;\n        uint256 total = 0;\n\n        // If nextIndex is 0, begin scan at the start of the list\n        if (nextIndex == 0) {\n            uint256 data = getUint(keccak256(abi.encodePacked(_namespace, \".data\")));\n            uint256 start = uint64(data >> startOffset);\n            nextIndex = start;\n        }\n\n        while (total < _count && nextIndex != 0) {\n            uint256 packedValue = getUint(keccak256(abi.encodePacked(_namespace, \".item\", nextIndex)));\n            entries[total] = _unpackItem(packedValue);\n            nextIndex = getUint(keccak256(abi.encodePacked(_namespace, \".next\", nextIndex)));\n            total++;\n        }\n\n        assembly {\n            mstore(entries, total)\n        }\n\n        return (entries, nextIndex);\n    }\n}",
        "RocketDAOProtocolInterface.sol": "pragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolInterface {\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\n    function getBootstrapModeDisabled() external view returns (bool);\n    function bootstrapSettingMulti(string[] memory _settingContractNames, string[] memory _settingPaths, SettingType[] memory _types, bytes[] memory _values) external;\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function bootstrapSettingAddress(string memory _settingContractName, string memory _settingPath, address _value) external;\n    function bootstrapSettingAddressList(string memory _settingContractName, string memory _settingPath, address[] calldata _value) external;\n    function bootstrapSettingClaimers(uint256 _trustedNodePerc, uint256 _protocolPerc, uint256 _nodePerc) external;\n    function bootstrapSpendTreasury(string memory _invoiceID, address _recipientAddress, uint256 _amount) external;\n    function bootstrapTreasuryNewContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _startTime, uint256 _numPeriods) external;\n    function bootstrapTreasuryUpdateContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _numPeriods) external;\n    function bootstrapSecurityInvite(string memory _id, address _memberAddress) external;\n    function bootstrapSecurityKick(address _memberAddress) external;\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\n    function bootstrapEnableGovernance() external;\n}\n"
    }
}