{
    "vfp_id": "vfp_00289",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Frontrunning Considerations for Off-Chain Infrastructure",
            "description": "Off-chain systems must account for frontrunning risks:\n1. redeemCollateral uses user-provided max amount for fee calculation, which may exceed actual redemption, leading to overpayment.\n2. Setting _maxFeePercentage may cause reverts if base rate increases due to prior redemptions.\n3. Liquidation order affects redistributions, which can alter the health of other troves.\nIntegrators should consider using wrapper contracts to dynamically compute safe redemption amounts.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small Redemptions Do Not Increase Base Rate",
            "description": "The function CollateralRegistry._getUpdatedBaseRateFromRedemption calculates the base rate based on the fraction of BOLD redeemed. Due to integer division rounding down, very small redemptions (e.g., less than totalSupply / 1e18) result in zero base rate increase. This allows strategic splitting of redemptions to avoid fees, though at higher gas cost. For example, with a 10B total supply, redemptions below 1e-8 BOLD have no effect. Liquity acknowledges this but considers the amounts negligible and not economically viable to exploit.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry._getUpdatedBaseRateFromRedemption"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Backed Tokens Can Be Redeemed Unproportionally",
            "description": "The `redeemCollateral` function in `CollateralRegistry` can redeem disproportionately from a single branch when not all branches are fully backed, violating fairness assumptions.\n\nThe cause is that the redemption logic does not cap the amount by total unbacked debt when some branches are partially backed.\n\nAn attacker could redeem large amounts from a single branch before it becomes fully backed, gaining an unfair advantage over proportional redemption.\n\nUnfair distribution of collateral during redemptions, potentially leading to economic imbalance between branches.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        }
    ],
    "affected_files": {
        "CollateralRegistry.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Dependencies/Constants.sol\";\nimport \"./Dependencies/LiquityMath.sol\";\n\nimport \"./Interfaces/ICollateralRegistry.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract CollateralRegistry is ICollateralRegistry {\n    // mapping from Collateral token address to the corresponding TroveManagers\n    //mapping(address => address) troveManagers;\n    // See: https://github.com/ethereum/solidity/issues/12587\n    uint256 public immutable totalCollaterals;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n    IERC20Metadata internal immutable token4;\n    IERC20Metadata internal immutable token5;\n    IERC20Metadata internal immutable token6;\n    IERC20Metadata internal immutable token7;\n    IERC20Metadata internal immutable token8;\n    IERC20Metadata internal immutable token9;\n\n    ITroveManager internal immutable troveManager0;\n    ITroveManager internal immutable troveManager1;\n    ITroveManager internal immutable troveManager2;\n    ITroveManager internal immutable troveManager3;\n    ITroveManager internal immutable troveManager4;\n    ITroveManager internal immutable troveManager5;\n    ITroveManager internal immutable troveManager6;\n    ITroveManager internal immutable troveManager7;\n    ITroveManager internal immutable troveManager8;\n    ITroveManager internal immutable troveManager9;\n\n    IBoldToken public immutable boldToken;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new Bold issuance)\n    uint256 public lastFeeOperationTime = block.timestamp;\n\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n\n    constructor(IBoldToken _boldToken, IERC20Metadata[] memory _tokens, ITroveManager[] memory _troveManagers) {\n        uint256 numTokens = _tokens.length;\n        require(numTokens > 0, \"Collateral list cannot be empty\");\n        require(numTokens <= 10, \"Collateral list too long\");\n        totalCollaterals = numTokens;\n\n        boldToken = _boldToken;\n\n        token0 = _tokens[0];\n        token1 = numTokens > 1 ? _tokens[1] : IERC20Metadata(address(0));\n        token2 = numTokens > 2 ? _tokens[2] : IERC20Metadata(address(0));\n        token3 = numTokens > 3 ? _tokens[3] : IERC20Metadata(address(0));\n        token4 = numTokens > 4 ? _tokens[4] : IERC20Metadata(address(0));\n        token5 = numTokens > 5 ? _tokens[5] : IERC20Metadata(address(0));\n        token6 = numTokens > 6 ? _tokens[6] : IERC20Metadata(address(0));\n        token7 = numTokens > 7 ? _tokens[7] : IERC20Metadata(address(0));\n        token8 = numTokens > 8 ? _tokens[8] : IERC20Metadata(address(0));\n        token9 = numTokens > 9 ? _tokens[9] : IERC20Metadata(address(0));\n\n        troveManager0 = _troveManagers[0];\n        troveManager1 = numTokens > 1 ? _troveManagers[1] : ITroveManager(address(0));\n        troveManager2 = numTokens > 2 ? _troveManagers[2] : ITroveManager(address(0));\n        troveManager3 = numTokens > 3 ? _troveManagers[3] : ITroveManager(address(0));\n        troveManager4 = numTokens > 4 ? _troveManagers[4] : ITroveManager(address(0));\n        troveManager5 = numTokens > 5 ? _troveManagers[5] : ITroveManager(address(0));\n        troveManager6 = numTokens > 6 ? _troveManagers[6] : ITroveManager(address(0));\n        troveManager7 = numTokens > 7 ? _troveManagers[7] : ITroveManager(address(0));\n        troveManager8 = numTokens > 8 ? _troveManagers[8] : ITroveManager(address(0));\n        troveManager9 = numTokens > 9 ? _troveManagers[9] : ITroveManager(address(0));\n\n        // Initialize the baseRate state variable\n        baseRate = INITIAL_BASE_RATE;\n        emit BaseRateUpdated(INITIAL_BASE_RATE);\n    }\n\n    struct RedemptionTotals {\n        uint256 numCollaterals;\n        uint256 boldSupplyAtStart;\n        uint256 unbacked;\n        uint256 redeemedAmount;\n    }\n\n    function redeemCollateral(uint256 _boldAmount, uint256 _maxIterationsPerCollateral, uint256 _maxFeePercentage)\n        external\n    {\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAmountGreaterThanZero(_boldAmount);\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        RedemptionTotals memory totals;\n\n        totals.numCollaterals = totalCollaterals;\n        uint256[] memory unbackedPortions = new uint256[](totals.numCollaterals);\n        uint256[] memory prices = new uint256[](totals.numCollaterals);\n\n        totals.boldSupplyAtStart = boldToken.totalSupply();\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total Bold supply value, from before it was reduced by the redemption.\n        // We only compute it here, and update it at the end,\n        // because the final redeemed amount may be less than the requested amount\n        // Redeemers should take this into account in order to request the optimal amount to not overpay\n        uint256 redemptionRate =\n            _calcRedemptionRate(_getUpdatedBaseRateFromRedemption(_boldAmount, totals.boldSupplyAtStart));\n        require(redemptionRate <= _maxFeePercentage, \"CR: Fee exceeded provided maximum\");\n        // Implicit by the above and the _requireValidMaxFeePercentage checks\n        //require(newBaseRate < DECIMAL_PRECISION, \"CR: Fee would eat up all collateral\");\n\n        // Gather and accumulate unbacked portions\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            ITroveManager troveManager = getTroveManager(index);\n            (uint256 unbackedPortion, uint256 price, bool redeemable) =\n                troveManager.getUnbackedPortionPriceAndRedeemability();\n            prices[index] = price;\n            if (redeemable) {\n                totals.unbacked += unbackedPortion;\n                unbackedPortions[index] = unbackedPortion;\n            }\n        }\n\n        // Thereâ€™s an unlikely scenario where all the normally redeemable branches (i.e. having TCR > SCR) have 0 unbacked\n        // In that case, we redeem proportinally to branch size\n        if (totals.unbacked == 0) {\n            unbackedPortions = new uint256[](totals.numCollaterals);\n            for (uint256 index = 0; index < totals.numCollaterals; index++) {\n                ITroveManager troveManager = getTroveManager(index);\n                (,, bool redeemable) = troveManager.getUnbackedPortionPriceAndRedeemability();\n                if (redeemable) {\n                    uint256 unbackedPortion = troveManager.getEntireSystemDebt();\n                    totals.unbacked += unbackedPortion;\n                    unbackedPortions[index] = unbackedPortion;\n                }\n            }\n        }\n\n        // Compute redemption amount for each collateral and redeem against the corresponding TroveManager\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            //uint256 unbackedPortion = unbackedPortions[index];\n            if (unbackedPortions[index] > 0) {\n                uint256 redeemAmount = _boldAmount * unbackedPortions[index] / totals.unbacked;\n                if (redeemAmount > 0) {\n                    ITroveManager troveManager = getTroveManager(index);\n                    uint256 redeemedAmount = troveManager.redeemCollateral(\n                        msg.sender, redeemAmount, prices[index], redemptionRate, _maxIterationsPerCollateral\n                    );\n                    totals.redeemedAmount += redeemedAmount;\n                }\n            }\n        }\n\n        _updateBaseRateAndGetRedemptionRate(totals.redeemedAmount, totals.boldSupplyAtStart);\n\n        // Burn the total Bold that is cancelled with debt\n        if (totals.redeemedAmount > 0) {\n            boldToken.burn(msg.sender, totals.redeemedAmount);\n        }\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint256 timePassed = block.timestamp - lastFeeOperationTime;\n\n        if (timePassed >= ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint256) {\n        return (block.timestamp - lastFeeOperationTime) / ONE_MINUTE;\n    }\n\n    // Updates the `baseRate` state with math from `_getUpdatedBaseRateFromRedemption`\n    function _updateBaseRateAndGetRedemptionRate(uint256 _boldAmount, uint256 _totalBoldSupplyAtStart) internal {\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_boldAmount, _totalBoldSupplyAtStart);\n\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in `_getUpdatedBaseRateFromRedemption`\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    /*\n     * This function calculates the new baseRate in the following way:\n     * 1) decays the baseRate based on time passed since last redemption or Bold borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _getUpdatedBaseRateFromRedemption(uint256 _redeemAmount, uint256 _totalBoldSupply)\n        internal\n        view\n        returns (uint256)\n    {\n        // decay the base rate\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        // get the fraction of total supply that was redeemed\n        uint256 redeemedBoldFraction = _redeemAmount * DECIMAL_PRECISION / _totalBoldSupply;\n\n        uint256 newBaseRate = decayedBaseRate + redeemedBoldFraction / REDEMPTION_BETA;\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n\n        return newBaseRate;\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint256 decayFactor = LiquityMath._decPow(REDEMPTION_MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate * decayFactor / DECIMAL_PRECISION;\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal pure returns (uint256) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR + _baseRate,\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _amount) internal pure returns (uint256) {\n        uint256 redemptionFee = _redemptionRate * _amount / DECIMAL_PRECISION;\n        return redemptionFee;\n    }\n\n    // external redemption rate/fee getters\n\n    function getRedemptionRate() external view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionRate(newBaseRate);\n    }\n\n    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);\n    }\n\n    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view override returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionFee(_calcRedemptionRate(newBaseRate), _redeemAmount);\n    }\n\n    // getters\n\n    function getToken(uint256 _index) external view returns (IERC20Metadata) {\n        if (_index == 0) return token0;\n        else if (_index == 1) return token1;\n        else if (_index == 2) return token2;\n        else if (_index == 3) return token3;\n        else if (_index == 4) return token4;\n        else if (_index == 5) return token5;\n        else if (_index == 6) return token6;\n        else if (_index == 7) return token7;\n        else if (_index == 8) return token8;\n        else if (_index == 9) return token9;\n        else revert(\"Invalid index\");\n    }\n\n    function getTroveManager(uint256 _index) public view returns (ITroveManager) {\n        if (_index == 0) return troveManager0;\n        else if (_index == 1) return troveManager1;\n        else if (_index == 2) return troveManager2;\n        else if (_index == 3) return troveManager3;\n        else if (_index == 4) return troveManager4;\n        else if (_index == 5) return troveManager5;\n        else if (_index == 6) return troveManager6;\n        else if (_index == 7) return troveManager7;\n        else if (_index == 8) return troveManager8;\n        else if (_index == 9) return troveManager9;\n        else revert(\"Invalid index\");\n    }\n\n    // require functions\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        require(_amount > 0, \"CollateralRegistry: Amount must be greater than zero\");\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        // Confirm redeemer's balance is less than total Bold supply\n        assert(boldBalance <= _boldToken.totalSupply());\n        require(\n            boldBalance >= _amount,\n            \"CollateralRegistry: Requested redemption amount must be <= user's Bold token balance\"\n        );\n    }\n}\n"
    }
}