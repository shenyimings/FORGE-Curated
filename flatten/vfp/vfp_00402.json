{
    "vfp_id": "vfp_00402",
    "project_name": "ackee-blockchain-lido-vault-wrapper-report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Possible type mismatch during calling BORING_QUEUE.requestOnChainWithdraw",
            "description": "The GGVStrategy contract calls BORING_QUEUE.requestOnChainWithdraw with a parameter of type int256 by using ggvShares.toInt256(), while the target function expects a uint128 amountOfShares. This type mismatch constitutes a data validation issue that could lead to transaction failures or undefined behavior during ABI encoding, especially if the receiving contract strictly enforces type correctness. The root cause is improper type conversion in the calling code, which assumes that a uint256 can be safely cast to int256 and then interpreted as uint128, which is not guaranteed. An attacker could potentially exploit this by triggering the function with edge-case values that cause silent truncation or misinterpretation of the amount, leading to incorrect withdrawal requests. The impact is limited to transaction failure or incorrect processing, not direct fund loss, hence classified as a Warning.\n",
            "severity": "Informational",
            "location": [
                "GGVStrategy.sol::requestExitByWsteth#199"
            ],
            "files": [
                "vaults-wrapper/src/strategy/GGVStrategy.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Unsafe transfer in recoverERC20 function",
            "description": "The recoverERC20 function in the GGVStrategy contract uses low-level calls to IERC20.transfer without checking the return value, which is a critical data validation flaw. Many ERC20 tokens, such as USDT, do not return a boolean on transfer, and others may return false instead of reverting on failure. By using callForwarder.doCall without verifying the success of the transfer, the function may appear to succeed while the tokens remain stuck in the call forwarder contract. The root cause is the absence of safe transfer practices, relying on raw calls instead of using the SafeERC20 library. An attacker could exploit this by sending a non-compliant token to the contract and then attempting recovery, leading to a silent failure where the user believes tokens were recovered but they were not. This could result in loss of recovered funds and misreporting of asset movement, hence classified as a Warning.\n",
            "severity": "Informational",
            "location": [
                "GGVStrategy.sol::recoverERC20#366"
            ],
            "files": [
                "vaults-wrapper/src/strategy/GGVStrategy.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Misleading error name in GGVStrategy",
            "description": "The error named NothingToExit in the GGVStrategy contract is misleading because it is triggered when a user attempts to withdraw more tokens than they have requested, not when there is literally nothing to exit. This is a code quality issue that can confuse developers and auditors, leading to incorrect assumptions about the control flow. The root cause is poor naming that does not reflect the actual condition being checked. While this does not introduce a direct security vulnerability, it can lead to maintenance errors or incorrect handling in integrations that rely on error messages for logic. There is no direct exploitation path, but the impact is on code clarity and long-term maintainability, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "GGVStrategy.sol::requestExitByWsteth#190"
            ],
            "files": [
                "vaults-wrapper/src/strategy/GGVStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "GGVStrategy.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {\n    AccessControlEnumerableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {StvStETHPool} from \"src/StvStETHPool.sol\";\nimport {WithdrawalQueue} from \"src/WithdrawalQueue.sol\";\nimport {IStrategyCallForwarder} from \"src/interfaces/IStrategyCallForwarder.sol\";\nimport {IBoringOnChainQueue} from \"src/interfaces/ggv/IBoringOnChainQueue.sol\";\nimport {ITellerWithMultiAssetSupport} from \"src/interfaces/ggv/ITellerWithMultiAssetSupport.sol\";\nimport {StrategyCallForwarderRegistry} from \"src/strategy/StrategyCallForwarderRegistry.sol\";\nimport {FeaturePausable} from \"src/utils/FeaturePausable.sol\";\n\nimport {IStrategy} from \"src/interfaces/IStrategy.sol\";\nimport {IWstETH} from \"src/interfaces/core/IWstETH.sol\";\n\ncontract GGVStrategy is IStrategy, AccessControlEnumerableUpgradeable, FeaturePausable, StrategyCallForwarderRegistry {\n    using SafeCast for uint256;\n\n    StvStETHPool private immutable POOL_;\n    IWstETH public immutable WSTETH;\n\n    ITellerWithMultiAssetSupport public immutable TELLER;\n    IBoringOnChainQueue public immutable BORING_QUEUE;\n\n    // ACL\n    bytes32 public constant SUPPLY_FEATURE = keccak256(\"SUPPLY_FEATURE\");\n    bytes32 public constant SUPPLY_PAUSE_ROLE = keccak256(\"SUPPLY_PAUSE_ROLE\");\n    bytes32 public constant SUPPLY_RESUME_ROLE = keccak256(\"SUPPLY_RESUME_ROLE\");\n\n    struct GGVParamsSupply {\n        uint256 minimumMint;\n    }\n\n    struct GGVParamsRequestExit {\n        uint16 discount;\n        uint24 secondsToDeadline;\n    }\n\n    event GGVDeposited(\n        address indexed recipient,\n        uint256 wstethAmount,\n        uint256 ggvShares,\n        address indexed referralAddress,\n        bytes paramsSupply\n    );\n    event GGVWithdrawalRequested(\n        address indexed recipient, bytes32 requestId, uint256 ggvShares, bytes paramsRequestExit\n    );\n\n    error ZeroArgument(string name);\n    error InvalidSender();\n    error InvalidWstethAmount();\n    error InsufficientWsteth();\n    error NotImplemented();\n\n    constructor(\n        bytes32 _strategyId,\n        address _strategyCallForwarderImpl,\n        address _pool,\n        address _teller,\n        address _boringQueue\n    ) StrategyCallForwarderRegistry(_strategyId, _strategyCallForwarderImpl) {\n        POOL_ = StvStETHPool(payable(_pool));\n        WSTETH = IWstETH(POOL_.WSTETH());\n\n        TELLER = ITellerWithMultiAssetSupport(_teller);\n        BORING_QUEUE = IBoringOnChainQueue(_boringQueue);\n\n        _disableInitializers();\n        _pauseFeature(SUPPLY_FEATURE);\n    }\n\n    /**\n     * @notice Initialize the contract storage explicitly\n     * @param _admin Admin address that can change every role\n     * @param _supplyPauser Address that can pause supply (zero for none)\n     * @dev Reverts if `_admin` equals to `address(0)`\n     */\n    function initialize(address _admin, address _supplyPauser) external initializer {\n        if (_admin == address(0)) revert ZeroArgument(\"_admin\");\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        if (address(0) != _supplyPauser) {\n            _grantRole(SUPPLY_PAUSE_ROLE, _supplyPauser);\n        }\n    }\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function POOL() external view returns (address) {\n        return address(POOL_);\n    }\n\n    // =================================================================================\n    // PAUSE / RESUME\n    // =================================================================================\n\n    /**\n     * @notice Pause supply\n     */\n    function pauseSupply() external {\n        _checkRole(SUPPLY_PAUSE_ROLE, msg.sender);\n        _pauseFeature(SUPPLY_FEATURE);\n    }\n\n    /**\n     * @notice Resume supply\n     */\n    function resumeSupply() external {\n        _checkRole(SUPPLY_RESUME_ROLE, msg.sender);\n        _resumeFeature(SUPPLY_FEATURE);\n    }\n\n    // =================================================================================\n    // SUPPLY\n    // =================================================================================\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function supply(address _referral, uint256 _wstethToMint, bytes calldata _params)\n        external\n        payable\n        returns (uint256 stv)\n    {\n        _checkFeatureNotPaused(SUPPLY_FEATURE);\n\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n\n        if (msg.value > 0) {\n            stv = POOL_.depositETH{value: msg.value}(address(callForwarder), _referral);\n        }\n\n        callForwarder.doCall(address(POOL_), abi.encodeWithSelector(POOL_.mintWsteth.selector, _wstethToMint));\n        callForwarder.doCall(\n            address(WSTETH), abi.encodeWithSelector(WSTETH.approve.selector, TELLER.vault(), _wstethToMint)\n        );\n\n        GGVParamsSupply memory params = abi.decode(_params, (GGVParamsSupply));\n\n        bytes memory data = callForwarder.doCall(\n            address(TELLER),\n            abi.encodeWithSelector(\n                TELLER.deposit.selector, address(WSTETH), _wstethToMint, params.minimumMint, _referral\n            )\n        );\n        uint256 ggvShares = abi.decode(data, (uint256));\n\n        emit StrategySupplied(msg.sender, _referral, msg.value, stv, _wstethToMint, _params);\n        emit GGVDeposited(msg.sender, _wstethToMint, ggvShares, _referral, _params);\n    }\n\n    // =================================================================================\n    // REQUEST EXIT FROM STRATEGY\n    // =================================================================================\n\n    /**\n     * @notice Previews the amount of wstETH that can be withdrawn by a given amount of GGV shares\n     * @param _ggvShares The amount of GGV shares to preview the amount of wstETH for\n     * @param _params The parameters for the withdrawal\n     * @return wsteth The amount of wstETH that can be withdrawn\n     */\n    function previewWstethByGGV(uint256 _ggvShares, bytes calldata _params) public view returns (uint256 wsteth) {\n        GGVParamsRequestExit memory params = abi.decode(_params, (GGVParamsRequestExit));\n        wsteth = BORING_QUEUE.previewAssetsOut(address(WSTETH), _ggvShares.toUint128(), params.discount);\n    }\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function requestExitByWsteth(uint256 _wsteth, bytes calldata _params) external returns (bytes32 requestId) {\n        if (_wsteth == 0) revert ZeroArgument(\"_wsteth\");\n\n        GGVParamsRequestExit memory params = abi.decode(_params, (GGVParamsRequestExit));\n\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n        IERC20 boringVault = IERC20(TELLER.vault());\n\n        // Calculate how much wsteth we'll get from total GGV shares\n        uint256 totalGGV = boringVault.balanceOf(address(callForwarder));\n        uint256 totalWstethFromGGV = previewWstethByGGV(totalGGV, _params);\n        if (totalWstethFromGGV == 0) revert InvalidWstethAmount();\n        if (_wsteth > totalWstethFromGGV) revert InsufficientWsteth();\n\n        // Approve GGV shares\n        uint256 ggvShares = Math.mulDiv(totalGGV, _wsteth, totalWstethFromGGV, Math.Rounding.Ceil);\n        callForwarder.doCall(\n            address(boringVault), abi.encodeWithSelector(boringVault.approve.selector, address(BORING_QUEUE), ggvShares)\n        );\n\n        // Withdrawal request from GGV\n        bytes memory data = callForwarder.doCall(\n            address(BORING_QUEUE),\n            abi.encodeWithSelector(\n                BORING_QUEUE.requestOnChainWithdraw.selector,\n                address(WSTETH),\n                ggvShares.toUint128(),\n                params.discount,\n                params.secondsToDeadline\n            )\n        );\n        requestId = abi.decode(data, (bytes32));\n\n        emit StrategyExitRequested(msg.sender, requestId, _wsteth, _params);\n        emit GGVWithdrawalRequested(msg.sender, requestId, ggvShares, _params);\n    }\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function finalizeRequestExit(\n        bytes32 /*_requestId*/\n    )\n        external\n        pure\n    {\n        // GGV does not provide a way to check request status, so we cannot verify if the request\n        // was actually finalized in GGV Queue. Additionally, GGV allows multiple withdrawal requests,\n        // so it's possible to have request->finalize->request sequence where 2 unfinalised requests\n        // exist in GGV at the same time.\n        revert NotImplemented();\n    }\n\n    // =================================================================================\n    // CANCEL / REPLACE GGV REQUEST\n    // =================================================================================\n\n    /**\n     * @notice Cancels a GGV withdrawal request\n     * @param _request The request to cancel\n     */\n    function cancelGGVOnChainWithdraw(IBoringOnChainQueue.OnChainWithdraw memory _request) external {\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n        if (address(callForwarder) != _request.user) revert InvalidSender();\n\n        callForwarder.doCall(\n            address(BORING_QUEUE), abi.encodeWithSelector(BORING_QUEUE.cancelOnChainWithdraw.selector, _request)\n        );\n    }\n\n    /**\n     * @notice Replaces a withdrawal request\n     * @param request The request to replace\n     * @param discount The discount to use\n     * @param secondsToDeadline The deadline to use\n     * @return oldRequestId The old request id\n     * @return newRequestId The new request id\n     */\n    function replaceGGVOnChainWithdraw(\n        IBoringOnChainQueue.OnChainWithdraw memory request,\n        uint16 discount,\n        uint24 secondsToDeadline\n    ) external returns (bytes32 oldRequestId, bytes32 newRequestId) {\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n        if (address(callForwarder) != request.user) revert InvalidSender();\n\n        bytes memory data = callForwarder.doCall(\n            address(BORING_QUEUE),\n            abi.encodeWithSelector(BORING_QUEUE.replaceOnChainWithdraw.selector, request, discount, secondsToDeadline)\n        );\n        (oldRequestId, newRequestId) = abi.decode(data, (bytes32, bytes32));\n    }\n\n    // =================================================================================\n    // HELPERS\n    // =================================================================================\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function mintedStethSharesOf(address _user) external view returns (uint256 mintedStethShares) {\n        IStrategyCallForwarder callForwarder = getStrategyCallForwarderAddress(_user);\n        mintedStethShares = POOL_.mintedStethSharesOf(address(callForwarder));\n    }\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function remainingMintingCapacitySharesOf(address _user, uint256 _ethToFund)\n        external\n        view\n        returns (uint256 stethShares)\n    {\n        IStrategyCallForwarder callForwarder = getStrategyCallForwarderAddress(_user);\n        stethShares = POOL_.remainingMintingCapacitySharesOf(address(callForwarder), _ethToFund);\n    }\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function wstethOf(address _user) external view returns (uint256 wsteth) {\n        IStrategyCallForwarder callForwarder = getStrategyCallForwarderAddress(_user);\n        wsteth = WSTETH.balanceOf(address(callForwarder));\n    }\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function stvOf(address _user) external view returns (uint256 stv) {\n        IStrategyCallForwarder callForwarder = getStrategyCallForwarderAddress(_user);\n        stv = POOL_.balanceOf(address(callForwarder));\n    }\n\n    /**\n     * @notice Returns the amount of GGV shares of a user\n     * @param _user The user to get the GGV shares for\n     * @return ggvShares The amount of GGV shares\n     */\n    function ggvOf(address _user) external view returns (uint256 ggvShares) {\n        IStrategyCallForwarder callForwarder = getStrategyCallForwarderAddress(_user);\n        ggvShares = IERC20(TELLER.vault()).balanceOf(address(callForwarder));\n    }\n\n    // =================================================================================\n    // REQUEST WITHDRAWAL FROM POOL\n    // =================================================================================\n\n    /**\n     * @inheritdoc IStrategy\n     */\n    function requestWithdrawalFromPool(address _recipient, uint256 _stvToWithdraw, uint256 _stethSharesToRebalance)\n        external\n        returns (uint256 requestId)\n    {\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n\n        // request withdrawal from pool\n        bytes memory withdrawalData = callForwarder.doCall(\n            address(POOL_.WITHDRAWAL_QUEUE()),\n            abi.encodeWithSelector(\n                WithdrawalQueue.requestWithdrawal.selector, _recipient, _stvToWithdraw, _stethSharesToRebalance\n            )\n        );\n        requestId = abi.decode(withdrawalData, (uint256));\n    }\n\n    /**\n     * @notice Burns wstETH to reduce the user's minted stETH obligation\n     * @param _wstethToBurn The amount of wstETH to burn\n     */\n    function burnWsteth(uint256 _wstethToBurn) external {\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n        callForwarder.doCall(\n            address(WSTETH), abi.encodeWithSelector(WSTETH.approve.selector, address(POOL_), _wstethToBurn)\n        );\n        callForwarder.doCall(address(POOL_), abi.encodeWithSelector(StvStETHPool.burnWsteth.selector, _wstethToBurn));\n    }\n\n    /**\n     * @notice Transfers ERC20 tokens from the call forwarder\n     * @param _token The token to recover\n     * @param _recipient The recipient of the tokens\n     * @param _amount The amount of tokens to recover\n     */\n    function safeTransferERC20(address _token, address _recipient, uint256 _amount) external {\n        if (_token == address(0)) revert ZeroArgument(\"_token\");\n        if (_recipient == address(0)) revert ZeroArgument(\"_recipient\");\n        if (_amount == 0) revert ZeroArgument(\"_amount\");\n\n        IStrategyCallForwarder callForwarder = _getOrCreateCallForwarder(msg.sender);\n        callForwarder.safeTransferERC20(_token, _recipient, _amount);\n    }\n}\n"
    }
}