{
    "vfp_id": "vfp_00402",
    "project_name": "Bridged USDC Support Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Custom Gas Tokens Can Get Stuck In `HubPool`",
            "description": "The `ZkStack_CustomGasToken_Adapter` contract pulls custom gas tokens from the funder via the `relayTokens` function when bridging tokens to a ZK Stack chain. However, when using the CCTP bridge, custom gas tokens are not required for the transaction. Despite this, the function still pulls the gas tokens from the funder during the delegatecall from `HubPool`, causing these tokens to become stuck in the `HubPool` contract with no mechanism to retrieve them.\n\nThe root cause is the unconditional execution of `_pullCustomGas` before checking whether the custom gas token is actually needed for the selected bridge route (e.g., CCTP does not require it). This leads to unnecessary token transfers in cases where they serve no purpose.\n\nAn attacker could potentially exploit this by initiating multiple bridging transactions using the CCTP route, leading to accumulation of stuck gas tokens in `HubPool`, effectively locking user funds indefinitely.\n\nThe impact is loss of custom gas tokens for users, reducing capital efficiency and potentially disrupting gas token economics on affected chains. While not catastrophic, it represents a loss of user funds and reduced system reliability.\n",
            "severity": "Low",
            "location": [
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#186",
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#299",
                "ZkStack_Adapter.sol::txBaseCost#162",
                "ZkStack_CustomGasToken_Adapter.sol::sharedBridge#187"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Missing and Misleading Documentation",
            "description": "Several parts of the codebase contain outdated or incorrect comments that do not reflect the actual logic, particularly around edge cases involving USDC bridging when `address(usdcToken) == address(0)`. For example, comments in `ZkStack_Adapter.sol` and `ZkStack_CustomGasToken_Adapter.sol` fail to account for this condition, which can mislead developers and auditors about the expected behavior.\n\nThe cause is insufficient maintenance of documentation during implementation changes, especially when new bridging routes like CCTP were introduced. Additionally, the mutual exclusivity of `zkUSDCBridgeDisabled` and `cctpUSDCBridgeDisabled` flags is enforced in code but not documented, increasing the risk of incorrect usage.\n\nWhile this cannot be directly exploited for financial gain, it increases the likelihood of developer errors during integration or future upgrades, especially when relying on comments instead of code.\n\nThe impact is reduced code maintainability, increased risk of integration bugs, and potential for future vulnerabilities due to misunderstanding of system invariants. This affects long-term security and developer experience.\n",
            "severity": "Informational",
            "location": [
                "ZkStack_Adapter.sol#203",
                "ZkStack_CustomGasToken_Adapter.sol#247",
                "ZkStack_Adapter.sol#107-109",
                "ZkStack_CustomGasToken_Adapter.sol#130-132",
                "ZkSync_SpokePool.sol#74-76"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_Adapter.sol",
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Relay Tokens From L1 Emits Empty Transaction Hash When Relaying USDC Through CCTP",
            "description": "The `relayTokens` functions in both `ZkStack_Adapter.sol` and `ZkStack_CustomGasToken_Adapter.sol` define a `txHash` variable intended to capture the transaction hash from the `BRIDGE_HUB`. However, when CCTP is used, the `_transferUsdc` function bypasses the `BRIDGE_HUB` and does not return a transaction hash. As a result, the `ZkStackMessageRelayed` event is emitted with an empty `txHash`, which can confuse users and indexing services.\n\nThe root cause is the assumption that all bridging paths return a valid transaction hash, without handling the CCTP path as a special case. The event is emitted unconditionally regardless of the bridging method used.\n\nOff-chain systems that rely on the `txHash` for tracking or verification may fail or produce incorrect results when processing these events, leading to broken user experiences or incorrect analytics.\n\nThe impact is degraded observability and potential confusion for users and third-party services. While not a direct security vulnerability, it undermines trust and usability of the system's event interface.\n",
            "severity": "Informational",
            "location": [
                "ZkStack_Adapter.sol::relayTokens#154",
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#178",
                "ZkStack_Adapter.sol::txHash#164",
                "ZkStack_CustomGasToken_Adapter.sol::txHash#189",
                "ZkStack_Adapter.sol::ZkStackMessageRelayed#222",
                "ZkStack_CustomGasToken_Adapter.sol::ZkStackMessageRelayed#266"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_Adapter.sol",
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "Restricted USDC Bridging via Shared Bridge with Custom Gas Token",
            "description": "In the `ZkStack_CustomGasToken_Adapter` contract, the `relayTokens` function incorrectly approves the `txBaseCost` amount of custom gas tokens to the `USDC_SHARED_BRIDGE` instead of the `sharedBridge` when bridging USDC via the shared bridge. This causes the bridging transaction to fail because the actual bridge (`sharedBridge`) lacks the necessary allowance.\n\nThe root cause is a logic error in the approval destination: the code uses `USDC_SHARED_BRIDGE` unconditionally, even when the `sharedBridge` is the one performing the transfer. This mismatch prevents the bridge from deducting gas fees.\n\nAn attacker could exploit this by initiating bridging transactions that appear valid but are guaranteed to revert, potentially disrupting user flows or causing front-running opportunities in dependent systems.\n\nThe impact is failed bridging transactions for USDC when using the shared bridge with custom gas tokens, leading to user fund lockups (temporarily) and degraded user experience. It breaks a core functionality path.\n",
            "severity": "High",
            "location": [
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#178",
                "ZkStack_CustomGasToken_Adapter.sol#230"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "ZkStack_CustomGasToken_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\nimport { CircleCCTPAdapter } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with a custom gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // The ZkSync bridgehub contract treats address(1) to represent ETH.\n    address private constant ETH_TOKEN_ADDRESS = address(1);\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://docs.zksync.io/build/developer-reference/l1-l2-interoperability#l1-to-l2-gas-estimation-for-transactions\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // USDC SharedBridge address, which is passed in on construction and used as the second bridge contract for USDC transfers.\n    address public immutable USDC_SHARED_BRIDGE;\n\n    // Custom gas token address, which is read from the BridgeHub at construction.\n    address public immutable CUSTOM_GAS_TOKEN;\n\n    // Custom gas token funder\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    // The maximum gas price a transaction sent to this adapter may have. This is set to prevent a block producer from setting an artificially high priority fee\n    // when calling a hub pool message relay, which would otherwise cause a large amount of the custom gas token to be sent to L2.\n    uint256 private immutable MAX_TX_GASPRICE;\n\n    event ZkStackMessageRelayed(bytes32 indexed canonicalTxHash);\n    error ETHGasTokenNotAllowed();\n    error TransactionFeeTooHigh();\n    error InvalidBridgeConfig();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _chainId The target ZkStack network's chain ID.\n     * @param _bridgeHub The bridge hub contract address for the ZkStack network.\n     * @param _circleUSDC Circle USDC address on L1. If not set to address(0), then either the USDCSharedBridge\n     * or CCTP token messenger must be set and will be used to bridge this token.\n     * @param _usdcSharedBridge Address of the second bridge contract for USDC corresponding to the configured ZkStack network.\n     * @param _cctpTokenMessenger address of the CCTP token messenger contract for the configured network.\n     * @param _recipientCircleDomainId Circle domain ID for the destination network.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     * @param _customGasTokenFunder Contract on L1 which funds bridge fees with amounts in the custom gas token.\n     * @param _l2GasLimit The maximum amount of gas this contract is willing to pay to execute a transaction on L2.\n     * @param _l1GasToL2GasPerPubDataLimit The exchange rate of l1 gas to l2 gas.\n     * @param _maxTxGasprice The maximum effective gas price any transaction sent to this adapter may have.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        IERC20 _circleUSDC,\n        address _usdcSharedBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit,\n        uint256 _maxTxGasprice\n    ) CircleCCTPAdapter(_circleUSDC, _cctpTokenMessenger, _recipientCircleDomainId) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        L2_GAS_LIMIT = _l2GasLimit;\n        MAX_TX_GASPRICE = _maxTxGasprice;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        address zero = address(0);\n        if (address(_circleUSDC) != zero) {\n            bool zkUSDCBridgeDisabled = _usdcSharedBridge == zero;\n            bool cctpUSDCBridgeDisabled = address(_cctpTokenMessenger) == zero;\n            // Bridged and Native USDC are mutually exclusive.\n            if (zkUSDCBridgeDisabled == cctpUSDCBridgeDisabled) {\n                revert InvalidBridgeConfig();\n            }\n        }\n        USDC_SHARED_BRIDGE = _usdcSharedBridge;\n        CUSTOM_GAS_TOKEN = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (CUSTOM_GAS_TOKEN == ETH_TOKEN_ADDRESS) {\n            revert ETHGasTokenNotAllowed();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        IERC20(CUSTOM_GAS_TOKEN).forceApprove(BRIDGE_HUB.sharedBridge(), txBaseCost);\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = BRIDGE_HUB.requestL2TransactionDirect(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkStackMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        address sharedBridge = BRIDGE_HUB.sharedBridge();\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost of custom gas tokens.\n            L1_WETH.withdraw(amount);\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            // Note: When bridging ETH with `L2TransactionRequestTwoBridgesOuter`, the second bridge must be 0 for the shared bridge call to not revert.\n            // https://github.com/matter-labs/era-contracts/blob/aafee035db892689df3f7afe4b89fd6467a39313/l1-contracts/contracts/bridge/L1SharedBridge.sol#L328\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: amount }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: amount,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, ETH_TOKEN_ADDRESS, 0)\n                })\n            );\n        } else if (l1Token == CUSTOM_GAS_TOKEN) {\n            // The chain's custom gas token.\n            IERC20(l1Token).forceApprove(sharedBridge, txBaseCost + amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost + amount,\n                    l2Contract: to,\n                    l2Value: amount,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else if (l1Token == address(usdcToken)) {\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                IERC20(CUSTOM_GAS_TOKEN).forceApprove(USDC_SHARED_BRIDGE, txBaseCost);\n                IERC20(l1Token).forceApprove(USDC_SHARED_BRIDGE, amount);\n                txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                    BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                        chainId: CHAIN_ID,\n                        mintValue: txBaseCost,\n                        l2Value: 0,\n                        l2GasLimit: L2_GAS_LIMIT,\n                        l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                        refundRecipient: L2_REFUND_ADDRESS,\n                        secondBridgeAddress: USDC_SHARED_BRIDGE,\n                        secondBridgeValue: 0,\n                        secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                    })\n                );\n            }\n        } else {\n            // An ERC20 that is not WETH and not the custom gas token.\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            IERC20(l1Token).forceApprove(sharedBridge, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkStackMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of tokens needed, pulls them from the funder, and\n     * returns the amount.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _pullCustomGas(uint256 l2GasLimit) internal returns (uint256) {\n        if (tx.gasprice > MAX_TX_GASPRICE) revert TransactionFeeTooHigh();\n        uint256 cost = BRIDGE_HUB.l2TransactionBaseCost(\n            CHAIN_ID,\n            tx.gasprice,\n            l2GasLimit,\n            L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT\n        );\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(IERC20(CUSTOM_GAS_TOKEN), cost);\n\n        return cost;\n    }\n}\n",
        "ZkStack_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\nimport { CircleCCTPAdapter } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with ETH as the gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // The ZkSync bridgehub contract treats address(1) to represent ETH.\n    address private constant ETH_TOKEN_ADDRESS = address(1);\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://docs.zksync.io/build/developer-reference/l1-l2-interoperability#l1-to-l2-gas-estimation-for-transactions\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // USDC SharedBridge address, which is passed in on construction and used as the second bridge contract for USDC transfers.\n    address public immutable USDC_SHARED_BRIDGE;\n\n    // The maximum gas price a transaction sent to this adapter may have. This is set to prevent a block producer from setting an artificially high priority fee\n    // when calling a hub pool message relay, which would otherwise cause a large amount of ETH to be sent to L2.\n    uint256 private immutable MAX_TX_GASPRICE;\n\n    event ZkStackMessageRelayed(bytes32 indexed canonicalTxHash);\n\n    error ETHGasTokenRequired();\n    error TransactionFeeTooHigh();\n    error InvalidBridgeConfig();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _chainId The target ZkStack network's chain ID.\n     * @param _bridgeHub The bridge hub contract address for the ZkStack network.\n     * @param _circleUSDC Circle USDC address on L1. If not set to address(0), then either the USDCSharedBridge\n     * or CCTP token messenger must be set and will be used to bridge this token.\n     * @param _usdcSharedBridge Address of the second bridge contract for USDC corresponding to the configured ZkStack network.\n     * @param _cctpTokenMessenger address of the CCTP token messenger contract for the configured network.\n     * @param _recipientCircleDomainId Circle domain ID for the destination network.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     * @param _l2GasLimit The maximum amount of gas this contract is willing to pay to execute a transaction on L2.\n     * @param _l1GasToL2GasPerPubDataLimit The exchange rate of l1 gas to l2 gas.\n     * @param _maxTxGasprice The maximum effective gas price any transaction sent to this adapter may have.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        IERC20 _circleUSDC,\n        address _usdcSharedBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit,\n        uint256 _maxTxGasprice\n    ) CircleCCTPAdapter(_circleUSDC, _cctpTokenMessenger, _recipientCircleDomainId) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        L2_GAS_LIMIT = _l2GasLimit;\n        MAX_TX_GASPRICE = _maxTxGasprice;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        address zero = address(0);\n        if (address(_circleUSDC) != zero) {\n            bool zkUSDCBridgeDisabled = _usdcSharedBridge == zero;\n            bool cctpUSDCBridgeDisabled = address(_cctpTokenMessenger) == zero;\n            // Bridged and Native USDC are mutually exclusive.\n            if (zkUSDCBridgeDisabled == cctpUSDCBridgeDisabled) {\n                revert InvalidBridgeConfig();\n            }\n        }\n        USDC_SHARED_BRIDGE = _usdcSharedBridge;\n        address gasToken = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (gasToken != ETH_TOKEN_ADDRESS) {\n            revert ETHGasTokenRequired();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = BRIDGE_HUB.requestL2TransactionDirect{ value: txBaseCost }(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkStackMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost.\n            L1_WETH.withdraw(amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect{ value: amount + txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost + amount,\n                    l2Contract: to,\n                    l2Value: amount,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else if (l1Token == address(usdcToken)) {\n            // Either use CCTP or the custom shared bridge when bridging USDC.\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                IERC20(l1Token).forceApprove(USDC_SHARED_BRIDGE, amount);\n                txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                    BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                        chainId: CHAIN_ID,\n                        mintValue: txBaseCost,\n                        l2Value: 0,\n                        l2GasLimit: L2_GAS_LIMIT,\n                        l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                        refundRecipient: L2_REFUND_ADDRESS,\n                        secondBridgeAddress: USDC_SHARED_BRIDGE,\n                        secondBridgeValue: 0,\n                        secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                    })\n                );\n            }\n        } else {\n            // An ERC20 that is not WETH.\n            address sharedBridge = BRIDGE_HUB.sharedBridge();\n            IERC20(l1Token).forceApprove(sharedBridge, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkStackMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of ETH needed and\n     * returns the amount.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _computeETHTxCost(uint256 l2GasLimit) internal view returns (uint256) {\n        if (tx.gasprice > MAX_TX_GASPRICE) revert TransactionFeeTooHigh();\n        return BRIDGE_HUB.l2TransactionBaseCost(CHAIN_ID, tx.gasprice, l2GasLimit, L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT);\n    }\n}\n"
    }
}