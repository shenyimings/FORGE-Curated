{
    "vfp_id": "vfp_00570",
    "project_name": "blocksec_astherus_202502-signed.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Potential reward loss due to COMPOUNDER role change",
            "description": "In the ass-cake-earn protocol, the RewardDistributionScheduler contract holds the COMPOUNDER role and is responsible for compounding CAKE rewards. If the role is changed before executing pending reward schedules, any unprocessed rewards will remain locked in the contract because only the COMPOUNDER can call compoundRewards(). The root cause is the lack of a pre-role-change check to ensure all rewards are processed. An attacker with role management privileges could maliciously change the role without settling pending rewards, leading to permanent loss of CAKE tokens. The impact is financial loss of undistributed rewards, affecting protocol incentives and user returns.\n",
            "severity": "Low",
            "location": [
                "RewardDistributionScheduler.sol::executeRewardSchedules#136"
            ],
            "files": [
                "5eb634c4ca7e1597e943c8c46e91683d76ac3ba9/ass-cake-earn-contract/src/RewardDistributionScheduler.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Precision loss in reward distribution results in permanently locked dust tokens",
            "description": "The RewardDistributionScheduler contract uses integer division to distribute rewards across epochs, which results in leftover token amounts (dust) due to truncation. The contract does not have a mechanism to handle or withdraw this dust, so it remains permanently locked. The root cause is the use of imprecise arithmetic without a remainder distribution strategy. An attacker cannot directly exploit this, but repeated operations accumulate locked funds over time. The impact is gradual loss of reward funds, reducing the efficiency and fairness of the reward system.\n",
            "severity": "Low",
            "location": [
                "RewardDistributionScheduler.sol::addRewardsSchedule"
            ],
            "files": [
                "5eb634c4ca7e1597e943c8c46e91683d76ac3ba9/ass-cake-earn-contract/src/RewardDistributionScheduler.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardDistributionScheduler.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"./interfaces/IRewardDistributionScheduler.sol\";\nimport \"./interfaces/IMinter.sol\";\n\ncontract RewardDistributionScheduler is\n  IRewardDistributionScheduler,\n  Initializable,\n  AccessControlUpgradeable,\n  PausableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  UUPSUpgradeable\n{\n  using SafeERC20 for IERC20;\n  // bot role\n  bytes32 public constant BOT = keccak256(\"BOT\");\n  // pause role\n  bytes32 public constant PAUSER = keccak256(\"PAUSER\");\n  // manager role\n  bytes32 public constant MANAGER = keccak256(\"MANAGER\");\n\n  /* ============ State Variables ============ */\n  // token address\n  IERC20 public token;\n  address public minter;\n  mapping(uint256 => mapping(IMinter.RewardsType => uint256)) public epochs;\n  //last time to distribute rewards\n  uint256 public lastDistributeRewardsTimestamp;\n\n  /* ============ Events ============ */\n  event RewardsScheduleAdded(\n    address sender,\n    IMinter.RewardsType rewardsType,\n    uint256 amount,\n    uint256 epochs,\n    uint256 startTime\n  );\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev initialize the contract\n   * @param _admin - Address of the admin\n   * @param _token - Address of the token\n   * @param _minter - Address of the minter\n   * @param _manager - Address of the manager\n   */\n  function initialize(\n    address _admin,\n    address _token,\n    address _minter,\n    address _manager,\n    address _pauser\n  ) external override initializer {\n    require(_admin != address(0), \"Invalid admin address\");\n    require(_token != address(0), \"Invalid token address\");\n    require(_minter != address(0), \"Invalid minter address\");\n    require(_manager != address(0), \"Invalid manager address\");\n    require(_pauser != address(0), \"Invalid pauser address\");\n\n    __Pausable_init();\n    __ReentrancyGuard_init();\n    __AccessControl_init();\n    __UUPSUpgradeable_init();\n    _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    _grantRole(MANAGER, _manager);\n    _grantRole(PAUSER, _pauser);\n\n    token = IERC20(_token);\n    minter = _minter;\n    lastDistributeRewardsTimestamp = (block.timestamp / 1 days) * 1 days;\n  }\n\n  // /* ============ External Functions ============ */\n\n  /**\n   * @dev addRewardsSchedule create a rewards plan\n   * @param _rewardsType - rewards type\n   * @param _amount - rewards amount\n   * @param _epochs - rewards epochs eg:7;14\n   * @param _startTime - rewards startTime timestamp\n   */\n  function addRewardsSchedule(\n    IMinter.RewardsType _rewardsType,\n    uint256 _amount,\n    uint256 _epochs,\n    uint256 _startTime\n  ) external override onlyRole(MANAGER) nonReentrant whenNotPaused {\n    require(_amount > 0, \"Invalid amount\");\n    require(_epochs > 0, \"Invalid epochs\");\n    require(_startTime > 0, \"Invalid startTime\");\n    //valid rewardsType\n    require(\n      IMinter.RewardsType.VeTokenRewards == _rewardsType ||\n        IMinter.RewardsType.VoteRewards == _rewardsType ||\n        IMinter.RewardsType.Donate == _rewardsType,\n      \"Invalid rewardsType\"\n    );\n\n    uint256 startTime = (_startTime / 1 days) * 1 days;\n\n    // The rewards have been distributed,\n    // and additional reward plans added later.\n    // if the start time is less than the emitted time. Need to reset the release time\n    if (startTime < lastDistributeRewardsTimestamp) {\n      lastDistributeRewardsTimestamp = startTime;\n    }\n\n    // transfer funds to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // average daily reward amount\n    uint256 amountPerDay = _amount / _epochs;\n    // spread rewards every day\n    for (uint256 i; i < _epochs; i++) {\n      // accumulation of different reward types\n      epochs[startTime + i * 1 days][_rewardsType] += amountPerDay;\n    }\n    // emit event\n    emit RewardsScheduleAdded(msg.sender, _rewardsType, _amount, _epochs, startTime);\n  }\n\n  /**\n   * @dev executeRewardSchedules per day\n   */\n  function executeRewardSchedules() external override onlyRole(BOT) nonReentrant whenNotPaused {\n    // flooring the current timestamp to 1 day\n    uint256 currentTimestamp = (block.timestamp / 1 days) * 1 days;\n    // get num. of reward types\n    uint max = (uint)(type(IMinter.RewardsType).max);\n    // rewards type array\n    IMinter.RewardsType[] memory rewardsTypes = new IMinter.RewardsType[](max);\n    // total rewards per type array\n    uint256[] memory totalRewards = new uint256[](max);\n\n    // from the day of last distribution\n    // process the rewards day by day\n    while (lastDistributeRewardsTimestamp <= currentTimestamp) {\n      // sum up rewards for each type\n      for (uint i; i < max; ++i) {\n        rewardsTypes[i] = IMinter.RewardsType(i);\n        // if there are rewards to distribute for that type on that day\n        if (epochs[lastDistributeRewardsTimestamp][rewardsTypes[i]] != 0) {\n          // add up rewards for that type and increase allowance\n          totalRewards[i] += epochs[lastDistributeRewardsTimestamp][rewardsTypes[i]];\n          IERC20(token).safeIncreaseAllowance(minter, epochs[lastDistributeRewardsTimestamp][rewardsTypes[i]]);\n          // remove it from the epoch\n          delete epochs[lastDistributeRewardsTimestamp][IMinter.RewardsType(i)];\n        }\n      }\n      // process the next day\n      lastDistributeRewardsTimestamp += 1 days;\n    }\n    // compound all types of rewards at once\n    IMinter(minter).compoundRewards(rewardsTypes, totalRewards);\n  }\n\n  /**\n   * @dev unpause the contract\n   */\n  function unpause() external onlyRole(MANAGER) {\n    _unpause();\n  }\n\n  /**\n   * @dev pause the contract\n   */\n  function pause() external onlyRole(PAUSER) {\n    _pause();\n  }\n\n  // /* ============ Internal Functions ============ */\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n}\n"
    }
}