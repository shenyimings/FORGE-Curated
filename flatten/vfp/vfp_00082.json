{
    "vfp_id": "vfp_00082",
    "project_name": "Very Liquid Vaults Audit.md",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1060"
                ]
            },
            "title": "Avoidable External Call",
            "description": "The `initialize` function in the `AaveStrategyVault` contract performs two external calls to the AAVE pool to retrieve the same `aToken` address, which is a gas-inefficient practice. The cause is the lack of local variable caching for the result of the first external call. This allows for avoidable gas expenditure during contract initialization. While external calls are necessary in some contexts, repeating the same call without change in state is unnecessary. The impact is limited to increased gas costs during deployment, with no risk of fund loss or access control breach.\n",
            "severity": "Low",
            "location": [
                "AaveStrategyVault.sol::initialize#70-81"
            ],
            "files": [
                "very-liquid-vaults/src/strategies/AaveStrategyVault.sol"
            ]
        }
    ],
    "affected_files": {
        "AaveStrategyVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {IAToken} from \"@aave/contracts/interfaces/IAToken.sol\";\nimport {IPool} from \"@aave/contracts/interfaces/IPool.sol\";\n\nimport {ReserveConfiguration} from \"@aave/contracts/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport {WadRayMath} from \"@aave/contracts/protocol/libraries/math/WadRayMath.sol\";\nimport {DataTypes} from \"@aave/contracts/protocol/libraries/types/DataTypes.sol\";\nimport {ERC4626Upgradeable} from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Auth} from \"@src/Auth.sol\";\nimport {BaseVault} from \"@src/utils/BaseVault.sol\";\nimport {NonReentrantVault} from \"@src/utils/NonReentrantVault.sol\";\n\n/// @title AaveStrategyVault\n/// @custom:security-contact security@size.credit\n/// @author Size (https://size.credit/)\n/// @notice A strategy that invests assets in Aave v3 lending pools\n/// @dev Extends NonReentrantVault for Aave v3 integration within the Size Meta Vault system\n/// @dev Reference https://github.com/superform-xyz/super-vaults/blob/8bc1d1bd1579f6fb9a047802256ed3a2bf15f602/src/aave-v3/AaveV3ERC4626Reinvest.sol\ncontract AaveStrategyVault is NonReentrantVault {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  /*//////////////////////////////////////////////////////////////\n                              STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @custom:storage-location erc7201:size.storage.AaveStrategyVault\n  struct AaveStrategyVaultStorage {\n    IPool _pool;\n    IAToken _aToken;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"size.storage.AaveStrategyVault\")) - 1)) & ~bytes32(uint256(0xff));\n  bytes32 private constant AaveStrategyVaultStorageLocation = 0x6b03c294048d7633f1826f4a825d1f9c054949a92b1cf388dba41a6d4d2b4500;\n\n  function _getAaveStrategyVaultStorage() private pure returns (AaveStrategyVaultStorage storage $) {\n    assembly {\n      $.slot := AaveStrategyVaultStorageLocation\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                              ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvalidAsset(address asset);\n\n  /*//////////////////////////////////////////////////////////////\n                              EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event PoolSet(address indexed pool);\n  event ATokenSet(address indexed aToken);\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR / INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Initializes the AaveStrategyVault with an Aave pool\n  /// @dev Sets the Aave pool and retrieves the corresponding aToken address\n  function initialize(Auth auth_, IERC20 asset_, string memory name_, string memory symbol_, address fundingAccount, uint256 firstDepositAmount, IPool pool_) public virtual initializer {\n    if (address(pool_) == address(0)) revert NullAddress();\n    if (address(pool_.getReserveData(address(asset_)).aTokenAddress) == address(0)) revert InvalidAsset(address(asset_));\n\n    AaveStrategyVaultStorage storage $ = _getAaveStrategyVaultStorage();\n    $._pool = pool_;\n    emit PoolSet(address(pool_));\n    $._aToken = IAToken(pool_.getReserveData(address(asset_)).aTokenAddress);\n    emit ATokenSet(address($._aToken));\n\n    super.initialize(auth_, asset_, name_, symbol_, fundingAccount, firstDepositAmount);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                              ERC4626 OVERRIDES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Returns the maximum amount that can be deposited\n  /// @dev Checks Aave reserve configuration and supply cap to determine max deposit\n  /// @dev Updates Superform implementation to comply with https://github.com/aave-dao/aave-v3-origin/blob/v3.4.0/src/contracts/protocol/libraries/logic/ValidationLogic.sol#L79-L85\n  /// @return The maximum deposit amount allowed by Aave\n  function maxDeposit(address receiver) public view override(BaseVault) returns (uint256) {\n    // check if asset is paused\n    DataTypes.ReserveConfigurationMap memory config = pool().getReserveData(asset()).configuration;\n    if (!(config.getActive() && !config.getFrozen() && !config.getPaused())) return 0;\n\n    // handle supply cap\n    uint256 supplyCapInWholeTokens = config.getSupplyCap();\n    if (supplyCapInWholeTokens == 0) return super.maxDeposit(receiver);\n\n    uint256 tokenDecimals = config.getDecimals();\n    uint256 supplyCap = supplyCapInWholeTokens * 10 ** tokenDecimals;\n    DataTypes.ReserveDataLegacy memory reserve = pool().getReserveData(asset());\n    uint256 usedSupply = (aToken().scaledTotalSupply() + uint256(reserve.accruedToTreasury)).rayMul(reserve.liquidityIndex);\n\n    if (usedSupply >= supplyCap) return 0;\n    return Math.min(supplyCap - usedSupply, super.maxDeposit(receiver));\n  }\n\n  /// @notice Returns the maximum number of shares that can be minted\n  /// @dev Converts the max deposit amount to shares\n  function maxMint(address receiver) public view override(BaseVault) returns (uint256) {\n    return Math.min(convertToShares(maxDeposit(receiver)), super.maxMint(receiver));\n  }\n\n  /// @notice Returns the maximum amount that can be withdrawn by an owner\n  /// @dev Limited by both owner's balance and Aave pool liquidity\n  function maxWithdraw(address owner) public view override(BaseVault) returns (uint256) {\n    // check if asset is paused\n    DataTypes.ReserveConfigurationMap memory config = pool().getReserveData(asset()).configuration;\n    if (!(config.getActive() && !config.getPaused())) return 0;\n\n    uint256 cash = IERC20(asset()).balanceOf(address(aToken()));\n    uint256 assetsBalance = convertToAssets(balanceOf(owner));\n    return Math.min(cash < assetsBalance ? cash : assetsBalance, super.maxWithdraw(owner));\n  }\n\n  /// @notice Returns the maximum number of shares that can be redeemed\n  /// @dev Updates Superform implementation to allow the SizeMetaVault to redeem all\n  /// @dev Limited by both owner's balance and Aave pool liquidity\n  function maxRedeem(address owner) public view override(BaseVault) returns (uint256) {\n    // check if asset is paused\n    DataTypes.ReserveConfigurationMap memory config = pool().getReserveData(asset()).configuration;\n    if (!(config.getActive() && !config.getPaused())) return 0;\n\n    uint256 cash = IERC20(asset()).balanceOf(address(aToken()));\n    uint256 cashInShares = convertToShares(cash);\n    uint256 shareBalance = balanceOf(owner);\n    return Math.min(cashInShares < shareBalance ? cashInShares : shareBalance, super.maxRedeem(owner));\n  }\n\n  /// @notice Returns the total assets managed by this strategy\n  /// @dev Returns the aToken balance since aTokens represent the underlying asset with accrued interest\n  /// @dev Round down to avoid stealing assets in roundtrip operations https://github.com/a16z/erc4626-tests/issues/13\n  function totalAssets() public view virtual override(ERC4626Upgradeable, IERC4626) returns (uint256) {\n    /// @notice aTokens use rebasing to accrue interest, so the total assets is just the aToken balance\n    uint256 liquidityIndex = pool().getReserveNormalizedIncome(address(asset()));\n    return Math.mulDiv(aToken().scaledBalanceOf(address(this)), liquidityIndex, WadRayMath.RAY);\n  }\n\n  /// @notice Internal deposit function that supplies assets to Aave\n  /// @dev Calls parent deposit then supplies the assets to the Aave pool\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {\n    super._deposit(caller, receiver, assets, shares);\n    IERC20(asset()).forceApprove(address(pool()), assets);\n    pool().supply(asset(), assets, address(this), 0);\n  }\n\n  /// @notice Internal withdraw function that withdraws from Aave\n  /// @dev Withdraws from the Aave pool then calls parent withdraw\n  function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n    // slither-disable-next-line unused-return\n    pool().withdraw(asset(), assets, address(this));\n    super._withdraw(caller, receiver, owner, assets, shares);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                              VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Returns the Aave pool\n  function pool() public view returns (IPool) {\n    return _getAaveStrategyVaultStorage()._pool;\n  }\n\n  /// @notice Returns the Aave aToken\n  function aToken() public view returns (IAToken) {\n    return _getAaveStrategyVaultStorage()._aToken;\n  }\n}\n"
    }
}