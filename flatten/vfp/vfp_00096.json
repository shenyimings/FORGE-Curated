{
    "vfp_id": "vfp_00096",
    "project_name": "2025.07.18 - Final - Notional Exponent Audit Report.pdf",
    "findings": [
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Unable to deposit to Convex in Arbitrum",
            "description": "The protocol attempts to deposit Curve LP tokens to Convex using the IConvexBooster interface on Arbitrum. However, the deposit function on Arbitrum's Convex Booster contract only accepts two parameters (_pid, _amount), whereas the Ethereum version accepts three parameters (_pid, _amount, _stake). The code calls a three-parameter version on Arbitrum, which does not exist, causing the transaction to revert.\n\nThe root cause is the lack of chain-specific handling for the Convex deposit function interface differences.\n\nAn attacker cannot directly exploit this, but any user attempting to stake LP tokens on Arbitrum will face transaction reverts.\n\nThis renders the protocol non-functional on Arbitrum, preventing users from entering positions and undermining cross-chain compatibility.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol::deposit#291",
                "CurveConvex2Token.sol::constructor#137"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/2025-06-notional-exponent/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Funds stuck if one of the withdrawal requests cannot be finalized",
            "description": "The protocol requires all withdrawal requests (WRs) to be finalized before allowing redemption. If one WR fails to finalize due to external factors (e.g., protocol compromise, liquidity issues, slashing events, or zero-asset redemption reverts), the entire withdrawal is blocked—even if other WRs are ready.\n\nThe root cause is the all-or-nothing design in handling multiple WRs and the lack of a minimum position size, which can trigger reverts during redemption (e.g., due to rounding errors in ERC4626 vaults like PirexETH).\n\nAn external event such as a hack or pause in a staking protocol (e.g., LIDO) can prevent finalization of one WR, thereby freezing funds in other WRs.\n\nThis leads to total loss of access to funds, even those unrelated to the failed WR, resulting in high user impact and potential fund loss.\n",
            "severity": "High",
            "location": [
                "AbstractSingleSidedLP.sol::finalizeAndRedeemWithdrawRequest#397",
                "AbstractSingleSidedLP.sol::hasPendingWithdrawals#338"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/2025-06-notional-exponent/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "WETH.withdraw called on native ETH balance causes revert",
            "description": "The vulnerability arises when a yield strategy deposits into a Curve pool where one of the underlying tokens is ETH. In such cases, the strategy receives native ETH after a trade, but later attempts to call WETH.withdraw(msgValue) when msgValue > 0, assuming it holds WETH. However, since the contract only holds native ETH and not WETH, the withdraw call reverts, blocking further operations.\n\nThe root cause is the incorrect assumption that receiving ETH via trade implies holding WETH, leading to an invalid WETH.withdraw() call. The code checks if TOKEN_1 or TOKEN_2 is ETH_ADDRESS and sets msgValue accordingly, then calls WETH.withdraw(msgValue), which fails because no WETH is present.\n\nAn attacker cannot directly exploit this, but the condition occurs naturally when users deposit into ETH-paired Curve pools. The attack path requires no malicious action—simply depositing into such a pool triggers the issue.\n\nThe impact is that users cannot complete deposits if the asset is one of the Curve LP tokens. If the reward token is WETH, the entire strategy state can be disrupted due to failed withdrawals, rendering the strategy unusable.\n",
            "severity": "High",
            "location": [
                "CurveConvex2Token.sol::deposit#180-196",
                "AbstractSingleSidedLP.sol::executeTrade#181-219",
                "TradingUtils.sol::ensureEtherBalance#164-172"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/2025-06-notional-exponent/notional-v4/src/single-sided-lp/CurveConvex2Token.sol",
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/2025-06-notional-exponent/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Single sided strategy cant do trades for ETH pools",
            "description": "When users deposit the asset into a single-sided Curve LP strategy where one of the pool's underlying tokens is ETH (not WETH), the trade execution fails. The issue occurs because the TRADING_MODULE returns native ETH when ETH is requested, but the strategy code expects to receive WETH. The root cause is a mismatch between the expected token type (WETH) and the actual received token (ETH) in the trade settlement logic. This leads to accounting errors or reverts when the contract attempts to handle the received ETH as WETH. Exploitation is not direct, but users attempting to use the strategy with ETH-pool assets will find their deposits fail or result in lost funds. The impact is medium: it breaks functionality for a specific but valid use case, limiting the protocol's flexibility.\n",
            "severity": "Medium",
            "location": [
                "CurveConvex2Token.sol"
            ],
            "files": [
                "7e0abc3e118db0abb20c7521c6f53f1762fdf562/2025-06-notional-exponent/notional-v4/src/single-sided-lp/CurveConvex2Token.sol"
            ]
        }
    ],
    "affected_files": {
        "CurveConvex2Token.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport {IWithdrawRequestManager} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {AbstractSingleSidedLP, BaseLPLib} from \"./AbstractSingleSidedLP.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {ETH_ADDRESS, ALT_ETH_ADDRESS, WETH, CHAIN_ID_MAINNET} from \"../utils/Constants.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/Curve/ICurve.sol\";\nimport \"../interfaces/Curve/IConvex.sol\";\n\nstruct DeploymentParams {\n    address pool;\n    address poolToken;\n    address gauge;\n    address convexRewardPool;\n    CurveInterface curveInterface;\n}\n\ncontract CurveConvex2Token is AbstractSingleSidedLP {\n\n    uint256 internal constant _NUM_TOKENS = 2;\n\n    ERC20 internal immutable CURVE_POOL_TOKEN;\n    uint8 internal immutable _PRIMARY_INDEX;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n\n    function NUM_TOKENS() internal pure override returns (uint256) { return _NUM_TOKENS; }\n    function PRIMARY_INDEX() internal view override returns (uint256) { return _PRIMARY_INDEX; }\n    function TOKENS() internal view override returns (ERC20[] memory) {\n        ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n        tokens[0] = ERC20(TOKEN_1);\n        tokens[1] = ERC20(TOKEN_2);\n        return tokens;\n    }\n\n    constructor(\n        uint256 _maxPoolShare,\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        DeploymentParams memory params,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) AbstractSingleSidedLP(_maxPoolShare, _asset, _yieldToken, _feeRate, _rewardManager, 18, _withdrawRequestManager) {\n        CURVE_POOL_TOKEN = ERC20(params.poolToken);\n\n        // We interact with curve pools directly so we never pass the token addresses back\n        // to the curve pools. The amounts are passed back based on indexes instead. Therefore\n        // we can rewrite the token addresses from ALT Eth (0xeeee...) back to (0x0000...) which\n        // is used by the vault internally to represent ETH.\n        TOKEN_1 = _rewriteAltETH(ICurvePool(params.pool).coins(0));\n        TOKEN_2 = _rewriteAltETH(ICurvePool(params.pool).coins(1));\n\n        // Assets may be WETH, so we need to unwrap it in this case.\n        _PRIMARY_INDEX =\n            (TOKEN_1 == _asset || (TOKEN_1 == ETH_ADDRESS && _asset == address(WETH))) ? 0 :\n            (TOKEN_2 == _asset || (TOKEN_2 == ETH_ADDRESS && _asset == address(WETH))) ? 1 :\n            // Otherwise the primary index is not set and we will not be able to enter or exit\n            // single sided.\n            type(uint8).max;\n\n        LP_LIB = address(new CurveConvexLib(TOKEN_1, TOKEN_2, _asset, _PRIMARY_INDEX, params));\n    }\n\n    function _rewriteAltETH(address token) private pure returns (address) {\n        return token == address(ALT_ETH_ADDRESS) ? ETH_ADDRESS : address(token);\n    }\n\n    function _transferYieldTokenToOwner(address owner, uint256 yieldTokens) internal override {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(\n            CurveConvexLib.transferYieldTokenToOwner.selector, owner, yieldTokens)\n        );\n    }\n\n    function _totalPoolSupply() internal view override returns (uint256) {\n        return CURVE_POOL_TOKEN.totalSupply();\n    }\n\n    function _checkReentrancyContext() internal override {\n        CurveConvexLib(payable(LP_LIB)).checkReentrancyContext();\n    }\n}\n\ncontract CurveConvexLib is BaseLPLib {\n    using SafeERC20 for ERC20;\n    using TokenUtils for ERC20;\n\n    uint256 internal constant _NUM_TOKENS = 2;\n\n    address internal immutable CURVE_POOL;\n    ERC20 internal immutable CURVE_POOL_TOKEN;\n\n    /// @dev Curve gauge contract used when there is no convex reward pool\n    address internal immutable CURVE_GAUGE;\n    /// @dev Convex booster contract used for staking BPT\n    address internal immutable CONVEX_BOOSTER;\n    /// @dev Convex reward pool contract used for unstaking and claiming reward tokens\n    address internal immutable CONVEX_REWARD_POOL;\n    uint256 internal immutable CONVEX_POOL_ID;\n\n    uint8 internal immutable _PRIMARY_INDEX;\n    address internal immutable ASSET;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n    CurveInterface internal immutable CURVE_INTERFACE;\n\n    // Payable is required for the CurveV1 interface which will execute a transfer\n    // when the remove_liquidity function is called, it only will be done to this contract\n    // during the checkReentrancyContext function.\n    receive() external payable {}\n\n    constructor(\n        address _token1,\n        address _token2,\n        address _asset,\n        uint8 _primaryIndex,\n        DeploymentParams memory params\n    ) {\n        TOKEN_1 = _token1;\n        TOKEN_2 = _token2;\n        ASSET = _asset;\n        _PRIMARY_INDEX = _primaryIndex;\n\n        CURVE_POOL = params.pool;\n        CURVE_GAUGE = params.gauge;\n        CURVE_POOL_TOKEN = ERC20(params.poolToken);\n        CURVE_INTERFACE = params.curveInterface;\n\n        // If the convex reward pool is set then get the booster and pool id, if not then\n        // we will stake on the curve gauge directly.\n        CONVEX_REWARD_POOL = params.convexRewardPool;\n        address convexBooster;\n        uint256 poolId;\n        if (block.chainid == CHAIN_ID_MAINNET && CONVEX_REWARD_POOL != address(0)) {\n            convexBooster = IConvexRewardPool(CONVEX_REWARD_POOL).operator();\n            poolId = IConvexRewardPool(CONVEX_REWARD_POOL).pid();\n        }\n\n        CONVEX_POOL_ID = poolId;\n        CONVEX_BOOSTER = convexBooster;\n    }\n\n    function checkReentrancyContext() external {\n        uint256[2] memory minAmounts;\n        if (CURVE_INTERFACE == CurveInterface.V1) {\n            ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity(0, minAmounts);\n        } else if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n            // Total supply on stable swap has a non-reentrant lock\n            ICurveStableSwapNG(CURVE_POOL).totalSupply();\n        } else if (CURVE_INTERFACE == CurveInterface.V2) {\n            // Curve V2 does a `-1` on the liquidity amount so set the amount removed to 1 to\n            // avoid an underflow.\n            ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(1, minAmounts, true, address(this));\n        } else {\n            revert();\n        }\n    }\n\n    function TOKENS() internal view override returns (ERC20[] memory) {\n        ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n        tokens[0] = ERC20(TOKEN_1);\n        tokens[1] = ERC20(TOKEN_2);\n        return tokens;\n    }\n\n    function initialApproveTokens() external {\n        // If either token is ETH_ADDRESS the check approve will short circuit\n        ERC20(TOKEN_1).checkApprove(address(CURVE_POOL), type(uint256).max);\n        ERC20(TOKEN_2).checkApprove(address(CURVE_POOL), type(uint256).max);\n        if (CONVEX_BOOSTER != address(0)) {\n            CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n        } else {\n            CURVE_POOL_TOKEN.checkApprove(address(CURVE_GAUGE), type(uint256).max);\n        }\n    }\n\n    function joinPoolAndStake(\n        uint256[] memory _amounts, uint256 minPoolClaim\n    ) external {\n        // Although Curve uses ALT_ETH to represent native ETH, it is rewritten in the Curve2TokenPoolMixin\n        // to the Deployments.ETH_ADDRESS which we use internally.\n        uint256 msgValue;\n        if (TOKEN_1 == ETH_ADDRESS) {\n            msgValue = _amounts[0];\n        } else if (TOKEN_2 == ETH_ADDRESS) {\n            msgValue = _amounts[1];\n        }\n        if (msgValue > 0) WETH.withdraw(msgValue);\n\n        uint256 lpTokens = _enterPool(_amounts, minPoolClaim, msgValue);\n\n        _stakeLpTokens(lpTokens);\n    }\n\n    function unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) external returns (uint256[] memory exitBalances) {\n        _unstakeLpTokens(poolClaim);\n\n        exitBalances = _exitPool(poolClaim, _minAmounts, isSingleSided);\n\n        if (ASSET == address(WETH)) {\n            if (TOKEN_1 == ETH_ADDRESS) {\n                WETH.deposit{value: exitBalances[0]}();\n            } else if (TOKEN_2 == ETH_ADDRESS) {\n                WETH.deposit{value: exitBalances[1]}();\n            }\n        }\n    }\n\n    function transferYieldTokenToOwner(address owner, uint256 yieldTokens) external {\n        _unstakeLpTokens(yieldTokens);\n        CURVE_POOL_TOKEN.safeTransfer(owner, yieldTokens);\n    }\n\n    function _enterPool(\n        uint256[] memory _amounts, uint256 minPoolClaim, uint256 msgValue\n    ) internal returns (uint256) {\n        if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n            return ICurveStableSwapNG(CURVE_POOL).add_liquidity{value: msgValue}(\n                _amounts, minPoolClaim\n            );\n        } \n\n        uint256[2] memory amounts;\n        amounts[0] = _amounts[0];\n        amounts[1] = _amounts[1];\n        if (CURVE_INTERFACE == CurveInterface.V1) {\n            return ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim\n            );\n        } else if (CURVE_INTERFACE == CurveInterface.V2) {\n            return ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n            );\n        }\n\n        revert();\n    }\n\n    function _exitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) internal returns (uint256[] memory exitBalances) {\n        if (isSingleSided) {\n            exitBalances = new uint256[](_NUM_TOKENS);\n            if (CURVE_INTERFACE == CurveInterface.V1 || CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n                // Method signature is the same for v1 and stable swap ng\n                exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity_one_coin(\n                    poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n                );\n            } else {\n                exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity_one_coin(\n                    // Last two parameters are useEth = true and receiver = this contract\n                    poolClaim, _PRIMARY_INDEX, _minAmounts[_PRIMARY_INDEX], true, address(this)\n                );\n            }\n        } else {\n            // Two sided exit\n            if (CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n                return ICurveStableSwapNG(CURVE_POOL).remove_liquidity(poolClaim, _minAmounts);\n            }\n            \n            // Redeem proportionally, min amounts are rewritten to a fixed length array\n            uint256[2] memory minAmounts;\n            minAmounts[0] = _minAmounts[0];\n            minAmounts[1] = _minAmounts[1];\n\n            exitBalances = new uint256[](_NUM_TOKENS);\n            if (CURVE_INTERFACE == CurveInterface.V1) {\n                uint256[2] memory _exitBalances = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity(poolClaim, minAmounts);\n                exitBalances[0] = _exitBalances[0];\n                exitBalances[1] = _exitBalances[1];\n            } else {\n                exitBalances[0] = TokenUtils.tokenBalance(TOKEN_1);\n                exitBalances[1] = TokenUtils.tokenBalance(TOKEN_2);\n                // Remove liquidity on CurveV2 does not return the exit amounts so we have to measure\n                // them before and after.\n                ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(\n                    // Last two parameters are useEth = true and receiver = this contract\n                    poolClaim, minAmounts, true, address(this)\n                );\n                exitBalances[0] = TokenUtils.tokenBalance(TOKEN_1) - exitBalances[0];\n                exitBalances[1] = TokenUtils.tokenBalance(TOKEN_2) - exitBalances[1];\n            }\n        }\n    }\n\n    function _stakeLpTokens(uint256 lpTokens) internal {\n        if (CONVEX_BOOSTER != address(0)) {\n            bool success = IConvexBooster(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens, true);\n            require(success);\n        } else {\n            ICurveGauge(CURVE_GAUGE).deposit(lpTokens);\n        }\n    }\n\n\n    function _unstakeLpTokens(uint256 poolClaim) internal {\n        if (CONVEX_REWARD_POOL != address(0)) {\n            bool success = IConvexRewardPool(CONVEX_REWARD_POOL).withdrawAndUnwrap(poolClaim, false);\n            require(success);\n        } else {\n            ICurveGauge(CURVE_GAUGE).withdraw(poolClaim);\n        }\n    }\n\n}",
        "AbstractSingleSidedLP.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.29;\n\nimport \"../interfaces/ISingleSidedLP.sol\";\nimport {AbstractYieldStrategy} from \"../AbstractYieldStrategy.sol\";\nimport {DEFAULT_PRECISION, ADDRESS_REGISTRY} from \"../utils/Constants.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Trade, TradeType} from \"../interfaces/ITradingModule.sol\";\nimport {RewardManagerMixin} from \"../rewards/RewardManagerMixin.sol\";\nimport {IWithdrawRequestManager, WithdrawRequest, TokenizedWithdrawRequest} from \"../interfaces/IWithdrawRequestManager.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {\n    CannotEnterPosition,\n    WithdrawRequestNotFinalized,\n    PoolShareTooHigh,\n    AssetRemaining\n} from \"../interfaces/Errors.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract AbstractSingleSidedLP is RewardManagerMixin {\n    using TokenUtils for ERC20;\n\n    uint256 immutable MAX_POOL_SHARE;\n    address internal immutable LP_LIB;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as address(0)\n    function TOKENS() internal view virtual returns (ERC20[] memory);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256);\n\n    /// @dev Checks that the reentrancy context is valid\n    function _checkReentrancyContext() internal virtual;\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(ILPLib.initialApproveTokens.selector));\n    }\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual {\n        _delegateCall(LP_LIB, abi.encodeWithSelector(ILPLib.joinPoolAndStake.selector, amounts, minPoolClaim));\n    }\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.unstakeAndExitPool.selector, poolClaim, minAmounts, isSingleSided\n        ));\n        exitBalances = abi.decode(result, (uint256[]));\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(\n        uint256 _maxPoolShare,\n        address _asset,\n        address _yieldToken,\n        uint256 _feeRate,\n        address _rewardManager,\n        uint8 _yieldTokenDecimals,\n        IWithdrawRequestManager _withdrawRequestManager\n    ) RewardManagerMixin( _asset, _yieldToken, _feeRate, _rewardManager, _yieldTokenDecimals) {\n        MAX_POOL_SHARE = _maxPoolShare;\n        // Although there will be multiple withdraw request managers, we only need to set one here\n        // to check whether or not a withdraw request is pending. If any one of the withdraw requests\n        // is not finalized then the entire withdraw will revert and the user will remain in a pending\n        // withdraw state.\n        withdrawRequestManager = _withdrawRequestManager;\n    }\n\n    function _initialize(bytes calldata data) internal override {\n        super._initialize(data);\n        _initialApproveTokens();\n    }\n\n    function _mintYieldTokens(\n        uint256 assets,\n        address /* receiver */,\n        bytes memory depositData\n    ) internal override {\n        DepositParams memory params = abi.decode(depositData, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            // NOTE: amounts is modified in place\n            _executeDepositTrades(assets, amounts, params.depositTrades);\n        } else {\n            // This is a single sided entry, will revert if index is out of bounds\n            amounts[PRIMARY_INDEX()] = assets;\n        }\n\n        _joinPoolAndStake(amounts, params.minPoolClaim);\n\n        _checkPoolShare();\n    }\n\n    function _checkPoolShare() internal view virtual {\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * MAX_POOL_SHARE) / DEFAULT_PRECISION;\n        // This is incumbent on a 1-1 ratio between the lpToken and the yieldToken, if that is not the\n        // case then this function must be overridden.\n        uint256 poolClaim = _yieldTokenBalance();\n        if (maxSupplyThreshold < poolClaim) revert PoolShareTooHigh(poolClaim, maxSupplyThreshold);\n    }\n\n    function _redeemShares(\n        uint256 sharesToRedeem,\n        address sharesOwner,\n        bool isEscrowed,\n        bytes memory redeemData\n    ) internal override {\n        RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n\n        // Stores the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances;\n        bool isSingleSided;\n        ERC20[] memory tokens;\n        if (isEscrowed) {\n            // Attempt to withdraw all pending requests, tokens may be different if there\n            // is a withdraw request.\n            (exitBalances, tokens) = _withdrawPendingRequests(sharesOwner, sharesToRedeem);\n            // If there are pending requests, then we are not single sided by definition\n            isSingleSided = false;\n        } else {\n            isSingleSided = params.redemptionTrades.length == 0;\n            uint256 yieldTokensBurned = convertSharesToYieldToken(sharesToRedeem);\n            exitBalances = _unstakeAndExitPool(yieldTokensBurned, params.minAmounts, isSingleSided);\n            tokens = TOKENS();\n        }\n\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            _executeRedemptionTrades(tokens, exitBalances, params.redemptionTrades);\n        }\n    }\n\n    /// @dev Trades the amount of primary token into other secondary tokens prior to entering a pool.\n    function _executeDepositTrades(\n        uint256 assets,\n        uint256[] memory amounts,\n        TradeParams[] memory depositTrades\n    ) internal {\n        ERC20[] memory tokens = TOKENS();\n        Trade memory trade;\n        uint256 assetRemaining = assets;\n\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == PRIMARY_INDEX()) continue;\n            TradeParams memory t = depositTrades[i];\n\n            if (t.tradeAmount > 0) {\n                trade = Trade({\n                    tradeType: t.tradeType,\n                    sellToken: address(asset),\n                    buyToken: address(tokens[i]),\n                    amount: t.tradeAmount,\n                    limit: t.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: t.exchangeData\n                });\n                // Always selling the primaryToken and buying the secondary token.\n                (uint256 amountSold, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n                amounts[i] = amountBought;\n                // Will revert on underflow if over-selling the primary borrowed\n                assetRemaining -= amountSold;\n            }\n        }\n\n        if (PRIMARY_INDEX() < amounts.length) {\n            amounts[PRIMARY_INDEX()] = assetRemaining;\n        } else if (0 < assetRemaining) {\n            // This can happen if the asset is not in the pool and we need to trade all\n            // of the remaining asset for tokens in the pool.\n            revert AssetRemaining(assetRemaining);\n        }\n    }\n\n    /// @dev Trades the amount of secondary tokens into the primary token after exiting a pool.\n    function _executeRedemptionTrades(\n        ERC20[] memory tokens,\n        uint256[] memory exitBalances,\n        TradeParams[] memory redemptionTrades\n    ) internal returns (uint256 finalPrimaryBalance) {\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (address(tokens[i]) == address(asset)) {\n                finalPrimaryBalance += exitBalances[i];\n                continue;\n            }\n\n            TradeParams memory t = redemptionTrades[i];\n            // Always sell the entire exit balance to the primary token\n            if (exitBalances[i] > 0) {\n                Trade memory trade = Trade({\n                    tradeType: t.tradeType,\n                    sellToken: address(tokens[i]),\n                    buyToken: address(asset),\n                    amount: exitBalances[i],\n                    limit: t.minPurchaseAmount,\n                    deadline: block.timestamp,\n                    exchangeData: t.exchangeData\n                });\n                (/* */, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n                finalPrimaryBalance += amountBought;\n            }\n        }\n    }\n\n    function _preLiquidation(address liquidateAccount, address liquidator, uint256 sharesToLiquidate, uint256 accountSharesHeld) internal override {\n        _checkReentrancyContext();\n        return super._preLiquidation(liquidateAccount, liquidator, sharesToLiquidate, accountSharesHeld);\n    }\n\n    function __postLiquidation(address liquidator, address liquidateAccount, uint256 sharesToLiquidator) internal override returns (bool didTokenize) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.tokenizeWithdrawRequest.selector, liquidateAccount, liquidator, sharesToLiquidator\n        ));\n        didTokenize = abi.decode(result, (bool));\n    }\n\n    function __initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override returns (uint256 requestId) {\n        WithdrawParams memory params = abi.decode(data, (WithdrawParams));\n\n        uint256[] memory exitBalances = _unstakeAndExitPool({\n            poolClaim: yieldTokenAmount,\n            minAmounts: params.minAmounts,\n            // When initiating a withdraw, we always exit proportionally\n            isSingleSided: false\n        });\n\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.initiateWithdraw.selector, account, sharesHeld, exitBalances, params.withdrawData\n        ));\n        uint256[] memory requestIds = abi.decode(result, (uint256[]));\n        // Although we get multiple requests ids, we just return the first one here. The rest will be\n        // observable off chain.\n        requestId = requestIds[0];\n    }\n\n    function _withdrawPendingRequests(\n        address sharesOwner,\n        uint256 sharesToRedeem\n    ) internal returns (uint256[] memory exitBalances, ERC20[] memory tokens) {\n        bytes memory result = _delegateCall(LP_LIB, abi.encodeWithSelector(\n            ILPLib.finalizeAndRedeemWithdrawRequest.selector, sharesOwner, sharesToRedeem\n        ));\n        (exitBalances, tokens) = abi.decode(result, (uint256[], ERC20[]));\n    }\n\n    /// @notice Returns the total value in terms of the borrowed token of the account's position\n    function convertToAssets(uint256 shares) public view override returns (uint256) {\n        if (t_CurrentAccount != address(0) && _isWithdrawRequestPending(t_CurrentAccount)) {\n            return ILPLib(LP_LIB).getWithdrawRequestValue(t_CurrentAccount, asset, shares);\n        }\n\n        return super.convertToAssets(shares);\n    }\n\n    function _isWithdrawRequestPending(address account) internal view override returns (bool) {\n        return ILPLib(LP_LIB).hasPendingWithdrawals(account);\n    }\n}\n\nabstract contract BaseLPLib is ILPLib {\n    using TokenUtils for ERC20;\n\n    function TOKENS() internal view virtual returns (ERC20[] memory);\n\n    /// @inheritdoc ILPLib\n    function getWithdrawRequestValue(\n        address account,\n        address asset,\n        uint256 shares\n    ) external view returns (uint256 totalValue) {\n        ERC20[] memory tokens = TOKENS();\n\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            // This is called as a view function, not a delegate call so use the msg.sender to get\n            // the correct vault address\n            (bool hasRequest, uint256 value) = manager.getWithdrawRequestValue(msg.sender, account, asset, shares);\n            // Ensure that this is true so that we do not lose any value.\n            require(hasRequest);\n            totalValue += value;\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function hasPendingWithdrawals(address account) external view override returns (bool) {\n        ERC20[] memory tokens = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            if (address(manager) == address(0)) continue;\n            // This is called as a view function, not a delegate call so use the msg.sender to get\n            // the correct vault address\n            (WithdrawRequest memory w, /* */) = manager.getWithdrawRequest(msg.sender, account);\n            if (w.requestId != 0) return true;\n        }\n\n        return false;\n    }\n\n    /// @inheritdoc ILPLib\n    function initiateWithdraw(\n        address account,\n        uint256 sharesHeld,\n        uint256[] calldata exitBalances,\n        bytes[] calldata withdrawData\n    ) external override returns (uint256[] memory requestIds) {\n        ERC20[] memory tokens = TOKENS();\n\n        requestIds = new uint256[](exitBalances.length);\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (exitBalances[i] == 0) continue;\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n\n            tokens[i].checkApprove(address(manager), exitBalances[i]);\n            // Will revert if there is already a pending withdraw\n            requestIds[i] = manager.initiateWithdraw({\n                account: account,\n                yieldTokenAmount: exitBalances[i],\n                sharesAmount: sharesHeld,\n                data: withdrawData[i]\n            });\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function finalizeAndRedeemWithdrawRequest(\n        address sharesOwner,\n        uint256 sharesToRedeem\n    ) external override returns (uint256[] memory exitBalances, ERC20[] memory withdrawTokens) {\n        ERC20[] memory tokens = TOKENS();\n\n        exitBalances = new uint256[](tokens.length);\n        withdrawTokens = new ERC20[](tokens.length);\n\n        WithdrawRequest memory w;\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            (w, /* */) = manager.getWithdrawRequest(address(this), sharesOwner);\n\n            uint256 yieldTokensBurned = uint256(w.yieldTokenAmount) * sharesToRedeem / w.sharesAmount;\n            bool finalized;\n            (exitBalances[i], finalized) = manager.finalizeAndRedeemWithdrawRequest({\n                account: sharesOwner, withdrawYieldTokenAmount: yieldTokensBurned, sharesToBurn: sharesToRedeem\n            });\n            if (!finalized) revert WithdrawRequestNotFinalized(w.requestId);\n            withdrawTokens[i] = ERC20(manager.WITHDRAW_TOKEN());\n        }\n    }\n\n    /// @inheritdoc ILPLib\n    function tokenizeWithdrawRequest(\n        address liquidateAccount,\n        address liquidator,\n        uint256 sharesToLiquidator\n    ) external override returns (bool didTokenize) {\n        ERC20[] memory tokens = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n            if (address(manager) == address(0)) continue;\n            // If there is no withdraw request then this will be a noop, make sure to OR with the previous result\n            // to ensure that the result is always set but it is done after so the tokenizeWithdrawRequest call\n            // is not short circuited.\n            didTokenize = manager.tokenizeWithdrawRequest(liquidateAccount, liquidator, sharesToLiquidator) || didTokenize;\n        }\n    }\n}\n"
    }
}