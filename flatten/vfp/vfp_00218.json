{
    "vfp_id": "vfp_00218",
    "project_name": "cantina_steakhouse_nov2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Share price manipulation attack in Box.flash() callbacks",
            "description": "The vulnerability arises because the Box.flash() function caches the Net Asset Value (NAV) at the beginning of the flash operation, freezing totalAssets(), while allowing deposits and withdrawals that modify totalSupply(). This creates an inconsistency between totalAssets() and totalSupply(), leading to a fluctuating share price during the flash loan callback. An attacker can exploit this by redeeming shares in multiple steps during the callback, benefiting from the outdated NAV and receiving more assets than they are entitled to. The root cause is the lack of protection against changes in totalSupply() during the flash operation. The impact is economic loss to the vault, as the attacker extracts more funds than should be possible under fair redemption conditions.\n",
            "severity": "High",
            "location": [
                "Box.sol#L650-L672"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Invisible Aave isolation mode",
            "description": "The FundingAave.pledge function enables a token as collateral on Aave without checking whether that token is in isolation mode. If it is, Aave restricts the account to using only that collateral and limits borrows to specific stablecoins. The Box system does not track or validate these constraints, so an allocator can inadvertently place the entire position into isolation mode. This can block future pledging or borrowing actions with opaque reverts, disrupting automation. Additionally, there is no awareness of Aave's isolation debt ceiling, so borrows may fail without clear diagnostics. The root cause is the lack of local enforcement of Aave's isolation rules. The impact is operational outages and potential bricking of investment workflows, risking stranded collateral.\n",
            "severity": "Low",
            "location": [
                "FundingAave.sol#L238"
            ],
            "files": [
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Donation attack can partially absorb the first deposit",
            "description": "When the base asset has 18 decimals, the Box constructor sets virtualShares to 1. Before any deposit, an attacker can donate assets directly to the contract. This results in totalAssets() > 0 while totalSupply() == 0. When the first legitimate deposit occurs, the convertToShares function calculates shares as floor(A * 1 / (D + 1)), which is zero if the deposit A is less than or equal to the donation D. The deposit is accepted and tokens are transferred, but zero shares are minted, effectively burning the deposit. The root cause is the lack of a check for pre-existing assets before the first deposit. The impact is a denial-of-service vector that forces operators to either redeploy or bridge in more capital, though no profit is possible for the attacker.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L213-L218"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Winddown allows unvetted swappers to skim the slippage budget",
            "description": "During winddown, the Box.allocate function allows anyone to perform swaps to repay debt, accepting any ISwapper implementation. The only check is that the output meets a minimum threshold based on slippage tolerance, which increases up to ~1%. A malicious swapper can return the minimum required tokens, keep the rest, and repeat the process across multiple calls, draining the entire slippage budget. The root cause is the trust in arbitrary swappers without validation or restriction during winddown. The impact is a guaranteed loss of up to 1% per unwind trade, converting every winddown into a profit opportunity for attackers at the protocol's expense.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L387-L432"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Dust transfers blocks token delisting",
            "description": "The removeToken function requires the Box to hold zero balance of a token before removal. However, any external user can transfer a minimal amount (e.g., 1 wei) of a whitelisted token to the Box, making the balance non-zero and causing removeToken to revert. This prevents governance from delisting the token until the dust is manually cleared. The root cause is the lack of a governance escape hatch or threshold-based tolerance for negligible balances. The impact is a low-severity griefing vector that forces extra transactions and gas costs to clean up the whitelist, though it does not cause permanent lockup.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L959"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Include boundary checks on duration-related parameters",
            "description": "The Box contract checks that _slippageEpochDuration and _shutdownSlippageDuration are non-zero but does not enforce upper bounds. Similarly, shutdownWarmup lacks a lower bound, which could allow it to be set too low, not giving the guardian enough time to react to a malicious shutdown. The root cause is insufficient input validation for time-based parameters. The impact is potential configuration errors that could lead to operational risks, such as insufficient response time during emergencies or overly long slippage periods that increase exposure. While not directly exploitable, it increases the risk surface due to misconfiguration.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L154-L156"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect rounding directions",
            "description": "Several integer divisions in the Box contract use default rounding modes instead of explicitly choosing a direction that benefits the protocol. For example, when calculating expected tokens from a swap, rounding down could underestimate the amount, weakening slippage protection. Best practice is to round up in such cases to enforce stricter checks. The locations include calculations in allocate, repay, and other critical functions. The root cause is inconsistent application of safe arithmetic practices. The impact is potential economic inefficiency or increased vulnerability to edge-case exploits, though the immediate risk is low due to the small magnitude of rounding differences.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L416-L418",
                "Box.sol#L407-L408",
                "Box.sol#L424",
                "Box.sol#L464",
                "Box.sol#L515-L516",
                "Box.sol#L525",
                "Box.sol#L1360"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Compromised curator can abdicate timelock functions immediately",
            "description": "The abdicateTimelock() function allows the curator to permanently disable timelocked functions (e.g., setGuardian, setMaxSlippage) without any delay. If the curator is compromised, they can call this function immediately, rendering the guardian unable to intervene even after the curator is replaced. The root cause is the lack of a timelock or reversibility on the abdication itself. The impact is a loss of governance control over critical risk-mitigating functions, forcing users to migrate to a new Box, which is operationally burdensome but not catastrophic.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L889-L895"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Risks of unset or insufficiently long timelock periods",
            "description": "Critical functions in the Box contract rely on timelocks for security, but the default delay is 0. If not explicitly set, this allows immediate execution of sensitive actions. Users must ensure timelocks are set to a sufficient duration, especially for setGuardian(), which is the last line of defense. The root cause is the absence of a default minimum delay or a validation check during submission. The impact is increased risk of flash attacks if a curator is compromised and can make dangerous changes without delay, though the risk is mitigated by user diligence and governance oversight.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L746-L748"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ],
                "4": [
                    "CWE-455"
                ]
            },
            "title": "Revert if an oracle is unset when calculating NAV",
            "description": "The _nav() function in Box and nav() in FundingAave and FundingMorpho skip oracle price checks if the oracle address is zero. While current invariants prevent zero oracles, this could mask programming errors. It is safer to revert explicitly if an oracle is unset, as returning a partial NAV could lead to incorrect valuations. The root cause is defensive programming oversight. The impact is low, as the system likely reverts anyway when calling the zero address, but explicit checks improve code clarity and safety.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L1406-L1413",
                "FundingAave.sol#L331-L335",
                "FundingMorpho.sol#L279",
                "FundingMorpho.sol#L320-L322",
                "FundingMorpho.sol#L331-L334"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Possible duplicate markets in FundingMorpho",
            "description": "The isFacility function in FundingMorpho compares raw bytes of facilityData, but abi.decode() ignores trailing data. An attacker can append arbitrary bytes to valid facilityData, creating a distinct bytes array that decodes to the same MarketParams, allowing the same market to be added multiple times. This could inflate the NAV. The root cause is the lack of strict equality on decoded data or length validation. The impact is potential inflation of NAV and incorrect accounting, though mitigated by the need for valid encoding.\n",
            "severity": "Low",
            "location": [
                "FundingMorpho.sol#L344-L347"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Risks of allowing anyone to execute Box.changeTokenOracle()",
            "description": "The changeTokenOracle() function can be called by anyone after the timelock expires, allowing public initiation of oracle updates. This creates a window for arbitrageurs to sandwich the update and profit from price discrepancies. While the timelock provides some protection, the open execution model increases MEV exposure. The root cause is the permissionless design of a sensitive function. The impact is potential arbitrage losses for users during oracle updates, though the risk is general to such systems and partially mitigated by timelock.\n",
            "severity": "Low",
            "location": [
                "Box.sol#L982-L988"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Cache asset address in FundingAave.nav",
            "description": "The nav() function in FundingAave repeatedly calls oraclesProvider.asset() inside loops to compare with the base asset. Since the result is constant, each iteration performs an unnecessary external call. Caching the result at the start would eliminate redundant calls. The root cause is inefficient code structure. The impact is increased gas costs, especially with many tokens, but no security risk.\n",
            "severity": "Informational",
            "location": [
                "FundingAave.sol#L327"
            ],
            "files": [
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Cache facilityHash in FundingAave loops",
            "description": "Functions isFacility and _findFacilityIndex recompute keccak256(facilityData) in every loop iteration. Since facilityData is constant, hashing it once and reusing the result would save gas. The root cause is repeated computation of a static value. The impact is higher gas usage that scales with the number of facilities.\n",
            "severity": "Informational",
            "location": [
                "FundingAave.sol#L132-L140"
            ],
            "files": [
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Skip oracle call when LTV has no collateral",
            "description": "The ltv() function in FundingMorpho queries the oracle even when collateralAmount is zero, despite documenting that it returns zero in that case. Adding an early return would avoid unnecessary external calls and arithmetic. The root cause is missing short-circuit logic. The impact is wasted gas, especially with multiple collateral tokens.\n",
            "severity": "Informational",
            "location": [
                "FundingMorpho.sol#L279"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Reuse debtToken in FundingMorpho.repay",
            "description": "The repay function re-casts market.loanToken to IERC20 after already verifying it equals the debtToken parameter. Reusing the parameter would save a stack slot and improve clarity. The root cause is redundant casting. The impact is minor gas savings and code cleanliness.\n",
            "severity": "Informational",
            "location": [
                "FundingMorpho.sol#L239"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "Use EnumerableSet for constant-time lookups and removals",
            "description": "The FundingAave and FundingMorpho contracts use arrays for facilities, collateralTokens, and debtTokens, resulting in O(n) lookups and removals. Using OpenZeppelin's EnumerableSet would provide O(1) operations and reduce gas costs as the number of elements grows. The root cause is suboptimal data structure choice. The impact is higher gas costs for large sets, though insertion cost increases slightly.\n",
            "severity": "Informational",
            "location": [
                "FundingAave.sol#L383-L391"
            ],
            "files": [
                "box/src/FundingAave.sol",
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Avoid this.nav() external calls",
            "description": "The skim() function calls this.nav(), which incurs the cost of an external call. Making nav() public and calling it directly would reduce gas by avoiding the external call overhead. The root cause is inefficient function visibility and call pattern. The impact is minor gas savings per skim operation.\n",
            "severity": "Informational",
            "location": [
                "FundingAave.sol#L211",
                "FundingMorpho.sol#L174"
            ],
            "files": [
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-703"
                ]
            },
            "title": "Winddown slippage ramp can block exits",
            "description": "During winddown, both allocate and deallocate functions enforce a minimum output derived from _winddownSlippageTolerance(), which starts at 0% and ramps linearly to a maximum of 1% over a 10-day period. This creates a narrow slippage tolerance window that may prevent successful trades during market stress. The slippage tolerance starts at zero and increases too slowly, with a hard cap of 1% defined in Constants.sol. The system does not allow higher slippage even when market conditions demand it, and breaking trades into smaller parts does not help because each trade is subject to the same per-trade tolerance check. In a distressed market, where the executable price is more than 1% below the oracle price, all unwind attempts will revert. During emergency shutdown, the protocol may be unable to repay debt or allow user exits for up to 10 days if market prices deviate more than 1% from the oracle, defeating the purpose of a timely winddown. This could lead to liquidity lockups and loss of confidence.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::allocate#L400",
                "Box.sol::deallocate#L400"
            ],
            "files": [
                "box/src/Box.sol",
                "box/src/libraries/Constants.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Predicted funding address risk",
            "description": "The factory for FundingMorpho is permissionless, allowing anyone to deploy a module. If governance queues addFunding using a predicted address instead of a deployed one, an attacker can front-run the deployment and register a malicious module. The addFunding function only verifies that the module lists the Box as owner and is empty, but does not validate whether the module was pre-deployed by the correct party. This creates a race condition if predicted addresses are used. An attacker can monitor governance transactions, detect a queued addFunding call with a predicted address, deploy the module first with malicious logic, and get it whitelisted upon execution. A malicious funding module could manipulate NAV calculations or drain funds if it gains control over asset flows, although the risk is mitigated by operational discipline (deploy first, queue later).\n",
            "severity": "Informational",
            "location": [
                "Box.sol::addFunding#L998-L1020"
            ],
            "files": [
                "box/src/Box.sol",
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Skim ETH transfer uses 2300 gas",
            "description": "The Box.skim function uses Solidity's .transfer() method, which forwards only 2300 gas, insufficient for complex recipient contracts like Gnosis Safe. The use of .transfer() enforces a low gas stipend, which was historically safe but now fails for contracts requiring more computation in their fallback functions. Any attempt to skim ETH to a contract that consumes more than 2300 gas in its receive or fallback function will revert, preventing the vault from recovering native tokens. ETH remains stranded in the Box contract until the skimRecipient is changed via governance, leading to operational inefficiency and potential loss of fees.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::skim#L370"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused code",
            "description": "Several code elements are defined but never used, including MathLib usage directive in BoxAdapter, unused RAY constant in FundingAave, and multiple custom errors in ErrorsLib with no throw sites. Code was likely added for future use or copied from templates but never fully integrated or cleaned up. While not directly exploitable, unused code increases bytecode size and maintenance burden, potentially increasing deployment costs and audit complexity. Increased gas costs for deployment and a cluttered codebase that may confuse developers or auditors, reducing code clarity and security maintainability.\n",
            "severity": "Informational",
            "location": [
                "ErrorsLib.sol::#L4",
                "BoxAdapter.sol",
                "FundingAave.sol::RAY"
            ],
            "files": [
                "box/src/libraries/ErrorsLib.sol",
                "box/src/BoxAdapter.sol",
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Oracles must return prices in asset denomination",
            "description": "The oracle used in nav calculations must return prices in token/asset format (e.g., DAI/USDC), but this is not enforced on-chain. The contract assumes correct oracle behavior without validating the price denomination, relying on off-chain governance checks. If an oracle returning price in asset/token format (inverse) is mistakenly set, all valuations will be inverted, leading to wildly incorrect NAV and collateral calculations. Severe miscalculations in share pricing, deposit previews, and funding ratios could result in massive financial loss or system instability.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::#L1411"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "More detailed custom errors",
            "description": "In Box.allocate(), when winddown is active but debt balance is zero, the error OnlyAllocatorsOrWinddown() is raised, which does not clearly indicate the actual cause. The error message is generic and does not reflect the specific condition (zero debt balance) that caused the revert. While not exploitable per se, unclear errors make debugging and user communication harder during failures. Poor user experience and increased difficulty in diagnosing issues during winddown, potentially delaying corrective actions.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::allocate#L395-L396",
                "Box.sol::deallocate"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Explicitly check whether the target function is abdicated in Box.submit()",
            "description": "When a curator abdicates a function, its timelock is set to type(uint256).max. Calling submit() for such a function reverts due to arithmetic overflow when calculating executableAt. The code lacks an explicit check for TIMELOCK_DISABLED, relying instead on arithmetic overflow to revert. Users attempting to call abdicated functions receive a low-level arithmetic error instead of a clear message. Poor error clarity reduces transparency and user experience. An explicit check with a custom error would improve debuggability.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::submit#L815-L817"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Custom error name could be more accurate",
            "description": "In Box.increaseTimelock(), the error TimelockDecrease() is raised if the new period is not larger, but it does not cover the case where the period is equal. The error name is imprecise, suggesting only decreases are blocked when in fact non-increases (equal or lower) are rejected. Misleading error names can confuse developers and users about the actual validation logic. Reduced code clarity and potential misinterpretation of business rules, increasing the risk of incorrect usage or assumptions.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::increaseTimelock#L858",
                "Box.sol::decreaseTimelock#L876"
            ],
            "files": [
                "box/src/Box.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Reduce code duplication in Funding modules",
            "description": "FundingAave and FundingMorpho share identical implementations of several functions, indicating an opportunity for abstraction. Lack of a shared base contract leads to duplicated logic across funding modules. Code duplication increases the risk of inconsistent fixes and security patches being applied to one module but not the other. Higher maintenance cost, increased audit surface, and greater likelihood of bugs due to inconsistent updates across modules.\n",
            "severity": "Informational",
            "location": [
                "FundingAave.sol::#L71"
            ],
            "files": [
                "box/src/FundingAave.sol",
                "box/src/FundingMorpho.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Suggestions on code comments and docs",
            "description": "Several comments are inaccurate or misleading, such as stating that the caller returns tokens in flash loans when it is actually the Box contract, and misnaming the owner variable in FundingAave as potentially changeable. Comments were not updated after code changes or were written imprecisely. Developers relying on outdated comments may misunderstand the code behavior, leading to incorrect integrations or modifications. Increased risk of developer error, reduced code readability, and longer onboarding time for new contributors.\n",
            "severity": "Informational",
            "location": [
                "Box.sol::#L647",
                "Box.sol::#L1296",
                "FundingAave.sol::#L78"
            ],
            "files": [
                "box/src/Box.sol",
                "box/src/FundingAave.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Non-existent Morpho markets can be added as facilities",
            "description": "FundingMorpho.addFacility() does not validate whether the provided market exists on Morpho, allowing non-existent markets to be added. Missing validation call to morpho.market(market_id) and check for lastUpdate != 0. A governance mistake or malicious proposal could add a non-existent market, leading to failed operations or confusion in module behavior. Operational failures when attempting to interact with non-existent markets, and potential confusion in risk assessment or accounting.\n",
            "severity": "Informational",
            "location": [
                "FundingMorpho.sol::addFacility#L62-L71"
            ],
            "files": [
                "box/src/FundingMorpho.sol"
            ]
        }
    ],
    "affected_files": {
        "BoxAdapter.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 Morpho Association, Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IVaultV2} from \"./../lib/vault-v2/src/interfaces/IVaultV2.sol\";\nimport {MathLib} from \"./../lib/vault-v2/src/libraries/MathLib.sol\";\nimport {SafeERC20Lib} from \"./../lib/vault-v2/src/libraries/SafeERC20Lib.sol\";\nimport {IBox} from \"./interfaces/IBox.sol\";\nimport {IBoxAdapter} from \"./interfaces/IBoxAdapter.sol\";\n\ncontract BoxAdapter is IBoxAdapter {\n    using MathLib for uint256;\n\n    /* IMMUTABLES */\n\n    address public immutable factory;\n    address public immutable parentVault;\n    IBox public immutable box;\n    bytes32 public immutable adapterId;\n\n    /* STORAGE */\n\n    address public skimRecipient;\n\n    /* FUNCTIONS */\n\n    constructor(address _parentVault, IBox _box) {\n        factory = msg.sender;\n        parentVault = _parentVault;\n        box = _box;\n        adapterId = keccak256(abi.encode(\"this\", address(this)));\n        address asset = IVaultV2(_parentVault).asset();\n        require(asset == _box.asset(), AssetMismatch());\n        SafeERC20Lib.safeApprove(asset, _parentVault, type(uint256).max);\n        SafeERC20Lib.safeApprove(asset, address(_box), type(uint256).max);\n    }\n\n    function setSkimRecipient(address newSkimRecipient) external {\n        require(msg.sender == IVaultV2(parentVault).owner(), NotAuthorized());\n        skimRecipient = newSkimRecipient;\n        emit SetSkimRecipient(newSkimRecipient);\n    }\n\n    /// @dev Skims the adapter's balance of `token` and sends it to `skimRecipient`.\n    /// @dev This is useful to handle rewards that the adapter has earned.\n    function skim(address token) external {\n        require(msg.sender == skimRecipient, NotAuthorized());\n        require(token != address(box), CannotSkimBoxShares());\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        SafeERC20Lib.safeTransfer(token, skimRecipient, balance);\n        emit Skim(token, balance);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the allocation and the change in allocation.\n    function allocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(box).deposit(assets, address(this));\n        // Safe casts because bounded by Vault V2 which requires totalAssets to stay below ~10^35\n        int256 newAllocation = int256(box.previewRedeem(box.balanceOf(address(this))));\n        int256 oldAllocation = int256(allocation());\n\n        return (ids(), newAllocation - oldAllocation);\n    }\n\n    /// @dev Does not log anything because the ids (logged in the parent vault) are enough.\n    /// @dev Returns the ids of the deallocation and the change in allocation.\n    function deallocate(bytes memory data, uint256 assets, bytes4, address) external returns (bytes32[] memory, int256) {\n        require(data.length == 0, InvalidData());\n        require(msg.sender == parentVault, NotAuthorized());\n\n        if (assets > 0) IERC4626(box).withdraw(assets, address(this), address(this));\n        // Safe casts because bounded by Vault V2 which requires totalAssets to stay below ~10^35\n        int256 newAllocation = int256(box.previewRedeem(box.balanceOf(address(this))));\n        int256 oldAllocation = int256(allocation());\n\n        return (ids(), newAllocation - oldAllocation);\n    }\n\n    /// @dev Returns adapter's ids.\n    function ids() public view returns (bytes32[] memory) {\n        bytes32[] memory ids_ = new bytes32[](1);\n        ids_[0] = adapterId;\n        return ids_;\n    }\n\n    function allocation() public view returns (uint256) {\n        return IVaultV2(parentVault).allocation(adapterId);\n    }\n\n    function realAssets() external view returns (uint256) {\n        return allocation() != 0 ? box.previewRedeem(box.balanceOf(address(this))) : 0;\n    }\n\n    function adapterData() external view returns (bytes memory) {\n        return abi.encode(\"this\", address(this));\n    }\n}\n",
        "FundingAave.sol": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MathLib} from \"@morpho-blue/libraries/MathLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IFunding, IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\n\ninterface IPool {\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external returns (uint256);\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n    function setUserEMode(uint8 categoryId) external;\n    function getUserEMode(address user) external view returns (uint256);\n    function getEModeCategoryData(\n        uint8 categoryId\n    ) external view returns (uint16 ltv, uint16 liquidationThreshold, uint16 liquidationBonus, address priceSource, string memory label);\n    function getReserveEModeCategory(address asset) external view returns (uint256);\n\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function getReserveData(\n        address asset\n    )\n        external\n        view\n        returns (\n            uint256 configuration,\n            uint128 liquidityIndex,\n            uint128 currentLiquidityRate,\n            uint128 variableBorrowIndex,\n            uint128 currentVariableBorrowRate,\n            uint128 currentStableBorrowRate,\n            uint40 lastUpdateTimestamp,\n            uint16 id,\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress,\n            address interestRateStrategyAddress,\n            uint128 accruedToTreasury,\n            uint128 unbacked,\n            uint128 isolationModeTotalDebt\n        );\n\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n}\n\ninterface IScaledBalanceToken {\n    function scaledBalanceOf(address user) external view returns (uint256);\n}\n\ncontract FundingAave is IFunding {\n    using SafeERC20 for IERC20;\n    using MathLib for uint256;\n    using Math for uint256;\n\n    uint256 internal constant RAY = 1e27;\n\n    address public immutable owner;\n    IPool public immutable pool;\n    uint256 public immutable rateMode = 2; // 1 = Stable, 2 = Variable (Aave v3 constant)\n    uint8 public immutable eMode; // 0 = no e-mode\n\n    bytes[] public facilities;\n    IERC20[] public collateralTokens;\n    IERC20[] public debtTokens;\n\n    // interestRateMode: 1 = Stable, 2 = Variable (Aave v3 constant)\n\n    /**\n     * @notice Allows the contract to receive native currency\n     * @dev Required for skimming native currency back to the Box\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Fallback function to receive native currency\n     * @dev Required for skimming native currency back to the Box\n     */\n    fallback() external payable {}\n\n    constructor(address _owner, IPool _pool, uint8 _eMode) {\n        owner = _owner;\n        pool = _pool;\n        eMode = _eMode;\n        if (pool.getUserEMode(address(this)) != eMode) {\n            pool.setUserEMode(eMode);\n        }\n    }\n\n    // ========== IFunding implementations ==========\n\n    // ========== ADMIN ==========\n\n    /// @dev FundingAave always expect \"\" as facilityData\n    function addFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!isFacility(facilityData), ErrorsLib.AlreadyWhitelisted());\n        require(facilityData.length == 0, ErrorsLib.InvalidValue());\n\n        facilities.push(facilityData);\n    }\n\n    function removeFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!_isFacilityUsed(facilityData), ErrorsLib.CannotRemove());\n\n        uint256 index = _findFacilityIndex(facilityData);\n        facilities[index] = facilities[facilities.length - 1];\n        facilities.pop();\n    }\n\n    function isFacility(bytes calldata facilityData) public view override returns (bool) {\n        uint256 length = facilities.length;\n        for (uint i = 0; i < length; i++) {\n            if (keccak256(facilities[i]) == keccak256(facilityData)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function facilitiesLength() external view returns (uint256) {\n        return facilities.length;\n    }\n\n    function addCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!isCollateralToken(collateralToken), ErrorsLib.AlreadyWhitelisted());\n\n        collateralTokens.push(collateralToken);\n    }\n\n    function removeCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_collateralBalance(collateralToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 index = _findCollateralTokenIndex(collateralToken);\n        collateralTokens[index] = collateralTokens[collateralTokens.length - 1];\n        collateralTokens.pop();\n    }\n\n    function isCollateralToken(IERC20 collateralToken) public view override returns (bool) {\n        uint256 length = collateralTokens.length;\n        for (uint i = 0; i < length; i++) {\n            if (address(collateralTokens[i]) == address(collateralToken)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function collateralTokensLength() external view returns (uint256) {\n        return collateralTokens.length;\n    }\n\n    function addDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!isDebtToken(debtToken), ErrorsLib.AlreadyWhitelisted());\n\n        debtTokens.push(debtToken);\n    }\n\n    function removeDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_debtBalance(debtToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 index = _findDebtTokenIndex(debtToken);\n        debtTokens[index] = debtTokens[debtTokens.length - 1];\n        debtTokens.pop();\n    }\n\n    function isDebtToken(IERC20 debtToken) public view override returns (bool) {\n        uint256 length = debtTokens.length;\n        for (uint i = 0; i < length; i++) {\n            if (address(debtTokens[i]) == address(debtToken)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function debtTokensLength() external view returns (uint256) {\n        return debtTokens.length;\n    }\n\n    // ========== ACTIONS ==========\n\n    function skim(IERC20 token) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n\n        uint256 navBefore = this.nav(IOracleCallback(owner));\n        uint256 balance;\n\n        if (address(token) != address(0)) {\n            // ERC-20 tokens\n            balance = token.balanceOf(address(this));\n            require(balance > 0, ErrorsLib.InvalidAmount());\n            token.safeTransfer(owner, balance);\n        } else {\n            // ETH\n            balance = address(this).balance;\n            require(balance > 0, ErrorsLib.InvalidAmount());\n            payable(owner).transfer(balance);\n        }\n\n        uint256 navAfter = this.nav(IOracleCallback(owner));\n        require(navBefore == navAfter, ErrorsLib.SkimChangedNav());\n    }\n\n    /// @dev Assume caller did transfer the collateral tokens to this contract before calling\n    function pledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        IERC20(collateralToken).forceApprove(address(pool), collateralAmount);\n        pool.supply(address(collateralToken), collateralAmount, address(this), 0);\n        pool.setUserUseReserveAsCollateral(address(collateralToken), true);\n    }\n\n    function depledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        pool.withdraw(address(collateralToken), collateralAmount, owner);\n    }\n\n    function borrow(bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        pool.borrow(address(debtToken), borrowAmount, rateMode, 0, address(this));\n        debtToken.safeTransfer(owner, borrowAmount);\n    }\n\n    /// @dev Assume caller did transfer the debt tokens to this contract before calling\n    function repay(bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        debtToken.forceApprove(address(pool), repayAmount);\n        uint256 actualRepaid = pool.repay(address(debtToken), repayAmount, rateMode, address(this));\n\n        if (actualRepaid < repayAmount) {\n            debtToken.safeTransfer(owner, repayAmount - actualRepaid);\n        }\n    }\n\n    /**\n     * @notice Executes multiple calls in a single transaction\n     * @param data Array of encoded function calls\n     * @dev Allows EOAs to execute multiple operations atomically\n     */\n    function multicall(bytes[] calldata data) external {\n        uint256 length = data.length;\n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);\n            if (!success) {\n                assembly (\"memory-safe\") {\n                    revert(add(32, returnData), mload(returnData))\n                }\n            }\n        }\n    }\n\n    // ========== POSITION ==========\n\n    /// @dev ltv can also use non whitelisted collaterals (donated)\n    /// @dev returns 0 if there is no collateral\n    function ltv(bytes calldata data) external view returns (uint256) {\n        (uint256 totalCollateralBase, uint256 totalDebtBase, , , , ) = pool.getUserAccountData(address(this));\n\n        return totalCollateralBase == 0 ? 0 : totalDebtBase.wDivUp(totalCollateralBase);\n    }\n\n    function debtBalance(bytes calldata facilityData, IERC20 debtToken) public view returns (uint256) {\n        return _debtBalance(debtToken);\n    }\n\n    function collateralBalance(bytes calldata facilityData, IERC20 collateralToken) external view returns (uint256) {\n        return _collateralBalance(collateralToken);\n    }\n\n    function debtBalance(IERC20 debtToken) external view override returns (uint256) {\n        return _debtBalance(debtToken);\n    }\n\n    function collateralBalance(IERC20 collateralToken) external view override returns (uint256) {\n        return _collateralBalance(collateralToken);\n    }\n\n    /// @dev The NAV for a given lending market can be negative but there is no recourse so it can be floored to 0.\n    function nav(IOracleCallback oraclesProvider) external view returns (uint256) {\n        uint256 totalCollateralValue;\n        uint256 totalDebtValue;\n\n        // Calculate total collateral value\n        uint256 collateralLength = collateralTokens.length;\n        for (uint256 i = 0; i < collateralLength; i++) {\n            IERC20 collateralToken = collateralTokens[i];\n            uint256 collateralBalance_ = _collateralBalance(collateralToken);\n\n            if (collateralBalance_ > 0) {\n                if (address(collateralToken) == oraclesProvider.asset()) {\n                    totalCollateralValue += collateralBalance_;\n                } else {\n                    IOracle oracle = oraclesProvider.oracles(collateralToken);\n                    if (address(oracle) != address(0)) {\n                        uint256 price = oracle.price();\n                        uint256 value = collateralBalance_.mulDivDown(price, ORACLE_PRICE_SCALE);\n                        totalCollateralValue += value;\n                    }\n                }\n            }\n        }\n\n        // Calculate total debt value\n        uint256 debtLength = debtTokens.length;\n        for (uint256 i = 0; i < debtLength; i++) {\n            IERC20 debtToken = debtTokens[i];\n            uint256 debtBalance_ = _debtBalance(debtToken);\n\n            if (debtBalance_ > 0) {\n                if (address(debtToken) == oraclesProvider.asset()) {\n                    totalDebtValue += debtBalance_;\n                } else {\n                    IOracle oracle = oraclesProvider.oracles(debtToken);\n                    if (address(oracle) != address(0)) {\n                        uint256 price = oracle.price();\n                        uint256 value = debtBalance_.mulDivDown(price, ORACLE_PRICE_SCALE);\n                        totalDebtValue += value;\n                    }\n                }\n            }\n        }\n\n        // Return NAV = collateral - debt (floor at 0)\n        if (totalCollateralValue <= totalDebtValue) return 0;\n        unchecked {\n            return totalCollateralValue - totalDebtValue;\n        }\n    }\n\n    function _debtBalance(IERC20 debtToken) internal view returns (uint256 balance) {\n        (, , , , , , , , , , address variableDebtToken, , , , ) = pool.getReserveData(address(debtToken));\n        return IERC20(variableDebtToken).balanceOf(address(this));\n    }\n\n    function _collateralBalance(IERC20 collateralToken) internal view returns (uint256 balance) {\n        (, , , , , , , , address aTokenAddress, , , , , , ) = pool.getReserveData(address(collateralToken));\n        return IERC20(aTokenAddress).balanceOf(address(this));\n    }\n\n    function _isFacilityUsed(bytes calldata facilityData) internal view returns (bool) {\n        (uint256 totalCollateralBase, uint256 totalDebtBase, , , , ) = pool.getUserAccountData(address(this));\n\n        return totalCollateralBase > 0 || totalDebtBase > 0;\n    }\n\n    function _findFacilityIndex(bytes calldata facilityData) internal view returns (uint256) {\n        uint256 length = facilities.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(facilities[i]) == keccak256(facilityData)) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n\n    function _findCollateralTokenIndex(IERC20 collateralToken) internal view returns (uint256) {\n        uint256 length = collateralTokens.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (collateralTokens[i] == collateralToken) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n\n    function _findDebtTokenIndex(IERC20 debtToken) internal view returns (uint256) {\n        uint256 length = debtTokens.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (debtTokens[i] == debtToken) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n}\n",
        "Constants.sol": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2025 Steakhouse\npragma solidity >=0.8.0;\n\n// Precision for percentage calculations\nuint256 constant PRECISION = 1 ether;\n// Maximum timelock duration (4 weeks)\nuint256 constant TIMELOCK_CAP = 4 weeks;\n// Timelock duration for disabled selectors\nuint256 constant TIMELOCK_DISABLED = type(uint256).max;\n// Maximum allowed slippage percentage (1%)\nuint256 constant MAX_SLIPPAGE_LIMIT = 0.01 ether;\n// Delay from start of a shutdown to possible liquidations\nuint256 constant MAX_SHUTDOWN_WARMUP = 4 weeks;\n// Precision for oracle prices\nuint256 constant ORACLE_PRECISION = 1e36;\n// Maximum number of tokens allowed in a box\nuint256 constant MAX_TOKENS = 20;\n",
        "Box.sol": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IBox} from \"./interfaces/IBox.sol\";\nimport {IBoxFlashCallback} from \"./interfaces/IBox.sol\";\nimport {IFunding, IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport \"./libraries/Constants.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\nimport {EventsLib} from \"./libraries/EventsLib.sol\";\n\n/**\n * @title Box\n * @notice An ERC4626 vault that holds a base asset, invest in other ERC20 tokens and can borrow/lend via funding modules.\n * @dev Features role-based access control, timelocked governance, and slippage protection\n * @dev Box is not inflation or donation resistant as deposits are strictly controlled via the isFeeder role.\n * @dev Should deposit happen in an automated way (liquidity on a Vault V2) and from multiple feeders, it should be seeded first.\n * @dev Oracles can be manipulated to give an unfair price\n * @dev It is recommanded to create resiliency by using the BoxAdapterCached\n * @dev and/or by using a Vault V2 as a parent vault, which can have a reported price a but lower the NAV price and a setMaxRate()\n * @dev During flash operations there is no totalAssets() calculation possible to avoid NAV based attacks\n * @dev There is no protection against ERC4626 inflation attacks, as deposits are controlled via the isFeeder role.\n * @dev Users shouldn't be able to deposited directly or indirectly to a Box.\n * @dev The Box uses forceApprove with 0 value, making it incompatible with BNB chain\n * @dev Token removal can be stopped by sending dust amount of tokens. Can be fixed by deallocating then removing the token atomically\n * @dev The epoch-based slippage protection is relative to Box total assets, but a bad allocator can deposit all parent Vault V2\n * @dev fund into one Box to temporarily inflate its total asset and extract more value than expected.\n */\ncontract Box is IBox, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // ========== IMMUTABLE STATE ==========\n\n    /// @notice Base currency token (e.g., USDC)\n    address public immutable asset;\n\n    /// @notice Number of decimals for the vault shares (normalized to 18 for assets with fewer decimals)\n    uint8 private immutable _decimals;\n\n    /// @notice Virtual shares used for inflation attack protection\n    uint256 public immutable virtualShares;\n\n    /// @notice Duration of slippage tracking epochs\n    uint256 public immutable slippageEpochDuration;\n\n    /// @notice Duration over which shutdown slippage tolerance increases\n    uint256 public immutable shutdownSlippageDuration;\n\n    /// @notice Duration between shutdown and wind-down phase\n    uint256 public immutable shutdownWarmup;\n\n    // ========== MUTABLE STATE ==========\n\n    /// @notice Contract owner with administrative privileges\n    address public owner;\n\n    /// @notice Curator who manages tokens and funding modules\n    address public curator;\n\n    /// @notice Guardian who can trigger shutdowns and revoke timelocked actions\n    address public guardian;\n\n    /// @notice Timestamp when shutdown was triggered, no shutdown if type(uint256).max\n    uint256 public shutdownTime;\n\n    /// @notice Recipient of skimmed tokens that aren't part of the vault's strategy\n    address public skimRecipient;\n\n    /// @notice Tracks which addresses can execute allocation strategies\n    mapping(address => bool) public isAllocator;\n\n    /// @notice Tracks which addresses can deposit into the vault\n    mapping(address => bool) public isFeeder;\n\n    /// @notice List of whitelisted investment tokens\n    IERC20[] public tokens;\n\n    /// @notice Maps each token to its price oracle\n    mapping(IERC20 => IOracle) public oracles;\n\n    /// @notice Maximum allowed slippage per operation and per epoch (scaled by PRECISION = 1e18)\n    uint256 public maxSlippage;\n\n    /// @notice Accumulated slippage within current epoch (scaled by PRECISION = 1e18)\n    uint256 public accumulatedSlippage;\n\n    /// @notice Timestamp when the current slippage tracking epoch started\n    uint256 public slippageEpochStart;\n\n    /// @notice Delay duration for each function selector (in seconds)\n    mapping(bytes4 => uint256) public timelock;\n\n    /// @notice Timestamp when specific calldata becomes executable\n    mapping(bytes => uint256) public executableAt;\n\n    /// @notice List of whitelisted funding modules for borrowing/lending\n    IFunding[] public fundings;\n\n    /// @notice Quick lookup to check if a funding module is whitelisted\n    mapping(IFunding => bool) internal fundingMap;\n\n    /// @notice Depth counter for nested NAV-caching operations (flash and swaps)\n    uint8 private transient _cachedNavDepth;\n\n    /// @notice Cached NAV value during flash and swap operations to prevent manipulation\n    uint256 private transient _cachedNav;\n\n    // ========== CONSTRUCTOR ==========\n\n    /**\n     * @notice Allows the contract to receive native currency\n     * @dev Required for skimming native currency from funding modules\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Fallback function to receive native currency\n     * @dev Required for skimming native currency from funding modules\n     */\n    fallback() external payable {}\n\n    /**\n     * @notice Initializes the Box vault\n     * @param _asset Base currency token (e.g., USDC)\n     * @param _owner Initial owner address\n     * @param _curator Initial curator address\n     * @param _name ERC20 token name\n     * @param _symbol ERC20 token symbol\n     * @param _maxSlippage Max allowed slippage for a swap or aggregated over `_slippageEpochDuration`\n     * @param _slippageEpochDuration Duration for which slippage is measured\n     * @param _shutdownSlippageDuration When shutdown duration for slippage allowance to widen\n     * @param _shutdownWarmup Duration between shutdown and wind-down phase\n     */\n    constructor(\n        address _asset,\n        address _owner,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _maxSlippage,\n        uint256 _slippageEpochDuration,\n        uint256 _shutdownSlippageDuration,\n        uint256 _shutdownWarmup\n    ) ERC20(_name, _symbol) {\n        _requireNonZeroAddress(_asset);\n        _requireNonZeroAddress(_owner);\n        _requireNonZeroAddress(_curator);\n        require(_maxSlippage <= MAX_SLIPPAGE_LIMIT, ErrorsLib.SlippageTooHigh());\n        _requireNotEqual(_slippageEpochDuration, 0);\n        _requireNotEqual(_shutdownSlippageDuration, 0);\n        require(_shutdownWarmup <= MAX_SHUTDOWN_WARMUP, ErrorsLib.InvalidValue());\n\n        asset = _asset;\n        owner = _owner;\n        curator = _curator;\n        maxSlippage = _maxSlippage;\n        slippageEpochDuration = _slippageEpochDuration;\n        shutdownSlippageDuration = _shutdownSlippageDuration;\n        shutdownWarmup = _shutdownWarmup;\n        slippageEpochStart = block.timestamp;\n        shutdownTime = type(uint256).max; // No shutdown initially\n\n        // Set up decimals following VaultV2 pattern\n        uint256 assetDecimals = IERC20Metadata(asset).decimals();\n        uint256 decimalOffset = uint256(18) > assetDecimals ? uint256(18) - assetDecimals : 0;\n        _decimals = uint8(assetDecimals + decimalOffset);\n        virtualShares = 10 ** decimalOffset;\n\n        emit EventsLib.BoxCreated(\n            address(this),\n            asset,\n            owner,\n            curator,\n            _name,\n            _symbol,\n            maxSlippage,\n            slippageEpochDuration,\n            shutdownSlippageDuration,\n            shutdownWarmup\n        );\n        emit EventsLib.OwnershipTransferred(address(0), _owner);\n        emit EventsLib.CuratorUpdated(address(0), _curator);\n    }\n\n    // ========== ERC4626 IMPLEMENTATION ==========\n\n    /// @notice Returns the number of decimals for the vault shares\n    /// @dev Overrides ERC20.decimals() to support assets with different decimal values\n    function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {\n        return _decimals;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Returns the total value of assets managed by the vault\n    /// @dev Returns cached NAV during flash and swap operations to prevent manipulation\n    function totalAssets() public view returns (uint256) {\n        return _cachedNavDepth > 0 ? _cachedNav : _nav();\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Calculates shares received for a given asset amount\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return assets.mulDiv(supply + virtualShares, totalAssets() + 1, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Calculates assets received for redeeming shares\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return shares.mulDiv(totalAssets() + 1, supply + virtualShares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum assets that can be deposited\n    function maxDeposit(address) external view returns (uint256) {\n        return (isShutdown()) ? 0 : type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates share minting for a deposit\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Deposits base asset and mints shares to receiver\n    /// @dev Only authorized feeders can deposit\n    function deposit(uint256 assets, address receiver) public nonReentrant returns (uint256 shares) {\n        shares = previewDeposit(assets);\n        _depositMint(assets, shares, receiver);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum shares that can be minted\n    function maxMint(address) external view returns (uint256) {\n        return (isShutdown()) ? 0 : type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates assets needed to mint shares\n    function previewMint(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return shares.mulDiv(totalAssets() + 1, supply + virtualShares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Mints exact shares by depositing necessary base asset\n    /// @dev Only authorized feeders can mint\n    function mint(uint256 shares, address receiver) external nonReentrant returns (uint256 assets) {\n        assets = previewMint(shares);\n        _depositMint(assets, shares, receiver);\n    }\n\n    /// @dev Internal helper for deposit and mint to reduce bytecode duplication\n    function _depositMint(uint256 assets, uint256 shares, address receiver) internal {\n        _onlyFeeder();\n        _requireNotShutdown();\n        _requireNonZeroAddress(receiver);\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum assets owner can withdraw\n    function maxWithdraw(address owner_) external view returns (uint256) {\n        uint256 ownerAssets = convertToAssets(balanceOf(owner_));\n        uint256 availableLiquidity = IERC20(asset).balanceOf(address(this));\n        return ownerAssets < availableLiquidity ? ownerAssets : availableLiquidity;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates shares burned for withdrawing assets\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return assets.mulDiv(supply + virtualShares, totalAssets() + 1, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Withdraws base asset by burning owner's shares\n    /// @dev Requires sufficient shares and vault liquidity\n    function withdraw(uint256 assets, address receiver, address owner_) public nonReentrant returns (uint256 shares) {\n        shares = previewWithdraw(assets);\n        _withdrawRedeem(assets, shares, receiver, owner_);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Maximum shares owner can redeem\n    function maxRedeem(address owner_) external view returns (uint256) {\n        uint256 ownerShares = balanceOf(owner_);\n        uint256 availableLiquidity = IERC20(asset).balanceOf(address(this));\n        uint256 liquidityShares = convertToShares(availableLiquidity);\n        return ownerShares < liquidityShares ? ownerShares : liquidityShares;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Simulates assets received for redeeming shares\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Redeems shares for underlying base asset\n    /// @dev Burns shares and transfers base asset to receiver\n    function redeem(uint256 shares, address receiver, address owner_) external nonReentrant returns (uint256 assets) {\n        assets = previewRedeem(shares);\n        _withdrawRedeem(assets, shares, receiver, owner_);\n    }\n\n    /// @dev Internal helper for withdraw and redeem to reduce bytecode duplication\n    function _withdrawRedeem(uint256 assets, uint256 shares, address receiver, address owner_) internal {\n        _requireNonZeroAddress(receiver);\n\n        if (msg.sender != owner_) {\n            uint256 allowed = allowance(owner_, msg.sender);\n            if (allowed < shares) revert ErrorsLib.InsufficientAllowance();\n            if (allowed != type(uint256).max) {\n                _approve(owner_, msg.sender, allowed - shares);\n            }\n        }\n\n        if (balanceOf(owner_) < shares) revert ErrorsLib.InsufficientShares();\n        if (IERC20(asset).balanceOf(address(this)) < assets) revert ErrorsLib.InsufficientLiquidity();\n\n        _burn(owner_, shares);\n        IERC20(asset).safeTransfer(receiver, assets);\n\n        emit Withdraw(msg.sender, receiver, owner_, assets, shares);\n    }\n\n    // ========== SWAP FUNCTIONS ==========\n\n    /**\n     * @notice Transfers accidentally sent tokens to the skim recipient\n     * @param token Token to skim from the contract\n     * @dev Cannot skim the base asset or whitelisted investment tokens\n     */\n    function skim(IERC20 token) external nonReentrant {\n        require(msg.sender == skimRecipient, ErrorsLib.OnlySkimRecipient());\n        _requireNotEqualAddress(address(token), asset);\n        require(!isToken(token), ErrorsLib.CannotSkimToken());\n\n        uint256 balance;\n\n        if (address(token) != address(0)) {\n            // ERC-20 tokens\n            balance = token.balanceOf(address(this));\n            require(balance > 0, ErrorsLib.CannotSkimZero());\n            token.safeTransfer(skimRecipient, balance);\n        } else {\n            // ETH\n            balance = address(this).balance;\n            require(balance > 0, ErrorsLib.CannotSkimZero());\n            payable(skimRecipient).transfer(balance);\n        }\n\n        emit EventsLib.Skim(token, skimRecipient, balance);\n    }\n\n    /**\n     * @notice Swaps base asset for investment tokens\n     * @param token Target token to acquire\n     * @param assetsAmount Maximum amount of base asset to spend\n     * @param swapper Contract that will execute the swap\n     * @param data Custom data for the swapper implementation\n     * @return expected Expected amount of target token based on oracle price\n     * @return received Actual amount of target token received from the allocation\n     * @dev Enforces slippage protection based on oracle prices\n     * @dev During wind-down, slippage tolerance increases over time\n     */\n    function allocate(\n        IERC20 token,\n        uint256 assetsAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) public nonReentrant returns (uint256 expected, uint256 received) {\n        _startNavCache();\n\n        bool winddown = isWinddown();\n        require((isAllocator[msg.sender] && !winddown) || (winddown && _debtBalance(token) > 0), ErrorsLib.OnlyAllocatorsOrWinddown());\n        _requireIsToken(token);\n\n        uint256 oraclePrice = oracles[token].price();\n        uint256 slippageTolerance = winddown ? _winddownSlippageTolerance() : maxSlippage;\n\n        if (winddown) {\n            // Limit allocation to debt shortfall adjusted for slippage tolerance\n            uint256 debtAmount = _debtBalance(token);\n            uint256 existingBalance = token.balanceOf(address(this));\n            uint256 neededTokens = debtAmount > existingBalance ? debtAmount - existingBalance : 0;\n            uint256 neededValue = neededTokens.mulDiv(oraclePrice, ORACLE_PRECISION);\n            uint256 maxAllocation = neededValue.mulDiv(PRECISION, PRECISION - slippageTolerance);\n            require(assetsAmount <= maxAllocation, ErrorsLib.InvalidAmount());\n        }\n\n        // Execute swap\n        (uint256 assetsSpent, uint256 tokensReceived) = _executeSwap(IERC20(asset), token, assetsAmount, swapper, data);\n\n        // Calculate and validate slippage\n        uint256 expectedTokens = assetsAmount.mulDiv(ORACLE_PRECISION, oraclePrice);\n        uint256 minTokens = _calculateMinAmount(expectedTokens, slippageTolerance);\n        require(tokensReceived >= minTokens, ErrorsLib.AllocationTooExpensive());\n\n        int256 slippagePct = _calculateSlippagePct(expectedTokens, tokensReceived);\n\n        // Track slippage if we are not in winddown and have positive slippage\n        if (!winddown && tokensReceived < expectedTokens) {\n            uint256 slippageValue = (expectedTokens - tokensReceived).mulDiv(oraclePrice, ORACLE_PRECISION);\n            _increaseSlippage(slippageValue.mulDiv(PRECISION, totalAssets(), Math.Rounding.Ceil));\n        }\n\n        emit EventsLib.Allocation(token, assetsSpent, expectedTokens, tokensReceived, slippagePct, swapper, data);\n\n        _endNavCache();\n        return (expectedTokens, tokensReceived);\n    }\n\n    /**\n     * @notice Swaps investment tokens back to base asset\n     * @param token Token to sell\n     * @param tokensAmount Maximum amount of tokens to sell\n     * @param swapper Contract that will execute the swap\n     * @param data Custom data for the swapper implementation\n     * @return expected Expected amount of base asset based on oracle price\n     * @return received Actual amount of base asset received from the deallocation\n     * @dev Enforces slippage protection based on oracle prices\n     * @dev During wind-down, anyone can deallocate tokens with no outstanding debt\n     */\n    function deallocate(\n        IERC20 token,\n        uint256 tokensAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) external nonReentrant returns (uint256 expected, uint256 received) {\n        _startNavCache();\n\n        bool winddown = isWinddown();\n        require((isAllocator[msg.sender] && !winddown) || (winddown && _debtBalance(token) == 0), ErrorsLib.OnlyAllocatorsOrWinddown());\n        _requireIsToken(token);\n\n        uint256 oraclePrice = oracles[token].price();\n        uint256 slippageTolerance = winddown ? _winddownSlippageTolerance() : maxSlippage;\n\n        // Execute swap\n        (uint256 tokensSpent, uint256 assetsReceived) = _executeSwap(token, IERC20(asset), tokensAmount, swapper, data);\n\n        // Calculate and validate slippage\n        uint256 expectedAssets = tokensAmount.mulDiv(oraclePrice, ORACLE_PRECISION);\n        uint256 minAssets = _calculateMinAmount(expectedAssets, slippageTolerance);\n        require(assetsReceived >= minAssets, ErrorsLib.TokenSaleNotGeneratingEnoughAssets());\n\n        int256 slippagePct = _calculateSlippagePct(expectedAssets, assetsReceived);\n\n        // Track slippage if not in winddown and we have positive slippage\n        if (!winddown && assetsReceived < expectedAssets) {\n            // slippage is already in asset units\n            uint256 slippageValue = expectedAssets - assetsReceived;\n            _increaseSlippage(slippageValue.mulDiv(PRECISION, totalAssets(), Math.Rounding.Ceil));\n        }\n\n        emit EventsLib.Deallocation(token, tokensSpent, expectedAssets, assetsReceived, slippagePct, swapper, data);\n\n        _endNavCache();\n        return (expectedAssets, assetsReceived);\n    }\n\n    /**\n     * @notice Swaps between two investment tokens directly\n     * @param from Source token to sell\n     * @param to Target token to buy\n     * @param tokensAmount Maximum amount of source token to sell\n     * @param swapper Contract that will execute the swap\n     * @param data Custom data for the swapper implementation\n     * @return expected Expected amount of target token based on oracle prices\n     * @return received Actual amount of target token received from the reallocation\n     * @dev More gas efficient than separate deallocate + allocate\n     */\n    function reallocate(\n        IERC20 from,\n        IERC20 to,\n        uint256 tokensAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) external nonReentrant returns (uint256 expected, uint256 received) {\n        _startNavCache();\n\n        _onlyAllocator();\n        _requireNotWinddown();\n        _requireIsToken(from);\n        _requireIsToken(to);\n\n        uint256 fromOraclePrice = oracles[from].price();\n        uint256 toOraclePrice = oracles[to].price();\n\n        // Execute swap\n        (uint256 fromSpent, uint256 toReceived) = _executeSwap(from, to, tokensAmount, swapper, data);\n\n        // Calculate expected amounts and validate slippage\n        uint256 fromValue = tokensAmount.mulDiv(fromOraclePrice, ORACLE_PRECISION);\n        uint256 expectedToTokens = fromValue.mulDiv(ORACLE_PRECISION, toOraclePrice);\n        uint256 minToTokens = _calculateMinAmount(expectedToTokens, maxSlippage);\n        require(toReceived >= minToTokens, ErrorsLib.ReallocationSlippageTooHigh());\n\n        int256 slippagePct = _calculateSlippagePct(expectedToTokens, toReceived);\n\n        // Track slippage if we have positive slippage\n        // Note: No winddown check needed as reallocate cannot be called during winddown\n        if (toReceived < expectedToTokens) {\n            uint256 slippageValue = (expectedToTokens - toReceived).mulDiv(toOraclePrice, ORACLE_PRECISION);\n            _increaseSlippage(slippageValue.mulDiv(PRECISION, totalAssets(), Math.Rounding.Ceil));\n        }\n\n        emit EventsLib.Reallocation(from, to, fromSpent, expectedToTokens, toReceived, slippagePct, swapper, data);\n\n        _endNavCache();\n        return (expectedToTokens, toReceived);\n    }\n\n    // ========== FUNDING FUNCTIONS ==========\n\n    /**\n     * @notice Posts collateral to a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param collateralToken Token to pledge as collateral\n     * @param collateralAmount Amount to pledge\n     * @dev Transfers tokens to module and updates collateral position\n     */\n    function pledge(\n        IFunding fundingModule,\n        bytes calldata facilityData,\n        IERC20 collateralToken,\n        uint256 collateralAmount\n    ) external nonReentrant {\n        _onlyAllocatorNotWinddown();\n        _requireIsFunding(fundingModule);\n\n        collateralToken.safeTransfer(address(fundingModule), collateralAmount);\n        fundingModule.pledge(facilityData, collateralToken, collateralAmount);\n\n        emit EventsLib.Pledge(fundingModule, facilityData, collateralToken, collateralAmount);\n    }\n\n    /**\n     * @notice Withdraws collateral from a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param collateralToken Token to withdraw\n     * @param collateralAmount Amount to withdraw (max uint256 = all)\n     * @dev Returns tokens to vault, must maintain required collateral ratios\n     */\n    function depledge(\n        IFunding fundingModule,\n        bytes calldata facilityData,\n        IERC20 collateralToken,\n        uint256 collateralAmount\n    ) external nonReentrant {\n        _onlyAllocatorOrWinddown();\n        _requireIsFunding(fundingModule);\n\n        uint256 pledgeAmount = fundingModule.collateralBalance(facilityData, collateralToken);\n\n        if (collateralAmount == type(uint256).max) {\n            collateralAmount = pledgeAmount;\n        }\n\n        fundingModule.depledge(facilityData, collateralToken, collateralAmount);\n\n        emit EventsLib.Depledge(fundingModule, facilityData, collateralToken, collateralAmount);\n    }\n\n    /**\n     * @notice Takes out a loan from a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param debtToken Token to borrow\n     * @param borrowAmount Amount to borrow\n     * @dev Requires sufficient collateral, borrowed tokens sent to vault\n     */\n    function borrow(IFunding fundingModule, bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external nonReentrant {\n        _onlyAllocatorNotWinddown();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.borrow(facilityData, debtToken, borrowAmount);\n\n        emit EventsLib.Borrow(fundingModule, facilityData, debtToken, borrowAmount);\n    }\n\n    /**\n     * @notice Repays borrowed tokens to a lending facility\n     * @param fundingModule Module managing the facility\n     * @param facilityData Encoded facility identifier\n     * @param debtToken Token to repay\n     * @param repayAmount Amount to repay (max uint256 = full debt)\n     * @dev Transfers tokens from vault to module, reduces debt position\n     */\n    function repay(IFunding fundingModule, bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external nonReentrant {\n        _onlyAllocatorOrWinddown();\n        _requireIsFunding(fundingModule);\n\n        uint256 debtAmount = fundingModule.debtBalance(facilityData, debtToken);\n\n        if (repayAmount > debtAmount) {\n            repayAmount = debtAmount;\n        }\n\n        debtToken.safeTransfer(address(fundingModule), repayAmount);\n        fundingModule.repay(facilityData, debtToken, repayAmount);\n\n        emit EventsLib.Repay(fundingModule, facilityData, debtToken, repayAmount);\n    }\n\n    /**\n     * @notice Recovers non-position tokens from a funding module\n     * @param fundingModule Module to skim from\n     * @param token Token to recover\n     * @dev NAV must remain unchanged to prevent skimming tokenized positions\n     */\n    function skimFunding(IFunding fundingModule, IERC20 token) external nonReentrant {\n        _onlyAllocatorOrWinddown();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.skim(token);\n    }\n\n    /**\n     * @notice Provides temporary liquidity for complex operations\n     * @param flashToken Token to flash loan\n     * @param flashAmount Amount to provide temporarily\n     * @param data Custom data passed to the callback\n     * @dev Caller must implement IBoxFlashCallback and return tokens within same transaction\n     * @dev NAV is cached during flash to prevent manipulation\n     */\n    function flash(IERC20 flashToken, uint256 flashAmount, bytes calldata data) external {\n        _onlyAllocatorOrWinddown();\n        _requireNonZeroAddress(address(flashToken));\n        _requireIsTokenOrAsset(flashToken);\n        // Prevent re-entrancy. Can't use nonReentrant modifier because of conflict with allocate/deallocate/reallocate\n        require(_cachedNavDepth == 0, ErrorsLib.ReentryNotAllowed());\n\n        // Cache NAV before starting flash operation for slippage calculations\n        _startNavCache();\n\n        // Transfer flash amount FROM caller TO this contract\n        flashToken.safeTransferFrom(msg.sender, address(this), flashAmount);\n\n        // Call the callback function on the caller\n        IBoxFlashCallback(msg.sender).onBoxFlash(flashToken, flashAmount, data);\n\n        // Repay the flash loan by transferring back TO caller\n        flashToken.safeTransfer(msg.sender, flashAmount);\n\n        _endNavCache();\n\n        emit EventsLib.Flash(msg.sender, flashToken, flashAmount);\n    }\n\n    /**\n     * @notice Executes multiple calls in a single transaction\n     * @param data Array of encoded function calls\n     * @dev Allows EOAs to execute multiple operations atomically\n     */\n    function multicall(bytes[] calldata data) external {\n        uint256 length = data.length;\n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);\n            if (!success) {\n                assembly (\"memory-safe\") {\n                    revert(add(32, returnData), mload(returnData))\n                }\n            }\n        }\n    }\n\n    // ========== ADMIN FUNCTIONS ==========\n\n    /**\n     * @notice Sets the address that receives skimmed tokens\n     * @param newSkimRecipient New recipient address for skimmed tokens\n     * @dev Only owner can call this function\n     */\n    function setSkimRecipient(address newSkimRecipient) external {\n        _onlyOwner();\n        _requireNonZeroAddress(newSkimRecipient);\n        address oldRecipient = skimRecipient;\n        _requireNotEqualAddress(newSkimRecipient, oldRecipient);\n\n        skimRecipient = newSkimRecipient;\n\n        emit EventsLib.SkimRecipientUpdated(oldRecipient, newSkimRecipient);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract\n     * @param newOwner Address that will become the new owner\n     * @dev Immediately transfers all owner privileges\n     */\n    function transferOwnership(address newOwner) external {\n        _requireNonZeroAddress(newOwner);\n        address oldOwner = owner;\n        _onlyOwner();\n        _requireNotEqualAddress(newOwner, oldOwner);\n\n        owner = newOwner;\n\n        emit EventsLib.OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @notice Sets a new curator for the vault\n     * @param newCurator Address that will manage tokens and funding\n     * @dev Only owner can update the curator\n     */\n    function setCurator(address newCurator) external {\n        _onlyOwner();\n        _requireNonZeroAddress(newCurator);\n        _requireNotEqualAddress(newCurator, curator);\n\n        address oldCurator = curator;\n        curator = newCurator;\n\n        emit EventsLib.CuratorUpdated(oldCurator, newCurator);\n    }\n\n    /**\n     * @notice Sets a new guardian with emergency powers\n     * @param newGuardian Address that can trigger shutdowns and revoke actions\n     * @dev Requires timelock, only curator can execute\n     */\n    function setGuardian(address newGuardian) external {\n        _requireNotWinddown();\n        timelocked();\n        _onlyCurator();\n        _requireNonZeroAddress(newGuardian);\n        _requireNotEqualAddress(newGuardian, guardian);\n\n        address oldGuardian = guardian;\n        guardian = newGuardian;\n\n        emit EventsLib.GuardianUpdated(oldGuardian, newGuardian);\n    }\n\n    /**\n     * @notice Grants or revokes allocator privileges\n     * @param account Address to modify permissions for\n     * @param newIsAllocator True to grant allocator role, false to revoke\n     * @dev Allocators can execute investment strategies\n     */\n    function setIsAllocator(address account, bool newIsAllocator) external {\n        _onlyCurator();\n        _requireNonZeroAddress(account);\n        require(isAllocator[account] != newIsAllocator, ErrorsLib.InvalidValue());\n\n        isAllocator[account] = newIsAllocator;\n\n        emit EventsLib.AllocatorUpdated(account, newIsAllocator);\n    }\n\n    /**\n     * @notice Initiates emergency shutdown of the vault\n     * @dev Stops deposits and starts the wind-down process after warmup period\n     * @dev Guardian or curator can trigger shutdown\n     */\n    function shutdown() external {\n        require(msg.sender == guardian || msg.sender == curator, ErrorsLib.OnlyGuardianOrCuratorCanShutdown());\n        require(!isShutdown(), ErrorsLib.AlreadyShutdown());\n\n        shutdownTime = block.timestamp;\n\n        emit EventsLib.Shutdown(msg.sender);\n    }\n\n    /**\n     * @notice Cancels shutdown and returns vault to normal operation\n     * @dev Only guardian can recover, must be before wind-down phase starts\n     */\n    function recover() external {\n        require(msg.sender == guardian, ErrorsLib.OnlyGuardianCanRecover());\n        require(isShutdown(), ErrorsLib.NotShutdown());\n        require(!isWinddown(), ErrorsLib.CannotRecoverAfterWinddown());\n\n        shutdownTime = type(uint256).max;\n\n        emit EventsLib.Recover(msg.sender);\n    }\n\n    // ========== TIMELOCK GOVERNANCE ==========\n\n    /**\n     * @notice Submits a function call to the timelock queue\n     * @param data Encoded function call to be executed after delay\n     * @dev Delay duration depends on the function selector\n     */\n    function submit(bytes calldata data) external {\n        _onlyCurator();\n        require(executableAt[data] == 0, ErrorsLib.DataAlreadyTimelocked());\n        require(data.length >= 4, ErrorsLib.InvalidAmount());\n\n        bytes4 selector = bytes4(data);\n        uint256 delay = selector == IBox.decreaseTimelock.selector ? timelock[bytes4(data[4:8])] : timelock[selector];\n        executableAt[data] = block.timestamp + delay;\n\n        emit EventsLib.TimelockSubmitted(selector, data, executableAt[data], msg.sender);\n    }\n\n    /**\n     * @dev Validates and consumes a timelocked transaction\n     * @dev Checks if current calldata is timelocked and ready for execution\n     */\n    function timelocked() internal {\n        require(executableAt[msg.data] > 0, ErrorsLib.DataNotTimelocked());\n        require(block.timestamp >= executableAt[msg.data], ErrorsLib.TimelockNotExpired());\n\n        executableAt[msg.data] = 0;\n\n        emit EventsLib.TimelockExecuted(bytes4(msg.data), msg.data, msg.sender);\n    }\n\n    /**\n     * @notice Cancels a pending timelocked transaction\n     * @param data Encoded function call to cancel\n     * @dev Guardian or curator can revoke pending transactions\n     */\n    function revoke(bytes calldata data) external {\n        require(msg.sender == curator || msg.sender == guardian, ErrorsLib.OnlyCuratorOrGuardian());\n        require(executableAt[data] > 0, ErrorsLib.DataNotTimelocked());\n\n        executableAt[data] = 0;\n\n        emit EventsLib.TimelockRevoked(bytes4(data), data, msg.sender);\n    }\n\n    /**\n     * @notice Extends the timelock delay for a function\n     * @param selector Function signature to modify\n     * @param newDuration New delay in seconds (must be longer than current)\n     * @dev No timelock required to increase delays\n     */\n    function increaseTimelock(bytes4 selector, uint256 newDuration) external {\n        _onlyCurator();\n        require(newDuration <= TIMELOCK_CAP, ErrorsLib.InvalidTimelock());\n        require(newDuration > timelock[selector], ErrorsLib.TimelockDecrease());\n\n        timelock[selector] = newDuration;\n\n        emit EventsLib.TimelockIncreased(selector, newDuration, msg.sender);\n    }\n\n    /**\n     * @notice Reduces the timelock delay for a function\n     * @param selector Function signature to modify\n     * @param newDuration New delay in seconds (must be shorter than current)\n     * @dev Requires timelock to prevent governance attacks\n     */\n    function decreaseTimelock(bytes4 selector, uint256 newDuration) external {\n        timelocked();\n        _onlyCurator();\n        uint256 currentTimelock = timelock[selector];\n        require(currentTimelock != TIMELOCK_DISABLED, ErrorsLib.InvalidTimelock());\n        require(newDuration < currentTimelock, ErrorsLib.TimelockIncrease());\n\n        timelock[selector] = newDuration;\n\n        emit EventsLib.TimelockDecreased(selector, newDuration, msg.sender);\n    }\n\n    /**\n     * @notice Permanently disables a function by setting infinite timelock\n     * @param selector Function signature to disable\n     * @dev Irreversible - function becomes permanently inaccessible\n     * @dev Does not impact previsously queued changes\n     */\n    function abdicateTimelock(bytes4 selector) external {\n        _onlyCurator();\n\n        timelock[selector] = TIMELOCK_DISABLED;\n\n        emit EventsLib.TimelockIncreased(selector, TIMELOCK_DISABLED, msg.sender);\n    }\n\n    // ========== TIMELOCKED FUNCTIONS ==========\n\n    /**\n     * @notice Grants or revokes deposit privileges\n     * @param account Address to modify permissions for\n     * @param newIsFeeder True to allow deposits, false to revoke\n     * @dev Requires timelock to add feeders\n     */\n    function setIsFeeder(address account, bool newIsFeeder) external {\n        timelocked();\n        _requireNonZeroAddress(account);\n        require(isFeeder[account] != newIsFeeder, ErrorsLib.InvalidValue());\n\n        isFeeder[account] = newIsFeeder;\n\n        emit EventsLib.FeederUpdated(account, newIsFeeder);\n    }\n\n    /**\n     * @notice Sets the maximum tolerated slippage for swaps\n     * @param newMaxSlippage New limit scaled by PRECISION (e.g., 0.01e18 = 1%)\n     * @dev Requires timelock, applies per-swap and per-epoch\n     */\n    function setMaxSlippage(uint256 newMaxSlippage) external {\n        timelocked();\n        require(newMaxSlippage <= MAX_SLIPPAGE_LIMIT, ErrorsLib.SlippageTooHigh());\n        _requireNotEqual(newMaxSlippage, maxSlippage);\n\n        uint256 oldMaxSlippage = maxSlippage;\n        maxSlippage = newMaxSlippage;\n\n        emit EventsLib.MaxSlippageUpdated(oldMaxSlippage, newMaxSlippage);\n    }\n\n    /**\n     * @notice Whitelists a new investment token\n     * @param token Token contract to add\n     * @param oracle Price feed for the token\n     * @dev Requires timelock, oracle must return prices in base asset terms\n     */\n    function addToken(IERC20 token, IOracle oracle) external {\n        timelocked();\n        _requireNonZeroAddress(address(token));\n        _requireNotEqualAddress(address(token), asset);\n        require(address(oracle) != address(0), ErrorsLib.OracleRequired());\n        require(!isToken(token), ErrorsLib.TokenAlreadyWhitelisted());\n        require(tokens.length < MAX_TOKENS, ErrorsLib.TooManyTokens());\n\n        tokens.push(token);\n        oracles[token] = oracle;\n\n        emit EventsLib.TokenAdded(token, oracle);\n    }\n\n    /**\n     * @notice Removes a token from the whitelist\n     * @param token Token to delist\n     * @dev Token balance must be zero and not used in any funding module\n     */\n    function removeToken(IERC20 token) external {\n        _onlyCurator();\n        _requireIsToken(token);\n        require(token.balanceOf(address(this)) == 0, ErrorsLib.TokenBalanceMustBeZero());\n        require(!_isTokenUsedInFunding(token), ErrorsLib.CannotRemove());\n\n        uint256 length = tokens.length;\n        for (uint256 i; i < length; i++) {\n            if (tokens[i] == token) {\n                tokens[i] = tokens[length - 1];\n                tokens.pop();\n                break;\n            }\n        }\n\n        delete oracles[token];\n\n        emit EventsLib.TokenRemoved(token);\n    }\n\n    /**\n     * @notice Updates the price oracle for a whitelisted token\n     * @param token Token to update oracle for\n     * @param oracle New price feed contract\n     * @dev Requires timelock in normal operation, guardian can update during final wind-down\n     */\n    function changeTokenOracle(IERC20 token, IOracle oracle) external {\n        if (isWinddown()) {\n            require(block.timestamp >= shutdownTime + shutdownWarmup + shutdownSlippageDuration, ErrorsLib.NotAllowed());\n            _onlyGuardian();\n        } else {\n            timelocked();\n        }\n        _requireNonZeroAddress(address(oracle));\n        _requireIsToken(token);\n        _requireNotEqualAddress(address(oracles[token]), address(oracle));\n\n        oracles[token] = oracle;\n\n        emit EventsLib.TokenOracleChanged(token, oracle);\n    }\n\n    /**\n     * @notice Adds a new funding module for borrowing/lending\n     * @param fundingModule Module contract to whitelist\n     * @dev Module must be empty with no facilities, collateral, or debt\n     */\n    function addFunding(IFunding fundingModule) external {\n        timelocked();\n        require(!fundingMap[fundingModule], ErrorsLib.AlreadyWhitelisted());\n        _requireNonZeroAddress(address(fundingModule));\n        // Check that Box is the owner of the funding module\n        (bool success, bytes memory data) = address(fundingModule).staticcall(abi.encodeWithSignature(\"owner()\"));\n        require(success && data.length == 32, ErrorsLib.InvalidValue());\n        address fundingOwner = abi.decode(data, (address));\n        require(fundingOwner == address(this), ErrorsLib.InvalidValue());\n        require(fundingModule.facilitiesLength() == 0, ErrorsLib.NotClean());\n        require(fundingModule.collateralTokensLength() == 0, ErrorsLib.NotClean());\n        require(fundingModule.debtTokensLength() == 0, ErrorsLib.NotClean());\n\n        fundingMap[fundingModule] = true;\n        fundings.push(fundingModule);\n\n        emit EventsLib.FundingModuleAdded(fundingModule);\n    }\n\n    /**\n     * @notice Registers a lending facility within a funding module\n     * @param fundingModule Module to add facility to\n     * @param facilityData Encoded facility parameters\n     * @dev Requires timelock, facility specifics depend on module implementation\n     */\n    function addFundingFacility(IFunding fundingModule, bytes calldata facilityData) external {\n        timelocked();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.addFacility(facilityData);\n\n        emit EventsLib.FundingFacilityAdded(fundingModule, facilityData);\n    }\n\n    /**\n     * @notice Enables a token as collateral in a funding module\n     * @param fundingModule Module to configure\n     * @param collateralToken Token to use as collateral\n     * @dev Token must be whitelisted in the vault first\n     */\n    function addFundingCollateral(IFunding fundingModule, IERC20 collateralToken) external {\n        timelocked();\n        _requireIsFunding(fundingModule);\n        _requireIsTokenOrAsset(collateralToken);\n\n        fundingModule.addCollateralToken(collateralToken);\n\n        emit EventsLib.FundingCollateralAdded(fundingModule, collateralToken);\n    }\n\n    /**\n     * @notice Enables a token for borrowing in a funding module\n     * @param fundingModule Module to configure\n     * @param debtToken Token that can be borrowed\n     * @dev Token must be whitelisted in the vault first\n     */\n    function addFundingDebt(IFunding fundingModule, IERC20 debtToken) external {\n        timelocked();\n        _requireIsFunding(fundingModule);\n        _requireIsTokenOrAsset(debtToken);\n\n        fundingModule.addDebtToken(debtToken);\n\n        emit EventsLib.FundingDebtAdded(fundingModule, debtToken);\n    }\n\n    /**\n     * @notice Removes a funding module from the vault\n     * @param fundingModule Module to remove\n     * @dev Module must be empty with no active facilities, collateral, or debt\n     */\n    function removeFunding(IFunding fundingModule) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        require(fundingModule.facilitiesLength() == 0, ErrorsLib.CannotRemove());\n        require(fundingModule.collateralTokensLength() == 0, ErrorsLib.CannotRemove());\n        require(fundingModule.debtTokensLength() == 0, ErrorsLib.CannotRemove());\n\n        fundingMap[fundingModule] = false;\n        uint256 index = _findFundingIndex(fundingModule);\n        fundings[index] = fundings[fundings.length - 1];\n        fundings.pop();\n\n        emit EventsLib.FundingModuleRemoved(fundingModule);\n    }\n\n    /**\n     * @notice Deregisters a lending facility from a funding module\n     * @param fundingModule Module containing the facility\n     * @param facilityData Encoded facility identifier\n     * @dev Facility must have no outstanding positions\n     */\n    function removeFundingFacility(IFunding fundingModule, bytes calldata facilityData) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.removeFacility(facilityData);\n\n        emit EventsLib.FundingFacilityRemoved(fundingModule, facilityData);\n    }\n\n    /**\n     * @notice Disables a token as collateral in a funding module\n     * @param fundingModule Module to update\n     * @param collateralToken Token to remove from collateral list\n     * @dev Token must not be actively used as collateral\n     */\n    function removeFundingCollateral(IFunding fundingModule, IERC20 collateralToken) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.removeCollateralToken(collateralToken);\n\n        emit EventsLib.FundingCollateralRemoved(fundingModule, collateralToken);\n    }\n\n    /**\n     * @notice Disables borrowing of a token in a funding module\n     * @param fundingModule Module to update\n     * @param debtToken Token to remove from debt list\n     * @dev No outstanding debt must exist for this token\n     */\n    function removeFundingDebt(IFunding fundingModule, IERC20 debtToken) external {\n        _onlyCurator();\n        _requireIsFunding(fundingModule);\n\n        fundingModule.removeDebtToken(debtToken);\n\n        emit EventsLib.FundingDebtRemoved(fundingModule, debtToken);\n    }\n\n    // ========== VIEW FUNCTIONS ==========\n    /**\n     * @notice Checks if a token is whitelisted for investment\n     * @param token Token to check\n     * @return True if the token has an associated oracle\n     */\n    function isToken(IERC20 token) public view returns (bool) {\n        return address(oracles[token]) != address(0);\n    }\n\n    /**\n     * @notice Checks if a token is the base asset or a whitelisted token\n     * @param token Token to check\n     * @return True if it's the base asset or has an oracle\n     */\n    function isTokenOrAsset(IERC20 token) public view returns (bool) {\n        return address(token) == asset || address(oracles[token]) != address(0);\n    }\n\n    /**\n     * @notice Gets the count of whitelisted tokens\n     * @return Number of tokens in the investment list\n     */\n    function tokensLength() external view returns (uint256) {\n        return tokens.length;\n    }\n\n    /**\n     * @notice Checks if a funding module is authorized\n     * @param fundingModule Module to verify\n     * @return True if the module can be used for borrowing/lending\n     */\n    function isFunding(IFunding fundingModule) public view returns (bool) {\n        return fundingMap[fundingModule];\n    }\n\n    /**\n     * @notice Gets the count of active funding modules\n     * @return Number of modules available for borrowing/lending\n     */\n    function fundingsLength() external view override returns (uint256) {\n        return fundings.length;\n    }\n\n    /**\n     * @notice Checks if the vault is in shutdown mode\n     * @return True if shutdown has been triggered\n     */\n    function isShutdown() public view returns (bool) {\n        return shutdownTime != type(uint256).max;\n    }\n\n    /**\n     * @notice Checks if the vault has entered wind-down phase\n     * @return True if past the warmup period after shutdown\n     */\n    function isWinddown() public view returns (bool) {\n        return shutdownTime != type(uint256).max && block.timestamp >= shutdownTime + shutdownWarmup;\n    }\n\n    // ========== INTERNAL FUNCTIONS ==========\n\n    /**\n     * @dev Checks if msg.sender is the owner\n     */\n    function _onlyOwner() internal view {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n    }\n\n    /**\n     * @dev Checks if msg.sender is the curator\n     */\n    function _onlyCurator() internal view {\n        require(msg.sender == curator, ErrorsLib.OnlyCurator());\n    }\n\n    /**\n     * @dev Checks that an address is not zero\n     */\n    function _requireNonZeroAddress(address addr) internal pure {\n        require(addr != address(0), ErrorsLib.InvalidAddress());\n    }\n\n    /**\n     * @dev Checks if a token is whitelisted\n     */\n    function _requireIsToken(IERC20 token) internal view {\n        require(isToken(token), ErrorsLib.TokenNotWhitelisted());\n    }\n\n    /**\n     * @dev Checks if a funding module is whitelisted\n     */\n    function _requireIsFunding(IFunding fundingModule) internal view {\n        require(isFunding(fundingModule), ErrorsLib.NotWhitelisted());\n    }\n\n    /**\n     * @dev Checks that vault is not in winddown\n     */\n    function _requireNotWinddown() internal view {\n        require(!isWinddown(), ErrorsLib.CannotDuringWinddown());\n    }\n\n    /**\n     * @dev Checks if msg.sender is allocator and not in winddown\n     */\n    function _onlyAllocatorNotWinddown() internal view {\n        require(isAllocator[msg.sender] && !isWinddown(), ErrorsLib.OnlyAllocators());\n    }\n\n    /**\n     * @dev Checks if msg.sender is allocator or in winddown\n     */\n    function _onlyAllocatorOrWinddown() internal view {\n        require(isAllocator[msg.sender] || isWinddown(), ErrorsLib.OnlyAllocatorsOrWinddown());\n    }\n\n    /**\n     * @dev Checks that two values are not equal\n     */\n    function _requireNotEqual(uint256 a, uint256 b) internal pure {\n        require(a != b, ErrorsLib.InvalidValue());\n    }\n\n    /**\n     * @dev Checks that two addresses are not equal\n     */\n    function _requireNotEqualAddress(address a, address b) internal pure {\n        require(a != b, ErrorsLib.InvalidValue());\n    }\n\n    /**\n     * @dev Checks if msg.sender is the guardian\n     */\n    function _onlyGuardian() internal view {\n        require(msg.sender == guardian, ErrorsLib.OnlyGuardian());\n    }\n\n    /**\n     * @dev Checks if msg.sender is allocator\n     */\n    function _onlyAllocator() internal view {\n        require(isAllocator[msg.sender], ErrorsLib.OnlyAllocators());\n    }\n\n    /**\n     * @dev Checks if msg.sender is feeder\n     */\n    function _onlyFeeder() internal view {\n        require(isFeeder[msg.sender], ErrorsLib.OnlyFeeders());\n    }\n\n    /**\n     * @dev Checks that vault is not shutdown\n     */\n    function _requireNotShutdown() internal view {\n        require(!isShutdown(), ErrorsLib.CannotDuringShutdown());\n    }\n\n    /**\n     * @dev Checks if token or asset is whitelisted\n     */\n    function _requireIsTokenOrAsset(IERC20 token) internal view {\n        require(isTokenOrAsset(token), ErrorsLib.TokenNotWhitelisted());\n    }\n\n    /**\n     * @dev Starts NAV caching for the current operation\n     * @dev Caches NAV on first call (depth 0 -> 1), increments depth on nested calls\n     * @dev Properly handles nesting when swaps are called from flash callbacks\n     */\n    function _startNavCache() internal {\n        if (_cachedNavDepth == 0) {\n            _cachedNav = _nav();\n        }\n        _cachedNavDepth++;\n    }\n\n    /**\n     * @dev Ends NAV caching for the current operation\n     * @dev Decrements the depth counter\n     */\n    function _endNavCache() internal {\n        _cachedNavDepth--;\n    }\n\n    /**\n     * @dev Executes a swap through a swapper contract with approval management\n     * @param fromToken Token to sell\n     * @param toToken Token to buy\n     * @param maxAmount Maximum amount of fromToken to sell\n     * @param swapper Swapper contract to execute the trade\n     * @param data Custom data for the swapper\n     * @return spent Actual amount of fromToken spent\n     * @return received Amount of toToken received\n     */\n    function _executeSwap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 maxAmount,\n        ISwapper swapper,\n        bytes calldata data\n    ) internal returns (uint256 spent, uint256 received) {\n        uint256 fromBefore = fromToken.balanceOf(address(this));\n        uint256 toBefore = toToken.balanceOf(address(this));\n\n        fromToken.forceApprove(address(swapper), maxAmount);\n        swapper.sell(fromToken, toToken, maxAmount, data);\n        fromToken.forceApprove(address(swapper), 0);\n\n        spent = fromBefore - fromToken.balanceOf(address(this));\n        received = toToken.balanceOf(address(this)) - toBefore;\n\n        require(spent <= maxAmount, ErrorsLib.SwapperDidSpendTooMuch());\n    }\n\n    /**\n     * @dev Calculates slippage percentage from expected vs actual amounts\n     * @param expectedAmount Expected amount based on oracle price\n     * @param actualAmount Actual amount received/spent\n     * @return slippagePct Slippage as a percentage scaled by PRECISION\n     */\n    function _calculateSlippagePct(uint256 expectedAmount, uint256 actualAmount) internal pure returns (int256 slippagePct) {\n        int256 slippage = expectedAmount.toInt256() - actualAmount.toInt256();\n        slippagePct = expectedAmount == 0 ? int256(0) : (slippage * PRECISION.toInt256()) / expectedAmount.toInt256();\n    }\n\n    /**\n     * @dev Calculates minimum acceptable amount based on slippage tolerance\n     * @param expectedAmount Expected amount based on oracle price\n     * @param tolerance Maximum allowed slippage scaled by PRECISION\n     * @return minAmount Minimum acceptable amount after slippage\n     */\n    function _calculateMinAmount(uint256 expectedAmount, uint256 tolerance) internal pure returns (uint256 minAmount) {\n        minAmount = expectedAmount.mulDiv(PRECISION - tolerance, PRECISION, Math.Rounding.Ceil);\n    }\n\n    /**\n     * @dev Tracks slippage within current epoch and enforces limits\n     * @param slippagePct Slippage to add scaled by PRECISION\n     * @dev Resets epoch if duration has passed\n     */\n    function _increaseSlippage(uint256 slippagePct) internal {\n        // Reset epoch if expired\n        if (block.timestamp >= slippageEpochStart + slippageEpochDuration) {\n            slippageEpochStart = block.timestamp;\n            accumulatedSlippage = slippagePct;\n            emit EventsLib.SlippageEpochReset(block.timestamp);\n        } else {\n            accumulatedSlippage += slippagePct;\n        }\n\n        require(accumulatedSlippage < maxSlippage, ErrorsLib.TooMuchAccumulatedSlippage());\n\n        emit EventsLib.SlippageAccumulated(slippagePct, accumulatedSlippage);\n    }\n\n    /**\n     * @dev Calculates total vault value across all positions\n     * @return nav Sum of base asset, token values, and funding positions\n     * @dev Negative funding NAV is floored to zero\n     * @dev Reverts if called during NAV-cached operations (swaps or flash) to prevent read-only reentrancy\n     */\n    function _nav() internal view returns (uint256 nav) {\n        require(_cachedNavDepth == 0, ErrorsLib.NoNavDuringCache());\n        nav = IERC20(asset).balanceOf(address(this));\n\n        // Add value of all tokens\n        uint256 length = tokens.length;\n        for (uint256 i; i < length; i++) {\n            IERC20 token = tokens[i];\n            IOracle oracle = oracles[token];\n            if (address(oracle) != address(0)) {\n                uint256 tokenBalance = token.balanceOf(address(this));\n                if (tokenBalance > 0) {\n                    nav += tokenBalance.mulDiv(oracle.price(), ORACLE_PRECISION);\n                }\n            }\n        }\n        // Loop over funding sources\n        length = fundings.length;\n        for (uint256 i; i < length; i++) {\n            IFunding funding = fundings[i];\n            nav += funding.nav(IOracleCallback(address(this)));\n        }\n    }\n\n    /**\n     * @dev Calculates dynamic slippage tolerance during wind-down\n     * @return Slippage limit that increases linearly over shutdown duration\n     * @dev Returns up to 1% slippage after full duration\n     */\n    function _winddownSlippageTolerance() internal view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - shutdownWarmup - shutdownTime;\n        return\n            (timeElapsed < shutdownSlippageDuration)\n                ? timeElapsed.mulDiv(MAX_SLIPPAGE_LIMIT, shutdownSlippageDuration)\n                : MAX_SLIPPAGE_LIMIT;\n    }\n\n    /**\n     * @dev Locates a funding module's position in the array\n     * @param fundingModule Module to find\n     * @return Index in the fundings array\n     * @dev Reverts if module is not whitelisted\n     */\n    function _findFundingIndex(IFunding fundingModule) internal view returns (uint256) {\n        uint256 length = fundings.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (fundings[i] == fundingModule) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n\n    /**\n     * @dev Checks if a token is used in any funding module\n     * @param token Token to check\n     * @return True if token is used as collateral or debt anywhere\n     */\n    function _isTokenUsedInFunding(IERC20 token) internal view returns (bool) {\n        uint256 length = fundings.length;\n        for (uint256 i; i < length; i++) {\n            IFunding funding = fundings[i];\n            if (funding.isCollateralToken(token) || funding.isDebtToken(token)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Sums outstanding debt for a token across all modules\n     * @param debtToken Token to check debt for\n     * @return totalDebt Combined debt balance from all facilities\n     */\n    function _debtBalance(IERC20 debtToken) internal view returns (uint256 totalDebt) {\n        uint256 length = fundings.length;\n        for (uint256 i; i < length; i++) {\n            IFunding funding = fundings[i];\n            totalDebt += funding.debtBalance(debtToken);\n        }\n    }\n}\n",
        "ErrorsLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary ErrorsLib {\n    // General errors\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidValue();\n    error CannotRemove();\n    error AlreadyWhitelisted();\n    error NotWhitelisted();\n    error NotClean();\n    error NotAllowed();\n\n    // Access control errors\n    error OnlyOwner();\n    error OnlyCurator();\n    error OnlyGuardian();\n    error OnlyCuratorOrGuardian();\n    error OnlyAllocators();\n    error OnlyFeeders();\n    error OnlySkimRecipient();\n    error OnlyAllocatorsOrWinddown();\n    error OnlyMorpho();\n    error OnlyBox();\n    error OnlyPool();\n    error OnlyThisContract();\n    error InvalidOwner();\n    error CannotDuringShutdown();\n    error CannotDuringWinddown();\n\n    // Deposit/Mint errors\n    error CannotDepositZero();\n    error CannotMintZero();\n\n    // Withdraw/Redeem errors\n    error InsufficientShares();\n    error InsufficientAllowance();\n    error InsufficientLiquidity();\n    error DataAlreadyTimelocked();\n\n    // Token errors\n    error TokenNotWhitelisted();\n    error TokenAlreadyWhitelisted();\n    error OracleRequired();\n    error NoOracleForToken();\n    error TokenBalanceMustBeZero();\n    error TooManyTokens();\n\n    // Slippage errors\n    error SwapperDidSpendTooMuch();\n    error AllocationTooExpensive();\n    error TokenSaleNotGeneratingEnoughAssets();\n    error ReallocationSlippageTooHigh();\n    error TooMuchAccumulatedSlippage();\n    error SlippageTooHigh();\n\n    // Shutdown/Recover errors\n    error OnlyGuardianOrCuratorCanShutdown();\n    error OnlyGuardianCanRecover();\n    error AlreadyShutdown();\n    error NotShutdown();\n    error CannotRecoverAfterWinddown();\n\n    // Timelock errors\n    error TimelockNotExpired();\n    error DataNotTimelocked();\n    error InvalidTimelock();\n    error TimelockDecrease();\n    error TimelockIncrease();\n\n    // Skim errors\n    error CannotSkimAsset();\n    error CannotSkimToken();\n    error AlreadySet();\n    error CannotSkimZero();\n    error SkimChangedNav();\n\n    // Funding module errors\n    error ExcessiveLTV();\n    error NoNavDuringCache();\n\n    // Flash callback errors\n    error ReentryNotAllowed();\n}\n",
        "FundingMorpho.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright (c) 2025 Steakhouse Financial\npragma solidity 0.8.28;\n\nimport {IMorpho, Id, MarketParams, Position} from \"@morpho-blue/interfaces/IMorpho.sol\";\nimport \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MarketParamsLib} from \"@morpho-blue/libraries/MarketParamsLib.sol\";\nimport {MorphoBalancesLib} from \"@morpho-blue/libraries/periphery/MorphoBalancesLib.sol\";\nimport {MorphoLib} from \"@morpho-blue/libraries/periphery/MorphoLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MathLib} from \"./../lib/morpho-blue/src/libraries/MathLib.sol\";\nimport {IFunding, IOracleCallback} from \"./interfaces/IFunding.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ErrorsLib} from \"./libraries/ErrorsLib.sol\";\n\ncontract FundingMorpho is IFunding {\n    using SafeERC20 for IERC20;\n    using MarketParamsLib for MarketParams;\n    using MorphoBalancesLib for IMorpho;\n    using MorphoLib for IMorpho;\n    using MathLib for uint256;\n\n    address public immutable owner;\n    IMorpho public immutable morpho;\n    uint256 public immutable lltvCap; // Maximum LTV/LTTV ration in 18 decimals, e.g. 80e16 for 80%\n\n    bytes[] public facilities;\n    IERC20[] public collateralTokens;\n    IERC20[] public debtTokens;\n\n    // ========== INITIALIZATION ==========\n\n    /**\n     * @notice Allows the contract to receive native currency\n     * @dev Required for skimming native currency back to the Box\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Fallback function to receive native currency\n     * @dev Required for skimming native currency back to the Box\n     */\n    fallback() external payable {}\n\n    constructor(address owner_, address morpho_, uint256 lltvCap_) {\n        require(owner_ != address(0), ErrorsLib.InvalidAddress());\n        require(morpho_ != address(0), ErrorsLib.InvalidAddress());\n        require(lltvCap_ <= 100e16, ErrorsLib.InvalidValue()); // Max 100%\n        require(lltvCap_ > 0, ErrorsLib.InvalidValue()); // Min above 0%\n\n        owner = owner_;\n        morpho = IMorpho(morpho_);\n        lltvCap = lltvCap_;\n    }\n\n    // ========== IFunding implementations ==========\n\n    // ========== ADMIN ==========\n\n    /// @dev Before adding a facility, you need to add the underlying tokens as collateral/debt tokens\n    function addFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!isFacility(facilityData), ErrorsLib.AlreadyWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(isCollateralToken(IERC20(market.collateralToken)), ErrorsLib.TokenNotWhitelisted());\n        require(isDebtToken(IERC20(market.loanToken)), ErrorsLib.TokenNotWhitelisted());\n\n        facilities.push(facilityData);\n    }\n\n    function removeFacility(bytes calldata facilityData) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!_isFacilityUsed(facilityData), ErrorsLib.CannotRemove());\n\n        uint256 index = _findFacilityIndex(facilityData);\n        facilities[index] = facilities[facilities.length - 1];\n        facilities.pop();\n    }\n\n    function isFacility(bytes calldata facilityData) public view override returns (bool) {\n        uint256 length = facilities.length;\n        for (uint i = 0; i < length; i++) {\n            if (keccak256(facilities[i]) == keccak256(facilityData)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function facilitiesLength() external view returns (uint256) {\n        return facilities.length;\n    }\n\n    function addCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!isCollateralToken(collateralToken), ErrorsLib.AlreadyWhitelisted());\n\n        collateralTokens.push(collateralToken);\n    }\n\n    /// @dev Before being able to remove a collateral, no facility should reference it and the balance should be 0\n    function removeCollateralToken(IERC20 collateralToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_collateralBalance(collateralToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 length = facilities.length;\n        for (uint i = 0; i < length; i++) {\n            MarketParams memory market = decodeFacilityData(facilities[i]);\n            require(address(market.collateralToken) != address(collateralToken), ErrorsLib.CannotRemove());\n        }\n\n        uint256 index = _findCollateralTokenIndex(collateralToken);\n        collateralTokens[index] = collateralTokens[collateralTokens.length - 1];\n        collateralTokens.pop();\n    }\n\n    function isCollateralToken(IERC20 collateralToken) public view override returns (bool) {\n        uint256 length = collateralTokens.length;\n        for (uint i = 0; i < length; i++) {\n            if (address(collateralTokens[i]) == address(collateralToken)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function collateralTokensLength() external view returns (uint256) {\n        return collateralTokens.length;\n    }\n\n    function addDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(!isDebtToken(debtToken), ErrorsLib.AlreadyWhitelisted());\n\n        debtTokens.push(debtToken);\n    }\n\n    /// @dev Before being able to remove a debt, no facility should reference it and the balance should be 0\n    function removeDebtToken(IERC20 debtToken) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(_debtBalance(debtToken) == 0, ErrorsLib.CannotRemove());\n\n        uint256 length = facilities.length;\n        for (uint i = 0; i < length; i++) {\n            MarketParams memory market = decodeFacilityData(facilities[i]);\n            require(address(market.loanToken) != address(debtToken), ErrorsLib.CannotRemove());\n        }\n\n        uint256 index = _findDebtTokenIndex(debtToken);\n        debtTokens[index] = debtTokens[debtTokens.length - 1];\n        debtTokens.pop();\n    }\n\n    function isDebtToken(IERC20 debtToken) public view override returns (bool) {\n        uint256 length = debtTokens.length;\n        for (uint i = 0; i < length; i++) {\n            if (address(debtTokens[i]) == address(debtToken)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function debtTokensLength() external view returns (uint256) {\n        return debtTokens.length;\n    }\n\n    // ========== ACTIONS ==========\n    function skim(IERC20 token) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n\n        uint256 navBefore = this.nav(IOracleCallback(owner));\n        uint256 balance;\n\n        if (address(token) != address(0)) {\n            // ERC-20 tokens\n            balance = token.balanceOf(address(this));\n            require(balance > 0, ErrorsLib.InvalidAmount());\n            token.safeTransfer(owner, balance);\n        } else {\n            // ETH\n            balance = address(this).balance;\n            require(balance > 0, ErrorsLib.InvalidAmount());\n            payable(owner).transfer(balance);\n        }\n\n        uint256 navAfter = this.nav(IOracleCallback(owner));\n        require(navBefore == navAfter, ErrorsLib.SkimChangedNav());\n    }\n\n    /// @dev Assume caller did transfer the collateral tokens to this contract before calling\n    function pledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n\n        collateralToken.forceApprove(address(morpho), collateralAmount);\n        morpho.supplyCollateral(market, collateralAmount, address(this), \"\");\n    }\n\n    function depledge(bytes calldata facilityData, IERC20 collateralToken, uint256 collateralAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isCollateralToken(collateralToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n\n        morpho.withdrawCollateral(market, collateralAmount, address(this), owner);\n\n        require(ltv(facilityData) <= (market.lltv * lltvCap) / 100e16, ErrorsLib.ExcessiveLTV());\n    }\n\n    function borrow(bytes calldata facilityData, IERC20 debtToken, uint256 borrowAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n\n        morpho.borrow(market, borrowAmount, 0, address(this), owner);\n\n        require(ltv(facilityData) <= (market.lltv * lltvCap) / 100e16, ErrorsLib.ExcessiveLTV());\n    }\n\n    /// @dev Assume caller did transfer the debt tokens to this contract before calling\n    function repay(bytes calldata facilityData, IERC20 debtToken, uint256 repayAmount) external override {\n        require(msg.sender == owner, ErrorsLib.OnlyOwner());\n        require(isFacility(facilityData), ErrorsLib.NotWhitelisted());\n        require(isDebtToken(debtToken), ErrorsLib.TokenNotWhitelisted());\n\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n\n        uint256 debtAmount = morpho.expectedBorrowAssets(market, address(this));\n\n        IERC20(market.loanToken).forceApprove(address(morpho), repayAmount);\n\n        // If the amount repaid is all the debt, we convert to all shares\n        // amount repaid would internally get translated to more shares that there is to repaid\n        if (repayAmount == debtAmount) {\n            morpho.repay(market, 0, morpho.borrowShares(market.id(), address(this)), address(this), \"\");\n        } else {\n            morpho.repay(market, repayAmount, 0, address(this), \"\");\n        }\n    }\n\n    /**\n     * @notice Executes multiple calls in a single transaction\n     * @param data Array of encoded function calls\n     * @dev Allows EOAs to execute multiple operations atomically\n     */\n    function multicall(bytes[] calldata data) external {\n        uint256 length = data.length;\n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);\n            if (!success) {\n                assembly (\"memory-safe\") {\n                    revert(add(32, returnData), mload(returnData))\n                }\n            }\n        }\n    }\n\n    // ========== POSITION ==========\n\n    /// @dev returns 0 if there is no collateral\n    function ltv(bytes calldata facilityData) public view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        Id marketId = market.id();\n        uint256 borrowedAssets = morpho.expectedBorrowAssets(market, address(this));\n        uint256 collateralAmount = morpho.collateral(marketId, address(this));\n        uint256 collateralPrice = (market.oracle == address(0)) ? 0 : IOracle(market.oracle).price();\n        uint256 collateralValue = collateralAmount.mulDivDown(collateralPrice, ORACLE_PRICE_SCALE);\n        return (collateralValue == 0) ? 0 : borrowedAssets.wDivUp(collateralValue);\n    }\n\n    function debtBalance(bytes calldata facilityData, IERC20 debtToken) external view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(debtToken) == market.loanToken, \"FundingModuleMorpho: Wrong debt token\");\n        return morpho.expectedBorrowAssets(market, address(this));\n    }\n\n    function collateralBalance(bytes calldata facilityData, IERC20 collateralToken) external view override returns (uint256) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        require(address(collateralToken) == market.collateralToken, \"FundingModuleMorpho: Wrong collateral token\");\n        return morpho.collateral(market.id(), address(this));\n    }\n\n    function debtBalance(IERC20 debtToken) external view override returns (uint256) {\n        return _debtBalance(debtToken);\n    }\n\n    function collateralBalance(IERC20 collateralToken) external view override returns (uint256) {\n        return _collateralBalance(collateralToken);\n    }\n\n    /// @dev The NAV for a given lending market can be negative but there is no recourse so it can be floored to 0.\n    function nav(IOracleCallback oraclesProvider) external view returns (uint256) {\n        uint256 nav_ = 0;\n        uint256 length = facilities.length;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 facilityNav = 0;\n            MarketParams memory market = decodeFacilityData(facilities[i]);\n            uint256 collateralBalance_ = morpho.collateral(market.id(), address(this));\n\n            if (collateralBalance_ == 0) continue; // No debt if no collateral\n\n            if (market.collateralToken == oraclesProvider.asset()) {\n                // RIs are considered to have a price of ORACLE_PRECISION\n                facilityNav += collateralBalance_;\n            } else {\n                IOracle oracle = oraclesProvider.oracles(IERC20(market.collateralToken));\n                if (address(oracle) != address(0)) {\n                    facilityNav += collateralBalance_.mulDivDown(oracle.price(), ORACLE_PRICE_SCALE);\n                }\n            }\n\n            uint256 debtBalance_ = morpho.expectedBorrowAssets(market, address(this));\n\n            if (market.loanToken == oraclesProvider.asset()) {\n                facilityNav = (facilityNav > debtBalance_) ? facilityNav - debtBalance_ : 0;\n            } else {\n                IOracle oracle = oraclesProvider.oracles(IERC20(market.loanToken));\n                if (address(oracle) != address(0)) {\n                    uint256 value = debtBalance_.mulDivDown(oracle.price(), ORACLE_PRICE_SCALE);\n                    facilityNav = (facilityNav > value) ? facilityNav - value : 0;\n                }\n            }\n\n            nav_ += facilityNav;\n        }\n        return nav_;\n    }\n\n    // ========== Other exposed view functions ==========\n\n    function decodeFacilityData(bytes memory facilityData) public pure returns (MarketParams memory market) {\n        (MarketParams memory marketParams) = abi.decode(facilityData, (MarketParams));\n        return (marketParams);\n    }\n\n    function encodeFacilityData(MarketParams memory market) public pure returns (bytes memory) {\n        return abi.encode(market);\n    }\n\n    // ========== Internal functions ==========\n    function _debtBalance(IERC20 debtToken) internal view returns (uint256 balance) {\n        uint256 length = facilities.length;\n        for (uint256 i = 0; i < length; i++) {\n            MarketParams memory market = decodeFacilityData(facilities[i]);\n            if (address(debtToken) == market.loanToken) {\n                balance += morpho.expectedBorrowAssets(market, address(this));\n            }\n        }\n    }\n\n    function _collateralBalance(IERC20 collateralToken) internal view returns (uint256 balance) {\n        uint256 length = facilities.length;\n        for (uint256 i = 0; i < length; i++) {\n            MarketParams memory market = decodeFacilityData(facilities[i]);\n            if (address(collateralToken) == market.collateralToken) {\n                balance += morpho.collateral(market.id(), address(this));\n            }\n        }\n    }\n\n    function _isFacilityUsed(bytes calldata facilityData) internal view returns (bool) {\n        MarketParams memory market = decodeFacilityData(facilityData);\n        Position memory position = morpho.position(market.id(), address(this));\n        return position.collateral > 0 || position.borrowShares > 0;\n    }\n\n    function _findFacilityIndex(bytes calldata facilityData) internal view returns (uint256) {\n        bytes32 facilityHash = keccak256(facilityData);\n        uint256 length = facilities.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(facilities[i]) == facilityHash) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n\n    function _findCollateralTokenIndex(IERC20 collateralToken) internal view returns (uint256) {\n        uint256 length = collateralTokens.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (collateralTokens[i] == collateralToken) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n\n    function _findDebtTokenIndex(IERC20 debtToken) internal view returns (uint256) {\n        uint256 length = debtTokens.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (debtTokens[i] == debtToken) {\n                return i;\n            }\n        }\n        revert ErrorsLib.NotWhitelisted();\n    }\n}\n"
    }
}