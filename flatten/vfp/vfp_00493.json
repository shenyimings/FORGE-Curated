{
    "vfp_id": "vfp_00493",
    "project_name": "Parallel Protocol - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "updateMerkleDrop's safety check might end up not checking accurately",
            "description": "The updateMerkleDrop function checks if the contract has sufficient token balance to cover the new merkle drop amount using TOKEN.balanceOf(address(this)). However, this balance includes unclaimed rewards from current and expired epochs, making the check inaccurate. The root cause is the use of total balance instead of available balance, failing to account for already allocated rewards. This could allow setting a new merkle drop even when insufficient funds are available for new distributions. The impact is potential failure of future reward claims if the contract runs out of tokens, damaging user trust and protocol reliability. Although acknowledged, this remains a risk if forwardExpiredRewards is not called promptly.\n",
            "severity": "Low",
            "location": [
                "RewardMerkleDistributor.sol::updateMerkleDrop"
            ],
            "files": [
                "cd3992aec0847063c2b979c51f6cac7dd2ff03bd/tokenomics/contracts/rewardMerkleDistributor/RewardMerkleDistributor.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "The epoch should only be updated once",
            "description": "The updateMerkleDrop function in RewardMerkleDistributor.sol allows updating the merkle drop data for a given epoch without checking if that epoch has already been set. This could allow an admin to overwrite an existing epoch's configuration, which would break the reward claiming system since totalClaimedPerEpoch and hasClaimed mappings are tied to the epoch. The root cause is the absence of a guard clause preventing re-initialization of an epoch. Although the function is restricted to authorized callers, a mistake or malicious actor could overwrite critical reward data. The impact includes disruption of reward distribution, potential double-distribution or denial of valid claims, and corruption of the reward system state.\n",
            "severity": "Low",
            "location": [
                "RewardMerkleDistributor.sol#L180",
                "RewardMerkleDistributor.sol::updateMerkleDrop"
            ],
            "files": [
                "cd3992aec0847063c2b979c51f6cac7dd2ff03bd/tokenomics/contracts/rewardMerkleDistributor/RewardMerkleDistributor.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardMerkleDistributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { AccessManaged } from \"@openzeppelin/contracts/access/manager/AccessManaged.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title RewardMerkleDistributor\n/// @author Cooper Labs\n/// @custom:contact security@cooperlabs.org\n/// @notice Contract to distribute rewards using a merkle tree.\ncontract RewardMerkleDistributor is AccessManaged, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //-------------------------------------------\n    // Storage\n    //-------------------------------------------\n\n    struct MerkleDrop {\n        bytes32 root;\n        uint256 totalAmount;\n        uint64 startTime;\n        uint64 expiryTime;\n    }\n\n    struct ClaimCallData {\n        uint64 epochId;\n        address account;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    /// @dev The length of a claim/allocate epoch\n    uint64 public constant EPOCH_LENGTH = 28 days;\n    /// @notice The token to distribute.\n    IERC20 public immutable TOKEN;\n    /// @notice address that will received unclaimed token after epoch' expired time.\n    address public expiredRewardsRecipient;\n    /// @notice The total amount of tokens claimed.\n    uint256 public totalClaimed;\n    /// @notice The merkle drops.\n    mapping(uint64 epochId => MerkleDrop merkleDrop) public merkleDrops;\n    /// @notice The rewards already claimed.\n    mapping(address account => mapping(uint64 epochId => bool hasClaimed)) public hasClaimed;\n    /// @notice Tracks total amount of user claimed amounts.\n    mapping(address account => uint256 totalClaimed) public totalClaimedPerUser;\n    /// @notice Maps total claimed amount per epoch.\n    mapping(uint64 epochId => uint256 totalClaimed) public totalClaimedPerEpoch;\n\n    //-------------------------------------------\n    // Events\n    //-------------------------------------------\n\n    /// @notice Emitted when the root is updated.\n    /// @param epochId The epoch id.\n    /// @param root The merkle's tree root.\n    /// @param totalAmount The totalAmount to distribute.\n    /// @param startTime The start time of the epoch.\n    /// @param endTime The time at which all none claimed token will be send to the expiredRewardsRecipient address.\n    event MerkleDropUpdated(uint64 epochId, bytes32 root, uint256 totalAmount, uint64 startTime, uint64 endTime);\n\n    /// @notice Emitted when tokens are rescued.\n    /// @param token The address of the token.\n    /// @param to The address of the recipient.\n    /// @param amount The amount of tokens rescued.\n    event EmergencyRescued(address token, address to, uint256 amount);\n\n    /// @notice Emitted when an account claims rewards.\n    /// @param epochId The epochId claimed.\n    /// @param account The address of the claimer.\n    /// @param amount The amount of rewards claimed.\n    event RewardsClaimed(uint64 epochId, address account, uint256 amount);\n\n    /// @notice Emitted when expired rewards are forwarded.\n    /// @param epochId The epochId forwarded.\n    /// @param amount The amount of rewards forwarded.\n    event ExpiredRewardsForwarded(uint64 epochId, uint256 amount);\n\n    /// @notice Emitted when the expired rewards recipient is updated.\n    /// @param _newExpiredRewardsRecipient The new expired rewards recipient.\n    event ExpiredRewardsRecipientUpdated(address _newExpiredRewardsRecipient);\n\n    //-------------------------------------------\n    // Errors\n    //-------------------------------------------\n    /// @notice Thrown when the address == address(0).\n    error AddressZero();\n    /// @notice Thrown when the proof is invalid or expired.\n    error ProofInvalid();\n    /// @notice Thrown when the claimer has already claimed the rewards.\n    error AlreadyClaimed();\n    /// @notice Thrown when epoch expired.\n    error EpochExpired();\n    /// @notice Thrown when epoch didn't expired.\n    error EpochNotExpired();\n    /// @notice Thrown when claim windows didn't not start.\n    error NotStarted();\n    /// @notice Thrown when totalAmountClaimed for the epoch after a claim will exceed the total amount to distribute.\n    error TotalEpochRewardsExceeded();\n    /// @notice Thrown when the epochIds array is empty.\n    error EmptyArray();\n\n    //-------------------------------------------\n    // Constructor\n    //-------------------------------------------\n\n    /// @notice Constructs RewardsDistributor contract.\n    /// @param _accessManager The address of the AccessManager.\n    /// @param _token The address of the token to distribute.\n    /// @param _expiredRewardsRecipient The address of the recipient of the expired rewards.\n    constructor(\n        address _accessManager,\n        address _token,\n        address _expiredRewardsRecipient\n    )\n        AccessManaged(_accessManager)\n    {\n        if (_expiredRewardsRecipient == address(0)) revert AddressZero();\n        TOKEN = IERC20(_token);\n        expiredRewardsRecipient = _expiredRewardsRecipient;\n    }\n\n    //-------------------------------------------\n    // External Functions\n    //-------------------------------------------\n\n    /// @notice Claims rewards for multi Epoch.\n    /// @param _claimsData The claim data array info.\n    function claims(ClaimCallData[] calldata _claimsData) external whenNotPaused nonReentrant {\n        uint256 len = _claimsData.length;\n        if (len == 0) revert EmptyArray();\n        uint256 i;\n        for (; i < len; ++i) {\n            _claim(_claimsData[i].epochId, _claimsData[i].account, _claimsData[i].amount, _claimsData[i].merkleProof);\n        }\n    }\n\n    /// @notice Transfer expired rewards to the expiredRewardsRecipient.\n    /// @param _epochIds The list of epoch that will be claimed.\n    function forwardExpiredRewards(uint64[] calldata _epochIds) external {\n        uint256 len = _epochIds.length;\n        if (len == 0) revert EmptyArray();\n        uint256 i;\n        uint256 totalExpiredRewards;\n        for (; i < len; ++i) {\n            uint64 epochId = _epochIds[i];\n            uint256 expiredRewards = _getEpochExpiredRewards(epochId);\n            totalExpiredRewards += expiredRewards;\n            totalClaimedPerEpoch[epochId] += expiredRewards;\n\n            emit ExpiredRewardsForwarded(epochId, expiredRewards);\n        }\n        totalClaimed += totalExpiredRewards;\n        TOKEN.safeTransfer(expiredRewardsRecipient, totalExpiredRewards);\n    }\n\n    /// @notice Get the total rewards that can be forward to the recipient address for the list of epoch.\n    /// @dev will revert if an epoch is not expired.\n    /// @param _epochIds The list of epoch to check.\n    function getExpiredEpochRewards(uint64[] calldata _epochIds) external view returns (uint256 totalExpiredRewards) {\n        uint256 len = _epochIds.length;\n        if (len == 0) revert EmptyArray();\n        uint256 i;\n        for (; i < len; ++i) {\n            totalExpiredRewards += _getEpochExpiredRewards(_epochIds[i]);\n        }\n    }\n\n    //-------------------------------------------\n    // AccessManaged Functions\n    //-------------------------------------------\n\n    /// @notice Updates the merkleDrop for a specific epoch.\n    /// @dev This function can only be called by AccessManager.\n    /// @param _epoch The epoch to update.\n    /// @param _merkleDrop The merkleDrop to update.\n    function updateMerkleDrop(uint64 _epoch, MerkleDrop memory _merkleDrop) external restricted {\n        if (_merkleDrop.expiryTime - _merkleDrop.startTime < EPOCH_LENGTH) revert EpochExpired();\n        merkleDrops[_epoch] = _merkleDrop;\n        emit MerkleDropUpdated(\n            _epoch, _merkleDrop.root, _merkleDrop.totalAmount, _merkleDrop.startTime, _merkleDrop.expiryTime\n        );\n    }\n\n    /// @notice Allow to rescue tokens own by the contract.\n    /// @param _token The address of the token.\n    /// @param _to The address of the recipient.\n    /// @param _amount The amount of tokens to rescue.\n    function emergencyRescue(address _token, address _to, uint256 _amount) external restricted whenPaused {\n        emit EmergencyRescued(_token, _to, _amount);\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    /// @notice Update the recipient address that will receive expired rewards.\n    /// @param _newExpiredRewardsRecipient the new recipient address.\n    function updateExpiredRewardsRecipient(address _newExpiredRewardsRecipient) external restricted {\n        if (_newExpiredRewardsRecipient == address(0)) revert AddressZero();\n        expiredRewardsRecipient = _newExpiredRewardsRecipient;\n        emit ExpiredRewardsRecipientUpdated(_newExpiredRewardsRecipient);\n    }\n\n    /// @notice Allow AccessManager to pause the contract.\n    /// @dev This function can only be called by AccessManager.\n    function pause() external restricted {\n        _pause();\n    }\n\n    /// @notice Allow AccessManager to unpause the contract\n    /// @dev This function can only be called by AccessManager\n    function unpause() external restricted {\n        _unpause();\n    }\n\n    //-------------------------------------------\n    // Internal Functions\n    //-------------------------------------------\n\n    /// @notice Claims rewards.\n    /// @param _account The address of the claimer.\n    /// @param _amount The amount that the account should claim for the epoch.\n    /// @param _proof The merkle proof that validates this claim.\n    function _claim(uint64 _epochId, address _account, uint256 _amount, bytes32[] calldata _proof) private {\n        MerkleDrop memory _merkleDrop = merkleDrops[_epochId];\n\n        uint64 currentTimetamp = uint64(block.timestamp);\n        if (currentTimetamp > _merkleDrop.expiryTime) revert EpochExpired();\n        if (currentTimetamp < _merkleDrop.startTime) revert NotStarted();\n        if (hasClaimed[_account][_epochId]) revert AlreadyClaimed();\n        /// @dev Merkle leaves are double-hashed to avoid second preimage attack:\n        /// https://www.rareskills.io/post/merkle-tree-second-preimage-attack\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_epochId, _account, _amount))));\n        bool isValidProof = MerkleProof.verify(_proof, _merkleDrop.root, leaf);\n        if (!isValidProof) revert ProofInvalid();\n        totalClaimed += _amount;\n        totalClaimedPerEpoch[_epochId] += _amount;\n        if (totalClaimedPerEpoch[_epochId] > _merkleDrop.totalAmount) revert TotalEpochRewardsExceeded();\n\n        hasClaimed[_account][_epochId] = true;\n        totalClaimedPerUser[_account] += _amount;\n        emit RewardsClaimed(_epochId, _account, _amount);\n        TOKEN.safeTransfer(_account, _amount);\n    }\n\n    function _getEpochExpiredRewards(uint64 _epochId) private view returns (uint256 epochExpiredRewards) {\n        MerkleDrop memory _merkleDrop = merkleDrops[_epochId];\n        if (_merkleDrop.expiryTime >= uint64(block.timestamp)) revert EpochNotExpired();\n        epochExpiredRewards = _merkleDrop.totalAmount - totalClaimedPerEpoch[_epochId];\n    }\n}\n"
    }
}