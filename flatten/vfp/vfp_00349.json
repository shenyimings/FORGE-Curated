{
    "vfp_id": "vfp_00349",
    "project_name": "Polygon Staking - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "Centralization risk of upgradability.",
            "description": "The `PolygonVault` and `PolygonFundFlowController` contracts are upgradable, meaning their logic can be changed post-deployment by the owner. This introduces a centralization risk, as a malicious or compromised owner could upgrade the contracts to steal funds, disable functionality, or alter behavior in ways that harm users.\n\nThe root cause is the reliance on a single owner for upgrades without decentralized governance or multi-signature controls. While upgradability provides flexibility, it also creates a single point of failure.\n\nAn attacker who gains control of the owner key could exploit this by deploying malicious contract versions that drain funds or lock users out. Even with honest intentions, the owner's unilateral control undermines trust in the system's decentralization.\n\nThe impact is a systemic risk to user funds and protocol integrity, as users must trust the owner not to act maliciously or negligently.\n",
            "severity": "Informational",
            "location": [
                "PolygonVault",
                "PolygonFundFlowController"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonVault.sol",
                "contracts/contracts/polygonStaking/PolygonFundFlowController.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Hardcoded rate precision",
            "description": "The `PolygonVault` contract implements its own `_getRatePrecision` function, which is copied from the upstream `ValidatorShare` contract. This creates a dependency on the internal logic of the upstream contract, assuming that the rate precision rules will not change. If the upstream contract modifies its precision logic, the `PolygonVault` implementation may become incorrect.\n\nThe root cause is the duplication of logic instead of relying on the upstream contract's public interface. The contract uses internal calculations based on validator ID ranges to determine precision, but this is not guaranteed to remain consistent with future updates to the `ValidatorShare` contract.\n\nAn attacker could exploit this by influencing or triggering an upstream contract upgrade that changes the rate precision logic, causing `PolygonVault` to miscalculate principal deposits and leading to incorrect staking behavior or financial loss.\n\nThe impact is a potential future vulnerability if the upstream contract evolves, leading to incorrect exchange rate calculations and financial discrepancies in staking operations.\n",
            "severity": "Low",
            "location": [
                "PolygonVault.sol::getPrincipalDeposits",
                "PolygonVault.sol::_getRatePrecision"
            ],
            "files": [
                "contracts/contracts/polygonStaking/PolygonVault.sol"
            ]
        }
    ],
    "affected_files": {
        "PolygonVault.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IPolygonStakeManager.sol\";\nimport \"./interfaces/IPolygonStaking.sol\";\n\n/**\n * @title Polygon Vault\n * @notice Manages deposits of POL into a validator delegation contract\n */\ncontract PolygonVault is Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\n    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10 ** 29;\n\n    // address of staking token\n    IERC20Upgradeable public token;\n    // address of strategy that controls this vault\n    address public vaultController;\n    // address of Polygon stake manager\n    IPolygonStakeManager public stakeManager;\n    // address of Polygon delegation contract for this vault's validator\n    IPolygonStaking public validatorPool;\n\n    error OnlyVaultController();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes contract\n     * @param _token address of POL token\n     * @param _vaultController address of strategy that controls this vault\n     * @param _stakeManager address of Polygon stake manager\n     * @param _validatorPool address of Polygon delegation contract for this vault's validator\n     **/\n    function initialize(\n        address _token,\n        address _vaultController,\n        address _stakeManager,\n        address _validatorPool\n    ) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        token = IERC20Upgradeable(_token);\n        vaultController = _vaultController;\n        stakeManager = IPolygonStakeManager(_stakeManager);\n        validatorPool = IPolygonStaking(_validatorPool);\n        token.safeApprove(_stakeManager, type(uint256).max);\n    }\n\n    /**\n     * @notice Reverts if sender is not vault controller\n     **/\n    modifier onlyVaultController() {\n        if (msg.sender != vaultController) revert OnlyVaultController();\n        _;\n    }\n\n    /**\n     * @notice Deposits tokens from the vault controller into the validator pool\n     * @param _amount amount to deposit\n     */\n    function deposit(uint256 _amount) external onlyVaultController {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        validatorPool.buyVoucherPOL(_amount, 0);\n\n        uint256 balance = token.balanceOf(address(this));\n        if (balance != 0) token.safeTransfer(msg.sender, balance);\n    }\n\n    /**\n     * @notice Withdraws tokens from the validator pool and sends them to the vault controller\n     */\n    function withdraw() external onlyVaultController returns (uint256) {\n        validatorPool.unstakeClaimTokensPOL();\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(msg.sender, amount);\n        return amount;\n    }\n\n    /**\n     * @notice Queues tokens for withdrawal in the validator pool\n     * @param _amount amount to unbond\n     */\n    function unbond(uint256 _amount) external onlyVaultController {\n        validatorPool.sellVoucherPOL(_amount, type(uint256).max);\n\n        uint256 balance = token.balanceOf(address(this));\n        if (balance != 0) token.safeTransfer(msg.sender, balance);\n    }\n\n    /**\n     * @notice Restakes rewards in the validator pool\n     **/\n    function restakeRewards() external {\n        if (getRewards() != 0) {\n            validatorPool.restakePOL();\n        }\n    }\n\n    /**\n     * @notice Withdraws rewards from the validator pool\n     **/\n    function withdrawRewards() external onlyVaultController {\n        if (getRewards() != 0) {\n            validatorPool.withdrawRewardsPOL();\n        }\n\n        uint256 balance = token.balanceOf(address(this));\n        token.safeTransfer(msg.sender, balance);\n    }\n\n    /**\n     * @notice Returns the total balance of this contract\n     * @dev includes principal, rewards, queued withdrawals, and tokens held by this contract\n     * @return total balance\n     */\n    function getTotalDeposits() public view returns (uint256) {\n        return\n            getPrincipalDeposits() +\n            getRewards() +\n            getQueuedWithdrawals() +\n            token.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Returns the principal balance of this contract in the validator pool\n     * @return principal balance\n     */\n    function getPrincipalDeposits() public view returns (uint256) {\n        return\n            (validatorPool.balanceOf(address(this)) * validatorPool.exchangeRate()) /\n            _getRatePrecision();\n    }\n\n    /**\n     * @notice Returns the claimable rewards balance of this contract in the validator pool\n     * @return rewards balance\n     */\n    function getRewards() public view returns (uint256) {\n        return validatorPool.getLiquidRewards(address(this));\n    }\n\n    /**\n     * @notice Returns the amount of queued withdrawals for this contract in the validator pool\n     * @return amount of queued withdrawals\n     */\n    function getQueuedWithdrawals() public view returns (uint256) {\n        (uint256 shares, ) = validatorPool.unbonds(address(this));\n        return (shares * validatorPool.withdrawExchangeRate()) / _getRatePrecision();\n    }\n\n    /**\n     * @notice Returns whether deposits can be withdrawn from the validator pool\n     * @return whether deposits can be withdrawn\n     */\n    function isWithdrawable() external view returns (bool) {\n        (uint256 shares, uint256 withdrawEpoch) = validatorPool.unbonds(address(this));\n        return\n            shares != 0 && stakeManager.epoch() >= (withdrawEpoch + stakeManager.withdrawalDelay());\n    }\n\n    /**\n     * @notice Returns whether this vault is currently unbonding\n     * @return whether vault is unbonding\n     */\n    function isUnbonding() external view returns (bool) {\n        (, uint256 withdrawEpoch) = validatorPool.unbonds(address(this));\n        return stakeManager.epoch() < (withdrawEpoch + stakeManager.withdrawalDelay());\n    }\n\n    /**\n     * @notice Returns the minimum amount of rewards that can be claimed/restaked\n     * @return min amount of rewards\n     */\n    function minRewardClaimAmount() external view returns (uint256) {\n        return validatorPool.minAmount();\n    }\n\n    /**\n     * @notice Returns the rate precision for share exchange rates in validator pool\n     * @return rate precision\n     */\n    function _getRatePrecision() private view returns (uint256) {\n        uint256 validatorId = validatorPool.validatorId();\n\n        // if foundation validator, use old precision\n        if (validatorId < 8) {\n            return EXCHANGE_RATE_PRECISION;\n        }\n\n        return EXCHANGE_RATE_HIGH_PRECISION;\n    }\n\n    /**\n     * @dev Checks authorization for contract upgrades\n     */\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}\n",
        "PolygonFundFlowController.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../core/interfaces/IWithdrawalPool.sol\";\nimport \"./interfaces/IPolygonStrategy.sol\";\nimport \"./interfaces/IPolygonVault.sol\";\n\n/**\n * @title Polygon Fund Flow Controller\n * @notice Manages deposits and withdrawals for Polygon staking vaults\n */\ncontract PolygonFundFlowController is UUPSUpgradeable, OwnableUpgradeable {\n    // address of staking strategy\n    IPolygonStrategy public strategy;\n    // address of withdrawal pool\n    IWithdrawalPool public withdrawalPool;\n\n    // address authorized to deposit queued tokens into vaults\n    address public depositController;\n\n    // min number of seconds between unbonding calls\n    uint64 public minTimeBetweenUnbonding;\n    // time of last unbonding call\n    uint64 public timeOfLastUnbond;\n\n    event SetMinTimeBetweenUnbonding(uint64 minTimeBetweenUnbonding);\n\n    error SenderNotAuthorized();\n    error NoUnbondingNeeded();\n    error InvalidAddress();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes contract\n     * @param _strategy address of staking strategy\n     * @param _withdrawalPool address of withdrawal pool\n     * @param _depositController address authorized to deposit queued tokens into vaults\n     * @param _minTimeBetweenUnbonding min number of seconds between unbonding calls\n     **/\n    function initialize(\n        address _strategy,\n        address _withdrawalPool,\n        address _depositController,\n        uint64 _minTimeBetweenUnbonding\n    ) public initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        strategy = IPolygonStrategy(_strategy);\n        withdrawalPool = IWithdrawalPool(_withdrawalPool);\n        depositController = _depositController;\n        minTimeBetweenUnbonding = _minTimeBetweenUnbonding;\n    }\n\n    /**\n     * @notice Reverts if sender is not deposit controller\n     */\n    modifier onlyDepositController() {\n        if (msg.sender != depositController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Returns whether tokens can be deposited\n     * @return true if tokens can be deposited, false otherwise\n     */\n    function canDepositQueuedTokens() external view returns (bool) {\n        return strategy.numVaultsUnbonding() == 0;\n    }\n\n    /**\n     * @notice Deposits queued tokens into vaults\n     * @param _vaultIds list of vaults to deposit into\n     * @param _amounts list of amounts to deposit into each respective vault\n     */\n    function depositQueuedTokens(\n        uint256[] calldata _vaultIds,\n        uint256[] calldata _amounts\n    ) external onlyDepositController {\n        strategy.depositQueuedTokens(_vaultIds, _amounts);\n    }\n\n    /**\n     * @notice Returns whether vaults should be unbonded\n     * @return true if vaults should be unbonded, false otherwise\n     */\n    function shouldUnbondVaults() external view returns (bool) {\n        uint256 queuedWithdrawals = withdrawalPool.getTotalQueuedWithdrawals();\n        uint256 queuedDeposits = strategy.totalQueued();\n        (, , uint256 validatorRemovalDeposits) = strategy.validatorRemoval();\n\n        if (\n            strategy.numVaultsUnbonding() != 0 ||\n            block.timestamp < (timeOfLastUnbond + minTimeBetweenUnbonding) ||\n            queuedWithdrawals <= (queuedDeposits + validatorRemovalDeposits)\n        ) return false;\n\n        return true;\n    }\n\n    /**\n     * @notice Unbonds vaults\n     */\n    function unbondVaults() external {\n        uint256 queuedWithdrawals = withdrawalPool.getTotalQueuedWithdrawals();\n        uint256 queuedDeposits = strategy.totalQueued();\n        (, , uint256 validatorRemovalDeposits) = strategy.validatorRemoval();\n\n        if (\n            strategy.numVaultsUnbonding() != 0 ||\n            block.timestamp < (timeOfLastUnbond + minTimeBetweenUnbonding) ||\n            queuedWithdrawals <= (queuedDeposits + validatorRemovalDeposits)\n        ) revert NoUnbondingNeeded();\n\n        uint256 toWithdraw = queuedWithdrawals - (queuedDeposits + validatorRemovalDeposits);\n        strategy.unbond(toWithdraw);\n        timeOfLastUnbond = uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Unbonds vaults\n     * @dev used to rebalance deposits between vaults if necessary\n     * @param _vaultIds list of vaults to unbond\n     * @param _amounts list of amounts to unbond\n     */\n    function forceUnbondVaults(\n        uint256[] calldata _vaultIds,\n        uint256[] calldata _amounts\n    ) external onlyDepositController {\n        strategy.forceUnbond(_vaultIds, _amounts);\n    }\n\n    /**\n     * @notice Returns whether vaults are unbonded and ready to be withdrawn from\n     * @return true if vaults are ready for withdrawal, false otherwise\n     * @return list of withdrawable vaults\n     */\n    function shouldWithdrawVaults() external view returns (bool, uint256[] memory) {\n        uint256[] memory vaults = getWithdrawableVaults();\n        return (vaults.length != 0, vaults);\n    }\n\n    /**\n     * @notice Withdraws from vaults\n     * @param _vaultIds list of vaults to withdraw from\n     */\n    function withdrawVaults(uint256[] calldata _vaultIds) external {\n        strategy.unstakeClaim(_vaultIds);\n\n        (bool upkeepNeeded, ) = withdrawalPool.checkUpkeep(\"\");\n\n        if (upkeepNeeded) {\n            withdrawalPool.performUpkeep(\"\");\n        }\n    }\n\n    /**\n     * @notice Restakes vault rewards\n     * @param _vaultIds list of vaults to restake rewards for\n     */\n    function restakeRewards(uint256[] calldata _vaultIds) external {\n        strategy.restakeRewards(_vaultIds);\n    }\n\n    /**\n     * @notice Returns a list of total deposits for all vaults\n     * @return list of deposit amounts\n     */\n    function getVaultDeposits() external view returns (uint256[] memory) {\n        address[] memory vaults = strategy.getVaults();\n        uint256[] memory deposits = new uint256[](vaults.length);\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            deposits[i] = IPolygonVault(vaults[i]).getTotalDeposits();\n        }\n\n        return deposits;\n    }\n\n    /**\n     * @notice Returns a list of unclaimed rewards for all vaults\n     * @return list of reward amounts\n     */\n    function getVaultRewards() external view returns (uint256[] memory) {\n        address[] memory vaults = strategy.getVaults();\n        uint256[] memory rewards = new uint256[](vaults.length);\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            rewards[i] = IPolygonVault(vaults[i]).getRewards();\n        }\n\n        return rewards;\n    }\n\n    /**\n     * @notice Returns a list of currently unbonding vaults\n     * @dev excludes vaults that are queued for removal\n     * @return list of vaults\n     */\n    function getUnbondingVaults() external view returns (uint256[] memory) {\n        address[] memory vaults = strategy.getVaults();\n        bool[] memory vaultsUnbonding = new bool[](vaults.length);\n\n        (bool isActive, uint256 validatorId, ) = strategy.validatorRemoval();\n        uint256 skipIndex = isActive ? validatorId : type(uint256).max;\n        uint256 numVaultsUnbonding;\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            if (IPolygonVault(vaults[i]).isUnbonding() && i != skipIndex) {\n                vaultsUnbonding[i] = true;\n                ++numVaultsUnbonding;\n            }\n        }\n\n        uint256[] memory ret = new uint256[](numVaultsUnbonding);\n        uint256 numAdded;\n\n        for (uint256 i = 0; i < vaultsUnbonding.length; ++i) {\n            if (vaultsUnbonding[i]) {\n                ret[numAdded] = i;\n                ++numAdded;\n            }\n        }\n\n        return ret;\n    }\n\n    /**\n     * @notice Returns a list of currently withdrawable vaults\n     * @dev excludes vaults that are queued for removal\n     * @return list of vaults\n     */\n    function getWithdrawableVaults() public view returns (uint256[] memory) {\n        address[] memory vaults = strategy.getVaults();\n        bool[] memory vaultsWithdrawable = new bool[](vaults.length);\n\n        (bool isActive, uint256 validatorId, ) = strategy.validatorRemoval();\n        uint256 skipIndex = isActive ? validatorId : type(uint256).max;\n        uint256 numVaultsWithdrawable;\n\n        for (uint256 i = 0; i < vaults.length; ++i) {\n            if (IPolygonVault(vaults[i]).isWithdrawable() && i != skipIndex) {\n                vaultsWithdrawable[i] = true;\n                ++numVaultsWithdrawable;\n            }\n        }\n\n        uint256[] memory ret = new uint256[](numVaultsWithdrawable);\n        uint256 numAdded;\n\n        for (uint256 i = 0; i < vaultsWithdrawable.length; ++i) {\n            if (vaultsWithdrawable[i]) {\n                ret[numAdded] = i;\n                ++numAdded;\n            }\n        }\n\n        return ret;\n    }\n\n    /**\n     * @notice Sets the address authorized to deposit queued tokens\n     * @param _depositController address of deposit controller\n     */\n    function setDepositController(address _depositController) external onlyOwner {\n        if (_depositController == address(0)) revert InvalidAddress();\n        depositController = _depositController;\n    }\n\n    /**\n     * @notice Sets the min time between unbonding\n     * @param _minTimeBetweenUnbonding min time in seconds\n     */\n    function setMinTimeBetweenUnbonding(uint64 _minTimeBetweenUnbonding) external onlyOwner {\n        minTimeBetweenUnbonding = _minTimeBetweenUnbonding;\n        emit SetMinTimeBetweenUnbonding(_minTimeBetweenUnbonding);\n    }\n\n    /**\n     * @dev Checks authorization for contract upgrades\n     */\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}\n"
    }
}