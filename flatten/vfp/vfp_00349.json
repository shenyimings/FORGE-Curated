{
    "vfp_id": "vfp_00349",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small amount of AgentToken will be locked in the FPair after graduating",
            "description": "When an agent graduates via Bonding::_openTradingOnUniswap(), the amount of FERC20 tokens in the FPair is divided by 1e18 to normalize decimals. If the balance is not a multiple of 1e18, precision is lost due to truncation. This rounded-down value is used to mint AgentToken for Uniswap liquidity, while the remainder is sent to the FPair. As a result, slightly more AgentToken than intended ends up in the FPair, where it cannot be retrieved. The root cause is improper handling of decimal precision in token amount calculations. This can be exploited to cause permanent loss of tokens, though the amount per incident is small. The impact is gradual erosion of token supply, with up to 1e18-1 tokens locked per graduation event.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "FERC20 tokens lose value when they graduate to AgentTokens",
            "description": "During agent graduation, the FERC20 tokens are converted 1:1 to AgentToken and migrated to a real Uniswap pool. However, the VIRTUAL liquidity in the new pool comes from actual reserves, whereas the FPair used a \"virtual\" reserve of 6000e18 VIRTUAL tokens that were never actually deposited. This results in a lower VIRTUAL liquidity in the Uniswap pool compared to the FPair, reducing the exchange rate for AgentToken. The root cause is the discrepancy between virtual and real liquidity models. This is not directly exploitable by an attacker but creates economic loss for FERC20 holders. The impact is devaluation of user holdings upon graduation, undermining trust and creating misaligned incentives.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "FERC20 creator can launch a sale with faulty parameters",
            "description": "The Bonding contract allows a token creator to launch a bonding sale with an empty cores array, which later causes the AgentFactoryV3::initFromBondingCurve function to revert due to a requirement that cores.length > 0. The root cause is the lack of input validation in the Bonding::launch function. An attacker or malicious creator could exploit this by launching a sale with an empty cores array, causing the sale to proceed until graduation, at which point the transaction reverts and traps user funds in the FPair contract. This leads to a loss of user funds and a denial of service for the sale process, undermining trust in the protocol's reliability.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol#191",
                "AgentFactoryV3.sol#531"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Attacker can sandwich the call to BondingTax/:swapForAsset() in order to steal taxes",
            "description": "The BondingTax::swapForAsset function uses getAmountsOut to determine the minimum output for a swap but does not enforce it with slippage protection during the actual swap. Because the price query and swap are not atomic, an attacker can sandwich the swap by manipulating the pool state before and after the tax swap. The root cause is the lack of a minimum output enforcement in the swap call. The attacker profits by causing the protocol to receive fewer cbBTC than expected, effectively stealing part of the tax revenue. This leads to direct financial loss for the protocol and undermines the sustainability of the tax collection mechanism.\n",
            "severity": "Medium",
            "location": [
                "BondingTax.sol"
            ],
            "files": [
                "protocol-contracts/contracts/tax/BondingTax.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Bonding/:buy() and Bonding/:sell() lack slippage parameters",
            "description": "The Bonding::buy and Bonding::sell functions do not include slippage controls, meaning users cannot specify a minimum amount of tokens they expect to receive. The root cause is the absence of minAmountOut parameters in these functions. While the Base chain's private mempool reduces the risk of sandwich attacks, users can still suffer losses due to execution ordering, especially when large trades are processed ahead of smaller ones. This leads to a suboptimal user experience and potential economic loss, even in the absence of malicious actors, reducing trust in the fairness of the bonding curve mechanism.\n",
            "severity": "Medium",
            "location": [
                "Bonding.sol"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol",
                "protocol-contracts/contracts/fun/FRouter.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "FRouter::buy()/FRouter::sell() revert if BondingTax.sol holds 0 VIRTUAL tokens",
            "description": "The BondingTax::swapForAsset function reverts if the contract has zero VIRTUAL tokens, which can happen if buy/sell taxes are set to zero or no fees have accumulated. This causes FRouter::buy and FRouter::sell to revert, blocking user transactions. The root cause is the lack of a guard clause to handle zero-balance cases gracefully. While the impact is low due to the current tax settings, it introduces unnecessary fragility. A simple check to return early when the balance is zero would prevent reverts and ensure uninterrupted trading, improving robustness.\n",
            "severity": "Low",
            "location": [
                "BondingTax.sol"
            ],
            "files": [
                "protocol-contracts/contracts/tax/BondingTax.sol",
                "protocol-contracts/contracts/fun/FRouter.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Lack of deadline on Bonding::buy() and Bonding::sell() functions",
            "description": "The Bonding::buy() and Bonding::sell() functions do not include a deadline parameter, allowing user transactions to remain in the mempool indefinitely before execution. This occurs because there is no time-bound enforcement on transaction execution. An attacker or network congestion could delay transaction inclusion, causing the transaction to execute at a much later time than intended by the user. This could result in unfavorable price execution or unexpected state changes due to delayed actions, undermining user expectations and potentially leading to financial loss.\n",
            "severity": "Low",
            "location": [
                "Bonding.sol::buy#341",
                "Bonding.sol::sell#288"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Ineffective deadline parameters",
            "description": "The BondingTax.sol and AgentTax.sol contracts set Uniswap swap deadlines using block.timestamp + 300, which is ineffective because the deadline is evaluated at the time of the initial call, not during execution. The Uniswap router's ensure modifier checks if the deadline is greater than or equal to the current block.timestamp, but since the deadline is always set relative to the current block time, it will always pass during execution. This negates the intended protection against front-running or long-pending transactions. As a result, swaps may be executed after significant delays, increasing exposure to price slippage and reducing transaction safety.\n",
            "severity": "Low",
            "location": [
                "BondingTax.sol#173",
                "AgentTax.sol#273"
            ],
            "files": [
                "protocol-contracts/contracts/tax/BondingTax.sol",
                "protocol-contracts/contracts/tax/AgentTax.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ]
            },
            "title": "Sale data is not updated on initial FERC20 purchase",
            "description": "During the initial purchase of FERC20 tokens by the creator, the bonding contract fails to update key sale statistics such as price, market cap, liquidity, volume, and lastUpdated. This is caused by the absence of the update logic in the initial purchase path, unlike regular transactions. As a result, the displayed metrics will be inaccurate or outdated, misleading users and analytics tools about the token's performance and market activity.\n",
            "severity": "Informational",
            "location": [
                "Bonding.sol#282"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ],
                "3": [
                    "CWE-835"
                ]
            },
            "title": "No escape plan for a scenario when bonding sale never meets graduation threshold",
            "description": "The bonding sale only concludes when the FERC20 token reserve drops below gradThreshold. If this threshold is never reached, the sale remains open indefinitely, locking user funds in the FPair and preventing Agent token deployment. While EXECUTOR_ROLE can manually withdraw tokens, there is no automated or time-based fallback. This creates a risk of permanent fund lockup if market conditions prevent threshold achievement, leading to user fund loss and poor user experience.\n",
            "severity": "Informational",
            "location": [
                "Bonding.sol#391-L393"
            ],
            "files": [
                "protocol-contracts/contracts/fun/Bonding.sol"
            ]
        }
    ],
    "affected_files": {
        "FRouter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FFactory.sol\";\nimport \"./IFPair.sol\";\nimport \"../tax/IBondingTax.sol\";\n\ncontract FRouter is\n    Initializable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\n    FFactory public factory;\n    address public assetToken;\n    address public taxManager;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address factory_,\n        address assetToken_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        require(factory_ != address(0), \"Zero addresses are not allowed.\");\n        require(assetToken_ != address(0), \"Zero addresses are not allowed.\");\n\n        factory = FFactory(factory_);\n        assetToken = assetToken_;\n    }\n\n    function getAmountsOut(\n        address token,\n        address assetToken_,\n        uint256 amountIn\n    ) public view returns (uint256 _amountOut) {\n        require(token != address(0), \"Zero addresses are not allowed.\");\n\n        address pairAddress = factory.getPair(token, assetToken);\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        uint256 k = pair.kLast();\n\n        uint256 amountOut;\n\n        if (assetToken_ == assetToken) {\n            uint256 newReserveB = reserveB + amountIn;\n\n            uint256 newReserveA = k / newReserveB;\n\n            amountOut = reserveA - newReserveA;\n        } else {\n            uint256 newReserveA = reserveA + amountIn;\n\n            uint256 newReserveB = k / newReserveA;\n\n            amountOut = reserveB - newReserveB;\n        }\n\n        return amountOut;\n    }\n\n    function addInitialLiquidity(\n        address token_,\n        uint256 amountToken_,\n        uint256 amountAsset_\n    ) public onlyRole(EXECUTOR_ROLE) returns (uint256, uint256) {\n        require(token_ != address(0), \"Zero addresses are not allowed.\");\n\n        address pairAddress = factory.getPair(token_, assetToken);\n\n        IFPair pair = IFPair(pairAddress);\n\n        IERC20 token = IERC20(token_);\n\n        token.safeTransferFrom(msg.sender, pairAddress, amountToken_);\n\n        pair.mint(amountToken_, amountAsset_);\n\n        return (amountToken_, amountAsset_);\n    }\n\n    function sell(\n        uint256 amountIn,\n        address tokenAddress,\n        address to\n    ) public nonReentrant onlyRole(EXECUTOR_ROLE) returns (uint256, uint256) {\n        require(tokenAddress != address(0), \"Zero addresses are not allowed.\");\n        require(to != address(0), \"Zero addresses are not allowed.\");\n\n        address pairAddress = factory.getPair(tokenAddress, assetToken);\n\n        IFPair pair = IFPair(pairAddress);\n\n        IERC20 token = IERC20(tokenAddress);\n\n        uint256 amountOut = getAmountsOut(tokenAddress, address(0), amountIn);\n\n        token.safeTransferFrom(to, pairAddress, amountIn);\n\n        uint fee = factory.sellTax();\n        uint256 txFee = (fee * amountOut) / 100;\n\n        uint256 amount = amountOut - txFee;\n        address feeTo = factory.taxVault();\n\n        pair.transferAsset(to, amount);\n        pair.transferAsset(feeTo, txFee);\n\n        pair.swap(amountIn, 0, 0, amountOut);\n\n        if (feeTo == taxManager) {\n            IBondingTax(taxManager).swapForAsset();\n        }\n\n        return (amountIn, amountOut);\n    }\n\n    function buy(\n        uint256 amountIn,\n        address tokenAddress,\n        address to\n    ) public onlyRole(EXECUTOR_ROLE) nonReentrant returns (uint256, uint256) {\n        require(tokenAddress != address(0), \"Zero addresses are not allowed.\");\n        require(to != address(0), \"Zero addresses are not allowed.\");\n        require(amountIn > 0, \"amountIn must be greater than 0\");\n\n        address pair = factory.getPair(tokenAddress, assetToken);\n\n        uint fee = factory.buyTax();\n        uint256 txFee = (fee * amountIn) / 100;\n        address feeTo = factory.taxVault();\n\n        uint256 amount = amountIn - txFee;\n\n        IERC20(assetToken).safeTransferFrom(to, pair, amount);\n\n        IERC20(assetToken).safeTransferFrom(to, feeTo, txFee);\n\n        uint256 amountOut = getAmountsOut(tokenAddress, assetToken, amount);\n\n        IFPair(pair).transferTo(to, amountOut);\n\n        IFPair(pair).swap(0, amountOut, amount, 0);\n\n        if (feeTo == taxManager) {\n            IBondingTax(taxManager).swapForAsset();\n        }\n\n        return (amount, amountOut);\n    }\n\n    function graduate(\n        address tokenAddress\n    ) public onlyRole(EXECUTOR_ROLE) nonReentrant {\n        require(tokenAddress != address(0), \"Zero addresses are not allowed.\");\n        address pair = factory.getPair(tokenAddress, assetToken);\n        uint256 assetBalance = IFPair(pair).assetBalance();\n        FPair(pair).transferAsset(msg.sender, assetBalance);\n    }\n\n    function approval(\n        address pair,\n        address asset,\n        address spender,\n        uint256 amount\n    ) public onlyRole(EXECUTOR_ROLE) nonReentrant {\n        require(spender != address(0), \"Zero addresses are not allowed.\");\n\n        IFPair(pair).approval(spender, asset, amount);\n    }\n\n    function setTaxManager(address newManager) public onlyRole(ADMIN_ROLE) {\n        taxManager = newManager;\n    }\n}\n",
        "Bonding.sol": "// SPDX-License-Identifier: MIT\n// Modified from https://github.com/sourlodine/Pump.fun-Smart-Contract/blob/main/contracts/PumpFun.sol\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FFactory.sol\";\nimport \"./IFPair.sol\";\nimport \"./FRouter.sol\";\nimport \"./FERC20.sol\";\nimport \"../virtualPersona/IAgentFactoryV3.sol\";\n\ncontract Bonding is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    address private _feeTo;\n\n    FFactory public factory;\n    FRouter public router;\n    uint256 public initialSupply;\n    uint256 public fee;\n    uint256 public constant K = 3_000_000_000_000;\n    uint256 public assetRate;\n    uint256 public gradThreshold;\n    uint256 public maxTx;\n    address public agentFactory;\n    struct Profile {\n        address user;\n        address[] tokens;\n    }\n\n    struct Token {\n        address creator;\n        address token;\n        address pair;\n        address agentToken;\n        Data data;\n        string description;\n        uint8[] cores;\n        string image;\n        string twitter;\n        string telegram;\n        string youtube;\n        string website;\n        bool trading;\n        bool tradingOnUniswap;\n    }\n\n    struct Data {\n        address token;\n        string name;\n        string _name;\n        string ticker;\n        uint256 supply;\n        uint256 price;\n        uint256 marketCap;\n        uint256 liquidity;\n        uint256 volume;\n        uint256 volume24H;\n        uint256 prevPrice;\n        uint256 lastUpdated;\n    }\n\n    struct DeployParams {\n        bytes32 tbaSalt;\n        address tbaImplementation;\n        uint32 daoVotingPeriod;\n        uint256 daoThreshold;\n    }\n\n    DeployParams private _deployParams;\n\n    mapping(address => Profile) public profile;\n    address[] public profiles;\n\n    mapping(address => Token) public tokenInfo;\n    address[] public tokenInfos;\n\n    event Launched(address indexed token, address indexed pair, uint);\n    event Deployed(address indexed token, uint256 amount0, uint256 amount1);\n    event Graduated(address indexed token, address agentToken);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address factory_,\n        address router_,\n        address feeTo_,\n        uint256 fee_,\n        uint256 initialSupply_,\n        uint256 assetRate_,\n        uint256 maxTx_,\n        address agentFactory_,\n        uint256 gradThreshold_\n    ) external initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n\n        factory = FFactory(factory_);\n        router = FRouter(router_);\n\n        _feeTo = feeTo_;\n        fee = (fee_ * 1 ether) / 1000;\n\n        initialSupply = initialSupply_;\n        assetRate = assetRate_;\n        maxTx = maxTx_;\n\n        agentFactory = agentFactory_;\n        gradThreshold = gradThreshold_;\n    }\n\n    function _createUserProfile(address _user) internal returns (bool) {\n        address[] memory _tokens;\n\n        Profile memory _profile = Profile({user: _user, tokens: _tokens});\n\n        profile[_user] = _profile;\n\n        profiles.push(_user);\n\n        return true;\n    }\n\n    function _checkIfProfileExists(address _user) internal view returns (bool) {\n        return profile[_user].user == _user;\n    }\n\n    function _approval(\n        address _spender,\n        address _token,\n        uint256 amount\n    ) internal returns (bool) {\n        IERC20(_token).forceApprove(_spender, amount);\n\n        return true;\n    }\n\n    function setInitialSupply(uint256 newSupply) public onlyOwner {\n        initialSupply = newSupply;\n    }\n\n    function setGradThreshold(uint256 newThreshold) public onlyOwner {\n        gradThreshold = newThreshold;\n    }\n\n    function setFee(uint256 newFee, address newFeeTo) public onlyOwner {\n        fee = newFee;\n        _feeTo = newFeeTo;\n    }\n\n    function setMaxTx(uint256 maxTx_) public onlyOwner {\n        maxTx = maxTx_;\n    }\n\n    function setAssetRate(uint256 newRate) public onlyOwner {\n        require(newRate > 0, \"Rate err\");\n\n        assetRate = newRate;\n    }\n\n    function setDeployParams(DeployParams memory params) public onlyOwner {\n        _deployParams = params;\n    }\n\n    function getUserTokens(\n        address account\n    ) public view returns (address[] memory) {\n        require(_checkIfProfileExists(account), \"User Profile dose not exist.\");\n\n        Profile memory _profile = profile[account];\n\n        return _profile.tokens;\n    }\n\n    function launch(\n        string memory _name,\n        string memory _ticker,\n        uint8[] memory cores,\n        string memory desc,\n        string memory img,\n        string[4] memory urls,\n        uint256 purchaseAmount\n    ) public nonReentrant returns (address, address, uint) {\n        require(\n            purchaseAmount > fee,\n            \"Purchase amount must be greater than fee\"\n        );\n        address assetToken = router.assetToken();\n        require(\n            IERC20(assetToken).balanceOf(msg.sender) >= purchaseAmount,\n            \"Insufficient amount\"\n        );\n        uint256 initialPurchase = (purchaseAmount - fee);\n        IERC20(assetToken).safeTransferFrom(msg.sender, _feeTo, fee);\n        IERC20(assetToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            initialPurchase\n        );\n\n        FERC20 token = new FERC20(string.concat(\"fun \", _name), _ticker, initialSupply, maxTx);\n        uint256 supply = token.totalSupply();\n\n        address _pair = factory.createPair(address(token), assetToken);\n\n        bool approved = _approval(address(router), address(token), supply);\n        require(approved);\n\n        uint256 k = ((K * 10000) / assetRate);\n        uint256 liquidity = (((k * 10000 ether) / supply) * 1 ether) / 10000;\n\n        router.addInitialLiquidity(address(token), supply, liquidity);\n\n        Data memory _data = Data({\n            token: address(token),\n            name: string.concat(\"fun \", _name),\n            _name: _name,\n            ticker: _ticker,\n            supply: supply,\n            price: supply / liquidity,\n            marketCap: liquidity,\n            liquidity: liquidity * 2,\n            volume: 0,\n            volume24H: 0,\n            prevPrice: supply / liquidity,\n            lastUpdated: block.timestamp\n        });\n        Token memory tmpToken = Token({\n            creator: msg.sender,\n            token: address(token),\n            agentToken: address(0),\n            pair: _pair,\n            data: _data,\n            description: desc,\n            cores: cores,\n            image: img,\n            twitter: urls[0],\n            telegram: urls[1],\n            youtube: urls[2],\n            website: urls[3],\n            trading: true, // Can only be traded once creator made initial purchase\n            tradingOnUniswap: false\n        });\n        tokenInfo[address(token)] = tmpToken;\n        tokenInfos.push(address(token));\n\n        bool exists = _checkIfProfileExists(msg.sender);\n\n        if (exists) {\n            Profile storage _profile = profile[msg.sender];\n\n            _profile.tokens.push(address(token));\n        } else {\n            bool created = _createUserProfile(msg.sender);\n\n            if (created) {\n                Profile storage _profile = profile[msg.sender];\n\n                _profile.tokens.push(address(token));\n            }\n        }\n\n        uint n = tokenInfos.length;\n\n        emit Launched(address(token), _pair, n);\n\n        // Make initial purchase\n        IERC20(assetToken).forceApprove(address(router), initialPurchase);\n        router.buy(initialPurchase, address(token), address(this));\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n\n        return (address(token), _pair, n);\n    }\n\n    function sell(\n        uint256 amountIn,\n        address tokenAddress\n    ) public returns (bool) {\n        require(tokenInfo[tokenAddress].trading, \"Token not trading\");\n\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        (uint256 amount0In, uint256 amount1Out) = router.sell(\n            amountIn,\n            tokenAddress,\n            msg.sender\n        );\n\n        uint256 newReserveA = reserveA + amount0In;\n        uint256 newReserveB = reserveB - amount1Out;\n        uint256 duration = block.timestamp -\n            tokenInfo[tokenAddress].data.lastUpdated;\n\n        uint256 liquidity = newReserveB * 2;\n        uint256 mCap = (tokenInfo[tokenAddress].data.supply * newReserveB) /\n            newReserveA;\n        uint256 price = newReserveA / newReserveB;\n        uint256 volume = duration > 86400\n            ? amount1Out\n            : tokenInfo[tokenAddress].data.volume24H + amount1Out;\n        uint256 prevPrice = duration > 86400\n            ? tokenInfo[tokenAddress].data.price\n            : tokenInfo[tokenAddress].data.prevPrice;\n\n        tokenInfo[tokenAddress].data.price = price;\n        tokenInfo[tokenAddress].data.marketCap = mCap;\n        tokenInfo[tokenAddress].data.liquidity = liquidity;\n        tokenInfo[tokenAddress].data.volume =\n            tokenInfo[tokenAddress].data.volume +\n            amount1Out;\n        tokenInfo[tokenAddress].data.volume24H = volume;\n        tokenInfo[tokenAddress].data.prevPrice = prevPrice;\n\n        if (duration > 86400) {\n            tokenInfo[tokenAddress].data.lastUpdated = block.timestamp;\n        }\n\n        return true;\n    }\n\n    function buy(\n        uint256 amountIn,\n        address tokenAddress\n    ) public payable returns (bool) {\n        require(tokenInfo[tokenAddress].trading, \"Token not trading\");\n\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        (uint256 reserveA, uint256 reserveB) = pair.getReserves();\n\n        (uint256 amount1In, uint256 amount0Out) = router.buy(\n            amountIn,\n            tokenAddress,\n            msg.sender\n        );\n\n        uint256 newReserveA = reserveA - amount0Out;\n        uint256 newReserveB = reserveB + amount1In;\n        uint256 duration = block.timestamp -\n            tokenInfo[tokenAddress].data.lastUpdated;\n\n        uint256 liquidity = newReserveB * 2;\n        uint256 mCap = (tokenInfo[tokenAddress].data.supply * newReserveB) /\n            newReserveA;\n        uint256 price = newReserveA / newReserveB;\n        uint256 volume = duration > 86400\n            ? amount1In\n            : tokenInfo[tokenAddress].data.volume24H + amount1In;\n        uint256 _price = duration > 86400\n            ? tokenInfo[tokenAddress].data.price\n            : tokenInfo[tokenAddress].data.prevPrice;\n\n        tokenInfo[tokenAddress].data.price = price;\n        tokenInfo[tokenAddress].data.marketCap = mCap;\n        tokenInfo[tokenAddress].data.liquidity = liquidity;\n        tokenInfo[tokenAddress].data.volume =\n            tokenInfo[tokenAddress].data.volume +\n            amount1In;\n        tokenInfo[tokenAddress].data.volume24H = volume;\n        tokenInfo[tokenAddress].data.prevPrice = _price;\n\n        if (duration > 86400) {\n            tokenInfo[tokenAddress].data.lastUpdated = block.timestamp;\n        }\n\n        if (newReserveA <= gradThreshold && tokenInfo[tokenAddress].trading) {\n            _openTradingOnUniswap(tokenAddress);\n        }\n\n        return true;\n    }\n\n    function _openTradingOnUniswap(address tokenAddress) private {\n        FERC20 token_ = FERC20(tokenAddress);\n\n        Token storage _token = tokenInfo[tokenAddress];\n\n        require(\n            _token.trading && !_token.tradingOnUniswap,\n            \"trading is already open\"\n        );\n\n        _token.trading = false;\n        _token.tradingOnUniswap = true;\n\n        // Transfer asset tokens to bonding contract\n        address pairAddress = factory.getPair(\n            tokenAddress,\n            router.assetToken()\n        );\n\n        IFPair pair = IFPair(pairAddress);\n\n        uint256 assetBalance = pair.assetBalance();\n        uint256 tokenBalance = pair.balance();\n\n        router.graduate(tokenAddress);\n\n        IERC20(router.assetToken()).forceApprove(agentFactory, assetBalance);\n        uint256 id = IAgentFactoryV3(agentFactory).initFromBondingCurve(\n            string.concat(_token.data._name, \" by Virtuals\"),\n            _token.data.ticker,\n            _token.cores,\n            _deployParams.tbaSalt,\n            _deployParams.tbaImplementation,\n            _deployParams.daoVotingPeriod,\n            _deployParams.daoThreshold,\n            assetBalance\n        );\n\n        address agentToken = IAgentFactoryV3(agentFactory)\n            .executeBondingCurveApplication(\n                id,\n                _token.data.supply / (10 ** token_.decimals()),\n                tokenBalance / (10 ** token_.decimals()),\n                pairAddress\n            );\n        _token.agentToken = agentToken;\n\n        router.approval(\n            pairAddress,\n            agentToken,\n            address(this),\n            IERC20(agentToken).balanceOf(pairAddress)\n        );\n\n        token_.burnFrom(pairAddress, tokenBalance);\n\n        emit Graduated(tokenAddress, agentToken);\n    }\n\n    function unwrapToken(\n        address srcTokenAddress,\n        address[] memory accounts\n    ) public {\n        Token memory info = tokenInfo[srcTokenAddress];\n        require(info.tradingOnUniswap, \"Token is not graduated yet\");\n\n        FERC20 token = FERC20(srcTokenAddress);\n        IERC20 agentToken = IERC20(info.agentToken);\n        address pairAddress = factory.getPair(\n            srcTokenAddress,\n            router.assetToken()\n        );\n        for (uint i = 0; i < accounts.length; i++) {\n            address acc = accounts[i];\n            uint256 balance = token.balanceOf(acc);\n            if (balance > 0) {\n                token.burnFrom(acc, balance);\n                agentToken.transferFrom(pairAddress, acc, balance);\n            }\n        }\n    }\n}\n",
        "AgentTax.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../pool/IRouter.sol\";\nimport \"../virtualPersona/IAgentNft.sol\";\n\ncontract AgentTax is Initializable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n    struct TaxHistory {\n        uint256 agentId;\n        uint256 amount;\n    }\n\n    struct TaxAmounts {\n        uint256 amountCollected;\n        uint256 amountSwapped;\n    }\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\n    uint256 internal constant DENOM = 10000;\n\n    address public assetToken;\n    address public taxToken;\n    IRouter public router;\n    address public treasury;\n    uint16 public feeRate;\n    uint256 public minSwapThreshold;\n    uint256 public maxSwapThreshold;\n    IAgentNft public agentNft;\n\n    event SwapThresholdUpdated(\n        uint256 oldMinThreshold,\n        uint256 newMinThreshold,\n        uint256 oldMaxThreshold,\n        uint256 newMaxThreshold\n    );\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\n    event SwapExecuted(\n        uint256 indexed agentId,\n        uint256 taxTokenAmount,\n        uint256 assetTokenAmount\n    );\n    event SwapFailed(uint256 indexed agentId, uint256 taxTokenAmount);\n    event TaxCollected(bytes32 indexed txhash, uint256 agentId, uint256 amount);\n\n    mapping(uint256 agentId => address tba) private _agentTba; // cache to prevent calling AgentNft frequently\n    mapping(bytes32 txhash => TaxHistory history) public taxHistory;\n    mapping(uint256 agentId => TaxAmounts amounts) public agentTaxAmounts;\n\n    error TxHashExists(bytes32 txhash);\n    // V2 storage\n    struct TaxRecipient {\n        address tba;\n        address creator;\n    }\n    event SwapParamsUpdated2(\n        address oldRouter,\n        address newRouter,\n        address oldAsset,\n        address newAsset,\n        uint16 oldFeeRate,\n        uint16 newFeeRate,\n        uint16 oldCreatorFeeRate,\n        uint16 newCreatorFeeRate\n    );\n\n    mapping(uint256 agentId => TaxRecipient) private _agentRecipients;\n    uint16 public creatorFeeRate;\n\n    event CreatorUpdated(\n        uint256 agentId,\n        address oldCreator,\n        address newCreator\n    );\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address defaultAdmin_,\n        address assetToken_,\n        address taxToken_,\n        address router_,\n        address treasury_,\n        uint256 minSwapThreshold_,\n        uint256 maxSwapThreshold_,\n        address nft_\n    ) external initializer {\n        __AccessControl_init();\n\n        require(\n            assetToken_ != taxToken_,\n            \"Asset token cannot be same as tax token\"\n        );\n\n        _grantRole(ADMIN_ROLE, defaultAdmin_);\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin_);\n        assetToken = assetToken_;\n        taxToken = taxToken_;\n        router = IRouter(router_);\n        treasury = treasury_;\n        minSwapThreshold = minSwapThreshold_;\n        maxSwapThreshold = maxSwapThreshold_;\n        IERC20(taxToken).forceApprove(router_, type(uint256).max);\n        agentNft = IAgentNft(nft_);\n\n        feeRate = 100;\n        creatorFeeRate = 3000;\n\n        emit SwapParamsUpdated2(\n            address(0),\n            router_,\n            address(0),\n            assetToken_,\n            0,\n            feeRate,\n            0,\n            creatorFeeRate\n        );\n        emit SwapThresholdUpdated(0, minSwapThreshold_, 0, maxSwapThreshold_);\n    }\n\n    function updateSwapParams(\n        address router_,\n        address assetToken_,\n        uint16 feeRate_,\n        uint16 creatorFeeRate_\n    ) public onlyRole(ADMIN_ROLE) {\n        require((feeRate_ + creatorFeeRate_) <= DENOM, \"Fees overflow\");\n        address oldRouter = address(router);\n        address oldAsset = assetToken;\n        uint16 oldFee = feeRate;\n        uint16 oldCreatorFee = creatorFeeRate;\n\n        assetToken = assetToken_;\n        router = IRouter(router_);\n        feeRate = feeRate_;\n        creatorFeeRate = creatorFeeRate_;\n\n        IERC20(taxToken).forceApprove(oldRouter, 0);\n        IERC20(taxToken).forceApprove(router_, type(uint256).max);\n\n        emit SwapParamsUpdated2(\n            oldRouter,\n            router_,\n            oldAsset,\n            assetToken_,\n            oldFee,\n            feeRate_,\n            oldCreatorFee,\n            creatorFeeRate\n        );\n    }\n\n    function updateSwapThresholds(\n        uint256 minSwapThreshold_,\n        uint256 maxSwapThreshold_\n    ) public onlyRole(ADMIN_ROLE) {\n        uint256 oldMin = minSwapThreshold;\n        uint256 oldMax = maxSwapThreshold;\n\n        minSwapThreshold = minSwapThreshold_;\n        maxSwapThreshold = maxSwapThreshold_;\n\n        emit SwapThresholdUpdated(\n            oldMin,\n            minSwapThreshold_,\n            oldMax,\n            maxSwapThreshold_\n        );\n    }\n\n    function updateTreasury(address treasury_) public onlyRole(ADMIN_ROLE) {\n        address oldTreasury = treasury;\n        treasury = treasury_;\n\n        emit TreasuryUpdated(oldTreasury, treasury_);\n    }\n\n    function withdraw(address token) external onlyRole(ADMIN_ROLE) {\n        IERC20(token).safeTransfer(\n            treasury,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function handleAgentTaxes(\n        uint256 agentId,\n        bytes32[] memory txhashes,\n        uint256[] memory amounts,\n        uint256 minOutput\n    ) public onlyRole(EXECUTOR_ROLE) {\n        require(txhashes.length == amounts.length, \"Unmatched inputs\");\n        TaxAmounts storage agentAmounts = agentTaxAmounts[agentId];\n        uint256 totalAmount = 0;\n        for (uint i = 0; i < txhashes.length; i++) {\n            bytes32 txhash = txhashes[i];\n            if (taxHistory[txhash].agentId > 0) {\n                revert TxHashExists(txhash);\n            }\n            taxHistory[txhash] = TaxHistory(agentId, amounts[i]);\n            totalAmount += amounts[i];\n            emit TaxCollected(txhash, agentId, amounts[i]);\n        }\n        agentAmounts.amountCollected += totalAmount;\n        _swapForAsset(agentId, minOutput);\n    }\n\n    function _getTaxRecipient(\n        uint256 agentId\n    ) internal returns (TaxRecipient memory) {\n        TaxRecipient storage recipient = _agentRecipients[agentId];\n        if (recipient.tba == address(0)) {\n            IAgentNft.VirtualInfo memory info = agentNft.virtualInfo(agentId);\n            recipient.tba = info.tba;\n            recipient.creator = info.founder;\n        }\n        return recipient;\n    }\n\n    function swapForAsset(\n        uint256 agentId,\n        uint256 minOutput\n    ) public onlyRole(EXECUTOR_ROLE) returns (bool, uint256) {\n        return _swapForAsset(agentId, minOutput);\n    }\n\n    function _swapForAsset(\n        uint256 agentId,\n        uint256 minOutput\n    ) internal returns (bool, uint256) {\n        TaxAmounts storage agentAmounts = agentTaxAmounts[agentId];\n        uint256 amountToSwap = agentAmounts.amountCollected -\n            agentAmounts.amountSwapped;\n\n        uint256 balance = IERC20(taxToken).balanceOf(address(this));\n\n        require(balance >= amountToSwap, \"Insufficient balance\");\n\n        TaxRecipient memory taxRecipient = _getTaxRecipient(agentId);\n        require(taxRecipient.tba != address(0), \"Agent does not have TBA\");\n\n        if (amountToSwap < minSwapThreshold) {\n            return (false, 0);\n        }\n\n        if (amountToSwap > maxSwapThreshold) {\n            amountToSwap = maxSwapThreshold;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = taxToken;\n        path[1] = assetToken;\n\n        uint256[] memory amountsOut = router.getAmountsOut(amountToSwap, path);\n        require(amountsOut.length > 1, \"Failed to fetch token price\");\n\n        try\n            router.swapExactTokensForTokens(\n                amountToSwap,\n                minOutput,\n                path,\n                address(this),\n                block.timestamp + 300\n            )\n        returns (uint256[] memory amounts) {\n            uint256 assetReceived = amounts[1];\n            emit SwapExecuted(agentId, amountToSwap, assetReceived);\n\n            uint256 feeAmount = (assetReceived * feeRate) / DENOM;\n            uint256 creatorFee = (assetReceived * creatorFeeRate) / DENOM;\n            uint256 tbaFee = assetReceived - feeAmount - creatorFee;\n\n            if (tbaFee > 0) {\n                IERC20(assetToken).safeTransfer(taxRecipient.tba, tbaFee);\n            }\n\n            if (creatorFee > 0) {\n                IERC20(assetToken).safeTransfer(\n                    taxRecipient.creator,\n                    creatorFee\n                );\n            }\n\n            if (feeAmount > 0) {\n                IERC20(assetToken).safeTransfer(treasury, feeAmount);\n            }\n\n            agentAmounts.amountSwapped += amountToSwap;\n\n            return (true, amounts[1]);\n        } catch {\n            emit SwapFailed(agentId, amountToSwap);\n            return (false, 0);\n        }\n    }\n\n    function updateCreator(uint256 agentId, address creator) public {\n        address sender = _msgSender();\n        TaxRecipient storage recipient = _agentRecipients[agentId];\n        if (recipient.tba == address(0)) {\n            IAgentNft.VirtualInfo memory info = agentNft.virtualInfo(agentId);\n            recipient.tba = info.tba;\n            recipient.creator = info.founder;\n        }\n        address oldCreator = recipient.creator;\n        require(\n            sender == recipient.creator || hasRole(ADMIN_ROLE, sender),\n            \"Only creator can update\"\n        );\n        recipient.creator = creator;\n        emit CreatorUpdated(agentId, oldCreator, creator);\n    }\n}\n",
        "BondingTax.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./IBondingTax.sol\";\nimport \"../pool/IRouter.sol\";\n\ncontract BondingTax is\n    Initializable,\n    AccessControlUpgradeable,\n    IBondingTax\n{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public assetToken;\n    address public taxToken;\n    IRouter public router;\n    address public bondingRouter;\n    address public treasury;\n    uint256 public minSwapThreshold;\n    uint256 public maxSwapThreshold;\n    uint16 private _slippage;\n\n    event SwapParamsUpdated(\n        address oldRouter,\n        address newRouter,\n        address oldBondingRouter,\n        address newBondingRouter,\n        address oldAsset,\n        address newAsset\n    );\n    event SwapThresholdUpdated(\n        uint256 oldMinThreshold,\n        uint256 newMinThreshold,\n        uint256 oldMaxThreshold,\n        uint256 newMaxThreshold\n    );\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\n    event SwapExecuted(uint256 taxTokenAmount, uint256 assetTokenAmount);\n    event SwapFailed(uint256 taxTokenAmount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    modifier onlyBondingRouter() {\n        require(_msgSender() == address(bondingRouter), \"Only bonding router\");\n        _;\n    }\n\n    function initialize(\n        address defaultAdmin_,\n        address assetToken_,\n        address taxToken_,\n        address router_,\n        address bondingRouter_,\n        address treasury_,\n        uint256 minSwapThreshold_,\n        uint256 maxSwapThreshold_\n    ) external initializer {\n        __AccessControl_init();\n\n        _grantRole(ADMIN_ROLE, defaultAdmin_);\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin_);\n        assetToken = assetToken_;\n        taxToken = taxToken_;\n        router = IRouter(router_);\n        bondingRouter = bondingRouter_;\n        treasury = treasury_;\n        minSwapThreshold = minSwapThreshold_;\n        maxSwapThreshold = maxSwapThreshold_;\n        IERC20(taxToken).forceApprove(router_, type(uint256).max);\n\n        _slippage = 100; // default to 1%\n    }\n\n    function updateSwapParams(\n        address router_,\n        address bondingRouter_,\n        address assetToken_,\n        uint16 slippage_\n    ) public onlyRole(ADMIN_ROLE) {\n        address oldRouter = address(router);\n        address oldBondingRouter = bondingRouter;\n        address oldAsset = assetToken;\n\n        assetToken = assetToken_;\n        router = IRouter(router_);\n        bondingRouter = bondingRouter_;\n        _slippage = slippage_;\n\n        IERC20(taxToken).forceApprove(router_, type(uint256).max);\n        IERC20(taxToken).forceApprove(oldRouter, 0);\n\n        emit SwapParamsUpdated(\n            oldRouter,\n            router_,\n            oldBondingRouter,\n            bondingRouter_,\n            oldAsset,\n            assetToken_\n        );\n    }\n\n    function updateSwapThresholds(\n        uint256 minSwapThreshold_,\n        uint256 maxSwapThreshold_\n    ) public onlyRole(ADMIN_ROLE) {\n        uint256 oldMin = minSwapThreshold;\n        uint256 oldMax = maxSwapThreshold;\n\n        minSwapThreshold = minSwapThreshold_;\n        maxSwapThreshold = maxSwapThreshold_;\n\n        emit SwapThresholdUpdated(\n            oldMin,\n            minSwapThreshold_,\n            oldMax,\n            maxSwapThreshold_\n        );\n    }\n\n    function updateTreasury(address treasury_) public onlyRole(ADMIN_ROLE) {\n        address oldTreasury = treasury;\n        treasury = treasury_;\n\n        emit TreasuryUpdated(oldTreasury, treasury_);\n    }\n\n    function withdraw(address token) external onlyRole(ADMIN_ROLE) {\n        IERC20(token).safeTransfer(\n            treasury,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function swapForAsset() public onlyBondingRouter returns (bool, uint256) {\n        uint256 amount = IERC20(taxToken).balanceOf(address(this));\n\n        require(amount > 0, \"Nothing to be swapped\");\n\n        if (amount < minSwapThreshold) {\n            return (false, 0);\n        }\n\n        if (amount > maxSwapThreshold) {\n            amount = maxSwapThreshold;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = taxToken;\n        path[1] = assetToken;\n\n        uint256[] memory amountsOut = router.getAmountsOut(amount, path);\n        require(amountsOut.length > 1, \"Failed to fetch token price\");\n\n        uint256 expectedOutput = amountsOut[1];\n        uint256 minOutput = (expectedOutput * (10000 - _slippage)) / 10000;\n\n        try\n            router.swapExactTokensForTokens(\n                amount,\n                minOutput,\n                path,\n                treasury,\n                block.timestamp + 300\n            )\n        returns (uint256[] memory amounts) {\n            emit SwapExecuted(amount, amounts[1]);\n            return (true, amounts[1]);\n        } catch {\n            emit SwapFailed(amount);\n            return (false, 0);\n        }\n    }\n}\n"
    }
}