{
    "vfp_id": "vfp_00349",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "AgentToken tokens are created out of thin air if AgentToken::distributeTaxTokens() triggers an autoswap",
            "description": "The AgentToken::distributeTaxTokens() function transfers pending tax tokens to AgentTax.sol by calling the internal _transfer() function. This function saves the sender's balance before any state changes, then performs an autoswap if thresholds are met, which reduces the contract's balance of AgentToken. However, the balance update uses the pre-swap balance value, subtracting the transferred amount from the outdated balance. This discrepancy allows the creation of AgentToken tokens out of thin air when the swap occurs during the transfer. The root cause is the incorrect ordering of balance snapshot and state-changing operations. An attacker could potentially manipulate this to inflate supply or disrupt accounting. The impact includes potential inflation of AgentToken supply, undermining tokenomics and trust in the system.\n",
            "severity": "High",
            "location": [
                "AgentToken.sol::distributeTaxTokens"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentToken.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Agent token graduation can be blocked",
            "description": "An attacker can prevent the successful deployment and liquidity seeding of a new Agent token by front-running its creation. By precomputing the Agent token address and creating a Uniswap pair in advance, the attacker can donate 1 wei of an asset and call sync(), setting one reserve to a non-zero value. When the protocol attempts to add liquidity via the Uniswap router, the quote() function reverts due to insufficient liquidity (one reserve zero, one non-zero), causing the entire liquidity addition to fail. The root cause is reliance on Uniswap's router logic without handling edge cases of pre-initialized pairs. This can be exploited to block agent graduation, particularly affecting bonding curve launches. The impact is denial of service, where assets become trapped in the FPair contract and the agent cannot proceed with its launch.\n",
            "severity": "High",
            "location": [
                "AgentToken.sol#L279-L289"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentToken.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Attacker can steal AgentToken taxes by sandwich his own transfer",
            "description": "AgentToken implements automatic tax swapping during transfers via _swapTax(), which exchanges accumulated AgentToken taxes for VIRTUAL tokens on Uniswap. However, this swap lacks slippage protection, using a hard-coded deadline but no minimum output amount. An attacker can sandwich their own transfer to manipulate the price: first, they sell a large amount of AgentToken to depress its price; then, they trigger the tax swap, which receives fewer VIRTUAL tokens due to the manipulated pool state; finally, they buy back AgentToken at a discount. The root cause is the absence of slippage controls in a critical swap operation. This allows profit extraction at the expense of the protocol's tax revenue. The impact is financial loss to the protocol treasury, reducing funds available for development and rewards.\n",
            "severity": "High",
            "location": [
                "AgentToken.sol"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentToken.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "_tokenHasTax parameter is not updated if tax BPS was changed from 0",
            "description": "The _tokenHasTax flag is initialized to false when a token is created with zero tax on buy and sell. However, if the tax rates are later updated to non-zero values via setProjectTaxRates, the _tokenHasTax flag is not updated, so tax processing remains disabled. This is caused by the lack of synchronization between tax rate updates and the flag state. As a result, even though tax rates are set, no tax is collected on transactions because the _taxProcessing function checks the outdated _tokenHasTax flag. This leads to loss of expected tax revenue and incorrect token behavior.\n",
            "severity": "Low",
            "location": [
                "AgentToken.sol#466"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentToken.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "AgentToken::distributeTaxTokens() reverts in some situations",
            "description": "The distributeTaxTokens() function sets projectTaxPendingSwap to 0 before calling _transfer(), which may trigger _autoSwap() and _swapTax(). In _swapTax(), if the swapBalance_ is less than contractBalance_, it attempts to subtract from projectTaxPendingSwap, which has already been set to 0, causing an underflow revert. This occurs due to incorrect ordering of state updates and swap logic. The impact is that tax distribution can fail unexpectedly, preventing proper tax handling and potentially disrupting token operations.\n",
            "severity": "Informational",
            "location": [
                "AgentToken.sol#955"
            ],
            "files": [
                "protocol-contracts/contracts/virtualPersona/AgentToken.sol"
            ]
        }
    ],
    "affected_files": {
        "AgentToken.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../pool/IUniswapV2Router02.sol\";\nimport \"../pool/IUniswapV2Factory.sol\";\nimport \"./IAgentToken.sol\";\nimport \"./IAgentFactory.sol\";\n\ncontract AgentToken is\n    ContextUpgradeable,\n    IAgentToken,\n    Ownable2StepUpgradeable\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant BP_DENOM = 10000;\n    uint256 internal constant ROUND_DEC = 100000000000;\n    uint256 internal constant CALL_GAS_LIMIT = 50000;\n    uint256 internal constant MAX_SWAP_THRESHOLD_MULTIPLE = 20;\n\n    address public uniswapV2Pair;\n    uint256 public botProtectionDurationInSeconds;\n    bool internal _tokenHasTax;\n    IUniswapV2Router02 internal _uniswapRouter;\n\n    uint32 public fundedDate;\n    uint16 public projectBuyTaxBasisPoints;\n    uint16 public projectSellTaxBasisPoints;\n    uint16 public swapThresholdBasisPoints;\n    address public pairToken; // The token used to trade for this token\n\n    /** @dev {_autoSwapInProgress} We start with {_autoSwapInProgress} ON, as we don't want to\n     * call autoswap when processing initial liquidity from this address. We turn this OFF when\n     * liquidity has been loaded, and use this bool to control processing during auto-swaps\n     * from that point onwards. */\n    bool private _autoSwapInProgress;\n\n    address public projectTaxRecipient;\n    uint128 public projectTaxPendingSwap;\n    address public vault; // Project supply vault\n\n    string private _name;\n    string private _symbol;\n    uint256 private _totalSupply;\n\n    /** @dev {_balances} Addresses balances */\n    mapping(address => uint256) private _balances;\n\n    /** @dev {_allowances} Addresses allocance details */\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /** @dev {_validCallerCodeHashes} Code hashes of callers we consider valid */\n    EnumerableSet.Bytes32Set private _validCallerCodeHashes;\n\n    /** @dev {_liquidityPools} Enumerable set for liquidity pool addresses */\n    EnumerableSet.AddressSet private _liquidityPools;\n\n    IAgentFactory private _factory; // Single source of truth\n\n    /**\n     * @dev {onlyOwnerOrFactory}\n     *\n     * Throws if called by any account other than the owner, factory or pool.\n     */\n    modifier onlyOwnerOrFactory() {\n        if (owner() != _msgSender() && address(_factory) != _msgSender()) {\n            revert CallerIsNotAdminNorFactory();\n        }\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address[3] memory integrationAddresses_,\n        bytes memory baseParams_,\n        bytes memory supplyParams_,\n        bytes memory taxParams_\n    ) external initializer {\n        _decodeBaseParams(integrationAddresses_[0], baseParams_);\n        _uniswapRouter = IUniswapV2Router02(integrationAddresses_[1]);\n        pairToken = integrationAddresses_[2];\n\n        ERC20SupplyParameters memory supplyParams = abi.decode(\n            supplyParams_,\n            (ERC20SupplyParameters)\n        );\n\n        ERC20TaxParameters memory taxParams = abi.decode(\n            taxParams_,\n            (ERC20TaxParameters)\n        );\n\n        _processSupplyParams(supplyParams);\n\n        uint256 lpSupply = supplyParams.lpSupply * (10 ** decimals());\n        uint256 vaultSupply = supplyParams.vaultSupply * (10 ** decimals());\n\n        botProtectionDurationInSeconds = supplyParams\n            .botProtectionDurationInSeconds;\n\n        _tokenHasTax = _processTaxParams(taxParams);\n        swapThresholdBasisPoints = uint16(\n            taxParams.taxSwapThresholdBasisPoints\n        );\n        projectTaxRecipient = taxParams.projectTaxRecipient;\n\n        _mintBalances(lpSupply, vaultSupply);\n\n        uniswapV2Pair = _createPair();\n\n        _factory = IAgentFactory(_msgSender());\n        _autoSwapInProgress = true; // We don't want to tax initial liquidity\n    }\n\n    /**\n     * @dev function {_decodeBaseParams}\n     *\n     * Decode NFT Parameters\n     *\n     * @param projectOwner_ The owner of this contract\n     * @param encodedBaseParams_ The base params encoded into a bytes array\n     */\n    function _decodeBaseParams(\n        address projectOwner_,\n        bytes memory encodedBaseParams_\n    ) internal {\n        _transferOwnership(projectOwner_);\n\n        (_name, _symbol) = abi.decode(encodedBaseParams_, (string, string));\n    }\n\n    /**\n     * @dev function {_processSupplyParams}\n     *\n     * Process provided supply params\n     *\n     * @param erc20SupplyParameters_ The supply params\n     */\n    function _processSupplyParams(\n        ERC20SupplyParameters memory erc20SupplyParameters_\n    ) internal {\n        if (\n            erc20SupplyParameters_.maxSupply !=\n            (erc20SupplyParameters_.vaultSupply +\n                erc20SupplyParameters_.lpSupply)\n        ) {\n            revert SupplyTotalMismatch();\n        }\n\n        if (erc20SupplyParameters_.maxSupply > type(uint128).max) {\n            revert MaxSupplyTooHigh();\n        }\n\n        vault = erc20SupplyParameters_.vault;\n    }\n\n    /**\n     * @dev function {_processTaxParams}\n     *\n     * Process provided tax params\n     *\n     * @param erc20TaxParameters_ The tax params\n     */\n    function _processTaxParams(\n        ERC20TaxParameters memory erc20TaxParameters_\n    ) internal returns (bool tokenHasTax_) {\n        /**\n         * @dev If this\n         * token does NOT have tax applied then there is no need to store or read these parameters, and we can\n         * avoid this simply by checking the immutable var. Pass back the value for this var from this method.\n         */\n        if (\n            erc20TaxParameters_.projectBuyTaxBasisPoints == 0 &&\n            erc20TaxParameters_.projectSellTaxBasisPoints == 0\n        ) {\n            return false;\n        } else {\n            projectBuyTaxBasisPoints = uint16(\n                erc20TaxParameters_.projectBuyTaxBasisPoints\n            );\n            projectSellTaxBasisPoints = uint16(\n                erc20TaxParameters_.projectSellTaxBasisPoints\n            );\n            return true;\n        }\n    }\n\n    /**\n     * @dev function {_mintBalances}\n     *\n     * Mint initial balances\n     *\n     * @param lpMint_ The number of tokens for liquidity\n     */\n    function _mintBalances(uint256 lpMint_, uint256 vaultMint_) internal {\n        if (lpMint_ > 0) {\n            _mint(address(this), lpMint_);\n        }\n\n        if (vaultMint_ > 0) {\n            _mint(vault, vaultMint_);\n        }\n    }\n\n    /**\n     * @dev function {_createPair}\n     *\n     * Create the uniswap pair\n     *\n     * @return uniswapV2Pair_ The pair address\n     */\n    function _createPair() internal returns (address uniswapV2Pair_) {\n        uniswapV2Pair_ = IUniswapV2Factory(_uniswapRouter.factory()).getPair(\n            address(this),\n            pairToken\n        );\n\n        if (uniswapV2Pair_ == address(0)) {\n            uniswapV2Pair_ = IUniswapV2Factory(_uniswapRouter.factory())\n                .createPair(address(this), pairToken);\n\n            emit LiquidityPoolCreated(uniswapV2Pair_);\n        }\n\n        _liquidityPools.add(uniswapV2Pair_);\n\n        return (uniswapV2Pair_);\n    }\n\n    /**\n     * @dev function {addInitialLiquidity}\n     *\n     * Add initial liquidity to the uniswap pair\n     *\n     * @param lpOwner The recipient of LP tokens\n     */\n    function addInitialLiquidity(address lpOwner) external onlyOwnerOrFactory {\n        _addInitialLiquidity(lpOwner);\n    }\n\n    /**\n     * @dev function {_addInitialLiquidity}\n     *\n     * Add initial liquidity to the uniswap pair (internal function that does processing)\n     *\n     * * @param lpOwner The recipient of LP tokens\n     */\n    function _addInitialLiquidity(address lpOwner) internal {\n        // Funded date is the date of first funding. We can only add initial liquidity once. If this date is set,\n        // we cannot proceed\n        if (fundedDate != 0) {\n            revert InitialLiquidityAlreadyAdded();\n        }\n\n        fundedDate = uint32(block.timestamp);\n\n        // Can only do this if this contract holds tokens:\n        if (balanceOf(address(this)) == 0) {\n            revert NoTokenForLiquidityPair();\n        }\n\n        // Approve the uniswap router for an inifinite amount (max uint256)\n        // This means that we don't need to worry about later incrememtal\n        // approvals on tax swaps, as the uniswap router allowance will never\n        // be decreased (see code in decreaseAllowance for reference)\n        _approve(address(this), address(_uniswapRouter), type(uint256).max);\n        IERC20(pairToken).approve(address(_uniswapRouter), type(uint256).max);\n        // Add the liquidity:\n        (uint256 amountA, uint256 amountB, uint256 lpTokens) = _uniswapRouter\n            .addLiquidity(\n                address(this),\n                pairToken,\n                balanceOf(address(this)),\n                IERC20(pairToken).balanceOf(address(this)),\n                0,\n                0,\n                address(this),\n                block.timestamp\n            );\n\n        emit InitialLiquidityAdded(amountA, amountB, lpTokens);\n\n        // We now set this to false so that future transactions can be eligibile for autoswaps\n        _autoSwapInProgress = false;\n\n        IERC20(uniswapV2Pair).transfer(lpOwner, lpTokens);\n    }\n\n    /**\n     * @dev function {isLiquidityPool}\n     *\n     * Return if an address is a liquidity pool\n     *\n     * @param queryAddress_ The address being queried\n     * @return bool The address is / isn't a liquidity pool\n     */\n    function isLiquidityPool(address queryAddress_) public view returns (bool) {\n        /** @dev We check the uniswapV2Pair address first as this is an immutable variable and therefore does not need\n         * to be fetched from storage, saving gas if this address IS the uniswapV2Pool. We also add this address\n         * to the enumerated set for ease of reference (for example it is returned in the getter), and it does\n         * not add gas to any other calls, that still complete in 0(1) time.\n         */\n        return (queryAddress_ == uniswapV2Pair ||\n            _liquidityPools.contains(queryAddress_));\n    }\n\n    /**\n     * @dev function {liquidityPools}\n     *\n     * Returns a list of all liquidity pools\n     *\n     * @return liquidityPools_ a list of all liquidity pools\n     */\n    function liquidityPools()\n        external\n        view\n        returns (address[] memory liquidityPools_)\n    {\n        return (_liquidityPools.values());\n    }\n\n    /**\n     * @dev function {addLiquidityPool} onlyOwnerOrFactory\n     *\n     * Allows the manager to add a liquidity pool to the pool enumerable set\n     *\n     * @param newLiquidityPool_ The address of the new liquidity pool\n     */\n    function addLiquidityPool(\n        address newLiquidityPool_\n    ) public onlyOwnerOrFactory {\n        // Don't allow calls that didn't pass an address:\n        if (newLiquidityPool_ == address(0)) {\n            revert LiquidityPoolCannotBeAddressZero();\n        }\n        // Only allow smart contract addresses to be added, as only these can be pools:\n        if (newLiquidityPool_.code.length == 0) {\n            revert LiquidityPoolMustBeAContractAddress();\n        }\n        // Add this to the enumerated list:\n        _liquidityPools.add(newLiquidityPool_);\n        emit LiquidityPoolAdded(newLiquidityPool_);\n    }\n\n    /**\n     * @dev function {removeLiquidityPool} onlyOwnerOrFactory\n     *\n     * Allows the manager to remove a liquidity pool\n     *\n     * @param removedLiquidityPool_ The address of the old removed liquidity pool\n     */\n    function removeLiquidityPool(\n        address removedLiquidityPool_\n    ) external onlyOwnerOrFactory {\n        // Remove this from the enumerated list:\n        _liquidityPools.remove(removedLiquidityPool_);\n        emit LiquidityPoolRemoved(removedLiquidityPool_);\n    }\n\n    /**\n     * @dev function {isValidCaller}\n     *\n     * Return if an address is a valid caller\n     *\n     * @param queryHash_ The code hash being queried\n     * @return bool The address is / isn't a valid caller\n     */\n    function isValidCaller(bytes32 queryHash_) public view returns (bool) {\n        return (_validCallerCodeHashes.contains(queryHash_));\n    }\n\n    /**\n     * @dev function {validCallers}\n     *\n     * Returns a list of all valid caller code hashes\n     *\n     * @return validCallerHashes_ a list of all valid caller code hashes\n     */\n    function validCallers()\n        external\n        view\n        returns (bytes32[] memory validCallerHashes_)\n    {\n        return (_validCallerCodeHashes.values());\n    }\n\n    /**\n     * @dev function {addValidCaller} onlyOwnerOrFactory\n     *\n     * Allows the owner to add the hash of a valid caller\n     *\n     * @param newValidCallerHash_ The hash of the new valid caller\n     */\n    function addValidCaller(\n        bytes32 newValidCallerHash_\n    ) external onlyOwnerOrFactory {\n        _validCallerCodeHashes.add(newValidCallerHash_);\n        emit ValidCallerAdded(newValidCallerHash_);\n    }\n\n    /**\n     * @dev function {removeValidCaller} onlyOwnerOrFactory\n     *\n     * Allows the owner to remove a valid caller\n     *\n     * @param removedValidCallerHash_ The hash of the old removed valid caller\n     */\n    function removeValidCaller(\n        bytes32 removedValidCallerHash_\n    ) external onlyOwnerOrFactory {\n        // Remove this from the enumerated list:\n        _validCallerCodeHashes.remove(removedValidCallerHash_);\n        emit ValidCallerRemoved(removedValidCallerHash_);\n    }\n\n    /**\n     * @dev function {setProjectTaxRecipient} onlyOwnerOrFactory\n     *\n     * Allows the manager to set the project tax recipient address\n     *\n     * @param projectTaxRecipient_ New recipient address\n     */\n    function setProjectTaxRecipient(\n        address projectTaxRecipient_\n    ) external onlyOwnerOrFactory {\n        projectTaxRecipient = projectTaxRecipient_;\n        emit ProjectTaxRecipientUpdated(projectTaxRecipient_);\n    }\n\n    /**\n     * @dev function {setSwapThresholdBasisPoints} onlyOwnerOrFactory\n     *\n     * Allows the manager to set the autoswap threshold\n     *\n     * @param swapThresholdBasisPoints_ New swap threshold in basis points\n     */\n    function setSwapThresholdBasisPoints(\n        uint16 swapThresholdBasisPoints_\n    ) external onlyOwnerOrFactory {\n        uint256 oldswapThresholdBasisPoints = swapThresholdBasisPoints;\n        swapThresholdBasisPoints = swapThresholdBasisPoints_;\n        emit AutoSwapThresholdUpdated(\n            oldswapThresholdBasisPoints,\n            swapThresholdBasisPoints_\n        );\n    }\n\n    /**\n     * @dev function {setProjectTaxRates} onlyOwnerOrFactory\n     *\n     * Change the tax rates, subject to only ever decreasing\n     *\n     * @param newProjectBuyTaxBasisPoints_ The new buy tax rate\n     * @param newProjectSellTaxBasisPoints_ The new sell tax rate\n     */\n    function setProjectTaxRates(\n        uint16 newProjectBuyTaxBasisPoints_,\n        uint16 newProjectSellTaxBasisPoints_\n    ) external onlyOwnerOrFactory {\n        uint16 oldBuyTaxBasisPoints = projectBuyTaxBasisPoints;\n        uint16 oldSellTaxBasisPoints = projectSellTaxBasisPoints;\n\n        projectBuyTaxBasisPoints = newProjectBuyTaxBasisPoints_;\n        projectSellTaxBasisPoints = newProjectSellTaxBasisPoints_;\n\n        emit ProjectTaxBasisPointsChanged(\n            oldBuyTaxBasisPoints,\n            newProjectBuyTaxBasisPoints_,\n            oldSellTaxBasisPoints,\n            newProjectSellTaxBasisPoints_\n        );\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev totalBuyTaxBasisPoints\n     *\n     * Provide easy to view tax total:\n     */\n    function totalBuyTaxBasisPoints() public view returns (uint256) {\n        return projectBuyTaxBasisPoints;\n    }\n\n    /**\n     * @dev totalSellTaxBasisPoints\n     *\n     * Provide easy to view tax total:\n     */\n    function totalSellTaxBasisPoints() public view returns (uint256) {\n        return projectSellTaxBasisPoints;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(\n        address account\n    ) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override(IERC20) returns (bool) {\n        address owner = _msgSender();\n        _transfer(\n            owner,\n            to,\n            amount,\n            (isLiquidityPool(owner) || isLiquidityPool(to))\n        );\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(\n            from,\n            to,\n            amount,\n            (isLiquidityPool(from) || isLiquidityPool(to))\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < subtractedValue) {\n            revert AllowanceDecreasedBelowZero();\n        }\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount,\n        bool applyTax\n    ) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n\n        // Perform pre-tax validation (e.g. amount doesn't exceed balance, max txn amount)\n        uint256 fromBalance = _pretaxValidationAndLimits(from, to, amount);\n\n        // Perform autoswap if eligible\n        _autoSwap(from, to);\n\n        // Process taxes\n        uint256 amountMinusTax = _taxProcessing(applyTax, to, from, amount);\n\n        _balances[from] = fromBalance - amount;\n        _balances[to] += amountMinusTax;\n\n        emit Transfer(from, to, amountMinusTax);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @dev function {_pretaxValidationAndLimits}\n     *\n     * Perform validation on pre-tax amounts\n     *\n     * @param from_ From address for the transaction\n     * @param to_ To address for the transaction\n     * @param amount_ Amount of the transaction\n     */\n    function _pretaxValidationAndLimits(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) internal view returns (uint256 fromBalance_) {\n        // This can't be a transfer to the liquidity pool before the funding date\n        // UNLESS the from address is this contract. This ensures that the initial\n        // LP funding transaction is from this contract using the supply of tokens\n        // designated for the LP pool, and therefore the initial price in the pool\n        // is being set as expected.\n        //\n        // This protects from, for example, tokens from a team minted supply being\n        // paired with ETH and added to the pool, setting the initial price, BEFORE\n        // the initial liquidity is added through this contract.\n        if (to_ == uniswapV2Pair && from_ != address(this) && fundedDate == 0) {\n            revert InitialLiquidityNotYetAdded();\n        }\n\n        if (from_ == address(0)) {\n            revert TransferFromZeroAddress();\n        }\n\n        if (to_ == address(0)) {\n            revert TransferToZeroAddress();\n        }\n\n        fromBalance_ = _balances[from_];\n\n        if (fromBalance_ < amount_) {\n            revert TransferAmountExceedsBalance();\n        }\n\n        return (fromBalance_);\n    }\n\n    /**\n     * @dev function {_taxProcessing}\n     *\n     * Perform tax processing\n     *\n     * @param applyTax_ Do we apply tax to this transaction?\n     * @param to_ The reciever of the token\n     * @param from_ The sender of the token\n     * @param sentAmount_ The amount being send\n     * @return amountLessTax_ The amount that will be recieved, i.e. the send amount minus tax\n     */\n    function _taxProcessing(\n        bool applyTax_,\n        address to_,\n        address from_,\n        uint256 sentAmount_\n    ) internal returns (uint256 amountLessTax_) {\n        amountLessTax_ = sentAmount_;\n        unchecked {\n            if (_tokenHasTax && applyTax_ && !_autoSwapInProgress) {\n                uint256 tax;\n\n                // on sell\n                if (isLiquidityPool(to_) && totalSellTaxBasisPoints() > 0) {\n                    if (projectSellTaxBasisPoints > 0) {\n                        uint256 projectTax = ((sentAmount_ *\n                            projectSellTaxBasisPoints) / BP_DENOM);\n                        projectTaxPendingSwap += uint128(projectTax);\n                        tax += projectTax;\n                    }\n                }\n                // on buy\n                else if (\n                    isLiquidityPool(from_) && totalBuyTaxBasisPoints() > 0\n                ) {\n                    if (projectBuyTaxBasisPoints > 0) {\n                        uint256 projectTax = ((sentAmount_ *\n                            projectBuyTaxBasisPoints) / BP_DENOM);\n                        projectTaxPendingSwap += uint128(projectTax);\n                        tax += projectTax;\n                    }\n                }\n\n                if (tax > 0) {\n                    _balances[address(this)] += tax;\n                    emit Transfer(from_, address(this), tax);\n                    amountLessTax_ -= tax;\n                }\n            }\n        }\n        return (amountLessTax_);\n    }\n\n    /**\n     * @dev function {_autoSwap}\n     *\n     * Automate the swap of accumulated tax fees to native token\n     *\n     * @param from_ The sender of the token\n     * @param to_ The recipient of the token\n     */\n\n    function _autoSwap(address from_, address to_) internal {\n        if (_tokenHasTax) {\n            uint256 contractBalance = balanceOf(address(this));\n            uint256 swapBalance = contractBalance;\n\n            uint256 swapThresholdInTokens = (_totalSupply *\n                swapThresholdBasisPoints) / BP_DENOM;\n\n            if (\n                _eligibleForSwap(from_, to_, swapBalance, swapThresholdInTokens)\n            ) {\n                // Store that a swap back is in progress:\n                _autoSwapInProgress = true;\n                // Check if we need to reduce the amount of tokens for this swap:\n                if (\n                    swapBalance >\n                    swapThresholdInTokens * MAX_SWAP_THRESHOLD_MULTIPLE\n                ) {\n                    swapBalance =\n                        swapThresholdInTokens *\n                        MAX_SWAP_THRESHOLD_MULTIPLE;\n                }\n                // Perform the auto swap to pair token\n                _swapTax(swapBalance, contractBalance);\n                // Flag that the autoswap is complete:\n                _autoSwapInProgress = false;\n            }\n        }\n    }\n\n    /**\n     * @dev function {_eligibleForSwap}\n     *\n     * Is the current transfer eligible for autoswap\n     *\n     * @param from_ The sender of the token\n     * @param to_ The recipient of the token\n     * @param taxBalance_ The current accumulated tax balance\n     * @param swapThresholdInTokens_ The swap threshold as a token amount\n     */\n    function _eligibleForSwap(\n        address from_,\n        address to_,\n        uint256 taxBalance_,\n        uint256 swapThresholdInTokens_\n    ) internal view returns (bool) {\n        return (taxBalance_ >= swapThresholdInTokens_ &&\n            !_autoSwapInProgress &&\n            !isLiquidityPool(from_) &&\n            from_ != address(_uniswapRouter) &&\n            to_ != address(_uniswapRouter));\n    }\n\n    /**\n     * @dev function {_swapTax}\n     *\n     * Swap tokens taken as tax for pair token\n     *\n     * @param swapBalance_ The current accumulated tax balance to swap\n     * @param contractBalance_ The current accumulated total tax balance\n     */\n    function _swapTax(uint256 swapBalance_, uint256 contractBalance_) internal {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = pairToken;\n\n        // Wrap external calls in try / catch to handle errors\n        try\n            _uniswapRouter\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                    swapBalance_,\n                    0,\n                    path,\n                    projectTaxRecipient,\n                    block.timestamp + 600\n                )\n        {\n            // We will not have swapped all tax tokens IF the amount was greater than the max auto swap.\n            // We therefore cannot just set the pending swap counters to 0. Instead, in this scenario,\n            // we must reduce them in proportion to the swap amount vs the remaining balance + swap\n            // amount.\n            //\n            // For example:\n            //  * swap Balance is 250\n            //  * contract balance is 385.\n            //  * projectTaxPendingSwap is 300\n            //\n            // The new total for the projectTaxPendingSwap is:\n            //   = 300 - ((300 * 250) / 385)\n            //   = 300 - 194\n            //   = 106\n\n            if (swapBalance_ < contractBalance_) {\n                projectTaxPendingSwap -= uint128(\n                    (projectTaxPendingSwap * swapBalance_) / contractBalance_\n                );\n            } else {\n                projectTaxPendingSwap = 0;\n            }\n        } catch {\n            // Dont allow a failed external call (in this case to uniswap) to stop a transfer.\n            // Emit that this has occured and continue.\n            emit ExternalCallError(5);\n        }\n    }\n\n    /**\n     * @dev distributeTaxTokens\n     *\n     * Allows the distribution of tax tokens to the designated recipient(s)\n     *\n     * As part of standard processing the tax token balance being above the threshold\n     * will trigger an autoswap to ETH and distribution of this ETH to the designated\n     * recipients. This is automatic and there is no need for user involvement.\n     *\n     * As part of this swap there are a number of calculations performed, particularly\n     * if the tax balance is above MAX_SWAP_THRESHOLD_MULTIPLE.\n     *\n     * Testing indicates that these calculations are safe. But given the data / code\n     * interactions it remains possible that some edge case set of scenarios may cause\n     * an issue with these calculations.\n     *\n     * This method is therefore provided as a 'fallback' option to safely distribute\n     * accumulated taxes from the contract, with a direct transfer of the ERC20 tokens\n     * themselves.\n     */\n    function distributeTaxTokens() external {\n        if (projectTaxPendingSwap > 0) {\n            uint256 projectDistribution = projectTaxPendingSwap;\n            projectTaxPendingSwap = 0;\n            _transfer(\n                address(this),\n                projectTaxRecipient,\n                projectDistribution,\n                false\n            );\n        }\n    }\n\n    /**\n     * @dev function {withdrawETH} onlyOwnerOrFactory\n     *\n     * A withdraw function to allow ETH to be withdrawn by the manager\n     *\n     * This contract should never hold ETH. The only envisaged scenario where\n     * it might hold ETH is a failed autoswap where the uniswap swap has completed,\n     * the recipient of ETH reverts, the contract then wraps to WETH and the\n     * wrap to WETH fails.\n     *\n     * This feels unlikely. But, for safety, we include this method.\n     *\n     * @param amount_ The amount to withdraw\n     */\n    function withdrawETH(uint256 amount_) external onlyOwnerOrFactory {\n        (bool success, ) = _msgSender().call{value: amount_}(\"\");\n        if (!success) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @dev function {withdrawERC20} onlyOwnerOrFactory\n     *\n     * A withdraw function to allow ERC20s (except address(this)) to be withdrawn.\n     *\n     * This contract should never hold ERC20s other than tax tokens. The only envisaged\n     * scenario where it might hold an ERC20 is a failed autoswap where the uniswap swap\n     * has completed, the recipient of ETH reverts, the contract then wraps to WETH, the\n     * wrap to WETH succeeds, BUT then the transfer of WETH fails.\n     *\n     * This feels even less likely than the scenario where ETH is held on the contract.\n     * But, for safety, we include this method.\n     *\n     * @param token_ The ERC20 contract\n     * @param amount_ The amount to withdraw\n     */\n    function withdrawERC20(\n        address token_,\n        uint256 amount_\n    ) external onlyOwnerOrFactory {\n        if (token_ == address(this)) {\n            revert CannotWithdrawThisToken();\n        }\n        IERC20(token_).safeTransfer(_msgSender(), amount_);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) {\n            revert MintToZeroAddress();\n        }\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += uint128(amount);\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        if (account == address(0)) {\n            revert BurnFromTheZeroAddress();\n        }\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        if (accountBalance < amount) {\n            revert BurnExceedsBalance();\n        }\n\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= uint128(amount);\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        if (owner == address(0)) {\n            revert ApproveFromTheZeroAddress();\n        }\n\n        if (spender == address(0)) {\n            revert ApproveToTheZeroAddress();\n        }\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < amount) {\n                revert InsufficientAllowance();\n            }\n\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    receive() external payable {}\n}\n"
    }
}