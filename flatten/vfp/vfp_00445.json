{
    "vfp_id": "vfp_00445",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ]
            },
            "title": "W6: Invalid tagging of memory-safe assembly",
            "description": "The SSZ library uses inline assembly blocks that are tagged with a single-line comment `// @solidity memory-safe-assembly`. However, the Solidity compiler only recognizes memory-safe assembly tags when they are written as NatSpec comments using triple slashes (`///`). The incorrect comment syntax fails to properly signal memory safety to the compiler, which may result in unnecessary memory clobbering or missed optimizations. This issue arises due to a misunderstanding of Solidity's syntax requirements for memory-safe assembly annotations. Although the impact is limited to compiler-level optimizations and does not introduce direct security risks, it may affect runtime behavior in unexpected ways under certain conditions. The consequence is a warning-level issue related to code correctness and compiler interaction.\n",
            "severity": "Informational",
            "location": [
                "SSZ.sol#30",
                "SSZ.sol#121",
                "SSZ.sol#187"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/lib/SSZ.sol"
            ]
        }
    ],
    "affected_files": {
        "SSZ.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { BeaconBlockHeader, Withdrawal, Validator } from \"./Types.sol\";\nimport { GIndex } from \"./GIndex.sol\";\n\nlibrary SSZ {\n    error BranchHasMissingItem();\n    error BranchHasExtraItem();\n    error InvalidProof();\n\n    function hashTreeRoot(\n        BeaconBlockHeader memory header\n    ) internal view returns (bytes32 root) {\n        root = bytes32(0);\n\n        bytes32[8] memory nodes = [\n            toLittleEndian(header.slot.unwrap()),\n            toLittleEndian(header.proposerIndex),\n            header.parentRoot,\n            header.stateRoot,\n            header.bodyRoot,\n            bytes32(0),\n            bytes32(0),\n            bytes32(0)\n        ];\n\n        // @solidity memory-safe-assembly\n        assembly {\n            // Count of nodes to hash\n            let count := 8\n\n            // Loop over levels\n            // prettier-ignore\n            for { } 1 { } {\n                // Loop over nodes at the given depth\n\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let target := nodes\n                let source := nodes\n                let end := add(source, shl(5, count))\n\n                // prettier-ignore\n                for { } 1 { } {\n                    // Read next two hashes to hash\n                    mcopy(0x00, source, 0x40)\n\n                    // Call sha256 precompile\n                    let result := staticcall(\n                        gas(),\n                        0x02,\n                        0x00,\n                        0x40,\n                        0x00,\n                        0x20\n                    )\n\n                    if iszero(result) {\n                        // Precompiles returns no data on OutOfGas error.\n                        revert(0, 0)\n                    }\n\n                    // Store the resulting hash at the target location\n                    mstore(target, mload(0x00))\n\n                    // Advance the pointers\n                    target := add(target, 0x20)\n                    source := add(source, 0x40)\n\n                    if iszero(lt(source, end)) {\n                        break\n                    }\n                }\n\n                count := shr(1, count)\n                if eq(count, 1) {\n                    root := mload(0x00)\n                    break\n                }\n            }\n        }\n    }\n\n    function hashTreeRoot(\n        Validator memory validator\n    ) internal view returns (bytes32 root) {\n        root = bytes32(0);\n\n        bytes32 pubkeyRoot;\n        assembly {\n            // Dynamic data types such as bytes are stored at the specified offset.\n            let offset := mload(validator)\n            // Copy the pubkey to the scratch space.\n            mcopy(0x00, add(offset, 32), 48)\n            // Clear the last 16 bytes.\n            mcopy(48, 0x60, 16)\n            // Call sha256 precompile.\n            let result := staticcall(gas(), 0x02, 0x00, 0x40, 0x00, 0x20)\n\n            if iszero(result) {\n                // Precompiles returns no data on OutOfGas error.\n                revert(0, 0)\n            }\n\n            pubkeyRoot := mload(0x00)\n        }\n\n        bytes32[8] memory nodes = [\n            pubkeyRoot,\n            validator.withdrawalCredentials,\n            toLittleEndian(validator.effectiveBalance),\n            toLittleEndian(validator.slashed),\n            toLittleEndian(validator.activationEligibilityEpoch),\n            toLittleEndian(validator.activationEpoch),\n            toLittleEndian(validator.exitEpoch),\n            toLittleEndian(validator.withdrawableEpoch)\n        ];\n\n        // @solidity memory-safe-assembly\n        assembly {\n            // Count of nodes to hash\n            let count := 8\n\n            // Loop over levels\n            // prettier-ignore\n            for { } 1 { } {\n                // Loop over nodes at the given depth\n\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let target := nodes\n                let source := nodes\n                let end := add(source, shl(5, count))\n\n                // prettier-ignore\n                for { } 1 { } {\n                    // Read next two hashes to hash\n                    mcopy(0x00, source, 0x40)\n\n                    // Call sha256 precompile\n                    let result := staticcall(\n                        gas(),\n                        0x02,\n                        0x00,\n                        0x40,\n                        0x00,\n                        0x20\n                    )\n\n                    if iszero(result) {\n                        // Precompiles returns no data on OutOfGas error.\n                        revert(0, 0)\n                    }\n\n                    // Store the resulting hash at the target location\n                    mstore(target, mload(0x00))\n\n                    // Advance the pointers\n                    target := add(target, 0x20)\n                    source := add(source, 0x40)\n\n                    if iszero(lt(source, end)) {\n                        break\n                    }\n                }\n\n                count := shr(1, count)\n                if eq(count, 1) {\n                    root := mload(0x00)\n                    break\n                }\n            }\n        }\n    }\n\n    /// @notice Modified version of `verify` from Solady `MerkleProofLib` to support generalized indices and sha256 precompile.\n    /// @dev Reverts if `leaf` doesn't exist in the Merkle tree with `root`, given `proof`.\n    function verifyProof(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        GIndex gI\n    ) internal view {\n        uint256 index = gI.index();\n\n        // @solidity memory-safe-assembly\n        assembly {\n            // Check if `proof` is empty.\n            if iszero(proof.length) {\n                // revert InvalidProof()\n                mstore(0x00, 0x09bde339)\n                revert(0x1c, 0x04)\n            }\n            // Left shift by 5 is equivalent to multiplying by 0x20.\n            let end := add(proof.offset, shl(5, proof.length))\n            // Initialize `offset` to the offset of `proof` in the calldata.\n            let offset := proof.offset\n            // Iterate over proof elements to compute root hash.\n            // prettier-ignore\n            for { } 1 { } {\n                // Slot of `leaf` in scratch space.\n                // If the condition is true: 0x20, otherwise: 0x00.\n                let scratch := shl(5, and(index, 1))\n                index := shr(1, index)\n                if iszero(index) {\n                    // revert BranchHasExtraItem()\n                    mstore(0x00, 0x5849603f)\n                    // 0x1c = 28 => offset in 32-byte word of a slot 0x00\n                    revert(0x1c, 0x04)\n                }\n                // Store elements to hash contiguously in scratch space.\n                // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                mstore(scratch, leaf)\n                mstore(xor(scratch, 0x20), calldataload(offset))\n                // Call sha256 precompile.\n                let result := staticcall(\n                    gas(),\n                    0x02,\n                    0x00,\n                    0x40,\n                    0x00,\n                    0x20\n                )\n\n                if iszero(result) {\n                    // Precompile returns no data on OutOfGas error.\n                    revert(0, 0)\n                }\n\n                // Reuse `leaf` to store the hash to reduce stack operations.\n                leaf := mload(0x00)\n                offset := add(offset, 0x20)\n                if iszero(lt(offset, end)) {\n                    break\n                }\n            }\n\n            if iszero(eq(index, 1)) {\n                // revert BranchHasMissingItem()\n                mstore(0x00, 0x1b6661c3)\n                revert(0x1c, 0x04)\n            }\n\n            if iszero(eq(leaf, root)) {\n                // revert InvalidProof()\n                mstore(0x00, 0x09bde339)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    // Inspired by https://github.com/succinctlabs/telepathy-contracts/blob/5aa4bb7/src/libraries/SimpleSerialize.sol#L59\n    function hashTreeRoot(\n        Withdrawal memory withdrawal\n    ) internal pure returns (bytes32) {\n        return\n            sha256(\n                bytes.concat(\n                    sha256(\n                        bytes.concat(\n                            toLittleEndian(withdrawal.index),\n                            toLittleEndian(withdrawal.validatorIndex)\n                        )\n                    ),\n                    sha256(\n                        bytes.concat(\n                            bytes20(withdrawal.withdrawalAddress),\n                            bytes12(0),\n                            toLittleEndian(withdrawal.amount)\n                        )\n                    )\n                )\n            );\n    }\n\n    // See https://github.com/succinctlabs/telepathy-contracts/blob/5aa4bb7/src/libraries/SimpleSerialize.sol#L17-L28\n    function toLittleEndian(uint256 v) internal pure returns (bytes32) {\n        v =\n            ((v &\n                0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n                8) |\n            ((v &\n                0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) <<\n                8);\n        v =\n            ((v &\n                0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                16) |\n            ((v &\n                0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) <<\n                16);\n        v =\n            ((v &\n                0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\n                32) |\n            ((v &\n                0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) <<\n                32);\n        v =\n            ((v &\n                0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\n                64) |\n            ((v &\n                0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) <<\n                64);\n        v = (v >> 128) | (v << 128);\n        return bytes32(v);\n    }\n\n    function toLittleEndian(bool v) internal pure returns (bytes32) {\n        return bytes32(v ? 1 << 248 : 0);\n    }\n}\n"
    }
}