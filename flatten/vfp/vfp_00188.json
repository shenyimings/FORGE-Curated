{
    "vfp_id": "vfp_00188",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "solverGasLiability() overestimated when multipleSuccessfulSolvers == true",
            "description": "1. **Description:** The solverGasLiability() function overestimates the gas liability for solvers when multipleSuccessfulSolvers == true, as it assumes each solver must pay for all calldata rather than just their own.\n2. **Cause:** The function's logic was designed before the multipleSuccessfulSolvers feature and does not account for shared calldata costs in that mode.\n3. **Exploitation:** While not directly exploitable for gain, this overestimation leads to inefficient gas accounting and higher prepayment requirements than necessary.\n4. **Impact:** Solvers may be required to prepay more gas than needed, reducing capital efficiency and increasing operational costs.\n",
            "severity": "Low",
            "location": [
                "GasAccLib.sol#L71-L82"
            ],
            "files": [
                "atlas/src/contracts/libraries/GasAccLib.sol"
            ]
        }
    ],
    "affected_files": {
        "GasAccLib.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { SafeCast } from \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport { AccountingMath } from \"./AccountingMath.sol\";\nimport { IL2GasCalculator } from \"../interfaces/IL2GasCalculator.sol\";\nimport { SolverOperation } from \"../types/SolverOperation.sol\";\n\n// All GasLedger vars are measured in units of gas.\n// All GasLedger vars also include calldata and execution gas components.\n// remainingMaxGas and unreachedSolverGas measure max gas limits (C + E).\n// writeoffsGas and solverFaultFailureGas measure actual gas used (C + E).\n// Only stores base gas values. Does not include the surcharges or gasprice components.\n// type(uint40).max ~= 1.09 x 10^12, plenty even for gigagas (10^9) blocks\nstruct GasLedger {\n    uint40 remainingMaxGas; // Measured at start, decreased by solverOp gas limits when reached\n    uint40 writeoffsGas; // Gas used for solverOps but written off due to bundler fault\n    uint40 solverFaultFailureGas; // Gas used by solverOps that failed due to solver fault\n    uint40 unreachedSolverGas; // Sum of gas limits of solverOps not yet reached in the current metacall\n    uint40 maxApprovedGasSpend; // Max gas units approved by current solver to be spent from their bonded atlETH\n    uint24 atlasSurchargeRate; // Scale is 10_000 (100%) --> max atlas surcharge rate ~= 167.77x or 16777%\n    uint24 bundlerSurchargeRate; // Scale is 10_000 (100%) --> max bundler surcharge rate ~= 167.77x or 16777%\n        // NOTE: 8 bits unused.\n}\n\n// All BorrowsLedger vars are measured in units of native token (wei).\nstruct BorrowsLedger {\n    uint128 borrows; // Total native token value borrowed in the current metacall\n    uint128 repays; // Total native token value repaid in the current metacall\n}\n\nlibrary GasAccLib {\n    using AccountingMath for uint256;\n    using SafeCast for uint256;\n\n    uint256 internal constant _SOLVER_OP_BASE_CALLDATA = 608;\n    uint256 internal constant _CALLDATA_LENGTH_PREMIUM_HALVED = 8;\n\n    function pack(GasLedger memory gasLedger) internal pure returns (uint256) {\n        return uint256(gasLedger.remainingMaxGas) | (uint256(gasLedger.writeoffsGas) << 40)\n            | (uint256(gasLedger.solverFaultFailureGas) << 80) | (uint256(gasLedger.unreachedSolverGas) << 120)\n            | (uint256(gasLedger.maxApprovedGasSpend) << 160) | (uint256(gasLedger.atlasSurchargeRate) << 200)\n            | (uint256(gasLedger.bundlerSurchargeRate) << 224);\n    }\n\n    function pack(BorrowsLedger memory borrowsLedger) internal pure returns (uint256) {\n        return uint256(borrowsLedger.borrows) | (uint256(borrowsLedger.repays) << 128);\n    }\n\n    function toGasLedger(uint256 gasLedgerPacked) internal pure returns (GasLedger memory) {\n        return GasLedger({\n            remainingMaxGas: uint40(gasLedgerPacked),\n            writeoffsGas: uint40(gasLedgerPacked >> 40),\n            solverFaultFailureGas: uint40(gasLedgerPacked >> 80),\n            unreachedSolverGas: uint40(gasLedgerPacked >> 120),\n            maxApprovedGasSpend: uint40(gasLedgerPacked >> 160),\n            atlasSurchargeRate: uint24(gasLedgerPacked >> 200),\n            bundlerSurchargeRate: uint24(gasLedgerPacked >> 224)\n        });\n    }\n\n    function toBorrowsLedger(uint256 borrowsLedgerPacked) internal pure returns (BorrowsLedger memory) {\n        return BorrowsLedger({ borrows: uint128(borrowsLedgerPacked), repays: uint128(borrowsLedgerPacked >> 128) });\n    }\n\n    function netRepayments(BorrowsLedger memory bL) internal pure returns (int256) {\n        return uint256(bL.repays).toInt256() - uint256(bL.borrows).toInt256();\n    }\n\n    // Returns the max gas liability (in native token units) for the current solver.\n    // `remainingMaxGas` is max gas limit as measured at start of metacall, with the gas limit of each solverOp\n    // subtracted at the end of its execution.\n    // `unreachedSolverGas` is the sum of solverOp gas limits not yet reached, with gas limit of current solverOp\n    // subtracted at the start of its execution, before bonded balance check.\n    // Thus `remainingMaxGas - unreachedSolverGas` is the max gas the current solver might need to pay for if they win,\n    // including dApp hook gas limits and userOp gas limit.\n    function solverGasLiability(GasLedger memory gL) internal view returns (uint256) {\n        return uint256(gL.remainingMaxGas - gL.unreachedSolverGas).withSurcharge(\n            uint256(gL.atlasSurchargeRate + gL.bundlerSurchargeRate)\n        ) * tx.gasprice;\n    }\n\n    // Returns the sum of the Atlas and bundler surcharge rates.\n    // Scale of the returned value is 10_000 (100%).\n    function totalSurchargeRate(GasLedger memory gL) internal pure returns (uint256) {\n        return uint256(gL.atlasSurchargeRate + gL.bundlerSurchargeRate);\n    }\n\n    function solverOpCalldataGas(uint256 calldataLength, address l2GasCalculator) internal view returns (uint256 gas) {\n        if (l2GasCalculator == address(0)) {\n            // Default to using mainnet gas calculations\n            // _SOLVER_OP_BASE_CALLDATA = SolverOperation calldata length excluding solverOp.data\n            gas = (calldataLength + _SOLVER_OP_BASE_CALLDATA) * _CALLDATA_LENGTH_PREMIUM_HALVED;\n        } else {\n            gas = IL2GasCalculator(l2GasCalculator).getCalldataGas(calldataLength + _SOLVER_OP_BASE_CALLDATA);\n        }\n    }\n\n    function calldataGas(uint256 calldataLength, address l2GasCalculator) internal view returns (uint256 gas) {\n        if (l2GasCalculator == address(0)) {\n            // Default to using mainnet gas calculations\n            gas = calldataLength * _CALLDATA_LENGTH_PREMIUM_HALVED;\n        } else {\n            gas = IL2GasCalculator(l2GasCalculator).getCalldataGas(calldataLength);\n        }\n    }\n\n    function metacallCalldataGas(\n        uint256 msgDataLength,\n        address l2GasCalculator\n    )\n        internal\n        view\n        returns (uint256 calldataGas)\n    {\n        if (l2GasCalculator == address(0)) {\n            calldataGas = msgDataLength * _CALLDATA_LENGTH_PREMIUM_HALVED;\n        } else {\n            calldataGas = IL2GasCalculator(l2GasCalculator).initialGasUsed(msgDataLength);\n        }\n    }\n}\n"
    }
}