{
    "vfp_id": "vfp_00042",
    "project_name": "ChainSecurity_MellowFinance_Multivault_Audit.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Overly Sensitive Reverting in Ratios Strategy",
            "description": "The RatiosStrategy reverts during withdrawal or rebalancing if any adapter returns true for areWithdrawalsPaused(), even if the paused subvault is not involved in the current operation. For example, a withdrawal might pull funds from an underallocated subvault with available liquidity, yet the strategy reverts due to an unrelated paused subvault. Similarly, a rebalance that deposits into a paused subvault should be allowed, but the strategy incorrectly reverts. The root cause is overly broad error handling that does not assess the actual impact of the pause on the specific operation. This leads to unnecessary transaction failures and denial-of-service conditions during routine operations. The impact is reduced system availability and user frustration due to preventable reverts, even when sufficient liquidity exists elsewhere.\n",
            "severity": "Low",
            "location": [
                "RatiosStrategy::calculateState",
                "areWithdrawalsPaused"
            ],
            "files": [
                "simple-lrt/src/strategies/RatiosStrategy.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "EigenLayer Withdrawals Attempted When Maximum Is Reached",
            "description": "The system limits EigenLayer withdrawals to 14 (15 during shutdown), but the RatioStrategy is unaware of this limit and does not treat the withdrawal queue as paused when the limit is reached. This causes the vault to attempt withdrawals even when no new requests can be created, leading to transaction reverts. The root cause is the lack of integration between the withdrawal limit enforcement and the strategy logic. As a result, vault withdrawal operations may be temporarily denied, leading to a denial-of-service (DoS) condition. An attacker could potentially trigger this by filling the withdrawal queue, blocking legitimate user withdrawals and rebalancing operations. The impact is a temporary disruption of core vault functionality, reducing user trust and operational reliability.\n",
            "severity": "Low",
            "location": [
                "RatioStrategy::calculateState",
                "Vault::requestWithdrawal"
            ],
            "files": [
                "simple-lrt/src/strategies/RatiosStrategy.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Maximum Computation in Ratios Strategy",
            "description": "The `RatiosStrategy.calculateState()` function incorrectly computes the maximum deposit limit by including `claimable` and `pending` assets in the total, when only `staked` assets should count toward the protocol's current exposure. The logic adds `multiVault.maxDeposit(i)` to the sum of `staked`, `pending`, and `claimable` assets, overestimating the allowable deposit. After a large withdrawal increases `pending` assets, the system may attempt a deposit that exceeds the actual capacity of the external protocol, causing the transaction to revert. This leads to partial denial-of-service during rebalancing, where valid reallocations fail due to incorrect accounting.\n",
            "severity": "Low",
            "location": [
                "RatiosStrategy.calculateState"
            ],
            "files": [
                "simple-lrt/src/strategies/RatiosStrategy.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Incorrect Maximum Deposit Computation in Ratio Strategy",
            "description": "The `RatioStrategy.calculateState()` function fails to handle potential overflows when computing the maximum deposit limit, as it lacks an `else` branch to set the maximum to `uint256.max` when addition would overflow. The condition `if (type(uint256).max - assets >= state[i].max)` safely avoids overflow but does not set `state[i].max` to the maximum value when the condition fails. In rare cases where `assets` is very large (e.g., near `uint256.max`), the computed maximum deposit will be incorrect, leading to suboptimal or failed allocations. Incorrect strategy calculations could result in underutilization of available deposit capacity or failed rebalances.\n",
            "severity": "Low",
            "location": [
                "RatioStrategy.calculateState"
            ],
            "files": [
                "simple-lrt/src/strategies/RatiosStrategy.sol"
            ]
        }
    ],
    "affected_files": {
        "RatiosStrategy.sol": "// // SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.25;\n\nimport \"../interfaces/strategies/IRatiosStrategy.sol\";\n\ncontract RatiosStrategy is IRatiosStrategy {\n    /// @inheritdoc IRatiosStrategy\n    uint256 public constant D18 = 1e18;\n    /// @inheritdoc IRatiosStrategy\n    bytes32 public constant RATIOS_STRATEGY_SET_RATIOS_ROLE =\n        keccak256(\"RATIOS_STRATEGY_SET_RATIOS_ROLE\");\n\n    /// @inheritdoc IRatiosStrategy\n    mapping(address vault => mapping(address subvault => Ratio)) public ratios;\n\n    /// @inheritdoc IRatiosStrategy\n    function setRatios(address vault, address[] calldata subvaults, Ratio[] calldata ratios_)\n        external\n    {\n        require(\n            IAccessControl(vault).hasRole(RATIOS_STRATEGY_SET_RATIOS_ROLE, msg.sender),\n            \"RatiosStrategy: forbidden\"\n        );\n        require(\n            subvaults.length == ratios_.length,\n            \"RatiosStrategy: subvaults and ratios length mismatch\"\n        );\n        IMultiVault multiVault = IMultiVault(vault);\n        uint256 n = subvaults.length;\n        for (uint256 i = 0; i < n; i++) {\n            if (multiVault.indexOfSubvault(subvaults[i]) != 0) {\n                require(\n                    ratios_[i].minRatioD18 <= ratios_[i].maxRatioD18\n                        && ratios_[i].maxRatioD18 <= D18,\n                    \"RatiosStrategy: invalid ratios\"\n                );\n            } else {\n                require(\n                    ratios_[i].minRatioD18 == 0 && ratios_[i].maxRatioD18 == 0,\n                    \"RatiosStrategy: invalid subvault\"\n                );\n            }\n        }\n        mapping(address => Ratio) storage vaultRatios_ = ratios[vault];\n        for (uint256 i = 0; i < n; i++) {\n            vaultRatios_[subvaults[i]] = ratios_[i];\n        }\n\n        emit RatiosSet(vault, subvaults, ratios_);\n    }\n\n    /// @inheritdoc IRatiosStrategy\n    function calculateState(address vault, bool isDeposit, uint256 increment)\n        public\n        view\n        returns (Amounts[] memory state, uint256 liquid)\n    {\n        IMultiVault multiVault = IMultiVault(vault);\n        uint256 n = multiVault.subvaultsCount();\n        state = new Amounts[](n);\n\n        liquid = IERC20(IERC4626(vault).asset()).balanceOf(vault);\n        IDefaultCollateral collateral = multiVault.defaultCollateral();\n        if (address(collateral) != address(0)) {\n            liquid += collateral.balanceOf(vault);\n        }\n        uint256 totalAssets = liquid;\n        IMultiVaultStorage.Subvault memory subvault;\n        for (uint256 i = 0; i < n; i++) {\n            subvault = multiVault.subvaultAt(i);\n            IProtocolAdapter adapter = multiVault.adapterOf(subvault.protocol);\n            state[i].staked = adapter.stakedAt(subvault.vault);\n            if (!isDeposit && adapter.areWithdrawalsPaused(subvault.vault, vault)) {\n                revert(\"RatiosStrategy: withdrawals paused\");\n            }\n            if (subvault.withdrawalQueue != address(0)) {\n                state[i].claimable =\n                    IWithdrawalQueue(subvault.withdrawalQueue).claimableAssetsOf(vault);\n                state[i].pending = IWithdrawalQueue(subvault.withdrawalQueue).pendingAssetsOf(vault);\n                totalAssets += state[i].staked + state[i].pending + state[i].claimable;\n            } else {\n                totalAssets += state[i].staked;\n            }\n            uint256 maxDeposit = adapter.maxDeposit(subvault.vault);\n            if (type(uint256).max - state[i].staked > maxDeposit) {\n                state[i].max = maxDeposit + state[i].staked;\n            } else {\n                state[i].max = type(uint256).max;\n            }\n        }\n        totalAssets = isDeposit ? totalAssets + increment : totalAssets - increment;\n        mapping(address => Ratio) storage vaultRatios_ = ratios[vault];\n        for (uint256 i = 0; i < n; i++) {\n            Ratio memory ratio = vaultRatios_[multiVault.subvaultAt(i).vault];\n            if (ratio.maxRatioD18 == 0) {\n                state[i].max = 0;\n                state[i].min = 0;\n            } else {\n                state[i].max = Math.min(state[i].max, (totalAssets * ratio.maxRatioD18) / D18);\n                state[i].min = Math.min(state[i].max, (totalAssets * ratio.minRatioD18) / D18);\n            }\n        }\n    }\n\n    /// @inheritdoc IDepositStrategy\n    function calculateDepositAmounts(address vault, uint256 amount)\n        external\n        view\n        override\n        returns (DepositData[] memory data)\n    {\n        (Amounts[] memory state,) = calculateState(vault, true, amount);\n        uint256 n = state.length;\n        for (uint256 i = 0; i < n; i++) {\n            uint256 assets_ = state[i].staked;\n            if (state[i].min > assets_) {\n                state[i].min -= assets_;\n                state[i].max -= assets_;\n            } else if (state[i].max > assets_) {\n                state[i].min = 0;\n                state[i].max -= assets_;\n            } else {\n                state[i].min = 0;\n                state[i].max = 0;\n            }\n        }\n        data = new DepositData[](n);\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            data[i].subvaultIndex = i;\n            if (state[i].min == 0) {\n                continue;\n            }\n            uint256 assets_ = Math.min(state[i].min, amount);\n            state[i].max -= assets_;\n            amount -= assets_;\n            data[i].deposit = assets_;\n        }\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            if (state[i].max == 0) {\n                continue;\n            }\n            uint256 assets_ = Math.min(state[i].max, amount);\n            amount -= assets_;\n            data[i].deposit += assets_;\n        }\n        uint256 count = 0;\n        for (uint256 i = 0; i < n; i++) {\n            if (data[i].deposit != 0) {\n                if (count != i) {\n                    data[count] = data[i];\n                }\n                count++;\n            }\n        }\n        assembly {\n            mstore(data, count)\n        }\n    }\n\n    /// @inheritdoc IWithdrawalStrategy\n    function calculateWithdrawalAmounts(address vault, uint256 amount)\n        external\n        view\n        override\n        returns (WithdrawalData[] memory data)\n    {\n        (Amounts[] memory state, uint256 liquid) = calculateState(vault, false, amount);\n        if (amount <= liquid) {\n            return data;\n        }\n        amount -= liquid;\n        uint256 n = state.length;\n        data = new WithdrawalData[](n);\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            data[i].subvaultIndex = i;\n            if (state[i].staked > state[i].max) {\n                uint256 extra = state[i].staked - state[i].max;\n                if (extra > amount) {\n                    data[i].staked = amount;\n                    amount = 0;\n                } else {\n                    data[i].staked = extra;\n                    amount -= extra;\n                }\n                state[i].staked -= data[i].staked;\n            }\n        }\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            if (state[i].staked > state[i].min) {\n                uint256 allowed = state[i].staked - state[i].min;\n                if (allowed > amount) {\n                    data[i].staked += amount;\n                    amount = 0;\n                } else {\n                    data[i].staked += allowed;\n                    amount -= allowed;\n                    state[i].staked -= allowed;\n                }\n            }\n        }\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            if (state[i].pending > 0) {\n                if (state[i].pending > amount) {\n                    data[i].pending += amount;\n                    amount = 0;\n                } else {\n                    data[i].pending += state[i].pending;\n                    amount -= state[i].pending;\n                }\n            }\n        }\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            if (state[i].claimable > 0) {\n                if (state[i].claimable > amount) {\n                    data[i].claimable += amount;\n                    amount = 0;\n                } else {\n                    data[i].claimable += state[i].claimable;\n                    amount -= state[i].claimable;\n                }\n            }\n        }\n        for (uint256 i = 0; i < n && amount != 0; i++) {\n            uint256 staked = state[i].staked;\n            if (staked > 0) {\n                if (staked > amount) {\n                    data[i].staked += amount;\n                    amount = 0;\n                } else {\n                    data[i].staked += staked;\n                    amount -= staked;\n                }\n            }\n        }\n\n        uint256 count = 0;\n        for (uint256 i = 0; i < n; i++) {\n            if (data[i].staked + data[i].pending + data[i].claimable != 0) {\n                if (count != i) {\n                    data[count] = data[i];\n                }\n                count++;\n            }\n        }\n        assembly {\n            mstore(data, count)\n        }\n    }\n\n    /// @inheritdoc IRebalanceStrategy\n    function calculateRebalanceAmounts(address vault)\n        external\n        view\n        override\n        returns (RebalanceData[] memory data)\n    {\n        (Amounts[] memory state, uint256 liquid) = calculateState(vault, false, 0);\n        uint256 n = state.length;\n        data = new RebalanceData[](n);\n        uint256 totalRequired = 0;\n        uint256 pending = 0;\n        for (uint256 i = 0; i < n; i++) {\n            data[i].subvaultIndex = i;\n            data[i].claimable = state[i].claimable;\n            liquid += state[i].claimable;\n            pending += state[i].pending;\n            if (state[i].staked > state[i].max) {\n                data[i].staked = state[i].staked - state[i].max;\n                pending += data[i].staked;\n                state[i].staked = state[i].max;\n            }\n            if (state[i].min > state[i].staked) {\n                totalRequired += state[i].min - state[i].staked;\n            }\n        }\n\n        if (totalRequired > liquid + pending) {\n            uint256 unstake = totalRequired - liquid - pending;\n            for (uint256 i = 0; i < n && unstake > 0; i++) {\n                if (state[i].staked > state[i].min) {\n                    uint256 allowed = state[i].staked - state[i].min;\n                    if (allowed > unstake) {\n                        data[i].staked += unstake;\n                        unstake = 0;\n                    } else {\n                        data[i].staked += allowed;\n                        unstake -= allowed;\n                    }\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < n && liquid > 0; i++) {\n            if (state[i].staked < state[i].min) {\n                uint256 required = state[i].min - state[i].staked;\n                if (required > liquid) {\n                    data[i].deposit = liquid;\n                    liquid = 0;\n                } else {\n                    data[i].deposit = required;\n                    liquid -= required;\n                    state[i].max -= data[i].deposit;\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < n && liquid > 0; i++) {\n            if (state[i].staked < state[i].max) {\n                uint256 allowed = state[i].max - state[i].staked;\n                if (allowed > liquid) {\n                    data[i].deposit += liquid;\n                    liquid = 0;\n                } else {\n                    data[i].deposit += allowed;\n                    liquid -= allowed;\n                }\n            }\n        }\n    }\n}\n"
    }
}