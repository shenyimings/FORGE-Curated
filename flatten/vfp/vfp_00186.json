{
    "vfp_id": "vfp_00186",
    "project_name": "2024-12-balancer-v3-securityreview.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Quote functions should not be payable",
            "description": "The VaultExtension.quote and VaultExtension.quoteAndRevert functions are marked as payable, but they cannot receive Ether due to the Vault's fallback function reverting on non-zero msg.value. This creates a contradiction in the contract design. The cause is an unnecessary payable modifier on functions that do not and cannot handle Ether. While these functions use msg.value in their logic, the proxy architecture ensures msg.value is always zero when they are called. This issue does not lead to direct exploitation but indicates poor code hygiene and potential confusion for integrators. An attacker cannot exploit this to cause harm, as the system rejects Ether at the entry point. The impact is purely informational, affecting code clarity and maintainability rather than security.\n",
            "severity": "Informational",
            "location": [
                "Vault.sol::fallback#1436-1442",
                "VaultExtension.sol::quote#843-851",
                "VaultExtension.sol::quoteAndRevert",
                "https://github.com/balancer/balancer-v3-monorepo/pull/863"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultExtension.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Reentrancy on pool initialization allows users to re-initialize pools",
            "description": "The initialize function in VaultExtension.sol follows an incorrect check-effect-interaction pattern, where it checks if a pool is already initialized at the beginning but only marks it as initialized after an external call via the BeforeInitialize hook. This creates a window for reentrancy: a malicious contract can re-enter the initialize function during the hook call and re-initialize the pool multiple times. Since state changes occur after external calls, the attacker can manipulate pool behavior, potentially leading to unexpected state transitions or economic impacts. The severity is undetermined due to time constraints in fully assessing the impact, but the flaw enables repeated initialization which could be abused in combination with other actions like swapping or liquidity manipulation.\n",
            "severity": "Informational",
            "location": [
                "VaultExtension.sol::initialize#364-379",
                "VaultExtension.sol::initialize#391-392",
                "VaultExtension.sol::initialize#443-446",
                "https://github.com/balancer/balancer-v3-monorepo/pull/899"
            ],
            "files": [
                "a24ebf0141e9350a42639d8593c1436241deae59/balancer-v3-monorepo/pkg/vault/contracts/VaultExtension.sol"
            ]
        }
    ],
    "affected_files": {
        "VaultExtension.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.24;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IBasePool } from \"@balancer-labs/v3-interfaces/contracts/vault/IBasePool.sol\";\nimport { IHooks } from \"@balancer-labs/v3-interfaces/contracts/vault/IHooks.sol\";\nimport { IProtocolFeeController } from \"@balancer-labs/v3-interfaces/contracts/vault/IProtocolFeeController.sol\";\nimport { IRateProvider } from \"@balancer-labs/v3-interfaces/contracts/vault/IRateProvider.sol\";\nimport { IVault } from \"@balancer-labs/v3-interfaces/contracts/vault/IVault.sol\";\nimport { IVaultAdmin } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultAdmin.sol\";\nimport { IVaultExtension } from \"@balancer-labs/v3-interfaces/contracts/vault/IVaultExtension.sol\";\nimport { IAuthentication } from \"@balancer-labs/v3-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol\";\nimport \"@balancer-labs/v3-interfaces/contracts/vault/VaultTypes.sol\";\n\nimport { CastingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/CastingHelpers.sol\";\nimport { InputHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/InputHelpers.sol\";\nimport { RevertCodec } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/RevertCodec.sol\";\nimport { ScalingHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport { EVMCallModeHelpers } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/EVMCallModeHelpers.sol\";\nimport {\n    TransientStorageHelpers\n} from \"@balancer-labs/v3-solidity-utils/contracts/helpers/TransientStorageHelpers.sol\";\nimport { BasePoolMath } from \"@balancer-labs/v3-solidity-utils/contracts/math/BasePoolMath.sol\";\nimport { StorageSlotExtension } from \"@balancer-labs/v3-solidity-utils/contracts/openzeppelin/StorageSlotExtension.sol\";\nimport { FixedPoint } from \"@balancer-labs/v3-solidity-utils/contracts/math/FixedPoint.sol\";\nimport { PackedTokenBalance } from \"@balancer-labs/v3-solidity-utils/contracts/helpers/PackedTokenBalance.sol\";\n\nimport { VaultStateBits, VaultStateLib } from \"./lib/VaultStateLib.sol\";\nimport { PoolConfigLib, PoolConfigBits } from \"./lib/PoolConfigLib.sol\";\nimport { HooksConfigLib } from \"./lib/HooksConfigLib.sol\";\nimport { VaultExtensionsLib } from \"./lib/VaultExtensionsLib.sol\";\nimport { VaultCommon } from \"./VaultCommon.sol\";\nimport { PoolDataLib } from \"./lib/PoolDataLib.sol\";\n\n/**\n * @notice Bytecode extension for the Vault containing permissionless functions outside the critical path.\n * It has access to the same storage layout as the main vault.\n *\n * The functions in this contract are not meant to be called directly. They must only be called by the Vault\n * via delegate calls, so that any state modifications produced by this contract's code will actually target\n * the main Vault's state.\n *\n * The storage of this contract is in practice unused.\n */\ncontract VaultExtension is IVaultExtension, VaultCommon, Proxy {\n    using Address for *;\n    using CastingHelpers for uint256[];\n    using FixedPoint for uint256;\n    using PackedTokenBalance for bytes32;\n    using PoolConfigLib for PoolConfigBits;\n    using HooksConfigLib for PoolConfigBits;\n    using VaultStateLib for VaultStateBits;\n    using InputHelpers for uint256;\n    using ScalingHelpers for *;\n    using VaultExtensionsLib for IVault;\n    using TransientStorageHelpers for *;\n    using StorageSlotExtension for *;\n    using PoolDataLib for PoolData;\n\n    IVault private immutable _vault;\n    IVaultAdmin private immutable _vaultAdmin;\n\n    /// @dev Functions with this modifier can only be delegate-called by the vault.\n    modifier onlyVaultDelegateCall() {\n        _ensureVaultDelegateCall();\n        _;\n    }\n\n    function _ensureVaultDelegateCall() internal view {\n        _vault.ensureVaultDelegateCall();\n    }\n\n    constructor(IVault mainVault, IVaultAdmin vaultAdmin) {\n        if (vaultAdmin.vault() != mainVault) {\n            revert WrongVaultAdminDeployment();\n        }\n\n        _vaultPauseWindowEndTime = vaultAdmin.getPauseWindowEndTime();\n        _vaultBufferPeriodDuration = vaultAdmin.getBufferPeriodDuration();\n        _vaultBufferPeriodEndTime = vaultAdmin.getBufferPeriodEndTime();\n\n        _vault = mainVault;\n        _vaultAdmin = vaultAdmin;\n    }\n\n    /*******************************************************************************\n                              Constants and immutables\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function vault() external view returns (IVault) {\n        return _vault;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getVaultAdmin() external view returns (address) {\n        return _implementation();\n    }\n\n    /*******************************************************************************\n                              Transient Accounting\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isUnlocked() external view onlyVaultDelegateCall returns (bool) {\n        return _isUnlocked().tload();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getNonzeroDeltaCount() external view onlyVaultDelegateCall returns (uint256) {\n        return _nonZeroDeltaCount().tload();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getTokenDelta(IERC20 token) external view onlyVaultDelegateCall returns (int256) {\n        return _tokenDeltas().tGet(token);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getReservesOf(IERC20 token) external view onlyVaultDelegateCall returns (uint256) {\n        return _reservesOf[token];\n    }\n\n    /*******************************************************************************\n                                    Pool Registration\n    *******************************************************************************/\n\n    struct PoolRegistrationParams {\n        TokenConfig[] tokenConfig;\n        uint256 swapFeePercentage;\n        uint32 pauseWindowEndTime;\n        bool protocolFeeExempt;\n        PoolRoleAccounts roleAccounts;\n        address poolHooksContract;\n        LiquidityManagement liquidityManagement;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function registerPool(\n        address pool,\n        TokenConfig[] memory tokenConfig,\n        uint256 swapFeePercentage,\n        uint32 pauseWindowEndTime,\n        bool protocolFeeExempt,\n        PoolRoleAccounts calldata roleAccounts,\n        address poolHooksContract,\n        LiquidityManagement calldata liquidityManagement\n    ) external onlyVaultDelegateCall nonReentrant whenVaultNotPaused {\n        _registerPool(\n            pool,\n            PoolRegistrationParams({\n                tokenConfig: tokenConfig,\n                swapFeePercentage: swapFeePercentage,\n                pauseWindowEndTime: pauseWindowEndTime,\n                protocolFeeExempt: protocolFeeExempt,\n                roleAccounts: roleAccounts,\n                poolHooksContract: poolHooksContract,\n                liquidityManagement: liquidityManagement\n            })\n        );\n    }\n\n    /**\n     * @dev The function will register the pool, setting its tokens with an initial balance of zero.\n     * The function also checks for valid token addresses and ensures that the pool and tokens aren't\n     * already registered.\n     *\n     * Emits a `PoolRegistered` event upon successful registration.\n     */\n    function _registerPool(address pool, PoolRegistrationParams memory params) internal {\n        // Ensure the pool isn't already registered\n        if (_isPoolRegistered(pool)) {\n            revert PoolAlreadyRegistered(pool);\n        }\n\n        uint256 numTokens = params.tokenConfig.length;\n        if (numTokens < _MIN_TOKENS) {\n            revert MinTokens();\n        }\n        if (numTokens > _MAX_TOKENS) {\n            revert MaxTokens();\n        }\n\n        uint8[] memory tokenDecimalDiffs = new uint8[](numTokens);\n        IERC20 previousToken;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            TokenConfig memory tokenData = params.tokenConfig[i];\n            IERC20 token = tokenData.token;\n\n            // Ensure that the token address is valid\n            if (address(token) == address(0) || address(token) == pool) {\n                revert InvalidToken();\n            }\n\n            // Enforce token sorting. (`previousToken` will be the zero address on the first iteration.)\n            if (token < previousToken) {\n                revert InputHelpers.TokensNotSorted();\n            }\n\n            if (token == previousToken) {\n                revert TokenAlreadyRegistered(token);\n            }\n\n            bool hasRateProvider = tokenData.rateProvider != IRateProvider(address(0));\n\n            _poolTokenInfo[pool][token] = TokenInfo({\n                tokenType: tokenData.tokenType,\n                rateProvider: tokenData.rateProvider,\n                paysYieldFees: tokenData.paysYieldFees\n            });\n\n            if (tokenData.tokenType == TokenType.STANDARD) {\n                if (hasRateProvider || tokenData.paysYieldFees) {\n                    revert InvalidTokenConfiguration();\n                }\n            } else if (tokenData.tokenType == TokenType.WITH_RATE) {\n                if (hasRateProvider == false) {\n                    revert InvalidTokenConfiguration();\n                }\n            } else {\n                revert InvalidTokenType();\n            }\n\n            tokenDecimalDiffs[i] = uint8(18) - IERC20Metadata(address(token)).decimals();\n\n            // Store token and seed the next iteration.\n            _poolTokens[pool].push(token);\n            previousToken = token;\n        }\n\n        // Store the role account addresses (for getters).\n        _poolRoleAccounts[pool] = params.roleAccounts;\n\n        // Make pool role assignments. A zero address means default to the authorizer.\n        _assignPoolRoles(pool, params.roleAccounts);\n\n        PoolConfigBits poolConfigBits;\n\n        // Store the configuration, and mark the pool as registered.\n        {\n            // Initialize the pool-specific protocol fee values to the current global defaults.\n            (uint256 aggregateSwapFeePercentage, uint256 aggregateYieldFeePercentage) = _protocolFeeController\n                .registerPool(pool, params.roleAccounts.poolCreator, params.protocolFeeExempt);\n\n            poolConfigBits = poolConfigBits.setPoolRegistered(true);\n            poolConfigBits = poolConfigBits.setDisableUnbalancedLiquidity(\n                params.liquidityManagement.disableUnbalancedLiquidity\n            );\n            poolConfigBits = poolConfigBits.setAddLiquidityCustom(params.liquidityManagement.enableAddLiquidityCustom);\n            poolConfigBits = poolConfigBits.setRemoveLiquidityCustom(\n                params.liquidityManagement.enableRemoveLiquidityCustom\n            );\n            poolConfigBits = poolConfigBits.setDonation(params.liquidityManagement.enableDonation);\n            poolConfigBits = poolConfigBits.setTokenDecimalDiffs(PoolConfigLib.toTokenDecimalDiffs(tokenDecimalDiffs));\n            poolConfigBits = poolConfigBits.setPauseWindowEndTime(params.pauseWindowEndTime);\n            poolConfigBits = poolConfigBits.setAggregateSwapFeePercentage(aggregateSwapFeePercentage);\n            poolConfigBits = poolConfigBits.setAggregateYieldFeePercentage(aggregateYieldFeePercentage);\n\n            if (params.poolHooksContract != address(0)) {\n                // If a hook address was passed, make sure that hook trusts the pool factory.\n                if (\n                    IHooks(params.poolHooksContract).onRegister(\n                        msg.sender,\n                        pool,\n                        params.tokenConfig,\n                        params.liquidityManagement\n                    ) == false\n                ) {\n                    revert HookRegistrationFailed(params.poolHooksContract, pool, msg.sender);\n                }\n\n                // Gets the default HooksConfig from the hook contract and saves in the vault state.\n                // Storing into hooksConfig first avoids stack-too-deep.\n                HookFlags memory hookFlags = IHooks(params.poolHooksContract).getHookFlags();\n\n                // When enableHookAdjustedAmounts == true, hooks are able to modify the result of a liquidity or swap\n                // operation by implementing an after hook. For simplicity, the vault only supports modifying the\n                // calculated part of the operation. As such, when a hook supports adjusted amounts, it cannot support\n                // unbalanced liquidity operations, as this would introduce instances where the amount calculated is the\n                // input amount (EXACT_OUT).\n                if (\n                    hookFlags.enableHookAdjustedAmounts &&\n                    params.liquidityManagement.disableUnbalancedLiquidity == false\n                ) {\n                    revert HookRegistrationFailed(params.poolHooksContract, pool, msg.sender);\n                }\n\n                poolConfigBits = poolConfigBits.setHookAdjustedAmounts(hookFlags.enableHookAdjustedAmounts);\n                poolConfigBits = poolConfigBits.setShouldCallBeforeInitialize(hookFlags.shouldCallBeforeInitialize);\n                poolConfigBits = poolConfigBits.setShouldCallAfterInitialize(hookFlags.shouldCallAfterInitialize);\n                poolConfigBits = poolConfigBits.setShouldCallComputeDynamicSwapFee(\n                    hookFlags.shouldCallComputeDynamicSwapFee\n                );\n                poolConfigBits = poolConfigBits.setShouldCallBeforeSwap(hookFlags.shouldCallBeforeSwap);\n                poolConfigBits = poolConfigBits.setShouldCallAfterSwap(hookFlags.shouldCallAfterSwap);\n                poolConfigBits = poolConfigBits.setShouldCallBeforeAddLiquidity(hookFlags.shouldCallBeforeAddLiquidity);\n                poolConfigBits = poolConfigBits.setShouldCallAfterAddLiquidity(hookFlags.shouldCallAfterAddLiquidity);\n                poolConfigBits = poolConfigBits.setShouldCallBeforeRemoveLiquidity(\n                    hookFlags.shouldCallBeforeRemoveLiquidity\n                );\n                poolConfigBits = poolConfigBits.setShouldCallAfterRemoveLiquidity(\n                    hookFlags.shouldCallAfterRemoveLiquidity\n                );\n            }\n\n            _poolConfigBits[pool] = poolConfigBits;\n            _hooksContracts[pool] = IHooks(params.poolHooksContract);\n        }\n\n        // Static swap fee percentage has special limits, so we don't use the library function directly.\n        _setStaticSwapFeePercentage(pool, params.swapFeePercentage);\n\n        // Emit an event to log the pool registration (pass msg.sender as the factory argument).\n        emit PoolRegistered(\n            pool,\n            msg.sender,\n            params.tokenConfig,\n            params.swapFeePercentage,\n            params.pauseWindowEndTime,\n            params.roleAccounts,\n            poolConfigBits.toHooksConfig(IHooks(params.poolHooksContract)),\n            params.liquidityManagement\n        );\n    }\n\n    function _assignPoolRoles(address pool, PoolRoleAccounts memory roleAccounts) private {\n        mapping(bytes32 => PoolFunctionPermission) storage roleAssignments = _poolFunctionPermissions[pool];\n        IAuthentication vaultAdmin = IAuthentication(address(_vaultAdmin));\n\n        if (roleAccounts.pauseManager != address(0)) {\n            roleAssignments[vaultAdmin.getActionId(IVaultAdmin.pausePool.selector)] = PoolFunctionPermission({\n                account: roleAccounts.pauseManager,\n                onlyOwner: false\n            });\n            roleAssignments[vaultAdmin.getActionId(IVaultAdmin.unpausePool.selector)] = PoolFunctionPermission({\n                account: roleAccounts.pauseManager,\n                onlyOwner: false\n            });\n        }\n\n        if (roleAccounts.swapFeeManager != address(0)) {\n            bytes32 swapFeeAction = vaultAdmin.getActionId(IVaultAdmin.setStaticSwapFeePercentage.selector);\n\n            roleAssignments[swapFeeAction] = PoolFunctionPermission({\n                account: roleAccounts.swapFeeManager,\n                onlyOwner: true\n            });\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function isPoolRegistered(address pool) external view onlyVaultDelegateCall returns (bool) {\n        return _isPoolRegistered(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function initialize(\n        address pool,\n        address to,\n        IERC20[] memory tokens,\n        uint256[] memory exactAmountsIn,\n        uint256 minBptAmountOut,\n        bytes memory userData\n    ) external onlyVaultDelegateCall onlyWhenUnlocked withRegisteredPool(pool) returns (uint256 bptAmountOut) {\n        _ensureUnpaused(pool);\n\n        // Balances are zero until after initialize is called, so there is no need to charge pending yield fee here.\n        PoolData memory poolData = _loadPoolData(pool, Rounding.ROUND_DOWN);\n\n        if (poolData.poolConfigBits.isPoolInitialized()) {\n            revert PoolAlreadyInitialized(pool);\n        }\n        uint256 numTokens = poolData.tokens.length;\n\n        InputHelpers.ensureInputLengthMatch(numTokens, exactAmountsIn.length);\n\n        // Amounts are entering pool math, so round down. A lower invariant after the join means less bptOut,\n        // favoring the pool.\n        uint256[] memory exactAmountsInScaled18 = exactAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n            poolData.decimalScalingFactors,\n            poolData.tokenRates\n        );\n\n        if (poolData.poolConfigBits.shouldCallBeforeInitialize()) {\n            HooksConfigLib.callBeforeInitializeHook(exactAmountsInScaled18, userData, _hooksContracts[pool]);\n            // The before hook is reentrant, and could have changed token rates.\n            // Updating balances here is unnecessary since they're 0, but we do not special case before init\n            // for the sake of bytecode size.\n            poolData.reloadBalancesAndRates(_poolTokenBalances[pool], Rounding.ROUND_DOWN);\n\n            // Also update `exactAmountsInScaled18`, in case the underlying rates changed.\n            exactAmountsInScaled18 = exactAmountsIn.copyToScaled18ApplyRateRoundDownArray(\n                poolData.decimalScalingFactors,\n                poolData.tokenRates\n            );\n        }\n\n        bptAmountOut = _initialize(pool, to, poolData, tokens, exactAmountsIn, exactAmountsInScaled18, minBptAmountOut);\n\n        if (poolData.poolConfigBits.shouldCallAfterInitialize()) {\n            // `hooksContract` needed to fix stack too deep.\n            IHooks hooksContract = _hooksContracts[pool];\n\n            HooksConfigLib.callAfterInitializeHook(exactAmountsInScaled18, bptAmountOut, userData, hooksContract);\n        }\n    }\n\n    function _initialize(\n        address pool,\n        address to,\n        PoolData memory poolData,\n        IERC20[] memory tokens,\n        uint256[] memory exactAmountsIn,\n        uint256[] memory exactAmountsInScaled18,\n        uint256 minBptAmountOut\n    ) internal nonReentrant returns (uint256 bptAmountOut) {\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[pool];\n\n        for (uint256 i = 0; i < poolData.tokens.length; ++i) {\n            IERC20 actualToken = poolData.tokens[i];\n\n            // Tokens passed into `initialize` are the \"expected\" tokens.\n            if (actualToken != tokens[i]) {\n                revert TokensMismatch(pool, address(tokens[i]), address(actualToken));\n            }\n\n            // Debit token[i] for amountIn.\n            _takeDebt(actualToken, exactAmountsIn[i]);\n\n            // Store the new Pool balances (and initial last live balances).\n            poolBalances[i] = PackedTokenBalance.toPackedBalance(exactAmountsIn[i], exactAmountsInScaled18[i]);\n        }\n\n        emit PoolBalanceChanged(pool, to, exactAmountsIn.unsafeCastToInt256(true));\n\n        poolData.poolConfigBits = poolData.poolConfigBits.setPoolInitialized(true);\n\n        // Store config and mark the pool as initialized.\n        _poolConfigBits[pool] = poolData.poolConfigBits;\n\n        // Pass scaled balances to the pool.\n        bptAmountOut = IBasePool(pool).computeInvariant(exactAmountsInScaled18);\n\n        _ensureMinimumTotalSupply(bptAmountOut);\n\n        // At this point we know that bptAmountOut >= _MINIMUM_TOTAL_SUPPLY, so this will not revert.\n        bptAmountOut -= _MINIMUM_TOTAL_SUPPLY;\n        // When adding liquidity, we must mint tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Minting will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _mintMinimumSupplyReserve(address(pool));\n        _mint(address(pool), to, bptAmountOut);\n\n        // At this point we have the calculated BPT amount.\n        if (bptAmountOut < minBptAmountOut) {\n            revert BptAmountOutBelowMin(bptAmountOut, minBptAmountOut);\n        }\n\n        // Emit an event to log the pool initialization.\n        emit PoolInitialized(pool);\n    }\n\n    /*******************************************************************************\n                                    Pool Information\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isPoolInitialized(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool) {\n        return _isPoolInitialized(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolTokens(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (IERC20[] memory tokens) {\n        return _poolTokens[pool];\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolTokenRates(\n        address pool\n    )\n        external\n        view\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        returns (uint256[] memory decimalScalingFactors, uint256[] memory tokenRates)\n    {\n        // Retrieve the mapping of tokens and their balances for the specified pool.\n        PoolConfigBits poolConfig = _poolConfigBits[pool];\n\n        IERC20[] memory tokens = _poolTokens[pool];\n        uint256 numTokens = tokens.length;\n        decimalScalingFactors = PoolConfigLib.getDecimalScalingFactors(poolConfig, numTokens);\n        tokenRates = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            TokenInfo memory tokenInfo = _poolTokenInfo[pool][tokens[i]];\n            tokenRates[i] = PoolDataLib.getTokenRate(tokenInfo);\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolData(\n        address pool\n    ) external view onlyVaultDelegateCall withInitializedPool(pool) returns (PoolData memory) {\n        return _loadPoolData(pool, Rounding.ROUND_DOWN);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolTokenInfo(\n        address pool\n    )\n        external\n        view\n        onlyVaultDelegateCall\n        withRegisteredPool(pool)\n        returns (\n            IERC20[] memory tokens,\n            TokenInfo[] memory tokenInfo,\n            uint256[] memory balancesRaw,\n            uint256[] memory lastBalancesLiveScaled18\n        )\n    {\n        // Retrieve the mapping of tokens and their balances for the specified pool.\n        mapping(uint256 => bytes32) storage poolTokenBalances = _poolTokenBalances[pool];\n        tokens = _poolTokens[pool];\n        uint256 numTokens = tokens.length;\n        tokenInfo = new TokenInfo[](numTokens);\n        balancesRaw = new uint256[](numTokens);\n        lastBalancesLiveScaled18 = new uint256[](numTokens);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            bytes32 packedBalance = poolTokenBalances[i];\n            tokenInfo[i] = _poolTokenInfo[pool][tokens[i]];\n            balancesRaw[i] = packedBalance.getBalanceRaw();\n            lastBalancesLiveScaled18[i] = packedBalance.getBalanceDerived();\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getCurrentLiveBalances(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256[] memory balancesLiveScaled18) {\n        return _loadPoolData(pool, Rounding.ROUND_DOWN).balancesLiveScaled18;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolConfig(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (PoolConfig memory) {\n        PoolConfigBits config = _poolConfigBits[pool];\n\n        return\n            PoolConfig({\n                isPoolRegistered: config.isPoolRegistered(),\n                isPoolInitialized: config.isPoolInitialized(),\n                isPoolPaused: config.isPoolPaused(),\n                isPoolInRecoveryMode: config.isPoolInRecoveryMode(),\n                staticSwapFeePercentage: config.getStaticSwapFeePercentage(),\n                aggregateSwapFeePercentage: config.getAggregateSwapFeePercentage(),\n                aggregateYieldFeePercentage: config.getAggregateYieldFeePercentage(),\n                tokenDecimalDiffs: config.getTokenDecimalDiffs(),\n                pauseWindowEndTime: config.getPauseWindowEndTime(),\n                liquidityManagement: LiquidityManagement({\n                    // NOTE: supportUnbalancedLiquidity is inverted because false means it is supported.\n                    disableUnbalancedLiquidity: !config.supportsUnbalancedLiquidity(),\n                    enableAddLiquidityCustom: config.supportsAddLiquidityCustom(),\n                    enableRemoveLiquidityCustom: config.supportsRemoveLiquidityCustom(),\n                    enableDonation: config.supportsDonation()\n                })\n            });\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getHooksConfig(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (HooksConfig memory) {\n        return _poolConfigBits[pool].toHooksConfig(_hooksContracts[pool]);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getBptRate(\n        address pool\n    ) external view onlyVaultDelegateCall withInitializedPool(pool) returns (uint256 rate) {\n        PoolData memory poolData = _loadPoolData(pool, Rounding.ROUND_DOWN);\n        uint256 invariant = IBasePool(pool).computeInvariant(poolData.balancesLiveScaled18);\n\n        return invariant.divDown(_totalSupply(pool));\n    }\n\n    /*******************************************************************************\n                                 Balancer Pool Tokens\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function totalSupply(address token) external view onlyVaultDelegateCall returns (uint256) {\n        return _totalSupply(token);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function balanceOf(address token, address account) external view onlyVaultDelegateCall returns (uint256) {\n        return _balanceOf(token, account);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external view onlyVaultDelegateCall returns (uint256) {\n        return _allowance(token, owner, spender);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function approve(address owner, address spender, uint256 amount) external onlyVaultDelegateCall returns (bool) {\n        _approve(msg.sender, owner, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function transfer(address owner, address to, uint256 amount) external onlyVaultDelegateCall returns (bool) {\n        _transfer(msg.sender, owner, to, amount);\n        return true;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function transferFrom(\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external onlyVaultDelegateCall returns (bool) {\n        _spendAllowance(msg.sender, from, spender, amount);\n        _transfer(msg.sender, from, to, amount);\n        return true;\n    }\n\n    /*******************************************************************************\n                                     Pool Pausing\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isPoolPaused(address pool) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool) {\n        return _isPoolPaused(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolPausedState(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool, uint32, uint32, address) {\n        (bool paused, uint32 pauseWindowEndTime) = _getPoolPausedState(pool);\n\n        return (\n            paused,\n            pauseWindowEndTime,\n            pauseWindowEndTime + _vaultBufferPeriodDuration,\n            _poolRoleAccounts[pool].pauseManager\n        );\n    }\n\n    /*******************************************************************************\n                                          Fees\n    *******************************************************************************/\n\n    // Swap and Yield fees are both stored using the PackedTokenBalance library, which is usually used for\n    // balances that are related (e.g., raw and live). In this case, it holds two uncorrelated values: swap\n    // and yield fee amounts, arbitrarily assigning \"Raw\" to Swap and \"Derived\" to Yield.\n\n    /// @inheritdoc IVaultExtension\n    function getAggregateSwapFeeAmount(\n        address pool,\n        IERC20 token\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256) {\n        return _aggregateFeeAmounts[pool][token].getBalanceRaw();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getAggregateYieldFeeAmount(\n        address pool,\n        IERC20 token\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256) {\n        return _aggregateFeeAmounts[pool][token].getBalanceDerived();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getStaticSwapFeePercentage(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (uint256) {\n        PoolConfigBits config = _poolConfigBits[pool];\n        return config.getStaticSwapFeePercentage();\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getPoolRoleAccounts(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (PoolRoleAccounts memory) {\n        return _poolRoleAccounts[pool];\n    }\n\n    /// @inheritdoc IVaultExtension\n    function computeDynamicSwapFeePercentage(\n        address pool,\n        PoolSwapParams memory swapParams\n    )\n        external\n        view\n        onlyVaultDelegateCall\n        withInitializedPool(pool)\n        returns (bool success, uint256 dynamicSwapFeePercentage)\n    {\n        return\n            HooksConfigLib.callComputeDynamicSwapFeeHook(\n                swapParams,\n                pool,\n                _poolConfigBits[pool].getStaticSwapFeePercentage(),\n                _hooksContracts[pool]\n            );\n    }\n\n    /// @inheritdoc IVaultExtension\n    function getProtocolFeeController() external view onlyVaultDelegateCall returns (IProtocolFeeController) {\n        return _protocolFeeController;\n    }\n\n    /*******************************************************************************\n                                     Recovery Mode\n    *******************************************************************************/\n\n    /// @inheritdoc IVaultExtension\n    function isPoolInRecoveryMode(\n        address pool\n    ) external view onlyVaultDelegateCall withRegisteredPool(pool) returns (bool) {\n        return _isPoolInRecoveryMode(pool);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function removeLiquidityRecovery(\n        address pool,\n        address from,\n        uint256 exactBptAmountIn\n    )\n        external\n        onlyVaultDelegateCall\n        onlyWhenUnlocked\n        nonReentrant\n        withInitializedPool(pool)\n        onlyInRecoveryMode(pool)\n        returns (uint256[] memory amountsOutRaw)\n    {\n        // Retrieve the mapping of tokens and their balances for the specified pool.\n        mapping(uint256 => bytes32) storage poolTokenBalances = _poolTokenBalances[pool];\n\n        // Initialize arrays to store tokens and balances based on the number of tokens in the pool.\n        IERC20[] memory tokens = _poolTokens[pool];\n        uint256 numTokens = tokens.length;\n\n        uint256[] memory balancesRaw = new uint256[](numTokens);\n        bytes32 packedBalances;\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            balancesRaw[i] = poolTokenBalances[i].getBalanceRaw();\n        }\n\n        amountsOutRaw = BasePoolMath.computeProportionalAmountsOut(balancesRaw, _totalSupply(pool), exactBptAmountIn);\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            // Credit token[i] for amountOut.\n            _supplyCredit(tokens[i], amountsOutRaw[i]);\n\n            // Compute the new Pool balances. A Pool's token balance always decreases after an exit\n            // (potentially by 0).\n            balancesRaw[i] -= amountsOutRaw[i];\n        }\n\n        // Store the new pool balances - raw only, since we don't have rates in Recovery Mode.\n        // In Recovery Mode, raw and last live balances will get out of sync. This is corrected when the pool is taken\n        // out of Recovery Mode.\n        mapping(uint256 => bytes32) storage poolBalances = _poolTokenBalances[pool];\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            packedBalances = poolBalances[i];\n            poolBalances[i] = packedBalances.setBalanceRaw(balancesRaw[i]);\n        }\n\n        _spendAllowance(pool, from, msg.sender, exactBptAmountIn);\n\n        if (_isQueryContext()) {\n            // Increase `from` balance to ensure the burn function succeeds.\n            _queryModeBalanceIncrease(pool, from, exactBptAmountIn);\n        }\n        // When removing liquidity, we must burn tokens concurrently with updating pool balances,\n        // as the pool's math relies on totalSupply.\n        // Burning will be reverted if it results in a total supply less than the _MINIMUM_TOTAL_SUPPLY.\n        _burn(pool, from, exactBptAmountIn);\n\n        emit PoolBalanceChanged(\n            pool,\n            from,\n            // We can unsafely cast to int256 because balances are stored as uint128 (see PackedTokenBalance).\n            amountsOutRaw.unsafeCastToInt256(false)\n        );\n    }\n\n    /*******************************************************************************\n                                        Queries\n    *******************************************************************************/\n\n    /// @dev Ensure that only static calls are made to the functions with this modifier.\n    modifier query() {\n        _setupQuery();\n        _;\n    }\n\n    function _setupQuery() internal {\n        if (EVMCallModeHelpers.isStaticCall() == false) {\n            revert EVMCallModeHelpers.NotStaticCall();\n        }\n\n        bool _isQueryDisabled = _vaultStateBits.isQueryDisabled();\n        if (_isQueryDisabled) {\n            revert QueriesDisabled();\n        }\n\n        // Unlock so that `onlyWhenUnlocked` does not revert.\n        _isUnlocked().tstore(true);\n    }\n\n    function _isQueryContext() internal view returns (bool) {\n        return EVMCallModeHelpers.isStaticCall() && _vaultStateBits.isQueryDisabled() == false;\n    }\n\n    /// @inheritdoc IVaultExtension\n    function quote(bytes calldata data) external payable query onlyVaultDelegateCall returns (bytes memory result) {\n        // Forward the incoming call to the original sender of this transaction.\n        return (msg.sender).functionCallWithValue(data, msg.value);\n    }\n\n    /// @inheritdoc IVaultExtension\n    function quoteAndRevert(bytes calldata data) external payable query onlyVaultDelegateCall {\n        // Forward the incoming call to the original sender of this transaction.\n        (bool success, bytes memory result) = (msg.sender).call{ value: msg.value }(data);\n        if (success) {\n            // This will only revert if result is empty and sender account has no code.\n            Address.verifyCallResultFromTarget(msg.sender, success, result);\n            // Send result in revert reason.\n            revert RevertCodec.Result(result);\n        } else {\n            // If the call reverted with a spoofed `QuoteResult`, we catch it and bubble up a different reason.\n            bytes4 errorSelector = RevertCodec.parseSelector(result);\n            if (errorSelector == RevertCodec.Result.selector) {\n                revert QuoteResultSpoofed();\n            }\n\n            // Otherwise we bubble up the original revert reason.\n            RevertCodec.bubbleUpRevert(result);\n        }\n    }\n\n    /// @inheritdoc IVaultExtension\n    function isQueryDisabled() external view onlyVaultDelegateCall returns (bool) {\n        return _vaultStateBits.isQueryDisabled();\n    }\n\n    /*******************************************************************************\n                                     Default handlers\n    *******************************************************************************/\n\n    receive() external payable {\n        revert CannotReceiveEth();\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Override proxy implementation of `fallback` to disallow incoming ETH transfers.\n     * This function actually returns whatever the Vault Extension does when handling the request.\n     */\n    fallback() external payable override {\n        if (msg.value > 0) {\n            revert CannotReceiveEth();\n        }\n\n        _fallback();\n    }\n\n    /*******************************************************************************\n                                     Miscellaneous\n    *******************************************************************************/\n\n    /**\n     * @inheritdoc Proxy\n     * @dev Returns Vault Extension, where fallback requests are forwarded.\n     */\n    function _implementation() internal view override returns (address) {\n        return address(_vaultAdmin);\n    }\n}\n"
    }
}