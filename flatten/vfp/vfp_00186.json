{
    "vfp_id": "vfp_00186",
    "project_name": "cantina_revert_sept2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Incorrect onERC721Received Logic Causes Staked Positions to be Undetectable, Breaking Liquidation & NFT Return Flows",
            "description": "The vulnerability lies in the `onERC721Received` function of the vault, which fails to distinguish between newly deposited NFTs and NFTs being returned from unstaking. The function assumes every incoming NFT is a new deposit by checking only if `oldTokenId == 0`, leading it to overwrite existing loan state and incorrectly assign ownership when an unstaked NFT is returned. This flaw arises due to the lack of validation of the NFT's prior ownership status. An attacker could exploit this by unstaking an NFT, causing the system to wipe the associated loan data, thereby making the position unliquidatable. The impact includes the permanent loss of user NFTs during unstaking and the breakdown of critical liquidation and return mechanisms, severely compromising the protocol's financial integrity.\n",
            "severity": "Critical",
            "location": [],
            "files": [
                "lend/src/V3Vault.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Gauge address is not properly verified",
            "description": "The `setGauge` function in the GaugeManager contract does not verify that the provided gauge address corresponds to the actual gauge associated with the given pool. This omission allows the owner to potentially set an incorrect or malicious gauge address. The root cause is the absence of a validation check against the pool's expected gauge (as defined in CLPool.sol). An attacker with ownership privileges could set a rogue gauge, leading to misrouted rewards or incorrect staking operations. This could result in financial loss or disruption of staking functionality, though the risk is mitigated by the fact that only the owner can call the function.\n",
            "severity": "Low",
            "location": [
                "GaugeManager.sol#L77"
            ],
            "files": [
                "lend/src/GaugeManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing validation of max aeroSplitBps",
            "description": "The `compoundRewards` and `executeV3UtilsWithOptionalCompound` functions do not validate that the `aeroSplitBps` parameter is within the valid range (â‰¤10,000 basis points). This lack of input validation could allow a user to specify a value exceeding 100%, leading to arithmetic overflows or unintended token distributions. The cause is the missing `require` statement to cap the value. An attacker could exploit this by providing a large `aeroSplitBps` value, potentially draining protocol funds through miscalculated swaps. The impact includes potential loss of funds due to incorrect swap amounts, though the risk is considered low due to the narrow exploitation path.\n",
            "severity": "Low",
            "location": [
                "GaugeManager.sol#L212"
            ],
            "files": [
                "lend/src/GaugeManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing input validation in the create function",
            "description": "The `create` function in the V3Vault contract lacks validation of the `recipient` parameter, allowing it to be set to the zero address. This could result in tokens being sent to an invalid or non-recoverable address. The root cause is the absence of a basic input check. An attacker could call the function with `address(0)` as the recipient, leading to permanent loss of the associated NFT. While the impact is limited to individual user errors, it represents a preventable risk that undermines user safety.\n",
            "severity": "Low",
            "location": [
                "V3Vault.sol#L355"
            ],
            "files": [
                "lend/src/V3Vault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "totalAssets does not follow the ERC-4626 standard specification",
            "description": "The `totalAssets` function in the vault contract only returns the idle balance of the underlying asset, excluding outstanding lent assets and accrued interest. This violates the ERC-4626 standard, which requires `totalAssets` to reflect all assets under management, including lent amounts. The cause is an incomplete implementation that fails to include debt with interest. External integrators relying on this function will receive inaccurate TVL data, leading to misleading analytics, incorrect pricing, and potential integration failures. Although internal accounting remains correct, the external interface misrepresents the vault's true asset value, posing a risk to ecosystem compatibility.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "lend/src/V3Vault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary approval in migrateToVault",
            "description": "The `migrateToVault` function in GaugeManager unnecessarily approves the vault to transfer an NFT before using `safeTransferFrom`, which already includes the recipient in the data payload and does not require prior approval. This redundant approval increases gas costs without providing any security benefit. The cause is an inefficient use of the ERC721 interface. While the impact is limited to wasted gas, it represents a suboptimal implementation that could be exploited in gas-sensitive contexts. Removing the approval would improve efficiency and reduce transaction costs.\n",
            "severity": "Informational",
            "location": [
                "GaugeManager.sol#L563"
            ],
            "files": [
                "lend/src/GaugeManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-477"
                ]
            },
            "title": "Stale approval system",
            "description": "The GaugeManager and Swapper contracts use a legacy ERC20 approval pattern that first sets allowance to zero before increasing it, even when unnecessary. This pattern, while functional, is inefficient and outdated, especially for tokens that do not require zeroing. The cause is the use of `safeApprove(0)` followed by `safeIncreaseAllowance`, instead of using modern alternatives like `forceApprove`. This results in higher gas costs and unnecessary transactions. The impact is increased operational expenses and reduced efficiency, though there is no direct security risk. Migrating to `forceApprove` would streamline approvals and reduce gas usage.\n",
            "severity": "Informational",
            "location": [
                "GaugeManager.sol#L240",
                "GaugeManager.sol#L438",
                "GaugeManager.sol#L511-L518",
                "Swapper.sol#L105"
            ],
            "files": [
                "lend/src/GaugeManager.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "_addTokenToOwner should emit the Add event",
            "description": "The `Add` event is emitted in two separate locations within the `onERC721Received` function, duplicating logic that could be centralized in the `_addTokenToOwner` function. This redundancy increases code complexity and the risk of inconsistent event emission. The cause is poor code organization. By moving the event emission into `_addTokenToOwner` and passing `oldTokenId` as a parameter, the code can be simplified and made more maintainable. The impact is primarily on code quality and readability, with no direct security implications, but it improves long-term maintainability.\n",
            "severity": "Informational",
            "location": [
                "V3Vault.sol#L389"
            ],
            "files": [
                "lend/src/V3Vault.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused code across the repository",
            "description": "The repository contains several instances of unused code, including unused error definitions in Constants.sol, redundant imports in AutoCompound.sol, GaugeManager.sol, and V3Vault.sol. These elements do not contribute to the contract functionality and increase code bloat. The cause is leftover development artifacts or incomplete cleanup. While there is no security risk, the presence of unused code reduces readability and maintainability, making audits and future development more difficult. Removing these lines would improve code clarity and reduce potential confusion.\n",
            "severity": "Informational",
            "location": [
                "Constants.sol#L4"
            ],
            "files": [
                "lend/src/utils/Constants.sol",
                "lend/src/GaugeManager.sol",
                "lend/src/V3Vault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Incorrect PUSH pattern used when collecting staking rewards",
            "description": "The protocol uses a PUSH pattern to send staking rewards directly to users during operations like liquidation. This approach is risky because if the reward token (e.g., aeroToken) has transfer restrictions or is ETH, a malicious recipient could block the transfer, causing a denial-of-service (DOS) for critical functions like liquidation. The cause is the use of direct transfers instead of a pull-based system. The recommended solution is to implement a pull mechanism where users claim rewards via a separate function. This would prevent DOS attacks and ensure the reliability of liquidation and other reward-distributing operations.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "lend/src/GaugeManager.sol"
            ]
        }
    ],
    "affected_files": {
        "Constants.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nabstract contract Constants {\n    uint256 internal constant Q32 = 2 ** 32;\n    uint256 internal constant Q64 = 2 ** 64;\n    uint256 internal constant Q96 = 2 ** 96;\n    uint256 internal constant Q128 = 2 ** 128;\n    uint256 internal constant Q160 = 2 ** 160;\n\n    error Unauthorized();\n    error Reentrancy();\n    error NotConfigured();\n    error NotReady();\n    error InvalidConfig();\n    error TWAPCheckFailed();\n    error WrongContract();\n    error InvalidToken();\n\n    error SwapFailed();\n    error SlippageError();\n    error MissingSwapData();\n    error SwapAmountTooLarge();\n\n    error ExceedsMaxReward();\n    error InvalidPool();\n    error ChainlinkPriceError();\n    error PriceDifferenceExceeded();\n    error SequencerDown();\n    error SequencerGracePeriodNotOver();\n    error SequencerUptimeFeedInvalid();\n\n    error CollateralFail();\n    error MinLoanSize();\n    error GlobalDebtLimit();\n    error GlobalLendLimit();\n    error DailyDebtIncreaseLimit();\n    error DailyLendIncreaseLimit();\n    error InsufficientLiquidity();\n    error NotLiquidatable();\n    error InterestNotUpdated();\n    error TransformNotAllowed();\n    error TransformFailed();\n    error CollateralFactorExceedsMax();\n    error CollateralValueLimit();\n    error NoLiquidity();\n    error DebtChanged();\n    error NeedsRepay();\n    error NoSharesRepayed();\n\n    error SelfSend();\n    error NotSupportedWhatToDo();\n    error SameToken();\n    error AmountError();\n    error CollectError();\n    error TransferError();\n\n    error TooMuchEtherSent();\n    error NoEtherToken();\n    error EtherSendFailed();\n    error NotWETH();\n\n    error NotEnoughReward();\n    error SameRange();\n    error NotSupportedFeeTier();\n\n    // Aerodrome-specific errors\n    error InvalidTickSpacing();\n    error GaugeNotSet();\n    error AlreadyStaked();\n    error NotStaked();\n    error RewardClaimFailed();\n    error GaugeManagerNotSet();\n    error NotDepositor();\n}\n",
        "GaugeManager.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./interfaces/aerodrome/IAerodromeNonfungiblePositionManager.sol\";\nimport \"./interfaces/aerodrome/IAerodromeSlipstreamFactory.sol\";\nimport \"./interfaces/aerodrome/IGauge.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./transformers/V3Utils.sol\";\nimport \"./utils/Constants.sol\";\nimport \"./utils/Swapper.sol\";\n\n/// @title GaugeManager with Built-in Compounding\n/// @notice Single contract that handles both staking AND compounding\n/// @dev Simplest solution - one contract does everything\ncontract GaugeManager is Ownable2Step, IERC721Receiver, ReentrancyGuard, Swapper {\n    using SafeERC20 for IERC20;\n\n    event PositionStaked(uint256 indexed tokenId, address indexed owner);\n    event PositionUnstaked(uint256 indexed tokenId, address indexed owner);\n    event RewardsCompounded(uint256 indexed tokenId, uint256 aeroAmount, uint256 amount0, uint256 amount1);\n    event SwapAndIncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    event V3UtilsSet(address indexed v3Utils);\n    event PositionMigratedToVault(uint256 indexed tokenId, address indexed owner);\n    event PositionTransformed(uint256 indexed oldTokenId, uint256 indexed newTokenId, address indexed owner);\n    event TransformerSet(address indexed transformer, bool active);\n    event ApprovedTransform(uint256 indexed tokenId, address indexed owner, address indexed transformer, bool isActive);\n\n    IERC20 public immutable aeroToken;\n    IVault public immutable vault;\n    \n    // V3Utils for position management operations\n    address payable public v3Utils;\n    \n    // Compound fee configuration\n    uint64 public constant MAX_REWARD_X64 = uint64(Q64 * 5 / 100); // 5% max fee\n    uint64 public totalRewardX64 = 0; // Start at 0%, owner can set up to 5%\n    address public feeWithdrawer; // Can withdraw accumulated fees\n\n    // Core mappings\n    mapping(address => address) public poolToGauge;\n    mapping(uint256 => address) public tokenIdToGauge;\n    mapping(uint256 => address) public positionOwners;\n    mapping(uint256 => bool) public isVaultPosition;\n    \n    // Transform system for AutoRange/AutoCompound integration\n    mapping(address => bool) public transformerAllowList;\n    uint256 public transformedTokenId;\n    \n    // Transform approvals: owner => tokenId => transformer => approved\n    mapping(address => mapping(uint256 => mapping(address => bool))) public transformApprovals;\n\n    constructor(\n        IAerodromeNonfungiblePositionManager _npm,\n        IERC20 _aeroToken,\n        IVault _vault,\n        address _universalRouter,\n        address _zeroxAllowanceHolder,\n        address _feeWithdrawer\n    ) Swapper(\n        INonfungiblePositionManager(address(_npm)),\n        _universalRouter,\n        _zeroxAllowanceHolder\n    ) Ownable2Step() {\n        aeroToken = _aeroToken;\n        vault = _vault;\n        feeWithdrawer = _feeWithdrawer;\n    }\n\n    /// @notice Set gauge for a pool\n    function setGauge(address pool, address gauge) external onlyOwner {\n        poolToGauge[pool] = gauge;\n    }\n\n    /// @notice Approve/revoke transformer for a specific position\n    function approveTransform(uint256 tokenId, address transformer, bool isActive) external {\n        require(positionOwners[tokenId] == msg.sender, \"Not position owner\");\n        transformApprovals[msg.sender][tokenId][transformer] = isActive;\n        emit ApprovedTransform(tokenId, msg.sender, transformer, isActive);\n    }\n\n    /// @notice Set transformer contract (e.g., AutoRange) allowlist\n    function setTransformer(address transformer, bool active) external onlyOwner {\n        transformerAllowList[transformer] = active;\n        emit TransformerSet(transformer, active);\n    }\n\n    /// @notice Set V3Utils contract address\n    function setV3Utils(address payable _v3Utils) external onlyOwner {\n        v3Utils = _v3Utils;\n        emit V3UtilsSet(_v3Utils);\n    }\n\n    /// @notice Stake a position (works for both vault and direct)\n    function stakePosition(uint256 tokenId) external nonReentrant {\n        address nftOwner = nonfungiblePositionManager.ownerOf(tokenId);\n        \n        // Determine if vault or direct position\n        bool fromVault = msg.sender == address(vault);\n        address owner = fromVault ? IVault(vault).ownerOf(tokenId) : msg.sender;\n        \n        require(owner != address(0), \"Invalid owner\");\n        require(fromVault || nftOwner == msg.sender, \"Not authorized\");\n\n        // Get gauge for position\n        (,, address token0, address token1, uint24 tickSpacing,,,,,,,) = \n            nonfungiblePositionManager.positions(tokenId);\n        address pool = IAerodromeSlipstreamFactory(factory).getPool(token0, token1, int24(tickSpacing));\n        address gauge = poolToGauge[pool];\n        require(gauge != address(0), \"No gauge\");\n\n        // Transfer and stake\n        nonfungiblePositionManager.safeTransferFrom(nftOwner, address(this), tokenId);\n        nonfungiblePositionManager.approve(gauge, tokenId);\n        IGauge(gauge).deposit(tokenId);\n\n        // Record ownership\n        tokenIdToGauge[tokenId] = gauge;\n        positionOwners[tokenId] = owner;\n        isVaultPosition[tokenId] = fromVault;\n\n        emit PositionStaked(tokenId, owner);\n    }\n\n    /// @notice Unstake a position\n    function unstakePosition(uint256 tokenId) external nonReentrant {\n        address owner = positionOwners[tokenId];\n        bool fromVault = isVaultPosition[tokenId];\n        \n        // Check authorization\n        require(\n            (fromVault && msg.sender == address(vault)) ||\n            (!fromVault && msg.sender == owner),\n            \"Not authorized\"\n        );\n\n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n\n        // Claim final rewards and send to owner\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n        \n        if (aeroAmount > 0) {\n            aeroToken.safeTransfer(owner, aeroAmount);\n        }\n        \n        // Unstake\n        IGauge(gauge).withdraw(tokenId);\n        \n        // Return NFT\n        address returnTo = fromVault ? address(vault) : owner;\n        nonfungiblePositionManager.safeTransferFrom(address(this), returnTo, tokenId);\n\n        // Clean up\n        delete tokenIdToGauge[tokenId];\n        delete positionOwners[tokenId];\n        delete isVaultPosition[tokenId];\n\n        emit PositionUnstaked(tokenId, owner);\n    }\n\n    /// @notice Compound rewards for a position (THE KEY SIMPLIFICATION)\n    /// @dev All-in-one: claim, swap, add liquidity\n    function compoundRewards(\n        uint256 tokenId,\n        bytes calldata swapData0,\n        bytes calldata swapData1,\n        uint256 minAmount0,\n        uint256 minAmount1,\n        uint256 aeroSplitBps,\n        uint256 deadline\n    ) external nonReentrant {\n        // Check authorization - only owner or vault can manually compound\n        address owner = positionOwners[tokenId];\n        bool fromVault = isVaultPosition[tokenId];\n        require(\n            msg.sender == owner || \n            (fromVault && msg.sender == address(vault)),\n            \"Not authorized\"\n        );\n\n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n\n        // 1. Claim AERO rewards for this specific NFT\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n        \n        if (aeroAmount == 0) return;\n\n        // 2. Get position details\n        (,, address token0, address token1,,,,,,,,) = \n            nonfungiblePositionManager.positions(tokenId);\n\n        // 3. Swap AERO to position tokens\n        uint256 amount0;\n        uint256 amount1;\n        \n        if (swapData0.length > 0) {\n            (, amount0) = _routerSwap(\n                RouterSwapParams(\n                    aeroToken,\n                    IERC20(token0),\n                    (aeroAmount * aeroSplitBps) / 10000,\n                    minAmount0,\n                    swapData0\n                )\n            );\n        }\n        \n        if (swapData1.length > 0) {\n            (, amount1) = _routerSwap(\n                RouterSwapParams(\n                    aeroToken,\n                    IERC20(token1),\n                    aeroToken.balanceOf(address(this)),\n                    minAmount1,\n                    swapData1\n                )\n            );\n        }\n\n        // 4. Apply compound fees (same logic as AutoCompound)\n        uint256 rewardX64 = totalRewardX64;\n        uint256 maxAddAmount0 = amount0 * Q64 / (rewardX64 + Q64);\n        uint256 maxAddAmount1 = amount1 * Q64 / (rewardX64 + Q64);\n\n        // 5. Temporarily unstake to add liquidity\n        IGauge(gauge).withdraw(tokenId);\n\n        // 6. Add liquidity (fees implicitly stay in contract)\n        IERC20(token0).safeApprove(address(nonfungiblePositionManager), 0);\n        IERC20(token0).safeIncreaseAllowance(address(nonfungiblePositionManager), maxAddAmount0);\n        IERC20(token1).safeApprove(address(nonfungiblePositionManager), 0);\n        IERC20(token1).safeIncreaseAllowance(address(nonfungiblePositionManager), maxAddAmount1);\n        \n        (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) = \n            nonfungiblePositionManager.increaseLiquidity(\n                INonfungiblePositionManager.IncreaseLiquidityParams(\n                    tokenId,\n                    maxAddAmount0,\n                    maxAddAmount1,\n                    0,\n                    0,\n                    deadline\n                )\n            );\n\n        // 6. Re-stake\n        nonfungiblePositionManager.approve(gauge, tokenId);\n        IGauge(gauge).deposit(tokenId);\n\n        // 7. Return only slippage to position owner (fees stay in contract)\n        uint256 leftover0 = maxAddAmount0 - amount0Added;\n        uint256 leftover1 = maxAddAmount1 - amount1Added;\n        \n        if (leftover0 > 0) {\n            IERC20(token0).safeTransfer(owner, leftover0);\n        }\n        if (leftover1 > 0) {\n            IERC20(token1).safeTransfer(owner, leftover1);\n        }\n\n        emit RewardsCompounded(tokenId, aeroAmount, amount0Added, amount1Added);\n    }\n\n    /// @notice Simple reward claiming without compounding\n    function claimRewards(uint256 tokenId) external nonReentrant {\n        address owner = positionOwners[tokenId];\n        bool fromVault = isVaultPosition[tokenId];\n        \n        // Check authorization: only owner or vault can claim\n        require(\n            msg.sender == owner || \n            (fromVault && msg.sender == address(vault)),\n            \"Not authorized\"\n        );\n        \n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n        \n        // Claim and send to owner\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n        \n        if (aeroAmount > 0) {\n            aeroToken.safeTransfer(owner, aeroAmount);\n        }\n    }\n\n    /// @notice Execute V3Utils operation on staked position with optional AERO compounding\n    /// @param tokenId The staked position to operate on\n    /// @param instructions V3Utils instructions\n    /// @param shouldCompound Whether to compound AERO rewards before restaking\n    /// @param aeroSwapData0 Swap data for AERO->token0 if compounding\n    /// @param aeroSwapData1 Swap data for AERO->token1 if compounding\n    /// @param minAeroAmount0 Min amount of token0 from AERO swap if compounding\n    /// @param minAeroAmount1 Min amount of token1 from AERO swap if compounding\n    /// @param aeroSplitBps Basis points of AERO to swap to token0 (rest goes to token1)\n    function executeV3UtilsWithOptionalCompound(\n        uint256 tokenId,\n        V3Utils.Instructions memory instructions,\n        bool shouldCompound,\n        bytes memory aeroSwapData0,\n        bytes memory aeroSwapData1,\n        uint256 minAeroAmount0,\n        uint256 minAeroAmount1,\n        uint256 aeroSplitBps\n    ) public nonReentrant returns (uint256 newTokenId) {\n        require(v3Utils != address(0), \"V3Utils not configured\");\n        \n        // Check authorization\n        address owner = positionOwners[tokenId];\n        bool fromVault = isVaultPosition[tokenId];\n        require(\n            msg.sender == owner || \n            (fromVault && msg.sender == address(vault)),\n            \"Not authorized\"\n        );\n\n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n\n        // 1. Claim any pending AERO rewards\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n\n        // 2. Unstake position from gauge\n        IGauge(gauge).withdraw(tokenId);\n\n        // 3. Execute V3Utils operation\n        nonfungiblePositionManager.approve(v3Utils, tokenId);\n        newTokenId = V3Utils(v3Utils).execute(tokenId, instructions);\n\n        // Determine which tokenId to work with going forward\n        uint256 tokenToStake = newTokenId != 0 ? newTokenId : tokenId;\n\n        // 4. If requested and AERO available, compound it\n        if (shouldCompound && aeroAmount > 0) {\n            _compoundIntoPosition(\n                tokenToStake,\n                owner,\n                aeroAmount,\n                aeroSwapData0,\n                aeroSwapData1,\n                minAeroAmount0,\n                minAeroAmount1,\n                aeroSplitBps,\n                instructions.deadline\n            );\n        } else if (aeroAmount > 0) {\n            // Send unclaimed AERO to owner\n            aeroToken.safeTransfer(owner, aeroAmount);\n        }\n\n        // 5. Restake the position (same gauge - pool doesn't change)\n        nonfungiblePositionManager.approve(gauge, tokenToStake);\n        IGauge(gauge).deposit(tokenToStake);\n\n        // 6. Update ownership tracking\n        if (newTokenId != 0) {\n            // Clean up old tokenId\n            delete tokenIdToGauge[tokenId];\n            delete positionOwners[tokenId];\n            delete isVaultPosition[tokenId];\n            \n            // Set mappings for new tokenId\n            tokenIdToGauge[tokenToStake] = gauge;\n            positionOwners[tokenToStake] = owner;\n            isVaultPosition[tokenToStake] = fromVault;\n        }\n\n        emit PositionStaked(tokenToStake, owner);\n\n        return newTokenId;\n    }\n\n    /// @notice Internal function to compound AERO into a position\n    function _compoundIntoPosition(\n        uint256 tokenId,\n        address owner,\n        uint256 aeroAmount,\n        bytes memory swapData0,\n        bytes memory swapData1,\n        uint256 minAmount0,\n        uint256 minAmount1,\n        uint256 aeroSplitBps,\n        uint256 deadline\n    ) internal {\n        // Get position details\n        (,, address token0, address token1,,,,,,,,) = \n            nonfungiblePositionManager.positions(tokenId);\n\n        // Swap AERO to position tokens\n        uint256 amount0;\n        uint256 amount1;\n        \n        if (swapData0.length > 0) {\n            (, amount0) = _routerSwap(\n                RouterSwapParams(\n                    aeroToken,\n                    IERC20(token0),\n                    (aeroAmount * aeroSplitBps) / 10000,\n                    minAmount0,\n                    swapData0\n                )\n            );\n        }\n        \n        if (swapData1.length > 0) {\n            (, amount1) = _routerSwap(\n                RouterSwapParams(\n                    aeroToken,\n                    IERC20(token1),\n                    aeroToken.balanceOf(address(this)),\n                    minAmount1,\n                    swapData1\n                )\n            );\n        }\n\n        // Apply fees\n        uint256 rewardX64 = totalRewardX64;\n        uint256 maxAddAmount0 = amount0 * Q64 / (rewardX64 + Q64);\n        uint256 maxAddAmount1 = amount1 * Q64 / (rewardX64 + Q64);\n\n        // Add liquidity with fee-adjusted amounts\n        IERC20(token0).safeApprove(address(nonfungiblePositionManager), 0);\n        IERC20(token0).safeIncreaseAllowance(address(nonfungiblePositionManager), maxAddAmount0);\n        IERC20(token1).safeApprove(address(nonfungiblePositionManager), 0);\n        IERC20(token1).safeIncreaseAllowance(address(nonfungiblePositionManager), maxAddAmount1);\n        \n        (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) = \n            nonfungiblePositionManager.increaseLiquidity(\n                INonfungiblePositionManager.IncreaseLiquidityParams(\n                    tokenId,\n                    maxAddAmount0,\n                    maxAddAmount1,\n                    0,\n                    0,\n                    deadline\n                )\n            );\n\n        // Return only slippage to position owner (fees stay in contract)\n        uint256 leftover0 = maxAddAmount0 - amount0Added;\n        uint256 leftover1 = maxAddAmount1 - amount1Added;\n        \n        if (leftover0 > 0) {\n            IERC20(token0).safeTransfer(owner, leftover0);\n        }\n        if (leftover1 > 0) {\n            IERC20(token1).safeTransfer(owner, leftover1);\n        }\n\n        emit RewardsCompounded(tokenId, aeroAmount, amount0Added, amount1Added);\n    }\n\n\n    /// @notice Add liquidity to a staked position with optional token swaps\n    /// @param tokenId The staked position to add liquidity to\n    /// @param params Parameters for V3Utils.swapAndIncreaseLiquidity\n    function swapAndIncreaseStakedPosition(\n        uint256 tokenId,\n        V3Utils.SwapAndIncreaseLiquidityParams calldata params\n    ) external payable nonReentrant returns (uint128 liquidity, uint256 amount0, uint256 amount1) {\n        require(v3Utils != address(0), \"V3Utils not configured\");\n        \n        // Check authorization\n        address owner = positionOwners[tokenId];\n        bool fromVault = isVaultPosition[tokenId];\n        require(\n            msg.sender == owner || \n            (fromVault && msg.sender == address(vault)),\n            \"Not authorized\"\n        );\n        \n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n        \n        // Get position tokens\n        (,, address token0, address token1,,,,,,,,) = nonfungiblePositionManager.positions(tokenId);\n        \n        // Claim and send AERO rewards to owner before unstaking\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n        if (aeroAmount > 0) {\n            aeroToken.safeTransfer(owner, aeroAmount);\n        }\n        \n        // Transfer tokens from sender to this contract\n        if (params.amount0 > 0) {\n            IERC20(token0).safeTransferFrom(msg.sender, address(this), params.amount0);\n        }\n        if (params.amount1 > 0) {\n            IERC20(token1).safeTransferFrom(msg.sender, address(this), params.amount1);\n        }\n        \n        // Approve V3Utils\n        if (params.amount0 > 0) {\n            IERC20(token0).safeApprove(v3Utils, 0);\n            IERC20(token0).safeIncreaseAllowance(v3Utils, params.amount0);\n        }\n        if (params.amount1 > 0) {\n            IERC20(token1).safeApprove(v3Utils, 0);\n            IERC20(token1).safeIncreaseAllowance(v3Utils, params.amount1);\n        }\n        \n        // Unstake position\n        IGauge(gauge).withdraw(tokenId);\n        \n        // Call V3Utils.swapAndIncreaseLiquidity (forward ETH if sent)\n        (liquidity, amount0, amount1) = V3Utils(v3Utils).swapAndIncreaseLiquidity{value: msg.value}(params);\n        \n        // Restake position\n        nonfungiblePositionManager.approve(gauge, tokenId);\n        IGauge(gauge).deposit(tokenId);\n        \n        // Note: V3Utils already handles returning leftover tokens to params.recipient\n        // No need to handle leftovers here as they've already been sent\n        \n        emit SwapAndIncreaseLiquidity(tokenId, liquidity, amount0, amount1);\n        \n        return (liquidity, amount0, amount1);\n    }\n\n    /// @notice Migrate a staked position to the vault for collateralized borrowing\n    /// @param tokenId The staked position to migrate\n    /// @param recipient The recipient address in the vault (usually msg.sender)\n    /// @dev This unstakes the position and deposits it into the vault in one transaction\n    function migrateToVault(uint256 tokenId, address recipient) external nonReentrant {\n        address owner = positionOwners[tokenId];\n        require(owner == msg.sender, \"Not position owner\");\n        require(!isVaultPosition[tokenId], \"Already a vault position\");\n        \n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n        \n        // Claim final rewards and send to owner\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n        \n        if (aeroAmount > 0) {\n            aeroToken.safeTransfer(owner, aeroAmount);\n        }\n        \n        // Unstake from gauge\n        IGauge(gauge).withdraw(tokenId);\n        \n        // Approve vault to take the NFT\n        nonfungiblePositionManager.approve(address(vault), tokenId);\n        \n        // Transfer to vault using safeTransferFrom with recipient encoded\n        nonfungiblePositionManager.safeTransferFrom(\n            address(this), \n            address(vault), \n            tokenId, \n            abi.encode(recipient)\n        );\n        \n        // Clean up mappings\n        delete tokenIdToGauge[tokenId];\n        delete positionOwners[tokenId];\n        delete isVaultPosition[tokenId];\n        \n        emit PositionUnstaked(tokenId, owner);\n        emit PositionMigratedToVault(tokenId, owner);\n    }\n\n    /// @notice Transform a staked position using an approved transformer (e.g., AutoRange, AutoCompound)\n    /// @param tokenId The staked position to transform\n    /// @param transformer The transformer contract to use\n    /// @param data The encoded function call for the transformer\n    /// @return newTokenId The tokenId after transformation (may be same or different)\n    function transform(\n        uint256 tokenId, \n        address transformer, \n        bytes calldata data\n    ) external nonReentrant returns (uint256 newTokenId) {\n        // Check authorization\n        address owner = positionOwners[tokenId];\n        bool fromVault = isVaultPosition[tokenId];\n        require(\n            msg.sender == owner || \n            (fromVault && msg.sender == address(vault)) ||\n            msg.sender == transformer || // Allow transformer to call (for AutoCompound.executeWithGauge)\n            transformApprovals[owner][tokenId][msg.sender], // Check if approved transformer\n            \"Not authorized\"\n        );\n        \n        // Validate transformer\n        require(transformerAllowList[transformer], \"Transformer not allowed\");\n        require(transformedTokenId == 0, \"Reentrancy\");\n        \n        // Set reentrancy guard\n        transformedTokenId = tokenId;\n        \n        // Save state before transform\n        address gauge = tokenIdToGauge[tokenId];\n        require(gauge != address(0), \"Not staked\");\n        \n        // 1. Always claim pending AERO rewards\n        uint256 aeroBefore = aeroToken.balanceOf(address(this));\n        IGauge(gauge).getReward(tokenId);\n        uint256 aeroAmount = aeroToken.balanceOf(address(this)) - aeroBefore;\n        \n        // Check if this is AutoCompound\n        bytes4 selector = bytes4(data[:4]);\n        bool isAutoCompound = selector == bytes4(keccak256(\"executeForGauge((uint256,uint256,bytes,bytes,uint256,uint256,uint256,uint256))\"));\n        \n        bytes memory callData = data;\n        \n        if (isAutoCompound) {\n            // For AutoCompound: transfer AERO and re-encode with actual amount\n            if (aeroAmount > 0) {\n                aeroToken.safeTransfer(transformer, aeroAmount);\n            }\n            \n            // Re-encode the call data with the actual aeroAmount\n            // Decode the original params (skip the selector and tokenId, insert aeroAmount)\n            (uint256 originalTokenId, , bytes memory swapData0, bytes memory swapData1, \n             uint256 minAmount0, uint256 minAmount1, uint256 aeroSplitBps, uint256 deadline) = \n                abi.decode(data[4:], (uint256, uint256, bytes, bytes, uint256, uint256, uint256, uint256));\n            \n            // Re-encode with the actual aeroAmount\n            callData = abi.encodeWithSelector(\n                selector,\n                originalTokenId,\n                aeroAmount,\n                swapData0,\n                swapData1,\n                minAmount0,\n                minAmount1,\n                aeroSplitBps,\n                deadline\n            );\n        } else if (aeroAmount > 0) {\n            // For other transformers: send AERO to position owner\n            aeroToken.safeTransfer(owner, aeroAmount);\n        }\n        \n        // 2. Unstake from gauge\n        IGauge(gauge).withdraw(tokenId);\n        \n        // 3. Execute transform\n        nonfungiblePositionManager.approve(transformer, tokenId);\n        (bool success,) = transformer.call(callData);\n        require(success, \"Transform failed\");\n        \n        // 4. Get new tokenId (may have changed)\n        newTokenId = transformedTokenId;\n        \n        // Verify ownership\n        require(nonfungiblePositionManager.ownerOf(newTokenId) == address(this), \n                \"Position not returned\");\n        \n        // Clear approval\n        nonfungiblePositionManager.approve(address(0), newTokenId);\n        \n        // 5. Re-stake to same gauge\n        nonfungiblePositionManager.approve(gauge, newTokenId);\n        IGauge(gauge).deposit(newTokenId);\n        \n        // 6. Update mappings if tokenId changed\n        if (newTokenId != tokenId) {\n            // Transfer approvals to new tokenId\n            // Note: This is a design choice - we transfer approvals to maintain continuity\n            // Alternatively, we could require re-approval for the new tokenId\n            \n            // Clean up old tokenId\n            delete tokenIdToGauge[tokenId];\n            delete positionOwners[tokenId];\n            delete isVaultPosition[tokenId];\n            \n            // Set up new tokenId\n            tokenIdToGauge[newTokenId] = gauge;\n            positionOwners[newTokenId] = owner;\n            isVaultPosition[newTokenId] = fromVault;\n        }\n        \n        // Clear reentrancy guard\n        transformedTokenId = 0;\n        \n        emit PositionTransformed(tokenId, newTokenId, owner);\n    }\n\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata) \n        external override returns (bytes4) {\n        require(msg.sender == address(nonfungiblePositionManager), \"Only NPM\");\n        \n        // Handle transform case - AutoRange sends new NFT back\n        if (transformedTokenId != 0 && from == address(this)) {\n            transformedTokenId = tokenId;\n        }\n        \n        return IERC721Receiver.onERC721Received.selector;\n    }\n    \n    /**\n     * @notice Set compound reward fee (onlyOwner)\n     * @param _totalRewardX64 Fee percentage in X64 format (max 5%)\n     */\n    function setReward(uint64 _totalRewardX64) external onlyOwner {\n        require(_totalRewardX64 <= MAX_REWARD_X64, \"Fee too high\");\n        totalRewardX64 = _totalRewardX64;\n        emit RewardUpdated(msg.sender, _totalRewardX64);\n    }\n    \n    /**\n     * @notice Set fee withdrawer address (onlyOwner)\n     * @param _feeWithdrawer Address that can withdraw fees\n     */\n    function setFeeWithdrawer(address _feeWithdrawer) external onlyOwner {\n        feeWithdrawer = _feeWithdrawer;\n        emit FeeWithdrawerUpdated(_feeWithdrawer);\n    }\n    \n    /**\n     * @notice Withdraw accumulated compound fees\n     * @param tokens Array of token addresses to withdraw\n     * @param to Recipient address\n     */\n    function withdrawFees(address[] calldata tokens, address to) external nonReentrant {\n        require(msg.sender == feeWithdrawer, \"Not fee withdrawer\");\n        for (uint i = 0; i < tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(to, balance);\n                emit FeesWithdrawn(tokens[i], to, balance);\n            }\n        }\n    }\n    \n    // Events for compound fee management\n    event RewardUpdated(address account, uint64 totalRewardX64);\n    event FeeWithdrawerUpdated(address withdrawer);\n    event FeesWithdrawn(address token, address to, uint256 amount);\n}\n",
        "V3Vault.sol": "\npragma solidity ^0.8.0;\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport \"permit2/interfaces/IPermit2.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IV3Oracle.sol\";\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\n\nimport \"./utils/Constants.sol\";\n\n\ncontract V3Vault is ERC20, Multicall, Ownable2Step, IVault, IERC721Receiver, Constants {\n    using Math for uint256;\n\n    uint32 public constant MAX_COLLATERAL_FACTOR_X32 = uint32(Q32 * 90 / 100);\n\n    uint32 public constant MIN_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 2 / 100);\n    uint32 public constant MAX_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 10 / 100);\n\n    uint32 public constant MIN_RESERVE_PROTECTION_FACTOR_X32 = uint32(Q32 / 100);\n\n    uint32 public constant MAX_DAILY_LEND_INCREASE_X32 = uint32(Q32 / 10);\n    uint32 public constant MAX_DAILY_DEBT_INCREASE_X32 = uint32(Q32 / 10);\n\n    uint32 public constant BORROW_SAFETY_BUFFER_X32 = uint32(Q32 * 95 / 100);\n\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    IUniswapV3Factory public immutable factory;\n\n    IInterestRateModel public immutable interestRateModel;\n\n    IV3Oracle public immutable oracle;\n\n    IPermit2 public immutable permit2;\n\n    address public immutable override asset;\n\n    uint8 private immutable assetDecimals;\n\n    event ApprovedTransform(uint256 indexed tokenId, address owner, address target, bool isActive);\n\n    event Add(uint256 indexed tokenId, address owner, uint256 oldTokenId);\n    event Remove(uint256 indexed tokenId, address owner, address recipient);\n\n    event ExchangeRateUpdate(uint256 debtExchangeRateX96, uint256 lendExchangeRateX96);\n    \n    event WithdrawCollateral(\n        uint256 indexed tokenId, address owner, address recipient, uint128 liquidity, uint256 amount0, uint256 amount1\n    );\n    event Borrow(uint256 indexed tokenId, address owner, uint256 assets, uint256 shares);\n    event Repay(uint256 indexed tokenId, address repayer, address owner, uint256 assets, uint256 shares);\n    event Liquidate(\n        uint256 indexed tokenId,\n        address liquidator,\n        address owner,\n        uint256 value,\n        uint256 cost,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 reserve,\n        uint256 missing\n    ); \n\n    event WithdrawReserves(uint256 amount, address receiver);\n    event SetTransformer(address transformer, bool active);\n    event SetLimits(\n        uint256 minLoanSize,\n        uint256 globalLendLimit,\n        uint256 globalDebtLimit,\n        uint256 dailyLendIncreaseLimitMin,\n        uint256 dailyDebtIncreaseLimitMin\n    );\n    event SetReserveFactor(uint32 reserveFactorX32);\n    \n    event SetReserveProtectionFactor(uint32 reserveProtectionFactorX32);\n    event SetTokenConfig(address token, uint32 collateralFactorX32, uint32 collateralValueLimitFactorX32);\n\n    event SetEmergencyAdmin(address emergencyAdmin);\n\n    struct TokenConfig {\n        uint32 collateralFactorX32; \n        uint32 collateralValueLimitFactorX32; \n        uint192 totalDebtShares; \n    }\n\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    uint256 public debtSharesTotal;\n\n    uint256 public lastDebtExchangeRateX96 = Q96;\n    uint256 public lastLendExchangeRateX96 = Q96;\n\n    uint256 public globalDebtLimit;\n    uint256 public globalLendLimit;\n\n    uint256 public minLoanSize;\n\n    uint256 public dailyLendIncreaseLimitMin;\n    uint256 public dailyLendIncreaseLimitLeft;\n\n    uint256 public dailyDebtIncreaseLimitMin;\n    uint256 public dailyDebtIncreaseLimitLeft;\n\n    struct Loan {\n        uint256 debtShares;\n    }\n\n    mapping(uint256 => Loan) public override loans; \n\n    mapping(address => uint256[]) private ownedTokens; \n    mapping(uint256 => uint256) private ownedTokensIndex; \n    mapping(uint256 => address) private tokenOwner; \n\n    uint256 public override transformedTokenId; \n\n    mapping(address => bool) public transformerAllowList; \n    mapping(address => mapping(uint256 => mapping(address => bool))) public transformApprovals; \n\n    uint64 public lastExchangeRateUpdate;\n\n    uint32 public reserveFactorX32;\n\n    uint32 public reserveProtectionFactorX32 = MIN_RESERVE_PROTECTION_FACTOR_X32;\n\n    uint32 public dailyLendIncreaseLimitLastReset;\n    uint32 public dailyDebtIncreaseLimitLastReset;\n\n    address public emergencyAdmin;\n    \n    // Gauge integration\n    address public gaugeManager;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _asset,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        IInterestRateModel _interestRateModel,\n        IV3Oracle _oracle,\n        IPermit2 _permit2\n    ) ERC20(name, symbol) {\n        asset = _asset;\n        assetDecimals = IERC20Metadata(_asset).decimals();\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        factory = IUniswapV3Factory(_nonfungiblePositionManager.factory());\n        interestRateModel = _interestRateModel;\n        oracle = _oracle;\n        permit2 = _permit2;\n    }\n\n    function vaultInfo()\n        external\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 lent,\n            uint256 balance,\n            uint256 reserves,\n            uint256 debtExchangeRateX96,\n            uint256 lendExchangeRateX96\n        )\n    {\n        (debtExchangeRateX96, lendExchangeRateX96) = _calculateGlobalInterest();\n        (balance, reserves) = _getBalanceAndReserves(debtExchangeRateX96, lendExchangeRateX96);\n\n        debt = _convertToAssets(debtSharesTotal, debtExchangeRateX96, Math.Rounding.Up);\n        lent = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    function lendInfo(address account) external view override returns (uint256 amount) {\n        (, uint256 newLendExchangeRateX96) = _calculateGlobalInterest();\n        amount = _convertToAssets(balanceOf(account), newLendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    function loanInfo(uint256 tokenId)\n        external\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 fullValue,\n            uint256 collateralValue,\n            uint256 liquidationCost,\n            uint256 liquidationValue\n        )\n    {\n        (uint256 newDebtExchangeRateX96,) = _calculateGlobalInterest();\n\n        debt = _convertToAssets(loans[tokenId].debtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n\n        bool isHealthy;\n        (isHealthy, fullValue, collateralValue,) = _checkLoanIsHealthy(tokenId, debt, false);\n\n        if (!isHealthy) {\n            (liquidationValue, liquidationCost,) = _calculateLiquidation(debt, fullValue, collateralValue);\n        }\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address owner) {\n        return tokenOwner[tokenId];\n    }\n\n    function loanCount(address owner) external view override returns (uint256) {\n        return ownedTokens[owner].length;\n    }\n\n    function loanAtIndex(address owner, uint256 index) external view override returns (uint256) {\n        return ownedTokens[owner][index];\n    }\n\n    function decimals() public view override(IERC20Metadata, ERC20) returns (uint8) {\n        return assetDecimals;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    function convertToShares(uint256 assets) external view override returns (uint256 shares) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    function convertToAssets(uint256 shares) external view override returns (uint256 assets) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    function maxDeposit(address) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        uint256 value = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        if (value >= globalLendLimit) {\n            return 0;\n        } else {\n            uint256 maxGlobalDeposit = globalLendLimit - value;\n            if (maxGlobalDeposit > dailyLendIncreaseLimitLeft) {\n                return dailyLendIncreaseLimitLeft;\n            } else {\n                return maxGlobalDeposit;\n            }\n        }\n    }\n\n    function maxMint(address) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        uint256 value = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        if (value >= globalLendLimit) {\n            return 0;\n        } else {\n            uint256 maxGlobalDeposit = globalLendLimit - value;\n            if (maxGlobalDeposit > dailyLendIncreaseLimitLeft) {\n                return _convertToShares(dailyLendIncreaseLimitLeft, lendExchangeRateX96, Math.Rounding.Down);\n            } else {\n                return _convertToShares(maxGlobalDeposit, lendExchangeRateX96, Math.Rounding.Down);\n            }\n        }\n    }\n\n    function maxWithdraw(address owner) external view override returns (uint256) {\n        (uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n\n        uint256 ownerShareBalance = balanceOf(owner);\n        uint256 ownerAssetBalance = _convertToAssets(ownerShareBalance, lendExchangeRateX96, Math.Rounding.Down);\n\n        (uint256 balance,) = _getBalanceAndReserves(debtExchangeRateX96, lendExchangeRateX96);\n        if (balance > ownerAssetBalance) {\n            return ownerAssetBalance;\n        } else {\n            return balance;\n        }\n    }\n\n    function maxRedeem(address owner) external view override returns (uint256) {\n        (uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n\n        uint256 ownerShareBalance = balanceOf(owner);\n\n        (uint256 balance,) = _getBalanceAndReserves(debtExchangeRateX96, lendExchangeRateX96);\n        uint256 shareBalance = _convertToShares(balance, lendExchangeRateX96, Math.Rounding.Down);\n\n        if (shareBalance > ownerShareBalance) {\n            return ownerShareBalance;\n        } else {\n            return shareBalance;\n        }\n    }\n\n    function previewDeposit(uint256 assets) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    function previewMint(uint256 shares) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    function previewWithdraw(uint256 assets) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    function previewRedeem(uint256 shares) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    function deposit(uint256 assets, address receiver) external override returns (uint256) {\n        (, uint256 shares) = _deposit(receiver, assets, false, \"\");\n        return shares;\n    }\n\n    function mint(uint256 shares, address receiver) external override returns (uint256) {\n        (uint256 assets,) = _deposit(receiver, shares, true, \"\");\n        return assets;\n    }\n\n    function withdraw(uint256 assets, address receiver, address owner) external override returns (uint256) {\n        (, uint256 shares) = _withdraw(receiver, owner, assets, false);\n        return shares;\n    }\n\n    function redeem(uint256 shares, address receiver, address owner) external override returns (uint256) {\n        (uint256 assets,) = _withdraw(receiver, owner, shares, true);\n        return assets;\n    }\n\n    function deposit(uint256 assets, address receiver, bytes calldata permitData) external override returns (uint256) {\n        (, uint256 shares) = _deposit(receiver, assets, false, permitData);\n        return shares;\n    }\n\n    function mint(uint256 shares, address receiver, bytes calldata permitData) external override returns (uint256) {\n        (uint256 assets,) = _deposit(receiver, shares, true, permitData);\n        return assets;\n    }\n\n    function create(uint256 tokenId, address recipient) external override {\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId, abi.encode(recipient));\n    }\n\n    function createWithPermit(uint256 tokenId, address recipient, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        override\n    {\n        nonfungiblePositionManager.permit(address(this), tokenId, deadline, v, r, s);\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId, abi.encode(recipient));\n    }\n\n    function onERC721Received(address,  address from, uint256 tokenId, bytes calldata data)\n        external\n        override\n        returns (bytes4)\n    {\n        \n        if (msg.sender != address(nonfungiblePositionManager) || from == address(this)) {\n            revert WrongContract();\n        }\n\n        (uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) = _updateGlobalInterest();\n\n        uint256 oldTokenId = transformedTokenId;\n\n        if (oldTokenId == 0) {\n            address owner = from;\n            if (data.length != 0) {\n                owner = abi.decode(data, (address));\n            }\n            loans[tokenId] = Loan(0);\n\n            _addTokenToOwner(owner, tokenId);\n            emit Add(tokenId, owner, 0);\n        } else {\n            \n            if (tokenId != oldTokenId) {\n                address owner = tokenOwner[oldTokenId];\n\n                transformedTokenId = tokenId;\n\n                uint256 debtShares = loans[oldTokenId].debtShares;\n\n                loans[tokenId] = Loan(debtShares);\n\n                _addTokenToOwner(owner, tokenId);\n                emit Add(tokenId, owner, oldTokenId);\n\n                _cleanupLoan(oldTokenId, debtExchangeRateX96, lendExchangeRateX96);\n\n                _updateAndCheckCollateral(\n                    tokenId, debtExchangeRateX96, lendExchangeRateX96, 0, debtShares\n                );\n            }\n        }\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function approveTransform(uint256 tokenId, address target, bool isActive) external override {\n        if (tokenOwner[tokenId] != msg.sender) {\n            revert Unauthorized();\n        }\n        transformApprovals[msg.sender][tokenId][target] = isActive;\n\n        emit ApprovedTransform(tokenId, msg.sender, target, isActive);\n    }\n\n    function transform(uint256 tokenId, address transformer, bytes calldata data)\n        external\n        override\n        returns (uint256 newTokenId)\n    {\n        if (tokenId == 0 || !transformerAllowList[transformer]) {\n            revert TransformNotAllowed();\n        }\n        if (transformedTokenId != 0) {\n            revert Reentrancy();\n        }\n        transformedTokenId = tokenId;\n\n        (uint256 newDebtExchangeRateX96,) = _updateGlobalInterest();\n\n        address loanOwner = tokenOwner[tokenId];\n\n        if (loanOwner != msg.sender && !transformApprovals[loanOwner][tokenId][msg.sender]) {\n            revert Unauthorized();\n        }\n\n        // Track if position was staked before transformation\n        bool wasStaked = gaugeManager != address(0) && IGaugeManager(gaugeManager).tokenIdToGauge(tokenId) != address(0);\n        \n        // Unstake position if it's in a gauge (for liquidations/transformations)\n        if (wasStaked) {\n            _unstakeForLiquidation(tokenId);\n        }\n\n        nonfungiblePositionManager.approve(transformer, tokenId);\n\n        (bool success,) = transformer.call(data);\n        if (!success) {\n            revert TransformFailed();\n        }\n\n        newTokenId = transformedTokenId;\n\n        if (tokenId != newTokenId && transformApprovals[loanOwner][tokenId][msg.sender]) {\n            transformApprovals[loanOwner][newTokenId][msg.sender] = true;\n            delete transformApprovals[loanOwner][tokenId][msg.sender];\n        }\n\n        address owner = nonfungiblePositionManager.ownerOf(newTokenId);\n        if (owner != address(this)) {\n            revert Unauthorized();\n        }\n\n        nonfungiblePositionManager.approve(address(0), newTokenId);\n\n        uint256 debt = _convertToAssets(loans[newTokenId].debtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n        _requireLoanIsHealthy(newTokenId, debt, false);\n\n        transformedTokenId = 0;\n        \n        // Re-stake the position if it was previously staked\n        if (wasStaked) {\n            nonfungiblePositionManager.approve(gaugeManager, newTokenId);\n            IGaugeManager(gaugeManager).stakePosition(newTokenId);\n        }\n    }\n\n    function borrow(uint256 tokenId, uint256 assets) external override {\n\n        bool isTransformMode = tokenId != 0 && transformedTokenId == tokenId && transformerAllowList[msg.sender];\n\n        address owner = tokenOwner[tokenId];\n\n        if (!isTransformMode && owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n\n        _resetDailyDebtIncreaseLimit(newLendExchangeRateX96, false);\n\n        Loan storage loan = loans[tokenId];\n\n        uint256 shares = _convertToShares(assets, newDebtExchangeRateX96, Math.Rounding.Up);\n\n        uint256 loanDebtShares = loan.debtShares + shares;\n        loan.debtShares = loanDebtShares;\n        debtSharesTotal = debtSharesTotal + shares;\n\n        if (debtSharesTotal > _convertToShares(globalDebtLimit, newDebtExchangeRateX96, Math.Rounding.Down)) {\n            revert GlobalDebtLimit();\n        }\n        if (assets > dailyDebtIncreaseLimitLeft) {\n            revert DailyDebtIncreaseLimit();\n        } else {\n            dailyDebtIncreaseLimitLeft = dailyDebtIncreaseLimitLeft - assets;\n        }\n\n        _updateAndCheckCollateral(\n            tokenId, newDebtExchangeRateX96, newLendExchangeRateX96, loanDebtShares - shares, loanDebtShares\n        );\n\n        uint256 debt = _convertToAssets(loanDebtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n\n        if (debt < minLoanSize) {\n            revert MinLoanSize();\n        }\n\n        if (!isTransformMode) {\n            _requireLoanIsHealthy(tokenId, debt, true);\n        }\n\n        SafeERC20.safeTransfer(IERC20(asset), msg.sender, assets);\n\n        emit Borrow(tokenId, owner, assets, shares);\n    }\n\n    function decreaseLiquidityAndCollect(DecreaseLiquidityAndCollectParams calldata params)\n        external\n        override\n        returns (uint256 amount0, uint256 amount1)\n    {\n        \n        if (transformedTokenId != 0) {\n            revert TransformNotAllowed();\n        }\n\n        address owner = tokenOwner[params.tokenId];\n\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        (uint256 newDebtExchangeRateX96,) = _updateGlobalInterest();\n\n        if (params.liquidity != 0) {\n            (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams(\n                    params.tokenId, params.liquidity, params.amount0Min, params.amount1Min, params.deadline\n                )\n            );\n        }\n\n        INonfungiblePositionManager.CollectParams memory collectParams = INonfungiblePositionManager.CollectParams(\n            params.tokenId,\n            params.recipient,\n            params.feeAmount0 == type(uint128).max ? type(uint128).max : SafeCast.toUint128(amount0 + params.feeAmount0),\n            params.feeAmount1 == type(uint128).max ? type(uint128).max : SafeCast.toUint128(amount1 + params.feeAmount1)\n        );\n\n        (amount0, amount1) = nonfungiblePositionManager.collect(collectParams);\n\n        uint256 debt = _convertToAssets(loans[params.tokenId].debtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n        _requireLoanIsHealthy(params.tokenId, debt, true);\n\n        emit WithdrawCollateral(params.tokenId, owner, params.recipient, params.liquidity, amount0, amount1);\n    }\n\n    function repay(uint256 tokenId, uint256 amount, bool isShare)\n        external\n        override\n        returns (uint256 assets, uint256 shares)\n    {\n        (assets, shares) = _repay(tokenId, amount, isShare, \"\");\n    }\n\n    function repay(uint256 tokenId, uint256 amount, bool isShare, bytes calldata permitData)\n        external\n        override\n        returns (uint256 assets, uint256 shares)\n    {\n        (assets, shares) = _repay(tokenId, amount, isShare, permitData);\n    }\n\n    struct LiquidateState {\n        uint256 newDebtExchangeRateX96;\n        uint256 newLendExchangeRateX96;\n        uint256 debt;\n        bool isHealthy;\n        uint256 liquidationValue;\n        uint256 liquidatorCost;\n        uint256 reserveCost;\n        uint256 missing;\n        uint256 fullValue;\n        uint256 collateralValue;\n        uint256 feeValue;\n    }\n\n    function liquidate(LiquidateParams calldata params) external override returns (uint256 amount0, uint256 amount1) {\n        \n        if (transformedTokenId != 0) {\n            revert TransformNotAllowed();\n        }\n\n        _unstakeForLiquidation(params.tokenId);\n\n        LiquidateState memory state;\n\n        (state.newDebtExchangeRateX96, state.newLendExchangeRateX96) = _updateGlobalInterest();\n\n        _resetDailyDebtIncreaseLimit(state.newLendExchangeRateX96, false);\n\n        uint256 debtShares = loans[params.tokenId].debtShares;\n\n        state.debt = _convertToAssets(debtShares, state.newDebtExchangeRateX96, Math.Rounding.Up);\n\n        (state.isHealthy, state.fullValue, state.collateralValue, state.feeValue) =\n            _checkLoanIsHealthy(params.tokenId, state.debt, false);\n        if (state.isHealthy) {\n            revert NotLiquidatable();\n        }\n\n        (state.liquidationValue, state.liquidatorCost, state.reserveCost) =\n            _calculateLiquidation(state.debt, state.fullValue, state.collateralValue);\n\n        if (state.reserveCost != 0) {\n            state.missing =\n                _handleReserveLiquidation(state.reserveCost, state.newDebtExchangeRateX96, state.newLendExchangeRateX96);\n        }\n\n        if (state.liquidatorCost != 0) {\n            if (params.permitData.length != 0) {\n                (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =\n                    abi.decode(params.permitData, (ISignatureTransfer.PermitTransferFrom, bytes));\n\n                if (permit.permitted.token != asset) {\n                    revert InvalidToken();\n                }\n\n                permit2.permitTransferFrom(\n                    permit,\n                    ISignatureTransfer.SignatureTransferDetails(address(this), state.liquidatorCost),\n                    msg.sender,\n                    signature\n                );\n            } else {\n                \n                SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), state.liquidatorCost);\n            }\n        }\n\n        debtSharesTotal = debtSharesTotal - debtShares;\n\n        dailyDebtIncreaseLimitLeft = dailyDebtIncreaseLimitLeft + state.debt;\n\n        (amount0, amount1) = _sendPositionValue(\n            params.tokenId, state.liquidationValue, state.fullValue, state.feeValue, params.recipient, params.deadline\n        );\n\n        if (amount0 < params.amount0Min || amount1 < params.amount1Min) {\n            revert SlippageError();\n        }\n\n        _cleanupLoan(params.tokenId, state.newDebtExchangeRateX96, state.newLendExchangeRateX96);\n\n        emit Liquidate(\n            params.tokenId,\n            msg.sender,\n            tokenOwner[params.tokenId],\n            state.fullValue,\n            state.liquidatorCost,\n            amount0,\n            amount1,\n            state.reserveCost,\n            state.missing\n        );\n    }\n\n    function remove(uint256 tokenId, address recipient, bytes calldata data) external {\n        address owner = tokenOwner[tokenId];\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        if (loans[tokenId].debtShares != 0) {\n            revert NeedsRepay();\n        }\n\n        _unstakeForLiquidation(tokenId);\n\n        _removeTokenFromOwner(owner, tokenId);\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), recipient, tokenId, data);\n        emit Remove(tokenId, owner, recipient);\n    }\n\n\n\n    function withdrawReserves(uint256 amount, address receiver) external onlyOwner {\n        (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n\n        uint256 protected =\n            _convertToAssets(totalSupply(), newLendExchangeRateX96, Math.Rounding.Up) * reserveProtectionFactorX32 / Q32;\n        (uint256 balance, uint256 reserves) = _getBalanceAndReserves(newDebtExchangeRateX96, newLendExchangeRateX96);\n        uint256 unprotected = reserves > protected ? reserves - protected : 0;\n        uint256 available = balance > unprotected ? unprotected : balance;\n\n        if (amount > available) {\n            revert InsufficientLiquidity();\n        }\n\n        if (amount != 0) {\n            SafeERC20.safeTransfer(IERC20(asset), receiver, amount);\n        }\n\n        emit WithdrawReserves(amount, receiver);\n    }\n\n    function setTransformer(address transformer, bool active) external onlyOwner {\n        \n        if (\n            transformer == address(0) || transformer == address(this) || transformer == asset\n                || transformer == address(nonfungiblePositionManager)\n        ) {\n            revert InvalidConfig();\n        }\n\n        transformerAllowList[transformer] = active;\n        emit SetTransformer(transformer, active);\n    }\n\n    function setLimits(\n        uint256 _minLoanSize,\n        uint256 _globalLendLimit,\n        uint256 _globalDebtLimit,\n        uint256 _dailyLendIncreaseLimitMin,\n        uint256 _dailyDebtIncreaseLimitMin\n    ) external {\n        if (msg.sender != emergencyAdmin && msg.sender != owner()) {\n            revert Unauthorized();\n        }\n\n        minLoanSize = _minLoanSize;\n        globalLendLimit = _globalLendLimit;\n        globalDebtLimit = _globalDebtLimit;\n        dailyLendIncreaseLimitMin = _dailyLendIncreaseLimitMin;\n        dailyDebtIncreaseLimitMin = _dailyDebtIncreaseLimitMin;\n\n        (, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n\n        _resetDailyLendIncreaseLimit(newLendExchangeRateX96, true);\n        _resetDailyDebtIncreaseLimit(newLendExchangeRateX96, true);\n\n        emit SetLimits(\n            _minLoanSize, _globalLendLimit, _globalDebtLimit, _dailyLendIncreaseLimitMin, _dailyDebtIncreaseLimitMin\n        );\n    }\n\n    function setReserveFactor(uint32 _reserveFactorX32) external onlyOwner {\n        \n        _updateGlobalInterest();\n        reserveFactorX32 = _reserveFactorX32;\n        emit SetReserveFactor(_reserveFactorX32);\n    }\n\n    function setReserveProtectionFactor(uint32 _reserveProtectionFactorX32) external onlyOwner {\n        if (_reserveProtectionFactorX32 < MIN_RESERVE_PROTECTION_FACTOR_X32) {\n            revert InvalidConfig();\n        }\n        reserveProtectionFactorX32 = _reserveProtectionFactorX32;\n        emit SetReserveProtectionFactor(_reserveProtectionFactorX32);\n    }\n\n    function setTokenConfig(address token, uint32 collateralFactorX32, uint32 collateralValueLimitFactorX32)\n        external\n        onlyOwner\n    {\n        if (collateralFactorX32 > MAX_COLLATERAL_FACTOR_X32) {\n            revert CollateralFactorExceedsMax();\n        }\n        TokenConfig storage config = tokenConfigs[token];\n        config.collateralFactorX32 = collateralFactorX32;\n        config.collateralValueLimitFactorX32 = collateralValueLimitFactorX32;\n        emit SetTokenConfig(token, collateralFactorX32, collateralValueLimitFactorX32);\n    }\n\n    function setEmergencyAdmin(address admin) external onlyOwner {\n        emergencyAdmin = admin;\n        emit SetEmergencyAdmin(admin);\n    }\n\n\n\n    function _deposit(address receiver, uint256 amount, bool isShare, bytes memory permitData)\n        internal\n        returns (uint256 assets, uint256 shares)\n    {\n        (, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n\n        _resetDailyLendIncreaseLimit(newLendExchangeRateX96, false);\n\n        if (isShare) {\n            shares = amount;\n            assets = _convertToAssets(shares, newLendExchangeRateX96, Math.Rounding.Up);\n        } else {\n            assets = amount;\n            shares = _convertToShares(assets, newLendExchangeRateX96, Math.Rounding.Down);\n        }\n\n        uint256 newTotalAssets = _convertToAssets(totalSupply() + shares, newLendExchangeRateX96, Math.Rounding.Up);\n        if (newTotalAssets > globalLendLimit) {\n            revert GlobalLendLimit();\n        }\n        if (assets > dailyLendIncreaseLimitLeft) {\n            revert DailyLendIncreaseLimit();\n        }\n\n        dailyLendIncreaseLimitLeft = dailyLendIncreaseLimitLeft - assets;\n\n        if (permitData.length != 0) {\n            (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =\n                abi.decode(permitData, (ISignatureTransfer.PermitTransferFrom, bytes));\n\n            if (permit.permitted.token != asset) {\n                revert InvalidToken();\n            }\n\n            permit2.permitTransferFrom(\n                permit, ISignatureTransfer.SignatureTransferDetails(address(this), assets), msg.sender, signature\n            );\n        } else {\n            \n            SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), assets);\n        }\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function _withdraw(address receiver, address owner, uint256 amount, bool isShare)\n        internal\n        returns (uint256 assets, uint256 shares)\n    {\n        (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n        _resetDailyLendIncreaseLimit(newLendExchangeRateX96, false);\n\n        if (isShare) {\n            shares = amount;\n            assets = _convertToAssets(amount, newLendExchangeRateX96, Math.Rounding.Down);\n        } else {\n            assets = amount;\n            shares = _convertToShares(amount, newLendExchangeRateX96, Math.Rounding.Up);\n        }\n\n        uint256 ownerBalance = balanceOf(owner);\n        if (shares > ownerBalance) {\n            shares = ownerBalance;\n            assets = _convertToAssets(shares, newLendExchangeRateX96, Math.Rounding.Down);\n        }\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        (uint256 balance,) = _getBalanceAndReserves(newDebtExchangeRateX96, newLendExchangeRateX96);\n        if (balance < assets) {\n            revert InsufficientLiquidity();\n        }\n\n        _burn(owner, shares);\n        \n        dailyLendIncreaseLimitLeft = dailyLendIncreaseLimitLeft + assets;\n        \n        SafeERC20.safeTransfer(IERC20(asset), receiver, assets);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function _repay(uint256 tokenId, uint256 amount, bool isShare, bytes memory permitData)\n        internal\n        returns (uint256 assets, uint256 shares)\n    {\n        (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n        _resetDailyDebtIncreaseLimit(newLendExchangeRateX96, false);\n\n        Loan storage loan = loans[tokenId];\n\n        uint256 currentShares = loan.debtShares;\n\n        if (isShare) {\n            shares = amount;\n            assets = _convertToAssets(amount, newDebtExchangeRateX96, Math.Rounding.Up);\n        } else {\n            assets = amount;\n            shares = _convertToShares(amount, newDebtExchangeRateX96, Math.Rounding.Down);\n        }\n\n        if (shares == 0) {\n            revert NoSharesRepayed();\n        }\n\n        if (shares > currentShares) {\n            shares = currentShares;\n            assets = _convertToAssets(shares, newDebtExchangeRateX96, Math.Rounding.Up);\n        }\n\n        if (assets != 0) {\n            if (permitData.length != 0) {\n                (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =\n                    abi.decode(permitData, (ISignatureTransfer.PermitTransferFrom, bytes));\n\n                if (permit.permitted.token != asset) {\n                    revert InvalidToken();\n                }\n\n                permit2.permitTransferFrom(\n                    permit, ISignatureTransfer.SignatureTransferDetails(address(this), assets), msg.sender, signature\n                );\n            } else {\n                \n                SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), assets);\n            }\n        }\n\n        uint256 loanDebtShares = currentShares - shares;\n        loan.debtShares = loanDebtShares;\n        debtSharesTotal = debtSharesTotal - shares;\n\n        dailyDebtIncreaseLimitLeft = dailyDebtIncreaseLimitLeft + assets;\n\n        _updateAndCheckCollateral(\n            tokenId, newDebtExchangeRateX96, newLendExchangeRateX96, loanDebtShares + shares, loanDebtShares\n        );\n\n        if (currentShares != shares) {\n            \n            if (_convertToAssets(loanDebtShares, newDebtExchangeRateX96, Math.Rounding.Up) < minLoanSize) {\n                revert MinLoanSize();\n            }\n        }\n\n        emit Repay(tokenId, msg.sender, tokenOwner[tokenId], assets, shares);\n    }\n\n    function _getBalanceAndReserves(uint256 debtExchangeRateX96, uint256 lendExchangeRateX96)\n        internal\n        view\n        returns (uint256 balance, uint256 reserves)\n    {\n        balance = totalAssets();\n        uint256 debt = _convertToAssets(debtSharesTotal, debtExchangeRateX96, Math.Rounding.Up);\n        uint256 lent = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        unchecked {\n            reserves = balance + debt > lent ? balance + debt - lent : 0;\n        }\n    }\n\n    function _sendPositionValue(\n        uint256 tokenId,\n        uint256 liquidationValue,\n        uint256 fullValue,\n        uint256 feeValue,\n        address recipient,\n        uint256 deadline\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        uint128 liquidity;\n        uint128 fees0;\n        uint128 fees1;\n\n        if (liquidationValue == fullValue) {\n            (,,,,,,, liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\n            fees0 = type(uint128).max;\n            fees1 = type(uint128).max;\n        } else {\n            (liquidity, fees0, fees1) = oracle.getLiquidityAndFees(tokenId);\n\n            if (liquidationValue <= feeValue) {\n                liquidity = 0;\n                unchecked {\n                    fees0 = SafeCast.toUint128(liquidationValue * fees0 / feeValue);\n                    fees1 = SafeCast.toUint128(liquidationValue * fees1 / feeValue);\n                }\n            } else {\n                \n                fees0 = type(uint128).max;\n                fees1 = type(uint128).max;\n                unchecked {\n                    liquidity = SafeCast.toUint128((liquidationValue - feeValue) * liquidity / (fullValue - feeValue));\n                }\n            }\n        }\n\n        if (liquidity != 0) {\n            nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidity, 0, 0, deadline)\n            );\n        }\n\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, recipient, fees0, fees1)\n        );\n    }\n\n    function _cleanupLoan(uint256 tokenId, uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) internal {\n        _updateAndCheckCollateral(tokenId, debtExchangeRateX96, lendExchangeRateX96, loans[tokenId].debtShares, 0);\n        delete loans[tokenId];\n    }\n\n    function _calculateLiquidation(uint256 debt, uint256 fullValue, uint256 collateralValue)\n        internal\n        pure\n        returns (uint256 liquidationValue, uint256 liquidatorCost, uint256 reserveCost)\n    {\n\n        liquidatorCost = debt;\n\n        uint256 maxPenaltyValue = debt * (Q32 + MAX_LIQUIDATION_PENALTY_X32) / Q32;\n\n        if (fullValue >= maxPenaltyValue) {\n            if (collateralValue != 0) {\n                \n                uint256 startLiquidationValue = debt * fullValue / collateralValue;\n                uint256 penaltyFractionX96 =\n                    (Q96 - ((fullValue - maxPenaltyValue) * Q96 / (startLiquidationValue - maxPenaltyValue)));\n                uint256 penaltyX32 = MIN_LIQUIDATION_PENALTY_X32\n                    + (MAX_LIQUIDATION_PENALTY_X32 - MIN_LIQUIDATION_PENALTY_X32) * penaltyFractionX96 / Q96;\n\n                liquidationValue = debt * (Q32 + penaltyX32) / Q32;\n            } else {\n                liquidationValue = maxPenaltyValue;\n            }\n        } else {\n            uint256 penalty = debt * MAX_LIQUIDATION_PENALTY_X32 / Q32;\n\n            if (fullValue > penalty) {\n                liquidatorCost = fullValue - penalty;\n            } else {\n                \n                liquidatorCost = 0;\n            }\n\n            liquidationValue = fullValue;\n            unchecked {\n                reserveCost = debt - liquidatorCost;\n            } \n        }\n    }\n\n    function _handleReserveLiquidation(\n        uint256 reserveCost,\n        uint256 newDebtExchangeRateX96,\n        uint256 newLendExchangeRateX96\n    ) internal returns (uint256 missing) {\n        (, uint256 reserves) = _getBalanceAndReserves(newDebtExchangeRateX96, newLendExchangeRateX96);\n\n        if (reserveCost > reserves) {\n            missing = reserveCost - reserves;\n\n            uint256 totalLent = _convertToAssets(totalSupply(), newLendExchangeRateX96, Math.Rounding.Up);\n\n            newLendExchangeRateX96 = (totalLent - missing) * newLendExchangeRateX96 / totalLent;\n            lastLendExchangeRateX96 = newLendExchangeRateX96;\n            emit ExchangeRateUpdate(newDebtExchangeRateX96, newLendExchangeRateX96);\n        }\n    }\n\n    function _calculateTokenCollateralFactorX32(uint256 tokenId) internal view returns (uint32) {\n        (,, address token0, address token1,,,,,,,,) = nonfungiblePositionManager.positions(tokenId);\n        uint32 factor0X32 = tokenConfigs[token0].collateralFactorX32;\n        uint32 factor1X32 = tokenConfigs[token1].collateralFactorX32;\n        return factor0X32 > factor1X32 ? factor1X32 : factor0X32;\n    }\n\n    function _updateGlobalInterest()\n        internal\n        returns (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96)\n    {\n        \n        if (block.timestamp > lastExchangeRateUpdate) {\n            (newDebtExchangeRateX96, newLendExchangeRateX96) = _calculateGlobalInterest();\n            lastDebtExchangeRateX96 = newDebtExchangeRateX96;\n            lastLendExchangeRateX96 = newLendExchangeRateX96;\n            lastExchangeRateUpdate = uint64(block.timestamp); \n            emit ExchangeRateUpdate(newDebtExchangeRateX96, newLendExchangeRateX96);\n        } else {\n            newDebtExchangeRateX96 = lastDebtExchangeRateX96;\n            newLendExchangeRateX96 = lastLendExchangeRateX96;\n        }\n    }\n\n    function _calculateGlobalInterest()\n        internal\n        view\n        returns (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96)\n    {\n        uint256 oldDebtExchangeRateX96 = lastDebtExchangeRateX96;\n        uint256 oldLendExchangeRateX96 = lastLendExchangeRateX96;\n\n        uint256 lastRateUpdate = lastExchangeRateUpdate;\n        uint256 timeElapsed = (block.timestamp - lastRateUpdate);\n\n        if (timeElapsed != 0 && lastRateUpdate != 0) {\n\n            (uint256 balance,) = _getBalanceAndReserves(oldDebtExchangeRateX96, oldLendExchangeRateX96);\n            uint256 debt = _convertToAssets(debtSharesTotal, oldDebtExchangeRateX96, Math.Rounding.Up);\n            (uint256 borrowRateX64, uint256 supplyRateX64) = interestRateModel.getRatesPerSecondX64(balance, debt);\n            supplyRateX64 = supplyRateX64.mulDiv(Q32 - reserveFactorX32, Q32);\n\n            newDebtExchangeRateX96 = oldDebtExchangeRateX96 + oldDebtExchangeRateX96 * timeElapsed * borrowRateX64 / Q64;\n            newLendExchangeRateX96 = oldLendExchangeRateX96 + oldLendExchangeRateX96 * timeElapsed * supplyRateX64 / Q64;\n        } else {\n            newDebtExchangeRateX96 = oldDebtExchangeRateX96;\n            newLendExchangeRateX96 = oldLendExchangeRateX96;\n        }\n    }\n\n    function _requireLoanIsHealthy(uint256 tokenId, uint256 debt, bool withBuffer) internal view {\n        (bool isHealthy,,,) = _checkLoanIsHealthy(tokenId, debt, withBuffer);\n        if (!isHealthy) {\n            revert CollateralFail();\n        }\n    }\n\n    function _updateAndCheckCollateral(\n        uint256 tokenId,\n        uint256 debtExchangeRateX96,\n        uint256 lendExchangeRateX96,\n        uint256 oldShares,\n        uint256 newShares\n    ) internal {\n        if (oldShares != newShares) {\n            (,, address token0, address token1,,,,,,,,) = nonfungiblePositionManager.positions(tokenId);\n\n            if (oldShares > newShares) {\n                uint192 difference = SafeCast.toUint192(oldShares - newShares);\n                tokenConfigs[token0].totalDebtShares -= difference;\n                tokenConfigs[token1].totalDebtShares -= difference;\n            } else {\n                uint192 difference = SafeCast.toUint192(newShares - oldShares);\n                tokenConfigs[token0].totalDebtShares += difference;\n                tokenConfigs[token1].totalDebtShares += difference;\n\n                uint256 lentAssets = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n                uint256 collateralValueLimitFactorX32 = tokenConfigs[token0].collateralValueLimitFactorX32;\n                if (\n                    collateralValueLimitFactorX32 < type(uint32).max\n                        && _convertToAssets(tokenConfigs[token0].totalDebtShares, debtExchangeRateX96, Math.Rounding.Up)\n                            > lentAssets * collateralValueLimitFactorX32 / Q32\n                ) {\n                    revert CollateralValueLimit();\n                }\n                collateralValueLimitFactorX32 = tokenConfigs[token1].collateralValueLimitFactorX32;\n                if (\n                    collateralValueLimitFactorX32 < type(uint32).max\n                        && _convertToAssets(tokenConfigs[token1].totalDebtShares, debtExchangeRateX96, Math.Rounding.Up)\n                            > lentAssets * collateralValueLimitFactorX32 / Q32\n                ) {\n                    revert CollateralValueLimit();\n                }\n            }\n        }\n    }\n\n    function _resetDailyLendIncreaseLimit(uint256 newLendExchangeRateX96, bool force) internal {\n        \n        uint32 time = uint32(block.timestamp / 1 days);\n        if (force || time > dailyLendIncreaseLimitLastReset) {\n            uint256 lendIncreaseLimit = _convertToAssets(totalSupply(), newLendExchangeRateX96, Math.Rounding.Up)\n                * MAX_DAILY_LEND_INCREASE_X32 / Q32;\n            dailyLendIncreaseLimitLeft =\n                dailyLendIncreaseLimitMin > lendIncreaseLimit ? dailyLendIncreaseLimitMin : lendIncreaseLimit;\n            dailyLendIncreaseLimitLastReset = time;\n        }\n    }\n\n    function _resetDailyDebtIncreaseLimit(uint256 newLendExchangeRateX96, bool force) internal {\n        \n        uint32 time = uint32(block.timestamp / 1 days);\n        if (force || time > dailyDebtIncreaseLimitLastReset) {\n            uint256 debtIncreaseLimit = _convertToAssets(totalSupply(), newLendExchangeRateX96, Math.Rounding.Up)\n                * MAX_DAILY_DEBT_INCREASE_X32 / Q32;\n            dailyDebtIncreaseLimitLeft =\n                dailyDebtIncreaseLimitMin > debtIncreaseLimit ? dailyDebtIncreaseLimitMin : debtIncreaseLimit;\n            dailyDebtIncreaseLimitLastReset = time;\n        }\n    }\n\n    function _checkLoanIsHealthy(uint256 tokenId, uint256 debt, bool withBuffer)\n        internal\n        view\n        returns (bool isHealthy, uint256 fullValue, uint256 collateralValue, uint256 feeValue)\n    {\n        (fullValue, feeValue,,) = oracle.getValue(tokenId, address(asset));\n        uint256 collateralFactorX32 = _calculateTokenCollateralFactorX32(tokenId);\n        collateralValue = fullValue.mulDiv(collateralFactorX32, Q32);\n        isHealthy = (withBuffer ? collateralValue * BORROW_SAFETY_BUFFER_X32 / Q32 : collateralValue) >= debt;\n    }\n\n    function _convertToShares(uint256 amount, uint256 exchangeRateX96, Math.Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        return amount.mulDiv(Q96, exchangeRateX96, rounding);\n    }\n\n    function _convertToAssets(uint256 shares, uint256 exchangeRateX96, Math.Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        return shares.mulDiv(exchangeRateX96, Q96, rounding);\n    }\n\n    function _addTokenToOwner(address to, uint256 tokenId) internal {\n        ownedTokensIndex[tokenId] = ownedTokens[to].length;\n        ownedTokens[to].push(tokenId);\n        tokenOwner[tokenId] = to;\n    }\n\n    function _removeTokenFromOwner(address from, uint256 tokenId) internal {\n        uint256 lastTokenIndex = ownedTokens[from].length - 1;\n        uint256 tokenIndex = ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = ownedTokens[from][lastTokenIndex];\n            ownedTokens[from][tokenIndex] = lastTokenId;\n            ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n        ownedTokens[from].pop();\n        \n        delete tokenOwner[tokenId]; \n    }\n\n    // Gauge Integration\n    \n    /// @notice Set gauge manager\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\n        gaugeManager = _gaugeManager;\n        emit GaugeManagerSet(_gaugeManager);\n    }\n\n    /// @notice Stake position in gauge\n    function stakePosition(uint256 tokenId) external {\n        if (gaugeManager == address(0)) revert GaugeManagerNotSet();\n        if (ownerOf(tokenId) != msg.sender) revert NotDepositor();\n        \n        nonfungiblePositionManager.approve(gaugeManager, tokenId);\n        IGaugeManager(gaugeManager).stakePosition(tokenId);\n    }\n\n    /// @notice Unstake position  \n    function unstakePosition(uint256 tokenId) external {\n        if (gaugeManager == address(0)) revert GaugeManagerNotSet();\n        if (ownerOf(tokenId) != msg.sender && transformedTokenId != tokenId) revert Unauthorized();\n        \n        IGaugeManager(gaugeManager).unstakePosition(tokenId);\n    }\n\n\n\n    /// @notice Emergency unstake for liquidations\n    function _unstakeForLiquidation(uint256 tokenId) internal {\n        if (gaugeManager != address(0) && IGaugeManager(gaugeManager).tokenIdToGauge(tokenId) != address(0)) {\n            IGaugeManager(gaugeManager).unstakePosition(tokenId);\n        }\n    }\n\n    event GaugeManagerSet(address indexed gaugeManager);\n\n}\n"
    }
}