{
    "vfp_id": "vfp_00264",
    "project_name": "2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "findings": [
        {
            "id": 65,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Invalid network registration in Delegation.registerNetwork can cause DoS",
            "description": "The registerNetwork function allows registration of the zero address as a network, which can lead to a denial-of-service condition. The cause is the lack of zero-address validation. An attacker could register a null network, causing subsequent operations to revert when interacting with it. This disrupts network registration and delegation functionality.\n",
            "severity": "Low",
            "location": [
                "Delegation.sol::registerNetwork"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 67,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Agent LTV can be configured equal to or higher than liquidation threshold",
            "description": "The protocol allows setting an agent's Loan-to-Value (LTV) ratio equal to or higher than its liquidation threshold, which makes liquidation impossible. The cause is insufficient validation in the configuration logic. An attacker with configuration rights could set such parameters to create unliquidatable positions. This increases credit risk and can lead to bad debt accumulation.\n",
            "severity": "Low",
            "location": [
                "Delegation.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Immediate liquidation possible when reducing an agent’s liquidation threshold",
            "description": "The modifyAgent function allows reducing an agent’s liquidation threshold without checking if the agent is already below the new threshold. This could immediately trigger liquidation of the agent’s position. The root cause is the lack of a safety check before updating the threshold. An admin could unknowingly or maliciously set a threshold that puts an agent into a liquidatable state. The impact is unfair liquidation of agents’ positions, leading to loss of collateral and potential disputes or loss of trust in the system.\n",
            "severity": "Informational",
            "location": [
                "contracts/delegation/Delegation.sol::modifyAgent#227-244",
                "Lender.sol::setLiquidationThreshold"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "The protocol exhibits a critical discrepancy between how an agent's health factor is calculated and how slashable collateral is determined. This inconsistency arises because the health factor evaluation uses all current collateral, including recent deposits, while the slashing mechanism only considers deposits made before the most recent epoch or the agent's last borrow time. The root cause is the misalignment in time bases used by the coverage and slashTimestamp functions. An attacker can exploit this by adding fresh collateral just before a liquidation event to improve their health factor, knowing that these new deposits will not be subject to slashing. As a result, during liquidation, the protocol cannot recover sufficient collateral from these recent deposits, leading to a shortfall that the protocol must absorb. This undermines the financial stability and security model of the system, potentially resulting in significant protocol losses, especially if all existing delegations are from the current epoch.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/Delegation.sol#L73-L76",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L195-L206",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 52,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Immediate liquidation possible when reducing an agent's liquidation threshold",
            "description": "Reducing an agent's liquidation threshold can immediately trigger liquidation if the agent's health factor drops below the new threshold. This is an intentional design choice, but it introduces risk because the change takes effect instantly without a grace period. An attacker with control over the threshold parameter could exploit this to liquidate an agent arbitrarily. The impact includes potential loss of collateral and user funds due to abrupt liquidation.\n",
            "severity": "Informational",
            "location": [
                "AgentManager.sol::setLiquidationThreshold"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Invalid network registration in Delegation.registerNetwork can cause DoS",
            "description": "The registerNetwork function in the Delegation contract lacks validation for network addresses and provides no way to remove registered networks. The root cause is insufficient input validation and missing administrative functions for error correction. If an invalid address (e.g., address(0)) or a non-compliant contract is registered, key functions like coverage and slashableCollateral will permanently revert when attempting external calls to the invalid network. This results in a denial of service for the affected agent, locking them out of protocol functionality indefinitely. Since there is no mechanism to unregister networks or remove the agent, the issue cannot be resolved post-deployment, making it a permanent operational failure for the affected user.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L249-L258",
                "Delegation.sol::registerNetwork"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Agent LTV can be configured equal to or higher than liquidation threshold",
            "description": "The addAgent and modifyAgent functions allow setting an agent's loan-to-value (LTV) ratio equal to or higher than its liquidation threshold. The root cause is missing validation that ensures LTV is strictly less than the liquidation threshold. This configuration leads to contradictory economic states: if LTV >= liquidation threshold, an agent could either be immediately liquidatable upon borrowing or never reach liquidation even when undercollateralized. The impact is a breakdown of the risk management system, exposing the protocol to uncontrolled borrowing and potential insolvency. Even if unintended, a simple administrative error could create such a dangerous configuration, undermining the core collateralization safeguards of the protocol.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L202-L209",
                "Lender.sol::setLTV"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        }
    ],
    "affected_files": {
        "Delegation.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport { Access } from \"../access/Access.sol\";\n\nimport { IDelegation } from \"../interfaces/IDelegation.sol\";\nimport { INetworkMiddleware } from \"../interfaces/INetworkMiddleware.sol\";\n\nimport { DelegationStorageUtils } from \"../storage/DelegationStorageUtils.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title Cap Delegation Contract\n/// @author Cap Labs\n/// @notice This contract manages delegation and slashing.\ncontract Delegation is IDelegation, UUPSUpgradeable, Access, DelegationStorageUtils {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract\n    /// @param _accessControl Access control address\n    /// @param _oracle Oracle address\n    /// @param _epochDuration Epoch duration in seconds\n    function initialize(address _accessControl, address _oracle, uint256 _epochDuration) external initializer {\n        __Access_init(_accessControl);\n        __UUPSUpgradeable_init();\n        DelegationStorage storage $ = getDelegationStorage();\n        $.oracle = _oracle;\n        $.epochDuration = _epochDuration;\n        $.ltvBuffer = 0.05e27; // 5%\n    }\n\n    /// @notice Get the epoch duration\n    /// @return duration Epoch duration in seconds\n    function epochDuration() external view returns (uint256 duration) {\n        DelegationStorage storage $ = getDelegationStorage();\n        duration = $.epochDuration;\n    }\n\n    /// @notice Get the current epoch\n    /// @return currentEpoch Current epoch\n    function epoch() public view returns (uint256 currentEpoch) {\n        DelegationStorage storage $ = getDelegationStorage();\n        currentEpoch = block.timestamp / $.epochDuration;\n    }\n\n    /// @notice Get the ltv buffer\n    /// @return buffer LTV buffer\n    function ltvBuffer() external view returns (uint256 buffer) {\n        buffer = getDelegationStorage().ltvBuffer;\n    }\n\n    /// @notice Get the timestamp that is most recent between the last borrow and the epoch -1\n    /// @param _agent The agent address\n    /// @return _slashTimestamp Timestamp that is most recent between the last borrow and the epoch -1\n    function slashTimestamp(address _agent) public view returns (uint48 _slashTimestamp) {\n        DelegationStorage storage $ = getDelegationStorage();\n        _slashTimestamp = uint48(Math.max((epoch() - 1) * $.epochDuration, $.agentData[_agent].lastBorrow));\n    }\n\n    /// @notice How much delegation and agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return delegation Amount in USD (8 decimals) that a agent has provided as delegation from the delegators\n    function coverage(address _agent) public view returns (uint256 delegation) {\n        DelegationStorage storage $ = getDelegationStorage();\n        delegation = INetworkMiddleware($.agentData[_agent].network).coverage(_agent);\n    }\n\n    /// @notice How much slashable coverage an agent has available to back their borrows\n    /// @param _agent The agent address\n    /// @return _slashableCollateral Amount in USD (8 decimals) that a agent has provided as slashable collateral from the delegators\n    function slashableCollateral(address _agent) public view returns (uint256 _slashableCollateral) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n        _slashableCollateral =\n            INetworkMiddleware($.agentData[_agent].network).slashableCollateral(_agent, _slashTimestamp);\n    }\n\n    /// @notice Fetch active network address\n    /// @param _agent Agent address\n    /// @return networkAddress network address\n    function networks(address _agent) external view returns (address networkAddress) {\n        networkAddress = getDelegationStorage().agentData[_agent].network;\n    }\n\n    /// @notice Fetch active agent addresses\n    /// @return agentAddresses Agent addresses\n    function agents() external view returns (address[] memory agentAddresses) {\n        agentAddresses = getDelegationStorage().agents.values();\n    }\n\n    /// @notice The LTV of a specific agent\n    /// @param _agent Agent who we are querying\n    /// @return currentLtv Loan to value ratio of the agent\n    function ltv(address _agent) external view returns (uint256 currentLtv) {\n        currentLtv = getDelegationStorage().agentData[_agent].ltv;\n    }\n\n    /// @notice Liquidation threshold of the agent\n    /// @param _agent Agent who we are querying\n    /// @return lt Liquidation threshold of the agent\n    function liquidationThreshold(address _agent) external view returns (uint256 lt) {\n        lt = getDelegationStorage().agentData[_agent].liquidationThreshold;\n    }\n\n    /// @notice The slash function. Calls the underlying networks to slash the delegated capital\n    /// @dev Called only by the lender during liquidation\n    /// @param _agent The agent who is unhealthy\n    /// @param _liquidator The liquidator who receives the funds\n    /// @param _amount The USD value of the delegation needed to cover the debt\n    function slash(address _agent, address _liquidator, uint256 _amount) external checkAccess(this.slash.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint48 _slashTimestamp = slashTimestamp(_agent);\n\n        address network = $.agentData[_agent].network;\n        uint256 networkSlashableCollateral = INetworkMiddleware(network).slashableCollateral(_agent, _slashTimestamp);\n        if (networkSlashableCollateral == 0) revert NoSlashableCollateral();\n        uint256 slashShare = _amount * 1e18 / networkSlashableCollateral;\n        if (slashShare > 1e18) slashShare = 1e18;\n\n        INetworkMiddleware(network).slash(_agent, _liquidator, slashShare, _slashTimestamp);\n        emit SlashNetwork(network, _amount);\n    }\n\n    /// @notice Distribute rewards to networks covering an agent proportionally to their coverage\n    /// @param _agent The agent address\n    /// @param _asset The reward token address\n    function distributeRewards(address _agent, address _asset) external {\n        DelegationStorage storage $ = getDelegationStorage();\n        uint256 _amount = IERC20(_asset).balanceOf(address(this));\n\n        uint256 totalCoverage = coverage(_agent);\n        // here we cannot revert because the agent might not have any coverage\n        // in case we are liquidating the current agent due to 0 coverage\n        if (totalCoverage == 0) return;\n\n        address network = $.agentData[_agent].network;\n        IERC20(_asset).safeTransfer(network, _amount);\n        INetworkMiddleware(network).distributeRewards(_agent, _asset);\n\n        emit DistributeReward(_agent, _asset, _amount);\n    }\n\n    /// @notice Set the last borrow timestamp for an agent\n    /// @param _agent Agent address\n    function setLastBorrow(address _agent) external checkAccess(this.setLastBorrow.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        $.agentData[_agent].lastBorrow = block.timestamp;\n    }\n\n    /// @notice Add agent to be delegated to\n    /// @param _agent Agent address\n    /// @param _network Network address\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function addAgent(address _agent, address _network, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.addAgent.selector)\n    {\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // if ltv is greater than 100% then agent could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv != 0 && _liquidationThreshold < _ltv + $.ltvBuffer) revert LiquidationThresholdTooCloseToLtv();\n\n        // If the agent already exists, we revert\n        if ($.agents.contains(_agent)) revert DuplicateAgent();\n        if (!$.networks.contains(_network)) revert NetworkDoesntExist();\n\n        $.agents.add(_agent);\n        $.agentData[_agent].network = _network;\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        emit AddAgent(_agent, _network, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Modify an agents config only callable by the operator\n    /// @param _agent the agent to modify\n    /// @param _ltv Loan to value ratio\n    /// @param _liquidationThreshold Liquidation threshold\n    function modifyAgent(address _agent, uint256 _ltv, uint256 _liquidationThreshold)\n        external\n        checkAccess(this.modifyAgent.selector)\n    {\n        DelegationStorage storage $ = getDelegationStorage();\n\n        // if ltv is greater than 100% then agent could borrow more than they are collateralized for\n        if (_liquidationThreshold > 1e27) revert InvalidLiquidationThreshold();\n        if (_ltv != 0 && _liquidationThreshold < _ltv + $.ltvBuffer) revert LiquidationThresholdTooCloseToLtv();\n\n        // Check that the agent exists\n        if (!$.agents.contains(_agent)) revert AgentDoesNotExist();\n\n        $.agentData[_agent].ltv = _ltv;\n        $.agentData[_agent].liquidationThreshold = _liquidationThreshold;\n        emit ModifyAgent(_agent, _ltv, _liquidationThreshold);\n    }\n\n    /// @notice Register a new network\n    /// @param _network Network address\n    function registerNetwork(address _network) external checkAccess(this.registerNetwork.selector) {\n        DelegationStorage storage $ = getDelegationStorage();\n        if (_network == address(0)) revert InvalidNetwork();\n\n        // Check for duplicates\n        if ($.networks.contains(_network)) revert DuplicateNetwork();\n\n        $.networks.add(_network);\n        emit RegisterNetwork(_network);\n    }\n\n    /// @notice Check if a network is registered\n    /// @param _network Network address\n    /// @return _exists Whether the network is registered\n    function networkExists(address _network) external view returns (bool) {\n        return getDelegationStorage().networks.contains(_network);\n    }\n\n    /// @notice Set the ltv buffer\n    /// @param _ltvBuffer LTV buffer\n    function setLtvBuffer(uint256 _ltvBuffer) external checkAccess(this.setLtvBuffer.selector) {\n        if (_ltvBuffer > 1e27) revert InvalidLtvBuffer();\n        getDelegationStorage().ltvBuffer = _ltvBuffer;\n        emit SetLtvBuffer(_ltvBuffer);\n    }\n\n    /// @dev Only admin can upgrade\n    function _authorizeUpgrade(address) internal override checkAccess(bytes4(0)) { }\n}\n"
    }
}