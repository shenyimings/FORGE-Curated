{
    "vfp_id": "vfp_00264",
    "project_name": "Jovay Rollup Contracts Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Incorrect Use of ERC-20 `amount_` As ETH Value in L2 ERC-20 Bridge `withdraw`",
            "description": "The L2ERC20Bridge contract incorrectly uses the ERC-20 token amount (`amount_`) as the ETH value when sending a cross-domain message via `L2Mailbox.sendMsg`. This function expects the `value` parameter to represent the amount of ETH to forward, which should be zero for ERC-20 token withdrawals. By passing `amount_` instead, the system may interpret the token amount as ETH, leading to incorrect ETH transfers or message execution failures.\n\nThe root cause is a logic error in the `withdraw` function where the wrong variable is passed to the `sendMsg` call. An attacker could potentially exploit this by initiating a withdrawal with a large token amount, causing the system to attempt an unintended ETH transfer, which may fail or lead to inconsistent state.\n\nThis could result in failed message executions on L1, incorrect accounting, or loss of user funds if the L1 bridge attempts to process a non-zero ETH value that was never sent. Even if no actual ETH is transferred, the inconsistency may disrupt message processing and bridge reliability.\n\nThe impact includes potential loss of user funds, failed withdrawals, and reduced trust in the bridge's correctness. Although the issue has been resolved, it highlights a critical flaw in cross-chain message construction.\n",
            "severity": "High",
            "location": [
                "L2ERC20Bridge.sol::withdraw#47",
                "L2Mailbox.sol::sendMsg#43-75"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L2/bridge/L2ERC20Bridge.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Broken Set Token Mapping Flow",
            "description": "The `setTokenMapping` function in the `L2ERC20Bridge` contract is only callable by the contract owner, which prevents the `L2Mailbox` from executing it when receiving a message from L1. Since token mapping updates are sent via cross-chain messages from L1 to L2, and the `L2Mailbox` acts as the caller, the function call fails unless the mailbox is the owner— which is not feasible due to conflicting privilege requirements.\n\nThe root cause is an access control misconfiguration: the function lacks a permission mechanism for the `L2Mailbox` to act as a trusted forwarder. This breaks the synchronization of token mappings between L1 and L2, leaving the system unable to process new ERC-20 token deposits.\n\nAn attacker could not directly exploit this, but malicious or negligent behavior by the owner (e.g., failing to manually set mappings) would prevent users from depositing unsupported tokens. More critically, even honest operation fails because the automated flow is broken.\n\nThe impact is that new ERC-20 tokens cannot be bridged until mappings are manually fixed, potentially locking user funds and disrupting onboarding of new assets. This undermines the autonomy and reliability of the bridge system.\n",
            "severity": "High",
            "location": [
                "L1ERC20Bridge.sol::setTokenMapping#21-29",
                "L2ERC20Bridge.sol::setTokenMapping#16-18",
                "L2Mailbox.sol::relayMsg#85-108"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ERC20Bridge.sol",
                "jovay-contracts/rollup_contracts/contracts/L2/bridge/L2ERC20Bridge.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "Inconsistent Handling of `l2MsgRoot` Across Proofs",
            "description": "The `Rollup.verifyBatch` function enforces consistency of the `postStateRoot` across multiple proof types (e.g., TEE and ZK proofs) by storing and comparing values. However, it does not perform the same check for the `l2MsgRoot`, allowing the second proof to overwrite the value without validation.\n\nThe root cause is the absence of a cross-proof consistency check for `l2MsgRoot`, relying instead on the assumption that valid proofs will inherently agree on the message root. This weakens the security model, which is designed to tolerate bugs in one proof system by requiring agreement between two independent verifiers.\n\nIf a vulnerability exists in one proof system, an attacker could generate two valid but inconsistent proofs—one with a legitimate `l2MsgRoot` and another with a malicious one—causing the system to accept an incorrect message root. This could allow invalid or forged L2→L1 messages to be processed.\n\nThe impact is a potential compromise of message integrity, leading to unauthorized withdrawals or execution of unapproved cross-chain actions, especially if one proof system is compromised. This undermines the redundancy-based security design.\n",
            "severity": "Medium",
            "location": [
                "Rollup.sol::verifyBatch#187-230",
                "Rollup.sol::_verifyTeeProof#291-297"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Unclear L1 Message Queue Logic",
            "description": "The `L1Mailbox` contract contains ambiguous and inconsistent logic for handling the message queue. The `popMsgs` function has `popFront()` commented out, so messages are never removed from the queue. Meanwhile, `getMsg` relies on `lastestQueueIndex` and `stableRollingHash`, which becomes outdated because it is never updated after messages are processed.\n\nThe root cause is incomplete refactoring: the team changed from a popping model to an index-tracking model but failed to fully update all related functions and remove dead code. The `setLastQueueIndex` function exists for upgrades but is not integrated into normal operation, creating state desynchronization risks.\n\nAn attacker could exploit this by triggering edge cases where `getMsg` returns incorrect rolling hashes, potentially leading to invalid message inclusion in batches or verification failures. Relayers may submit inconsistent data, and upgrades could introduce hard-to-predict behavior.\n\nThe impact includes potential DoS due to verification mismatches, incorrect message processing, and operational fragility during upgrades. While the mainnet deployment avoids some issues due to clean state, the code remains fragile and error-prone.\n",
            "severity": "Medium",
            "location": [
                "L1Mailbox.sol::getMsg#204-215",
                "L1Mailbox.sol::popMsgs#242",
                "L1Mailbox.sol::setLastQueueIndex#220-222"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Missing Manual Finalization Mechanism for ERC-20 Tokens Can Lead to Locked Funds",
            "description": "The `L2Mailbox.relayMsg` function uses a low-level call to execute cross-chain messages and stores the message hash in `receiveMsgMap` to prevent replays. If the call fails (e.g., due to a revert in `finalizeDeposit`), the transaction does not revert, but no recovery mechanism exists for ERC-20 deposits or `setTokenMapping`.\n\nThe root cause is the lack of a user-callable fallback function like `claimDeposit` (which exists for ETH) to retry failed executions. Once the hash is stored, the relayer cannot resubmit the message, and the user has no way to finalize the deposit.\n\nAn attacker could trigger a failure (e.g., by causing a revert in the token contract during minting) to permanently lock deposited funds in the L1 bridge. Even non-malicious failures (e.g., gas limits) would result in lost funds without manual intervention.\n\nThe impact is permanent loss of user funds in the event of a failed execution, undermining trust in the bridge's reliability. While `setTokenMapping` can be re-submitted by the owner, ERC-20 deposits remain vulnerable.\n",
            "severity": "Medium",
            "location": [
                "L2Mailbox.sol::relayMsg#85-108",
                "L2ETHBridge.sol::claimDeposit#53-60",
                "L2ERC20Bridge.sol::finalizeDeposit"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L2/bridge/L2ERC20Bridge.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-1283"
                ]
            },
            "title": "Mutable `layer2ChainId` Can Break Batch Verification and Cause DoS",
            "description": "The `Rollup` contract allows the `layer2ChainId` to be updated via `setL2ChainId` after initialization. However, this value is used in the commitment input for TEE proof verification in `verifyBatch`. If the chain ID is changed after batches are committed but before they are verified, the proof verification will fail due to mismatched commitments.\n\nThe root cause is the mutable nature of a parameter that is part of a cryptographic commitment. Since batch verification must proceed sequentially and each batch depends on the previous state, a single failed verification halts the entire chain.\n\nAn attacker with ownership privileges could change the `layer2ChainId` to intentionally break verification, causing a denial of service. Even accidental changes would freeze the system until a fix is deployed.\n\nThe impact is a complete halt in batch processing, preventing all withdrawals and message finalizations until the issue is resolved, leading to a full system freeze and loss of liveness.\n",
            "severity": "Medium",
            "location": [
                "Rollup.sol::setL2ChainId#361",
                "Rollup.sol::verifyBatch#187-218",
                "Rollup.sol::_verifyTeeProof#291-297"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-408"
                ]
            },
            "title": "Missing Gas Bounds and Fee Accounting in `L2Mailbox`",
            "description": "The `L2Mailbox.sendMsg` function uses the `gasLimit` parameter to calculate fees but does not enforce any minimum or maximum bounds. Users can set `gasLimit` to zero and avoid paying any fee while still generating valid withdrawal messages that relayers must process.\n\nAdditionally, the fee calculation does not account for the size of the `msg_` data, which can be arbitrarily large and increase blob storage costs. There is also no fee tracking mechanism (e.g., a balance variable) or withdrawal function for collected fees, leading to unaccounted funds.\n\nThe root cause is incomplete fee design: while `L1Mailbox` includes fee accounting, `L2Mailbox` was designed to set `baseFee` to zero, effectively disabling fees. However, this creates a gap in economic security, especially if ZK proofs are enabled in the future.\n\nAn attacker could spam the system with zero-fee, high-data messages, forcing relayers to bear the cost of blob submissions and proof verification. This could make operation economically unviable.\n\nThe impact includes potential DoS via spam, unfair cost distribution, and lack of transparency in fee handling. Although currently mitigated by zero fees, the design is fragile and not future-proof.\n",
            "severity": "Medium",
            "location": [
                "L2Mailbox.sol::sendMsg#43-75",
                "L1Mailbox.sol::sendMsg#105-106",
                "L2ETHBridge.sol::withdraw#21"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L2/core/L2Mailbox.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unsafe ETH and Token Handling in the Bridge Contracts",
            "description": "The L1Mailbox contract inherits a receive() function from MailBoxBase, allowing direct ETH transfers to it, which can result in permanently locked funds as users may mistakenly send ETH instead of using the proper deposit function. Similarly, on L2, users can send native tokens directly to L2Mailbox instead of calling withdraw, creating confusion and risk. Additionally, functions like relayMsgWithProof are marked payable despite not requiring ETH, increasing the risk of accidental and useless ETH transfers. The root cause is poor UX design and lack of protective measures against direct fund transfers. An attacker or mistaken user could send ETH directly to the contract, leading to loss of funds. The impact includes user fund loss and reduced trust in the bridge mechanism.\n",
            "severity": "Medium",
            "location": [
                "L1ETHBridge.sol::deposit#16-27",
                "L1Mailbox.sol::receive#96",
                "MailBoxBase.sol::receive#96",
                "L2ETHBridge.sol::withdraw#21-31",
                "L1BridgeProof.sol::relayMsgWithProof#8-15"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L2/core/L2Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ETHBridge.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Unsafe Token Mapping Updates Can Break Bridging",
            "description": "The setTokenMapping function allows updating the L2 token counterpart for an existing L1 token. If a deposit is initiated before a mapping update but finalized after the update, the finalizeDeposit function will validate against the new mapping, causing the deposit to fail and the bridging process to stall. The root cause is the mutable nature of token mappings without safeguards for in-flight deposits. An attacker could potentially exploit timing by triggering a deposit and then influencing a mapping change, or honest users could be affected by legitimate updates. The impact is a denial of service for bridging operations, leading to stuck deposits and user fund lockups on L1.\n",
            "severity": "Medium",
            "location": [
                "L1ERC20Bridge.sol::setTokenMapping#21-29",
                "L2ERC20Bridge.sol::finalizeDeposit#65-66"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ERC20Bridge.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Invalid Gas Limit Configuration Can Disable Deposits",
            "description": "The sendMsg function in L1Mailbox requires the user-provided gasLimit_ to be strictly less than l2GasLimit and greater than or equal to l2FinalizeDepositGasUsed. However, the setter functions allow l2GasLimit and l2FinalizeDepositGasUsed to be set equal, which would make it impossible to satisfy the strict inequality, thereby blocking all deposits. The root cause is insufficient validation in the setter functions, which only ensure l2GasLimit is not strictly less than l2FinalizeDepositGasUsed but allow equality. A malicious or mistaken owner could set these values equal, either intentionally or accidentally. The impact is a complete halt of deposit functionality, resulting in a denial of service for the entire bridge.\n",
            "severity": "Medium",
            "location": [
                "L1Mailbox.sol::sendMsg#105-106",
                "L1Mailbox.sol::setL2GasLimit#173-180",
                "L1Mailbox.sol::setL2FinalizeDepositGasUsed#185-192"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ]
            },
            "title": "Inconsistent Event Structures Between L1Mailbox and L2Mailbox",
            "description": "The SentMsg event in L1Mailbox and L2Mailbox have different argument orders and meanings; specifically, the fifth argument is 'data' in L1Mailbox but 'msg_' in L2Mailbox. Similarly, the AppendMsg event uses different indexing semantics: L1Mailbox emits the next index, while L2Mailbox emits the current index. This inconsistency stems from divergent design choices between the two mailbox contracts. While not directly exploitable for financial gain, this creates confusion for developers, relayers, and integrators who must implement different decoding logic for similar events. The impact includes increased integration complexity, higher risk of bugs in off-chain systems, and potential misinterpretation of message sequencing.\n",
            "severity": "Low",
            "location": [
                "L1Mailbox.sol::SentMsg#116",
                "L2Mailbox.sol::SentMsg#65",
                "L1Mailbox.sol::AppendMsg#230",
                "L2Mailbox.sol::AppendMsg#130"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L2/core/L2Mailbox.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Free-Memory Pointer is Moved to a Non-Word-Aligned Address",
            "description": "In the loadAndValidate function of BatchHeaderCodec.sol, the free memory pointer (0x40) is updated by adding a length of 105 bytes, which is not a multiple of 32, breaking Solidity's requirement for 32-byte alignment. This misalignment can cause subsequent memory allocations to overwrite existing data or lead to out-of-bounds reads, resulting in undefined behavior or transaction reverts. Additionally, store functions in the same library write directly to memory without updating the free memory pointer, which could cause memory corruption if used outside the Rollup contract. The root cause is improper memory management in low-level assembly code. The impact includes potential runtime failures, data corruption, and unpredictable contract behavior, especially if the library is reused in other contexts.\n",
            "severity": "Medium",
            "location": [
                "BatchHeaderCodec.sol::loadAndValidate#47-56",
                "Rollup.sol#161-164"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/libraries/codec/BatchHeaderCodec.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing Zero-Address Checks",
            "description": "Several functions across the codebase fail to validate that address parameters are not the zero address before assigning them to state variables or using them in critical operations. This includes functions in L1Mailbox, Rollup, L2ERC20Bridge, L2ETHBridge, L2CoinBase, and ERC20Token. The root cause is the omission of require(_addr != address(0)) checks. A mistaken or malicious caller could set critical addresses to zero, which may result in loss of control, inability to recover funds, or breaking contract functionality (e.g., sending funds to the burn address). The impact includes permanent loss of access, denial of service, and potential fund loss due to irreversible operations.\n",
            "severity": "Medium",
            "location": [
                "L1Mailbox.sol#147",
                "L1Mailbox.sol#156",
                "L1Mailbox.sol#166",
                "Rollup.sol#107",
                "L2ERC20Bridge.sol#72",
                "L2ETHBridge.sol#45",
                "L2CoinBase.sol#21",
                "L2Mailbox.sol#117",
                "ERC20Token.sol#38"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Inconsistent Handling of Empty Batches",
            "description": "The _getBlobDataHash function in the Rollup contract computes the hash of an empty blob as keccak256(\"\") if the first blob is empty, instead of reverting. While relayers are expected to act honestly, this behavior allows the commitment of empty batches, which is unnecessary and potentially wasteful. The root cause is the lack of a validation check to revert when a batch is empty. A malicious or malfunctioning relayer could submit empty batches, increasing storage costs and bloating the chain without providing value. The impact includes increased gas costs for validators and inefficiencies in the rollup system, though the security risk is low.\n",
            "severity": "Low",
            "location": [
                "Rollup.sol::_getBlobDataHash#253-271",
                "Rollup.sol#151-184"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Setter Truncates 64-bit `rollupTimeLimit` to 32 bits",
            "description": "In `Rollup.sol`, the `rollupTimeLimit` state variable is declared as `uint64`, but the setter function `setRollupTimeLimit` accepts a `uint32` parameter. This causes any value above 4,294,967,295 to be silently truncated, imposing an undocumented 32-bit cap on a 64-bit field. The root cause is a mismatch in parameter and variable size. An attacker or malicious owner could set a high value expecting full 64-bit range, but the truncation would result in a much lower effective limit, potentially disrupting protocol timing assumptions. This could lead to unexpected behavior in time-dependent logic, such as rollup finalization windows. The impact is moderate, primarily affecting configurability and introducing a silent failure mode.\n",
            "severity": "Medium",
            "location": [
                "Rollup.sol::setRollupTimeLimit#355",
                "Rollup.sol::rollupTimeLimit"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect Documentation for ZK Verifier Setter",
            "description": "The parameter description in the function that sets the ZK verifier address in `Rollup.sol` incorrectly states \"The verifier address of tee\", implying a Trusted Execution Environment (TEE) verifier instead of a Zero-Knowledge (ZK) proof verifier. This is a documentation error that could mislead developers, auditors, or integrators into assuming the system uses TEE-based verification instead of ZK proofs. The root cause is inaccurate inline comment or NatSpec. While this does not introduce a direct security vulnerability, it can lead to misunderstandings during integration or security analysis, potentially resulting in incorrect threat modeling or integration errors. The impact is low but affects the clarity and correctness of the codebase.\n",
            "severity": "Low",
            "location": [
                "Rollup.sol#373"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unused State Variables",
            "description": "Multiple state variables in `Rollup.sol` (`maxTxsInChunk`, `maxBlockInChunk`, `maxCallDataInChunk`, `l1BlobNumberLimit`, `rollupTimeLimit`) are declared but not used within the contract logic. Although the team later stated these are used by the relayer, they are not accessed in the contract itself, making them appear as dead code. The root cause is either off-chain reliance or incomplete cleanup. While not directly exploitable, unused state variables increase deployment cost and storage bloat. If these variables are meant to be public constants, they should be declared as such. The impact is low, mainly affecting gas efficiency and code clarity.\n",
            "severity": "Low",
            "location": [
                "Rollup.sol::maxTxsInChunk#20",
                "Rollup.sol::maxBlockInChunk#23",
                "Rollup.sol::maxCallDataInChunk#26",
                "Rollup.sol::l1BlobNumberLimit#32",
                "Rollup.sol::rollupTimeLimit#35"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused Imports",
            "description": "Several Solidity files contain import statements that are never used in the code, such as `IL1BridgeProof.sol` and `ITokenBridge.sol` in bridge interfaces, and `L2Mailbox` in `L2ETHBridge.sol`. The root cause is leftover or unnecessary imports. While this does not pose a security risk, it increases compilation time and reduces code clarity. Unused imports can also create confusion about dependencies and increase the attack surface if future code mistakenly relies on imported but unused contracts. The impact is informational, affecting maintainability and readability.\n",
            "severity": "Low",
            "location": [
                "IL1ERC20Bridge.sol::import#4",
                "IL1ERC20Bridge.sol::import#5",
                "IL1ETHBridge.sol::import#4",
                "L2ETHBridge.sol::import#9"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ETHBridge.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/interfaces/IL1BridgeProof.sol",
                "jovay-contracts/rollup_contracts/contracts/common/interfaces/ITokenBridge.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Multiple Functions With Incorrect Order of Modifiers",
            "description": "Several functions across the codebase violate the Solidity style guide by not ordering modifiers in the recommended sequence: visibility, mutability, virtual, override, custom modifiers. For example, functions in `L1ERC20Bridge.sol` and `L1GasOracle.sol` have modifiers in incorrect order. The root cause is inconsistent coding style. While this does not introduce a security vulnerability, it reduces code readability and may lead to confusion during audits or maintenance. The impact is low, primarily affecting code quality and maintainability.\n",
            "severity": "Low",
            "location": [
                "L1ERC20Bridge.sol::setTokenMapping#21-29",
                "L1ERC20Bridge.sol::deposit#31-46",
                "L1GasOracle.sol::setNewBatchBlobFeeAndTxFee#100-121",
                "L1GasOracle.sol::setBlobBaseFeeScalaAndTxFeeScala#123-130",
                "L1GasOracle.sol::setL1Profit#132-137",
                "L1GasOracle.sol::setTotalScala#139-144",
                "L1GasOracle.sol::setMaxL1ExecGasUsedLimit#146-151",
                "L1GasOracle.sol::setMaxL1BlobGasUsedLimit#153-158",
                "L1GasOracle.sol::addRelayer#160-164",
                "L1GasOracle.sol::removeRelayer#166-170",
                "L2CoinBase.sol::setL2EthBridge#56-59",
                "L2CoinBase.sol::addWithdrawer#61-65",
                "L2CoinBase.sol::removeWithdrawer#67-71",
                "L2CoinBase.sol::addWhiteAddress#73-77",
                "L2CoinBase.sol::removeWhiteAddress#79-83",
                "L2CoinBase.sol::withdraw#85-93",
                "L2CoinBase.sol::withdrawAll#95-97",
                "L2Mailbox.sol::setL1MailBox#38-41",
                "ITokenBridge.sol::setTokenMapping#12"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ERC20Bridge.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant Getter Functions",
            "description": "Public state variables automatically generate getter functions in Solidity, making manually defined getters redundant. In `L1Mailbox.sol`, the `nextMsgIndex` function duplicates the auto-generated getter for `pendingQueueIndex`. Similarly, `getL2MsgRoot` in `Rollup.sol` duplicates the getter for `l2MsgRoots`. The root cause is unnecessary code duplication. While not exploitable, this increases contract size and gas costs. The team noted `getL2MsgRoot` is used externally, so it was retained with documentation. The impact is low, mainly affecting code efficiency and clarity.\n",
            "severity": "Low",
            "location": [
                "L1Mailbox.sol::nextMsgIndex#197-199",
                "Rollup.sol::getL2MsgRoot#249-251"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Missing Named Parameters in Mappings",
            "description": "Mappings in Solidity can include named parameters for better readability (e.g., `mapping(address owner => uint amount)`). However, many mappings in the codebase lack these names, such as `committedBatches` in `Rollup.sol`. The root cause is outdated or incomplete style adherence. While this does not introduce security risks, it reduces code clarity, especially for new developers. The impact is low, affecting maintainability and readability.\n",
            "severity": "Low",
            "location": [
                "Rollup.sol::committedBatches#50",
                "Rollup.sol::finalizedStateRoots#53",
                "Rollup.sol::l2MsgRoots#56",
                "Rollup.sol::l1MsgCount#59",
                "Rollup.sol::isRelayer#66",
                "L1GasOracle.sol::isRelayer#31",
                "L2CoinBase.sol::isWithdrawer#25",
                "L2CoinBase.sol::whiteListOnL1#28",
                "L2Mailbox.sol::receiveMsgStatus#13",
                "MailBoxBase.sol::sendMsgMap#27",
                "MailBoxBase.sol::receiveMsgMap#29",
                "MailBoxBase.sol::isBridge#34",
                "TokenBridge.sol::tokenMapping#8",
                "TokenBridge.sol::balanceOf#10"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ]
            },
            "title": "Missing Security Contact",
            "description": "None of the contracts include a `@custom:security-contact` NatSpec tag, making it difficult for security researchers to report vulnerabilities. The root cause is omission of best practices in responsible disclosure. While this does not directly affect contract security, it increases the risk of unreported vulnerabilities. The impact is low to medium depending on ecosystem expectations, but it is a recommended practice for production systems.\n",
            "severity": "Low",
            "location": [
                "L1ERC20Bridge.sol",
                "L1ETHBridge.sol",
                "L1GasOracle.sol",
                "L1Mailbox.sol",
                "Rollup.sol",
                "L2ERC20Bridge.sol",
                "L2ETHBridge.sol",
                "L2CoinBase.sol",
                "L2Mailbox.sol"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1Mailbox.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ERC20Bridge.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Magic Numbers",
            "description": "The codebase contains multiple literal values (e.g., 1000000, 100, 1e6) without explanation, known as \"magic numbers\". These appear in `L1ERC20Bridge.sol`, `Rollup.sol`, and `L1GasOracle.sol`. The root cause is lack of constant definitions. Magic numbers reduce code readability and make maintenance harder, as their purpose is unclear. While not directly exploitable, they can lead to errors during updates if the same value is used inconsistently. The impact is low, primarily affecting code clarity and maintainability.\n",
            "severity": "Low",
            "location": [
                "L1ERC20Bridge.sol#28",
                "Rollup.sol#238",
                "L1GasOracle.sol#59",
                "L1GasOracle.sol#60",
                "L1GasOracle.sol#61",
                "L1GasOracle.sol#62",
                "L1GasOracle.sol#63",
                "L1GasOracle.sol#74",
                "L1GasOracle.sol#75"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ERC20Bridge.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/core/Rollup.sol",
                "jovay-contracts/rollup_contracts/contracts/L1/core/L1GasOracle.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "_transferERC20 Fails to Support Fee-on-Transfer Tokens Due to Balance Check",
            "description": "The `_transferERC20` function in `L1ERC20Bridge.sol` assumes that the full `_amount` will be transferred to the contract when `safeTransferFrom` is called. However, for fee-on-transfer tokens, the actual received amount is less than `_amount`, while the internal balance is still increased by the full `_amount`.\n\nThe cause of the vulnerability is the incorrect assumption that the transferred amount equals the requested amount, combined with a subsequent `require` statement that checks whether the contract's actual ERC20 balance is at least equal to the tracked balance. Since fee-on-transfer tokens deliver less than requested, this check always fails.\n\nAn attacker cannot directly exploit this for gain, but malicious or legitimate users can trigger a revert when attempting to bridge fee-on-transfer tokens, effectively blocking their use.\n\nThe impact is that the bridge does not support fee-on-transfer tokens, contrary to what a comment in the code suggests. This creates a misleading interface and reduces token compatibility, potentially leading to user frustration or failed transactions.\n",
            "severity": null,
            "location": [
                "L1ERC20Bridge.sol::_transferERC20#59-66"
            ],
            "files": [
                "jovay-contracts/rollup_contracts/contracts/L1/bridge/L1ERC20Bridge.sol"
            ]
        }
    ],
    "affected_files": {
        "L2Mailbox.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {AppendOnlyMerkleTree} from \"../libraries/common/AppendOnlyMerkleTree.sol\";\nimport \"../interfaces/IL2Mailbox.sol\";\nimport \"../interfaces/IL2MailQueue.sol\";\nimport \"../../common/MailBoxBase.sol\";\n\ncontract L2Mailbox is AppendOnlyMerkleTree, MailBoxBase, IL2Mailbox, IL2MailQueue {\n    /// @notice The address of L1MailBox contract.\n    address public l1MailBox;\n\n    mapping(bytes32 => bool) public receiveMsgStatus;\n\n    constructor(){\n        _disableInitializers();\n    }\n\n    /**\n     * Contract initialization\n     * @param l1MailBox_ L1MailBox contract address\n     * @param owner_ Contract owner address\n     * @param baseFee_ Message sender token transfer amount\n     */\n    function initialize(address l1MailBox_, address owner_, uint256 baseFee_) external initializer {\n        if (l1MailBox_ == address(0) || owner_ == address(0)) {\n            revert InvalidInitAddress();\n        }\n        require(_nextMsgIndex == 0, \"msg index is not 0\");\n        __MailBox_init();\n\n        l1MailBox = l1MailBox_;\n        baseFee = baseFee_;\n        _transferOwnership(owner_);\n        _initializeMerkleTree();\n    }\n\n    function setL1MailBox(address l1MailBox_) whenPaused external onlyOwner {\n        require(l1MailBox_ != address(0), \"Invalid address\");\n        l1MailBox = l1MailBox_;\n    }\n\n    function sendMsg(\n        address target_,\n        uint256 value_,\n        bytes calldata msg_,\n        uint256 gasLimit_,\n        address refundAddress_\n    ) external payable override onlyBridge whenNotPaused nonReentrant {\n\n        // compute the actual cross domain message calldata.\n        uint256 nonce_ = _nextMsgIndex;\n        bytes memory data_ = _encodeCall(_msgSender(), target_, value_, nonce_, msg_);\n\n        // Calculate the fee and keep it in the MailBox contract\n        uint256 fee_ = estimateMsgFee(gasLimit_);\n        require(msg.value >= fee_ + value_, \"Insufficient msg.value\");\n\n        bytes32 hash_ = keccak256(data_);\n        // normally this won't happen, since each message has different nonce, but just in case.\n        _sendMsgCheck(hash_);\n        // append message to L2MailQueue\n        _appendMsg(hash_);\n\n        emit SentMsg(_msgSender(), target_, value_, nonce_, msg_, gasLimit_, hash_);\n\n        // refund fee to `refundAddress_`\n        unchecked {\n            uint256 refund_ = msg.value - fee_ - value_;\n            if (refund_ > 0) {\n                (bool success_,) = refundAddress_.call{value : refund_}(\"\");\n                require(success_, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /**\n     * Send L1 message to current L2 through Relayer\n     * @param sender_ sender L1 bridge contract address\n     * @param target_ message receiver current L2 bridge contract address\n     * @param value_ native token transfer amount\n     * @param nonce_ message queue nonce\n     * @param msg_ message content sent to target_ execution\n     */\n    function relayMsg(\n        address sender_,\n        address target_,\n        uint256 value_,\n        uint256 nonce_,\n        bytes calldata msg_\n    ) external override whenNotPaused nonReentrant {\n        // here l1MailBox will be set as L2Relayer 0x5100000000000000000000000000000000000000\n        require(_msgSender() == l1MailBox, \"Caller is not L1Mailbox\");\n\n        bytes32 hash_ = keccak256(_encodeCall(sender_, target_, value_, nonce_, msg_));\n        bytes32 rollinghash = _getRollingHash(hash_);\n        emit RollingHash(rollinghash);\n        _receiveMsgCheck(hash_);\n        (bool success,) = target_.call{value : value_}(msg_);\n        if (success) {\n            _receiveMsgSuccess(hash_);\n            emit FinalizeDepositETHSuccess(hash_, nonce_);\n        } else {\n            _receiveMsgFailed(hash_);\n            emit FinalizeDepositETHFailed(hash_, nonce_);\n        }\n        emit RelayedMsg(hash_, nonce_);\n    }\n\n    function claimAmount(\n        address refundAddress_,\n        uint256 amount_,\n        uint256 nonce_,\n        bytes32 msgHash_\n    ) external override onlyBridge whenNotPaused nonReentrant {\n        _checkMsgClaimValid(msgHash_);\n        (bool success,) = refundAddress_.call{value : amount_}(\"\");\n        require(success, \"claim amount failed when transfer to refund\");\n        _finalizeClaimMsg(msgHash_);\n\n        emit ClaimMsg(msgHash_, nonce_);\n    }\n\n    /**\n     * @dev Appends a message to the queue.\n     */\n    function _appendMsg(bytes32 msgHash) internal override {\n        (uint256 currentNonce,) = _appendMsgHash(msgHash);\n        // We can use the event to compute the merkle tree locally.\n        emit AppendMsg(currentNonce, msgHash);\n    }\n\n    function msgRoot() external view returns (bytes32) {\n        return _msgRoot;\n    }\n\n    function _receiveMsgFailed(bytes32 hash_) internal {\n        receiveMsgStatus[hash_] = false;\n    }\n\n    function _receiveMsgSuccess(bytes32 hash_) internal {\n        receiveMsgStatus[hash_] = true;\n    }\n\n    function _checkMsgClaimValid(bytes32 hash_) internal view {\n        _msgExistCheck(hash_);\n        require(!receiveMsgStatus[hash_], \"ClaimMsg : L2 msg must exec failed before\");\n    }\n\n    function _finalizeClaimMsg(bytes32 hash_) internal {\n        _msgExistCheck(hash_);\n        require(!receiveMsgStatus[hash_], \"ClaimMsg : L2 msg must exec failed before\");\n        receiveMsgStatus[hash_] = true;\n    }\n\n}\n",
        "L1Mailbox.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IL1Mailbox.sol\";\nimport \"../interfaces/IRollup.sol\";\nimport \"../../common/MailBoxBase.sol\";\nimport \"../libraries/verifier/WithdrawTrieVerifier.sol\";\nimport \"../interfaces/IL1MailQueue.sol\";\nimport \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\n\ncontract L1Mailbox is MailBoxBase, IL1Mailbox, IL1MailQueue {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    event SetL2GasLimit(uint256 oldGasLimit, uint256 newGasLimit);\n\n    event SetL2FinalizeDepositGasUsed(uint256 oldL2FinalizeDepositGasUsed, uint256 newL2FinalizeDepositGasUsed);\n\n    // double ended msg queue\n    // begin is next finalize msg\n    // end + 1 is next append msg\n    DoubleEndedQueue.Bytes32Deque private msgQueue;\n\n    bytes32 public stableRollingHash;\n\n    // next pending msg index\n    uint256 public pendingQueueIndex;\n\n    // init with 0;\n    uint256 public nextFinalizeQueueIndex;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The gaslimit of L2, deposit gas limit must less than this value.\n    uint256 public l2GasLimit;\n\n    uint256 public feeBalance;\n\n    address public withdrawer;\n\n    uint256 public l2FinalizeDepositGasUsed;\n\n    uint256 public lastestQueueIndex;\n\n    modifier onlyRollup() {\n        require(msg.sender == rollup, \"Only callable by the Rollup\");\n        _;\n    }\n\n    modifier onlyWithdrawer() {\n        require(msg.sender == withdrawer, \"Only callable by the withdrawer\");\n        _;\n    }\n\n    constructor(){\n        _disableInitializers();\n    }\n\n    /**\n     * Contract initialization\n     * @param rollup_ rollup contract address\n     * @param owner_ contract owner address\n     * @param baseFee_ base fee\n     */\n    function initialize(address rollup_, address owner_, uint256 baseFee_, uint256 _l2GasLimit, uint256 _l2FinalizeDepositGasUsed) external initializer {\n        if (rollup_ == address(0) || owner_ == address(0)) {\n            revert InvalidInitAddress();\n        }\n\n        if (_l2GasLimit < _l2FinalizeDepositGasUsed) {\n            revert InvalidL2GasLimit();\n        }\n        __MailBox_init();\n\n        rollup = rollup_;\n        baseFee = baseFee_;\n        l2GasLimit = _l2GasLimit;\n        l2FinalizeDepositGasUsed = _l2FinalizeDepositGasUsed;\n        _transferOwnership(owner_);\n    }\n\n    function setRollup(address rollup_) external whenPaused onlyOwner {\n        require(rollup_ != address(0), \"Invalid rollup address\");\n        rollup = rollup_;\n    }\n\n    function setWithdrawer(address _withdrawer) external onlyOwner {\n        require(_withdrawer != address(0), \"Invalid withdrawer address\");\n        withdrawer = _withdrawer;\n    }\n\n    function sendMsg(\n        address target_,\n        uint256 value_,\n        bytes calldata msg_,\n        uint256 gasLimit_,\n        address refundAddress_\n    ) external payable override onlyBridge whenNotPaused nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 nonce_ = nextMsgIndex();\n        bytes memory data_ = _encodeCall(_msgSender(), target_, value_, nonce_, msg_);\n\n        // Calculate the fee and leave it in the MailBox contract\n        uint256 fee_ = estimateMsgFee(gasLimit_);\n        require(gasLimit_ < l2GasLimit, \"gasLimit must less than L2 config\");\n        require(gasLimit_ >= l2FinalizeDepositGasUsed, \"gas limit must be bigger than or equal to the tx_fee of finalize deposit on Jovay\");\n        require(msg.value >= fee_ + value_, \"Insufficient msg.value\");\n\n        bytes32 hash_ = keccak256(data_);\n        // normally this won't happen, since each message has different nonce, but just in case.\n        _sendMsgCheck(hash_);\n\n        // append message to L1MailQueue\n        _appendMsg(_getRollingHash(hash_));\n\n        emit SentMsg(_msgSender(), target_, value_, nonce_, data_, gasLimit_, hash_);\n\n        // refund fee to `refundAddress_`\n        unchecked {\n            uint256 refund_ = msg.value - fee_ - value_;\n            if (refund_ > 0) {\n                (bool success_,) = refundAddress_.call{value : refund_}(\"\");\n                require(success_, \"Failed to refund the fee\");\n            }\n        }\n        feeBalance += fee_;\n    }\n\n    /**\n     * Send L2 message to L1, need to verify the validity of the message through proof,\n     * if valid, execute the corresponding message in L1 bridge contract\n     * @param sender_; sender L2 bridge contract address\n     * @param target_; message receiver L1 bridge contract address\n     * @param value_; native token transfer amount\n     * @param nonce_; message nonce value\n     * @param msg_; message content sent to target_ execution\n     * @param proof_; proof information used to prove the validity of the message\n     */\n    function relayMsgWithProof(\n        address sender_,\n        address target_,\n        uint256 value_,\n        uint256 nonce_,\n        bytes memory msg_,\n        L2MsgProof memory proof_\n    ) external payable whenNotPaused nonReentrant {\n        require(sender_ == IBridge(target_).toBridge(), \"Invalid sender\");\n        bytes32 hash_ = keccak256(_encodeCall(sender_, target_, value_, nonce_, msg_));\n\n        bytes32 msgRoot_ = IRollup(rollup).getL2MsgRoot(proof_.batchIndex);\n        require(\n            WithdrawTrieVerifier.verifyMerkleProof(msgRoot_, hash_, nonce_, proof_.merkleProof),\n            \"Invalid proof\"\n        );\n\n        (bool success,) = target_.call{value : value_}(msg_);\n        require(success, \"RelayMsg Failed\");\n        _receiveMsgCheck(hash_);\n        emit RelayedMsg(hash_, nonce_);\n    }\n\n    function withdrawDepositFee(address _target, uint256 _amount) external onlyWithdrawer whenNotPaused {\n        require(_target.code.length == 0, \"INVALID_PARAMETER: withdraw target must be eoa\");\n        require(_amount <= feeBalance, \"INVALID_PARAMETER : withdraw amount must smaller than or equal to fee in mailbox\");\n        feeBalance -= _amount;\n        (bool success,) = _target.call{value : _amount}(\"\");\n        require(success, \"INTERNAL_ERROR : withdraw fee Failed\");\n    }\n\n    /**\n     * @notice Set new L2 Gas limit for deposit\n     */\n    function setL2GasLimit(uint256 _l2GasLimit) external onlyOwner {\n        if (l2FinalizeDepositGasUsed > _l2GasLimit) {\n            revert SetL2GasLimitSmallerThanGasUsed();\n        }\n        uint256 oldL2GasLimit = l2GasLimit;\n        l2GasLimit = _l2GasLimit;\n        emit SetL2GasLimit(oldL2GasLimit, _l2GasLimit);\n    }\n\n    /**\n     * @notice Set new L2 Gas used for finalize deposit\n     */\n    function setL2FinalizeDepositGasUsed(uint256 _l2FinalizeDepositGasUsed) external onlyOwner {\n        if (_l2FinalizeDepositGasUsed > l2GasLimit) {\n            revert SetL2FinalizeDepositGasUsedBiggerThanGasLimit();\n        }\n        uint256 oldL2FinalizeDepositGasUsed = l2FinalizeDepositGasUsed;\n        l2FinalizeDepositGasUsed = _l2FinalizeDepositGasUsed;\n        emit SetL2FinalizeDepositGasUsed(oldL2FinalizeDepositGasUsed, _l2FinalizeDepositGasUsed);\n    }\n\n    /**\n     * @notice Returns next message index\n     */\n    function nextMsgIndex() public view override returns (uint256) {\n        return pendingQueueIndex;\n    }\n\n    /**\n     * @notice Returns message at index\n     */\n    function getMsg(uint256 _l1MsgCount) external view override returns (bytes32) {\n        if (_l1MsgCount == 0) {\n            return bytes32(0);\n        }\n        // totalIndex - 1 == index; index >= nextFinalizeQueueIndex or index = nextFinalizeQueueIndex - 1;\n        require(_l1MsgCount >= lastestQueueIndex, \"used msg must bigger than lastestQueueIndex\");\n        require(_l1MsgCount - 1 < pendingQueueIndex, \"used msg must smaller than next pending\");\n        if (_l1MsgCount < lastestQueueIndex + 1) {\n            return stableRollingHash;\n        }\n        return msgQueue.at(_l1MsgCount - lastestQueueIndex - 1);\n    }\n\n    /**\n      * @notice set lastest queue index  called when pause\n     */\n    function setLastQueueIndex() external whenPaused onlyOwner {\n        lastestQueueIndex = nextFinalizeQueueIndex;\n    }\n\n    /**\n     * @notice Appends message to queue\n     */\n    function _appendMsg(bytes32 msg_) internal override {\n        msgQueue.pushBack(msg_);\n        pendingQueueIndex++;\n        emit AppendMsg(pendingQueueIndex, msg_);\n    }\n\n    /**\n     * @notice Pops messages from queue\n     */\n    function popMsgs(uint256 _l1MsgCount) external onlyRollup whenNotPaused {\n        // l1MsgCount - 1 = index < pendingQueueIndex\n        require(_l1MsgCount < pendingQueueIndex + 1, \"finalize index must smaller than pendingQueueIndex\");\n        require(_l1MsgCount >= nextFinalizeQueueIndex, \"finalize index must smaller than or equal to l1MsgCount\");\n        nextFinalizeQueueIndex = _l1MsgCount;\n//        while (nextFinalizeQueueIndex < _l1MsgCount) {\n//            stableRollingHash = msgQueue.popFront();\n//            nextFinalizeQueueIndex++;\n//        }\n        emit PopMsgs(nextFinalizeQueueIndex);\n    }\n\n}\n",
        "L1ERC20Bridge.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IL1ERC20Bridge.sol\";\nimport \"../interfaces/IL1Mailbox.sol\";\nimport \"../../L2/bridge/interfaces/IL2ERC20Bridge.sol\";\nimport \"../../common/TokenBridge.sol\";\nimport {L1BridgeProof} from \"src/L1/bridge/L1BridgeProof.sol\";\n\ncontract L1ERC20Bridge is TokenBridge, L1BridgeProof, IL1ERC20Bridge {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * Set token mapping relationship\n     * @param token_ this chain asset contract address\n     * @param tokenTo_ Target chain asset contract address\n     */\n    function setTokenMapping(address token_, address tokenTo_) public override payable onlyOwner whenNotPaused {\n        require(token_ != address(0) && tokenTo_ != address(0), \"token address cannot be 0\");\n\n        super.setTokenMapping(token_, tokenTo_);\n\n        // update corresponding mapping in L2, 1000000 gas limit should be enough\n        bytes memory message_ = abi.encodeCall(ITokenBridge.setTokenMapping, (tokenTo_, token_));\n        mailBoxCall(abi.encodeCall(IMailBoxBase.sendMsg, (toBridge, 0, message_, 1000000, _msgSender())));\n    }\n\n    function deposit(address token_, address to_, uint256 amount_, uint256 gasLimit_, bytes memory msg_) external override payable nonReentrant whenNotPaused {\n        address l2Token_ = tokenMapping[token_];\n        require(l2Token_ != address(0), \"deposit erc20 token not exist\");\n\n        // 1. Transfer token into this contract.\n        address sender_ = _msgSender();\n        _transferERC20(token_, amount_);\n\n        // 2. Generate message passed to L2CustomERC20Gateway.\n        bytes memory message_ = abi.encodeCall(IL2ERC20Bridge.finalizeDeposit, (token_, l2Token_, sender_, to_, amount_, msg_));\n\n        // 3. Send message to L1Mailbox.\n        mailBoxCall(abi.encodeCall(IMailBoxBase.sendMsg, (toBridge, 0, message_, gasLimit_, sender_)));\n\n        emit DepositERC20(token_, l2Token_, sender_, to_, amount_, msg_);\n    }\n\n    function finalizeWithdraw(address l1Token_, address l2Token_, address sender_, address to_, uint256 amount_, bytes memory msg_) external payable override nonReentrant onlyMailBox whenNotPaused {\n        require(l2Token_ == tokenMapping[l1Token_], \"l2 token not exist\");\n        IERC20Upgradeable(l1Token_).safeTransfer(to_, amount_);\n        _decreaseBalance(l1Token_, amount_);\n        // TODO : add call msg with withdraw\n//        _doCallback(to_, msg_);\n        require(IERC20Upgradeable(l1Token_).balanceOf(address(this)) >= balanceOf[l1Token_], \"totalSupply mismatch\");\n\n        emit FinalizeWithdrawERC20(l1Token_, l2Token_, sender_, to_, amount_, msg_);\n    }\n\n    function _transferERC20(address token_, uint256 amount_) internal {\n        require(amount_ > 0, \"deposit zero amount\");\n        address sender_ = _msgSender();\n        // common practice to handle fee on transfer token.\n        IERC20Upgradeable(token_).safeTransferFrom(sender_, address(this), amount_);\n        _increaseBalance(token_, amount_);\n        require(IERC20Upgradeable(token_).balanceOf(address(this)) >= balanceOf[token_], \"balance not match\");\n    }\n}\n",
        "L1ETHBridge.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./interfaces/IL1ETHBridge.sol\";\nimport \"../interfaces/IL1Mailbox.sol\";\nimport \"../../L2/bridge/interfaces/IL2ETHBridge.sol\";\nimport \"./L1BridgeProof.sol\";\n\ncontract L1ETHBridge is L1BridgeProof, IL1ETHBridge {\n    using AddressUpgradeable for address;\n    uint256 public balance;\n\n    function deposit(address to_, uint256 amount_, uint256 gasLimit_, bytes memory msg_) external payable override nonReentrant whenNotPaused {\n        require(amount_ > 0, \"deposit zero eth\");\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address sender_ = _msgSender();\n\n        // 2. Generate message passed to L1Mailbox.\n        bytes memory message_ = abi.encodeCall(IL2ETHBridge.finalizeDeposit, (sender_, to_, amount_, msg_));\n        balance += amount_;\n        mailBoxCall(abi.encodeCall(IMailBoxBase.sendMsg, (toBridge, amount_, message_, gasLimit_, sender_)));\n\n        emit DepositETH(sender_, to_, amount_, msg_);\n    }\n\n    function finalizeWithdraw(address sender_, address to_, uint256 amount_, bytes memory msg_) external payable override nonReentrant onlyMailBox whenNotPaused {\n        require(msg.value == amount_, \"msg.value mismatch\");\n        require(balance >= amount_, \"balance too low\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        balance -= amount_;\n        (bool success_, ) = to_.call{value: amount_}(\"\");\n        require(success_, \"ETH transfer failed\");\n// TODO : add call msg with withdraw\n//        _doCallback(to_, msg_);\n\n        emit FinalizeWithdrawETH(sender_, to_, amount_, msg_);\n    }\n}\n",
        "IL1BridgeProof.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IL1Mailbox} from \"../../interfaces/IL1Mailbox.sol\";\n\ninterface IL1BridgeProof {\n    function relayMsgWithProof(\n        uint256 value_,\n        uint256 nonce_,\n        bytes memory msg_,\n        IL1Mailbox.L2MsgProof memory proof_\n    ) external payable;\n}\n",
        "L2ERC20Bridge.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IL2ERC20Bridge.sol\";\nimport \"../interfaces/IL2Mailbox.sol\";\nimport \"../../common/TokenBridge.sol\";\nimport \"../../common/interfaces/IERC20Token.sol\";\nimport \"../../L1/bridge/interfaces/IL1ERC20Bridge.sol\";\n\ncontract L2ERC20Bridge is TokenBridge, IL2ERC20Bridge {\n    /**\n     * Set token mapping relationship\n     * @param token_ Current chain asset contract address\n     * @param tokenTo_ Target asset contract address\n     */\n    function setTokenMapping(address token_, address tokenTo_) public payable override onlyOwner whenNotPaused {\n        super.setTokenMapping(token_, tokenTo_);\n    }\n\n    /**\n     * The bridge contract calls the asset contract to burn the asset and sends a message to the mailbox contract to build a message tree\n     * @param token_ erc20 contract address\n     * @param to_ target address\n     * @param amount_ transfer amount\n     * @param gasLimit_ gas limit\n     * @param msg_ data\n     */\n    function withdraw(address token_, address to_, uint256 amount_, uint256 gasLimit_, bytes memory msg_) external payable override nonReentrant whenNotPaused {\n        address l1Token_ = tokenMapping[token_];\n        require(l1Token_ != address(0), \"withdraw erc20 token not exist\");\n\n        require(amount_ > 0, \"withdraw zero amount\");\n\n        // 1. Extract real sender if this call is from L2GatewayRouter.\n        address sender_ = _msgSender();\n\n        // 2. Burn token.\n        IERC20Token(token_).burn(sender_, amount_);\n\n        // 3. Generate message passed to IL1ERC20Bridge.\n        bytes memory message_ = abi.encodeCall(\n            IL1ERC20Bridge.finalizeWithdraw,\n            (l1Token_, token_, sender_, to_, amount_, msg_)\n        );\n\n        // 4. send message to L2Mailbox\n        mailBoxCall(abi.encodeCall(IMailBoxBase.sendMsg, (toBridge, amount_, message_, gasLimit_, sender_)));\n\n        emit WithdrawERC20(l1Token_, token_, sender_, to_, amount_, message_);\n        _decreaseBalance(token_, amount_);\n        require(IERC20Token(token_).totalSupply() == balanceOf[token_], \"totalSupply mismatch\");\n    }\n\n    /**\n     * Complete the transfer of L1 assets\n     * @param l1Token_ L1 chain asset contract address\n     * @param l2Token_ L2 chain asset contract address\n     * @param sender_ transfer initiator\n     * @param to_ target address\n     * @param amount_ transfer amount\n     * @param msg_ data\n     */\n    function finalizeDeposit(address l1Token_, address l2Token_, address sender_, address to_, uint256 amount_, bytes calldata msg_) external payable override nonReentrant onlyMailBox whenNotPaused {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(l1Token_ != address(0), \"token address cannot be 0\");\n        require(l1Token_ == tokenMapping[l2Token_], \"l1 token mismatch\");\n\n        IERC20Token(l2Token_).mint(to_, amount_);\n        _increaseBalance(l2Token_, amount_);\n        // TODO : add call msg with deposit\n//        _doCallback(to_, msg_);\n        require(IERC20Token(l2Token_).totalSupply() == balanceOf[l2Token_], \"totalSupply mismatch\");\n\n        emit FinalizeDepositERC20(l1Token_, l2Token_, sender_, to_, amount_, msg_);\n    }\n}\n",
        "BatchHeaderCodec.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\n// solhint-disable no-inline-assembly\n/// @dev Below is the encoding for `Chunk`, total 40*n+1+m bytes.\n/// ```text\n///   * Field           Bytes       Type            Index       Comments\n///   * numBlocks       1           uint8           0           The number of blocks in this chunk\n///   * block[0]        40          BlockContext    1           The first block in this chunk\n///   * ......\n///   * block[i]        40          BlockContext    40*i+1      The (i+1)'th block in this chunk\n///   * ......\n///   * block[n-1]      40          BlockContext    40*n-39     The last block in this chunk\n///   * l2Transactions  dynamic     bytes           40*n+1      l2txRlpdatalength|l2txRlpdata|l2txRlpdatalength|l2txRlpdata| ...\n/// ```\n///\n/// @dev Below is the encoding for `BlockContext`, total 40 bytes.\n/// ```text\n///   * Field                   Bytes      Type         Index  Comments\n///   * spec_version            4          uint32       0      The spec_version of this block.\n///   * blockNumber             8          uint64       4      The height of this block.\n///   * timestamp               8          uint64       12     The timestamp of this block.\n///   * baseFee                 8          uint64       20     The base fee of this block. Currently, it is always 0, because we disable EIP-1559.\n///   * gasLimit                8          uint64       28     The gas limit of this block.\n///   * numTransactions         2          uint16       36     The number of transactions in this block, both L1 & L2 txs.\n///   * numL1Messages           2          uint16       38     The number of l1 messages in this block.\n/// ```\n\n/// @dev Below is the encoding for `BatchHeader` V0, total 89 + ceil(l1MessagePopped / 256) * 32 bytes.\n/// ```text\n///   * Field                   Bytes       Type        Index   Comments\n///   * version                 1           uint8       0       The batch version\n///   * batchIndex              8           uint64      1       The index of the batch\n///   * L1MsgRollingHash        32          bytes32     9       Number of total L1 message popped after the batch\n///   * dataHash                32          bytes32     41      The data hash of the batch\n///   * parentBatchHash         32          bytes32     73      The parent batch hash\n/// ```\nlibrary BatchHeaderCodec {\n    /// @dev The length of fixed parts of the batch header.\n    uint256 internal constant BATCH_HEADER_FIXED_LENGTH = 105;\n\n    /// @notice Load batch header in calldata to memory.\n    /// @param _batchHeader The encoded batch header bytes in calldata.\n    /// @return batchPtr The start memory offset of the batch header in memory.\n    /// @return length The length in bytes of the batch header.\n    function loadAndValidate(bytes calldata _batchHeader) internal pure returns (uint256 batchPtr, uint256 length) {\n        length = _batchHeader.length;\n        require(length == BATCH_HEADER_FIXED_LENGTH, \"INVALID_PARAMETER : batchHeader is invalid\");\n\n        // copy batch header to memory.\n        assembly {\n            batchPtr := mload(0x40)\n            calldatacopy(batchPtr, _batchHeader.offset, length)\n            mstore(0x40, add(batchPtr, length))\n        }\n    }\n\n    /// @notice Get the version of the batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _version The version of the batch header.\n    function version(uint256 batchPtr) internal pure returns (uint256 _version) {\n        assembly {\n            _version := shr(248, mload(batchPtr))\n        }\n    }\n\n        /// @notice Get the batch index of the batch.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _batchIndex The batch index of the batch.\n    function batchIndex(uint256 batchPtr) internal pure returns (uint256 _batchIndex) {\n        assembly {\n            _batchIndex := shr(192, mload(add(batchPtr, 1)))\n        }\n    }\n\n    /// @notice Get the number of L1 messages popped before this batch.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _l1RollingHash The the number of L1 messages popped before this batch.\n    function l1RollingHash(uint256 batchPtr) internal pure returns (bytes32 _l1RollingHash) {\n        assembly {\n            _l1RollingHash := mload(add(batchPtr, 9))\n        }\n    }\n\n    /// @notice Get the data hash of the batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _dataHash The data hash of the batch header.\n    function dataHash(uint256 batchPtr) internal pure returns (bytes32 _dataHash) {\n        assembly {\n            _dataHash := mload(add(batchPtr, 41))\n        }\n    }\n\n    /// @notice Get the parent batch hash of the batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @return _parentBatchHash The parent batch hash of the batch header.\n    function parentBatchHash(uint256 batchPtr) internal pure returns (bytes32 _parentBatchHash) {\n        assembly {\n            _parentBatchHash := mload(add(batchPtr, 73))\n        }\n    }\n\n    /// @notice Store the version of batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _version The version of batch header.\n    function storeVersion(uint256 batchPtr, uint256 _version) internal pure {\n        assembly {\n            mstore8(batchPtr, _version)\n        }\n    }\n\n    /// @notice Store the batch index of batch header.\n    /// @dev Because this function can overwrite the subsequent fields, it must be called before\n    /// `storeL1MessagePopped`, `storeTotalL1MessagePopped`, and `storeDataHash`.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _batchIndex The batch index.\n    function storeBatchIndex(uint256 batchPtr, uint256 _batchIndex) internal pure {\n        assembly {\n            mstore(add(batchPtr, 1), shl(192, _batchIndex))\n        }\n    }\n\n    /// @notice Store the total number of L1 messages popped after current batch to batch header.\n    /// @dev Because this function can overwrite the subsequent fields, it must be called before\n    /// `storeDataHash`.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _l1RollingHash The total number of L1 messages popped after current batch.\n    function storeL1RollingHash(uint256 batchPtr, bytes32 _l1RollingHash) internal pure {\n        assembly {\n            mstore(add(batchPtr, 9), _l1RollingHash)\n        }\n    }\n\n    /// @notice Store the data hash of batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _dataHash The data hash.\n    function storeDataHash(uint256 batchPtr, bytes32 _dataHash) internal pure {\n        assembly {\n            mstore(add(batchPtr, 41), _dataHash)\n        }\n    }\n\n    /// @notice Store the parent batch hash of batch header.\n    /// @param batchPtr The start memory offset of the batch header in memory.\n    /// @param _parentBatchHash The parent batch hash.\n    function storeParentBatchHash(uint256 batchPtr, bytes32 _parentBatchHash) internal pure {\n        assembly {\n            mstore(add(batchPtr, 73), _parentBatchHash)\n        }\n    }\n\n    /// @notice Compute the batch hash.\n    /// @dev Caller should make sure that the encoded batch header is correct.\n    ///\n    /// @param batchPtr The memory offset of the encoded batch header.\n    /// @param length The length of the batch.\n    /// @return _batchHash The hash of the corresponding batch.\n    function computeBatchHash(uint256 batchPtr, uint256 length) internal pure returns (bytes32 _batchHash) {\n        // in the current version, the hash is: keccak(BatchHeader without timestamp)\n        assembly {\n            _batchHash := keccak256(batchPtr, length)\n        }\n    }\n}\n",
        "ITokenBridge.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ITokenBridge {\n    event TokenMappingChanged(address indexed token, address indexed tokenTo);\n\n    /**\n     * set token mapping\n     * @param token_; this chain token address\n     * @param tokenTo_; target chain token address\n     */\n    function setTokenMapping(address token_, address tokenTo_) payable external;\n}\n",
        "Rollup.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IRollup.sol\";\nimport \"../libraries/codec/BatchHeaderCodec.sol\";\nimport \"../libraries/verifier/ITeeRollupVerifier.sol\";\nimport \"../libraries/verifier/IZkRollupVerifier.sol\";\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IL1MailQueue} from \"../interfaces/IL1MailQueue.sol\";\n\n\ncontract Rollup is IRollup, OwnableUpgradeable, PausableUpgradeable {\n\n    error NotSupportZkProof();\n\n    /// @notice The max number of txs in a chunk, fill by bytes32(0) if not enough.\n    uint32 public maxTxsInChunk;\n\n    /// @notice The max number of blocks in a chunk, not need fill by (0) if not enough.\n    uint32 public maxBlockInChunk;\n\n    /// @notice The max tx data size in a chunk;\n    uint32 public maxCallDataInChunk;\n\n    /// @notice The max zk circle in a chunk;\n    uint32 public maxZkCircleInChunk;\n\n    /// @notice The max tx data (byte) limit in L1;\n    uint32 public l1BlobNumberLimit;\n\n    /// @notice Time limit between two rollups;\n    uint64 public rollupTimeLimit;\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public layer2ChainId;\n\n    // The batch index that has been committed;\n    uint256 public lastCommittedBatch;\n\n    // The batch index that has been zk verified;\n    uint256 public lastZkVerifiedBatch;\n\n    // The batch index that has been tee verified;\n    uint256 public lastTeeVerifiedBatch;\n\n    // Record the batchhash corresponding to the batch\n    mapping(uint256 => bytes32) public committedBatches;\n\n    // Record the stateroot corresponding to each batch of L2 and the stateroot of the last block of the batch\n    mapping(uint256 => bytes32) public finalizedStateRoots;\n\n    // batchindex corresponds to the root of the L2withroot message tree; it is used to verify L2 transactions;\n    mapping(uint256 => bytes32) public l2MsgRoots;\n\n    // total pop l1msg of batch;\n    mapping(uint256 => uint256) public l1MsgCount;\n\n    address public zk_verifier;  // zk_verifier contract address, compatibility operations such as upgrades are handled by the verifier contract\n    address public tee_verifier;  // tee_verifier contract address, compatibility operations such as upgrades are handled by the verifier contract\n    address public l1_mail_box;   // mail box address; L1 Msg Rolling hash storage in it\n\n    /// @notice Whether an account is a relayer.\n    mapping(address => bool) public isRelayer;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlyRelayer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isRelayer[_msgSender()], \"INVALID_PERMISSION : sender is not relayer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n//    /// @notice Constructor implementation .\n    constructor(\n    ) {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint64 _chainId,\n        address _zk_verifier,\n        address _tee_verifier,\n        address _l1_mail_box,\n        uint32 _maxTxsInChunk,\n        uint32 _maxBlockInChunk,\n        uint32 _maxCallDataInChunk,\n        uint32 _maxZkCircleInChunk,\n        uint32 _l1BlobNumberLimit,\n        uint32 _rollupTimeLimit\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n\n        require(_zk_verifier != address(0) || _tee_verifier != address(0), \"INVALID_PARAMETER : must specify one verifier address\");\n        layer2ChainId = _chainId;\n        zk_verifier = _zk_verifier;\n        tee_verifier = _tee_verifier;\n        l1_mail_box = _l1_mail_box;\n        maxTxsInChunk = _maxTxsInChunk;\n        maxBlockInChunk = _maxBlockInChunk;\n        maxCallDataInChunk = _maxCallDataInChunk;\n        maxZkCircleInChunk = _maxZkCircleInChunk;\n        l1BlobNumberLimit = _l1BlobNumberLimit;\n        rollupTimeLimit = _rollupTimeLimit;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n    /// @notice Import layer 2 genesis block\n    /// @param _batchHeader The header of the genesis batch.\n    /// @param _stateRoot The state root of the genesis block.\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external onlyOwner {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"INVALID_PARAMETER : state root is zero\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"INVALID_PARAMETER : genesis batch is imported\");\n\n        (uint256 memPtr, , bytes32 _batchHash, ) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderCodec.version(memPtr) +\n                                BatchHeaderCodec.batchIndex(memPtr);\n            require(sum == 0, \"INVALID_PARAMETER : genesis batch has no zero field\");\n            require(BatchHeaderCodec.l1RollingHash(memPtr) == bytes32(0), \"INVALID_PARAMETER : genesis batch rolling hash must be zero\");\n            require(BatchHeaderCodec.dataHash(memPtr) != bytes32(0), \"INVALID_PARAMETER : genesis batch data hash is zero\");\n            require(BatchHeaderCodec.parentBatchHash(memPtr) == bytes32(0), \"INVALID_PARAMETER : genesis parent batch hash must be zero\");\n        }\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        lastCommittedBatch = 0;\n        lastZkVerifiedBatch = 0;\n        lastTeeVerifiedBatch = 0;\n        l1MsgCount[0] = 0;\n        l2MsgRoots[0] = bytes32(0);\n        emit CommitBatch( 0, _batchHash);\n    }\n\n    /// @inheritdoc IRollup\n    function commitBatch(\n        uint8 _version,\n        uint256 _batchIndex,\n        uint256 _totalL1MessagePopped\n    ) external override OnlyRelayer whenNotPaused {\n        require(_batchIndex == lastCommittedBatch + 1, \"INVALID_PARAMETER : commit batch one by one\");\n\n        uint256 BATCH_HEADER_LENGTH = BatchHeaderCodec.BATCH_HEADER_FIXED_LENGTH;\n        // init empty batch\n        uint256 batchPtr;\n        assembly {\n            batchPtr := mload(0x40)\n            mstore(0x40, add(batchPtr, BATCH_HEADER_LENGTH))\n        }\n\n        BatchHeaderCodec.storeVersion(batchPtr, _version);\n        BatchHeaderCodec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderCodec.storeL1RollingHash(\n            batchPtr,\n            IL1MailQueue(l1_mail_box).getMsg(_totalL1MessagePopped)\n        );\n        BatchHeaderCodec.storeDataHash(batchPtr, _getBlobDataHash());\n        BatchHeaderCodec.storeParentBatchHash(batchPtr, committedBatches[_batchIndex - 1]);\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderCodec.computeBatchHash(\n            batchPtr,\n            BatchHeaderCodec.BATCH_HEADER_FIXED_LENGTH\n        );\n\n        committedBatches[_batchIndex] = _batchHash;\n        lastCommittedBatch =  _batchIndex;\n        l1MsgCount[_batchIndex] = _totalL1MessagePopped;\n        emit CommitBatch(_batchIndex, _batchHash);\n    }\n\n    /// @inheritdoc IRollup\n    function verifyBatch(\n        uint8 _prove_type,\n        bytes calldata _batchHeader,\n        bytes32 _postStateRoot,\n        bytes32 _l2MsgRoot,\n        bytes calldata _proof\n    ) external override OnlyRelayer whenNotPaused {\n        require(_prove_type == 0 || _prove_type == 1, \"INVALID_PARAMETER : invalid prove type\");\n        require(_postStateRoot != bytes32(0), \"INVALID_PARAMETER : invalid state root\");\n        uint256 _verifiedBatchIndex = _prove_type == 0 ? lastZkVerifiedBatch : lastTeeVerifiedBatch;\n\n        // compute pending batch hash and verify\n        (\n            ,\n            uint256 _batchIndex,\n            bytes32 _batchHash,\n        ) = _loadBatchHeader(_batchHeader);\n        require(_batchIndex == _verifiedBatchIndex + 1, \"INVALID_PARAMETER : invalid verify batch index, must one by one\");\n        require(committedBatches[_batchIndex] != bytes32(0) && committedBatches[_batchIndex] ==  _batchHash, \"INVALID_PARAMETER : invalid commit batch hash\");\n        require(finalizedStateRoots[_batchIndex] == bytes32(0) || finalizedStateRoots[_batchIndex] == _postStateRoot, \"INVALID_PARAMETER : invalid verify state root\");\n        bytes memory _publicInput = abi.encodePacked(\n            layer2ChainId,\n            finalizedStateRoots[_verifiedBatchIndex], // _prevStateRoot\n            _postStateRoot,\n            _batchHash,\n            _l2MsgRoot\n        );\n        if (_prove_type == 0) {\n            revert NotSupportZkProof();\n        } else if (_prove_type == 1) {\n            _verifyTeeProof(_proof, _publicInput);\n        }\n\n        // TODO : add finalize check\n//        if ((_prove_type == 0 && lastTeeVerifiedBatch >= _batchIndex) || (_prove_type == 1 && lastZkVerifiedBatch >= _batchIndex)) {\n        // after verify update contract storage\n        if (finalizedStateRoots[_batchIndex] == bytes32(0)) {\n            finalizedStateRoots[_batchIndex] = _postStateRoot;\n        }\n        l2MsgRoots[_batchIndex] = _l2MsgRoot;\n        IL1MailQueue(l1_mail_box).popMsgs(l1MsgCount[_batchIndex]);\n//        }\n        emit VerifyBatch(_prove_type, _batchIndex, _batchHash, _postStateRoot, _l2MsgRoot);\n    }\n\n    /// @inheritdoc IRollup\n    /// @dev If the owner want to revert a sequence of batches by sending multiple transactions,\n    ///      make sure to revert recent batches first.\n    /// can only revert L2; L1 can not be revert;\n    function revertBatches(uint256 _newLastBatchIndex) external override onlyOwner {\n        require(_newLastBatchIndex < lastCommittedBatch, \"INVALID_PARAMETER : revert lastCommitBatchIndex must smaller than current\");\n        require(lastCommittedBatch - _newLastBatchIndex <= 100, \"INVALID_PARAMETER : revert block number must smaller than 100 for gas limit\");\n        require(_newLastBatchIndex >= lastZkVerifiedBatch, \"INVALID_PARAMETER : revert block number bigger than last zk verify block number\");\n        require(_newLastBatchIndex >= lastTeeVerifiedBatch, \"INVALID_PARAMETER : revert block number bigger than last tee verify block number\");\n\n        // actual revert\n        for (uint256 _batchIndex = lastCommittedBatch; _batchIndex > _newLastBatchIndex; --_batchIndex) {\n            committedBatches[_batchIndex] = bytes32(0);\n        }\n        lastCommittedBatch = _newLastBatchIndex;\n    }\n\n    function getL2MsgRoot(uint256 batch_index) external view override returns (bytes32) {\n        return l2MsgRoots[batch_index];\n    }\n\n    function _getBlobDataHash() internal virtual returns (bytes32 _blobDataHash) {\n        uint32 blobNumberLimit = l1BlobNumberLimit;\n        assembly {\n            let dataStart := mload(0x40)\n            let offset := 0\n            let i := 0\n            for {} lt(i, blobNumberLimit) { i := add(i, 1) } {\n                let hash := blobhash(i)\n                if iszero(hash) {\n                    break\n                }\n                mstore(add(dataStart, offset), hash)\n                offset := add(offset, 0x20)\n            }\n            _blobDataHash := keccak256(dataStart, offset)\n            mstore(0x40, add(dataStart, offset))\n        }\n        emit BlobDataHash(_blobDataHash);\n    }\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchIndex The index of the loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    /// @return _l1MsgRollingHash The rolling hash of L1 msg on this batch.\n    function _loadBatchHeader(\n        bytes calldata _batchHeader\n    ) internal pure returns (uint256 memPtr, uint256 _batchIndex, bytes32 _batchHash, bytes32 _l1MsgRollingHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderCodec.loadAndValidate(_batchHeader);\n        // compute batch hash\n        _batchHash = BatchHeaderCodec.computeBatchHash(memPtr, _length);\n        _batchIndex = BatchHeaderCodec.batchIndex(memPtr);\n        _l1MsgRollingHash = BatchHeaderCodec.l1RollingHash(memPtr);\n    }\n\n    function _verifyTeeProof(bytes memory _proof, bytes memory _publicInput) internal {\n        bytes32 _commitment = keccak256(_publicInput);\n        (uint32 error_code, bytes32 commitment) = ITeeRollupVerifier(tee_verifier).verifyProof(_proof);\n        require(error_code == 0, \"ERROR : verify failed\");\n        require(commitment == _commitment, \"ERROR : error tee commitment for verify\");\n        lastTeeVerifiedBatch = lastTeeVerifiedBatch + 1;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add an account to the relayer list.\n    /// @param _account The address of account to add.\n    function addRelayer(address _account) external onlyOwner {\n        // @note Currently many external services rely on EOA sequencer to decode metadata directly from tx.calldata.\n        // So we explicitly make sure the account is EOA.\n        require(_account.code.length == 0, \"INVALID_PERMISSION : relayer account must be a eoa\");\n\n        isRelayer[_account] = true;\n    }\n\n    /// @notice Remove an account from the relayer list.\n    /// @param _account The address of account to remove.\n    function removeRelayer(address _account) external onlyOwner {\n        isRelayer[_account] = false;\n    }\n\n    /// @notice Pause the contract\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Set maxTxsInChunk of tx size in a chunk.\n    /// @param _maxTxsInChunk The number of tx size in a chunk.\n    function setMaxTxsInChunk(uint32 _maxTxsInChunk) external onlyOwner {\n        maxTxsInChunk = _maxTxsInChunk;\n    }\n\n    /// @notice Set maxBlockInChunk of block size in a chunk.\n    /// @param _maxBlockInChunk The number of block size in a chunk.\n    function setMaxBlockInChunk(uint32 _maxBlockInChunk) external onlyOwner {\n        maxBlockInChunk = _maxBlockInChunk;\n    }\n\n    /// @notice Set maxCallDataInChunk of tx data size in a chunk.\n    /// @param _maxCallDataInChunk The number of tx data size in a chunk.\n    function setMaxCallDataInChunk(uint32 _maxCallDataInChunk) external onlyOwner {\n        maxCallDataInChunk = _maxCallDataInChunk;\n    }\n\n    /// @notice Set l1BlobNumberLimit of the limit of l1 tx data size.\n    /// @param _l1BlobNumberLimit The limit of L1 tx data size.\n    function setL1BlobNumberLimit(uint32 _l1BlobNumberLimit) external onlyOwner {\n        l1BlobNumberLimit = _l1BlobNumberLimit;\n    }\n\n    /// @notice Set rollupTimeLimit of the limit of l1 tx data size.\n    /// @param _rollupTimeLimit The limit of L1 tx data size.\n    function setRollupTimeLimit(uint32 _rollupTimeLimit) external onlyOwner {\n        rollupTimeLimit = _rollupTimeLimit;\n    }\n\n    /// @notice Set setL2ChainId\n    /// @param _layer2ChainId The chain Id of L2.\n    function setL2ChainId(uint64 _layer2ChainId) external onlyOwner {\n        layer2ChainId = _layer2ChainId;\n    }\n\n    /// @notice Set tee_verifier\n    /// @param _teeVerifierAddress The verifier address of tee.\n    function setTeeVerifierAddress(address _teeVerifierAddress) external onlyOwner whenPaused {\n        require(_teeVerifierAddress != address(0), \"INVALID_PARAMETER : must specify one verifier address\");\n        tee_verifier = _teeVerifierAddress;\n    }\n\n    /// @notice Set zk_verifier\n    /// @param _zkVerifierAddress The verifier address of tee.\n    function setZkVerifierAddress(address _zkVerifierAddress) external onlyOwner whenPaused {\n        require(_zkVerifierAddress != address(0), \"INVALID_PARAMETER : must specify one verifier address\");\n        zk_verifier = _zkVerifierAddress;\n    }\n}"
    }
}