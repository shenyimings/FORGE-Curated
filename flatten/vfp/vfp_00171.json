{
    "vfp_id": "vfp_00171",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Underflow via Token Hook Manipulation During Batch Claims",
            "description": "During batch claims, the protocol calculates withdrawn amounts by comparing the contract's token balance before and after a transfer. However, if the token implements hooks (e.g., ERC-777), a malicious receiver can use the hook to send tokens back to the contract during withdrawal.\nThe cause is the assumption that the contract's balance will only decrease, without accounting for reentrancy-like behavior via token hooks.\nBy returning more tokens than received, the receiver can cause the post-withdrawal balance to exceed the pre-withdrawal balance, leading to an underflow in the subtraction operation.\nThis causes the entire transaction to revert, preventing other recipients from receiving their funds. The impact includes denial of service for batch claims and potential fund lockup.\n",
            "severity": "Low",
            "location": [
                "TransferLib.sol#131"
            ],
            "files": [
                "the-compact/src/lib/TransferLib.sol"
            ]
        }
    ],
    "affected_files": {
        "TransferLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { TransferBenchmarkLib } from \"./TransferBenchmarkLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/**\n * @title TransferLib\n * @notice Library contract implementing logic for internal functions with\n * low-level shared logic for processing transfers, withdrawals and deposits.\n */\nlibrary TransferLib {\n    using TransferLib for address;\n    using IdLib for uint256;\n    using SafeTransferLib for address;\n    using TransferBenchmarkLib for address;\n\n    // Storage slot seed for ERC6909 state, used in computing balance slots.\n    uint256 private constant _ERC6909_MASTER_SLOT_SEED = 0xedcaa89a82293940;\n\n    // keccak256(bytes(\"Transfer(address,address,address,uint256,uint256)\")).\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859;\n\n    /**\n     * @notice Internal function for transferring ERC6909 tokens between accounts. Updates\n     * both balances, checking for overflow and insufficient balance. This function bypasses\n     * transfer hooks and allowance checks as it is only called in trusted contexts. Emits\n     * a Transfer event.\n     * @param from   The account to transfer tokens from.\n     * @param to     The account to transfer tokens to.\n     * @param id     The ERC6909 token identifier to transfer.\n     * @param amount The amount of tokens to transfer.\n     */\n    function release(address from, address to, uint256 id, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Compute the sender's balance slot using the master slot seed.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n\n            // Load from sender's current balance.\n            let fromBalance := sload(fromBalanceSlot)\n\n            // Revert if amount is zero or exceeds balance.\n            if or(iszero(amount), gt(amount, fromBalance)) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Subtract from current balance and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n\n            // Compute the recipient's balance slot and update balance.\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Store the recipient's updated balance.\n            sstore(toBalanceSlot, toBalanceAfter)\n\n            // Emit the Transfer event:\n            //  - topic1: Transfer event signature\n            //  - topic2: sender address (sanitized)\n            //  - topic3: recipient address (sanitized)\n            //  - topic4: token id\n            //  - data: [caller, amount]\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(0x60, shl(0x60, from)), shr(0x60, shl(0x60, to)), id)\n        }\n    }\n\n    /**\n     * @notice Internal function for burning ERC6909 tokens and withdrawing the underlying\n     * tokens. Updates the sender's balance and transfers either native tokens or ERC20\n     * tokens to the recipient. For ERC20 withdrawals, the actual amount burned is derived\n     * from the balance change. Ensure that a reentrancy guard has been set before calling.\n     * Emits a Transfer event. Note that if the withdrawal fails, a direct release of the\n     * 6909 tokens in question will be performed instead.\n     * @param from   The account to burn tokens from.\n     * @param to     The account to send underlying tokens to.\n     * @param id     The ERC6909 token identifier to burn.\n     * @param amount The amount of tokens to burn and withdraw.\n     */\n    function withdraw(address from, address to, uint256 id, uint256 amount) internal {\n        // Derive the underlying token from the id of the resource lock.\n        address token = id.toAddress();\n\n        // Handle native token withdrawals directly.\n        bool withdrawalSucceeded;\n        uint256 postWithdrawalAmount = amount;\n        if (token == address(0)) {\n            // Attempt to transfer the ETH using half of available gas.\n            assembly (\"memory-safe\") {\n                withdrawalSucceeded := call(div(gas(), 2), to, amount, codesize(), 0, codesize(), 0)\n            }\n        } else {\n            // For ERC20s, track balance change to determine actual withdrawal amount.\n            uint256 initialBalance = token.balanceOf(address(this));\n\n            // Attempt to transfer the tokens using half of available gas.\n            assembly (\"memory-safe\") {\n                mstore(0x14, to) // Store the `to` argument.\n                mstore(0x34, amount) // Store the `amount` argument.\n                mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n\n                // Perform the transfer using half of available gas & examine the call for failure.\n                withdrawalSucceeded :=\n                    and( // The arguments of `and` are evaluated from right to left.\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(div(gas(), 2), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n\n                mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n            }\n\n            // Derive actual amount from balance change.\n            postWithdrawalAmount = initialBalance - token.balanceOf(address(this));\n\n            // Consider the withdrawal as having succeeded if any amount was withdrawn.\n            assembly (\"memory-safe\") {\n                withdrawalSucceeded := or(withdrawalSucceeded, iszero(iszero(postWithdrawalAmount)))\n            }\n        }\n\n        // Burn the 6909 tokens if the withdrawal succeeded.\n        if (withdrawalSucceeded) {\n            from.burn(id, postWithdrawalAmount);\n        } else {\n            // Ensure that sufficient additional gas stipend has been supplied.\n            token.ensureBenchmarkExceeded();\n\n            // Transfer original amount of associated 6909 tokens directly.\n            from.release(to, id, amount);\n        }\n    }\n\n    /**\n     * @notice Internal function for burning ERC6909 tokens. Emits a Transfer event.\n     * @param from   The account to burn tokens from.\n     * @param id     The ERC6909 token identifier to burn.\n     * @param amount The amount of tokens to burn.\n     */\n    function burn(address from, uint256 id, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Compute the sender's balance slot using the master slot seed.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n\n            // Load from sender's current balance.\n            let fromBalance := sload(fromBalanceSlot)\n\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Subtract from current balance and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n\n            // Emit the Transfer event:\n            //  - topic1: Transfer event signature\n            //  - topic2: sender address (sanitized)\n            //  - topic3: address(0) signifying a burn\n            //  - topic4: token id\n            //  - data: [caller, amount]\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(0x60, shl(0x60, from)), 0, id)\n        }\n    }\n\n    /**\n     * @notice Internal function for minting ERC6909 tokens. Updates the recipient's balance,\n     * checking for overflow, and emits a Transfer event. This function bypasses transfer\n     * hooks and allowance checks as it is only called in trusted deposit contexts.\n     * @param to     The address to mint tokens to.\n     * @param id     The ERC6909 token identifier to mint.\n     * @param amount The amount of tokens to mint.\n     */\n    function deposit(address to, uint256 id, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Compute the recipient's balance slot using the master slot seed.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n\n            // Load current balance and compute new balance.\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n\n            // Revert on balance overflow.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Store the updated balance.\n            sstore(toBalanceSlot, toBalanceAfter)\n\n            // Emit the Transfer event:\n            // - topic1: Transfer event signature\n            // - topic2: address(0) signifying a mint\n            // - topic3: recipient address (sanitized)\n            // - topic4: token id\n            // - data: [caller, amount]\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0, 0x40, _TRANSFER_EVENT_SIGNATURE, 0, shr(0x60, shl(0x60, to)), id)\n        }\n    }\n\n    /**\n     * @notice Internal function for handling various token operation flows based on the\n     * respective lock tags. Determines whether to withdraw, release, or transfer tokens.\n     * @param from     The address from which the operation originates.\n     * @param id       The ERC6909 token identifier to operate on.\n     * @param claimant The identifier representing the claimant entity.\n     * @param amount   The amount of tokens involved in the operation.\n     */\n    function performOperation(address from, uint256 id, uint256 claimant, uint256 amount) internal {\n        // Extract lock tags from both token ID and claimant.\n        bytes12 lockTag = id.toLockTag();\n        bytes12 claimantLockTag = claimant.toLockTag();\n\n        // Extract the recipient address referenced by the claimant.\n        address recipient = claimant.toAddress();\n\n        if (claimantLockTag == bytes12(0)) {\n            // Case 1: Zero lock tag - perform a standard withdrawal operation\n            // to the recipient address referenced by the claimant.\n            from.withdraw(recipient, id, amount);\n        } else if (claimantLockTag == lockTag) {\n            // Case 2: Matching lock tags - transfer tokens to the recipient address\n            // referenced by the claimant.\n            from.release(recipient, id, amount);\n        } else {\n            // Case 3: Different lock tags - convert the resource lock, burning\n            // tokens and minting the same amount with the new token ID to the\n            // recipient address referenced by the claimant.\n\n            // Create a new token ID using the original ID with claimant's lock tag.\n            uint256 claimantId = id.withReplacedLockTag(claimantLockTag);\n\n            // Verify the allocator ID is registered.\n            claimantId.toRegisteredAllocatorId();\n\n            // Burn tokens from the original context.\n            from.burn(id, amount);\n\n            // Deposit tokens to the claimant's address with the new token ID.\n            recipient.deposit(claimantId, amount);\n        }\n    }\n}\n"
    }
}