{
    "vfp_id": "vfp_00463",
    "project_name": "Paxos Labs - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "DoS risk due to unhandled permit reverts",
            "description": "1. **Description:** The `_verifyDepositor` function calls `permit` without error handling. If the permit signature has already been used, the call reverts, blocking the entire operation.\n\n2. **Cause:** Lack of `try/catch` or pre-check for used nonces makes the function vulnerable to front-running attacks where an attacker uses the permit signature first.\n\n3. **Exploitation:** An attacker can monitor the mempool and front-run a transaction by calling `permit` with the same parameters, causing the original transaction to revert.\n\n4. **Impact:** This leads to a denial of service for order submission or processing that relies on permit. The impact is low due to the requirement of timely front-running.\n",
            "severity": "Low",
            "location": [
                "OneToOneQueue.sol#L513-L522",
                "CommunityCodeDepositor.sol#L151"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Minimum order size check before fees",
            "description": "1. **Description:** The minimum order size check is performed on the gross `amountOffer` before fees are deducted. After fee calculation, the net amount received by the user may fall below the intended minimum.\n\n2. **Cause:** The check `if (params.amountOffer < minimumOrderSize)` is executed before `calculateOfferFees`, which reduces the amount sent to the receiver.\n\n3. **Exploitation:** An attacker can submit an order just above the minimum threshold, but after fees, the actual amount delivered is below minimum, potentially distorting economic incentives.\n\n4. **Impact:** This undermines the intended minimum order size policy, possibly enabling spam or economically inefficient trades. The impact is low as it does not lead to fund loss.\n",
            "severity": "Low",
            "location": [
                "OneToOneQueue.sol#L374-L382"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "processOrders() should perform external call after state updates",
            "description": "1. **Description:** The `processOrders` function performs an external call to `safeTransfer` before updating the `lastProcessedOrder` state variable, violating the Checks-Effects-Interactions (CEI) pattern.\n\n2. **Cause:** The state update `++lastProcessedOrder` occurs after the external call, creating a reentrancy window if the recipient is a malicious contract.\n\n3. **Exploitation:** A malicious `wantAsset` that supports callbacks (e.g., ERC777) could reenter `processOrders`, reprocessing the same order and draining funds.\n\n4. **Impact:** This could lead to reentrancy-based fund loss. The impact is low due to the specific token requirements and decreasing prevalence of such tokens.\n",
            "severity": "Low",
            "location": [
                "OneToOneQueue.sol#L464"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "setFeeModule() will apply new fee structure retroactively and affect refunds",
            "description": "1. **Description:** The `setFeeModule` function allows updating the fee module, which affects fee calculations for existing orders. Refunds for these orders use the new fee structure, potentially returning incorrect fee amounts.\n\n2. **Cause:** The fee amount is not stored at order creation; instead, it is recalculated during refund using the current fee module.\n\n3. **Exploitation:** An admin could change the fee module to reduce or eliminate fees, then trigger refunds, returning less than originally paid in fees.\n\n4. **Impact:** Users may receive incorrect refunds, leading to financial loss. The impact is low due to the requirement of admin privilege to change the fee module.\n",
            "severity": "Low",
            "location": [
                "OneToOneQueue.sol#L177-L187"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1285"
                ],
                "4": [
                    "CWE-129"
                ]
            },
            "title": "getOrderStatus returns misleading status for non-existent orders",
            "description": "1. **Description:** The `getOrderStatus` function returns `PENDING` for non-existent order indices (e.g., `orderIndex > latestOrder`), which is misleading as no such order was ever created.\n\n2. **Cause:** The function does not validate whether the `orderIndex` corresponds to a submitted order before returning a status.\n\n3. **Exploitation:** An attacker can query non-existent orders and misinterpret them as pending, leading to incorrect off-chain logic or user confusion.\n\n4. **Impact:** This leads to incorrect state interpretation by off-chain systems or users. The impact is informational, as it does not affect on-chain behavior.\n",
            "severity": "Informational",
            "location": [
                "OneToOneQueue.sol#L357-L359"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "uint128 truncation without bounds check",
            "description": "1. **Description:** The `submitOrder` function casts `params.amountOffer` (uint256) to `uint128` without bounds checking, causing silent truncation if the value exceeds `type(uint128).max`.\n\n2. **Cause:** Direct unsafe casting using `uint128(params.amountOffer)` without prior validation.\n\n3. **Exploitation:** A user submitting an order with `amountOffer > uint128.max` would have their amount truncated, leading to incorrect order size and potential loss of funds.\n\n4. **Impact:** Users may deposit more than intended due to truncation, resulting in financial loss. The impact is informational as it's a known Solidity anti-pattern, but could be more severe in practice.\n",
            "severity": "Informational",
            "location": [
                "OneToOneQueue.sol#L407-L410"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Lack of Order expiry can cause issue",
            "description": "1. **Description:** Orders do not have an expiration deadline. If a stablecoin depegs after order submission but before processing, users receive devalued assets without the ability to cancel.\n\n2. **Cause:** No timestamp or deadline is included in the order struct or validated during processing.\n\n3. **Exploitation:** In the event of a depeg, users are forced to accept devalued tokens, with no opt-out mechanism.\n\n4. **Impact:** Users may suffer financial loss due to receiving depegged assets. The impact is informational as the team acknowledges this as a design choice.\n",
            "severity": "Informational",
            "location": [
                "OneToOneQueue.sol#L368-L424"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "_verifyDepositor doesnâ€™t handle permit for feeAsset",
            "description": "1. **Description:** The `_verifyDepositor` function only handles permit approval for `offerAsset`, but the fee module may return a different `feeAsset`. Transferring `feeAsset` without approval causes reverts.\n\n2. **Cause:** The permit logic is only applied to `params.offerAsset`, not the actual `feeAsset` used in the fee transfer.\n\n3. **Exploitation:** If `feeAsset != offerAsset`, the contract will attempt to transfer `feeAsset` from the depositor without allowance, causing the transaction to fail.\n\n4. **Impact:** This leads to failed transactions when fee and offer assets differ. The impact is informational as the team has removed support for different fee assets.\n",
            "severity": "Informational",
            "location": [
                "OneToOneQueue.sol#L397"
            ],
            "files": [
                "0x7032978ef1fc44271145bb593be45be1c7a0b6c5/nucleus-boring-vault/src/helper/one-to-one-queue/OneToOneQueue.sol"
            ]
        }
    ],
    "affected_files": {
        "OneToOneQueue.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport { ERC721Enumerable, ERC721 } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IFeeModule } from \"./interfaces/IFeeModule.sol\";\nimport { VerboseAuth, Authority } from \"./access/VerboseAuth.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title OneToOneQueue\n * @notice A FIFO queue system for processing withdrawal requests with tokenized receipts\n * @dev Implements ERC721Enumerable for tokenized order receipts\n */\ncontract OneToOneQueue is ERC721Enumerable, VerboseAuth {\n\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /// @notice Type for internal order handling\n    /// @dev all but default orders are skipped on solve, as refunds and pre-fills are handled at the time they are\n    /// marked\n    enum OrderType {\n        DEFAULT, // Normal order in queue\n        PRE_FILLED, // Order filled out of order, skip on process\n        REFUND // Order refunded, skip on process\n    }\n\n    /// @notice Return type of a user's order status in the queue\n    enum OrderStatus {\n        NOT_FOUND,\n        PENDING,\n        COMPLETE,\n        COMPLETE_PRE_FILLED,\n        COMPLETE_REFUNDED,\n        FAILED_TRANSFER,\n        FAILED_REFUND\n    }\n\n    /// @notice Approval method for submitting an order\n    enum ApprovalMethod {\n        EIP20_APROVE,\n        EIP2612_PERMIT\n    }\n\n    /// @notice Parameters for submitting and approving an order with signatures\n    struct SignatureParams {\n        ApprovalMethod approvalMethod;\n        uint8 approvalV;\n        bytes32 approvalR;\n        bytes32 approvalS;\n        bool submitWithSignature;\n        uint256 deadline;\n        bytes eip2612Signature;\n        uint256 nonce;\n    }\n\n    /// @notice Parameters for submitting an order\n    struct SubmitOrderParams {\n        uint256 amountOffer;\n        IERC20 offerAsset;\n        IERC20 wantAsset;\n        address intendedDepositor;\n        address receiver;\n        address refundReceiver;\n        SignatureParams signatureParams;\n    }\n\n    /// @notice Represents a withdrawal order in the queue\n    struct Order {\n        uint128 amountOffer; // Amount of offer asset in offer decimals to exchange for the same amount of want asset\n        // minus fees.\n        uint128 amountWant; // Amount of want asset to give the user in want decimals. This is not inclusive of fees.\n        IERC20 offerAsset; // Asset being offered\n        IERC20 wantAsset; // Asset being requested\n        address refundReceiver; // Address to receive refunds\n        OrderType orderType; // Current status of the order\n        bool didOrderFailTransfer; // Whether the order failed to transfer on process or refund\n    }\n\n    /// @notice Mapping of hashes that have been used for signatures to prevent replays\n    mapping(bytes32 => bool) public usedSignatureHashes;\n\n    /// @notice Mapping of supported offer assets\n    mapping(address => bool) public supportedOfferAssets;\n\n    /// @notice Mapping of supported want assets\n    mapping(address => bool) public supportedWantAssets;\n\n    /// @notice Minimum order size per offer asset\n    mapping(address => uint256) public minimumOrderSizePerAsset;\n\n    /// @notice Address of the fee module for calculating fees\n    IFeeModule public feeModule;\n\n    /// @notice Address of the offerAssetRecipient\n    address public offerAssetRecipient;\n\n    /// @notice recipient of queue fees\n    address public feeRecipient;\n\n    /// @notice Address to hold funds for failed transfers\n    address public recoveryAddress;\n\n    /// @notice Mapping of order index to Order struct\n    mapping(uint256 => Order) public queue;\n\n    /// @notice The index of the last order that was processed\n    /// @dev Initialized to 0, meaining the queue starts at 1.\n    uint256 public lastProcessedOrder;\n\n    /// @notice represents the back of the queue, incremented on sumbiting orders\n    uint256 public latestOrder;\n\n    event FeeModuleUpdated(IFeeModule indexed oldFeeModule, IFeeModule indexed newFeeModule);\n    event OfferAssetAdded(address indexed asset, uint256 minimumOrderSize);\n    event OfferAssetRemoved(address indexed asset);\n    event WantAssetAdded(address indexed asset);\n    event WantAssetRemoved(address indexed asset);\n    event MinimumOrderSizeUpdated(address indexed asset, uint256 oldMinimum, uint256 newMinimum);\n    event OfferAssetRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n    event FeeRecipientUpdated(address indexed oldFeeRecipient, address indexed newFeeRecipient);\n    event OrderSubmitted(\n        uint256 indexed orderIndex,\n        Order order,\n        address indexed receiver,\n        address indexed depositor,\n        bool isSubmittedViaSignature\n    );\n    event OrdersProcessedInRange(uint256 indexed startIndex, uint256 indexed endIndex);\n    event OrderProcessed(\n        uint256 indexed orderIndex, Order order, address indexed receiver, bool indexed isForceProcessed\n    );\n    event OrderRefunded(uint256 indexed orderIndex, Order order);\n    event OrderFailedTransfer(\n        uint256 indexed orderIndex, address indexed recoveryAddress, address indexed originalReceiver, Order order\n    );\n    event RecoveryAddressUpdated(address indexed oldRecoveryAddress, address indexed newRecoveryAddress);\n\n    error ZeroAddress();\n    error AssetAlreadySupported(address asset);\n    error AssetNotSupported(address asset);\n    error OrderAlreadyProcessed(uint256 orderIndex);\n    error InvalidOrderStatus(uint256 orderIndex, OrderType currentStatus);\n    error InvalidOrderIndex(uint256 orderIndex);\n    error AmountBelowMinimum(uint256 amount, uint256 minimum);\n    error SignatureExpired(uint256 deadline, uint256 currentTimestamp);\n    error SignatureHashAlreadyUsed(bytes32 hash);\n    error NotEnoughOrdersToProcess(uint256 ordersToProcess, uint256 latestOrder);\n    error InsufficientBalanceInQueue(uint256 orderIndex, address asset, uint256 required, uint256 available);\n    error InvalidOrdersCount(uint256 ordersToProcess);\n    error InvalidEip2612Signature(address intendedDepositor, address depositor);\n    error InvalidDepositor(address intendedDepositor, address depositor);\n    error PermitFailedAndAllowanceTooLow();\n\n    /**\n     * @notice Initialize the contract\n     * @param _name Name for the ERC721 receipt tokens\n     * @param _symbol Symbol for the ERC721 receipt tokens\n     * @param _offerAssetRecipient Address of the boring vault\n     * @param _feeRecipient Address of the fee recipient\n     * @param _feeModule Address of fee module contract\n     * @param _owner Address of the initial owner\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _offerAssetRecipient,\n        address _feeRecipient,\n        IFeeModule _feeModule,\n        address _recoveryAddress,\n        address _owner\n    )\n        ERC721(_name, _symbol)\n        VerboseAuth(_owner, Authority(address(0)))\n    {\n        // no zero check on owner in Auth Contract\n        if (_owner == address(0)) revert ZeroAddress();\n        if (_offerAssetRecipient == address(0)) revert ZeroAddress();\n        if (_feeRecipient == address(0)) revert ZeroAddress();\n        if (_recoveryAddress == address(0)) revert ZeroAddress();\n        if (address(_feeModule) == address(0)) revert ZeroAddress();\n\n        offerAssetRecipient = _offerAssetRecipient;\n        recoveryAddress = _recoveryAddress;\n        feeRecipient = _feeRecipient;\n        feeModule = _feeModule;\n    }\n\n    /**\n     * @notice Set the fee module address\n     * @param _feeModule Address of the new fee module\n     */\n    function setFeeModule(IFeeModule _feeModule) external requiresAuthVerbose {\n        if (address(_feeModule) == address(0)) revert ZeroAddress();\n\n        IFeeModule oldFeeModule = feeModule;\n        feeModule = _feeModule;\n        emit FeeModuleUpdated(oldFeeModule, _feeModule);\n    }\n\n    /**\n     * @notice Set the fee recipient address\n     * @param _feeRecipient Address of the new fee module\n     */\n    function setFeeRecipient(address _feeRecipient) external requiresAuthVerbose {\n        if (_feeRecipient == address(0)) revert ZeroAddress();\n\n        address oldFeeRecipient = feeRecipient;\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(oldFeeRecipient, _feeRecipient);\n    }\n\n    /**\n     * @notice Set the recovery address\n     * @param _recoveryAddress Address of the new recovery address\n     */\n    function setRecoveryAddress(address _recoveryAddress) external requiresAuthVerbose {\n        if (_recoveryAddress == address(0)) revert ZeroAddress();\n        address oldRecoveryAddress = recoveryAddress;\n        recoveryAddress = _recoveryAddress;\n        emit RecoveryAddressUpdated(oldRecoveryAddress, _recoveryAddress);\n    }\n\n    /**\n     * @notice Add a supported offer asset\n     * @param _asset Address of the offer asset to add\n     * @param _minimumOrderSize Minimum order size for this asset\n     */\n    function addOfferAsset(address _asset, uint256 _minimumOrderSize) external requiresAuthVerbose {\n        if (_asset == address(0)) revert ZeroAddress();\n        if (supportedOfferAssets[_asset]) revert AssetAlreadySupported(_asset);\n\n        supportedOfferAssets[_asset] = true;\n        minimumOrderSizePerAsset[_asset] = _minimumOrderSize;\n\n        emit OfferAssetAdded(_asset, _minimumOrderSize);\n    }\n\n    /**\n     * @notice Update an assets minimum order size\n     * @param _asset Address of asset\n     * @param _newMinimum for this asset to update to\n     */\n    function updateAssetMinimumOrderSize(address _asset, uint256 _newMinimum) external requiresAuthVerbose {\n        if (!supportedOfferAssets[_asset]) revert AssetNotSupported(_asset);\n\n        uint256 oldMinimum = minimumOrderSizePerAsset[_asset];\n        minimumOrderSizePerAsset[_asset] = _newMinimum;\n\n        emit MinimumOrderSizeUpdated(_asset, oldMinimum, _newMinimum);\n    }\n\n    /**\n     * @notice Remove a supported offer asset\n     * @param _asset Address of the offer asset to remove\n     */\n    function removeOfferAsset(address _asset) external requiresAuthVerbose {\n        if (!supportedOfferAssets[_asset]) revert AssetNotSupported(_asset);\n\n        supportedOfferAssets[_asset] = false;\n\n        emit OfferAssetRemoved(_asset);\n    }\n\n    /**\n     * @notice Add a supported want asset\n     * @param _asset Address of the want asset to add\n     */\n    function addWantAsset(address _asset) external requiresAuthVerbose {\n        if (_asset == address(0)) revert ZeroAddress();\n        if (supportedWantAssets[_asset]) revert AssetAlreadySupported(_asset);\n\n        supportedWantAssets[_asset] = true;\n\n        emit WantAssetAdded(_asset);\n    }\n\n    /**\n     * @notice Remove a supported want asset\n     * @param _asset Address of the want asset to remove\n     */\n    function removeWantAsset(address _asset) external requiresAuthVerbose {\n        if (!supportedWantAssets[_asset]) revert AssetNotSupported(_asset);\n\n        supportedWantAssets[_asset] = false;\n\n        emit WantAssetRemoved(_asset);\n    }\n\n    /**\n     * @notice Update offer asset recipient address\n     * @param _newAddress Address of the new recipient\n     */\n    function updateOfferAssetRecipient(address _newAddress) external requiresAuthVerbose {\n        if (_newAddress == address(0)) revert ZeroAddress();\n\n        address oldVal = offerAssetRecipient;\n        offerAssetRecipient = _newAddress;\n\n        emit OfferAssetRecipientUpdated(oldVal, _newAddress);\n    }\n\n    /**\n     * @dev Allows owner to manage ERC20 tokens in the contract to prevent stuck funds\n     */\n    function manageERC20(IERC20 token, uint256 amount, address receiver) external requiresAuthVerbose {\n        if (address(token) == address(0)) revert ZeroAddress();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        token.safeTransfer(receiver, amount);\n    }\n\n    /**\n     * @notice Force refund multiple orders\n     * @param orderIndices Array of order indices to refund\n     */\n    function forceRefundOrders(uint256[] calldata orderIndices) external requiresAuthVerbose {\n        uint256 length = orderIndices.length;\n        for (uint256 i; i < length; ++i) {\n            _forceRefund(orderIndices[i]);\n        }\n    }\n\n    /**\n     * @notice Force process multiple orders\n     * @param orderIndices Array of order indices to process\n     */\n    function forceProcessOrders(uint256[] calldata orderIndices) external requiresAuthVerbose {\n        uint256 length = orderIndices.length;\n        for (uint256 i; i < length; ++i) {\n            _forceProcess(orderIndices[i]);\n        }\n    }\n\n    /**\n     * @notice refund an order and force process it\n     * @param orderIndex Index of the order to refund\n     */\n    function forceRefund(uint256 orderIndex) external requiresAuthVerbose {\n        _forceRefund(orderIndex);\n    }\n\n    /**\n     * @notice Force process an order out of sequence\n     * @param orderIndex Index of the order to force process\n     */\n    function forceProcess(uint256 orderIndex) external requiresAuthVerbose {\n        _forceProcess(orderIndex);\n    }\n\n    /**\n     * @notice Submit and immediately process a number of orders if liquidity is available\n     * @param params SubmitOrderParams struct containing all order parameters\n     * @param ordersToProcess Number of orders to process\n     * @return orderIndex The index of the created order\n     */\n    function submitOrderAndProcess(\n        SubmitOrderParams calldata params,\n        uint256 ordersToProcess\n    )\n        external\n        requiresAuthVerbose\n        returns (uint256 orderIndex)\n    {\n        orderIndex = submitOrder(params);\n        processOrders(ordersToProcess);\n    }\n\n    /**\n     * @notice Submit and immediately process an order if liquidity is available. Must process all the preceding orders\n     * to do so.\n     * @param params SubmitOrderParams struct containing all order parameters\n     * @return orderIndex The index of the created order\n     */\n    function submitOrderAndProcessAll(SubmitOrderParams calldata params)\n        external\n        requiresAuthVerbose\n        returns (uint256 orderIndex)\n    {\n        orderIndex = submitOrder(params);\n        // This is = getPendingOrderCount(). OrderIndex = latestOrder but does not require a cold storage read\n        processOrders(orderIndex - lastProcessedOrder);\n    }\n\n    /**\n     * @notice A user facing function to return an order's status\n     */\n    function getOrderStatus(uint256 orderIndex) external view returns (OrderStatus) {\n        if (orderIndex == 0) return OrderStatus.NOT_FOUND;\n        Order memory order = queue[orderIndex];\n\n        if (order.orderType == OrderType.PRE_FILLED) {\n            return OrderStatus.COMPLETE_PRE_FILLED;\n        }\n\n        if (order.orderType == OrderType.REFUND) {\n            if (order.didOrderFailTransfer) {\n                return OrderStatus.FAILED_REFUND;\n            }\n            return OrderStatus.COMPLETE_REFUNDED;\n        }\n\n        if (order.didOrderFailTransfer) {\n            return OrderStatus.FAILED_TRANSFER;\n        }\n\n        if (orderIndex > lastProcessedOrder) {\n            if (orderIndex > latestOrder) {\n                return OrderStatus.NOT_FOUND;\n            } else {\n                return OrderStatus.PENDING;\n            }\n        } else {\n            return OrderStatus.COMPLETE;\n        }\n    }\n\n    /**\n     * @notice Submit an order at the back of the queue\n     * @param params SubmitOrderParams struct containing all order parameters\n     */\n    function submitOrder(SubmitOrderParams calldata params) public requiresAuthVerbose returns (uint256 orderIndex) {\n        {\n            if (!supportedOfferAssets[address(params.offerAsset)]) {\n                revert AssetNotSupported(address(params.offerAsset));\n            }\n            if (!supportedWantAssets[address(params.wantAsset)]) revert AssetNotSupported(address(params.wantAsset));\n            uint256 minimumOrderSize = minimumOrderSizePerAsset[address(params.offerAsset)];\n            if (params.amountOffer < minimumOrderSize) revert AmountBelowMinimum(params.amountOffer, minimumOrderSize);\n            if (params.receiver == address(0)) revert ZeroAddress();\n            if (params.refundReceiver == address(0)) revert ZeroAddress();\n        }\n\n        address depositor = _verifyDepositor(params);\n\n        uint256 feeAmount =\n            feeModule.calculateOfferFees(params.amountOffer, params.offerAsset, params.wantAsset, params.receiver);\n        uint256 newAmountForReceiver = params.amountOffer - feeAmount;\n\n        // Increment the latestOrder as this one is being minted\n        unchecked {\n            orderIndex = ++latestOrder;\n        }\n\n        // Create order\n        // Since newAmountForReceiver is in offer decimals, we need to calculate the amountWant in want decimals\n        Order memory order = Order({\n            amountOffer: params.amountOffer.toUint128(),\n            amountWant: _getWantAmountInWantDecimals(\n                newAmountForReceiver.toUint128(), params.offerAsset, params.wantAsset\n            ),\n            offerAsset: params.offerAsset,\n            wantAsset: params.wantAsset,\n            refundReceiver: params.refundReceiver,\n            orderType: OrderType.DEFAULT,\n            didOrderFailTransfer: false\n        });\n        queue[orderIndex] = order;\n\n        // Transfer the offer assets to the offerAssetRecipient and feeRecipient\n        params.offerAsset.safeTransferFrom(depositor, offerAssetRecipient, newAmountForReceiver);\n        params.offerAsset.safeTransferFrom(depositor, feeRecipient, feeAmount);\n\n        // Mint NFT receipt to receiver\n        _safeMint(params.receiver, orderIndex);\n\n        emit OrderSubmitted(\n            orderIndex, queue[orderIndex], params.receiver, depositor, params.signatureParams.submitWithSignature\n        );\n    }\n\n    /**\n     * @notice Process orders sequentially from the queue\n     * @param ordersToProcess Number of orders to attempt processing\n     * @dev Processes orders starting from lastProcessedOrder + 1\n     *      Skips PRE_FILLED orders and REFUND orders\n     *      Requires sufficient want asset balance in contract\n     */\n    function processOrders(uint256 ordersToProcess) public requiresAuthVerbose {\n        if (ordersToProcess == 0) revert InvalidOrdersCount(ordersToProcess);\n\n        uint256 startIndex;\n        uint256 endIndex;\n\n        unchecked {\n            startIndex = lastProcessedOrder + 1;\n            endIndex = lastProcessedOrder + ordersToProcess;\n        }\n\n        // Ensure we don't go beyond existing orders\n        if (endIndex > latestOrder) revert NotEnoughOrdersToProcess(ordersToProcess, latestOrder);\n\n        // Essentially performing WHILE(++lastProcessedOrder < endIndex)\n        // However, using local variables to avoid unnecessary storage reads\n        for (uint256 i; i < ordersToProcess; ++i) {\n            uint256 orderIndex = startIndex + i;\n\n            Order memory order = queue[orderIndex];\n\n            if (order.orderType != OrderType.DEFAULT) {\n                unchecked {\n                    ++lastProcessedOrder;\n                }\n                // ignore\n                continue;\n            }\n\n            // receiver is the owner of the receipt token\n            address receiver = ownerOf(orderIndex);\n            _checkBalanceQueue(order.wantAsset, order.amountWant, orderIndex);\n\n            // Burn the order after noting the receiver, but before the transfer.\n            _burn(orderIndex);\n\n            // From SafeERC20 library to perform a safeERC20 transfer and return a bool on success. Implemented here\n            // since it's private and we cannot call it directly It's worth noting that there are some tokens like\n            // Tether Gold that return false while succeeding.\n            // This situation would result success in being false even though the transfer did not revert.\n            bool success = _callOptionalReturnBool(order.wantAsset, receiver, order.amountWant);\n\n            // If the transfer to the receiver fails, we mark the order as FAILED_TRANSFER and transfer the tokens to a\n            // recoveryAddress. This is because the queue could possibly be griefed by setting blacklisted addresses as\n            // the receivers and causing the queue to clog up on process. We handle this by taking the funds to the\n            // recoveryAddress to distribute to the user once they become un-blacklisted or otherwise determine a scheme\n            // for distribution\n            if (!success) {\n                // Set the type for the storage and memory as we will emit the memory order\n                order.didOrderFailTransfer = true;\n                queue[orderIndex].didOrderFailTransfer = true;\n                order.wantAsset.safeTransfer(recoveryAddress, order.amountWant);\n                emit OrderFailedTransfer(orderIndex, recoveryAddress, receiver, order);\n            }\n\n            unchecked {\n                ++lastProcessedOrder;\n            }\n\n            emit OrderProcessed(orderIndex, order, receiver, false);\n        }\n\n        emit OrdersProcessedInRange(startIndex, endIndex);\n    }\n\n    /**\n     * @dev helper function to handle the signature verification and permit for submitting an order\n     */\n    function _verifyDepositor(SubmitOrderParams calldata params) internal returns (address depositor) {\n        if (params.signatureParams.submitWithSignature) {\n            if (block.timestamp > params.signatureParams.deadline) {\n                revert SignatureExpired(params.signatureParams.deadline, block.timestamp);\n            }\n            bytes32 hash = keccak256(\n                abi.encode(\n                    params.amountOffer,\n                    params.offerAsset,\n                    params.wantAsset,\n                    params.receiver,\n                    params.refundReceiver,\n                    params.signatureParams.deadline,\n                    params.signatureParams.approvalMethod,\n                    params.signatureParams.nonce,\n                    address(feeModule),\n                    block.chainid,\n                    address(this)\n                )\n            );\n            if (usedSignatureHashes[hash]) revert SignatureHashAlreadyUsed(hash);\n            usedSignatureHashes[hash] = true;\n\n            depositor = ECDSA.recover(hash, params.signatureParams.eip2612Signature);\n            // Here we check the intended depositor for a better revert message. If we didn't do this, an incorrect\n            // signature would error on the attempt to transfer assets from a nonsense depositor. This error is more\n            // descriptive\n            if (depositor != params.intendedDepositor) {\n                revert InvalidEip2612Signature(params.intendedDepositor, depositor);\n            }\n        } else {\n            depositor = msg.sender;\n            if (depositor != params.intendedDepositor) revert InvalidDepositor(params.intendedDepositor, depositor);\n        }\n\n        // Do nothing if using standard ERC20 approve\n        if (params.signatureParams.approvalMethod == ApprovalMethod.EIP2612_PERMIT) {\n            try IERC20Permit(address(params.offerAsset))\n                .permit(\n                    depositor,\n                    address(this),\n                    params.amountOffer,\n                    params.signatureParams.deadline,\n                    params.signatureParams.approvalV,\n                    params.signatureParams.approvalR,\n                    params.signatureParams.approvalS\n                ) { }\n            catch {\n                if (params.offerAsset.allowance(depositor, address(this)) < params.amountOffer) {\n                    revert PermitFailedAndAllowanceTooLow();\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice helper to get want amount in want decimals from an amount of offer asset\n     */\n    function _getWantAmountInWantDecimals(\n        uint128 amountOfferAfterFees,\n        IERC20 offerAsset,\n        IERC20 wantAsset\n    )\n        internal\n        view\n        returns (uint128 amountWant)\n    {\n        uint8 offerDecimals = IERC20Metadata(address(offerAsset)).decimals();\n        uint8 wantDecimals = IERC20Metadata(address(wantAsset)).decimals();\n\n        if (offerDecimals == wantDecimals) {\n            return amountOfferAfterFees;\n        }\n\n        if (offerDecimals > wantDecimals) {\n            uint8 difference = offerDecimals - wantDecimals;\n            return amountOfferAfterFees / uint128(10 ** difference);\n        }\n\n        uint8 difference = wantDecimals - offerDecimals;\n        return amountOfferAfterFees * uint128(10 ** difference);\n    }\n\n    /// @notice helper to revert with a specific orderIndex when the queue runs out of balance\n    function _checkBalanceQueue(IERC20 asset, uint256 amount, uint256 orderIndex) internal view {\n        uint256 balance = asset.balanceOf(address(this));\n        if (balance < amount) {\n            revert InsufficientBalanceInQueue(orderIndex, address(asset), amount, balance);\n        }\n    }\n\n    /**\n     * @dev From SafeERC20 library: _callOptionalReturnBool(): Do a safe transfer and return a bool instead of reverting\n     * This is a function in SafeERC20 but is private so we need to replicate it here\n     */\n    function _callOptionalReturnBool(IERC20 token, address receiver, uint256 amount) internal returns (bool success) {\n        bytes memory data = abi.encodeWithSelector(token.transfer.selector, receiver, amount);\n\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        success = success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n\n    /// @notice force refund an order in the queue even if it's not at the front. Users will be refunded the offer\n    /// asset. Refund is inclusive of fees paid\n    function _forceRefund(uint256 orderIndex) internal {\n        Order memory order = _getOrderEnsureDefault(orderIndex);\n\n        // Mark as refunded\n        queue[orderIndex].orderType = OrderType.REFUND;\n\n        _checkBalanceQueue(order.offerAsset, order.amountOffer, orderIndex);\n        _burn(orderIndex);\n\n        // From SafeERC20 library to perform a safeERC20 transfer and return a bool on success. Implemented here\n        // since it's private and we cannot call it directly It's worth noting that there are some tokens like\n        // Tether Gold that return false while succeeding.\n        // This situation would result success in being false even though the transfer did not revert.\n        bool success = _callOptionalReturnBool(order.offerAsset, order.refundReceiver, order.amountOffer);\n\n        // If the transfer to the receiver fails, we mark the order as FAILED_TRANSFER and transfer the tokens to a\n        // recoveryAddress. This is because the queue could possibly be greifed by setting a blacklisted addresses as\n        // the refund receiver and block the refund ability. We handle this by taking the funds to the\n        // recoveryAddress to distribute to the user once they become un-blacklisted or otherwise determine a scheme\n        // for distribution\n        if (!success) {\n            // Set the type for the storage and memory as we will emit the memory order. The only difference is the\n            // REFUND status which we override as FAILED_TRANSFER\n            order.didOrderFailTransfer = true;\n            queue[orderIndex].didOrderFailTransfer = true;\n            order.offerAsset.safeTransfer(recoveryAddress, order.amountOffer);\n            emit OrderFailedTransfer(orderIndex, recoveryAddress, order.refundReceiver, order);\n        }\n\n        emit OrderRefunded(orderIndex, queue[orderIndex]);\n    }\n\n    /// @notice force process an order in the queue even if it's not at the front\n    function _forceProcess(uint256 orderIndex) internal {\n        Order memory order = _getOrderEnsureDefault(orderIndex);\n\n        // Mark as pre-filled\n        queue[orderIndex].orderType = OrderType.PRE_FILLED;\n\n        address receiver = ownerOf(orderIndex);\n        _checkBalanceQueue(order.wantAsset, order.amountWant, orderIndex);\n        _burn(orderIndex);\n        order.wantAsset.safeTransfer(receiver, order.amountWant);\n\n        emit OrderProcessed(orderIndex, queue[orderIndex], receiver, true);\n    }\n\n    /// @return order after checking index is a real order and is DEFAULT status\n    function _getOrderEnsureDefault(uint256 orderIndex) internal returns (Order memory order) {\n        // The orderIndex != 0 check is redundant and checked below but more accurate description in the error\n        // InvalidOrderIndex\n        if (orderIndex > latestOrder || orderIndex == 0) revert InvalidOrderIndex(orderIndex);\n        if (orderIndex <= lastProcessedOrder) revert OrderAlreadyProcessed(orderIndex);\n\n        order = queue[orderIndex];\n\n        // require order is set to DEFAULT status\n        if (order.orderType != OrderType.DEFAULT) revert InvalidOrderStatus(orderIndex, order.orderType);\n    }\n\n}\n"
    }
}