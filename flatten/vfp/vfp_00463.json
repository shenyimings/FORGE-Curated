{
    "vfp_id": "vfp_00463",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Code optimizations",
            "description": "Several functions contain suboptimal code patterns that could be improved for readability or gas efficiency. In ModuleManager.sol, a require statement could be replaced with a revert pattern for better error handling. In ERC165Handler.sol, loops use conditional checks (i > 0) before XOR operations, which are unnecessary because XOR with zero is idempotent. Removing these conditions would simplify the code without increasing gas costs. The root cause is a lack of optimization during implementation. The impact is informational, as these are code quality improvements rather than security fixes. The recommendations were implemented post-audit.\n",
            "severity": "Informational",
            "location": [
                "ModuleManager.sol::preModuleExecution#104",
                "ERC165Handler.sol::addSupportedInterfaceBatch#57-67",
                "ERC165Handler.sol::removeSupportedInterfaceBatch#80-89"
            ],
            "files": [
                "safe-smart-account/contracts/base/ModuleManager.sol",
                "safe-smart-account/contracts/handler/extensible/ERC165Handler.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC165Handler.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC165} from \"../../interfaces/IERC165.sol\";\nimport {ISafe, MarshalLib, ExtensibleBase} from \"./ExtensibleBase.sol\";\n\ninterface IERC165Handler {\n    function safeInterfaces(ISafe safe, bytes4 interfaceId) external view returns (bool);\n\n    function setSupportedInterface(bytes4 interfaceId, bool supported) external;\n\n    function addSupportedInterfaceBatch(bytes4 interfaceId, bytes32[] calldata handlerWithSelectors) external;\n\n    function removeSupportedInterfaceBatch(bytes4 interfaceId, bytes4[] calldata selectors) external;\n}\n\nabstract contract ERC165Handler is ExtensibleBase, IERC165Handler {\n    // --- events ---\n\n    event AddedInterface(ISafe indexed safe, bytes4 interfaceId);\n    event RemovedInterface(ISafe indexed safe, bytes4 interfaceId);\n\n    // --- storage ---\n\n    mapping(ISafe => mapping(bytes4 => bool)) public override safeInterfaces;\n\n    // --- setters ---\n\n    /**\n     * Setter to indicate if an interface is supported (and thus reported by ERC165 supportsInterface)\n     * @param interfaceId The interface id whose support is to be set\n     * @param supported True if the interface is supported, false otherwise\n     */\n    function setSupportedInterface(bytes4 interfaceId, bool supported) public override onlySelf {\n        ISafe safe = ISafe(payable(_manager()));\n        // invalid interface id per ERC165 spec\n        require(interfaceId != 0xffffffff, \"invalid interface id\");\n        mapping(bytes4 => bool) storage safeInterface = safeInterfaces[safe];\n        bool current = safeInterface[interfaceId];\n        if (supported != current) {\n            safeInterface[interfaceId] = supported;\n            if (supported) {\n                emit AddedInterface(safe, interfaceId);\n            } else {\n                emit RemovedInterface(safe, interfaceId);\n            }\n        }\n    }\n\n    /**\n     * Batch add selectors for an interface.\n     * @param _interfaceId The interface id to set\n     * @param handlerWithSelectors The handlers encoded with the 4-byte selectors of the methods\n     */\n    function addSupportedInterfaceBatch(bytes4 _interfaceId, bytes32[] calldata handlerWithSelectors) external override onlySelf {\n        ISafe safe = ISafe(payable(_msgSender()));\n        bytes4 interfaceId;\n        uint256 len = handlerWithSelectors.length;\n        for (uint256 i = 0; i < len; ++i) {\n            (bool isStatic, bytes4 selector, address handlerAddress) = MarshalLib.decodeWithSelector(handlerWithSelectors[i]);\n            _setSafeMethod(safe, selector, MarshalLib.encode(isStatic, handlerAddress));\n            if (i > 0) {\n                interfaceId ^= selector;\n            } else {\n                interfaceId = selector;\n            }\n        }\n\n        require(interfaceId == _interfaceId, \"interface id mismatch\");\n        setSupportedInterface(_interfaceId, true);\n    }\n\n    /**\n     * Batch remove selectors for an interface.\n     * @param _interfaceId the interface id to remove\n     * @param selectors The selectors of the methods to remove\n     */\n    function removeSupportedInterfaceBatch(bytes4 _interfaceId, bytes4[] calldata selectors) external override onlySelf {\n        ISafe safe = ISafe(payable(_msgSender()));\n        bytes4 interfaceId;\n        uint256 len = selectors.length;\n        for (uint256 i = 0; i < len; ++i) {\n            _setSafeMethod(safe, selectors[i], bytes32(0));\n            if (i > 0) {\n                interfaceId ^= selectors[i];\n            } else {\n                interfaceId = selectors[i];\n            }\n        }\n\n        require(interfaceId == _interfaceId, \"interface id mismatch\");\n        setSupportedInterface(_interfaceId, false);\n    }\n\n    /**\n     * @notice Implements ERC165 interface detection for the supported interfaces\n     * @dev Inheriting contracts should override `_supportsInterface` to add support for additional interfaces\n     * @param interfaceId The ERC165 interface id to check\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC165Handler).interfaceId ||\n            _supportsInterface(interfaceId) ||\n            safeInterfaces[ISafe(payable(_manager()))][interfaceId];\n    }\n\n    // --- internal ---\n\n    /**\n     * A stub function to be overridden by inheriting contracts to add support for additional interfaces\n     * @param interfaceId The interface id to check support for\n     * @return True if the interface is supported\n     */\n    function _supportsInterface(bytes4 interfaceId) internal view virtual returns (bool);\n}\n",
        "ModuleManager.sol": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\nimport {SelfAuthorized} from \"./../common/SelfAuthorized.sol\";\nimport {IERC165} from \"./../interfaces/IERC165.sol\";\nimport {IModuleManager} from \"./../interfaces/IModuleManager.sol\";\nimport {Enum} from \"./../libraries/Enum.sol\";\nimport {Executor} from \"./Executor.sol\";\n\n/**\n * @title IModuleGuard Interface\n */\ninterface IModuleGuard is IERC165 {\n    /**\n     * @notice Checks the module transaction details.\n     * @dev The function needs to implement module transaction validation logic.\n     * @param to The address to which the transaction is intended.\n     * @param value The value of the transaction in Wei.\n     * @param data The transaction data.\n     * @param operation The type of operation of the module transaction.\n     * @param module The module involved in the transaction.\n     * @return moduleTxHash The hash of the module transaction.\n     */\n    function checkModuleTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        address module\n    ) external returns (bytes32 moduleTxHash);\n\n    /**\n     * @notice Checks after execution of module transaction.\n     * @dev The function needs to implement a check after the execution of the module transaction.\n     * @param txHash The hash of the module transaction.\n     * @param success The status of the module transaction execution.\n     */\n    function checkAfterModuleExecution(bytes32 txHash, bool success) external;\n}\n\nabstract contract BaseModuleGuard is IModuleGuard {\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(IModuleGuard).interfaceId || // 0x58401ed8\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n\n/**\n * @title Module Manager - A contract managing Safe modules\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \n           so only trusted and audited modules should be added to a Safe. A malicious module can\n           completely takeover a Safe.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\nabstract contract ModuleManager is SelfAuthorized, Executor, IModuleManager {\n    // SENTINEL_MODULES is used to traverse `modules`, so that:\n    //      1. `modules[SENTINEL_MODULES]` contains the first module\n    //      2. `modules[last_module]` points back to SENTINEL_MODULES\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    // keccak256(\"module_manager.module_guard.address\")\n    bytes32 internal constant MODULE_GUARD_STORAGE_SLOT = 0xb104e0b93118902c651344349b610029d694cfdec91c589c91ebafbcd0289947;\n\n    mapping(address => address) internal modules;\n\n    /**\n     * @notice Setup function sets the initial storage of the contract.\n     *         Optionally executes a delegate call to another contract to setup the modules.\n     * @param to Optional destination address of the call to execute.\n     * @param data Optional data of call to execute.\n     */\n    function setupModules(address to, bytes memory data) internal {\n        if (modules[SENTINEL_MODULES] != address(0)) revertWithError(\"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0)) {\n            if (!isContract(to)) revertWithError(\"GS002\");\n            // Setup has to complete successfully or the transaction fails.\n            if (!execute(to, 0, data, Enum.Operation.DelegateCall, type(uint256).max)) revertWithError(\"GS000\");\n        }\n    }\n\n    /**\n     * @notice Runs pre-execution checks for module transactions if a guard is enabled.\n     * @param to Target address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return guard Guard to be used for checking.\n     * @return guardHash Hash returned from the guard tx check.\n     */\n    function preModuleExecution(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (address guard, bytes32 guardHash) {\n        onBeforeExecTransactionFromModule(to, value, data, operation);\n        guard = getModuleGuard();\n\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n\n        if (guard != address(0)) {\n            guardHash = IModuleGuard(guard).checkModuleTransaction(to, value, data, operation, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Runs post-execution checks for module transactions if a guard is enabled.\n     * @param guardHash Hash returned from the guard during pre execution check.\n     * @param success Boolean flag indicating if the call succeeded.\n     * @param guard Guard to be used for checking.\n     * @dev Emits event based on module transaction success.\n     */\n    function postModuleExecution(address guard, bytes32 guardHash, bool success) internal {\n        if (guard != address(0)) {\n            IModuleGuard(guard).checkAfterModuleExecution(guardHash, success);\n        }\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function enableModule(address module) public override authorized {\n        // Module address cannot be null or sentinel.\n        if (module == address(0) || module == SENTINEL_MODULES) revertWithError(\"GS101\");\n        // Module cannot be added twice.\n        if (modules[module] != address(0)) revertWithError(\"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function disableModule(address prevModule, address module) public override authorized {\n        // Validate module address and check that it corresponds to module index.\n        if (module == address(0) || module == SENTINEL_MODULES) revertWithError(\"GS101\");\n        if (modules[prevModule] != module) revertWithError(\"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external override returns (bool success) {\n        (address guard, bytes32 guardHash) = preModuleExecution(to, value, data, operation);\n        success = execute(to, value, data, operation, type(uint256).max);\n        postModuleExecution(guard, guardHash, success);\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external override returns (bool success, bytes memory returnData) {\n        (address guard, bytes32 guardHash) = preModuleExecution(to, value, data, operation);\n        success = execute(to, value, data, operation, type(uint256).max);\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load free memory location\n            returnData := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(returnData, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(returnData, returndatasize())\n            // Store the data\n            returndatacopy(add(returnData, 0x20), 0, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n        postModuleExecution(guard, guardHash, success);\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function isModuleEnabled(address module) public view override returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function getModulesPaginated(address start, uint256 pageSize) external view override returns (address[] memory array, address next) {\n        if (start != SENTINEL_MODULES && !isModuleEnabled(start)) revertWithError(\"GS105\");\n        if (pageSize == 0) revertWithError(\"GS106\");\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        next = modules[start];\n        while (next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = next;\n            next = modules[next];\n            ++moduleCount;\n        }\n\n        /**\n          Because of the argument validation, we can assume that the loop will always iterate over the valid module list values\n          and the `next` variable will either be an enabled module or a sentinel address (signalling the end). \n          \n          If we haven't reached the end inside the loop, we need to set the next pointer to the last element of the modules array\n          because the `next` variable (which is a module by itself) acting as a pointer to the start of the next page is neither \n          included to the current page, nor will it be included in the next one if you pass it as a start.\n        */\n        if (next != SENTINEL_MODULES) {\n            next = array[moduleCount - 1];\n        }\n        // Set the correct size of the returned array\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This function will return false if invoked during the constructor of a contract,\n     *      as the code is not created until after the constructor finishes.\n     * @param account The address being queried\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        /* solhint-enable no-inline-assembly */\n        return size > 0;\n    }\n\n    /**\n     * @inheritdoc IModuleManager\n     */\n    function setModuleGuard(address moduleGuard) external override authorized {\n        if (moduleGuard != address(0) && !IModuleGuard(moduleGuard).supportsInterface(type(IModuleGuard).interfaceId))\n            revertWithError(\"GS301\");\n\n        bytes32 slot = MODULE_GUARD_STORAGE_SLOT;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(slot, moduleGuard)\n        }\n        /* solhint-enable no-inline-assembly */\n        emit ChangedModuleGuard(moduleGuard);\n    }\n\n    /**\n     * @dev Internal method to retrieve the current module guard\n     * @return moduleGuard The address of the guard\n     */\n    function getModuleGuard() internal view returns (address moduleGuard) {\n        bytes32 slot = MODULE_GUARD_STORAGE_SLOT;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            moduleGuard := sload(slot)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @notice A hook that gets called before execution of {execTransactionFromModule*} methods.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function onBeforeExecTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation) internal virtual {}\n}\n"
    }
}