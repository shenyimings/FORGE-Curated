{
    "vfp_id": "vfp_00463",
    "project_name": "cantina_stryke_aug2025.pdf",
    "findings": [
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect comment",
            "description": "In BlackScholes.sol, comments incorrectly state that time is in days, while the implementation uses centidays (1/100 of a day). The root cause is outdated or inaccurate documentation. This could mislead developers or integrators into passing incorrect values. No direct exploitation, but the impact is potential miscalculations in pricing logic if external systems rely on the comment.\n",
            "severity": "Informational",
            "location": [
                "BlackScholes.sol#L28",
                "BlackScholes.sol#L45"
            ],
            "files": [
                "contracts/src/apps/options/pricing/external/BlackScholes.sol"
            ]
        }
    ],
    "affected_files": {
        "BlackScholes.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Libraries\nimport {ABDKMathQuad} from \"./ABDKMathQuad.sol\";\n\n/// @title Black-Scholes option pricing formula and supporting statistical functions\n/// @author Dopex\n/// @notice This library implements the Black-Scholes model to price options.\n/// See - https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model\n/// @dev Implements the following implementation - https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html\n/// Uses the ABDKMathQuad(https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md)\n/// library to make precise calculations. It uses a DIVISOR (1e16) for maintaining precision in constants.\nlibrary BlackScholes {\n    uint8 internal constant OPTION_TYPE_CALL = 0;\n    uint8 internal constant OPTION_TYPE_PUT = 1;\n\n    uint256 internal constant DIVISOR = 10 ** 16;\n\n    /**\n     * @notice The function that uses the Black-Scholes equation to calculate the option price\n     * See http://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model#Black-Scholes_formula\n     * NOTE: The different parts of the equation are broken down to separate functions as using\n     * ABDKMathQuad makes small equations verbose.\n     * @param optionType Type of option - 0 = call, 1 = put\n     * @param price Stock price\n     * @param strike Strike price\n     * @param timeToExpiry Time to expiry in days\n     * @param riskFreeRate Risk-free rate\n     * @param volatility Volatility on the asset\n     * @return Option price based on the Black-Scholes model\n     */\n    function calculate(\n        uint8 optionType,\n        uint256 price,\n        uint256 strike,\n        uint256 timeToExpiry,\n        uint256 riskFreeRate,\n        uint256 volatility\n    ) internal pure returns (uint256) {\n        bytes16 S = ABDKMathQuad.fromUInt(price);\n        bytes16 X = ABDKMathQuad.fromUInt(strike);\n        bytes16 T = ABDKMathQuad.div(\n            ABDKMathQuad.fromUInt(timeToExpiry),\n            ABDKMathQuad.fromUInt(36500) // 365 * 10 ^ DAYS_PRECISION\n        );\n        bytes16 r = ABDKMathQuad.div(ABDKMathQuad.fromUInt(riskFreeRate), ABDKMathQuad.fromUInt(10000));\n        bytes16 v = ABDKMathQuad.div(ABDKMathQuad.fromUInt(volatility), ABDKMathQuad.fromUInt(100));\n        bytes16 d1 = ABDKMathQuad.div(\n            ABDKMathQuad.add(\n                ABDKMathQuad.ln(ABDKMathQuad.div(S, X)),\n                ABDKMathQuad.mul(\n                    ABDKMathQuad.add(r, ABDKMathQuad.mul(v, ABDKMathQuad.div(v, ABDKMathQuad.fromUInt(2)))), T\n                )\n            ),\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\n        );\n        bytes16 d2 = ABDKMathQuad.sub(d1, ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T)));\n        if (optionType == OPTION_TYPE_CALL) {\n            return ABDKMathQuad.toUInt(\n                ABDKMathQuad.mul(_calculateCallTimeDecay(S, d1, X, r, T, d2), ABDKMathQuad.fromUInt(DIVISOR))\n            );\n        } else if (optionType == OPTION_TYPE_PUT) {\n            return ABDKMathQuad.toUInt(\n                ABDKMathQuad.mul(_calculatePutTimeDecay(X, r, T, d2, S, d1), ABDKMathQuad.fromUInt(DIVISOR))\n            );\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev Function to caluclate the call time decay\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation\n    /// ( S * CND(d1)-X * Math.exp(-r * T) * CND(d2) );\n    function _calculateCallTimeDecay(bytes16 S, bytes16 d1, bytes16 X, bytes16 r, bytes16 T, bytes16 d2)\n        internal\n        pure\n        returns (bytes16)\n    {\n        return ABDKMathQuad.sub(\n            ABDKMathQuad.mul(S, CND(d1)),\n            ABDKMathQuad.mul(ABDKMathQuad.mul(X, ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))), CND(d2))\n        );\n    }\n\n    /// @dev Function to caluclate the put time decay\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\n    /// ( X * Math.exp(-r * T) * CND(-d2) - S * CND(-d1) );\n    function _calculatePutTimeDecay(bytes16 X, bytes16 r, bytes16 T, bytes16 d2, bytes16 S, bytes16 d1)\n        internal\n        pure\n        returns (bytes16)\n    {\n        bytes16 price_part1 = ABDKMathQuad.mul(\n            ABDKMathQuad.mul(X, ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))), CND(ABDKMathQuad.neg(d2))\n        );\n        bytes16 price_part2 = ABDKMathQuad.mul(S, CND(ABDKMathQuad.neg(d1)));\n        bytes16 price = ABDKMathQuad.sub(price_part1, price_part2);\n        return price;\n    }\n\n    /**\n     * @notice Normal cumulative distribution function.\n     * See http://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function\n     * From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\n     * \"k = 1 / (1 + .2316419 * x); return ( 1 - Math.exp(-x * x / 2)/ Math.sqrt(2*Math.PI) * k * (.31938153 + k * (-.356563782 + k * (1.781477937 + k * (-1.821255978 + k * 1.330274429)))) );\"\n     * NOTE: The different parts of the equation are broken down to separate functions as using\n     * ABDKMathQuad makes small equations verbose.\n     */\n    function CND(bytes16 x) internal pure returns (bytes16) {\n        if (ABDKMathQuad.toInt(x) < 0) {\n            return (ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND(ABDKMathQuad.neg(x))));\n        } else {\n            bytes16 k = ABDKMathQuad.div(\n                ABDKMathQuad.fromUInt(1),\n                ABDKMathQuad.add(\n                    ABDKMathQuad.fromUInt(1),\n                    ABDKMathQuad.mul(\n                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(2316419000000000), ABDKMathQuad.fromUInt(DIVISOR)), x\n                    )\n                )\n            );\n            bytes16 CND_part2 = _getCNDPart2(k, x);\n            return ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND_part2);\n        }\n    }\n\n    function _getCNDPart2(bytes16 k, bytes16 x) internal pure returns (bytes16) {\n        return ABDKMathQuad.mul(_getCNDPart2_1(x), _getCNDPart2_2(k));\n    }\n\n    function _getCNDPart2_1(bytes16 x) internal pure returns (bytes16) {\n        return ABDKMathQuad.div(\n            ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(x), ABDKMathQuad.div(x, ABDKMathQuad.fromUInt(2)))),\n            ABDKMathQuad.sqrt(\n                ABDKMathQuad.mul(\n                    ABDKMathQuad.fromUInt(2),\n                    ABDKMathQuad.div(ABDKMathQuad.fromUInt(31415926530000000), ABDKMathQuad.fromUInt(DIVISOR))\n                )\n            )\n        );\n    }\n\n    function _getCNDPart2_2(bytes16 k) internal pure returns (bytes16) {\n        return ABDKMathQuad.mul(\n            ABDKMathQuad.add(\n                ABDKMathQuad.div(ABDKMathQuad.fromUInt(3193815300000000), ABDKMathQuad.fromUInt(DIVISOR)),\n                ABDKMathQuad.mul(\n                    k,\n                    ABDKMathQuad.add(\n                        ABDKMathQuad.neg(\n                            ABDKMathQuad.div(ABDKMathQuad.fromUInt(3565637820000000), ABDKMathQuad.fromUInt(DIVISOR))\n                        ),\n                        ABDKMathQuad.mul(\n                            k,\n                            ABDKMathQuad.add(\n                                ABDKMathQuad.div(\n                                    ABDKMathQuad.fromUInt(17814779370000000), ABDKMathQuad.fromUInt(DIVISOR)\n                                ),\n                                _getCNDPart2_2_1(k)\n                            )\n                        )\n                    )\n                )\n            ),\n            k\n        );\n    }\n\n    function _getCNDPart2_2_1(bytes16 k) internal pure returns (bytes16) {\n        return ABDKMathQuad.mul(\n            k,\n            ABDKMathQuad.add(\n                ABDKMathQuad.neg(\n                    ABDKMathQuad.div(ABDKMathQuad.fromUInt(18212559780000000), ABDKMathQuad.fromUInt(DIVISOR))\n                ),\n                ABDKMathQuad.mul(\n                    k, ABDKMathQuad.div(ABDKMathQuad.fromUInt(13302744290000000), ABDKMathQuad.fromUInt(DIVISOR))\n                )\n            )\n        );\n    }\n}\n"
    }
}