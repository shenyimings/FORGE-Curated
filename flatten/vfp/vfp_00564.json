{
    "vfp_id": "vfp_00564",
    "project_name": "cantina_seamless_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect rounding in _convertToShares for withdrawal-based actions leads to 1 dead share for users",
            "description": "1. **Description:** The _convertToShares function uses floor rounding in all cases, which causes a loss of one share for users during withdrawal-based actions due to incorrect rounding direction.\n2. **Cause:** The function does not adjust rounding based on the type of action (deposit vs. withdrawal), always applying Math.Rounding.Floor regardless of context.\n3. **Exploitation:** Users withdrawing funds will receive slightly fewer shares than they should due to the floor rounding, effectively losing a small amount of value per withdrawal.\n4. **Impact:** This leads to a systematic loss of user funds on every withdrawal, reducing the accuracy of share conversion and eroding user trust.\n",
            "severity": "Medium",
            "location": [
                "LeverageManager.sol::#L349-L362",
                "LeverageManager.sol::#L381",
                "LeverageManager.sol::#L419"
            ],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Protect external facing LeverageManager functions from reentrancy",
            "description": "1. **Description:** Several external functions in the LeverageManager contract, such as deposit, withdraw, rebalance, and createNewLeverageToken, perform state changes and external calls without reentrancy protection.\n2. **Cause:** The absence of a nonReentrant modifier or similar guard allows potential reentrancy attacks, especially during rebalance operations where state can be manipulated mid-execution.\n3. **Exploitation:** An attacker could exploit reentrancy during rebalance to manipulate the state of a leveraged token, potentially putting it into an invalid state that bypasses validation checks.\n4. **Impact:** This could lead to temporary invalid states in leveraged tokens, disrupting system integrity and potentially enabling further exploits or fund loss.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Remove configurability of DECIMALS_OFFSET parameter or account for offset in LeverageToken contract",
            "description": "1. **Description:** The DECIMALS_OFFSET parameter in LeverageManager is not properly accounted for in the LeverageToken contract's decimals() function, leading to potential inconsistencies in virtual share calculations.\n2. **Cause:** If DECIMALS_OFFSET is set to a non-zero value before deployment, the LeverageToken does not adjust its decimals accordingly, causing misalignment in share representation.\n3. **Exploitation:** An incorrect configuration could result in miscalculations of share values during deposits and withdrawals, especially when virtual shares are involved.\n4. **Impact:** This may lead to incorrect equity distribution among users and potential loss of funds due to inaccurate share conversions.\n",
            "severity": "Low",
            "location": [
                "LeverageManager.sol::#L65",
                "LeverageManager.sol::#L358",
                "LeverageToken.sol::#L20"
            ],
            "files": [
                "leverage-tokens/src/LeverageManager.sol",
                "leverage-tokens/src/LeverageToken.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Fractional collateral remainder from a rebalance could be pulled with lone removeCollateral action",
            "description": "1. **Description:** A fractional amount of collateral remaining after a rebalance can be withdrawn by a user calling removeCollateral without providing any input tokens.\n2. **Cause:** The rebalance logic does not fully account for small leftover collateral amounts, allowing them to be claimed by subsequent users via removeCollateral.\n3. **Exploitation:** A user can call removeCollateral with no inputs and still receive a small amount of leftover collateral from previous operations.\n4. **Impact:** This results in unintended transfer of value to opportunistic users, leading to loss of funds for the original stakeholders.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "createNewLeverageToken is permissionless and accepts any adapters, including possibly malicious",
            "description": "1. **Description:** The createNewLeverageToken function allows anyone to create a new leverage token using any lending adapter, including untrusted or malicious ones.\n2. **Cause:** There is no whitelist or validation mechanism in place to restrict which adapters can be used during token creation.\n3. **Exploitation:** An attacker could deploy a malicious adapter and trick users into interacting with a leverage token that uses it, leading to theft of funds.\n4. **Impact:** Users may unknowingly interact with unsafe contracts, resulting in loss of funds and reduced trust in the platform.\n",
            "severity": "Informational",
            "location": [
                "LeverageManager.sol::#L162",
                "LeverageManager.sol::#L176-L179"
            ],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "MorphoLendingAdapter is susceptible to oracle collusion or manipulation",
            "description": "1. **Description:** The MorphoLendingAdapter relies on external oracle data for critical pricing decisions, making it vulnerable to oracle manipulation or collusion attacks.\n2. **Cause:** The adapter uses price feeds from Morpho, which may be influenced by coordinated attacks or inaccurate data sources.\n3. **Exploitation:** Attackers could manipulate the oracle to report false prices, leading to incorrect valuation of collateral and debt during rebalancing or liquidation.\n4. **Impact:** This could result in unfair liquidations, incorrect leverage adjustments, or loss of user funds due to mispriced assets.\n",
            "severity": "Informational",
            "location": [
                "MorphoLendingAdapter.sol::#L104-L121"
            ],
            "files": [
                "leverage-tokens/src/lending/MorphoLendingAdapter.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Rebalancers must correctly specify tokensOut when rebalancing or lose tokens to others",
            "description": "1. **Description:** Rebalancers must provide exact values for the tokensOut parameter during rebalancing; otherwise, excess tokens may be left in the contract or the transaction may revert.\n2. **Cause:** The LeverageManager does not automatically transfer all resulting token balances after rebalancing, relying instead on precise user input.\n3. **Exploitation:** If a rebalancer underestimates tokensOut, leftover tokens remain in the contract and could be drained by others; if overestimated, the transaction reverts.\n4. **Impact:** This creates operational risk for rebalancers and potential loss of funds due to incorrect parameter specification.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "leverage-tokens/src/LeverageManager.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "General notes on morpho markets integration",
            "description": "1. **Description:** The integration with Morpho markets introduces risks related to re-entrancy and on-chain pricing mechanisms, particularly because leverage tokens use convertToShares/assets functions that can be influenced during callbacks.\n2. **Cause:** The leverage manager is not re-entrancy safe and may be called in the context of Morpho callbacks, potentially allowing manipulation of price() values through read-only re-entrancy.\n3. **Exploitation:** An attacker could manipulate the execution context during a callback to influence pricing calculations, leading to incorrect valuations.\n4. **Impact:** This could result in incorrect pricing of assets within leverage tokens, affecting rebalancing accuracy and potentially leading to financial loss.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "leverage-tokens/src/LeverageManager.sol",
                "leverage-tokens/src/lending/MorphoLendingAdapter.sol"
            ]
        }
    ],
    "affected_files": {
        "LeverageToken.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Dependency imports\nimport {ERC20PermitUpgradeable} from\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n// Internal imports\nimport {ILeverageToken} from \"src/interfaces/ILeverageToken.sol\";\n\n/**\n * @dev The LeverageToken contract is an upgradeable ERC20 token that represents a claim to the equity held by the LeverageToken.\n * It is used to represent a user's claim to the equity held by the LeverageToken in the LeverageManager.\n */\ncontract LeverageToken is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20PermitUpgradeable,\n    OwnableUpgradeable,\n    ILeverageToken\n{\n    function initialize(address _owner, string memory _name, string memory _symbol) external initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        __Ownable_init(_owner);\n\n        emit ILeverageToken.LeverageTokenInitialized(_name, _symbol);\n    }\n\n    /// @inheritdoc ILeverageToken\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    /// @inheritdoc ILeverageToken\n    function burn(address from, uint256 amount) external onlyOwner {\n        _burn(from, amount);\n    }\n}\n",
        "LeverageManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\n// Dependency imports\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n// Internal imports\nimport {IRebalanceAdapterBase} from \"src/interfaces/IRebalanceAdapterBase.sol\";\nimport {IBeaconProxyFactory} from \"src/interfaces/IBeaconProxyFactory.sol\";\nimport {ILendingAdapter} from \"src/interfaces/ILendingAdapter.sol\";\nimport {ILeverageManager} from \"src/interfaces/ILeverageManager.sol\";\nimport {ILeverageToken} from \"src/interfaces/ILeverageToken.sol\";\nimport {FeeManager} from \"src/FeeManager.sol\";\nimport {LeverageTokenState} from \"src/types/DataTypes.sol\";\nimport {LeverageToken} from \"src/LeverageToken.sol\";\nimport {\n    ActionData,\n    ActionType,\n    ExternalAction,\n    LeverageTokenConfig,\n    BaseLeverageTokenConfig,\n    RebalanceAction,\n    TokenTransfer\n} from \"src/types/DataTypes.sol\";\n\n/**\n * @dev The LeverageManager contract is an upgradeable core contract that is responsible for managing the creation of LeverageTokens.\n * It also acts as an entry point for users to deposit and withdraw equity from the position held by the LeverageToken, and for\n * rebalancers to rebalance LeverageTokens.\n *\n * LeverageTokens are ERC20 tokens that are akin to shares in an ERC-4626 vault - they represent a claim on the equity held by\n * the LeverageToken. They can be created on this contract by calling `createNewLeverageToken`, and their configuration on the\n * LeverageManager is immutable.\n * Note: Although the LeverageToken configuration saved on the LeverageManager is immutable, the configured LendingAdapter and\n *       RebalanceAdapter for the LeverageToken may be upgradeable contracts.\n *\n * The LeverageManager also inherits the `FeeManager` contract, which is used to manage LeverageToken fees (which accrue to\n * the share value of the LeverageToken) and the treasury fees.\n *\n * For deposits of equity into a LeverageToken, the collateral and debt required is calculated by using the LeverageToken's\n * current collateral ratio. As such, the collateral ratio after a deposit must be equal to the collateral ratio before a\n * deposit, within some rounding error.\n *\n * [CAUTION]\n * ====\n * LeverageTokens are susceptible to inflation attacks like ERC-4626 vaults:\n *   \"In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n *   with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n *   attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n *   deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n *   similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n *   verifying the amount received is as expected, using a wrapper that performs these checks such as\n *   https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\"\n *\n * As such it is highly recommended that LeverageToken creators make an initial deposit of a non-trivial amount of equity.\n * It is also recommended to use a router that performs slippage checks when depositing and withdrawing.\n */\ncontract LeverageManager is ILeverageManager, AccessControlUpgradeable, FeeManager, UUPSUpgradeable {\n    // Base collateral ratio constant, 1e18 means that collateral / debt ratio is 1:1\n    uint256 public constant BASE_RATIO = 1e18;\n    uint256 public constant DECIMALS_OFFSET = 0;\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    /// @dev Struct containing all state for the LeverageManager contract\n    /// @custom:storage-location erc7201:seamless.contracts.storage.LeverageManager\n    struct LeverageManagerStorage {\n        /// @dev Factory for deploying new LeverageTokens\n        IBeaconProxyFactory tokenFactory;\n        /// @dev LeverageToken address => Base config for LeverageToken\n        mapping(ILeverageToken token => BaseLeverageTokenConfig) config;\n    }\n\n    function _getLeverageManagerStorage() internal pure returns (LeverageManagerStorage storage $) {\n        // slither-disable-next-line assembly\n        assembly {\n            // keccak256(abi.encode(uint256(keccak256(\"seamless.contracts.storage.LeverageManager\")) - 1)) & ~bytes32(uint256(0xff));\n            $.slot := 0x326e20d598a681eb69bc11b5176604d340fccf9864170f09484f3c317edf3600\n        }\n    }\n\n    function initialize(address initialAdmin, IBeaconProxyFactory leverageTokenFactory) external initializer {\n        __FeeManager_init(initialAdmin);\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n        _getLeverageManagerStorage().tokenFactory = leverageTokenFactory;\n        emit LeverageManagerInitialized(leverageTokenFactory);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenFactory() public view returns (IBeaconProxyFactory factory) {\n        return _getLeverageManagerStorage().tokenFactory;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenCollateralAsset(ILeverageToken token) public view returns (IERC20 collateralAsset) {\n        return getLeverageTokenLendingAdapter(token).getCollateralAsset();\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenDebtAsset(ILeverageToken token) public view returns (IERC20 debtAsset) {\n        return getLeverageTokenLendingAdapter(token).getDebtAsset();\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenRebalanceAdapter(ILeverageToken token)\n        public\n        view\n        returns (IRebalanceAdapterBase module)\n    {\n        return _getLeverageManagerStorage().config[token].rebalanceAdapter;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenConfig(ILeverageToken token) external view returns (LeverageTokenConfig memory config) {\n        BaseLeverageTokenConfig memory baseConfig = _getLeverageManagerStorage().config[token];\n        uint256 depositTokenFee = getLeverageTokenActionFee(token, ExternalAction.Deposit);\n        uint256 withdrawTokenFee = getLeverageTokenActionFee(token, ExternalAction.Withdraw);\n\n        return LeverageTokenConfig({\n            lendingAdapter: baseConfig.lendingAdapter,\n            rebalanceAdapter: baseConfig.rebalanceAdapter,\n            depositTokenFee: depositTokenFee,\n            withdrawTokenFee: withdrawTokenFee\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenLendingAdapter(ILeverageToken token) public view returns (ILendingAdapter adapter) {\n        return _getLeverageManagerStorage().config[token].lendingAdapter;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenInitialCollateralRatio(ILeverageToken token) public view returns (uint256 ratio) {\n        return getLeverageTokenRebalanceAdapter(token).getLeverageTokenInitialCollateralRatio(token);\n    }\n\n    /// @inheritdoc ILeverageManager\n    function getLeverageTokenState(ILeverageToken token) public view returns (LeverageTokenState memory state) {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        uint256 collateral = lendingAdapter.getCollateralInDebtAsset();\n        uint256 debt = lendingAdapter.getDebt();\n        uint256 equity = lendingAdapter.getEquityInDebtAsset();\n\n        uint256 collateralRatio =\n            debt > 0 ? Math.mulDiv(collateral, BASE_RATIO, debt, Math.Rounding.Floor) : type(uint256).max;\n\n        return LeverageTokenState({\n            collateralInDebtAsset: collateral,\n            debt: debt,\n            equity: equity,\n            collateralRatio: collateralRatio\n        });\n    }\n\n    /// @inheritdoc ILeverageManager\n    function createNewLeverageToken(LeverageTokenConfig calldata tokenConfig, string memory name, string memory symbol)\n        external\n        returns (ILeverageToken token)\n    {\n        IBeaconProxyFactory tokenFactory = getLeverageTokenFactory();\n\n        // slither-disable-next-line reentrancy-events\n        token = ILeverageToken(\n            tokenFactory.createProxy(\n                abi.encodeWithSelector(LeverageToken.initialize.selector, address(this), name, symbol),\n                bytes32(tokenFactory.numProxies())\n            )\n        );\n\n        _getLeverageManagerStorage().config[token] = BaseLeverageTokenConfig({\n            lendingAdapter: tokenConfig.lendingAdapter,\n            rebalanceAdapter: tokenConfig.rebalanceAdapter\n        });\n        _setLeverageTokenActionFee(token, ExternalAction.Deposit, tokenConfig.depositTokenFee);\n        _setLeverageTokenActionFee(token, ExternalAction.Withdraw, tokenConfig.withdrawTokenFee);\n\n        tokenConfig.lendingAdapter.postLeverageTokenCreation(msg.sender, address(token));\n        tokenConfig.rebalanceAdapter.postLeverageTokenCreation(msg.sender, address(token));\n\n        emit LeverageTokenCreated(\n            token,\n            tokenConfig.lendingAdapter.getCollateralAsset(),\n            tokenConfig.lendingAdapter.getDebtAsset(),\n            tokenConfig\n        );\n        return token;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewDeposit(ILeverageToken token, uint256 equityInCollateralAsset)\n        public\n        view\n        returns (ActionData memory)\n    {\n        ActionData memory data = _previewAction(token, equityInCollateralAsset, ExternalAction.Deposit);\n\n        // For deposits, the collateral amount returned by the preview is the total collateral required to execute the\n        // deposit, so we add the treasury fee to it, since the collateral computed above is wrt the equity amount with\n        // the treasury fee subtracted.\n        data.collateral += data.treasuryFee;\n\n        return data;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function previewWithdraw(ILeverageToken token, uint256 equityInCollateralAsset)\n        public\n        view\n        returns (ActionData memory)\n    {\n        ActionData memory data = _previewAction(token, equityInCollateralAsset, ExternalAction.Withdraw);\n\n        // For withdrawals, the collateral amount returned is the collateral transferred to the sender, so we subtract the\n        // treasury fee, since the collateral computed by `previewAction` is wrt the equity amount without the treasury fee\n        // subtracted.\n        // Note: It is possible for collateral to be < treasuryFee because of rounding down for both the share calculation and\n        //       the resulting collateral calculated using those shares in `previewAction`, while the treasury fee is calculated\n        //       based on the initial equity amount rounded up. In this case, we set the collateral to 0 and the treasury fee to\n        //       the computed collateral amount\n        data.treasuryFee = Math.min(data.collateral, data.treasuryFee);\n        data.collateral = data.collateral > data.treasuryFee ? data.collateral - data.treasuryFee : 0;\n\n        return data;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function deposit(ILeverageToken token, uint256 equityInCollateralAsset, uint256 minShares)\n        external\n        returns (ActionData memory actionData)\n    {\n        ActionData memory depositData = previewDeposit(token, equityInCollateralAsset);\n\n        if (depositData.shares < minShares) {\n            revert SlippageTooHigh(depositData.shares, minShares);\n        }\n\n        // Take collateral asset from sender\n        IERC20 collateralAsset = getLeverageTokenCollateralAsset(token);\n        SafeERC20.safeTransferFrom(collateralAsset, msg.sender, address(this), depositData.collateral);\n\n        // Add collateral to LeverageToken\n        _executeLendingAdapterAction(token, ActionType.AddCollateral, depositData.collateral - depositData.treasuryFee);\n\n        // Charge treasury fee\n        _chargeTreasuryFee(collateralAsset, depositData.treasuryFee);\n\n        // Borrow and send debt assets to caller\n        _executeLendingAdapterAction(token, ActionType.Borrow, depositData.debt);\n        SafeERC20.safeTransfer(getLeverageTokenDebtAsset(token), msg.sender, depositData.debt);\n\n        // Mint shares to user\n        // slither-disable-next-line reentrancy-events\n        token.mint(msg.sender, depositData.shares);\n\n        // Emit event and explicit return statement\n        emit Deposit(token, msg.sender, depositData);\n        return depositData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function withdraw(ILeverageToken token, uint256 equityInCollateralAsset, uint256 maxShares)\n        external\n        returns (ActionData memory actionData)\n    {\n        ActionData memory withdrawData = previewWithdraw(token, equityInCollateralAsset);\n\n        if (withdrawData.shares > maxShares) {\n            revert SlippageTooHigh(withdrawData.shares, maxShares);\n        }\n\n        // Burn shares from user and total supply\n        token.burn(msg.sender, withdrawData.shares);\n\n        // Take assets from sender and repay the debt\n        SafeERC20.safeTransferFrom(getLeverageTokenDebtAsset(token), msg.sender, address(this), withdrawData.debt);\n        _executeLendingAdapterAction(token, ActionType.Repay, withdrawData.debt);\n\n        // Withdraw collateral from lending pool\n        _executeLendingAdapterAction(\n            token, ActionType.RemoveCollateral, withdrawData.collateral + withdrawData.treasuryFee\n        );\n\n        // Send collateral assets to sender\n        IERC20 collateralAsset = getLeverageTokenCollateralAsset(token);\n        SafeERC20.safeTransfer(collateralAsset, msg.sender, withdrawData.collateral);\n\n        // Charge treasury fee\n        _chargeTreasuryFee(collateralAsset, withdrawData.treasuryFee);\n\n        // Emit event and explicit return statement\n        emit Withdraw(token, msg.sender, withdrawData);\n        return withdrawData;\n    }\n\n    /// @inheritdoc ILeverageManager\n    function rebalance(\n        RebalanceAction[] calldata actions,\n        TokenTransfer[] calldata tokensIn,\n        TokenTransfer[] calldata tokensOut\n    ) external {\n        _transferTokens(tokensIn, msg.sender, address(this));\n\n        LeverageTokenState[] memory leverageTokensStateBefore = new LeverageTokenState[](actions.length);\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            ILeverageToken leverageToken = actions[i].leverageToken;\n\n            // Check if the LeverageToken is eligible for rebalance if it has not been checked yet in a previous iteration of the loop\n            if (!_isElementInSlice(actions, leverageToken, i)) {\n                LeverageTokenState memory state = getLeverageTokenState(leverageToken);\n                leverageTokensStateBefore[i] = state;\n\n                IRebalanceAdapterBase rebalanceAdapter = getLeverageTokenRebalanceAdapter(leverageToken);\n                if (!rebalanceAdapter.isEligibleForRebalance(leverageToken, state, msg.sender)) {\n                    revert LeverageTokenNotEligibleForRebalance(leverageToken);\n                }\n            }\n\n            _executeLendingAdapterAction(leverageToken, actions[i].actionType, actions[i].amount);\n        }\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            // Validate the LeverageToken state after rebalancing if it has not been validated yet in a previous iteration of the loop\n            if (!_isElementInSlice(actions, actions[i].leverageToken, i)) {\n                ILeverageToken leverageToken = actions[i].leverageToken;\n                IRebalanceAdapterBase rebalanceAdapter = getLeverageTokenRebalanceAdapter(leverageToken);\n\n                if (!rebalanceAdapter.isStateAfterRebalanceValid(leverageToken, leverageTokensStateBefore[i])) {\n                    revert InvalidLeverageTokenStateAfterRebalance(leverageToken);\n                }\n            }\n        }\n\n        _transferTokens(tokensOut, address(this), msg.sender);\n    }\n\n    /// @notice Function that converts user's equity to shares\n    /// @notice Function uses OZ formula for calculating shares\n    /// @param token LeverageToken to convert equity for\n    /// @param equityInCollateralAsset Equity to convert to shares, denominated in collateral asset\n    /// @return shares Shares\n    /// @dev Function should be used to calculate how much shares user should receive for their equity\n    function _convertToShares(ILeverageToken token, uint256 equityInCollateralAsset)\n        internal\n        view\n        returns (uint256 shares)\n    {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        return Math.mulDiv(\n            equityInCollateralAsset,\n            token.totalSupply() + 10 ** DECIMALS_OFFSET,\n            lendingAdapter.getEquityInCollateralAsset() + 1,\n            Math.Rounding.Floor\n        );\n    }\n\n    /// @notice Previews parameters related to a deposit action\n    /// @param token LeverageToken to preview deposit for\n    /// @param equityInCollateralAsset Amount of equity to add or withdraw, denominated in collateral asset\n    /// @param action Type of the action to preview, can be Deposit or Withdraw\n    /// @return data Preview data for the action\n    /// @dev If the LeverageToken has zero total supply of shares (so the LeverageToken does not hold any collateral or debt,\n    ///      or holds some leftover dust after all shares are redeemed), then the preview will use the target\n    ///      collateral ratio for determining how much collateral and debt is required instead of the current collateral ratio.\n    /// @dev If action is deposit collateral will be rounded down and debt up, if action is withdraw collateral will be rounded up and debt down\n    function _previewAction(ILeverageToken token, uint256 equityInCollateralAsset, ExternalAction action)\n        internal\n        view\n        returns (ActionData memory data)\n    {\n        (uint256 equityToCover, uint256 equityForShares, uint256 tokenFee, uint256 treasuryFee) =\n            _computeEquityFees(token, equityInCollateralAsset, action);\n\n        uint256 shares = _convertToShares(token, equityForShares);\n\n        (uint256 collateral, uint256 debt) = _computeCollateralAndDebtForAction(token, equityToCover, action);\n\n        // The collateral returned by `_computeCollateralAndDebtForAction` can be zero if the amount of equity for the LeverageToken\n        // cannot be exchanged for at least 1 LeverageToken share due to rounding down in the exchange rate calculation.\n        // The treasury fee returned by `_computeEquityFees` is wrt the equity amount, not the share amount, thus it's possible\n        // for it to be non-zero even if the collateral amount is zero. In this case, the treasury fee should be set to 0\n        treasuryFee = collateral == 0 ? 0 : treasuryFee;\n\n        return ActionData({\n            collateral: collateral,\n            debt: debt,\n            equity: equityInCollateralAsset,\n            shares: shares,\n            tokenFee: tokenFee,\n            treasuryFee: treasuryFee\n        });\n    }\n\n    /// @notice Function that computes collateral and debt required by the position held by a LeverageToken for a given action and an amount of equity to add / remove\n    /// @param token LeverageToken to compute collateral and debt for\n    /// @param equityInCollateralAsset Equity amount in collateral asset\n    /// @param action Action to compute collateral and debt for\n    /// @return collateral Collateral to add / remove from the LeverageToken\n    /// @return debt Debt to borrow / repay to the LeverageToken\n    function _computeCollateralAndDebtForAction(\n        ILeverageToken token,\n        uint256 equityInCollateralAsset,\n        ExternalAction action\n    ) internal view returns (uint256 collateral, uint256 debt) {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n        uint256 totalDebt = lendingAdapter.getDebt();\n        uint256 totalShares = token.totalSupply();\n\n        Math.Rounding collateralRounding = action == ExternalAction.Deposit ? Math.Rounding.Ceil : Math.Rounding.Floor;\n        Math.Rounding debtRounding = action == ExternalAction.Deposit ? Math.Rounding.Floor : Math.Rounding.Ceil;\n\n        uint256 shares = _convertToShares(token, equityInCollateralAsset);\n\n        // If action is deposit there might be some dust in collateral but debt can be 0. In that case we should follow target ratio\n        bool shouldFollowInitialRatio = totalShares == 0 || (action == ExternalAction.Deposit && totalDebt == 0);\n\n        if (shouldFollowInitialRatio) {\n            uint256 initialRatio = getLeverageTokenInitialCollateralRatio(token);\n            collateral =\n                Math.mulDiv(equityInCollateralAsset, initialRatio, initialRatio - BASE_RATIO, collateralRounding);\n            debt = lendingAdapter.convertCollateralToDebtAsset(collateral - equityInCollateralAsset);\n        } else {\n            collateral = Math.mulDiv(lendingAdapter.getCollateral(), shares, totalShares, collateralRounding);\n            debt = Math.mulDiv(totalDebt, shares, totalShares, debtRounding);\n        }\n\n        return (collateral, debt);\n    }\n\n    /// @notice Helper function that checks if a specific element has already been processed in the slice up to the given index\n    /// @param actions Entire array to go through\n    /// @param token Element to search for\n    /// @param untilIndex Search until this specific index\n    /// @dev This function is used to check if we already stored the state of the LeverageToken before rebalance.\n    ///      This function is used to check if LeverageToken state has been already validated after rebalance\n    function _isElementInSlice(RebalanceAction[] calldata actions, ILeverageToken token, uint256 untilIndex)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < untilIndex; i++) {\n            if (address(actions[i].leverageToken) == address(token)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /// @notice Executes actions on the LendingAdapter for a specific LeverageToken\n    /// @param token LeverageToken to execute action for\n    /// @param actionType Type of the action to execute\n    /// @param amount Amount to execute action with\n    function _executeLendingAdapterAction(ILeverageToken token, ActionType actionType, uint256 amount) internal {\n        ILendingAdapter lendingAdapter = getLeverageTokenLendingAdapter(token);\n\n        if (actionType == ActionType.AddCollateral) {\n            IERC20 collateralAsset = lendingAdapter.getCollateralAsset();\n            // slither-disable-next-line reentrancy-events\n            SafeERC20.forceApprove(collateralAsset, address(lendingAdapter), amount);\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.addCollateral(amount);\n        } else if (actionType == ActionType.RemoveCollateral) {\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.removeCollateral(amount);\n        } else if (actionType == ActionType.Borrow) {\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.borrow(amount);\n        } else if (actionType == ActionType.Repay) {\n            IERC20 debtAsset = lendingAdapter.getDebtAsset();\n            // slither-disable-next-line reentrancy-events\n            SafeERC20.forceApprove(debtAsset, address(lendingAdapter), amount);\n            // slither-disable-next-line reentrancy-events\n            lendingAdapter.repay(amount);\n        }\n    }\n\n    /// @notice Used for batching token transfers\n    /// @param transfers Array of transfer data. Transfer data consist of token to transfer and amount\n    /// @param from Address to transfer tokens from\n    /// @param to Address to transfer tokens to\n    /// @dev If from address is this smart contract it will use the regular transfer function otherwise it will use transferFrom\n    function _transferTokens(TokenTransfer[] calldata transfers, address from, address to) internal {\n        for (uint256 i = 0; i < transfers.length; i++) {\n            TokenTransfer calldata transfer = transfers[i];\n\n            if (from == address(this)) {\n                SafeERC20.safeTransfer(IERC20(transfer.token), to, transfer.amount);\n            } else {\n                SafeERC20.safeTransferFrom(IERC20(transfer.token), from, to, transfer.amount);\n            }\n        }\n    }\n}\n",
        "MorphoLendingAdapter.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Dependency imports\nimport {Id, IMorpho, MarketParams, Market, Position} from \"@morpho-blue/interfaces/IMorpho.sol\";\nimport {MAX_LIQUIDATION_INCENTIVE_FACTOR, LIQUIDATION_CURSOR} from \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MathLib as MorphoMathLib} from \"@morpho-blue/libraries/MathLib.sol\";\nimport {UtilsLib as MorphoUtilsLib} from \"@morpho-blue/libraries/UtilsLib.sol\";\nimport {SharesMathLib} from \"@morpho-blue/libraries/SharesMathLib.sol\";\nimport {IOracle} from \"@morpho-blue/interfaces/IOracle.sol\";\nimport {ORACLE_PRICE_SCALE} from \"@morpho-blue/libraries/ConstantsLib.sol\";\nimport {MorphoBalancesLib} from \"@morpho-blue/libraries/periphery/MorphoBalancesLib.sol\";\nimport {MorphoLib} from \"@morpho-blue/libraries/periphery/MorphoLib.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Internal imports\nimport {ILendingAdapter} from \"src/interfaces/ILendingAdapter.sol\";\nimport {ILeverageManager} from \"src/interfaces/ILeverageManager.sol\";\nimport {IMorphoLendingAdapter} from \"src/interfaces/IMorphoLendingAdapter.sol\";\nimport {IPreLiquidationLendingAdapter} from \"src/interfaces/IPreLiquidationLendingAdapter.sol\";\n\n/**\n * @dev The MorphoLendingAdapter is an adapter to interface with Morpho markets. LeverageToken creators can configure their LeverageToken\n * to use a MorphoLendingAdapter to use Morpho as the lending protocol for their LeverageToken.\n *\n * The MorphoLendingAdapter uses the underlying oracle of the Morpho market to convert between the collateral and debt asset. It also\n * uses Morpho's libraries to calculate the collateral and debt held by the adapter, including any accrued interest.\n *\n * Note: `getDebt` uses `MorphoBalancesLib.expectedBorrowAssets` which calculates the total debt of the adapter based on the Morpho\n * market's borrow shares owned by the adapter. This logic rounds up, so it is possible that `getDebt` returns a value that is\n * greater than the actual debt owed to the Morpho market.\n */\ncontract MorphoLendingAdapter is IMorphoLendingAdapter, Initializable {\n    uint256 internal constant WAD = 1e18;\n\n    /// @inheritdoc IMorphoLendingAdapter\n    ILeverageManager public immutable leverageManager;\n\n    /// @inheritdoc IMorphoLendingAdapter\n    IMorpho public immutable morpho;\n\n    /// @inheritdoc IMorphoLendingAdapter\n    Id public morphoMarketId;\n\n    /// @inheritdoc IMorphoLendingAdapter\n    MarketParams public marketParams;\n\n    /// @inheritdoc IMorphoLendingAdapter\n    address public authorizedCreator;\n\n    /// @inheritdoc IMorphoLendingAdapter\n    bool public isUsed;\n\n    /// @dev Reverts if the caller is not the stored LeverageManager address\n    modifier onlyLeverageManager() {\n        if (msg.sender != address(leverageManager)) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Creates a new MorphoLendingAdapter\n    /// @param _leverageManager The LeverageManager contract\n    /// @param _morpho The Morpho core protocol contract\n    constructor(ILeverageManager _leverageManager, IMorpho _morpho) {\n        leverageManager = _leverageManager;\n        morpho = _morpho;\n    }\n\n    /// @notice Initializes the MorphoLendingAdapter\n    /// @param _morphoMarketId The Morpho market ID\n    /// @param _authorizedCreator The authorized creator of this MorphoLendingAdapter. The authorized creator can create a\n    /// new LeverageToken using this adapter on the LeverageManager\n    function initialize(Id _morphoMarketId, address _authorizedCreator) external initializer {\n        morphoMarketId = _morphoMarketId;\n        marketParams = morpho.idToMarketParams(_morphoMarketId);\n\n        // slither-disable-next-line missing-zero-check\n        authorizedCreator = _authorizedCreator;\n        emit MorphoLendingAdapterInitialized(_morphoMarketId, marketParams, _authorizedCreator);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function postLeverageTokenCreation(address creator, address) external onlyLeverageManager {\n        if (creator != authorizedCreator) revert Unauthorized();\n        if (isUsed) revert LendingAdapterAlreadyInUse();\n        isUsed = true;\n\n        emit MorphoLendingAdapterUsed();\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getCollateralAsset() external view returns (IERC20) {\n        return IERC20(marketParams.collateralToken);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getDebtAsset() external view returns (IERC20) {\n        return IERC20(marketParams.loanToken);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function convertCollateralToDebtAsset(uint256 collateral) public view returns (uint256) {\n        // Morpho oracles return the price of 1 asset of collateral token quoted in 1 asset of loan token, scaled by ORACLE_PRICE_SCALE.\n        // More specifically, the price is quoted in `ORACLE_PRICE_SCALE + loan token decimals - collateral token decimals` decimals of precision.\n        uint256 collateralAssetPriceInDebtAsset = IOracle(marketParams.oracle).price();\n\n        // The result is scaled down by ORACLE_PRICE_SCALE to accommodate the oracle's decimals of precision\n        return Math.mulDiv(collateral, collateralAssetPriceInDebtAsset, ORACLE_PRICE_SCALE, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function convertDebtToCollateralAsset(uint256 debt) public view returns (uint256) {\n        // Morpho oracles return the price of 1 asset of collateral token quoted in 1 asset of loan token, scaled by ORACLE_PRICE_SCALE.\n        // More specifically, the price is quoted in `ORACLE_PRICE_SCALE + loan token decimals - collateral token decimals` decimals of precision.\n        uint256 collateralAssetPriceInDebtAsset = IOracle(marketParams.oracle).price();\n\n        // The result is scaled up by ORACLE_PRICE_SCALE to accommodate the oracle's decimals of precision\n        return Math.mulDiv(debt, ORACLE_PRICE_SCALE, collateralAssetPriceInDebtAsset, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getCollateral() public view returns (uint256) {\n        return MorphoLib.collateral(morpho, morphoMarketId, address(this));\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getCollateralInDebtAsset() public view returns (uint256) {\n        return convertCollateralToDebtAsset(getCollateral());\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getDebt() public view returns (uint256) {\n        return MorphoBalancesLib.expectedBorrowAssets(morpho, marketParams, address(this));\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getEquityInCollateralAsset() external view returns (uint256) {\n        uint256 collateral = getCollateral();\n        uint256 debtInCollateralAsset = convertDebtToCollateralAsset(getDebt());\n\n        return collateral > debtInCollateralAsset ? collateral - debtInCollateralAsset : 0;\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function getEquityInDebtAsset() external view returns (uint256) {\n        uint256 collateralInDebtAsset = getCollateralInDebtAsset();\n        uint256 debt = getDebt();\n\n        return collateralInDebtAsset > debt ? collateralInDebtAsset - debt : 0;\n    }\n\n    /// @inheritdoc IPreLiquidationLendingAdapter\n    function getLiquidationPenalty() external view returns (uint256) {\n        uint256 liquidationIncentiveFactor = MorphoUtilsLib.min(\n            MAX_LIQUIDATION_INCENTIVE_FACTOR,\n            MorphoMathLib.wDivDown(WAD, WAD - MorphoMathLib.wMulDown(LIQUIDATION_CURSOR, WAD - marketParams.lltv))\n        );\n\n        return liquidationIncentiveFactor - WAD;\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function addCollateral(uint256 amount) external {\n        if (amount == 0) return;\n\n        MarketParams memory _marketParams = marketParams;\n\n        // Transfer the collateral from msg.sender to this contract\n        SafeERC20.safeTransferFrom(IERC20(_marketParams.collateralToken), msg.sender, address(this), amount);\n\n        // Supply the collateral to the Morpho market\n        SafeERC20.forceApprove(IERC20(_marketParams.collateralToken), address(morpho), amount);\n        morpho.supplyCollateral(_marketParams, amount, address(this), hex\"\");\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function removeCollateral(uint256 amount) external onlyLeverageManager {\n        if (amount == 0) return;\n        // Withdraw the collateral from the Morpho market and send it to msg.sender\n        morpho.withdrawCollateral(marketParams, amount, address(this), msg.sender);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function borrow(uint256 amount) external onlyLeverageManager {\n        if (amount == 0) return;\n\n        // Borrow the debt asset from the Morpho market and send it to the caller\n        // slither-disable-next-line unused-return\n        morpho.borrow(marketParams, amount, 0, address(this), msg.sender);\n    }\n\n    /// @inheritdoc ILendingAdapter\n    function repay(uint256 amount) external {\n        if (amount == 0) return;\n\n        MarketParams memory _marketParams = marketParams;\n\n        // Transfer the debt asset from msg.sender to this contract\n        SafeERC20.safeTransferFrom(IERC20(_marketParams.loanToken), msg.sender, address(this), amount);\n\n        // Accrue interest before repaying to make sure interest is included in calculation\n        morpho.accrueInterest(marketParams);\n\n        // Fetch total borrow assets and total borrow shares. This data is updated because we accrued interest in previous step\n        Market memory market = morpho.market(morphoMarketId);\n        uint256 totalBorrowAssets = market.totalBorrowAssets;\n        uint256 totalBorrowShares = market.totalBorrowShares;\n\n        // Fetch how much borrow shares do we owe\n        Position memory position = morpho.position(morphoMarketId, address(this));\n        uint256 maxSharesToRepay = position.borrowShares;\n        uint256 maxAssetsToRepay = SharesMathLib.toAssetsUp(maxSharesToRepay, totalBorrowAssets, totalBorrowShares);\n\n        SafeERC20.forceApprove(IERC20(_marketParams.loanToken), address(morpho), amount);\n\n        // Repay all shares if we are trying to repay more assets than we owe\n        if (amount >= maxAssetsToRepay) {\n            // slither-disable-next-line unused-return\n            morpho.repay(_marketParams, 0, maxSharesToRepay, address(this), hex\"\");\n        } else {\n            // slither-disable-next-line unused-return\n            morpho.repay(_marketParams, amount, 0, address(this), hex\"\");\n        }\n    }\n}\n"
    }
}