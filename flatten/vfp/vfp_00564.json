{
    "vfp_id": "vfp_00564",
    "project_name": "cantina_seamless_sep2025.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Ceiling rounding in _getAccruedManagementFee can yield a much higher effective fee being charged than set",
            "description": "1. **Description:** The _getAccruedManagementFee function uses ceiling rounding, which causes the effective management fee to often exceed the set rate, and in extreme cases (e.g., low supply due to donation attacks), the fee can be orders of magnitude higher.\n2. **Cause:** Ceiling rounding in fee calculation introduces upward bias, especially when supply is low or fees are small, leading to disproportionate accruals.\n3. **Exploitation:** While not directly exploitable for profit, users may be overcharged in fee accruals, particularly in edge cases involving low token supply.\n4. **Impact:** Users are charged higher fees than intended, undermining fee predictability and fairness. This could damage trust in the protocol's fee model.\n",
            "severity": "Low",
            "location": [
                "FeeManager.sol#L259-L260"
            ],
            "files": [
                "leverage-tokens/src/FeeManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-193"
                ]
            },
            "title": "_computeFeesForNetShares fails to account for additional rounding step in reversal of _computeFeesForGrossShares",
            "description": "1. **Description:** The _computeFeesForNetShares function does not account for the rounding step used in _computeFeesForGrossShares, leading to discrepancies between previewRedeem and previewWithdraw outputs.\n2. **Cause:** Inconsistent rounding logic between the two functions results in off-by-one errors in fee calculations, particularly affecting treasury fee shares.\n3. **Exploitation:** Users could potentially exploit the mismatch to minimize treasury fees by choosing the lower-fee path (e.g., withdraw instead of redeem), though the impact is minimal.\n4. **Impact:** Inconsistencies in fee previews reduce transparency and may lead to suboptimal user decisions or reduced treasury revenue in edge cases.\n",
            "severity": "Low",
            "location": [
                "FeeManager.sol#L228-L238"
            ],
            "files": [
                "leverage-tokens/src/FeeManager.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Struct in FeeManager has variables that could be tightly packed",
            "description": "1. **Description:** The FeeManagerStorage struct contains two separate mappings to uint256 values that are often accessed together, leading to inefficient storage usage.\n2. **Cause:** Poor struct packing results in unnecessary SLOAD and SSTORE operations, increasing gas costs.\n3. **Exploitation:** No direct security exploit, but inefficient gas usage increases transaction costs for users.\n4. **Impact:** Higher gas consumption than necessary, reducing cost-efficiency for on-chain operations.\n",
            "severity": "Informational",
            "location": [
                "FeeManager.sol#L50-L53"
            ],
            "files": [
                "leverage-tokens/src/FeeManager.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "_getAccruedManagementFee can be optimized for on-chain callpaths",
            "description": "1. **Description:** The _getAccruedManagementFee function performs redundant operations when called during deposit, mint, redeem, or withdraw, where chargeManagementFee has already updated state.\n2. **Cause:** The function does not early-return when duration is zero, leading to unnecessary computation and storage loads.\n3. **Exploitation:** No security risk, but wasted gas on every call where duration is zero.\n4. **Impact:** Increased gas costs for users; optimization could save at least 100 gas per call.\n",
            "severity": "Informational",
            "location": [
                "FeeManager.sol::getAccruedManagementFee"
            ],
            "files": [
                "leverage-tokens/src/FeeManager.sol"
            ]
        }
    ],
    "affected_files": {
        "FeeManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\n// Dependency imports\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Internal imports\nimport {ExternalAction} from \"src/types/DataTypes.sol\";\nimport {ILeverageToken} from \"src/interfaces/ILeverageToken.sol\";\nimport {IFeeManager} from \"src/interfaces/IFeeManager.sol\";\n\n/**\n * @dev The FeeManager contract is an abstract upgradeable core contract that is responsible for managing the fees for LeverageTokens.\n * There are three types of fees:\n *   - Token action fees: Fees charged that accumulate towards the value of the LeverageToken for current LeverageToken\n *     holders, applied on equity for mints and redeems\n *   - Treasury action fees: Fees charged in shares that are transferred to the configured treasury address, applied on\n *     shares minted for mints and shares burned for redeems\n *   - Management fees: Fees charged in shares that are transferred to the configured treasury address. The management fee\n *     accrues linearly over time and is minted to the treasury when the `chargeManagementFee` function is executed\n * Note: This contract is abstract and meant to be inherited by LeverageManager\n * The maximum fee that can be set for each action is 100_00 (100%).\n *\n * @custom:contact security@seamlessprotocol.com\n */\nabstract contract FeeManager is IFeeManager, Initializable, AccessControlUpgradeable {\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n\n    uint256 internal constant MAX_BPS = 100_00;\n\n    uint256 internal constant MAX_BPS_SQUARED = MAX_BPS * MAX_BPS;\n\n    uint256 internal constant MAX_ACTION_FEE = MAX_BPS - 1;\n\n    uint256 internal constant MAX_MANAGEMENT_FEE = MAX_BPS;\n\n    uint256 internal constant SECS_PER_YEAR = 31536000;\n\n    /// @dev Struct containing all state for the FeeManager contract\n    /// @custom:storage-location erc7201:seamless.contracts.storage.FeeManager\n    struct FeeManagerStorage {\n        /// @dev Treasury address that receives treasury fees and management fees\n        address treasury;\n        /// @dev Default annual management fee for LeverageTokens at creation. 100_00 is 100% per year\n        uint256 defaultManagementFeeAtCreation;\n        /// @dev Annual management fee for each LeverageToken. 100_00 is 100% per year\n        mapping(ILeverageToken token => uint256) managementFee;\n        /// @dev Timestamp when the management fee was most recently accrued for each LeverageToken\n        mapping(ILeverageToken token => uint120) lastManagementFeeAccrualTimestamp;\n        /// @dev Treasury action fee for each action. 100_00 is 100%\n        mapping(ExternalAction action => uint256) treasuryActionFee;\n        /// @dev Token action fee for each action. 100_00 is 100%\n        mapping(ILeverageToken token => mapping(ExternalAction action => uint256)) tokenActionFee;\n    }\n\n    function _getFeeManagerStorage() internal pure returns (FeeManagerStorage storage $) {\n        // slither-disable-next-line assembly\n        assembly {\n            // keccak256(abi.encode(uint256(keccak256(\"seamless.contracts.storage.FeeManager\")) - 1)) & ~bytes32(uint256(0xff));\n            $.slot := 0x6c0d8f7f1305f10aa51c80093531513ff85a99140b414f68890d41ac36949e00\n        }\n    }\n\n    function __FeeManager_init(address defaultAdmin, address treasury) internal onlyInitializing {\n        __AccessControl_init_unchained();\n        __FeeManager_init_unchained(defaultAdmin, treasury);\n    }\n\n    function __FeeManager_init_unchained(address defaultAdmin, address treasury) internal onlyInitializing {\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _setTreasury(treasury);\n    }\n\n    /// @inheritdoc IFeeManager\n    function getDefaultManagementFeeAtCreation() public view returns (uint256) {\n        return _getFeeManagerStorage().defaultManagementFeeAtCreation;\n    }\n\n    /// @inheritdoc IFeeManager\n    function getFeeAdjustedTotalSupply(ILeverageToken token) public view returns (uint256) {\n        uint256 totalSupply = token.totalSupply();\n        uint256 accruedManagementFee = _getAccruedManagementFee(token, totalSupply);\n        return totalSupply + accruedManagementFee;\n    }\n\n    /// @inheritdoc IFeeManager\n    function getLastManagementFeeAccrualTimestamp(ILeverageToken token) public view returns (uint120) {\n        return _getFeeManagerStorage().lastManagementFeeAccrualTimestamp[token];\n    }\n\n    /// @inheritdoc IFeeManager\n    function getLeverageTokenActionFee(ILeverageToken token, ExternalAction action) public view returns (uint256 fee) {\n        return _getFeeManagerStorage().tokenActionFee[token][action];\n    }\n\n    /// @inheritdoc IFeeManager\n    function getManagementFee(ILeverageToken token) public view returns (uint256 fee) {\n        return _getFeeManagerStorage().managementFee[token];\n    }\n\n    /// @inheritdoc IFeeManager\n    function getTreasury() public view returns (address treasury) {\n        return _getFeeManagerStorage().treasury;\n    }\n\n    /// @inheritdoc IFeeManager\n    function getTreasuryActionFee(ExternalAction action) public view returns (uint256 fee) {\n        return _getFeeManagerStorage().treasuryActionFee[action];\n    }\n\n    /// @inheritdoc IFeeManager\n    function setDefaultManagementFeeAtCreation(uint256 fee) external onlyRole(FEE_MANAGER_ROLE) {\n        _validateManagementFee(fee);\n\n        _getFeeManagerStorage().defaultManagementFeeAtCreation = fee;\n        emit DefaultManagementFeeAtCreationSet(fee);\n    }\n\n    /// @inheritdoc IFeeManager\n    function setManagementFee(ILeverageToken token, uint256 fee) external onlyRole(FEE_MANAGER_ROLE) {\n        // Charge any accrued management fees before setting the new management fee\n        chargeManagementFee(token);\n\n        _validateManagementFee(fee);\n\n        _getFeeManagerStorage().managementFee[token] = fee;\n        emit ManagementFeeSet(token, fee);\n    }\n\n    /// @inheritdoc IFeeManager\n    function setTreasury(address treasury) external onlyRole(FEE_MANAGER_ROLE) {\n        _setTreasury(treasury);\n    }\n\n    /// @inheritdoc IFeeManager\n    function setTreasuryActionFee(ExternalAction action, uint256 fee) external onlyRole(FEE_MANAGER_ROLE) {\n        _validateActionFee(fee);\n        _getFeeManagerStorage().treasuryActionFee[action] = fee;\n\n        emit TreasuryActionFeeSet(action, fee);\n    }\n\n    /// @inheritdoc IFeeManager\n    function chargeManagementFee(ILeverageToken token) public {\n        // Shares fee must be obtained before the last management fee accrual timestamp is updated\n        uint256 sharesFee = _getAccruedManagementFee(token, token.totalSupply());\n        _getFeeManagerStorage().lastManagementFeeAccrualTimestamp[token] = uint120(block.timestamp);\n\n        _chargeTreasuryFee(token, sharesFee);\n        emit ManagementFeeCharged(token, sharesFee);\n    }\n\n    /// @notice Function that mints shares to the treasury, if the treasury is set\n    /// @param token LeverageToken to mint shares to treasury for\n    /// @param shares Shares to mint\n    /// @dev This contract must be authorized to mint shares for the LeverageToken\n    function _chargeTreasuryFee(ILeverageToken token, uint256 shares) internal {\n        // slither-disable-next-line timestamp\n        if (shares != 0) {\n            // slither-disable-next-line reentrancy-events\n            token.mint(getTreasury(), shares);\n        }\n    }\n\n    /// @notice Computes the share fees for a given action and share amount\n    /// @param token LeverageToken to compute share fees for\n    /// @param grossShares Amount of shares to compute share fees for\n    /// @param action Action to compute share fees for\n    /// @return netShares Amount of shares after fees\n    /// @return sharesTokenFee Amount of shares that will be charged for the action that are given to the LeverageToken\n    /// @return treasuryFee Amount of shares that will be charged for the action that are given to the treasury\n    /// @dev Token action fee is applied first, then treasury action fee is applied on the remaining shares\n    function _computeFeesForGrossShares(ILeverageToken token, uint256 grossShares, ExternalAction action)\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        uint256 sharesTokenFee =\n            Math.mulDiv(grossShares, getLeverageTokenActionFee(token, action), MAX_BPS, Math.Rounding.Ceil);\n        uint256 netShares = grossShares - sharesTokenFee;\n        uint256 treasuryFee = _computeTreasuryFee(action, netShares);\n\n        netShares = netShares - treasuryFee;\n\n        return (netShares, sharesTokenFee, treasuryFee);\n    }\n\n    /// @notice Based on an amount of net shares, compute the gross shares, token fee, and treasury fee\n    /// @param token LeverageToken to compute token fee for\n    /// @param netShares Net shares to compute token fee for\n    /// @param action Action to compute token fee for\n    /// @return grossShares Gross shares after token fee and treasury fee\n    /// @return sharesTokenFee Token fee amount in shares\n    /// @return treasuryFee Treasury fee amount in shares\n    /// @dev Token action fee is applied first, then treasury action fee is applied on the remaining shares\n    function _computeFeesForNetShares(ILeverageToken token, uint256 netShares, ExternalAction action)\n        internal\n        view\n        returns (uint256 grossShares, uint256 sharesTokenFee, uint256 treasuryFee)\n    {\n        uint256 tokenActionFeeRate = getLeverageTokenActionFee(token, action);\n        uint256 treasuryActionFeeRate = getTreasuryActionFee(action);\n\n        // Mathematical derivation for computing gross shares from net shares:\n        //\n        // Starting relationship for a single fee:\n        //   net = gross * (baseFee - feeRate) / baseFee\n        //   where feeRate is the fee percentage and baseFee is the base (100_00 for 100%)\n        //\n        // Rearranging to solve for gross:\n        //   gross = net * baseFee / (baseFee - feeRate)\n        //\n        // For two sequential fees (token action fee and treasury action fee), we apply this transformation twice:\n        //   1) First, apply token action fee: afterTokenFee = gross * (baseFee - tokenActionFeeRate) / baseFee\n        //   2) Then, apply treasury action fee: net = afterTokenFee * (baseFee - treasuryActionFeeRate) / baseFee\n        //\n        // Substituting step 1 into step 2:\n        //   net = gross * (baseFee - tokenActionFeeRate) / baseFee * (baseFee - treasuryActionFeeRate) / baseFee\n        //   net = gross * (baseFee - tokenActionFeeRate) * (baseFee - treasuryActionFeeRate) / (baseFee * baseFee)\n        //   net = gross * (baseFee - tokenActionFeeRate) * (baseFee - treasuryActionFeeRate) / baseFeeSquared\n        //\n        // Solving for gross:\n        //   gross = net * baseFeeSquared / ((baseFee - tokenActionFeeRate) * (baseFee - treasuryActionFeeRate))\n        grossShares = Math.mulDiv(\n            netShares,\n            MAX_BPS_SQUARED,\n            (MAX_BPS - tokenActionFeeRate) * (MAX_BPS - treasuryActionFeeRate),\n            Math.Rounding.Ceil\n        );\n        sharesTokenFee =\n            Math.min(Math.mulDiv(grossShares, tokenActionFeeRate, MAX_BPS, Math.Rounding.Ceil), grossShares - netShares);\n        treasuryFee = grossShares - sharesTokenFee - netShares;\n\n        return (grossShares, sharesTokenFee, treasuryFee);\n    }\n\n    /// @notice Computes the treasury action fee for a given action\n    /// @param action Action to compute treasury action fee for\n    /// @param shares Shares to compute treasury action fee for\n    /// @return treasuryFee Treasury action fee amount in shares\n    function _computeTreasuryFee(ExternalAction action, uint256 shares) internal view returns (uint256) {\n        return Math.mulDiv(shares, getTreasuryActionFee(action), MAX_BPS, Math.Rounding.Ceil);\n    }\n\n    /// @notice Function that calculates how many shares to mint for the accrued management fee at the current timestamp\n    /// @param token LeverageToken to calculate management fee shares for\n    /// @param totalSupply Total supply of the LeverageToken\n    /// @return shares Shares to mint\n    function _getAccruedManagementFee(ILeverageToken token, uint256 totalSupply) internal view returns (uint256) {\n        uint256 managementFee = getManagementFee(token);\n        uint120 lastManagementFeeAccrualTimestamp = getLastManagementFeeAccrualTimestamp(token);\n\n        uint256 duration = block.timestamp - lastManagementFeeAccrualTimestamp;\n\n        uint256 sharesFee =\n            Math.mulDiv(managementFee * totalSupply, duration, MAX_BPS * SECS_PER_YEAR, Math.Rounding.Ceil);\n        return sharesFee;\n    }\n\n    /// @notice Sets the LeverageToken fee for a specific action\n    /// @param token LeverageToken to set fee for\n    /// @param action Action to set fee for\n    /// @param fee Fee for action, 100_00 is 100%\n    /// @dev If caller tries to set fee above 100% it reverts with FeeTooHigh error\n    function _setLeverageTokenActionFee(ILeverageToken token, ExternalAction action, uint256 fee) internal {\n        _validateActionFee(fee);\n\n        _getFeeManagerStorage().tokenActionFee[token][action] = fee;\n        emit LeverageTokenActionFeeSet(token, action, fee);\n    }\n\n    /// @notice Sets the management fee for a new LeverageToken and the last management fee accrual timestamp to the\n    /// current timestamp\n    /// @param token LeverageToken to set management fee for\n    function _setNewLeverageTokenManagementFee(ILeverageToken token) internal {\n        uint256 fee = _getFeeManagerStorage().defaultManagementFeeAtCreation;\n\n        _getFeeManagerStorage().managementFee[token] = fee;\n        _getFeeManagerStorage().lastManagementFeeAccrualTimestamp[token] = uint120(block.timestamp);\n        emit ManagementFeeSet(token, fee);\n    }\n\n    /// @notice Sets the treasury address\n    /// @param treasury Treasury address to set\n    /// @dev Reverts if the treasury address is zero\n    function _setTreasury(address treasury) internal {\n        if (treasury == address(0)) {\n            revert ZeroAddressTreasury();\n        }\n\n        _getFeeManagerStorage().treasury = treasury;\n        emit TreasurySet(treasury);\n    }\n\n    /// @notice Validates that the fee is not higher than 99.99%\n    /// @param fee Fee to validate\n    function _validateActionFee(uint256 fee) internal pure {\n        if (fee > MAX_ACTION_FEE) {\n            revert FeeTooHigh(fee, MAX_ACTION_FEE);\n        }\n    }\n\n    /// @notice Validates that the fee is not higher than 100%\n    /// @param fee Fee to validate\n    function _validateManagementFee(uint256 fee) internal pure {\n        if (fee > MAX_MANAGEMENT_FEE) {\n            revert FeeTooHigh(fee, MAX_MANAGEMENT_FEE);\n        }\n    }\n}\n"
    }
}