{
    "vfp_id": "vfp_00549",
    "project_name": "Uniswap Calibur Audit.md",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1286"
                ]
            },
            "title": "Missing ERC-7739 Recommended contentsName Validation",
            "description": "The implementation does not fully comply with the recommended security checks in ERC-7739 for validating the `contentsName` field in typed data signatures. Specifically, it does not reject signatures where `contentsName` is empty, starts with lowercase letters (a-z), or contains disallowed characters like commas, parentheses, or null bytes. The root cause is the omission of these validation steps in the `ERC7739Utils.sol` library. An attacker could exploit this by crafting a malicious typed data structure with a deceptive `contentsName` that appears legitimate to the user but is processed differently by the contract. The impact includes user deception, signature misuse, and potential authorization of unintended actions due to ambiguous or malformed content names.\n",
            "severity": "Low",
            "location": [
                "ERC7739Utils.sol::contentsName validation#93-95"
            ],
            "files": [
                "732a20a8d82f034573c6c7e44160f1860233a946/minimal-delegation/src/libraries/ERC7739Utils.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC7739Utils.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {PersonalSignLib} from \"./PersonalSignLib.sol\";\nimport {TypedDataSignLib} from \"./TypedDataSignLib.sol\";\n\n/// @title ERC7739Utils\n/// @notice Modified from the original implementation at\n/// https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/53f590e4f4902bee0e06e455332e3321c697ea8b/contracts/utils/cryptography/ERC7739Utils.sol\n/// Changelog\n/// - Use in memory strings\n/// - Use Solady's LibString for memory string operations\nlibrary ERC7739Utils {\n    /// @notice Hash a PersonalSign struct with the app's domain separator to produce an EIP-712 compatible hash\n    /// @dev Uses this account's domain separator in the EIP-712 hash for replay protection\n    /// @param hash The hashed message, calculated offchain\n    /// @param domainSeparator This account's domain separator\n    /// @return The PersonalSign nested EIP-712 hash of the message\n    function toPersonalSignTypedDataHash(bytes32 hash, bytes32 domainSeparator) internal pure returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(domainSeparator, PersonalSignLib.hash(hash));\n    }\n\n    /// @notice Hash TypedDataSign with the app's domain separator to produce an EIP-712 compatible hash\n    /// @dev Includes this account's domain in the hash for replay protection\n    /// @param contentsHash The hash of the contents, per EIP-712\n    /// @param domainBytes The encoded domain bytes from EIP-5267\n    /// @param appSeparator The app's domain separator\n    /// @param contentsName The top level type, per EIP-712\n    /// @param contentsType The full type string of the contents, per EIP-712\n    function toNestedTypedDataSignHash(\n        bytes32 contentsHash,\n        bytes memory domainBytes,\n        bytes32 appSeparator,\n        string memory contentsName,\n        string memory contentsType\n    ) internal pure returns (bytes32) {\n        bytes32 typedDataSignHash = TypedDataSignLib.hash(contentsName, contentsType, contentsHash, domainBytes);\n        return MessageHashUtils.toTypedDataHash(appSeparator, typedDataSignHash);\n    }\n\n    /// @notice Parse the type name out of the ERC-7739 contents type description. Supports both the implicit and explicit modes\n    /// @dev Modified from https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/53f590e4f4902bee0e06e455332e3321c697ea8b/contracts/utils/cryptography/ERC7739Utils.sol\n    /// @dev Returns empty strings if the contentsDescr is invalid, which must be handled by the calling function\n    /// @return contentsName The type name of the contents\n    /// @return contentsType The type description of the contents\n    function decodeContentsDescr(string memory contentsDescr)\n        internal\n        pure\n        returns (string memory contentsName, string memory contentsType)\n    {\n        bytes memory buffer = bytes(contentsDescr);\n        if (buffer.length == 0) {\n            // pass through (fail)\n        } else if (buffer[buffer.length - 1] == bytes1(\")\")) {\n            // Implicit mode: read contentsName from the beginning, and keep the complete descr\n            for (uint256 i = 0; i < buffer.length; ++i) {\n                bytes1 current = buffer[i];\n                if (current == bytes1(\"(\")) {\n                    // if name is empty - passthrough (fail)\n                    if (i == 0) break;\n                    // we found the end of the contentsName\n                    contentsName = LibString.slice(contentsDescr, 0, i);\n                    contentsType = contentsDescr;\n                    return (contentsName, contentsType);\n                } else if (_isForbiddenChar(current)) {\n                    // we found an invalid character (forbidden) - passthrough (fail)\n                    break;\n                }\n            }\n        } else {\n            // Explicit mode: read contentsName from the end, and remove it from the descr\n            for (uint256 i = buffer.length; i > 0; --i) {\n                bytes1 current = buffer[i - 1];\n                if (current == bytes1(\")\")) {\n                    // we found the end of the contentsName\n                    contentsName = LibString.slice(contentsDescr, i, buffer.length);\n                    contentsType = LibString.slice(contentsDescr, 0, i);\n                    return (contentsName, contentsType);\n                } else if (_isForbiddenChar(current)) {\n                    // we found an invalid character (forbidden) - passthrough (fail)\n                    break;\n                }\n            }\n        }\n        return (\"\", \"\");\n    }\n\n    /// @notice Perform onchain sanitization of contentsName as defined by the ERC-7739 spec\n    /// @dev Following ERC-7739 specifications, a `contentsName` is considered invalid if it's empty or it contains\n    /// any of the following bytes: \", )\\x00\"\n    function _isForbiddenChar(bytes1 char) private pure returns (bool) {\n        return char == 0x00 || char == bytes1(\" \") || char == bytes1(\",\") || char == bytes1(\"(\") || char == bytes1(\")\");\n    }\n}\n"
    }
}