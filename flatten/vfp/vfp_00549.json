{
    "vfp_id": "vfp_00549",
    "project_name": "Across Audit.md",
    "findings": [
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Casts",
            "description": "The `_resolve` and `_resolveFor` functions in `ERC7683OrderDepositor` cast `block.chainId` to `uint32` when initializing the `minReceived` field of `ResolvedCrossChainOrder`, but the `Output.chainId` field is of type `uint64`. This causes a revert on chains with `chainId` values exceeding `uint32` range, even though they are valid under `uint64`. The root cause is an incorrect type cast that unnecessarily restricts compatibility. This could lead to failed order resolutions on high-chainID networks, resulting in a denial of service for users on those chains.\n",
            "severity": "Low",
            "location": [
                "ERC7683OrderDepositor.sol::_resolve#244",
                "ERC7683OrderDepositor.sol::_resolveFor#161",
                "ERC7683OrderDepositor.sol::minReceived#210",
                "ERC7683.sol::Output#77"
            ],
            "files": [
                "contracts/contracts/erc7683/ERC7683OrderDepositor.sol"
            ]
        }
    ],
    "affected_files": {
        "ERC7683OrderDepositor.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Output, GaslessCrossChainOrder, OnchainCrossChainOrder, ResolvedCrossChainOrder, IOriginSettler, FillInstruction } from \"./ERC7683.sol\";\nimport { AcrossOrderData, AcrossOriginFillerData, ERC7683Permit2Lib, ACROSS_ORDER_DATA_TYPE_HASH } from \"./ERC7683Across.sol\";\n\n/**\n * @notice ERC7683OrderDepositor processes an external order type and translates it into an AcrossV3 deposit.\n * @dev This contract is abstract because it is intended to be usable by a contract that can accept the deposit\n * as well as one that sends the deposit to another contract.\n * @custom:security-contact bugs@across.to\n */\nabstract contract ERC7683OrderDepositor is IOriginSettler {\n    using SafeERC20 for IERC20;\n\n    error WrongSettlementContract();\n    error WrongChainId();\n    error WrongOrderDataType();\n    error WrongExclusiveRelayer();\n\n    // Permit2 contract for this network.\n    IPermit2 public immutable PERMIT2;\n\n    // QUOTE_BEFORE_DEADLINE is subtracted from the deadline to get the quote timestamp.\n    // This is a somewhat arbitrary conversion, but order creators need some way to precompute the quote timestamp.\n    uint256 public immutable QUOTE_BEFORE_DEADLINE;\n\n    /**\n     * @notice Construct the Permit2Depositor.\n     * @param _permit2 Permit2 contract\n     * @param _quoteBeforeDeadline quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n     */\n    constructor(IPermit2 _permit2, uint256 _quoteBeforeDeadline) {\n        PERMIT2 = _permit2;\n        QUOTE_BEFORE_DEADLINE = _quoteBeforeDeadline;\n    }\n\n    /**\n     * @notice Open the order on behalf of the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     * @param signature signature for the EIP-712 compliant order type.\n     * @param fillerData Across-specific fillerData.\n     */\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata fillerData\n    ) external {\n        (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        ) = _resolveFor(order, fillerData);\n\n        // Verify Permit2 signature and pull user funds into this contract\n        _processPermit2Order(order, acrossOrderData, signature);\n\n        _callDeposit(\n            order.user,\n            acrossOrderData.recipient,\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOriginFillerData.exclusiveRelayer,\n            // Note: simplifying assumption to avoid quote timestamps that cause orders to expire before the deadline.\n            SafeCast.toUint32(order.openDeadline - QUOTE_BEFORE_DEADLINE),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Opens the order.\n     * @dev Unlike openFor, this method is callable by the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     */\n    function open(OnchainCrossChainOrder calldata order) external {\n        (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData) = _resolve(order);\n\n        IERC20(acrossOrderData.inputToken).safeTransferFrom(msg.sender, address(this), acrossOrderData.inputAmount);\n\n        _callDeposit(\n            msg.sender,\n            acrossOrderData.recipient,\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOrderData.exclusiveRelayer,\n            // Note: simplifying assumption to avoid the order type having to bake in the quote timestamp.\n            SafeCast.toUint32(block.timestamp),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a GaslessCrossChainOrder and originFillerData.\n     * @param order the ERC-7683 compliant order.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, , ) = _resolveFor(order, originFillerData);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a CrossChainOrder.\n     * @param order the ERC7683 compliant order.\n     */\n    function resolve(OnchainCrossChainOrder calldata order)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, ) = _resolve(order);\n    }\n\n    /**\n     * @notice Decodes the Across specific orderData and fillerData into descriptive types.\n     * @param orderData the orderData field of the ERC7683 compliant order.\n     * @param fillerData Across-specific fillerData.\n     * @return acrossOrderData decoded AcrossOrderData.\n     * @return acrossOriginFillerData decoded AcrossOriginFillerData.\n     */\n    function decode(bytes memory orderData, bytes memory fillerData)\n        public\n        pure\n        returns (AcrossOrderData memory, AcrossOriginFillerData memory)\n    {\n        return (abi.decode(orderData, (AcrossOrderData)), abi.decode(fillerData, (AcrossOriginFillerData)));\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint32) {\n        return SafeCast.toUint32(block.timestamp); // solhint-disable-line not-rely-on-time\n    }\n\n    function _resolveFor(GaslessCrossChainOrder calldata order, bytes calldata fillerData)\n        internal\n        view\n        returns (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        )\n    {\n        // Ensure that order was intended to be settled by Across.\n        if (order.originSettler != address(this)) {\n            revert WrongSettlementContract();\n        }\n\n        if (order.originChainId != block.chainid) {\n            revert WrongChainId();\n        }\n\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        (acrossOrderData, acrossOriginFillerData) = decode(order.orderData, fillerData);\n\n        if (\n            acrossOrderData.exclusiveRelayer != address(0) &&\n            acrossOrderData.exclusiveRelayer != acrossOriginFillerData.exclusiveRelayer\n        ) {\n            revert WrongExclusiveRelayer();\n        }\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: _toBytes32(acrossOrderData.outputToken),\n            amount: acrossOrderData.outputAmount,\n            recipient: _toBytes32(acrossOrderData.recipient),\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: _toBytes32(acrossOrderData.inputToken),\n            amount: acrossOrderData.inputAmount,\n            recipient: _toBytes32(acrossOriginFillerData.exclusiveRelayer),\n            chainId: SafeCast.toUint32(block.chainid)\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: acrossOrderData.destinationChainId,\n            destinationSettler: _toBytes32(_destinationSettler(acrossOrderData.destinationChainId)),\n            originData: abi.encode(\n                order.user,\n                acrossOrderData.recipient,\n                acrossOriginFillerData.exclusiveRelayer,\n                acrossOrderData.inputToken,\n                acrossOrderData.outputToken,\n                acrossOrderData.inputAmount,\n                acrossOrderData.outputAmount,\n                block.chainid,\n                _currentDepositId(),\n                order.fillDeadline,\n                acrossOrderData.exclusivityPeriod,\n                acrossOrderData.message\n            )\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: order.user,\n            originChainId: order.originChainId,\n            openDeadline: order.openDeadline,\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions\n        });\n    }\n\n    function _resolve(OnchainCrossChainOrder calldata order)\n        internal\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData)\n    {\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        acrossOrderData = abi.decode(order.orderData, (AcrossOrderData));\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: _toBytes32(acrossOrderData.outputToken),\n            amount: acrossOrderData.outputAmount,\n            recipient: _toBytes32(acrossOrderData.recipient),\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: _toBytes32(acrossOrderData.inputToken),\n            amount: acrossOrderData.inputAmount,\n            recipient: _toBytes32(acrossOrderData.exclusiveRelayer),\n            chainId: SafeCast.toUint32(block.chainid)\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: acrossOrderData.destinationChainId,\n            destinationSettler: _toBytes32(_destinationSettler(acrossOrderData.destinationChainId)),\n            originData: abi.encode(\n                msg.sender,\n                acrossOrderData.recipient,\n                acrossOrderData.exclusiveRelayer,\n                acrossOrderData.inputToken,\n                acrossOrderData.outputToken,\n                acrossOrderData.inputAmount,\n                acrossOrderData.outputAmount,\n                block.chainid,\n                _currentDepositId(),\n                order.fillDeadline,\n                acrossOrderData.exclusivityPeriod,\n                acrossOrderData.message\n            )\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: msg.sender,\n            originChainId: SafeCast.toUint64(block.chainid),\n            openDeadline: type(uint32).max, // no deadline since the user is sending it\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions\n        });\n    }\n\n    function _processPermit2Order(\n        GaslessCrossChainOrder memory order,\n        AcrossOrderData memory acrossOrderData,\n        bytes memory signature\n    ) internal {\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({\n                token: acrossOrderData.inputToken,\n                amount: acrossOrderData.inputAmount\n            }),\n            nonce: order.nonce,\n            deadline: order.openDeadline\n        });\n\n        IPermit2.SignatureTransferDetails memory signatureTransferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: acrossOrderData.inputAmount\n        });\n\n        // Pull user funds.\n        PERMIT2.permitWitnessTransferFrom(\n            permit,\n            signatureTransferDetails,\n            order.user,\n            ERC7683Permit2Lib.hashOrder(order, ERC7683Permit2Lib.hashOrderData(acrossOrderData)), // witness data hash\n            ERC7683Permit2Lib.PERMIT2_ORDER_TYPE, // witness data type string\n            signature\n        );\n    }\n\n    function _toBytes32(address input) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(input)));\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes memory message\n    ) internal virtual;\n\n    function _currentDepositId() internal view virtual returns (uint32);\n\n    function _destinationSettler(uint256 chainId) internal view virtual returns (address);\n}\n"
    }
}