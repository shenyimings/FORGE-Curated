{
    "vfp_id": "vfp_00423",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "L1: Bond burning denial of service",
            "description": "The CSBondCore._burn function converts the amount of stETH to burn into shares, and if the resulting shares are zero, it returns early. However, after computing the stETH amount from the shares, it calls Burner.requestBurnMyStETH, which reverts if the converted shares amount is zero due to rounding errors. This creates a denial of service risk where small bond amounts that should be burned may cause the function to revert unexpectedly. The root cause is the double conversion between stETH and shares and the lack of a check for negligible stETH amounts before initiating the burn. This can prevent legitimate penalty enforcement and leave dust shares stranded in the contract.\n",
            "severity": "Low",
            "location": [
                "CSBondCore.sol::_burn#203-211",
                "Burner.sol::_requestBurn"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/abstract/CSBondCore.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/core/contracts/0.8.9/Burner.sol"
            ]
        }
    ],
    "affected_files": {
        "Burner.sol": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts-v4.4/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts-v4.4/token/ERC721/IERC721.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-v4.4/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts-v4.4/utils/math/Math.sol\";\n\nimport {AccessControlEnumerable} from \"./utils/access/AccessControlEnumerable.sol\";\nimport {IBurner} from \"../common/interfaces/IBurner.sol\";\n\n/**\n  * @title Interface defining ERC20-compatible StETH token\n  */\ninterface IStETH is IERC20 {\n    /**\n      * @notice Get stETH amount by the provided shares amount\n      * @param _sharesAmount shares amount\n      * @dev dual to `getSharesByPooledEth`.\n      */\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    /**\n      * @notice Get shares amount by the provided stETH amount\n      * @param _pooledEthAmount stETH amount\n      * @dev dual to `getPooledEthByShares`.\n      */\n    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);\n\n    /**\n      * @notice Get shares amount of the provided account\n      * @param _account provided account address.\n      */\n    function sharesOf(address _account) external view returns (uint256);\n\n    /**\n      * @notice Transfer `_sharesAmount` stETH shares from `_sender` to `_receiver` using allowance.\n      */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256);\n}\n\n/**\n  * @notice A dedicated contract for stETH burning requests scheduling\n  *\n  * @dev Burning stETH means 'decrease total underlying shares amount to perform stETH positive token rebase'\n  */\ncontract Burner is IBurner, AccessControlEnumerable {\n    using SafeERC20 for IERC20;\n\n    error AppAuthLidoFailed();\n    error DirectETHTransfer();\n    error ZeroRecoveryAmount();\n    error StETHRecoveryWrongFunc();\n    error ZeroBurnAmount();\n    error BurnAmountExceedsActual(uint256 requestedAmount, uint256 actualAmount);\n    error ZeroAddress(string field);\n\n    bytes32 public constant REQUEST_BURN_MY_STETH_ROLE = keccak256(\"REQUEST_BURN_MY_STETH_ROLE\");\n    bytes32 public constant REQUEST_BURN_SHARES_ROLE = keccak256(\"REQUEST_BURN_SHARES_ROLE\");\n\n    uint256 private coverSharesBurnRequested;\n    uint256 private nonCoverSharesBurnRequested;\n\n    uint256 private totalCoverSharesBurnt;\n    uint256 private totalNonCoverSharesBurnt;\n\n    address public immutable STETH;\n    address public immutable TREASURY;\n\n    /**\n      * Emitted when a new stETH burning request is added by the `requestedBy` address.\n      */\n    event StETHBurnRequested(\n        bool indexed isCover,\n        address indexed requestedBy,\n        uint256 amountOfStETH,\n        uint256 amountOfShares\n    );\n\n    /**\n      * Emitted when the stETH `amount` (corresponding to `amountOfShares` shares) burnt for the `isCover` reason.\n      */\n    event StETHBurnt(\n        bool indexed isCover,\n        uint256 amountOfStETH,\n        uint256 amountOfShares\n    );\n\n    /**\n      * Emitted when the excessive stETH `amount` (corresponding to `amountOfShares` shares) recovered (i.e. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ExcessStETHRecovered(\n        address indexed requestedBy,\n        uint256 amountOfStETH,\n        uint256 amountOfShares\n    );\n\n    /**\n      * Emitted when the ERC20 `token` recovered (i.e. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC20Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 amount\n    );\n\n    /**\n      * Emitted when the ERC721-compatible `token` (NFT) recovered (i.e. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC721Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 tokenId\n    );\n\n    /**\n      * Ctor\n      *\n      * @param _admin the Lido DAO Aragon agent contract address\n      * @param _treasury the Lido treasury address (see StETH/ERC20/ERC721-recovery interfaces)\n      * @param _stETH stETH token address\n      * @param _totalCoverSharesBurnt Shares burnt counter init value (cover case)\n      * @param _totalNonCoverSharesBurnt Shares burnt counter init value (non-cover case)\n      */\n    constructor(\n        address _admin,\n        address _treasury,\n        address _stETH,\n        uint256 _totalCoverSharesBurnt,\n        uint256 _totalNonCoverSharesBurnt\n    ) {\n        if (_admin == address(0)) revert ZeroAddress(\"_admin\");\n        if (_treasury == address(0)) revert ZeroAddress(\"_treasury\");\n        if (_stETH == address(0)) revert ZeroAddress(\"_stETH\");\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(REQUEST_BURN_SHARES_ROLE, _stETH);\n\n        TREASURY = _treasury;\n        STETH = _stETH;\n\n        totalCoverSharesBurnt = _totalCoverSharesBurnt;\n        totalNonCoverSharesBurnt = _totalNonCoverSharesBurnt;\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      *\n      * Transfers `_stETHAmountToBurn` stETH tokens from the message sender and irreversibly locks these\n      * on the burner contract address. Internally converts `_stETHAmountToBurn` amount into underlying\n      * shares amount (`_stETHAmountToBurnAsShares`) and marks the converted amount for burning\n      * by increasing the `coverSharesBurnRequested` counter.\n      *\n      * @param _stETHAmountToBurn stETH tokens to burn\n      *\n      */\n    function requestBurnMyStETHForCover(uint256 _stETHAmountToBurn) external onlyRole(REQUEST_BURN_MY_STETH_ROLE) {\n        IStETH(STETH).transferFrom(msg.sender, address(this), _stETHAmountToBurn);\n        uint256 sharesAmount = IStETH(STETH).getSharesByPooledEth(_stETHAmountToBurn);\n        _requestBurn(sharesAmount, _stETHAmountToBurn, true /* _isCover */);\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      *\n      * Transfers `_sharesAmountToBurn` stETH shares from `_from` and irreversibly locks these\n      * on the burner contract address. Marks the shares amount for burning\n      * by increasing the `coverSharesBurnRequested` counter.\n      *\n      * @param _from address to transfer shares from\n      * @param _sharesAmountToBurn stETH shares to burn\n      *\n      */\n    function requestBurnSharesForCover(address _from, uint256 _sharesAmountToBurn) external onlyRole(REQUEST_BURN_SHARES_ROLE) {\n        uint256 stETHAmount = IStETH(STETH).transferSharesFrom(_from, address(this), _sharesAmountToBurn);\n        _requestBurn(_sharesAmountToBurn, stETHAmount, true /* _isCover */);\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      *\n      * Transfers `_stETHAmountToBurn` stETH tokens from the message sender and irreversibly locks these\n      * on the burner contract address. Internally converts `_stETHAmountToBurn` amount into underlying\n      * shares amount (`_stETHAmountToBurnAsShares`) and marks the converted amount for burning\n      * by increasing the `nonCoverSharesBurnRequested` counter.\n      *\n      * @param _stETHAmountToBurn stETH tokens to burn\n      *\n      */\n    function requestBurnMyStETH(uint256 _stETHAmountToBurn) external onlyRole(REQUEST_BURN_MY_STETH_ROLE) {\n        IStETH(STETH).transferFrom(msg.sender, address(this), _stETHAmountToBurn);\n        uint256 sharesAmount = IStETH(STETH).getSharesByPooledEth(_stETHAmountToBurn);\n        _requestBurn(sharesAmount, _stETHAmountToBurn, false /* _isCover */);\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      *\n      * Transfers `_sharesAmountToBurn` stETH shares from `_from` and irreversibly locks these\n      * on the burner contract address. Marks the shares amount for burning\n      * by increasing the `nonCoverSharesBurnRequested` counter.\n      *\n      * @param _from address to transfer shares from\n      * @param _sharesAmountToBurn stETH shares to burn\n      *\n      */\n    function requestBurnShares(address _from, uint256 _sharesAmountToBurn) external onlyRole(REQUEST_BURN_SHARES_ROLE) {\n        uint256 stETHAmount = IStETH(STETH).transferSharesFrom(_from, address(this), _sharesAmountToBurn);\n        _requestBurn(_sharesAmountToBurn, stETHAmount, false /* _isCover */);\n    }\n\n    /**\n      * Transfers the excess stETH amount (e.g. belonging to the burner contract address\n      * but not marked for burning) to the Lido treasury address set upon the\n      * contract construction.\n      */\n    function recoverExcessStETH() external {\n        uint256 excessStETH = getExcessStETH();\n\n        if (excessStETH > 0) {\n            uint256 excessSharesAmount = IStETH(STETH).getSharesByPooledEth(excessStETH);\n\n            emit ExcessStETHRecovered(msg.sender, excessStETH, excessSharesAmount);\n\n            IStETH(STETH).transfer(TREASURY, excessStETH);\n        }\n    }\n\n    /**\n      * Intentionally deny incoming ether\n      */\n    receive() external payable {\n        revert DirectETHTransfer();\n    }\n\n    /**\n      * Transfers a given `_amount` of an ERC20-token (defined by the `_token` contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC20-compatible token\n      * @param _amount token amount\n      */\n    function recoverERC20(address _token, uint256 _amount) external {\n        if (_amount == 0) revert ZeroRecoveryAmount();\n        if (_token == STETH) revert StETHRecoveryWrongFunc();\n\n        emit ERC20Recovered(msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(TREASURY, _amount);\n    }\n\n    /**\n      * Transfers a given token_id of an ERC721-compatible NFT (defined by the token contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC721-compatible token\n      * @param _tokenId minted token id\n      */\n    function recoverERC721(address _token, uint256 _tokenId) external {\n        if (_token == STETH) revert StETHRecoveryWrongFunc();\n\n        emit ERC721Recovered(msg.sender, _token, _tokenId);\n\n        IERC721(_token).transferFrom(address(this), TREASURY, _tokenId);\n    }\n\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     *\n     * Increments `totalCoverSharesBurnt` and `totalNonCoverSharesBurnt` counters.\n     * Decrements `coverSharesBurnRequested` and `nonCoverSharesBurnRequested` counters.\n     * Does nothing if zero amount passed.\n     *\n     * @param _sharesToBurn amount of shares to be burnt\n     */\n    function commitSharesToBurn(uint256 _sharesToBurn) external virtual override {\n        if (msg.sender != STETH) revert AppAuthLidoFailed();\n\n        if (_sharesToBurn == 0) {\n            return;\n        }\n\n        uint256 memCoverSharesBurnRequested = coverSharesBurnRequested;\n        uint256 memNonCoverSharesBurnRequested = nonCoverSharesBurnRequested;\n\n        uint256 burnAmount = memCoverSharesBurnRequested + memNonCoverSharesBurnRequested;\n\n        if (_sharesToBurn > burnAmount) {\n            revert BurnAmountExceedsActual(_sharesToBurn, burnAmount);\n        }\n\n        uint256 sharesToBurnNow;\n        if (memCoverSharesBurnRequested > 0) {\n            uint256 sharesToBurnNowForCover = Math.min(_sharesToBurn, memCoverSharesBurnRequested);\n\n            totalCoverSharesBurnt += sharesToBurnNowForCover;\n            uint256 stETHToBurnNowForCover = IStETH(STETH).getPooledEthByShares(sharesToBurnNowForCover);\n            emit StETHBurnt(true /* isCover */, stETHToBurnNowForCover, sharesToBurnNowForCover);\n\n            coverSharesBurnRequested -= sharesToBurnNowForCover;\n            sharesToBurnNow += sharesToBurnNowForCover;\n        }\n        if (memNonCoverSharesBurnRequested > 0 && sharesToBurnNow < _sharesToBurn) {\n            uint256 sharesToBurnNowForNonCover = Math.min(\n                _sharesToBurn - sharesToBurnNow,\n                memNonCoverSharesBurnRequested\n            );\n\n            totalNonCoverSharesBurnt += sharesToBurnNowForNonCover;\n            uint256 stETHToBurnNowForNonCover = IStETH(STETH).getPooledEthByShares(sharesToBurnNowForNonCover);\n            emit StETHBurnt(false /* isCover */, stETHToBurnNowForNonCover, sharesToBurnNowForNonCover);\n\n            nonCoverSharesBurnRequested -= sharesToBurnNowForNonCover;\n            sharesToBurnNow += sharesToBurnNowForNonCover;\n        }\n        assert(sharesToBurnNow == _sharesToBurn);\n    }\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view virtual override returns (\n        uint256 coverShares, uint256 nonCoverShares\n    ) {\n        coverShares = coverSharesBurnRequested;\n        nonCoverShares = nonCoverSharesBurnRequested;\n    }\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view virtual override returns (uint256) {\n        return totalCoverSharesBurnt;\n    }\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view virtual override returns (uint256) {\n        return totalNonCoverSharesBurnt;\n    }\n\n    /**\n      * Returns the stETH amount belonging to the burner contract address but not marked for burning.\n      */\n    function getExcessStETH() public view returns (uint256)  {\n        return IStETH(STETH).getPooledEthByShares(_getExcessStETHShares());\n    }\n\n    function _getExcessStETHShares() internal view returns (uint256) {\n        uint256 sharesBurnRequested = (coverSharesBurnRequested + nonCoverSharesBurnRequested);\n        uint256 totalShares = IStETH(STETH).sharesOf(address(this));\n\n        // sanity check, don't revert\n        if (totalShares <= sharesBurnRequested) {\n            return 0;\n        }\n\n        return totalShares - sharesBurnRequested;\n    }\n\n    function _requestBurn(uint256 _sharesAmount, uint256 _stETHAmount, bool _isCover) private {\n        if (_sharesAmount == 0) revert ZeroBurnAmount();\n\n        emit StETHBurnRequested(_isCover, msg.sender, _stETHAmount, _sharesAmount);\n\n        if (_isCover) {\n            coverSharesBurnRequested += _sharesAmount;\n        } else {\n            nonCoverSharesBurnRequested += _sharesAmount;\n        }\n    }\n}\n",
        "CSBondCore.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { ILidoLocator } from \"../interfaces/ILidoLocator.sol\";\nimport { ILido } from \"../interfaces/ILido.sol\";\nimport { IBurner } from \"../interfaces/IBurner.sol\";\nimport { IWstETH } from \"../interfaces/IWstETH.sol\";\nimport { IWithdrawalQueue } from \"../interfaces/IWithdrawalQueue.sol\";\nimport { ICSBondCore } from \"../interfaces/ICSBondCore.sol\";\n\n/// @dev Bond core mechanics abstract contract\n///\n/// It gives basic abilities to manage bond shares (stETH) of the Node Operator.\n///\n/// It contains:\n///  - store bond shares (stETH)\n///  - get bond shares (stETH) and bond amount\n///  - deposit ETH/stETH/wstETH\n///  - claim ETH/stETH/wstETH\n///  - burn\n///\n/// Should be inherited by Module contract, or Module-related contract.\n/// Internal non-view methods should be used in Module contract with additional requirements (if any).\n///\n/// @author vgorkavenko\nabstract contract CSBondCore is ICSBondCore {\n    /// @custom:storage-location erc7201:CSBondCore\n    struct CSBondCoreStorage {\n        mapping(uint256 nodeOperatorId => uint256 shares) bondShares;\n        uint256 totalBondShares;\n    }\n\n    ILidoLocator public immutable LIDO_LOCATOR;\n    ILido public immutable LIDO;\n    IWithdrawalQueue public immutable WITHDRAWAL_QUEUE;\n    IWstETH public immutable WSTETH;\n\n    // keccak256(abi.encode(uint256(keccak256(\"CSBondCore\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant CS_BOND_CORE_STORAGE_LOCATION =\n        0x23f334b9eb5378c2a1573857b8f9d9ca79959360a69e73d3f16848e56ec92100;\n\n    constructor(address lidoLocator) {\n        if (lidoLocator == address(0)) {\n            revert ZeroLocatorAddress();\n        }\n        LIDO_LOCATOR = ILidoLocator(lidoLocator);\n        LIDO = ILido(LIDO_LOCATOR.lido());\n        WITHDRAWAL_QUEUE = IWithdrawalQueue(LIDO_LOCATOR.withdrawalQueue());\n        WSTETH = IWstETH(WITHDRAWAL_QUEUE.WSTETH());\n    }\n\n    /// @inheritdoc ICSBondCore\n    function totalBondShares() public view returns (uint256) {\n        return _getCSBondCoreStorage().totalBondShares;\n    }\n\n    /// @inheritdoc ICSBondCore\n    function getBondShares(\n        uint256 nodeOperatorId\n    ) public view returns (uint256) {\n        return _getCSBondCoreStorage().bondShares[nodeOperatorId];\n    }\n\n    /// @inheritdoc ICSBondCore\n    function getBond(uint256 nodeOperatorId) public view returns (uint256) {\n        return _ethByShares(getBondShares(nodeOperatorId));\n    }\n\n    /// @dev Stake user's ETH with Lido and stores stETH shares as Node Operator's bond shares\n    function _depositETH(address from, uint256 nodeOperatorId) internal {\n        if (msg.value == 0) {\n            return;\n        }\n\n        uint256 shares = LIDO.submit{ value: msg.value }({\n            _referal: address(0)\n        });\n        _increaseBond(nodeOperatorId, shares);\n        emit BondDepositedETH(nodeOperatorId, from, msg.value);\n    }\n\n    /// @dev Transfer user's stETH to the contract and stores stETH shares as Node Operator's bond shares\n    function _depositStETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 shares = _sharesByEth(amount);\n        LIDO.transferSharesFrom(from, address(this), shares);\n        _increaseBond(nodeOperatorId, shares);\n        emit BondDepositedStETH(nodeOperatorId, from, amount);\n    }\n\n    /// @dev Transfer user's wstETH to the contract, unwrap and store stETH shares as Node Operator's bond shares\n    function _depositWstETH(\n        address from,\n        uint256 nodeOperatorId,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        WSTETH.transferFrom(from, address(this), amount);\n        uint256 sharesBefore = LIDO.sharesOf(address(this));\n        WSTETH.unwrap(amount);\n        uint256 sharesAfter = LIDO.sharesOf(address(this));\n        _increaseBond(nodeOperatorId, sharesAfter - sharesBefore);\n        emit BondDepositedWstETH(nodeOperatorId, from, amount);\n    }\n\n    function _increaseBond(uint256 nodeOperatorId, uint256 shares) internal {\n        if (shares == 0) {\n            return;\n        }\n\n        CSBondCoreStorage storage $ = _getCSBondCoreStorage();\n        unchecked {\n            $.bondShares[nodeOperatorId] += shares;\n            $.totalBondShares += shares;\n        }\n    }\n\n    /// @dev Claim Node Operator's excess bond shares (stETH) in ETH by requesting withdrawal from the protocol\n    ///      As a usual withdrawal request, this claim might be processed on the next stETH rebase\n    function _claimUnstETH(\n        uint256 nodeOperatorId,\n        uint256 requestedAmountToClaim,\n        address to\n    ) internal returns (uint256 requestId) {\n        uint256 claimableShares = _getClaimableBondShares(nodeOperatorId);\n        uint256 sharesToClaim = requestedAmountToClaim <\n            _ethByShares(claimableShares)\n            ? _sharesByEth(requestedAmountToClaim)\n            : claimableShares;\n        if (sharesToClaim == 0) {\n            revert NothingToClaim();\n        }\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _ethByShares(sharesToClaim);\n\n        uint256 sharesBefore = LIDO.sharesOf(address(this));\n        requestId = WITHDRAWAL_QUEUE.requestWithdrawals(amounts, to)[0];\n        uint256 sharesAfter = LIDO.sharesOf(address(this));\n\n        _unsafeReduceBond(nodeOperatorId, sharesBefore - sharesAfter);\n        emit BondClaimedUnstETH(nodeOperatorId, to, amounts[0], requestId);\n    }\n\n    /// @dev Claim Node Operator's excess bond shares (stETH) in stETH by transferring shares from the contract\n    function _claimStETH(\n        uint256 nodeOperatorId,\n        uint256 requestedAmountToClaim,\n        address to\n    ) internal returns (uint256 sharesToClaim) {\n        uint256 claimableShares = _getClaimableBondShares(nodeOperatorId);\n        sharesToClaim = requestedAmountToClaim < _ethByShares(claimableShares)\n            ? _sharesByEth(requestedAmountToClaim)\n            : claimableShares;\n        if (sharesToClaim == 0) {\n            revert NothingToClaim();\n        }\n\n        _unsafeReduceBond(nodeOperatorId, sharesToClaim);\n\n        uint256 ethAmount = LIDO.transferShares(to, sharesToClaim);\n        emit BondClaimedStETH(nodeOperatorId, to, ethAmount);\n    }\n\n    /// @dev Claim Node Operator's excess bond shares (stETH) in wstETH by wrapping stETH from the contract and transferring wstETH\n    function _claimWstETH(\n        uint256 nodeOperatorId,\n        uint256 requestedAmountToClaim,\n        address to\n    ) internal returns (uint256 wstETHAmount) {\n        uint256 claimableShares = _getClaimableBondShares(nodeOperatorId);\n        uint256 sharesToClaim = requestedAmountToClaim < claimableShares\n            ? requestedAmountToClaim\n            : claimableShares;\n        if (sharesToClaim == 0) {\n            revert NothingToClaim();\n        }\n\n        uint256 sharesBefore = LIDO.sharesOf(address(this));\n        wstETHAmount = WSTETH.wrap(_ethByShares(sharesToClaim));\n        uint256 sharesAfter = LIDO.sharesOf(address(this));\n        _unsafeReduceBond(nodeOperatorId, sharesBefore - sharesAfter);\n        WSTETH.transfer(to, wstETHAmount);\n        emit BondClaimedWstETH(nodeOperatorId, to, wstETHAmount);\n    }\n\n    /// @dev Burn Node Operator's bond shares (stETH). Shares will be burned on the next stETH rebase\n    /// @dev The contract that uses this implementation should be granted `Burner.REQUEST_BURN_MY_STETH_ROLE` and have stETH allowance for `Burner`\n    /// @param amount Bond amount to burn in ETH (stETH)\n    function _burn(uint256 nodeOperatorId, uint256 amount) internal {\n        uint256 sharesToBurn = _sharesByEth(amount);\n        uint256 burnedShares = _reduceBond(nodeOperatorId, sharesToBurn);\n        // If no bond already\n        if (burnedShares == 0) {\n            return;\n        }\n\n        uint256 burnedAmount = _ethByShares(burnedShares);\n        IBurner(LIDO_LOCATOR.burner()).requestBurnMyStETH(burnedAmount);\n\n        emit BondBurned(\n            nodeOperatorId,\n            _ethByShares(sharesToBurn),\n            burnedAmount\n        );\n    }\n\n    /// @dev Transfer Node Operator's bond shares (stETH) to charge recipient\n    /// @param amount Bond amount to charge in ETH (stETH)\n    /// @param recipient Address to send charged shares\n    function _charge(\n        uint256 nodeOperatorId,\n        uint256 amount,\n        address recipient\n    ) internal {\n        uint256 toChargeShares = _sharesByEth(amount);\n        uint256 chargedShares = _reduceBond(nodeOperatorId, toChargeShares);\n        uint256 chargedEth = LIDO.transferShares(recipient, chargedShares);\n        emit BondCharged(\n            nodeOperatorId,\n            _ethByShares(toChargeShares),\n            chargedEth\n        );\n    }\n\n    /// @dev Must be overridden in case of additional restrictions on a claimable bond amount\n    function _getClaimableBondShares(\n        uint256 nodeOperatorId\n    ) internal view virtual returns (uint256) {\n        return _getCSBondCoreStorage().bondShares[nodeOperatorId];\n    }\n\n    /// @dev Shortcut for Lido's getSharesByPooledEth\n    function _sharesByEth(uint256 ethAmount) internal view returns (uint256) {\n        if (ethAmount == 0) {\n            return 0;\n        }\n\n        return LIDO.getSharesByPooledEth(ethAmount);\n    }\n\n    /// @dev Shortcut for Lido's getPooledEthByShares\n    function _ethByShares(uint256 shares) internal view returns (uint256) {\n        if (shares == 0) {\n            return 0;\n        }\n\n        return LIDO.getPooledEthByShares(shares);\n    }\n\n    /// @dev Unsafe reduce bond shares (stETH) (possible underflow). Safety checks should be done outside\n    function _unsafeReduceBond(uint256 nodeOperatorId, uint256 shares) private {\n        CSBondCoreStorage storage $ = _getCSBondCoreStorage();\n        $.bondShares[nodeOperatorId] -= shares;\n        $.totalBondShares -= shares;\n    }\n\n    /// @dev Safe reduce bond shares (stETH). The maximum shares to reduce is the current bond shares\n    function _reduceBond(\n        uint256 nodeOperatorId,\n        uint256 shares\n    ) private returns (uint256 reducedShares) {\n        uint256 currentShares = getBondShares(nodeOperatorId);\n        reducedShares = shares < currentShares ? shares : currentShares;\n        _unsafeReduceBond(nodeOperatorId, reducedShares);\n    }\n\n    function _getCSBondCoreStorage()\n        private\n        pure\n        returns (CSBondCoreStorage storage $)\n    {\n        assembly {\n            $.slot := CS_BOND_CORE_STORAGE_LOCATION\n        }\n    }\n}\n"
    }
}