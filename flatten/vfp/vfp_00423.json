{
    "vfp_id": "vfp_00423",
    "project_name": "cantina_sky_grove_alm_controller_july2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Relayer can choose remoteExtraGasLimit for transferSharesCentrifuge",
            "description": "1. **Description:** The transferSharesCentrifuge function allows the relayer to specify a remoteExtraGasLimit parameter of type uint128. However, this parameter is not used in the current implementation of Centrifuge V3, as both execution paths in MessageDispatcher.sendExecuteTransferShares ignore it.\n\n2. **Cause:** The function includes a parameter that has no effect on execution, likely due to an outdated or misaligned interface design with the target protocol (Centrifuge V3).\n\n3. **Exploitation:** While the parameter is currently ignored, a relayer could set arbitrary values, potentially leading to confusion or future vulnerabilities if the parameter is later used without proper validation. It may also mislead developers into assuming gas limits are enforced.\n\n4. **Impact:** The primary impact is code clarity and maintainability. If future versions of Centrifuge V3 start using this parameter, unvalidated inputs could lead to gas-related attacks or failed transactions. Additionally, it increases the risk of incorrect assumptions during integration or upgrades.\n",
            "severity": "Low",
            "location": [
                "ForeignController.sol::transferSharesCentrifuge"
            ],
            "files": [
                "grove-alm-controller/src/ForeignController.sol"
            ]
        }
    ],
    "affected_files": {
        "ForeignController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { IERC7540 } from \"forge-std/interfaces/IERC7540.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IERC20 }   from \"openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\n\nimport { IPSM3 } from \"spark-psm/src/interfaces/IPSM3.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport { ICentrifugeV3VaultLike, IAsyncRedeemManagerLike, ISpokeLike } from \"./interfaces/CentrifugeInterfaces.sol\";\n\nimport \"./interfaces/ILayerZero.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ncontract ForeignController is AccessControl {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    // NOTE: This is used to track individual transfers for offchain processing of CCTP transactions\n    event CCTPTransferInitiated(\n        uint64  indexed nonce,\n        uint32  indexed destinationDomain,\n        bytes32 indexed mintRecipient,\n        uint256 usdcAmount\n    );\n\n    event CentrifugeRecipientSet(uint16 indexed destinationCentrifugeId, bytes32 recipient);\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT        = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW       = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_7540_DEPOSIT        = keccak256(\"LIMIT_7540_DEPOSIT\");\n    bytes32 public constant LIMIT_7540_REDEEM         = keccak256(\"LIMIT_7540_REDEEM\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT        = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW       = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_CENTRIFUGE_TRANSFER = keccak256(\"LIMIT_CENTRIFUGE_TRANSFER\");\n    bytes32 public constant LIMIT_LAYERZERO_TRANSFER  = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public constant LIMIT_PSM_DEPOSIT         = keccak256(\"LIMIT_PSM_DEPOSIT\");\n    bytes32 public constant LIMIT_PSM_WITHDRAW        = keccak256(\"LIMIT_PSM_WITHDRAW\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP        = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN      = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n\n    uint256 internal constant CENTRIFUGE_REQUEST_ID = 0;\n\n    IALMProxy   public immutable proxy;\n    ICCTPLike   public immutable cctp;\n    IPSM3       public immutable psm;\n    IRateLimits public immutable rateLimits;\n\n    IERC20 public immutable usdc;\n\n    mapping(uint32 destinationDomain       => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId   => bytes32 layerZeroRecipient) public layerZeroRecipients;\n    mapping(uint16 destinationCentrifugeId => bytes32 recipient)          public centrifugeRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address psm_,\n        address usdc_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        psm        = IPSM3(psm_);\n        usdc       = IERC20(usdc_);\n        cctp       = ICCTPLike(cctp_);\n    }\n\n    /**********************************************************************************************/\n    /*** Modifiers                                                                              ***/\n    /**********************************************************************************************/\n\n    modifier rateLimited(bytes32 key, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n        _;\n    }\n\n    modifier rateLimitedAsset(bytes32 key, address asset, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n        _;\n    }\n\n    modifier rateLimitExists(bytes32 key) {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"ForeignController/invalid-action\"\n        );\n        _;\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(uint32 destinationEndpointId, bytes32 layerZeroRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    function setCentrifugeRecipient(uint16 destinationCentrifugeId, bytes32 recipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        centrifugeRecipients[destinationCentrifugeId] = recipient;\n        emit CentrifugeRecipientSet(destinationCentrifugeId, recipient);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external onlyRole(FREEZER) {\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    function depositPSM(address asset, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_PSM_DEPOSIT, asset, amount)\n        returns (uint256 shares)\n    {\n        // Approve `asset` to PSM from the proxy (assumes the proxy has enough `asset`).\n        _approve(asset, address(psm), amount);\n\n        // Deposit `amount` of `asset` in the PSM, decode the result to get `shares`.\n        shares = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.deposit,\n                    (asset, address(proxy), amount)\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawPSM(address asset, uint256 maxAmount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assetsWithdrawn)\n    {\n        // Withdraw up to `maxAmount` of `asset` in the PSM, decode the result\n        // to get `assetsWithdrawn` (assumes the proxy has enough PSM shares).\n        assetsWithdrawn = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.withdraw,\n                    (asset, address(proxy), maxAmount)\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_PSM_WITHDRAW, asset),\n            assetsWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain)\n        external\n        onlyRole(RELAYER)\n        rateLimited(LIMIT_USDC_TO_CCTP, usdcAmount)\n        rateLimited(\n            RateLimitHelpers.makeDomainKey(LIMIT_USDC_TO_DOMAIN, destinationDomain),\n            usdcAmount\n        )\n    {\n        bytes32 mintRecipient = mintRecipients[destinationDomain];\n\n        require(mintRecipient != 0, \"ForeignController/domain-not-configured\");\n\n        // Approve USDC to CCTP from the proxy (assumes the proxy has enough USDC).\n        _approve(address(usdc), address(cctp), usdcAmount);\n\n        // If amount is larger than limit it must be split into multiple calls.\n        uint256 burnLimit = cctp.localMinter().burnLimitsPerMessage(address(usdc));\n\n        while (usdcAmount > burnLimit) {\n            _initiateCCTPTransfer(burnLimit, destinationDomain, mintRecipient);\n            usdcAmount -= burnLimit;\n        }\n\n        // Send remaining amount (if any)\n        if (usdcAmount > 0) {\n            _initiateCCTPTransfer(usdcAmount, destinationDomain, mintRecipient);\n        }\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external payable\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        // NOTE: Full integration testing of this logic is not possible without OFTs with\n        //       approvalRequired == true. Add integration testing for this case before\n        //       using in production.\n        if (ILayerZero(oftAddress).approvalRequired()) {\n            _approve(ILayerZero(oftAddress).token(), oftAddress, amount);\n        }\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue{value: fee.nativeFee}(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount)\n        returns (uint256 shares)\n    {\n        // Note that whitelist is done by rate limits.\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount)\n        returns (uint256 shares)\n    {\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assets)\n    {\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC7540 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function requestDepositERC7540(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_7540_DEPOSIT, token, amount)\n    {\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC7540(token).asset());\n\n        // Approve asset to vault from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Submit deposit request by transferring assets\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestDeposit, (amount, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimDepositERC7540(address token)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token))\n    {\n\n        uint256 shares = IERC7540(token).maxMint(address(proxy));\n\n        // Claim shares from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC4626(token).mint, (shares, address(proxy)))\n        );\n    }\n\n    function requestRedeemERC7540(address token, uint256 shares)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_7540_REDEEM, token, IERC7540(token).convertToAssets(shares))\n    {\n        // Submit redeem request by transferring shares\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestRedeem, (shares, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimRedeemERC7540(address token)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token))\n    {\n        uint256 assets = IERC7540(token).maxWithdraw(address(proxy));\n\n        // Claim assets from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).withdraw, (assets, address(proxy), address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Centrifuge functions                                                           ***/\n    /**********************************************************************************************/\n\n    // NOTE: These cancelation methods are compatible with ERC-7887\n\n    function cancelCentrifugeDepositRequest(address token)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token))\n    {\n        // NOTE: While the cancelation is pending, no new deposit request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeV3VaultLike(token).cancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelDepositRequest(address token)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token))\n    {\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeV3VaultLike(token).claimCancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    function cancelCentrifugeRedeemRequest(address token)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token))\n    {\n        // NOTE: While the cancelation is pending, no new redeem request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeV3VaultLike(token).cancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelRedeemRequest(address token)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token))\n    {\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeV3VaultLike(token).claimCancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    function transferSharesCentrifuge(\n        address token,\n        uint128 amount,\n        uint16  destinationCentrifugeId\n    )\n        external payable\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_CENTRIFUGE_TRANSFER, token, destinationCentrifugeId)),\n            amount\n        );\n\n        bytes32 recipient = centrifugeRecipients[destinationCentrifugeId];\n        require(recipient != 0, \"ForeignController/centrifuge-id-not-configured\");\n\n        ICentrifugeV3VaultLike centrifugeVault = ICentrifugeV3VaultLike(token);\n\n        address spoke = IAsyncRedeemManagerLike(centrifugeVault.manager()).spoke();\n\n        // Initiate cross-chain transfer via the specific spoke address\n        proxy.doCallWithValue{value: msg.value}(\n            spoke,\n            abi.encodeCall(\n                ISpokeLike(spoke).crosschainTransferShares,\n                (\n                    destinationCentrifugeId,\n                    centrifugeVault.poolId(),\n                    centrifugeVault.scId(),\n                    recipient,\n                    amount,\n                    0\n                )\n            ),\n            msg.value\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount)\n    {\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens.\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 amountWithdrawn)\n    {\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Morpho functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setSupplyQueueMorpho(address morphoVault, Id[] memory newSupplyQueue)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).setSupplyQueue, (newSupplyQueue))\n        );\n    }\n\n    function updateWithdrawQueueMorpho(address morphoVault, uint256[] calldata indexes)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).updateWithdrawQueue, (indexes))\n        );\n    }\n\n    function reallocateMorpho(address morphoVault, MarketAllocation[] calldata allocations)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).reallocate, (allocations))\n        );\n    }\n\n\n    /**********************************************************************************************/\n    /*** Internal helper functions                                                              ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        bytes memory approveCallReturnData;\n\n        if (success) {\n            // Data is the ABI-encoding of the approve call bytes return data, need to\n            // decode it first\n            approveCallReturnData = abi.decode(data, (bytes));\n            // Approve was successful if 1) no return value or 2) true return value\n            if (approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool))) {\n                return;\n            }\n        }\n\n        // If call was unsuccessful, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n\n        approveCallReturnData = proxy.doCall(token, approveData);\n\n        // Revert if approve returns false\n        require(\n            approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool)),\n            \"ForeignController/approve-failed\"\n        );\n    }\n\n    function _initiateCCTPTransfer(\n        uint256 usdcAmount,\n        uint32  destinationDomain,\n        bytes32 mintRecipient\n    )\n        internal\n    {\n        uint64 nonce = abi.decode(\n            proxy.doCall(\n                address(cctp),\n                abi.encodeCall(\n                    cctp.depositForBurn,\n                    (\n                        usdcAmount,\n                        destinationDomain,\n                        mintRecipient,\n                        address(usdc)\n                    )\n                )\n            ),\n            (uint64)\n        );\n\n        emit CCTPTransferInitiated(nonce, destinationDomain, mintRecipient, usdcAmount);\n    }\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n}\n"
    }
}