{
    "vfp_id": "vfp_00423",
    "project_name": "ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "findings": [
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-1071"
                ]
            },
            "title": "Unimplemented Function Can Be Called",
            "description": "The contracts GasCompZapper and WETHZapper define functions `receiveFlashLoanOnOpenLeveragedTrove`, `receiveFlashLoanOnLeverUpTrove`, and `receiveFlashLoanOnLeverDownTrove` with empty function bodies, meaning they can be called but perform no operations. The root cause is that these contracts are not marked as abstract despite containing unimplemented logic. An attacker or user could call these functions expecting them to revert or perform actions, leading to confusion or misuse. The impact is low, as no state changes occur, but it may mislead integrators or users into believing functionality exists when it does not.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.sol",
                "WETHZapper.sol"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol",
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Payable Modifier",
            "description": "The function `WETHZapper.adjustZombieTroveWithRawETH` lacks the `payable` modifier, causing transactions that send Ether to revert.\n\nThe root cause is that the function is intended to receive Ether for conversion to WETH but was not marked as `payable`, violating Solidity's requirement for functions that accept Ether.\n\nAny attempt to call this function with Ether attached will fail, preventing the adjustment of zombie troves via this method.\n\nThe impact is that users cannot use the zapper function to fix zombie troves unless the contract is redeployed with the correct modifier, limiting functionality and potentially leading to full redemption of affected troves.\n",
            "severity": "Low",
            "location": [
                "WETHZapper.adjustZombieTroveWithRawETH"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Zapper Delegation Is Not Reset When a Trove Is Closed",
            "description": "When a trove is closed, its delegation to a zapper is not reset, allowing reuse of old delegations if a new trove with the same ID is created.\n\nThe root cause is that the system does not clear zapper role assignments upon trove closure, creating a potential for unintended access.\n\nAn attacker could create and close a trove to set malicious delegations, which could later be reused if a user opens a trove with the same ID.\n\nThe impact is that users may unknowingly grant control to a zapper with outdated or malicious delegations, leading to loss of control over their trove.\n",
            "severity": "Low",
            "location": [
                "Zapper delegation system",
                "troveId reuse"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "CEI Pattern Violated in Adjust Trove",
            "description": "The `WETHZapper._adjustTrovePost` function sends ETH before BOLD tokens, violating the Checks-Effects-Interactions (CEI) pattern.\n\nThe root cause is that the order of external calls places a non-reentrant token transfer after a potential reentrant call (ETH transfer).\n\nA malicious receiver could reenter the contract after receiving ETH but before BOLD is sent, potentially manipulating state.\n\nThe impact is risk of reentrancy-based manipulation, though BOLD is non-reentrant, reducing actual exploitability.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePost"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Inconsistent Input Validation by Zappers",
            "description": "Zapper contracts have inconsistent validation for debt increase operations, with some missing checks for non-zero `_boldChange`.\n\nThe root cause is divergent implementation between `WETHZapper` and `GasCompZapper`.\n\nAllows no-op calls that pass validation but have no effect, potentially confusing users or interfaces.\n\nThe impact is reduced code consistency and reliability, though no critical security impact due to downstream checks.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePre",
                "GasCompZapper._adjustTrovePre"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol",
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Misleading Function Names in Zapper",
            "description": "Functions in `GasCompZapper` use names like `adjustTroveWithRawETH` that imply ETH handling, even though no raw ETH is used.\n\nThe root cause is inconsistent naming across zapper implementations.\n\nMisleads developers and users about the actual behavior of the function.\n\nThe impact is confusion during integration and potential misuse of functions based on incorrect assumptions.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.adjustTroveWithRawETH",
                "LeverageLSTZapper"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        }
    ],
    "affected_files": {
        "GasCompZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./BaseZapper.sol\";\nimport \"../Dependencies/Constants.sol\";\n\ncontract GasCompZapper is BaseZapper {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable collToken;\n\n    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)\n        BaseZapper(_addressesRegistry, _flashLoanProvider, _exchange)\n    {\n        collToken = _addressesRegistry.collToken();\n        require(address(WETH) != address(collToken), \"GCZ: Wrong coll branch\");\n\n        // Approve WETH to BorrowerOperations\n        WETH.approve(address(borrowerOperations), type(uint256).max);\n        // Approve coll to BorrowerOperations\n        collToken.approve(address(borrowerOperations), type(uint256).max);\n        // Approve Coll to exchange module (for closeTroveFromCollateral)\n        collToken.approve(address(_exchange), type(uint256).max);\n    }\n\n    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256) {\n        require(msg.value == ETH_GAS_COMPENSATION, \"GCZ: Wrong ETH\");\n        require(\n            _params.batchManager == address(0) || _params.annualInterestRate == 0,\n            \"GCZ: Cannot choose interest if joining a batch\"\n        );\n\n        // Convert ETH to WETH\n        WETH.deposit{value: msg.value}();\n\n        // Pull coll\n        collToken.safeTransferFrom(msg.sender, address(this), _params.collAmount);\n\n        uint256 troveId;\n        // Include sender in index\n        uint256 index = _getTroveIndex(_params.ownerIndex);\n        if (_params.batchManager == address(0)) {\n            troveId = borrowerOperations.openTrove(\n                _params.owner,\n                index,\n                _params.collAmount,\n                _params.boldAmount,\n                _params.upperHint,\n                _params.lowerHint,\n                _params.annualInterestRate,\n                _params.maxUpfrontFee,\n                // Add this contract as add/receive manager to be able to fully adjust trove,\n                // while keeping the same management functionality\n                address(this), // add manager\n                address(this), // remove manager\n                address(this) // receiver for remove manager\n            );\n        } else {\n            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory\n                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations\n                    .OpenTroveAndJoinInterestBatchManagerParams({\n                    owner: _params.owner,\n                    ownerIndex: index,\n                    collAmount: _params.collAmount,\n                    boldAmount: _params.boldAmount,\n                    upperHint: _params.upperHint,\n                    lowerHint: _params.lowerHint,\n                    interestBatchManager: _params.batchManager,\n                    maxUpfrontFee: _params.maxUpfrontFee,\n                    // Add this contract as add/receive manager to be able to fully adjust trove,\n                    // while keeping the same management functionality\n                    addManager: address(this), // add manager\n                    removeManager: address(this), // remove manager\n                    receiver: address(this) // receiver for remove manager\n                });\n            troveId =\n                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);\n        }\n\n        boldToken.transfer(msg.sender, _params.boldAmount);\n\n        // Set add/remove managers\n        _setAddManager(troveId, _params.addManager);\n        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);\n\n        return troveId;\n    }\n\n    function addColl(uint256 _troveId, uint256 _amount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n\n        IBorrowerOperations borrowerOperationsCached = borrowerOperations;\n\n        // Pull coll\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        borrowerOperationsCached.addColl(_troveId, _amount);\n    }\n\n    function withdrawColl(uint256 _troveId, uint256 _amount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawColl(_troveId, _amount);\n\n        // Send coll left\n        collToken.safeTransfer(receiver, _amount);\n    }\n\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);\n\n        // Send Bold\n        boldToken.transfer(receiver, _boldAmount);\n    }\n\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);\n\n        // Pull Bold\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n\n        borrowerOperations.repayBold(_troveId, _boldAmount);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external {\n        InitialBalances memory initialBalances;\n        address receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function adjustZombieTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        InitialBalances memory initialBalances;\n        address receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustZombieTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _upperHint, _lowerHint, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function _adjustTrovePre(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        InitialBalances memory _initialBalances\n    ) internal returns (address) {\n        address receiver = _checkAdjustTroveManagers(_troveId, _collChange, _isCollIncrease, _isDebtIncrease);\n\n        // Set initial balances to make sure there are not lefovers\n        _setInitialTokensAndBalances(collToken, boldToken, _initialBalances);\n\n        // Pull coll\n        if (_isCollIncrease) {\n            collToken.safeTransferFrom(msg.sender, address(this), _collChange);\n        }\n\n        // Pull Bold\n        if (!_isDebtIncrease) {\n            boldToken.transferFrom(msg.sender, address(this), _boldChange);\n        }\n\n        return receiver;\n    }\n\n    function _adjustTrovePost(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        address _receiver,\n        InitialBalances memory _initialBalances\n    ) internal {\n        // Send coll left\n        if (!_isCollIncrease) {\n            collToken.safeTransfer(_receiver, _collChange);\n        }\n\n        // Send Bold\n        if (_isDebtIncrease) {\n            boldToken.transfer(_receiver, _boldChange);\n        }\n\n        // return leftovers to user\n        _returnLeftovers(_initialBalances);\n    }\n\n    function closeTroveToRawETH(uint256 _troveId) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        // pull Bold for repayment\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        boldToken.transferFrom(msg.sender, address(this), trove.entireDebt);\n\n        borrowerOperations.closeTrove(_troveId);\n\n        // Send coll left\n        collToken.safeTransfer(receiver, trove.entireColl);\n\n        // Send gas compensation\n        WETH.withdraw(ETH_GAS_COMPENSATION);\n        (bool success,) = receiver.call{value: ETH_GAS_COMPENSATION}(\"\");\n        require(success, \"GCZ: Sending ETH failed\");\n    }\n\n    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount, uint256 _minExpectedCollateral)\n        external\n        override\n    {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        CloseTroveParams memory params = CloseTroveParams({\n            troveId: _troveId,\n            flashLoanAmount: _flashLoanAmount,\n            minExpectedCollateral: _minExpectedCollateral,\n            receiver: receiver\n        });\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        initialBalances.tokens[0] = collToken;\n        initialBalances.tokens[1] = boldToken;\n        _setInitialBalancesAndReceiver(initialBalances, receiver);\n\n        // Flash loan coll\n        flashLoanProvider.makeFlashLoan(\n            collToken, _flashLoanAmount, IFlashLoanProvider.Operation.CloseTrove, abi.encode(params)\n        );\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function receiveFlashLoanOnCloseTroveFromCollateral(\n        CloseTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external {\n        require(msg.sender == address(flashLoanProvider), \"GCZ: Caller not FlashLoan provider\");\n\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_params.troveId);\n        uint256 collLeft = trove.entireColl - _params.flashLoanAmount;\n        require(collLeft >= _params.minExpectedCollateral, \"GCZ: Not enough collateral received\");\n\n        // Swap Coll from flash loan to Bold, so we can repay and close trove\n        // We swap the flash loan minus the flash loan fee\n        exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n\n        // We asked for a min of entireDebt in swapToBold call above, so we don’t check again here:\n        //uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n        //require(receivedBoldAmount >= trove.entireDebt, \"GCZ: Not enough BOLD obtained to repay\");\n\n        borrowerOperations.closeTrove(_params.troveId);\n\n        // Send coll back to return flash loan\n        collToken.safeTransfer(address(flashLoanProvider), _params.flashLoanAmount);\n\n        // Send coll left\n        collToken.safeTransfer(_params.receiver, collLeft);\n\n        // Send gas compensation\n        WETH.withdraw(ETH_GAS_COMPENSATION);\n        (bool success,) = _params.receiver.call{value: ETH_GAS_COMPENSATION}(\"\");\n        require(success, \"GCZ: Sending ETH failed\");\n    }\n\n    receive() external payable {}\n\n    // Unimplemented flash loan receive functions for leverage\n    function receiveFlashLoanOnOpenLeveragedTrove(\n        ILeverageZapper.OpenLeveragedTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverUpTrove(\n        ILeverageZapper.LeverUpTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverDownTrove(\n        ILeverageZapper.LeverDownTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n}\n",
        "WETHZapper.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport \"./BaseZapper.sol\";\nimport \"../Dependencies/Constants.sol\";\n\ncontract WETHZapper is BaseZapper {\n    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)\n        BaseZapper(_addressesRegistry, _flashLoanProvider, _exchange)\n    {\n        require(address(WETH) == address(_addressesRegistry.collToken()), \"WZ: Wrong coll branch\");\n\n        // Approve coll to BorrowerOperations\n        WETH.approve(address(borrowerOperations), type(uint256).max);\n        // Approve Coll to exchange module (for closeTroveFromCollateral)\n        WETH.approve(address(_exchange), type(uint256).max);\n    }\n\n    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256) {\n        require(msg.value > ETH_GAS_COMPENSATION, \"WZ: Insufficient ETH\");\n        require(\n            _params.batchManager == address(0) || _params.annualInterestRate == 0,\n            \"WZ: Cannot choose interest if joining a batch\"\n        );\n\n        // Convert ETH to WETH\n        WETH.deposit{value: msg.value}();\n\n        uint256 troveId;\n        // Include sender in index\n        uint256 index = _getTroveIndex(_params.ownerIndex);\n        if (_params.batchManager == address(0)) {\n            troveId = borrowerOperations.openTrove(\n                _params.owner,\n                index,\n                msg.value - ETH_GAS_COMPENSATION,\n                _params.boldAmount,\n                _params.upperHint,\n                _params.lowerHint,\n                _params.annualInterestRate,\n                _params.maxUpfrontFee,\n                // Add this contract as add/receive manager to be able to fully adjust trove,\n                // while keeping the same management functionality\n                address(this), // add manager\n                address(this), // remove manager\n                address(this) // receiver for remove manager\n            );\n        } else {\n            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory\n                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations\n                    .OpenTroveAndJoinInterestBatchManagerParams({\n                    owner: _params.owner,\n                    ownerIndex: index,\n                    collAmount: msg.value - ETH_GAS_COMPENSATION,\n                    boldAmount: _params.boldAmount,\n                    upperHint: _params.upperHint,\n                    lowerHint: _params.lowerHint,\n                    interestBatchManager: _params.batchManager,\n                    maxUpfrontFee: _params.maxUpfrontFee,\n                    // Add this contract as add/receive manager to be able to fully adjust trove,\n                    // while keeping the same management functionality\n                    addManager: address(this), // add manager\n                    removeManager: address(this), // remove manager\n                    receiver: address(this) // receiver for remove manager\n                });\n            troveId =\n                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);\n        }\n\n        boldToken.transfer(msg.sender, _params.boldAmount);\n\n        // Set add/remove managers\n        _setAddManager(troveId, _params.addManager);\n        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);\n\n        return troveId;\n    }\n\n    function addCollWithRawETH(uint256 _troveId) external payable {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n        // Convert ETH to WETH\n        WETH.deposit{value: msg.value}();\n\n        borrowerOperations.addColl(_troveId, msg.value);\n    }\n\n    function withdrawCollToRawETH(uint256 _troveId, uint256 _amount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawColl(_troveId, _amount);\n\n        // Convert WETH to ETH\n        WETH.withdraw(_amount);\n        (bool success,) = receiver.call{value: _amount}(\"\");\n        require(success, \"WZ: Sending ETH failed\");\n    }\n\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireZapperIsReceiver(_troveId);\n\n        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);\n\n        // Send Bold\n        boldToken.transfer(receiver, _boldAmount);\n    }\n\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrAddManager(_troveId, owner);\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        _setInitialTokensAndBalances(WETH, boldToken, initialBalances);\n\n        // Pull Bold\n        boldToken.transferFrom(msg.sender, address(this), _boldAmount);\n\n        borrowerOperations.repayBold(_troveId, _boldAmount);\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function adjustTroveWithRawETH(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external payable {\n        InitialBalances memory initialBalances;\n        address payable receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function adjustZombieTroveWithRawETH(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external payable {\n        InitialBalances memory initialBalances;\n        address payable receiver =\n            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);\n        borrowerOperations.adjustZombieTrove(\n            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _upperHint, _lowerHint, _maxUpfrontFee\n        );\n        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);\n    }\n\n    function _adjustTrovePre(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        InitialBalances memory _initialBalances\n    ) internal returns (address payable) {\n        if (_isCollIncrease) {\n            require(_collChange == msg.value, \"WZ: Wrong coll amount\");\n        } else {\n            require(msg.value == 0, \"WZ: Not adding coll, no ETH should be received\");\n        }\n\n        address payable receiver =\n            payable(_checkAdjustTroveManagers(_troveId, _collChange, _isCollIncrease, _isDebtIncrease));\n\n        // Set initial balances to make sure there are not lefovers\n        _setInitialTokensAndBalances(WETH, boldToken, _initialBalances);\n\n        // ETH -> WETH\n        if (_isCollIncrease) {\n            WETH.deposit{value: _collChange}();\n        }\n\n        // Pull Bold\n        if (!_isDebtIncrease) {\n            boldToken.transferFrom(msg.sender, address(this), _boldChange);\n        }\n\n        return receiver;\n    }\n\n    function _adjustTrovePost(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        address payable _receiver,\n        InitialBalances memory _initialBalances\n    ) internal {\n        // Send Bold\n        if (_isDebtIncrease) {\n            boldToken.transfer(_receiver, _boldChange);\n        }\n\n        // return BOLD leftovers to user (trying to repay more than possible)\n        uint256 currentBoldBalance = boldToken.balanceOf(address(this));\n        if (currentBoldBalance > _initialBalances.balances[1]) {\n            boldToken.transfer(_initialBalances.receiver, currentBoldBalance - _initialBalances.balances[1]);\n        }\n        // There shouldn’t be Collateral leftovers, everything sent should end up in the trove\n        // But ETH and WETH balance can be non-zero if someone accidentally send it to this contract\n\n        // WETH -> ETH\n        if (!_isCollIncrease && _collChange > 0) {\n            WETH.withdraw(_collChange);\n            (bool success,) = _receiver.call{value: _collChange}(\"\");\n            require(success, \"WZ: Sending ETH failed\");\n        }\n    }\n\n    function closeTroveToRawETH(uint256 _troveId) external {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        // pull Bold for repayment\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        boldToken.transferFrom(msg.sender, address(this), trove.entireDebt);\n\n        borrowerOperations.closeTrove(_troveId);\n\n        WETH.withdraw(trove.entireColl + ETH_GAS_COMPENSATION);\n        (bool success,) = receiver.call{value: trove.entireColl + ETH_GAS_COMPENSATION}(\"\");\n        require(success, \"WZ: Sending ETH failed\");\n    }\n\n    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount, uint256 _minExpectedCollateral)\n        external\n        override\n    {\n        address owner = troveNFT.ownerOf(_troveId);\n        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));\n        _requireZapperIsReceiver(_troveId);\n\n        CloseTroveParams memory params = CloseTroveParams({\n            troveId: _troveId,\n            flashLoanAmount: _flashLoanAmount,\n            minExpectedCollateral: _minExpectedCollateral,\n            receiver: receiver\n        });\n\n        // Set initial balances to make sure there are not lefovers\n        InitialBalances memory initialBalances;\n        initialBalances.tokens[0] = WETH;\n        initialBalances.tokens[1] = boldToken;\n        _setInitialBalancesAndReceiver(initialBalances, receiver);\n\n        // Flash loan coll\n        flashLoanProvider.makeFlashLoan(\n            WETH, _flashLoanAmount, IFlashLoanProvider.Operation.CloseTrove, abi.encode(params)\n        );\n\n        // return leftovers to user\n        _returnLeftovers(initialBalances);\n    }\n\n    function receiveFlashLoanOnCloseTroveFromCollateral(\n        CloseTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external {\n        require(msg.sender == address(flashLoanProvider), \"WZ: Caller not FlashLoan provider\");\n\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_params.troveId);\n        uint256 collLeft = trove.entireColl - _params.flashLoanAmount;\n        require(collLeft >= _params.minExpectedCollateral, \"WZ: Not enough collateral received\");\n\n        // Swap Coll from flash loan to Bold, so we can repay and close trove\n        // We swap the flash loan minus the flash loan fee\n        exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n\n        // We asked for a min of entireDebt in swapToBold call above, so we don’t check again here:\n        // uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);\n        //require(receivedBoldAmount >= trove.entireDebt, \"WZ: Not enough BOLD obtained to repay\");\n\n        borrowerOperations.closeTrove(_params.troveId);\n\n        // Send coll back to return flash loan\n        WETH.transfer(address(flashLoanProvider), _params.flashLoanAmount);\n\n        uint256 ethToSendBack = collLeft + ETH_GAS_COMPENSATION;\n        // Send coll left and gas compensation\n        WETH.withdraw(ethToSendBack);\n        (bool success,) = _params.receiver.call{value: ethToSendBack}(\"\");\n        require(success, \"WZ: Sending ETH failed\");\n    }\n\n    receive() external payable {}\n\n    // Unimplemented flash loan receive functions for leverage\n    function receiveFlashLoanOnOpenLeveragedTrove(\n        ILeverageZapper.OpenLeveragedTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverUpTrove(\n        ILeverageZapper.LeverUpTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n    function receiveFlashLoanOnLeverDownTrove(\n        ILeverageZapper.LeverDownTroveParams calldata _params,\n        uint256 _effectiveFlashLoanAmount\n    ) external virtual override {}\n}\n"
    }
}