{
    "vfp_id": "vfp_00494",
    "project_name": "Parallel Protocol - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Consider use block.timestamp for ERC20Vote token clock mode",
            "description": "The TimeLockPenaltyERC20 contract inherits from ERC20Votes and uses the default clock mode of block.number. On chains like Arbitrum, block.number reflects L1 block numbers and may not accurately represent time passage, which can distort governance voting periods. The root cause is the reliance on block.number instead of block.timestamp for time-based governance logic. This is particularly problematic for cross-chain deployments where block production rates differ. While not directly exploitable, this could lead to unfair voting windows or confusion about proposal timelines. The impact includes potential governance manipulation, reduced fairness in voting, and user confusion regarding proposal deadlines on non-Ethereum chains.\n",
            "severity": "Low",
            "location": [
                "TimeLockPenaltyERC20.sol::CLOCK_MODE",
                "sPRL1.sol",
                "sPRL2.sol"
            ],
            "files": [
                "cd3992aec0847063c2b979c51f6cac7dd2ff03bd/tokenomics/contracts/sPRL/TimeLockPenaltyERC20.sol"
            ]
        }
    ],
    "affected_files": {
        "TimeLockPenaltyERC20.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport { ERC20Votes } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessManaged } from \"@openzeppelin/contracts/access/manager/AccessManaged.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { Nonces } from \"@openzeppelin/contracts/utils/Nonces.sol\";\n\nimport { MathsLib } from \"contracts/libraries/MathsLib.sol\";\n\n/// @title TimeLockPenaltyERC20\n/// @notice An ERC20 wrapper contract that allows users to deposit assets and can only withdraw them after a specified\n/// time lock period. If the user withdraws before the time lock period, a penalty fee is applied relative to the time\n/// left.\n/// @author Cooper Labs\n/// @custom:contact security@cooperlabs.xyz\nabstract contract TimeLockPenaltyERC20 is ERC20, ERC20Permit, ERC20Votes, AccessManaged, Pausable, ReentrancyGuard {\n    using MathsLib for *;\n\n    //-------------------------------------------\n    // Storage\n    //-------------------------------------------\n\n    /// @notice The status of a withdrawal request.\n    enum WITHDRAW_STATUS {\n        UNUSED,\n        UNLOCKING,\n        RELEASED,\n        CANCELLED\n    }\n\n    /// @notice A struct to store the details of a withdrawal request.\n    struct WithdrawalRequest {\n        /// @notice The amount of assets the user requested to withdraw.\n        uint256 amount;\n        /// @notice The time the user requested the withdrawal.\n        uint64 requestTime;\n        /// @notice The time the user can withdraw the assets.\n        uint64 releaseTime;\n        /// @notice The status of the withdrawal request.\n        WITHDRAW_STATUS status;\n    }\n\n    /// @notice 1e18 = 100%\n    uint256 private constant MAX_PENALTY_PERCENTAGE = 1e18;\n    /// @notice The min duration of the time lock\n    uint64 constant MIN_TIMELOCK_DURATION = 1 days;\n    /// @notice The max duration of the time lock\n    uint64 constant MAX_TIMELOCK_DURATION = 365 days;\n\n    /// @notice The address of the underlying token.\n    IERC20 public underlying;\n    /// @notice The address that will receive the fees.\n    address public feeReceiver;\n    /// @notice The duration of the time lock.\n    uint64 public timeLockDuration;\n    /// @notice The amount of underlying tokens that are in unlocking state.\n    uint256 public unlockingAmount;\n    /// @notice The penalties percentage that will be applied at request time.\n    uint256 public startPenaltyPercentage;\n    /// @notice Mapping of user to their withdrawal requests.\n    mapping(address user => mapping(uint256 requestId => WithdrawalRequest request)) public userVsWithdrawals;\n    /// @notice Mapping of user to their next withdrawal request ID.\n    mapping(address user => uint256 nextRequestId) public userVsNextID;\n\n    //----------------------------------------\n    // Events\n    //----------------------------------------\n\n    /// @notice Emitted when the time lock duration is changed.\n    /// @param oldTimeLock The old time lock duration.\n    /// @param newTimeLock The new time lock duration.\n    event TimeLockUpdated(uint256 oldTimeLock, uint256 newTimeLock);\n\n    /// @notice Emitted when a user requests to withdraw assets.\n    /// @param id The ID of the request.\n    /// @param user The user that requested the withdraw.\n    event WithdrawalRequested(uint256 id, address user, uint256 amount);\n\n    /// @notice Emitted when a user withdraws assets\n    /// @param id The ID of the request\n    /// @param user The user that withdrew the assets\n    /// @param amount The amount of underlying assets withdrawn for the user\n    /// @param slashAmount The amount of underlying assets slashed for the fee receiver\n    event Withdraw(uint256 id, address user, uint256 amount, uint256 slashAmount);\n\n    /// @notice Emitted when a user emergency withdraws assets.\n    /// @param user The user that withdrew the assets.\n    /// @param amount The amount of assets withdrawn.\n    event EmergencyWithdraw(address user, uint256 amount);\n\n    /// @notice Emitted when a user deposits assets\n    /// @param user The user that deposited the assets.\n    /// @param amount The amount of assets deposited.\n    event Deposited(address user, uint256 amount);\n\n    /// @notice Emitted when a user cancels a withdrawal request.\n    /// @param id The ID of the request.\n    /// @param user The user that cancelled the request.\n    /// @param amount The amount of assets cancelled.\n    event WithdrawalRequestCancelled(uint256 id, address user, uint256 amount);\n\n    /// @notice Emitted when the fee receiver is updated.\n    /// @param newFeeReceiver The new fee receiver.\n    event FeeReceiverUpdated(address newFeeReceiver);\n\n    /// @notice Emitted when the start penalty percentage is updated.\n    /// @param oldPercentage The old penalty percentage.\n    /// @param newPercentage The new penalty percentage.\n    event StartPenaltyPercentageUpdated(uint256 oldPercentage, uint256 newPercentage);\n\n    //-------------------------------------------\n    // Errors\n    //-------------------------------------------\n\n    /// @notice Thrown when the time lock duration is out of range.\n    error TimelockOutOfRange(uint256 attemptedTimelockDuration);\n    /// @notice Thrown when a user tries to cancel a withdrawal request that is not in the unlocking state.\n    error CannotCancelWithdrawalRequest(uint256 reqId);\n    /// @notice Thrown when a user tries to withdraw assets that are not in the unlocking state.\n    error CannotWithdraw(uint256 reqId);\n    /// @notice Thrown when a user tries to withdraw assets that are not yet unlocked.\n    error CannotWithdrawYet(uint256 reqId);\n    /// @notice Thrown when the percentage is out of range.\n    error PercentageOutOfRange(uint256 attemptedPercentage);\n\n    //-------------------------------------------\n    // Constructor\n    //-------------------------------------------\n\n    /// @notice Construct a new TimeLockedERC20 contract\n    /// @param _name The name of the token\n    /// @param _symbol The symbol of the token.\n    /// @param _underlying The underlying that is being locked.\n    /// @param _timeLockDuration The duration of the time lock.\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlying,\n        address _feeReceiver,\n        address _accessManager,\n        uint256 _startPenaltyPercentage,\n        uint64 _timeLockDuration\n    )\n        ERC20Permit(_name)\n        ERC20(_name, _symbol)\n        AccessManaged(_accessManager)\n    {\n        if (_timeLockDuration < MIN_TIMELOCK_DURATION || _timeLockDuration > MAX_TIMELOCK_DURATION) {\n            revert TimelockOutOfRange(_timeLockDuration);\n        }\n        if (_startPenaltyPercentage > MAX_PENALTY_PERCENTAGE) {\n            revert PercentageOutOfRange(_startPenaltyPercentage);\n        }\n\n        feeReceiver = _feeReceiver;\n        underlying = IERC20(_underlying);\n        timeLockDuration = _timeLockDuration;\n        startPenaltyPercentage = _startPenaltyPercentage;\n    }\n\n    //-------------------------------------------\n    // External functions\n    //-------------------------------------------\n\n    /// @notice Request to withdraw assets from the contract.\n    /// @param _unlockingAmount The amount of assets to unlock.\n    function requestWithdraw(uint256 _unlockingAmount) external {\n        _burn(msg.sender, _unlockingAmount);\n\n        uint256 id = userVsNextID[msg.sender]++;\n        WithdrawalRequest storage request = userVsWithdrawals[msg.sender][id];\n\n        request.amount = _unlockingAmount;\n        request.requestTime = uint64(block.timestamp);\n        request.releaseTime = uint64(block.timestamp) + timeLockDuration;\n        request.status = WITHDRAW_STATUS.UNLOCKING;\n\n        unlockingAmount += _unlockingAmount;\n\n        emit WithdrawalRequested(id, msg.sender, _unlockingAmount);\n    }\n\n    /// @notice Cancel multiple withdrawal requests.\n    /// @param _ids The IDs of the withdrawal requests to cancel.\n    function cancelWithdrawalRequests(uint256[] calldata _ids) external {\n        uint256 i = 0;\n        for (; i < _ids.length; ++i) {\n            _cancelWithdrawalRequest(_ids[i]);\n        }\n    }\n\n    /// @notice This is for off-chain use, it finds any locked IDs in the specified range.\n    /// @param _user The user to find the unlocking IDs for.\n    /// @param _start The ID to start looking from.\n    /// @param _startFromEnd Whether to start from the end.\n    /// @param _countToCheck The number of IDs to check.\n    /// @return ids The IDs of the unlocking requests.\n    function findUnlockingIDs(\n        address _user,\n        uint256 _start,\n        bool _startFromEnd,\n        uint16 _countToCheck\n    )\n        external\n        view\n        returns (uint256[] memory ids)\n    {\n        uint256 nextId = userVsNextID[_user];\n\n        if (_start >= nextId) return ids;\n        if (_startFromEnd) _start = nextId - _start;\n        uint256 end = _start + uint256(_countToCheck);\n        if (end > nextId) end = nextId;\n\n        mapping(uint256 => WithdrawalRequest) storage withdrawals = userVsWithdrawals[_user];\n\n        ids = new uint256[](end - _start);\n        uint256 length = 0;\n        uint256 id = _start;\n        // Nothing in here can overflow so disable the checks for the loop.\n        unchecked {\n            for (; id < end; ++id) {\n                if (withdrawals[id].status == WITHDRAW_STATUS.UNLOCKING) {\n                    ids[length++] = id;\n                }\n            }\n        }\n\n        // Need to force the array length to the correct value using assembly.\n        assembly {\n            mstore(ids, length)\n        }\n    }\n\n    //-------------------------------------------\n    // AccessManaged functions\n    //-------------------------------------------\n\n    /// @notice Allow the AccessManager to update the time lock duration.\n    /// @param _newTimeLockDuration The new time lock duration.\n    function updateTimeLockDuration(uint64 _newTimeLockDuration) external restricted {\n        if (_newTimeLockDuration < MIN_TIMELOCK_DURATION || _newTimeLockDuration > MAX_TIMELOCK_DURATION) {\n            revert TimelockOutOfRange(_newTimeLockDuration);\n        }\n        emit TimeLockUpdated(timeLockDuration, _newTimeLockDuration);\n        timeLockDuration = _newTimeLockDuration;\n    }\n\n    /// @notice Allow the AccessManager to update the time lock duration.\n    /// @param _newStartPenaltyPercentage The new time lock duration.\n    function updateStartPenaltyPercentage(uint256 _newStartPenaltyPercentage) external restricted {\n        if (_newStartPenaltyPercentage > MAX_PENALTY_PERCENTAGE) {\n            revert PercentageOutOfRange(_newStartPenaltyPercentage);\n        }\n        emit StartPenaltyPercentageUpdated(startPenaltyPercentage, _newStartPenaltyPercentage);\n        startPenaltyPercentage = _newStartPenaltyPercentage;\n    }\n\n    /// @notice Allow the AccessManager to update the fee receiver address.\n    /// @param _newFeeReceiver The new fee receiver.\n    function updateFeeReceiver(address _newFeeReceiver) external restricted {\n        emit FeeReceiverUpdated(_newFeeReceiver);\n        feeReceiver = _newFeeReceiver;\n    }\n\n    /// @notice Allow AccessManager to pause the contract.\n    /// @dev This function can only be called by the AccessManager.\n    function pause() external restricted {\n        _pause();\n    }\n\n    /// @notice Allow AccessManager to unpause the contract.\n    /// @dev This function can only be called by the AccessManager.\n    function unpause() external restricted {\n        _unpause();\n    }\n\n    //-------------------------------------------\n    // Private/Internal functions\n    //-------------------------------------------\n\n    /// @notice Mint the equivalent amount of underlying tokens deposited.\n    /// @param _amount The amount of underlying tokens deposited.\n    function _deposit(uint256 _amount) internal {\n        emit Deposited(msg.sender, _amount);\n        _mint(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw multiple withdrawal requests.\n    /// @param _ids The IDs of the withdrawal requests to withdraw.\n    /// @return totalAmountWithdrawn The total amount of assets withdrawn.\n    /// @return totalSlashAmount The total amount of assets that were slashed.\n    function _withdrawMultiple(uint256[] calldata _ids)\n        internal\n        returns (uint256 totalAmountWithdrawn, uint256 totalSlashAmount)\n    {\n        uint256 i = 0;\n        for (; i < _ids.length; ++i) {\n            (uint256 amountWithdrawn, uint256 slashAmount) = _withdraw(_ids[i]);\n            totalAmountWithdrawn += amountWithdrawn;\n            totalSlashAmount += slashAmount;\n        }\n    }\n\n    /// @notice Withdraw assets from the contract\n    /// @param _id The ID of the withdrawal request.\n    /// @return amount The amount of assets user received.\n    /// @return slashAmount The amount of assets that were slashed.\n    function _withdraw(uint256 _id) internal returns (uint256 amount, uint256 slashAmount) {\n        WithdrawalRequest storage request = userVsWithdrawals[msg.sender][_id];\n\n        if (request.status != WITHDRAW_STATUS.UNLOCKING) {\n            revert CannotWithdraw(_id);\n        }\n\n        slashAmount = _calculateFee(request.amount, request.requestTime, request.releaseTime);\n        amount = request.amount - slashAmount;\n        request.status = WITHDRAW_STATUS.RELEASED;\n\n        emit Withdraw(_id, msg.sender, amount, slashAmount);\n    }\n\n    /// @notice Cancel a withdrawal request.\n    /// @param _id The ID of the withdrawal request.\n    function _cancelWithdrawalRequest(uint256 _id) internal {\n        WithdrawalRequest storage request = userVsWithdrawals[msg.sender][_id];\n        if (request.status != WITHDRAW_STATUS.UNLOCKING) {\n            revert CannotCancelWithdrawalRequest(_id);\n        }\n        request.status = WITHDRAW_STATUS.CANCELLED;\n\n        uint256 _amount = request.amount;\n        unlockingAmount -= _amount;\n\n        emit WithdrawalRequestCancelled(_id, msg.sender, _amount);\n\n        _mint(msg.sender, _amount);\n    }\n\n    /// @notice Calculate the fee amount that will be slashed from the withdrawal amount.\n    /// @dev The fee amount is calculated based on the time left until the release time.\n    /// @param _amount The total amount of assets user should withdraw.\n    /// @param _requestTime The time the user requested the withdrawal.\n    /// @param _releaseTime The time the user can withdraw the assets.\n    /// @return feeAmount The amount of assets that will be slashed.\n    function _calculateFee(\n        uint256 _amount,\n        uint256 _requestTime,\n        uint256 _releaseTime\n    )\n        internal\n        view\n        returns (uint256 feeAmount)\n    {\n        if (block.timestamp >= _releaseTime) return 0;\n        uint256 timeLeft = _releaseTime - block.timestamp;\n        uint256 lockDuration = _releaseTime - _requestTime;\n        uint256 feePercentage = startPenaltyPercentage.mulDivUp(timeLeft, lockDuration);\n        feeAmount = _amount.wadMulUp(feePercentage);\n    }\n\n    //-------------------------------------------\n    // Overrides\n    //-------------------------------------------\n\n    /// @notice Update the balances of the token.\n    /// @param from The address to transfer from.\n    /// @param to The address to transfer to.\n    /// @param value The amount to transfer.\n    function _update(address from, address to, uint256 value) internal override(ERC20, ERC20Votes) {\n        super._update(from, to, value);\n    }\n\n    /// @notice Get the nonce for an address.\n    /// @param owner The address to get the nonce for.\n    /// @return The nonce for the address.\n    function nonces(address owner) public view virtual override(ERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n}\n"
    }
}