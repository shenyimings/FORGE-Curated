{
    "vfp_id": "vfp_00115",
    "project_name": "Proof of Data Possession - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Proof-set owner can reset proofSetLastProvenEpoch to avoid accumulated fees",
            "description": "The `nextProvingPeriod` function in the PDPVerifier contract removes scheduled roots and, if all roots are deleted, resets `proofSetLastProvenEpoch` and `nextChallengeEpoch` to zero. This behavior allows the proof-set owner to manipulate the fee calculation mechanism, as `proofSetLastProvenEpoch` is used to determine how many blocks have passed since the last proof was submitted, which directly affects the fee amount. By removing all roots and re-adding them, the owner can reset the epoch counter and avoid paying fees that would have accumulated over time. This constitutes a business logic flaw where a legitimate function is exploited to bypass intended economic incentives.\n",
            "severity": "Medium",
            "location": [
                "PDPVerifier.sol::nextProvingPeriod"
            ],
            "files": [
                "pdp/src/PDPVerifier.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Fee refund can revert due to the gas limit or smart wallets",
            "description": "The `calculateAndBurnProofFee` and `createProofSet` functions in the PDPVerifier contract use the `.transfer()` method to refund excess Ether to the caller. This method forwards only 2,300 gas, which is insufficient for contracts with non-trivial fallback or receive functions (e.g., smart wallets, DAOs). As a result, the refund call may revert, causing the entire transaction to fail. This issue affects user experience and accessibility, particularly for smart contract wallets, and stems from the use of an outdated and discouraged pattern in Solidity. The root cause is the reliance on `transfer` instead of a pull-over-push payment model or a low-reverting external call with proper gas forwarding.\n",
            "severity": "Low",
            "location": [
                "PDPVerifier.sol::calculateAndBurnProofFee",
                "PDPVerifier.sol::createProofSet"
            ],
            "files": [
                "pdp/src/PDPVerifier.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Reentrancy risk in provePossession during fee refund",
            "description": "The `provePossession` function in the PDPVerifier contract performs a refund via `transfer` before updating the `proofSetLastProvenEpoch` and notifying the listener via an external call. Although `transfer` limits gas to 2,300, making reentrancy currently non-exploitable, this is an unsafe design pattern because future changes in gas costs could render the contract vulnerable. Furthermore, while the current listener (SimplePDPService) includes protections, other compliant listeners might not, potentially allowing reentrant calls to manipulate state before critical updates occur. The root cause is the incorrect ordering of external calls and state changes, violating the checks-effects-interactions pattern.\n",
            "severity": "Informational",
            "location": [
                "PDPVerifier.sol::provePossession",
                "PDPVerifier.sol::calculateAndBurnProofFee"
            ],
            "files": [
                "pdp/src/PDPVerifier.sol"
            ]
        }
    ],
    "affected_files": {
        "PDPVerifier.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {BitOps} from \"./BitOps.sol\";\nimport {Cids} from \"./Cids.sol\";\nimport {MerkleVerify} from \"./Proofs.sol\";\nimport {PDPFees} from \"./Fees.sol\";\nimport \"../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/// @title PDPListener\n/// @notice Interface for PDP Service applications managing data storage.\n/// @dev This interface exists to provide an extensible hook for applications to use the PDP verification contract\n/// to implement data storage applications.\ninterface PDPListener {\n    function proofSetCreated(uint256 proofSetId, address creator, bytes calldata extraData) external;\n    function proofSetDeleted(uint256 proofSetId, uint256 deletedLeafCount, bytes calldata extraData) external;\n    function rootsAdded(uint256 proofSetId, uint256 firstAdded, PDPVerifier.RootData[] memory rootData, bytes calldata extraData) external;\n    function rootsScheduledRemove(uint256 proofSetId, uint256[] memory rootIds, bytes calldata extraData) external;\n    // Note: extraData not included as proving messages conceptually always originate from the SP\n    function possessionProven(uint256 proofSetId, uint256 challengedLeafCount, uint256 seed, uint256 challengeCount) external;\n    function nextProvingPeriod(uint256 proofSetId, uint256 challengeEpoch, uint256 leafCount, bytes calldata extraData) external;\n}\n\ncontract PDPVerifier is Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    // Constants\n    address public constant BURN_ACTOR = 0xff00000000000000000000000000000000000063;\n    uint256 public constant LEAF_SIZE = 32;\n    uint256 public constant MAX_ROOT_SIZE = 1 << 50;\n    uint256 public constant MAX_ENQUEUED_REMOVALS = 2000;\n    address public constant RANDOMNESS_PRECOMPILE = 0xfE00000000000000000000000000000000000006;\n    uint256 public constant EXTRA_DATA_MAX_SIZE = 2048;\n    uint256 public constant SECONDS_IN_DAY = 86400;\n    IPyth public constant PYTH = IPyth(0xA2aa501b19aff244D90cc15a4Cf739D2725B5729);\n\n    // FIL/USD price feed query ID on the Pyth network\n    bytes32 public constant FIL_USD_PRICE_FEED_ID = 0x150ac9b959aee0051e4091f0ef5216d941f590e1c5e7f91cf7635b5c11628c0e;\n    uint256 public constant NO_CHALLENGE_SCHEDULED = 0;\n    uint256 public constant NO_PROVEN_EPOCH = 0;\n\n\n    // Events\n    event ProofSetCreated(uint256 indexed setId, address indexed owner);\n    event ProofSetOwnerChanged(uint256 indexed setId, address indexed oldOwner, address indexed newOwner);\n    event ProofSetDeleted(uint256 indexed setId, uint256 deletedLeafCount);\n    event ProofSetEmpty(uint256 indexed setId);\n\n    event RootsAdded(uint256 indexed setId, uint256[] rootIds);\n    event RootsRemoved(uint256 indexed setId, uint256[] rootIds);\n   \n    event ProofFeePaid(uint256 indexed setId, uint256 fee, uint64 price, int32 expo);\n\n\n    event PossessionProven(uint256 indexed setId, RootIdAndOffset[] challenges);\n    event NextProvingPeriod(uint256 indexed setId, uint256 challengeEpoch, uint256 leafCount);\n\n    // Types\n    // State fields\n     event Debug(string message, uint256 value);\n\n    /*\n    A proof set is the metadata required for tracking data for proof of possession.\n    It maintains a list of CIDs of data to be proven and metadata needed to\n    add and remove data to the set and prove possession efficiently.\n\n    ** logical structure of the proof set**\n    /*\n    struct ProofSet {\n        Cid[] roots;\n        uint256[] leafCounts;\n        uint256[] sumTree;\n        uint256 leafCount;\n        address owner;\n        address proposed owner;\n        nextRootID uint64;\n        nextChallengeEpoch: uint64;\n        listenerAddress: address;\n        challengeRange: uint256\n        enqueuedRemovals: uint256[]\n    }\n    ** PDP Verifier contract tracks many possible proof sets **\n    []ProofSet proofsets\n\n    To implement this logical structure in the solidity data model we have\n    arrays tracking the singleton fields and two dimensional arrays\n    tracking linear proof set data.  The first index is the proof set id\n    and the second index if any is the index of the data in the array.\n\n    Invariant: rootCids.length == rootLeafCount.length == sumTreeCounts.length\n    */\n\n    // Network epoch delay between last proof of possession and next\n    // randomness sampling for challenge generation.\n    //\n    // The purpose of this delay is to prevent SPs from biasing randomness by running forking attacks.\n    // Given a small enough challengeFinality an SP can run several trials of challenge sampling and \n    // fork around samples that don't suit them, grinding the challenge randomness.\n    // For the filecoin L1, a safe value is 150 using the same analysis setting 150 epochs between\n    // PoRep precommit and PoRep provecommit phases.\n    //\n    // We keep this around for future portability to a variety of environments with different assumptions\n    // behind their challenge randomness sampling methods.\n    uint256 challengeFinality;\n\n    // TODO PERF: https://github.com/FILCAT/pdp/issues/16#issuecomment-2329838769\n    uint64 nextProofSetId;\n    // The CID of each root. Roots and all their associated data can be appended and removed but not modified.\n    mapping(uint256 => mapping(uint256 => Cids.Cid)) rootCids;\n    // The leaf count of each root\n    mapping(uint256 => mapping(uint256 => uint256)) rootLeafCounts;\n    // The sum tree array for finding the root id of a given leaf index.\n    mapping(uint256 => mapping(uint256 => uint256)) sumTreeCounts;\n    mapping(uint256 => uint256) nextRootId;\n    // The number of leaves (32 byte chunks) in the proof set when tallying up all roots.\n    // This includes the leaves in roots that have been added but are not yet eligible for proving.\n    mapping(uint256 => uint256) proofSetLeafCount;\n    // The epoch for which randomness is sampled for challenge generation while proving possession this proving period.\n    mapping(uint256 => uint256) nextChallengeEpoch;\n    // Each proof set notifies a configurable listener to implement extensible applications managing data storage.\n    mapping(uint256 => address) proofSetListener;\n    // The first index that is not challenged in prove possession calls this proving period.\n    // Updated to include the latest added leaves when starting the next proving period.\n    mapping(uint256 => uint256) challengeRange;\n    // Enqueued root ids for removal when starting the next proving period\n    mapping(uint256 => uint256[]) scheduledRemovals;\n    // ownership of proof set is initialized upon creation to create message sender\n    // proofset owner has exclusive permission to add and remove roots and delete the proof set\n    mapping(uint256 => address) proofSetOwner;\n    mapping(uint256 => address) proofSetProposedOwner;\n    mapping(uint256 => uint256) proofSetLastProvenEpoch;\n\n    // Methods\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n     _disableInitializers();\n    }\n\n    function initialize(uint256 _challengeFinality) public initializer {\n        __Ownable_init(msg.sender);\n        __UUPSUpgradeable_init();\n        challengeFinality = _challengeFinality;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function burnFee(uint256 amount) internal {\n        require(msg.value >= amount, \"Incorrect fee amount\");\n        (bool success, ) = BURN_ACTOR.call{value: amount}(\"\");\n        require(success, \"Burn failed\");\n    }\n\n    // Returns the current challenge finality value\n    function getChallengeFinality() public view returns (uint256) {\n        return challengeFinality;\n    }\n\n    // Returns the next proof set ID\n    function getNextProofSetId() public view returns (uint64) {\n        return nextProofSetId;\n    }\n\n    // Returns false if the proof set is 1) not yet created 2) deleted\n    function proofSetLive(uint256 setId) public view returns (bool) {\n        return setId < nextProofSetId && proofSetOwner[setId] != address(0);\n    }\n\n    // Returns false if the proof set is not live or if the root id is 1) not yet created 2) deleted\n    function rootLive(uint256 setId, uint256 rootId) public view returns (bool) {\n        return proofSetLive(setId) && rootId < nextRootId[setId] && rootLeafCounts[setId][rootId] > 0;\n    }\n\n    // Returns false if the root is not live or if the root id is not yet in challenge range\n    function rootChallengable(uint256 setId, uint256 rootId) public view returns (bool) {\n        uint256 top = 256 - BitOps.clz(nextRootId[setId]);\n        RootIdAndOffset memory ret = findOneRootId(setId, challengeRange[setId]-1, top);\n        require(ret.offset == rootLeafCounts[setId][ret.rootId] - 1, \"challengeRange -1 should align with the very last leaf of a root\");\n        return rootLive(setId, rootId) && rootId <= ret.rootId;\n    }\n\n    // Returns the leaf count of a proof set\n    function getProofSetLeafCount(uint256 setId) public view returns (uint256) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return proofSetLeafCount[setId];\n    }\n\n    // Returns the next root ID for a proof set\n    function getNextRootId(uint256 setId) public view returns (uint256) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return nextRootId[setId];\n    }\n\n    // Returns the next challenge epoch for a proof set\n    function getNextChallengeEpoch(uint256 setId) public view returns (uint256) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return nextChallengeEpoch[setId];\n    }\n\n    // Returns the listener address for a proof set\n    function getProofSetListener(uint256 setId) public view returns (address) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return proofSetListener[setId];\n    }\n\n    // Returns the owner of a proof set and the proposed owner if any\n    function getProofSetOwner(uint256 setId) public view returns (address, address) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return (proofSetOwner[setId], proofSetProposedOwner[setId]);\n    }\n\n    function getProofSetLastProvenEpoch(uint256 setId) public view returns (uint256) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return proofSetLastProvenEpoch[setId];\n    }\n\n    // Returns the root CID for a given proof set and root ID\n    function getRootCid(uint256 setId, uint256 rootId) public view returns (Cids.Cid memory) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return rootCids[setId][rootId];\n    }\n\n    // Returns the root leaf count for a given proof set and root ID\n    function getRootLeafCount(uint256 setId, uint256 rootId) public view returns (uint256) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return rootLeafCounts[setId][rootId];\n    }\n\n    // Returns the index of the most recently added leaf that is challengeable in the current proving period\n    function getChallengeRange(uint256 setId) public view returns (uint256) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        return challengeRange[setId];\n    }\n\n    // Returns the root ids of the roots scheduled for removal at the start of the next proving period\n    function getScheduledRemovals(uint256 setId) public view returns (uint256[] memory) {\n        require(proofSetLive(setId), \"Proof set not live\");\n        uint256[] storage removals = scheduledRemovals[setId];\n        uint256[] memory result = new uint256[](removals.length);\n        for (uint256 i = 0; i < removals.length; i++) {\n            result[i] = removals[i];\n        }\n        return result;\n    }\n\n    // owner proposes new owner.  If the owner proposes themself delete any outstanding proposed owner\n    function proposeProofSetOwner(uint256 setId, address newOwner) public {\n        require(proofSetLive(setId), \"Proof set not live\");\n        address owner = proofSetOwner[setId];\n        require(owner == msg.sender, \"Only the current owner can propose a new owner\");\n        if (owner == newOwner) {\n            // If the owner proposes themself delete any outstanding proposed owner\n            delete proofSetProposedOwner[setId];\n        } else {\n            proofSetProposedOwner[setId] = newOwner;\n        }\n    }\n\n    function claimProofSetOwnership(uint256 setId) public {\n        require(proofSetLive(setId), \"Proof set not live\");\n        require(proofSetProposedOwner[setId] == msg.sender, \"Only the proposed owner can claim ownership\");\n        address oldOwner = proofSetOwner[setId];\n        proofSetOwner[setId] = msg.sender;\n        delete proofSetProposedOwner[setId];\n        emit ProofSetOwnerChanged(setId, oldOwner, msg.sender);\n    }\n\n    // A proof set is created empty, with no roots. Creation yields a proof set ID\n    // for referring to the proof set later.\n    // Sender of create message is proof set owner.\n    function createProofSet(address listenerAddr, bytes calldata extraData) public payable returns (uint256) {\n        require(extraData.length <= EXTRA_DATA_MAX_SIZE, \"Extra data too large\");\n        uint256 sybilFee = PDPFees.sybilFee();\n        require(msg.value >= sybilFee, \"sybil fee not met\");\n        burnFee(sybilFee);\n        if (msg.value > sybilFee) {\n            // Return the overpayment\n            payable(msg.sender).transfer(msg.value - sybilFee);\n        }\n\n        uint256 setId = nextProofSetId++;\n        proofSetLeafCount[setId] = 0;\n        nextChallengeEpoch[setId] = NO_CHALLENGE_SCHEDULED;  // Initialized on first call to NextProvingPeriod\n        proofSetOwner[setId] = msg.sender;\n        proofSetListener[setId] = listenerAddr;\n        proofSetLastProvenEpoch[setId] = NO_PROVEN_EPOCH;\n\n        if (listenerAddr != address(0)) {\n            PDPListener(listenerAddr).proofSetCreated(setId, msg.sender, extraData);\n        }\n        emit ProofSetCreated(setId, msg.sender);\n        return setId;\n    }\n\n    // Removes a proof set. Must be called by the contract owner.\n    function deleteProofSet(uint256 setId, bytes calldata extraData) public {\n        require(extraData.length <= EXTRA_DATA_MAX_SIZE, \"Extra data too large\");\n        if (setId >= nextProofSetId) {\n            revert(\"proof set id out of bounds\");\n        }\n\n        require(proofSetOwner[setId] == msg.sender, \"Only the owner can delete proof sets\");\n        uint256 deletedLeafCount = proofSetLeafCount[setId];\n        proofSetLeafCount[setId] = 0;\n        proofSetOwner[setId] = address(0);\n        nextChallengeEpoch[setId] = 0;\n        proofSetLastProvenEpoch[setId] = NO_PROVEN_EPOCH;\n\n        address listenerAddr = proofSetListener[setId];\n        if (listenerAddr != address(0)) {\n            PDPListener(listenerAddr).proofSetDeleted(setId, deletedLeafCount, extraData);\n        }\n        emit ProofSetDeleted(setId, deletedLeafCount);\n    }\n\n    // Struct for tracking root data\n    struct RootData {\n        Cids.Cid root;\n        uint256 rawSize;\n    }\n\n    // Appends new roots to the collection managed by a proof set.\n    // These roots won't be challenged until the next proving period is \n    // started by calling nextProvingPeriod.\n    function addRoots(uint256 setId, RootData[] calldata rootData, bytes calldata extraData) public returns (uint256) {\n        require(extraData.length <= EXTRA_DATA_MAX_SIZE, \"Extra data too large\");\n        require(proofSetLive(setId), \"Proof set not live\");\n        require(rootData.length > 0, \"Must add at least one root\");\n        require(proofSetOwner[setId] == msg.sender, \"Only the owner can add roots\");\n        uint256 firstAdded = nextRootId[setId];\n        uint256[] memory rootIds = new uint256[](rootData.length);\n\n\n        for (uint256 i = 0; i < rootData.length; i++) {\n            addOneRoot(setId, i, rootData[i].root, rootData[i].rawSize);\n            rootIds[i] = firstAdded + i;\n        }\n        emit RootsAdded(setId, rootIds);\n\n        address listenerAddr = proofSetListener[setId];\n        if (listenerAddr != address(0)) {\n            PDPListener(listenerAddr).rootsAdded(setId, firstAdded, rootData, extraData);\n        }\n\n        return firstAdded;\n    }\n\n    error IndexedError(uint256 idx, string msg);\n\n    function addOneRoot(uint256 setId, uint256 callIdx, Cids.Cid calldata root, uint256 rawSize) internal returns (uint256) {\n        if (rawSize % LEAF_SIZE != 0) {\n            revert IndexedError(callIdx, \"Size must be a multiple of 32\");\n        }\n        if (rawSize == 0) {\n            revert IndexedError(callIdx, \"Size must be greater than 0\");\n        }\n        if (rawSize > MAX_ROOT_SIZE) {\n            revert IndexedError(callIdx, \"Root size must be less than 2^50\");\n        }\n\n        uint256 leafCount = rawSize / LEAF_SIZE;\n        uint256 rootId = nextRootId[setId]++;\n        sumTreeAdd(setId, leafCount, rootId);\n        rootCids[setId][rootId] = root;\n        rootLeafCounts[setId][rootId] = leafCount;\n        proofSetLeafCount[setId] += leafCount;\n        return rootId;\n    }\n\n    // scheduleRemovals scheduels removal of a batch of roots from a proof set for the start of the next\n    // proving period. It must be called by the proof set owner.\n    function scheduleRemovals(uint256 setId, uint256[] calldata rootIds, bytes calldata extraData) public {\n        require(extraData.length <= EXTRA_DATA_MAX_SIZE, \"Extra data too large\");\n        require(proofSetLive(setId), \"Proof set not live\");\n        require(proofSetOwner[setId] == msg.sender, \"Only the owner can schedule removal of roots\");\n        require(rootIds.length + scheduledRemovals[setId].length <= MAX_ENQUEUED_REMOVALS, \"Too many removals wait for next proving period to schedule\");\n\n        for (uint256 i = 0; i < rootIds.length; i++){\n            require(rootIds[i] < nextRootId[setId], \"Can only schedule removal of existing roots\");\n            scheduledRemovals[setId].push(rootIds[i]);\n        }\n\n        address listenerAddr = proofSetListener[setId];\n        if (listenerAddr != address(0)) {\n            PDPListener(listenerAddr).rootsScheduledRemove(setId, rootIds, extraData);\n        }\n    }\n\n    struct Proof {\n        bytes32 leaf;\n        bytes32[] proof;\n    }\n\n    // Verifies and records that the provider proved possession of the\n    // proof set Merkle roots at some epoch. The challenge seed is determined\n    // by the epoch of the previous proof of possession.\n    // Note that this method is not restricted to the proof set owner.\n    function provePossession(uint256 setId, Proof[] calldata proofs) public payable{\n        uint256 initialGas = gasleft();\n        require(msg.sender == proofSetOwner[setId], \"only the owner can move to next proving period\");\n        uint256 challengeEpoch = nextChallengeEpoch[setId];\n        require(block.number >= challengeEpoch, \"premature proof\");\n        require(proofs.length > 0, \"empty proof\");\n        require(challengeEpoch != NO_CHALLENGE_SCHEDULED, \"no challenge scheduled\");\n        RootIdAndOffset[] memory challenges = new RootIdAndOffset[](proofs.length);\n        \n        uint256 seed = drawChallengeSeed(setId);\n        uint256 leafCount = challengeRange[setId];\n        uint256 sumTreeTop = 256 - BitOps.clz(nextRootId[setId]);\n        for (uint64 i = 0; i < proofs.length; i++) {\n            // Hash (SHA3) the seed,  proof set id, and proof index to create challenge.\n            // Note -- there is a slight deviation here from the uniform distribution.\n            // Some leaves are challenged with probability p and some have probability p + deviation. \n            // This deviation is bounded by leafCount / 2^256 given a 256 bit hash.\n            // Deviation grows with proofset leaf count.\n            // Assuming a 1000EiB = 1 ZiB network size ~ 2^70 bytes of data or 2^65 leaves\n            // This deviation is bounded by 2^65 / 2^256 = 2^-191 which is negligible.            \n            //   If modifying this code to use a hash function with smaller output size \n            //   this deviation will increase and caution is advised.\n            // To remove this deviation we could use the standard solution of rejection sampling\n            //   This is complicated and slightly more costly at one more hash on average for maximally misaligned proofsets\n            //   and comes at no practical benefit given how small the deviation is.\n            bytes memory payload = abi.encodePacked(seed, setId, i);\n            uint256 challengeIdx = uint256(keccak256(payload)) % leafCount;\n\n            // Find the root that has this leaf, and the offset of the leaf within that root.\n            challenges[i] = findOneRootId(setId, challengeIdx, sumTreeTop);\n            bytes32 rootHash = Cids.digestFromCid(getRootCid(setId, challenges[i].rootId));\n            bool ok = MerkleVerify.verify(proofs[i].proof, rootHash, proofs[i].leaf, challenges[i].offset);\n            require(ok, \"proof did not verify\");\n        }\n\n     \n        // Note: We don't want to include gas spent on the listener call in the fee calculation\n        // to only account for proof verification fees and avoid gamability by getting the listener\n        // to do extraneous work just to inflate the gas fee.\n        //\n        // (add 32 bytes to the `callDataSize` to also account for the `setId` calldata param)\n        uint256 gasUsed = (initialGas - gasleft()) + ((calculateCallDataSize(proofs) + 32) * 1300);\n        calculateAndBurnProofFee(setId, gasUsed);\n\n        address listenerAddr = proofSetListener[setId];\n        if (listenerAddr != address(0)) {\n            PDPListener(listenerAddr).possessionProven(setId, proofSetLeafCount[setId], seed, proofs.length);\n        }\n        proofSetLastProvenEpoch[setId] = block.number;\n        emit PossessionProven(setId, challenges);\n    }\n\n    function calculateProofFee(uint256 setId, uint256 estimatedGasFee) public view returns (uint256) {\n        uint256 rawSize = 32 * challengeRange[setId];\n        (uint64 filUsdPrice, int32 filUsdPriceExpo) = getFILUSDPrice();\n\n        return PDPFees.proofFeeWithGasFeeBound(\n            estimatedGasFee,\n            filUsdPrice,\n            filUsdPriceExpo,\n            rawSize,\n            block.number - proofSetLastProvenEpoch[setId]\n        );\n    }\n\n    function calculateAndBurnProofFee(uint256 setId, uint256 gasUsed) internal {\n        uint256 estimatedGasFee = gasUsed * block.basefee;\n        uint256 rawSize = 32 * challengeRange[setId];\n        (uint64 filUsdPrice, int32 filUsdPriceExpo) = getFILUSDPrice();\n\n        uint256 proofFee = PDPFees.proofFeeWithGasFeeBound(\n            estimatedGasFee,\n            filUsdPrice,\n            filUsdPriceExpo,\n            rawSize,\n            block.number - proofSetLastProvenEpoch[setId]\n        );        \n        burnFee(proofFee);\n        if (msg.value > proofFee) {\n            // Return the overpayment\n            payable(msg.sender).transfer(msg.value - proofFee);\n        }\n        emit ProofFeePaid(setId, proofFee, filUsdPrice, filUsdPriceExpo);\n    }\n\n    function calculateCallDataSize(Proof[] calldata proofs) internal pure returns (uint256) {\n        uint256 callDataSize = 0;\n        for (uint256 i = 0; i < proofs.length; i++) {\n            // 64 for the (leaf + abi encoding overhead ) + each element in the proof is 32 bytes\n            callDataSize += 64 + (proofs[i].proof.length * 32);\n        }\n        return callDataSize;\n    }\n\n    function getRandomness(uint256 epoch) public view returns (uint256) {\n        // Call the precompile\n        (bool success, bytes memory result) = RANDOMNESS_PRECOMPILE.staticcall(abi.encodePacked(epoch));\n\n        // Check if the call was successful\n        require(success, \"Randomness precompile call failed\");\n\n        // Decode and return the result\n        return abi.decode(result, (uint256));\n    }\n\n\n    function drawChallengeSeed(uint256 setId) internal view returns (uint256) {\n        return getRandomness(nextChallengeEpoch[setId]);\n    }\n\n    // Roll over to the next proving period\n    //\n    // This method updates the collection of provable roots in the proof set by\n    // 1. Actually removing the roots that have been scheduled for removal\n    // 2. Updating the challenge range to now include leaves added in the last proving period\n    // So after this method is called roots scheduled for removal are no longer eligible for challenging\n    // and can be deleted.  And roots added in the last proving period must be available for challenging.\n    //\n    // Additionally this method forces sampling of a new challenge.  It enforces that the new\n    // challenge epoch is at least `challengeFinality` epochs in the future.\n    //\n    // Note that this method can be called at any time but the pdpListener will likely consider it\n    // a \"fault\" or other penalizeable behavior to call this method before calling provePossesion.\n    function nextProvingPeriod(uint256 setId, uint256 challengeEpoch, bytes calldata extraData) public {\n        require(extraData.length <= EXTRA_DATA_MAX_SIZE, \"Extra data too large\");\n        require(msg.sender == proofSetOwner[setId], \"only the owner can move to next proving period\");\n        require(proofSetLeafCount[setId] > 0, \"can only start proving once leaves are added\");\n        \n        if (proofSetLastProvenEpoch[setId] == NO_PROVEN_EPOCH) {\n            proofSetLastProvenEpoch[setId] = block.number;\n        }\n\n        // Take removed roots out of proving set\n        uint256[] storage removals = scheduledRemovals[setId];\n        uint256[] memory removalsToProcess = new uint256[](removals.length);\n\n        for (uint256 i = 0; i < removalsToProcess.length; i++) {\n            removalsToProcess[i] = removals[removals.length - 1];\n            removals.pop();\n        }\n\n        removeRoots(setId, removalsToProcess);\n        emit RootsRemoved(setId, removalsToProcess);\n        \n        // Bring added roots into proving set\n        challengeRange[setId] = proofSetLeafCount[setId];\n        if (challengeEpoch < block.number + challengeFinality) {\n            revert(\"challenge epoch must be at least challengeFinality epochs in the future\");\n        }\n        nextChallengeEpoch[setId] = challengeEpoch;\n\n        // Clear next challenge epoch if the set is now empty.\n        // It will be re-set after new data is added and nextProvingPeriod is called.\n        if (proofSetLeafCount[setId] == 0) {\n            emit ProofSetEmpty(setId);\n            proofSetLastProvenEpoch[setId] = NO_PROVEN_EPOCH;\n            nextChallengeEpoch[setId] = NO_CHALLENGE_SCHEDULED;\n        }\n\n        address listenerAddr = proofSetListener[setId];\n        if (listenerAddr != address(0)) {\n            PDPListener(listenerAddr).nextProvingPeriod(setId, nextChallengeEpoch[setId], proofSetLeafCount[setId], extraData);\n        }\n        emit NextProvingPeriod(setId, challengeEpoch, proofSetLeafCount[setId]);\n    }\n\n    // removes roots from a proof set's state.\n    function removeRoots(uint256 setId, uint256[] memory rootIds) internal {\n        require(proofSetLive(setId), \"Proof set not live\");\n        uint256 totalDelta = 0;\n        for (uint256 i = 0; i < rootIds.length; i++){\n            totalDelta += removeOneRoot(setId, rootIds[i]);\n        }\n        proofSetLeafCount[setId] -= totalDelta;\n    }\n\n    // removeOneRoot removes a root's array entries from the proof sets state and returns\n    // the number of leafs by which to reduce the total proof set leaf count.\n    function removeOneRoot(uint256 setId, uint256 rootId) internal returns (uint256) {\n        uint256 delta = rootLeafCounts[setId][rootId];\n        sumTreeRemove(setId, rootId, delta);\n        delete rootLeafCounts[setId][rootId];\n        delete rootCids[setId][rootId];\n        return delta;\n    }\n\n    /* Sum tree functions */\n    /*\n    A sumtree is a variant of a Fenwick or binary indexed tree.  It is a binary\n    tree where each node is the sum of its children. It is designed to support\n    efficient query and update operations on a base array of integers. Here\n    the base array is the roots leaf count array.  Asymptotically the sum tree\n    has logarithmic search and update functions.  Each slot of the sum tree is\n    logically a node in a binary tree.\n\n    The node’s height from the leaf depth is defined as -1 + the ruler function\n    (https://oeis.org/A001511 [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,...]) applied to\n    the slot’s index + 1, i.e. the number of trailing 0s in the binary representation\n    of the index + 1.  Each slot in the sum tree array contains the sum of a range\n    of the base array.  The size of this range is defined by the height assigned\n    to this slot in the binary tree structure of the sum tree, i.e. the value of\n    the ruler function applied to the slot’s index.  The range for height d and\n    current index j is [j + 1 - 2^d : j] inclusive.  For example if the node’s\n    height is 0 its value is set to the base array’s value at the same index and\n    if the node’s height is 3 then its value is set to the sum of the last 2^3 = 8\n    values of the base array. The reason to do things with recursive partial sums\n    is to accommodate O(log len(base array)) updates for add and remove operations\n    on the base array.\n    */\n\n    // Perform sumtree addition\n    //\n    function sumTreeAdd(uint256 setId, uint256 count, uint256 rootId) internal {\n        uint256 index = rootId;\n        uint256 h = heightFromIndex(index);\n\n        uint256 sum = count;\n        // Sum BaseArray[j - 2^i] for i in [0, h)\n        for (uint256 i = 0; i < h; i++) {\n            uint256 j = index - (1 << i);\n            sum += sumTreeCounts[setId][j];\n        }\n        sumTreeCounts[setId][rootId] = sum;\n    }\n\n    // Perform sumtree removal\n    //\n    function sumTreeRemove(uint256 setId, uint256 index, uint256 delta) internal {\n        uint256 top = uint256(256 - BitOps.clz(nextRootId[setId]));\n        uint256 h = uint256(heightFromIndex(index));\n\n        // Deletion traversal either terminates at\n        // 1) the top of the tree or\n        // 2) the highest node right of the removal index\n        while (h <= top && index < nextRootId[setId]) {\n            sumTreeCounts[setId][index] -= delta;\n            index += 1 << h;\n            h = heightFromIndex(index);\n        }\n    }\n\n    struct RootIdAndOffset {\n        uint256 rootId;\n        uint256 offset;\n    }\n\n    // Perform sumtree find\n    function findOneRootId(uint256 setId, uint256 leafIndex, uint256 top) internal view returns (RootIdAndOffset memory) {\n        require(leafIndex < proofSetLeafCount[setId], \"Leaf index out of bounds\");\n        uint256 searchPtr = (1 << top) - 1;\n        uint256 acc = 0;\n\n        // Binary search until we find the index of the sumtree leaf covering the index range\n        uint256 candidate;\n        for (uint256 h = top; h > 0; h--) {\n            // Search has taken us past the end of the sumtree\n            // Only option is to go left\n            if (searchPtr >= nextRootId[setId]) {\n                searchPtr -= 1 << (h - 1);\n                continue;\n            }\n\n            candidate = acc + sumTreeCounts[setId][searchPtr];\n            // Go right\n            if (candidate <= leafIndex) {\n                acc += sumTreeCounts[setId][searchPtr];\n                searchPtr += 1 << (h - 1);\n            } else {\n                // Go left\n                searchPtr -= 1 << (h - 1);\n            }\n        }\n        candidate = acc + sumTreeCounts[setId][searchPtr];\n        if (candidate <= leafIndex) {\n            // Choose right\n            return RootIdAndOffset(searchPtr + 1, leafIndex - candidate);\n        } // Choose left\n        return RootIdAndOffset(searchPtr, leafIndex - acc);\n    }\n\n    // findRootIds is a batched version of findOneRootId\n    function findRootIds(uint256 setId, uint256[] calldata leafIndexs) public view returns (RootIdAndOffset[] memory) {\n        // The top of the sumtree is the largest power of 2 less than the number of roots\n        uint256 top = 256 - BitOps.clz(nextRootId[setId]);\n        RootIdAndOffset[] memory result = new RootIdAndOffset[](leafIndexs.length);\n        for (uint256 i = 0; i < leafIndexs.length; i++) {\n            result[i] = findOneRootId(setId, leafIndexs[i], top);\n        }\n        return result;\n    }\n\n    // Return height of sumtree node at given index\n    // Calculated by taking the trailing zeros of 1 plus the index\n    function heightFromIndex(uint256 index) internal pure returns (uint256) {\n        return BitOps.ctz(index + 1);\n    }\n\n    // Add function to get FIL/USD price\n    function getFILUSDPrice() public view returns (uint64, int32) {\n        // Get FIL/USD price no older than 1 day\n        PythStructs.Price memory priceData = PYTH.getPriceNoOlderThan(\n            FIL_USD_PRICE_FEED_ID,\n            SECONDS_IN_DAY\n        );\n        require(priceData.price > 0, \"failed to validate: price must be greater than 0\");\n\n        // Return the price and exponent representing USD per FIL\n        return (uint64(priceData.price), priceData.expo);\n    }\n}\n"
    }
}