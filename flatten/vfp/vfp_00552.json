{
    "vfp_id": "vfp_00552",
    "project_name": "Zenith Audit Report - Sofa Automator 2.0.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Missing validation for `createAutomator()`",
            "description": "The function `createAutomator()` lacks input validation to ensure the provided parameters are valid. This could allow the creation of an automator with invalid or unsupported configurations. The root cause is the absence of checks on critical input parameters. An attacker could potentially exploit this by creating malfunctioning automators, leading to user confusion or wasted gas. The impact is limited to operational inefficiencies and user experience, hence classified as low risk. However, the full details of exploitation and impact may be elaborated in the complete finding.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "sofa-protocol/contracts/automators/AutomatorFactory.sol",
                "sofa-protocol/contracts/mocks/automators/CrvUSDAutomatorFactory.sol",
                "sofa-protocol/contracts/mocks/automators/RCHAutomatorFactory.sol",
                "sofa-protocol/contracts/mocks/automators/AutomatorBaseFactory.sol",
                "sofa-protocol/contracts/mocks/automators/StETHAutomatorFactory.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "`harvest()` could fail to collect protocol fee if automator owner is blacklisted",
            "description": "The `harvest()` function may fail to collect the protocol fee when the automator owner is blacklisted. While the fee collection logic is in place, it does not properly handle the case where the owner is blacklisted, potentially allowing fee leakage. The cause is a lack of conditional bypass or fallback mechanism for fee collection independent of owner status. An attacker could exploit this by getting blacklisted and still benefiting from system operations without paying fees. The impact is a potential loss of protocol revenue, though limited in scope. Full details may follow in subsequent sections.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "sofa-protocol/contracts/automators/bases/AAVEAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/CrvUSDAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/RCHAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/StETHAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/AutomatorBase.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Negative fee calculation for `burnProducts()` should not favor the Automator owner",
            "description": "The fee calculation in `burnProducts()` can result in negative values, which currently benefit the Automator owner by increasing their payout. This is due to an unchecked arithmetic operation that allows underflow or negative fee interpretation. An attacker who is an Automator owner could exploit this by triggering specific burn conditions to extract additional funds. The impact is an unfair distribution of fees and potential economic imbalance, though the risk is mitigated by access control. The project acknowledged the issue but accepted it for gas optimization. Further context may exist in the full report.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "sofa-protocol/contracts/automators/bases/AAVEAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/CrvUSDAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/RCHAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/StETHAutomatorBase.sol",
                "sofa-protocol/contracts/automators/bases/AutomatorBase.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Users could waste credit on `createAutomator()` if the specified collateral is unsupported",
            "description": "Users calling `createAutomator()` may waste their credit if they specify a collateral type that is not supported by the system. This occurs due to the lack of a check for collateral support before deducting user credit. The root cause is the absence of a validation step prior to credit consumption. An attacker could trick users into using invalid collateral types, leading to loss of credit. The impact is limited to user gas and credit loss, hence classified as low. Resolution status indicates it was fixed, but full technical details may be in the complete finding.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "sofa-protocol/contracts/automators/AutomatorFactory.sol",
                "sofa-protocol/contracts/automators/bases/AAVEAutomatorBase.sol",
                "sofa-protocol/contracts/mocks/automators/RCHAutomatorFactory.sol",
                "sofa-protocol/contracts/mocks/automators/AutomatorBaseFactory.sol",
                "sofa-protocol/contracts/automators/bases/RCHAutomatorBase.sol"
            ]
        }
    ],
    "affected_files": {
        "AutomatorBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../interfaces/IFeeCollector.sol\";\n\nstruct Product {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n}\n\nstruct MintParams {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n    uint256 makerCollateral;\n    uint256 deadline;\n    address maker;\n    bytes makerSignature;\n}\n\ninterface IVault {\n    function mint(\n        uint256 totalCollateral,\n        MintParams calldata params,\n        address referral\n    ) external;\n\n    function burn(uint256 expiry, uint256[2] calldata anchorPrices, uint256 isMaker) external;\n}\n\ninterface IAutomatorFactory {\n    function vaults(address) external view returns (bool);\n    function makers(address) external view returns (bool);\n    function referral() external view returns (address);\n    function feeCollector() external view returns (address);\n}\n\ncontract AutomatorBase is ERC1155Holder, ERC20, ReentrancyGuard {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    address private _owner;\n    IERC20 public collateral;\n    uint256 public feeRate;\n    uint256 public maxPeriod;\n    address public immutable factory;\n    uint256 public constant MINIMUM_SHARES = 10**3;\n    string private symbol_;\n\n    int256 public totalFee;\n    uint256 public totalProtocolFee;\n    uint256 public totalPendingRedemptions;\n    uint256 public totalPositions;\n\n    mapping(bytes32 => uint256) private _positions;\n    mapping(address => Redemption) private _redemptions;\n\n    struct Redemption {\n        uint256 pendingRedemption;\n        uint256 redemptionRequestTimestamp;\n    }\n\n    struct ProductMint {\n        address vault;\n        uint256 totalCollateral;\n        MintParams mintParams;\n    }\n\n    struct ProductBurn {\n        address vault;\n        Product[] products;\n    }\n\n    event Deposited(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event Withdrawn(address indexed account, uint256 shares);\n    event RedemptionsClaimed(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event ProductsMinted(ProductMint[] products);\n    event ProductsBurned(ProductBurn[] products, uint256 accCollateralPerShare, int256 fee, uint256 protocolFee);\n    event FeeCollected(address account, uint256 feeAmount, int256 fee, uint256 protocolFeeAmount, uint256 protocolFee);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() ERC20(\"\", \"\") {\n        factory = _msgSender();\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function initialize(\n        address owner_,\n        address collateral_,\n        uint256 feeRate_,\n        uint256 maxPeriod_\n    ) external {\n        require(_msgSender() == factory, \"Automator: forbidden\");\n        _owner = owner_;\n        collateral = IERC20(collateral_);\n        feeRate = feeRate_;\n        maxPeriod = maxPeriod_;\n        uint256 salt = uint256(uint160(address(this))) % 65536;\n        symbol_ = string(abi.encodePacked(\"at\", IERC20Metadata(address(collateral)).symbol(), \"_\", salt.toString()));\n    }\n\n    function deposit(uint256 amount) external nonReentrant {\n        collateral.safeTransferFrom(_msgSender(), address(this), amount);\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amount - MINIMUM_SHARES;\n            _mint(address(0x000000000000000000000000000000000000dEaD), MINIMUM_SHARES);\n        } else {\n            shares = amount * totalSupply() / (totalCollateral() - amount);\n        }\n        _mint(_msgSender(), shares);\n        emit Deposited(_msgSender(), amount, amount, shares);\n    }\n\n    function withdraw(uint256 shares) external nonReentrant {\n        require(balanceOf(_msgSender()) >= shares, \"Automator: insufficient shares\");\n        if (_redemptions[_msgSender()].pendingRedemption > 0) {\n            totalPendingRedemptions = totalPendingRedemptions + shares - _redemptions[_msgSender()].pendingRedemption;\n        } else {\n            totalPendingRedemptions = totalPendingRedemptions + shares;\n        }\n        _redemptions[_msgSender()].pendingRedemption = shares;\n        _redemptions[_msgSender()].redemptionRequestTimestamp = block.timestamp;\n\n        emit Withdrawn(_msgSender(), shares);\n    }\n\n    function claimRedemptions() external nonReentrant {\n        require(_redemptions[_msgSender()].pendingRedemption > 0, \"Automator: no pending redemption\");\n        require(block.timestamp >= _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod && block.timestamp < _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod + 3 days, \"Automator: invalid redemption\");\n\n        uint256 pendingRedemption = _redemptions[_msgSender()].pendingRedemption;\n        uint256 amount = pendingRedemption * totalCollateral() / totalSupply();\n        require(collateral.balanceOf(address(this)) >= amount, \"Automator: insufficient collateral to redeem\");\n\n        totalPendingRedemptions -= pendingRedemption;\n        _redemptions[_msgSender()].pendingRedemption = 0;\n\n        _burn(_msgSender(), pendingRedemption);\n        collateral.safeTransfer(_msgSender(), amount);\n\n        emit RedemptionsClaimed(_msgSender(), amount, amount, pendingRedemption);\n    }\n\n    function mintProducts(\n        ProductMint[] calldata products,\n        bytes calldata signature\n    ) external nonReentrant onlyOwner {\n        bytes32 signatures;\n        uint256 _totalPositions;\n        for (uint256 i = 0; i < products.length; i++) {\n            require(IAutomatorFactory(factory).vaults(products[i].vault), \"Automator: invalid vault\");\n            uint256 period = products[i].mintParams.expiry - block.timestamp;\n            require(period <= maxPeriod, \"Automator: exceed maxPeriod\");\n            // approve vaults\n            if (collateral.allowance(address(this), products[i].vault) == 0) {\n                collateral.approve(products[i].vault, type(uint256).max);\n            }\n            IVault(products[i].vault).mint(\n                products[i].totalCollateral,\n                products[i].mintParams,\n                IAutomatorFactory(factory).referral()\n            );\n            bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].mintParams.expiry, products[i].mintParams.anchorPrices));\n            _positions[id] = _positions[id] + products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            _totalPositions += products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            signatures = signatures ^ keccak256(abi.encodePacked(products[i].mintParams.maker, products[i].mintParams.makerSignature));\n        }\n        totalPositions += _totalPositions;\n\n        (address signer, ) = signatures.toEthSignedMessageHash().tryRecover(signature);\n        require(IAutomatorFactory(factory).makers(signer), \"Automator: invalid maker\");\n        if (totalFee > 0) {\n            require(collateral.balanceOf(address(this)) >= uint256(totalFee) + totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        } else {\n            require(collateral.balanceOf(address(this)) >= totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        }\n\n        emit ProductsMinted(products);\n    }\n\n    function burnProducts(\n        ProductBurn[] calldata products\n    ) external nonReentrant {\n        uint256 _totalPositions;\n        int256 fee;\n        uint256 protocolFee;\n        for (uint256 i = 0; i < products.length; i++) {\n            for (uint256 j = 0; j < products[i].products.length; j++) {\n                uint256 balanceBefore = collateral.balanceOf(address(this));\n                IVault(products[i].vault).burn(\n                    products[i].products[j].expiry,\n                    products[i].products[j].anchorPrices,\n                    0\n                );\n                uint256 balanceAfter = collateral.balanceOf(address(this));\n                uint256 earned = balanceAfter - balanceBefore;\n                bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].products[j].expiry, products[i].products[j].anchorPrices));\n                _totalPositions += _positions[id];\n                if (earned > _positions[id]) {\n                    fee += int256((earned - _positions[id]) * feeRate / 1e18);\n                    protocolFee += (earned - _positions[id]) * IFeeCollector(IAutomatorFactory(factory).feeCollector()).tradingFeeRate() / 1e18;\n                }\n                if (earned < _positions[id]) {\n                    fee -= int256((_positions[id] - earned) * feeRate / 1e18);\n                }\n                delete _positions[id];\n            }\n        }\n        if (fee != 0) {\n            totalFee += fee;\n        }\n        if (protocolFee > 0) {\n            totalProtocolFee += protocolFee;\n        }\n        totalPositions -= _totalPositions;\n\n        emit ProductsBurned(products, totalCollateral(), fee, protocolFee);\n    }\n\n    function harvest() external nonReentrant {\n        require(totalFee > 0 || totalProtocolFee > 0, \"Automator: zero fee\");\n        uint256 feeAmount = 0;\n        uint256 protocolFeeAmount = 0;\n        if (totalFee > 0) {\n            collateral.safeTransfer(owner(), uint256(totalFee));\n            feeAmount = uint256(totalFee);\n            totalFee = 0;\n        }\n        if (totalProtocolFee > 0) {\n            collateral.safeTransfer(IAutomatorFactory(factory).feeCollector(), totalProtocolFee);\n            protocolFeeAmount = totalProtocolFee;\n            totalProtocolFee = 0;\n        }\n        emit FeeCollected(_msgSender(), feeAmount, totalFee, protocolFeeAmount, totalProtocolFee);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Automator \", IERC20Metadata(address(collateral)).name()));\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return symbol_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return IERC20Metadata(address(collateral)).decimals();\n    }\n\n    function getRedemption() external view returns (uint256, uint256) {\n        return (_redemptions[_msgSender()].pendingRedemption, _redemptions[_msgSender()].redemptionRequestTimestamp);\n    }\n\n    function getPricePerShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        } else {\n            return totalCollateral() * 1e18 / totalSupply();\n        }\n    }\n\n    function getUnredeemedCollateral() external view returns (uint256) {\n        if (collateral.balanceOf(address(this)) > totalPendingRedemptions * getPricePerShare() / 1e18) {\n            return collateral.balanceOf(address(this)) - totalPendingRedemptions * getPricePerShare() / 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    function totalCollateral() public view returns (uint256) {\n        if (totalFee > 0) {\n            return collateral.balanceOf(address(this)) + totalPositions - uint256(totalFee) - totalProtocolFee;\n        } else {\n            return collateral.balanceOf(address(this)) + totalPositions - totalProtocolFee;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (from != address(0)) {\n            require(balanceOf(from) >= amount + _redemptions[from].pendingRedemption, \"Automator: invalid transfer amount\");\n        }\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n",
        "AutomatorFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./bases/AAVEAutomatorBase.sol\";\n\ncontract AutomatorFactory is Ownable {\n    address public referral;\n    address public feeCollector;\n    address public immutable automator;\n    mapping(address => bool) public vaults;\n    mapping(address => bool) public makers;\n\n    address[] public automators;\n    mapping(address => uint256) public credits;\n    mapping(address => mapping(address => address)) public getAutomator;\n\n    event ReferralSet(address oldReferral, address newReferral);\n    event FeeCollectorSet(address oldFeeCollector, address newFeeCollector);\n    event AutomatorCreated(address indexed creator, address indexed collateral, address automator, uint256 feeRate, uint256 maxPeriod);\n    event VaultsEnabled(address[] vaults);\n    event VaultsDisabled(address[] vaults);\n    event MakersEnabled(address[] makers);\n    event MakersDisabled(address[] makers);\n    event CreditsTopUp(address indexed user, uint256 amount);\n\n    constructor(address referral_, address feeCollector_, address pool_) {\n        referral = referral_;\n        feeCollector = feeCollector_;\n        automator = address(new AAVEAutomatorBase(pool_));\n    }\n\n    function createAutomator(\n        uint256 feeRate,\n        uint256 maxPeriod,\n        address collateral\n    ) external returns (address) {\n        require(credits[_msgSender()] > 0, \"AutomatorFactory: insufficient credits\");\n        credits[_msgSender()] -= 1;\n        bytes32 salt = keccak256(abi.encodePacked(_msgSender(), collateral));\n        address _automator = Clones.cloneDeterministic(automator, salt);\n        AAVEAutomatorBase(_automator).initialize(_msgSender(), collateral, feeRate, maxPeriod);\n        require(getAutomator[_msgSender()][collateral] == address(0), \"AutomatorFactory: automator already exists\");\n        getAutomator[_msgSender()][collateral] = _automator;\n        automators.push(_automator);\n        emit AutomatorCreated(_msgSender(), collateral, _automator, feeRate, maxPeriod);\n        return _automator;\n    }\n\n    function automatorsLength() external view returns (uint256) {\n        return automators.length;\n    }\n\n    function setReferral(address referral_) external onlyOwner {\n        require(referral_ != address(0), \"AutomatorFactory: referral is the zero address\");\n        emit ReferralSet(referral, referral_);\n        referral = referral_;\n    }\n\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        require(feeCollector_ != address(0), \"AutomatorFactory: feeCollector is the zero address\");\n        emit FeeCollectorSet(feeCollector, feeCollector_);\n        feeCollector = feeCollector_;\n    }\n\n    function topUp(address user, uint256 amount) external onlyOwner {\n        credits[user] += amount;\n        emit CreditsTopUp(user, amount);\n    }\n\n    function enableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = true;\n        }\n        emit VaultsEnabled(vaults_);\n    }\n\n    function disableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = false;\n        }\n        emit VaultsDisabled(vaults_);\n    }\n\n    function enableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = true;\n        }\n        emit MakersEnabled(makers_);\n    }\n\n    function disableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = false;\n        }\n        emit MakersDisabled(makers_);\n    }\n}\n",
        "RCHAutomatorFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../automators/bases/RCHAutomatorBase.sol\";\n\ncontract RCHAutomatorFactory is Ownable {\n    address public referral;\n    address public feeCollector;\n    address public immutable automator;\n    mapping(address => bool) public vaults;\n    mapping(address => bool) public makers;\n\n    address[] public automators;\n    mapping(address => uint256) public credits;\n    mapping(address => mapping(address => address)) public getAutomator;\n\n    event ReferralSet(address oldReferral, address newReferral);\n    event FeeCollectorSet(address oldFeeCollector, address newFeeCollector);\n    event AutomatorCreated(address indexed creator, address indexed collateral, address automator, uint256 feeRate, uint256 maxPeriod);\n    event VaultsEnabled(address[] vaults);\n    event VaultsDisabled(address[] vaults);\n    event MakersEnabled(address[] makers);\n    event MakersDisabled(address[] makers);\n    event CreditsTopUp(address indexed user, uint256 amount);\n\n    constructor(address referral_, address feeCollector_, address zenRCH_) {\n        referral = referral_;\n        feeCollector = feeCollector_;\n        automator = address(new RCHAutomatorBase(zenRCH_));\n    }\n\n    function createAutomator(\n        uint256 feeRate,\n        uint256 maxPeriod,\n        address collateral\n    ) external returns (address) {\n        require(credits[_msgSender()] > 0, \"AutomatorFactory: insufficient credits\");\n        credits[_msgSender()] -= 1;\n        bytes32 salt = keccak256(abi.encodePacked(_msgSender(), collateral));\n        address _automator = Clones.cloneDeterministic(automator, salt);\n        RCHAutomatorBase(_automator).initialize(_msgSender(), collateral, feeRate, maxPeriod);\n        require(getAutomator[_msgSender()][collateral] == address(0), \"AutomatorFactory: automator already exists\");\n        getAutomator[_msgSender()][collateral] = _automator;\n        automators.push(_automator);\n        emit AutomatorCreated(_msgSender(), collateral, _automator, feeRate, maxPeriod);\n        return _automator;\n    }\n\n    function automatorsLength() external view returns (uint256) {\n        return automators.length;\n    }\n\n    function setReferral(address referral_) external onlyOwner {\n        require(referral_ != address(0), \"AutomatorFactory: referral is the zero address\");\n        emit ReferralSet(referral, referral_);\n        referral = referral_;\n    }\n\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        require(feeCollector_ != address(0), \"AutomatorFactory: feeCollector is the zero address\");\n        emit FeeCollectorSet(feeCollector, feeCollector_);\n        feeCollector = feeCollector_;\n    }\n\n    function topUp(address user, uint256 amount) external onlyOwner {\n        credits[user] += amount;\n        emit CreditsTopUp(user, amount);\n    }\n\n    function enableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = true;\n        }\n        emit VaultsEnabled(vaults_);\n    }\n\n    function disableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = false;\n        }\n        emit VaultsDisabled(vaults_);\n    }\n\n    function enableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = true;\n        }\n        emit MakersEnabled(makers_);\n    }\n\n    function disableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = false;\n        }\n        emit MakersDisabled(makers_);\n    }\n}\n",
        "CrvUSDAutomatorFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../automators/bases/CrvUSDAutomatorBase.sol\";\n\ncontract CrvUSDAutomatorFactory is Ownable {\n    address public referral;\n    address public feeCollector;\n    address public immutable automator;\n    mapping(address => bool) public vaults;\n    mapping(address => bool) public makers;\n\n    address[] public automators;\n    mapping(address => uint256) public credits;\n    mapping(address => mapping(address => address)) public getAutomator;\n\n    event ReferralSet(address oldReferral, address newReferral);\n    event FeeCollectorSet(address oldFeeCollector, address newFeeCollector);\n    event AutomatorCreated(address indexed creator, address indexed collateral, address automator, uint256 feeRate, uint256 maxPeriod);\n    event VaultsEnabled(address[] vaults);\n    event VaultsDisabled(address[] vaults);\n    event MakersEnabled(address[] makers);\n    event MakersDisabled(address[] makers);\n    event CreditsTopUp(address indexed user, uint256 amount);\n\n    constructor(address referral_, address feeCollector_, address scrvUSD_) {\n        referral = referral_;\n        feeCollector = feeCollector_;\n        automator = address(new CrvUSDAutomatorBase(scrvUSD_));\n    }\n\n    function createAutomator(\n        uint256 feeRate,\n        uint256 maxPeriod,\n        address collateral\n    ) external returns (address) {\n        require(credits[_msgSender()] > 0, \"AutomatorFactory: insufficient credits\");\n        credits[_msgSender()] -= 1;\n        bytes32 salt = keccak256(abi.encodePacked(_msgSender(), collateral));\n        address _automator = Clones.cloneDeterministic(automator, salt);\n        CrvUSDAutomatorBase(_automator).initialize(_msgSender(), collateral, feeRate, maxPeriod);\n        require(getAutomator[_msgSender()][collateral] == address(0), \"AutomatorFactory: automator already exists\");\n        getAutomator[_msgSender()][collateral] = _automator;\n        automators.push(_automator);\n        emit AutomatorCreated(_msgSender(), collateral, _automator, feeRate, maxPeriod);\n        return _automator;\n    }\n\n    function automatorsLength() external view returns (uint256) {\n        return automators.length;\n    }\n\n    function setReferral(address referral_) external onlyOwner {\n        require(referral_ != address(0), \"AutomatorFactory: referral is the zero address\");\n        emit ReferralSet(referral, referral_);\n        referral = referral_;\n    }\n\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        require(feeCollector_ != address(0), \"AutomatorFactory: feeCollector is the zero address\");\n        emit FeeCollectorSet(feeCollector, feeCollector_);\n        feeCollector = feeCollector_;\n    }\n\n    function topUp(address user, uint256 amount) external onlyOwner {\n        credits[user] += amount;\n        emit CreditsTopUp(user, amount);\n    }\n\n    function enableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = true;\n        }\n        emit VaultsEnabled(vaults_);\n    }\n\n    function disableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = false;\n        }\n        emit VaultsDisabled(vaults_);\n    }\n\n    function enableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = true;\n        }\n        emit MakersEnabled(makers_);\n    }\n\n    function disableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = false;\n        }\n        emit MakersDisabled(makers_);\n    }\n}\n",
        "StETHAutomatorBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../interfaces/IFeeCollector.sol\";\n\nstruct Product {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n}\n\nstruct MintParams {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n    uint256 makerCollateral;\n    uint256 deadline;\n    address maker;\n    bytes makerSignature;\n}\n\ninterface IVault {\n    function mint(\n        uint256 totalCollateral,\n        MintParams calldata params,\n        address referral\n    ) external;\n\n    function burn(uint256 expiry, uint256[2] calldata anchorPrices, uint256 isMaker) external;\n}\n\ninterface IAutomatorFactory {\n    function vaults(address) external view returns (bool);\n    function makers(address) external view returns (bool);\n    function referral() external view returns (address);\n    function feeCollector() external view returns (address);\n}\n\ncontract StETHAutomatorBase is ERC1155Holder, ERC20, ReentrancyGuard {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    address private _owner;\n    IERC20 public collateral;\n    uint256 public feeRate;\n    uint256 public maxPeriod;\n    address public immutable factory;\n    uint256 public constant MINIMUM_SHARES = 10**3;\n    string private symbol_;\n\n    int256 public totalFee;\n    uint256 public totalProtocolFee;\n    uint256 public totalPendingRedemptions;\n    uint256 public totalPositions;\n\n    mapping(bytes32 => uint256) private _positions;\n    mapping(address => Redemption) private _redemptions;\n\n    struct Redemption {\n        uint256 pendingRedemption;\n        uint256 redemptionRequestTimestamp;\n    }\n\n    struct ProductMint {\n        address vault;\n        uint256 totalCollateral;\n        MintParams mintParams;\n    }\n\n    struct ProductBurn {\n        address vault;\n        Product[] products;\n    }\n\n    event Deposited(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event Withdrawn(address indexed account, uint256 shares);\n    event RedemptionsClaimed(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event ProductsMinted(ProductMint[] products);\n    event ProductsBurned(ProductBurn[] products, uint256 accCollateralPerShare, int256 fee, uint256 protocolFee);\n    event FeeCollected(address account, uint256 feeAmount, int256 fee, uint256 protocolFeeAmount, uint256 protocolFee);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() ERC20(\"\", \"\") {\n        factory = _msgSender();\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function initialize(\n        address owner_,\n        address collateral_,\n        uint256 feeRate_,\n        uint256 maxPeriod_\n    ) external {\n        require(_msgSender() == factory, \"Automator: forbidden\");\n        _owner = owner_;\n        collateral = IERC20(collateral_);\n        feeRate = feeRate_;\n        maxPeriod = maxPeriod_;\n        uint256 salt = uint256(uint160(address(this))) % 65536;\n        symbol_ = string(abi.encodePacked(\"at\", IERC20Metadata(address(collateral)).symbol(), \"_\", salt.toString()));\n    }\n\n    function deposit(uint256 amount) external nonReentrant {\n        collateral.safeTransferFrom(_msgSender(), address(this), amount);\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amount - MINIMUM_SHARES;\n            _mint(address(0x000000000000000000000000000000000000dEaD), MINIMUM_SHARES);\n        } else {\n            shares = amount * totalSupply() / (totalCollateral() - amount);\n        }\n        _mint(_msgSender(), shares);\n        emit Deposited(_msgSender(), amount, amount, shares);\n    }\n\n    function withdraw(uint256 shares) external nonReentrant {\n        require(balanceOf(_msgSender()) >= shares, \"Automator: insufficient shares\");\n        if (_redemptions[_msgSender()].pendingRedemption > 0) {\n            totalPendingRedemptions = totalPendingRedemptions + shares - _redemptions[_msgSender()].pendingRedemption;\n        } else {\n            totalPendingRedemptions = totalPendingRedemptions + shares;\n        }\n        _redemptions[_msgSender()].pendingRedemption = shares;\n        _redemptions[_msgSender()].redemptionRequestTimestamp = block.timestamp;\n\n        emit Withdrawn(_msgSender(), shares);\n    }\n\n    function claimRedemptions() external nonReentrant {\n        require(_redemptions[_msgSender()].pendingRedemption > 0, \"Automator: no pending redemption\");\n        require(block.timestamp >= _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod && block.timestamp < _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod + 3 days, \"Automator: invalid redemption\");\n\n        uint256 pendingRedemption = _redemptions[_msgSender()].pendingRedemption;\n        uint256 amount = pendingRedemption * totalCollateral() / totalSupply();\n        require(collateral.balanceOf(address(this)) >= amount, \"Automator: insufficient collateral to redeem\");\n\n        totalPendingRedemptions -= pendingRedemption;\n        _redemptions[_msgSender()].pendingRedemption = 0;\n\n        _burn(_msgSender(), pendingRedemption);\n        collateral.safeTransfer(_msgSender(), amount);\n\n        emit RedemptionsClaimed(_msgSender(), amount, amount, pendingRedemption);\n    }\n\n    function mintProducts(\n        ProductMint[] calldata products,\n        bytes calldata signature\n    ) external nonReentrant onlyOwner {\n        bytes32 signatures;\n        uint256 _totalPositions;\n        for (uint256 i = 0; i < products.length; i++) {\n            require(IAutomatorFactory(factory).vaults(products[i].vault), \"Automator: invalid vault\");\n            uint256 period = products[i].mintParams.expiry - block.timestamp;\n            require(period <= maxPeriod, \"Automator: exceed maxPeriod\");\n            // approve vaults\n            if (collateral.allowance(address(this), products[i].vault) == 0) {\n                collateral.approve(products[i].vault, type(uint256).max);\n            }\n            IVault(products[i].vault).mint(\n                products[i].totalCollateral,\n                products[i].mintParams,\n                IAutomatorFactory(factory).referral()\n            );\n            bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].mintParams.expiry, products[i].mintParams.anchorPrices));\n            _positions[id] = _positions[id] + products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            _totalPositions += products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            signatures = signatures ^ keccak256(abi.encodePacked(products[i].mintParams.maker, products[i].mintParams.makerSignature));\n        }\n        totalPositions += _totalPositions;\n\n        (address signer, ) = signatures.toEthSignedMessageHash().tryRecover(signature);\n        require(IAutomatorFactory(factory).makers(signer), \"Automator: invalid maker\");\n        if (totalFee > 0) {\n            require(collateral.balanceOf(address(this)) >= uint256(totalFee) + totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        } else {\n            require(collateral.balanceOf(address(this)) >= totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        }\n\n        emit ProductsMinted(products);\n    }\n\n    function burnProducts(\n        ProductBurn[] calldata products\n    ) external nonReentrant {\n        uint256 _totalPositions;\n        int256 fee;\n        uint256 protocolFee;\n        for (uint256 i = 0; i < products.length; i++) {\n            for (uint256 j = 0; j < products[i].products.length; j++) {\n                uint256 balanceBefore = collateral.balanceOf(address(this));\n                IVault(products[i].vault).burn(\n                    products[i].products[j].expiry,\n                    products[i].products[j].anchorPrices,\n                    0\n                );\n                uint256 balanceAfter = collateral.balanceOf(address(this));\n                uint256 earned = balanceAfter - balanceBefore;\n                bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].products[j].expiry, products[i].products[j].anchorPrices));\n                _totalPositions += _positions[id];\n                if (earned > _positions[id]) {\n                    fee += int256((earned - _positions[id]) * feeRate / 1e18);\n                    protocolFee += (earned - _positions[id]) * IFeeCollector(IAutomatorFactory(factory).feeCollector()).tradingFeeRate() / 1e18;\n                }\n                if (earned < _positions[id]) {\n                    fee -= int256((_positions[id] - earned) * feeRate / 1e18);\n                }\n                delete _positions[id];\n            }\n        }\n        if (fee != 0) {\n            totalFee += fee;\n        }\n        if (protocolFee > 0) {\n            totalProtocolFee += protocolFee;\n        }\n        totalPositions -= _totalPositions;\n\n        emit ProductsBurned(products, totalCollateral(), fee, protocolFee);\n    }\n\n    function harvest() external nonReentrant {\n        require(totalFee > 0 || totalProtocolFee > 0, \"Automator: zero fee\");\n        uint256 feeAmount = 0;\n        uint256 protocolFeeAmount = 0;\n        if (totalFee > 0) {\n            collateral.safeTransfer(owner(), uint256(totalFee));\n            feeAmount = uint256(totalFee);\n            totalFee = 0;\n        }\n        if (totalProtocolFee > 0) {\n            collateral.safeTransfer(IAutomatorFactory(factory).feeCollector(), totalProtocolFee);\n            protocolFeeAmount = totalProtocolFee;\n            totalProtocolFee = 0;\n        }\n        emit FeeCollected(_msgSender(), feeAmount, totalFee, protocolFeeAmount, totalProtocolFee);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Automator \", IERC20Metadata(address(collateral)).name()));\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return symbol_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return IERC20Metadata(address(collateral)).decimals();\n    }\n\n    function getRedemption() external view returns (uint256, uint256) {\n        return (_redemptions[_msgSender()].pendingRedemption, _redemptions[_msgSender()].redemptionRequestTimestamp);\n    }\n\n    function getPricePerShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        } else {\n            return totalCollateral() * 1e18 / totalSupply();\n        }\n    }\n\n    function getUnredeemedCollateral() external view returns (uint256) {\n        if (collateral.balanceOf(address(this)) > totalPendingRedemptions * getPricePerShare() / 1e18) {\n            return collateral.balanceOf(address(this)) - totalPendingRedemptions * getPricePerShare() / 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    function totalCollateral() public view returns (uint256) {\n        if (totalFee > 0) {\n            return collateral.balanceOf(address(this)) + totalPositions - uint256(totalFee) - totalProtocolFee;\n        } else {\n            return collateral.balanceOf(address(this)) + totalPositions - totalProtocolFee;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (from != address(0)) {\n            require(balanceOf(from) >= amount + _redemptions[from].pendingRedemption, \"Automator: invalid transfer amount\");\n        }\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n",
        "AutomatorBaseFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../automators/bases/AutomatorBase.sol\";\n\ncontract AutomatorBaseFactory is Ownable {\n    address public referral;\n    address public feeCollector;\n    address public immutable automator;\n    mapping(address => bool) public vaults;\n    mapping(address => bool) public makers;\n\n    address[] public automators;\n    mapping(address => uint256) public credits;\n    mapping(address => mapping(address => address)) public getAutomator;\n\n    event ReferralSet(address oldReferral, address newReferral);\n    event FeeCollectorSet(address oldFeeCollector, address newFeeCollector);\n    event AutomatorCreated(address indexed creator, address indexed collateral, address automator, uint256 feeRate, uint256 maxPeriod);\n    event VaultsEnabled(address[] vaults);\n    event VaultsDisabled(address[] vaults);\n    event MakersEnabled(address[] makers);\n    event MakersDisabled(address[] makers);\n    event CreditsTopUp(address indexed user, uint256 amount);\n\n    constructor(address referral_, address feeCollector_) {\n        referral = referral_;\n        feeCollector = feeCollector_;\n        automator = address(new AutomatorBase());\n    }\n\n    function createAutomator(\n        uint256 feeRate,\n        uint256 maxPeriod,\n        address collateral\n    ) external returns (address) {\n        require(credits[_msgSender()] > 0, \"AutomatorFactory: insufficient credits\");\n        credits[_msgSender()] -= 1;\n        bytes32 salt = keccak256(abi.encodePacked(_msgSender(), collateral));\n        address _automator = Clones.cloneDeterministic(automator, salt);\n        AutomatorBase(_automator).initialize(_msgSender(), collateral, feeRate, maxPeriod);\n        require(getAutomator[_msgSender()][collateral] == address(0), \"AutomatorFactory: automator already exists\");\n        getAutomator[_msgSender()][collateral] = _automator;\n        automators.push(_automator);\n        emit AutomatorCreated(_msgSender(), collateral, _automator, feeRate, maxPeriod);\n        return _automator;\n    }\n\n    function automatorsLength() external view returns (uint256) {\n        return automators.length;\n    }\n\n    function setReferral(address referral_) external onlyOwner {\n        require(referral_ != address(0), \"AutomatorFactory: referral is the zero address\");\n        emit ReferralSet(referral, referral_);\n        referral = referral_;\n    }\n\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        require(feeCollector_ != address(0), \"AutomatorFactory: feeCollector is the zero address\");\n        emit FeeCollectorSet(feeCollector, feeCollector_);\n        feeCollector = feeCollector_;\n    }\n\n    function topUp(address user, uint256 amount) external onlyOwner {\n        credits[user] += amount;\n        emit CreditsTopUp(user, amount);\n    }\n\n    function enableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = true;\n        }\n        emit VaultsEnabled(vaults_);\n    }\n\n    function disableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = false;\n        }\n        emit VaultsDisabled(vaults_);\n    }\n\n    function enableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = true;\n        }\n        emit MakersEnabled(makers_);\n    }\n\n    function disableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = false;\n        }\n        emit MakersDisabled(makers_);\n    }\n}\n",
        "RCHAutomatorBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../interfaces/IFeeCollector.sol\";\n\ninterface IZenRCH {\n    function mint(uint256 amount) external returns (uint256);\n    function withdraw(address to, uint256 shares) external returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function getPricePerShare() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\nstruct Product {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n}\n\nstruct MintParams {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n    uint256 makerCollateral;\n    uint256 deadline;\n    address maker;\n    bytes makerSignature;\n}\n\ninterface IVault {\n    function mint(\n        uint256 totalCollateral,\n        MintParams calldata params,\n        address referral\n    ) external;\n\n    function burn(uint256 expiry, uint256[2] calldata anchorPrices, uint256 isMaker) external;\n}\n\ninterface IAutomatorFactory {\n    function vaults(address) external view returns (bool);\n    function makers(address) external view returns (bool);\n    function referral() external view returns (address);\n    function feeCollector() external view returns (address);\n}\n\ncontract RCHAutomatorBase is ERC1155Holder, ERC20, ReentrancyGuard {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    address private _owner;\n    IERC20 public collateral;\n    uint256 public feeRate;\n    uint256 public maxPeriod;\n    address public immutable factory;\n    IZenRCH immutable zenRCH;\n    uint256 public constant MINIMUM_SHARES = 10**3;\n    string private symbol_;\n\n    int256 public totalFee;\n    uint256 public totalProtocolFee;\n    uint256 public totalPendingRedemptions;\n    uint256 public totalPositions;\n\n    mapping(bytes32 => uint256) private _positions;\n    mapping(address => Redemption) private _redemptions;\n\n    struct Redemption {\n        uint256 pendingRedemption;\n        uint256 redemptionRequestTimestamp;\n    }\n\n    struct ProductMint {\n        address vault;\n        uint256 totalCollateral;\n        MintParams mintParams;\n    }\n\n    struct ProductBurn {\n        address vault;\n        Product[] products;\n    }\n\n    event Deposited(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event Withdrawn(address indexed account, uint256 shares);\n    event RedemptionsClaimed(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event ProductsMinted(ProductMint[] products);\n    event ProductsBurned(ProductBurn[] products, uint256 accCollateralPerShare, int256 fee, uint256 protocolFee);\n    event FeeCollected(address account, uint256 feeAmount, int256 fee, uint256 protocolFeeAmount, uint256 protocolFee);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(address zenRCH_) ERC20(\"\", \"\") {\n        factory = _msgSender();\n        zenRCH = IZenRCH(zenRCH_);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function initialize(\n        address owner_,\n        address collateral_,\n        uint256 feeRate_,\n        uint256 maxPeriod_\n    ) external {\n        require(_msgSender() == factory, \"Automator: forbidden\");\n        _owner = owner_;\n        collateral = IERC20(collateral_);\n        feeRate = feeRate_;\n        maxPeriod = maxPeriod_;\n        collateral.safeApprove(address(zenRCH), type(uint256).max);\n        uint256 salt = uint256(uint160(address(this))) % 65536;\n        symbol_ = string(abi.encodePacked(\"at\", IERC20Metadata(address(collateral)).symbol(), \"_\", salt.toString()));\n    }\n\n    function deposit(uint256 amount) external nonReentrant {\n        collateral.safeTransferFrom(_msgSender(), address(this), amount);\n        uint256 shares;\n        uint256 zenRCHShares = zenRCH.mint(amount);\n        if (totalSupply() == 0) {\n            shares = zenRCHShares - MINIMUM_SHARES;\n            _mint(address(0x000000000000000000000000000000000000dEaD), MINIMUM_SHARES);\n        } else {\n            shares = zenRCHShares * totalSupply() / (totalCollateral() - zenRCHShares);\n        }\n        _mint(_msgSender(), shares);\n        emit Deposited(_msgSender(), amount, zenRCHShares, shares);\n    }\n\n    function withdraw(uint256 shares) external nonReentrant {\n        require(balanceOf(_msgSender()) >= shares, \"Automator: insufficient shares\");\n        if (_redemptions[_msgSender()].pendingRedemption > 0) {\n            totalPendingRedemptions = totalPendingRedemptions + shares - _redemptions[_msgSender()].pendingRedemption;\n        } else {\n            totalPendingRedemptions = totalPendingRedemptions + shares;\n        }\n        _redemptions[_msgSender()].pendingRedemption = shares;\n        _redemptions[_msgSender()].redemptionRequestTimestamp = block.timestamp;\n\n        emit Withdrawn(_msgSender(), shares);\n    }\n\n    function claimRedemptions() external nonReentrant {\n        require(_redemptions[_msgSender()].pendingRedemption > 0, \"Automator: no pending redemption\");\n        require(block.timestamp >= _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod && block.timestamp < _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod + 3 days, \"Automator: invalid redemption\");\n\n        uint256 pendingRedemption = _redemptions[_msgSender()].pendingRedemption;\n        uint256 zenRCHShares = pendingRedemption * totalCollateral() / totalSupply();\n        require(zenRCH.balanceOf(address(this)) >= zenRCHShares, \"Automator: insufficient collateral to redeem\");\n\n        totalPendingRedemptions -= pendingRedemption;\n        _redemptions[_msgSender()].pendingRedemption = 0;\n\n        _burn(_msgSender(), pendingRedemption);\n        uint256 amount = zenRCH.withdraw(_msgSender(), zenRCHShares);\n\n        emit RedemptionsClaimed(_msgSender(), amount, zenRCHShares, pendingRedemption);\n    }\n\n    function mintProducts(\n        ProductMint[] calldata products,\n        bytes calldata signature\n    ) external nonReentrant onlyOwner {\n        bytes32 signatures;\n        uint256 _totalPositions;\n        for (uint256 i = 0; i < products.length; i++) {\n            require(IAutomatorFactory(factory).vaults(products[i].vault), \"Automator: invalid vault\");\n            uint256 period = products[i].mintParams.expiry - block.timestamp;\n            require(period <= maxPeriod, \"Automator: exceed maxPeriod\");\n            // approve vaults\n            if (zenRCH.allowance(address(this), products[i].vault) == 0) {\n                zenRCH.approve(products[i].vault, type(uint256).max);\n            }\n            IVault(products[i].vault).mint(\n                products[i].totalCollateral,\n                products[i].mintParams,\n                IAutomatorFactory(factory).referral()\n            );\n            bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].mintParams.expiry, products[i].mintParams.anchorPrices));\n            _positions[id] = _positions[id] + products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            _totalPositions += products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            signatures = signatures ^ keccak256(abi.encodePacked(products[i].mintParams.maker, products[i].mintParams.makerSignature));\n        }\n        totalPositions += _totalPositions;\n\n        (address signer, ) = signatures.toEthSignedMessageHash().tryRecover(signature);\n        require(IAutomatorFactory(factory).makers(signer), \"Automator: invalid maker\");\n        if (totalFee > 0) {\n            require(zenRCH.balanceOf(address(this)) >= uint256(totalFee) + totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        } else {\n            require(zenRCH.balanceOf(address(this)) >= totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        }\n\n        emit ProductsMinted(products);\n    }\n\n    function burnProducts(\n        ProductBurn[] calldata products\n    ) external nonReentrant {\n        uint256 _totalPositions;\n        int256 fee;\n        uint256 protocolFee;\n        for (uint256 i = 0; i < products.length; i++) {\n            for (uint256 j = 0; j < products[i].products.length; j++) {\n                uint256 balanceBefore = zenRCH.balanceOf(address(this));\n                IVault(products[i].vault).burn(\n                    products[i].products[j].expiry,\n                    products[i].products[j].anchorPrices,\n                    0\n                );\n                uint256 balanceAfter = zenRCH.balanceOf(address(this));\n                uint256 earned = balanceAfter - balanceBefore;\n                bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].products[j].expiry, products[i].products[j].anchorPrices));\n                _totalPositions += _positions[id];\n                if (earned > _positions[id]) {\n                    fee += int256((earned - _positions[id]) * feeRate / 1e18);\n                    protocolFee += (earned - _positions[id]) * IFeeCollector(IAutomatorFactory(factory).feeCollector()).tradingFeeRate() / 1e18;\n                }\n                if (earned < _positions[id]) {\n                    fee -= int256((_positions[id] - earned) * feeRate / 1e18);\n                }\n                delete _positions[id];\n            }\n        }\n        if (fee != 0) {\n            totalFee += fee;\n        }\n        if (protocolFee > 0) {\n            totalProtocolFee += protocolFee;\n        }\n        totalPositions -= _totalPositions;\n\n        emit ProductsBurned(products, totalCollateral(), fee, protocolFee);\n    }\n\n    function harvest() external nonReentrant {\n        require(totalFee > 0 || totalProtocolFee > 0, \"Automator: zero fee\");\n        uint256 feeAmount = 0;\n        uint256 protocolFeeAmount = 0;\n        if (totalFee > 0) {\n            feeAmount = zenRCH.withdraw(owner(), uint256(totalFee));\n            totalFee = 0;\n        }\n        if (totalProtocolFee > 0) {\n            protocolFeeAmount = zenRCH.withdraw(IAutomatorFactory(factory).feeCollector(), totalProtocolFee);\n            totalProtocolFee = 0;\n        }\n        emit FeeCollected(_msgSender(), feeAmount, totalFee, protocolFeeAmount, totalProtocolFee);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Automator \", IERC20Metadata(address(collateral)).name()));\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return symbol_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return IERC20Metadata(address(collateral)).decimals();\n    }\n\n    function getRedemption() external view returns (uint256, uint256) {\n        return (_redemptions[_msgSender()].pendingRedemption, _redemptions[_msgSender()].redemptionRequestTimestamp);\n    }\n\n    function getPricePerShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        } else {\n            return totalCollateral() * 1e18 / totalSupply();\n        }\n    }\n\n    function getUnredeemedCollateral() external view returns (uint256) {\n        if (zenRCH.balanceOf(address(this)) > totalPendingRedemptions * getPricePerShare() / 1e18) {\n            return zenRCH.balanceOf(address(this)) - totalPendingRedemptions * getPricePerShare() / 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    function totalCollateral() public view returns (uint256) {\n        if (totalFee > 0) {\n            return zenRCH.balanceOf(address(this)) + totalPositions - uint256(totalFee) - totalProtocolFee;\n        } else {\n            return zenRCH.balanceOf(address(this)) + totalPositions - totalProtocolFee;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (from != address(0)) {\n            require(balanceOf(from) >= amount + _redemptions[from].pendingRedemption, \"Automator: invalid transfer amount\");\n        }\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n",
        "CrvUSDAutomatorBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../interfaces/IFeeCollector.sol\";\n\nstruct Product {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n}\n\nstruct MintParams {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n    uint256 makerCollateral;\n    uint256 deadline;\n    address maker;\n    bytes makerSignature;\n}\n\ninterface IVault {\n    function mint(\n        uint256 totalCollateral,\n        MintParams calldata params,\n        address referral\n    ) external;\n\n    function burn(uint256 expiry, uint256[2] calldata anchorPrices, uint256 isMaker) external;\n}\n\ninterface IAutomatorFactory {\n    function vaults(address) external view returns (bool);\n    function makers(address) external view returns (bool);\n    function referral() external view returns (address);\n    function feeCollector() external view returns (address);\n}\n\ninterface IScrvUSD {\n    function balanceOf(address account) external view returns (uint256);\n    //function convertToAssets(uint256 shares) external view returns (uint256);\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n    //function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract CrvUSDAutomatorBase is ERC1155Holder, ERC20, ReentrancyGuard {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    address private _owner;\n    IERC20 public collateral;\n    uint256 public feeRate;\n    uint256 public maxPeriod;\n    address public immutable factory;\n    IScrvUSD public immutable scrvUSD;\n    uint256 public constant MINIMUM_SHARES = 10**3;\n    string private symbol_;\n\n    int256 public totalFee;\n    uint256 public totalProtocolFee;\n    uint256 public totalPendingRedemptions;\n    uint256 public totalPositions;\n\n    mapping(bytes32 => uint256) private _positions;\n    mapping(address => Redemption) private _redemptions;\n\n    struct Redemption {\n        uint256 pendingRedemption;\n        uint256 redemptionRequestTimestamp;\n    }\n\n    struct ProductMint {\n        address vault;\n        uint256 totalCollateral;\n        MintParams mintParams;\n    }\n\n    struct ProductBurn {\n        address vault;\n        Product[] products;\n    }\n\n    event Deposited(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event Withdrawn(address indexed account, uint256 shares);\n    event RedemptionsClaimed(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event ProductsMinted(ProductMint[] products);\n    event ProductsBurned(ProductBurn[] products, uint256 accCollateralPerShare, int256 fee, uint256 protocolFee);\n    event FeeCollected(address account, uint256 feeAmount, int256 fee, uint256 protocolFeeAmount, uint256 protocolFee);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(address scrvUSD_) ERC20(\"\", \"\") {\n        factory = _msgSender();\n        scrvUSD = IScrvUSD(scrvUSD_);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function initialize(\n        address owner_,\n        address collateral_,\n        uint256 feeRate_,\n        uint256 maxPeriod_\n    ) external {\n        require(_msgSender() == factory, \"Automator: forbidden\");\n        _owner = owner_;\n        collateral = IERC20(collateral_);\n        feeRate = feeRate_;\n        maxPeriod = maxPeriod_;\n        collateral.safeApprove(address(scrvUSD), type(uint256).max);\n        uint256 salt = uint256(uint160(address(this))) % 65536;\n        symbol_ = string(abi.encodePacked(\"at\", IERC20Metadata(address(collateral)).symbol(), \"_\", salt.toString()));\n    }\n\n    function deposit(uint256 amount) external nonReentrant {\n        collateral.safeTransferFrom(_msgSender(), address(this), amount);\n        uint256  scrvusdShares = scrvUSD.deposit(amount, address(this));\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = scrvusdShares - MINIMUM_SHARES;\n            _mint(address(0x000000000000000000000000000000000000dEaD), MINIMUM_SHARES);\n        } else {\n            shares = scrvusdShares * totalSupply() / (totalCollateral() - scrvusdShares);\n        }\n        _mint(_msgSender(), shares);\n        emit Deposited(_msgSender(), amount, scrvusdShares, shares);\n    }\n\n    function withdraw(uint256 shares) external nonReentrant {\n        require(balanceOf(_msgSender()) >= shares, \"Automator: insufficient shares\");\n        if (_redemptions[_msgSender()].pendingRedemption > 0) {\n            totalPendingRedemptions = totalPendingRedemptions + shares - _redemptions[_msgSender()].pendingRedemption;\n        } else {\n            totalPendingRedemptions = totalPendingRedemptions + shares;\n        }\n        _redemptions[_msgSender()].pendingRedemption = shares;\n        _redemptions[_msgSender()].redemptionRequestTimestamp = block.timestamp;\n\n        emit Withdrawn(_msgSender(), shares);\n    }\n\n    function claimRedemptions() external nonReentrant {\n        require(_redemptions[_msgSender()].pendingRedemption > 0, \"Automator: no pending redemption\");\n        require(block.timestamp >= _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod && block.timestamp < _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod + 3 days, \"Automator: invalid redemption\");\n\n        uint256 pendingRedemption = _redemptions[_msgSender()].pendingRedemption;\n        uint256 scrvUSDShares = pendingRedemption * totalCollateral() / totalSupply();\n        require(scrvUSD.balanceOf(address(this)) >= scrvUSDShares, \"Automator: insufficient collateral to redeem\");\n\n        totalPendingRedemptions -= pendingRedemption;\n        _redemptions[_msgSender()].pendingRedemption = 0;\n\n        _burn(_msgSender(), pendingRedemption);\n        uint256 amount = scrvUSD.redeem(scrvUSDShares, _msgSender(), address(this));\n\n        emit RedemptionsClaimed(_msgSender(), amount, scrvUSDShares, pendingRedemption);\n    }\n\n    function mintProducts(\n        ProductMint[] calldata products,\n        bytes calldata signature\n    ) external nonReentrant onlyOwner {\n        bytes32 signatures;\n        uint256 _totalPositions;\n        for (uint256 i = 0; i < products.length; i++) {\n            require(IAutomatorFactory(factory).vaults(products[i].vault), \"Automator: invalid vault\");\n            uint256 period = products[i].mintParams.expiry - block.timestamp;\n            require(period <= maxPeriod, \"Automator: exceed maxPeriod\");\n            // approve vaults\n            if (scrvUSD.allowance(address(this), products[i].vault) == 0) {\n                scrvUSD.approve(products[i].vault, type(uint256).max);\n            }\n            IVault(products[i].vault).mint(\n                products[i].totalCollateral,\n                products[i].mintParams,\n                IAutomatorFactory(factory).referral()\n            );\n            bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].mintParams.expiry, products[i].mintParams.anchorPrices));\n            _positions[id] = _positions[id] + products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            _totalPositions += products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            signatures = signatures ^ keccak256(abi.encodePacked(products[i].mintParams.maker, products[i].mintParams.makerSignature));\n        }\n        totalPositions += _totalPositions;\n\n        (address signer, ) = signatures.toEthSignedMessageHash().tryRecover(signature);\n        require(IAutomatorFactory(factory).makers(signer), \"Automator: invalid maker\");\n        if (totalFee > 0) {\n            require(scrvUSD.balanceOf(address(this)) >= uint256(totalFee) + totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        } else {\n            require(scrvUSD.balanceOf(address(this)) >= totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        }\n\n        emit ProductsMinted(products);\n    }\n\n    function burnProducts(\n        ProductBurn[] calldata products\n    ) external nonReentrant {\n        uint256 _totalPositions;\n        int256 fee;\n        uint256 protocolFee;\n        for (uint256 i = 0; i < products.length; i++) {\n            for (uint256 j = 0; j < products[i].products.length; j++) {\n                uint256 balanceBefore = scrvUSD.balanceOf(address(this));\n                IVault(products[i].vault).burn(\n                    products[i].products[j].expiry,\n                    products[i].products[j].anchorPrices,\n                    0\n                );\n                uint256 balanceAfter = scrvUSD.balanceOf(address(this));\n                uint256 earned = balanceAfter - balanceBefore;\n                bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].products[j].expiry, products[i].products[j].anchorPrices));\n                _totalPositions += _positions[id];\n                if (earned > _positions[id]) {\n                    fee += int256((earned - _positions[id]) * feeRate / 1e18);\n                    protocolFee += (earned - _positions[id]) * IFeeCollector(IAutomatorFactory(factory).feeCollector()).tradingFeeRate() / 1e18;\n                }\n                if (earned < _positions[id]) {\n                    fee -= int256((_positions[id] - earned) * feeRate / 1e18);\n                }\n                delete _positions[id];\n            }\n        }\n        if (fee != 0) {\n            totalFee += fee;\n        }\n        if (protocolFee > 0) {\n            totalProtocolFee += protocolFee;\n        }\n        totalPositions -= _totalPositions;\n\n        emit ProductsBurned(products, totalCollateral(), fee, protocolFee);\n    }\n\n    function harvest() external nonReentrant {\n        require(totalFee > 0 || totalProtocolFee > 0, \"Automator: zero fee\");\n        uint256 feeAmount = 0;\n        uint256 protocolFeeAmount = 0;\n        if (totalFee > 0) {\n            feeAmount = scrvUSD.redeem(uint256(totalFee), owner(), address(this));\n            totalFee = 0;\n        }\n        if (totalProtocolFee > 0) {\n            protocolFeeAmount = scrvUSD.redeem(totalProtocolFee, IAutomatorFactory(factory).feeCollector(), address(this));\n            totalProtocolFee = 0;\n        }\n        emit FeeCollected(_msgSender(), feeAmount, totalFee, protocolFeeAmount, totalProtocolFee);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Automator \", IERC20Metadata(address(collateral)).name()));\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return symbol_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return IERC20Metadata(address(collateral)).decimals();\n    }\n\n    function getRedemption() external view returns (uint256, uint256) {\n        return (_redemptions[_msgSender()].pendingRedemption, _redemptions[_msgSender()].redemptionRequestTimestamp);\n    }\n\n    function getPricePerShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        } else {\n            return totalCollateral() * 1e18 / totalSupply();\n        }\n    }\n\n    function getUnredeemedCollateral() external view returns (uint256) {\n        if (scrvUSD.balanceOf(address(this)) > totalPendingRedemptions * getPricePerShare() / 1e18) {\n            return scrvUSD.balanceOf(address(this)) - totalPendingRedemptions * getPricePerShare() / 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    function totalCollateral() public view returns (uint256) {\n        if (totalFee > 0) {\n            return scrvUSD.balanceOf(address(this)) + totalPositions - uint256(totalFee) - totalProtocolFee;\n        } else {\n            return scrvUSD.balanceOf(address(this)) + totalPositions - totalProtocolFee;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (from != address(0)) {\n            require(balanceOf(from) >= amount + _redemptions[from].pendingRedemption, \"Automator: invalid transfer amount\");\n        }\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n",
        "AAVEAutomatorBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../interfaces/IFeeCollector.sol\";\nimport {IPool} from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\nimport {DataTypes} from \"@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol\";\nimport {ReserveLogic} from \"@aave/core-v3/contracts/protocol/libraries/logic/ReserveLogic.sol\";\nimport {IAToken} from \"@aave/core-v3/contracts/interfaces/IAToken.sol\";\n\nstruct Product {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n}\n\nstruct MintParams {\n    uint256 expiry;\n    uint256[2] anchorPrices;\n    uint256 makerCollateral;\n    uint256 deadline;\n    address maker;\n    bytes makerSignature;\n}\n\ninterface IVault {\n    function mint(\n        uint256 totalCollateral,\n        MintParams calldata params,\n        address referral\n    ) external;\n\n    function burn(uint256 expiry, uint256[2] calldata anchorPrices, uint256 isMaker) external;\n}\n\ninterface IAutomatorFactory {\n    function vaults(address) external view returns (bool);\n    function makers(address) external view returns (bool);\n    function referral() external view returns (address);\n    function feeCollector() external view returns (address);\n}\n\ncontract AAVEAutomatorBase is ERC1155Holder, ERC20, ReentrancyGuard {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    address private _owner;\n    IERC20 public collateral;\n    uint256 public feeRate;\n    uint256 public maxPeriod;\n    address public immutable factory;\n    uint256 public constant MINIMUM_SHARES = 10**3;\n    string private symbol_;\n\n    int256 public totalFee;\n    uint256 public totalProtocolFee;\n    uint256 public totalPendingRedemptions;\n    uint256 public totalPositions;\n\n    // Aave Referral Code\n    IAToken public aToken;\n    IPool public immutable pool;\n    uint16 private constant REFERRAL_CODE = 0;\n\n    mapping(bytes32 => uint256) private _positions;\n    mapping(address => Redemption) private _redemptions;\n\n    struct Redemption {\n        uint256 pendingRedemption;\n        uint256 redemptionRequestTimestamp;\n    }\n\n    struct ProductMint {\n        address vault;\n        uint256 totalCollateral;\n        MintParams mintParams;\n    }\n\n    struct ProductBurn {\n        address vault;\n        Product[] products;\n    }\n\n    event Deposited(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event Withdrawn(address indexed account, uint256 shares);\n    event RedemptionsClaimed(address indexed account, uint256 amount, uint256 yieldShares, uint256 shares);\n    event ProductsMinted(ProductMint[] products);\n    event ProductsBurned(ProductBurn[] products, uint256 accCollateralPerShare, int256 fee, uint256 protocolFee);\n    event FeeCollected(address account, uint256 feeAmount, int256 fee, uint256 protocolFeeAmount, uint256 protocolFee);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(address pool_) ERC20(\"\", \"\") {\n        pool = IPool(pool_);\n        factory = _msgSender();\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function initialize(\n        address owner_,\n        address collateral_,\n        uint256 feeRate_,\n        uint256 maxPeriod_\n    ) external {\n        require(_msgSender() == factory, \"Automator: forbidden\");\n        _owner = owner_;\n        collateral = IERC20(collateral_);\n        feeRate = feeRate_;\n        maxPeriod = maxPeriod_;\n        aToken = IAToken(pool.getReserveData(collateral_).aTokenAddress);\n        collateral.safeApprove(address(pool), type(uint256).max);\n        uint256 salt = uint256(uint160(address(this))) % 65536;\n        symbol_ = string(abi.encodePacked(\"at\", IERC20Metadata(address(collateral)).symbol(), \"_\", salt.toString()));\n    }\n\n    function deposit(uint256 amount) external nonReentrant {\n        collateral.safeTransferFrom(_msgSender(), address(this), amount);\n        pool.supply(address(collateral), amount, address(this), REFERRAL_CODE);\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amount - MINIMUM_SHARES;\n            _mint(address(0x000000000000000000000000000000000000dEaD), MINIMUM_SHARES);\n        } else {\n            shares = amount * totalSupply() / (totalCollateral() - amount);\n        }\n        _mint(_msgSender(), shares);\n        emit Deposited(_msgSender(), amount, amount, shares);\n    }\n\n    function withdraw(uint256 shares) external nonReentrant {\n        require(balanceOf(_msgSender()) >= shares, \"Automator: insufficient shares\");\n        if (_redemptions[_msgSender()].pendingRedemption > 0) {\n            totalPendingRedemptions = totalPendingRedemptions + shares - _redemptions[_msgSender()].pendingRedemption;\n        } else {\n            totalPendingRedemptions = totalPendingRedemptions + shares;\n        }\n        _redemptions[_msgSender()].pendingRedemption = shares;\n        _redemptions[_msgSender()].redemptionRequestTimestamp = block.timestamp;\n\n        emit Withdrawn(_msgSender(), shares);\n    }\n\n    function claimRedemptions() external nonReentrant {\n        require(_redemptions[_msgSender()].pendingRedemption > 0, \"Automator: no pending redemption\");\n        require(block.timestamp >= _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod && block.timestamp < _redemptions[_msgSender()].redemptionRequestTimestamp + maxPeriod + 3 days, \"Automator: invalid redemption\");\n\n        uint256 pendingRedemption = _redemptions[_msgSender()].pendingRedemption;\n        uint256 aTokenAmount = pendingRedemption * totalCollateral() / totalSupply();\n        require(aToken.balanceOf(address(this)) >= aTokenAmount, \"Automator: insufficient collateral to redeem\");\n\n        totalPendingRedemptions -= pendingRedemption;\n        _redemptions[_msgSender()].pendingRedemption = 0;\n\n        _burn(_msgSender(), pendingRedemption);\n        uint256 amount = pool.withdraw(address(collateral), aTokenAmount, _msgSender());\n        require(amount > 0, \"Automator: withdraw failed\");\n\n        emit RedemptionsClaimed(_msgSender(), amount, aTokenAmount, pendingRedemption);\n    }\n\n    function mintProducts(\n        ProductMint[] calldata products,\n        bytes calldata signature\n    ) external nonReentrant onlyOwner {\n        bytes32 signatures;\n        uint256 _totalPositions;\n        for (uint256 i = 0; i < products.length; i++) {\n            require(IAutomatorFactory(factory).vaults(products[i].vault), \"Automator: invalid vault\");\n            uint256 period = products[i].mintParams.expiry - block.timestamp;\n            require(period <= maxPeriod, \"Automator: exceed maxPeriod\");\n            // approve vaults\n            if (aToken.allowance(address(this), products[i].vault) == 0) {\n                aToken.approve(products[i].vault, type(uint256).max);\n            }\n            IVault(products[i].vault).mint(\n                products[i].totalCollateral,\n                products[i].mintParams,\n                IAutomatorFactory(factory).referral()\n            );\n            bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].mintParams.expiry, products[i].mintParams.anchorPrices));\n            _positions[id] = _positions[id] + products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            _totalPositions += products[i].totalCollateral - products[i].mintParams.makerCollateral;\n            signatures = signatures ^ keccak256(abi.encodePacked(products[i].mintParams.maker, products[i].mintParams.makerSignature));\n        }\n        totalPositions += _totalPositions;\n\n        (address signer, ) = signatures.toEthSignedMessageHash().tryRecover(signature);\n        require(IAutomatorFactory(factory).makers(signer), \"Automator: invalid maker\");\n        if (totalFee > 0) {\n            require(aToken.balanceOf(address(this)) >= uint256(totalFee) + totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        } else {\n            require(aToken.balanceOf(address(this)) >= totalProtocolFee + totalPendingRedemptions * totalCollateral() / totalSupply(), \"Automator: no enough collateral to redeem\");\n        }\n\n        emit ProductsMinted(products);\n    }\n\n    function burnProducts(\n        ProductBurn[] calldata products\n    ) external nonReentrant {\n        uint256 _totalPositions;\n        int256 fee;\n        uint256 protocolFee;\n        for (uint256 i = 0; i < products.length; i++) {\n            for (uint256 j = 0; j < products[i].products.length; j++) {\n                uint256 balanceBefore = aToken.balanceOf(address(this));\n                IVault(products[i].vault).burn(\n                    products[i].products[j].expiry,\n                    products[i].products[j].anchorPrices,\n                    0\n                );\n                uint256 balanceAfter = aToken.balanceOf(address(this));\n                uint256 earned = balanceAfter - balanceBefore;\n                bytes32 id = keccak256(abi.encodePacked(products[i].vault, products[i].products[j].expiry, products[i].products[j].anchorPrices));\n                _totalPositions += _positions[id];\n                if (earned > _positions[id]) {\n                    fee += int256((earned - _positions[id]) * feeRate / 1e18);\n                    protocolFee += (earned - _positions[id]) * IFeeCollector(IAutomatorFactory(factory).feeCollector()).tradingFeeRate() / 1e18;\n                }\n                if (earned < _positions[id]) {\n                    fee -= int256((_positions[id] - earned) * feeRate / 1e18);\n                }\n                delete _positions[id];\n            }\n        }\n        if (fee != 0) {\n            totalFee += fee;\n        }\n        if (protocolFee > 0) {\n            totalProtocolFee += protocolFee;\n        }\n        totalPositions -= _totalPositions;\n\n        emit ProductsBurned(products, totalCollateral(), fee, protocolFee);\n    }\n\n    function harvest() external nonReentrant {\n        require(totalFee > 0 || totalProtocolFee > 0, \"Automator: zero fee\");\n        uint256 feeAmount = 0;\n        uint256 protocolFeeAmount = 0;\n        if (totalFee > 0) {\n            feeAmount = pool.withdraw(address(collateral), uint256(totalFee), owner());\n            totalFee = 0;\n        }\n        if (totalProtocolFee > 0) {\n            protocolFeeAmount = pool.withdraw(address(collateral), totalProtocolFee, IAutomatorFactory(factory).feeCollector());\n            totalProtocolFee = 0;\n        }\n        emit FeeCollected(_msgSender(), feeAmount, totalFee, protocolFeeAmount, totalProtocolFee);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Automator \", IERC20Metadata(address(collateral)).name()));\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return symbol_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return IERC20Metadata(address(collateral)).decimals();\n    }\n\n    function getRedemption() external view returns (uint256, uint256) {\n        return (_redemptions[_msgSender()].pendingRedemption, _redemptions[_msgSender()].redemptionRequestTimestamp);\n    }\n\n    function getPricePerShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        } else {\n            return totalCollateral() * 1e18 / totalSupply();\n        }\n    }\n\n    function getUnredeemedCollateral() external view returns (uint256) {\n        if (aToken.balanceOf(address(this)) > totalPendingRedemptions * getPricePerShare() / 1e18) {\n            return aToken.balanceOf(address(this)) - totalPendingRedemptions * getPricePerShare() / 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    function totalCollateral() public view returns (uint256) {\n        if (totalFee > 0) {\n            return aToken.balanceOf(address(this)) + totalPositions - uint256(totalFee) - totalProtocolFee;\n        } else {\n            return aToken.balanceOf(address(this)) + totalPositions - totalProtocolFee;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (from != address(0)) {\n            require(balanceOf(from) >= amount + _redemptions[from].pendingRedemption, \"Automator: invalid transfer amount\");\n        }\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n",
        "StETHAutomatorFactory.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../automators/bases/StETHAutomatorBase.sol\";\n\ncontract StETHAutomatorFactory is Ownable {\n    address public referral;\n    address public feeCollector;\n    address public immutable automator;\n    mapping(address => bool) public vaults;\n    mapping(address => bool) public makers;\n\n    address[] public automators;\n    mapping(address => uint256) public credits;\n    mapping(address => mapping(address => address)) public getAutomator;\n\n    event ReferralSet(address oldReferral, address newReferral);\n    event FeeCollectorSet(address oldFeeCollector, address newFeeCollector);\n    event AutomatorCreated(address indexed creator, address indexed collateral, address automator, uint256 feeRate, uint256 maxPeriod);\n    event VaultsEnabled(address[] vaults);\n    event VaultsDisabled(address[] vaults);\n    event MakersEnabled(address[] makers);\n    event MakersDisabled(address[] makers);\n    event CreditsTopUp(address indexed user, uint256 amount);\n\n    constructor(address referral_, address feeCollector_) {\n        referral = referral_;\n        feeCollector = feeCollector_;\n        automator = address(new StETHAutomatorBase());\n    }\n\n    function createAutomator(\n        uint256 feeRate,\n        uint256 maxPeriod,\n        address collateral\n    ) external returns (address) {\n        require(credits[_msgSender()] > 0, \"AutomatorFactory: insufficient credits\");\n        credits[_msgSender()] -= 1;\n        bytes32 salt = keccak256(abi.encodePacked(_msgSender(), collateral));\n        address _automator = Clones.cloneDeterministic(automator, salt);\n        StETHAutomatorBase(_automator).initialize(_msgSender(), collateral, feeRate, maxPeriod);\n        require(getAutomator[_msgSender()][collateral] == address(0), \"AutomatorFactory: automator already exists\");\n        getAutomator[_msgSender()][collateral] = _automator;\n        automators.push(_automator);\n        emit AutomatorCreated(_msgSender(), collateral, _automator, feeRate, maxPeriod);\n        return _automator;\n    }\n\n    function automatorsLength() external view returns (uint256) {\n        return automators.length;\n    }\n\n    function setReferral(address referral_) external onlyOwner {\n        require(referral_ != address(0), \"AutomatorFactory: referral is the zero address\");\n        emit ReferralSet(referral, referral_);\n        referral = referral_;\n    }\n\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        require(feeCollector_ != address(0), \"AutomatorFactory: feeCollector is the zero address\");\n        emit FeeCollectorSet(feeCollector, feeCollector_);\n        feeCollector = feeCollector_;\n    }\n\n    function topUp(address user, uint256 amount) external onlyOwner {\n        credits[user] += amount;\n        emit CreditsTopUp(user, amount);\n    }\n\n    function enableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = true;\n        }\n        emit VaultsEnabled(vaults_);\n    }\n\n    function disableVaults(address[] calldata vaults_) external onlyOwner {\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            vaults[vaults_[i]] = false;\n        }\n        emit VaultsDisabled(vaults_);\n    }\n\n    function enableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = true;\n        }\n        emit MakersEnabled(makers_);\n    }\n\n    function disableMakers(address[] calldata makers_) external onlyOwner {\n        for (uint256 i = 0; i < makers_.length; i++) {\n            makers[makers_[i]] = false;\n        }\n        emit MakersDisabled(makers_);\n    }\n}\n"
    }
}