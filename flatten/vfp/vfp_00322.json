{
    "vfp_id": "vfp_00322",
    "project_name": "Taiko Shasta Protocol Audit.md",
    "findings": [
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Default Fail-Open Configuration for SGX Enclave Attestation",
            "description": "The `SgxVerifier` contract relies on `AutomataDcapV3Attestation` for verifying SGX enclaves, but the `checkLocalEnclaveReport` flag is set to `false` by default. This disables critical validation of the enclave's `MRENCLAVE` and `MRSIGNER` measurements, allowing any enclave with a valid Intel quote to be registered, regardless of the software it runs.\n\nThe root cause is a fail-open default configuration, which contradicts the principle of secure-by-default design. While the system assumes an honest owner will enable the check, an oversight or misconfiguration could leave the system vulnerable to malicious enclaves running unauthorized code.\n\nThe impact is a potential compromise of the proof-of-validity mechanism, as an attacker could register a rogue verifier enclave and submit invalid proofs. This undermines the security foundation of the entire protocol, especially if the owner fails to manually enable the check during deployment.\n",
            "severity": "High",
            "location": [
                "SgxVerifier.sol::",
                "AutomataDcapV3Attestation.sol::checkLocalEnclaveReport#37"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/verifiers/SgxVerifier.sol"
            ]
        }
    ],
    "affected_files": {
        "SgxVerifier.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IProofVerifier } from \"./IProofVerifier.sol\";\nimport { LibPublicInput } from \"./LibPublicInput.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { IAttestation } from \"src/layer1/automata-attestation/interfaces/IAttestation.sol\";\nimport { V3Struct } from \"src/layer1/automata-attestation/lib/QuoteV3Auth/V3Struct.sol\";\n\n/// @title SgxVerifier\n/// @notice This contract verifies SGX signature proofs onchain using attested SGX instances.\n/// Each instance is registered via remote attestation and can verify proofs until expiry.\n/// @dev Side-channel protection is achieved through mandatory instance expiry (INSTANCE_EXPIRY),\n/// requiring periodic re-attestation with new keypairs.\n/// @custom:security-contact security@taiko.xyz\ncontract SgxVerifier is IProofVerifier, Ownable2Step {\n    /// @dev Each public-private key pair (Ethereum address) is generated within\n    /// the SGX program when it boots up. The off-chain remote attestation\n    /// ensures the validity of the program hash and has the capability of\n    /// bootstrapping the network with trustworthy instances.\n    struct Instance {\n        address addr;\n        uint64 validSince;\n    }\n\n    /// @notice The expiry time for the SGX instance.\n    uint64 public constant INSTANCE_EXPIRY = 365 days;\n\n    /// @notice A security feature, a delay until an instance is enabled when using onchain RA\n    /// verification\n    uint64 public constant INSTANCE_VALIDITY_DELAY = 0;\n\n    uint64 public immutable taikoChainId;\n    address public immutable automataDcapAttestation;\n\n    /// @dev For gas savings, we assign each SGX instance with an ID to minimize storage operations.\n    /// Slot 1.\n    uint256 public nextInstanceId;\n\n    /// @dev One SGX instance is uniquely identified (on-chain) by its ECDSA public key\n    /// (or rather ethereum address). The instance address remains valid for INSTANCE_EXPIRY\n    /// duration (365 days) to protect against side-channel attacks through forced key expiry.\n    /// After expiry, the instance must be re-attested and registered with a new address.\n    /// Slot 2.\n    mapping(uint256 instanceId => Instance instance) public instances;\n\n    /// @dev One address shall be registered (during attestation) only once, otherwise it could\n    /// bypass this contract's expiry check by always registering with the same attestation and\n    /// getting multiple valid instanceIds.\n    /// Slot 3.\n    mapping(address instanceAddress => bool alreadyAttested) public addressRegistered;\n\n    uint256[47] private __gap;\n\n    /// @notice Emitted when a new SGX instance is added to the registry.\n    /// @param id The ID of the SGX instance.\n    /// @param instance The address of the SGX instance.\n    /// @param replaced Reserved for future use (always zero address).\n    /// @param validSince The time since the instance is valid.\n    event InstanceAdded(\n        uint256 indexed id, address indexed instance, address indexed replaced, uint256 validSince\n    );\n\n    /// @notice Emitted when an SGX instance is deleted from the registry.\n    /// @param id The ID of the SGX instance.\n    /// @param instance The address of the SGX instance.\n    event InstanceDeleted(uint256 indexed id, address indexed instance);\n\n    error SGX_ALREADY_ATTESTED();\n    error SGX_INVALID_ATTESTATION();\n    error SGX_INVALID_INSTANCE();\n    error SGX_INVALID_PROOF();\n\n    constructor(uint64 _taikoChainId, address _owner, address _automataDcapAttestation) {\n        require(_taikoChainId != 0, \"Invalid chain id\");\n        taikoChainId = _taikoChainId;\n        automataDcapAttestation = _automataDcapAttestation;\n\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Adds trusted SGX instances to the registry.\n    /// @param _instances The address array of trusted SGX instances.\n    /// @return The respective instanceId array per addresses.\n    function addInstances(address[] calldata _instances)\n        external\n        onlyOwner\n        returns (uint256[] memory)\n    {\n        return _addInstances(_instances, true);\n    }\n\n    /// @notice Deletes SGX instances from the registry.\n    /// @param _ids The ids array of SGX instances.\n    function deleteInstances(uint256[] calldata _ids) external onlyOwner {\n        uint256 size = _ids.length;\n        for (uint256 i; i < size; ++i) {\n            uint256 idx = _ids[i];\n\n            require(instances[idx].addr != address(0), SGX_INVALID_INSTANCE());\n\n            emit InstanceDeleted(idx, instances[idx].addr);\n\n            delete instances[idx];\n        }\n    }\n\n    /// @notice Adds an SGX instance after the attestation is verified\n    /// @param _attestation The parsed attestation quote.\n    /// @return The respective instanceId\n    function registerInstance(V3Struct.ParsedV3QuoteStruct calldata _attestation)\n        external\n        returns (uint256)\n    {\n        (bool verified,) = IAttestation(automataDcapAttestation).verifyParsedQuote(_attestation);\n        require(verified, SGX_INVALID_ATTESTATION());\n\n        address[] memory addresses = new address[](1);\n        addresses[0] = address(bytes20(_attestation.localEnclaveReport.reportData));\n\n        return _addInstances(addresses, false)[0];\n    }\n\n    /// @inheritdoc IProofVerifier\n    function verifyProof(\n        uint256, /* _proposalAge */\n        bytes32 _aggregatedProvingHash,\n        bytes calldata _proof\n    )\n        external\n        view\n    {\n        require(_proof.length == 89, SGX_INVALID_PROOF());\n\n        uint32 id = uint32(bytes4(_proof[:4]));\n        address instance = address(bytes20(_proof[4:24]));\n        require(_isInstanceValid(id, instance), SGX_INVALID_INSTANCE());\n\n        bytes32 signatureHash = LibPublicInput.hashPublicInputs(\n            _aggregatedProvingHash, address(this), instance, taikoChainId\n        );\n\n        // Verify the signature was created by the registered instance\n        bytes memory signature = _proof[24:];\n        require(instance == ECDSA.recover(signatureHash, signature), SGX_INVALID_PROOF());\n    }\n\n    function _addInstances(\n        address[] memory _instances,\n        bool instantValid\n    )\n        private\n        returns (uint256[] memory ids)\n    {\n        uint256 size = _instances.length;\n        ids = new uint256[](size);\n\n        uint64 validSince = uint64(block.timestamp);\n\n        if (!instantValid) {\n            validSince += INSTANCE_VALIDITY_DELAY;\n        }\n\n        for (uint256 i; i < size; ++i) {\n            require(!addressRegistered[_instances[i]], SGX_ALREADY_ATTESTED());\n\n            addressRegistered[_instances[i]] = true;\n\n            require(_instances[i] != address(0), SGX_INVALID_INSTANCE());\n\n            instances[nextInstanceId] = Instance(_instances[i], validSince);\n            ids[i] = nextInstanceId;\n\n            emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince);\n\n            ++nextInstanceId;\n        }\n    }\n\n    function _isInstanceValid(uint256 id, address instance) private view returns (bool) {\n        require(instance != address(0), SGX_INVALID_INSTANCE());\n        require(instance == instances[id].addr, SGX_INVALID_INSTANCE());\n        return instances[id].validSince <= block.timestamp\n            && block.timestamp <= instances[id].validSince + INSTANCE_EXPIRY;\n    }\n}\n"
    }
}