{
    "vfp_id": "vfp_00130",
    "project_name": "cantina_euler_swap_april2025.pdf",
    "findings": [
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "UniswapHook._beforeInitialize() is never reached during normal initialization",
            "description": "The _beforeInitialize function in UniswapHook is intended to prevent re-initialization by checking _poolKey.tickSpacing == 0, but it is never called due to the noSelfCall modifier in Uniswap V4. The hook is activated before initialization, so the check is ineffective. The root cause is a misunderstanding of the hook call flow. This leads to dead code and incorrect assumptions about initialization safety. The impact is informational, as the functionality works as intended via other mechanisms, but the code is misleading.\n",
            "severity": "Informational",
            "location": [
                "UniswapHook.sol#L129-L136",
                "Hooks.sol#L170-L175"
            ],
            "files": [
                "euler-swap/src/UniswapHook.sol"
            ]
        }
    ],
    "affected_files": {
        "UniswapHook.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {BaseHook} from \"v4-periphery/src/utils/BaseHook.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\nimport {\n    BeforeSwapDelta, toBeforeSwapDelta, BeforeSwapDeltaLibrary\n} from \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\n\nimport {IEVault} from \"evk/EVault/IEVault.sol\";\n\nimport {IEulerSwap} from \"./interfaces/IEulerSwap.sol\";\nimport {CtxLib} from \"./libraries/CtxLib.sol\";\nimport {QuoteLib} from \"./libraries/QuoteLib.sol\";\nimport {CurveLib} from \"./libraries/CurveLib.sol\";\nimport {FundsLib} from \"./libraries/FundsLib.sol\";\n\ncontract UniswapHook is BaseHook {\n    using SafeCast for uint256;\n\n    address private immutable evc;\n\n    PoolKey internal _poolKey;\n\n    error AlreadyInitialized();\n    error NativeConcentratedLiquidityUnsupported();\n\n    constructor(address evc_, address _poolManager) BaseHook(IPoolManager(_poolManager)) {\n        evc = evc_;\n    }\n\n    function activateHook(IEulerSwap.Params memory p) internal {\n        Hooks.validateHookPermissions(this, getHookPermissions());\n\n        address asset0Addr = IEVault(p.vault0).asset();\n        address asset1Addr = IEVault(p.vault1).asset();\n\n        // convert fee in WAD to pips. 0.003e18 / 1e12 = 3000 = 0.30%\n        uint24 fee = uint24(p.fee / 1e12);\n\n        _poolKey = PoolKey({\n            currency0: Currency.wrap(asset0Addr),\n            currency1: Currency.wrap(asset1Addr),\n            fee: fee,\n            tickSpacing: 1, // hard-coded tick spacing, as its unused\n            hooks: IHooks(address(this))\n        });\n\n        // create the pool on v4, using starting price as sqrtPrice(1/1) * Q96\n        poolManager.initialize(_poolKey, 79228162514264337593543950336);\n    }\n\n    /// @dev Helper function to return the poolKey as its struct type\n    function poolKey() external view returns (PoolKey memory) {\n        return _poolKey;\n    }\n\n    /// @dev Prevent hook address validation in constructor, which is not needed\n    /// because hook instances are proxies. Instead, the address is validated\n    /// in activateHook().\n    function validateHookAddress(BaseHook _this) internal pure override {}\n\n    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)\n        internal\n        override\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        IEulerSwap.Params memory p = CtxLib.getParams();\n\n        uint256 amountInWithoutFee;\n        uint256 amountOut;\n        BeforeSwapDelta returnDelta;\n\n        {\n            uint256 amountIn;\n            bool isExactInput = params.amountSpecified < 0;\n            if (isExactInput) {\n                amountIn = uint256(-params.amountSpecified);\n                amountOut = QuoteLib.computeQuote(evc, p, params.zeroForOne, uint256(-params.amountSpecified), true);\n            } else {\n                amountIn = QuoteLib.computeQuote(evc, p, params.zeroForOne, uint256(params.amountSpecified), false);\n                amountOut = uint256(params.amountSpecified);\n            }\n\n            // return the delta to the PoolManager, so it can process the accounting\n            // exact input:\n            //   specifiedDelta = positive, to offset the input token taken by the hook (negative delta)\n            //   unspecifiedDelta = negative, to offset the credit of the output token paid by the hook (positive delta)\n            // exact output:\n            //   specifiedDelta = negative, to offset the output token paid by the hook (positive delta)\n            //   unspecifiedDelta = positive, to offset the input token taken by the hook (negative delta)\n            returnDelta = isExactInput\n                ? toBeforeSwapDelta(amountIn.toInt128(), -(amountOut.toInt128()))\n                : toBeforeSwapDelta(-(amountOut.toInt128()), amountIn.toInt128());\n\n            // take the input token, from the PoolManager to the Euler vault\n            // the debt will be paid by the swapper via the swap router\n            poolManager.take(params.zeroForOne ? key.currency0 : key.currency1, address(this), amountIn);\n            amountInWithoutFee = FundsLib.depositAssets(evc, p, params.zeroForOne ? p.vault0 : p.vault1);\n\n            // pay the output token, to the PoolManager from an Euler vault\n            // the credit will be forwarded to the swap router, which then forwards it to the swapper\n            poolManager.sync(params.zeroForOne ? key.currency1 : key.currency0);\n            FundsLib.withdrawAssets(evc, p, params.zeroForOne ? p.vault1 : p.vault0, amountOut, address(poolManager));\n            poolManager.settle();\n        }\n\n        {\n            CtxLib.Storage storage s = CtxLib.getStorage();\n\n            uint256 newReserve0 = params.zeroForOne ? (s.reserve0 + amountInWithoutFee) : (s.reserve0 - amountOut);\n            uint256 newReserve1 = !params.zeroForOne ? (s.reserve1 + amountInWithoutFee) : (s.reserve1 - amountOut);\n\n            require(newReserve0 <= type(uint112).max && newReserve1 <= type(uint112).max, CurveLib.Overflow());\n            require(CurveLib.verify(p, newReserve0, newReserve1), CurveLib.CurveViolation());\n\n            s.reserve0 = uint112(newReserve0);\n            s.reserve1 = uint112(newReserve1);\n        }\n\n        return (BaseHook.beforeSwap.selector, returnDelta, 0);\n    }\n\n    /// @dev Each deployed hook only services one pair and prevent subsequent initializations\n    function _beforeInitialize(address, PoolKey calldata, uint160) internal view override returns (bytes4) {\n        // when the hook is deployed for the first time, the internal _poolKey is empty\n        // upon activation, the internal _poolKey is initialized and set\n        // once the hook contract is activated, do not allow subsequent initializations\n        require(_poolKey.tickSpacing == 0, AlreadyInitialized());\n        return BaseHook.beforeInitialize.selector;\n    }\n\n    function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        pure\n        override\n        returns (bytes4)\n    {\n        revert NativeConcentratedLiquidityUnsupported();\n    }\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: true,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n"
    }
}