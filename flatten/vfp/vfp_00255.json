{
    "vfp_id": "vfp_00255",
    "project_name": "ChainSecurity_StudioV_Neulock_Audit.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Getter for Number of Entitlement Contracts",
            "description": "The NeuEntitlementV2 contract provides entitlementContractsV2() to access contracts by index but lacks a function to query the total number of entitlement contracts. This forces callers to iterate until the function reverts, which is inefficient and error-prone.\n\nThe cause is the absence of a length getter, a common pattern in array-based data structures.\n\nOff-chain applications must use inefficient trial-and-error methods to determine the size of the list.\n\nThe impact is increased gas costs and complexity for external systems interacting with the contract.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/current/EntitlementV2.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "NEU Contract Is Not Necessarily the First Entitlement Contract",
            "description": "The initializeV2() function in NeuEntitlementV2 assumes the first entitlement contract is the NEU token, but this is not enforced. If the NEU contract was removed before initialization, a different contract could be assigned to _neuContract, leading to incorrect behavior.\n\nThe cause is a reliance on implicit ordering without validation.\n\nA compromised or mistaken operator could manipulate the order, causing the system to treat a non-NEU contract as the primary entitlement.\n\nThe impact is potential misconfiguration and incorrect access control decisions.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV2.sol::initializeV2"
            ],
            "files": [
                "neulock-onchain/contracts/current/EntitlementV2.sol"
            ]
        }
    ],
    "affected_files": {
        "EntitlementV2.sol": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {INeuEntitlementV2} from \"../interfaces/IEntitlementV2.sol\";\nimport {INeuTokenV3} from \"../interfaces/INeuV3.sol\";\n\n/**\n * @title NeuEntitlementV2\n * @author Lucas Neves (lneves.eth) for Studio V\n * @notice Manages entitlement contracts and checks user entitlements for Neulock.\n * @dev Upgradeable contract using OpenZeppelin's UUPS pattern. Handles entitlement contracts and integrates with NeuTokenV3.\n * @custom:security-contact security@studiov.tech\n */\ncontract NeuEntitlementV2 is\n    Initializable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable,\n    INeuEntitlementV2\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    uint256 private constant _VERSION = 2;\n\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    address[] private entitlementContracts; // Deprecated in V2\n    EnumerableSet.AddressSet private _entitlementContracts;\n    INeuTokenV3 private _neuContract;\n\n    /**\n     * @notice Disables initializers to prevent implementation contract from being initialized.\n     * @dev This constructor is only used to disable initializers for the implementation contract.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with admin, upgrader, operator, and Neu contract addresses.\n     * @dev Grants roles and adds the initial Neu contract as an entitlement contract.\n     * @param defaultAdmin The address to be granted DEFAULT_ADMIN_ROLE.\n     * @param upgrader The address to be granted UPGRADER_ROLE.\n     * @param operator The address to be granted OPERATOR_ROLE.\n     * @param neuContract The address of the NeuTokenV3 contract.\n     *\n     * Emits {EntitlementContractAdded} and {InitializedEntitlement} events.\n     */\n    function initialize(\n        address defaultAdmin,\n        address upgrader,\n        address operator,\n        address neuContract\n    ) public initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(UPGRADER_ROLE, upgrader);\n        _grantRole(OPERATOR_ROLE, operator);\n\n        entitlementContracts.push(neuContract);\n\n        emit EntitlementContractAdded(neuContract);\n        emit InitializedEntitlement(_VERSION, defaultAdmin, upgrader, operator, neuContract);\n    }\n\n    /**\n     * @notice Upgrades contract state to V2, migrating entitlement contracts to the new storage structure and setting the NEU contract.\n     * @dev Only callable by addresses with UPGRADER_ROLE. Should be called after upgrading to V2.\n     * @param neuContract The address of the NeuTokenV3 contract.\n     *\n     * Emits {InitializedEntitlementV2} event.\n     */\n    function initializeV2(address neuContract) public reinitializer(2) onlyRole(UPGRADER_ROLE) {\n        uint256 existingContractsLength = entitlementContracts.length;\n\n        _neuContract = INeuTokenV3(neuContract);\n\n        for (uint256 i = 0; i < existingContractsLength; i++) {\n            if (entitlementContracts[i] != neuContract) {\n                // slither-disable-next-line unused-return (we only care about the side effect)\n                _entitlementContracts.add(entitlementContracts[i]);\n            }\n        }\n\n        emit InitializedEntitlementV2(neuContract);\n    }\n\n    /**\n     * @notice Returns the address of an entitlement contract by index.\n     * @dev Index 0 returns the NeuTokenV3 contract, subsequent indices return other entitlement contracts.\n     * @param index The index of the entitlement contract.\n     * @return The address of the entitlement contract at the given index.\n     */\n    function entitlementContractsV2(uint256 index) external view returns (address) {\n        if (index == 0) {\n            return address(_neuContract);\n        }\n\n        return _entitlementContracts.at(index - 1);\n    }\n\n    /**\n     * @notice Returns the number of entitlement contracts.\n     * @dev Includes the NeuTokenV3 contract.\n     * @return The number of entitlement contracts.\n     */\n    function entitlementContractsLength() external view returns (uint256) {\n        return _entitlementContracts.length() + 1;\n    }\n\n    /**\n     * @notice Adds a new entitlement contract.\n     * @dev Only callable by addresses with OPERATOR_ROLE. The contract must implement balanceOf().\n     * @param entitlementContract The address of the entitlement contract to add.\n     *\n     * Emits {EntitlementContractAdded} event.\n     *\n     * Requirements:\n     * - The contract must not be the NEU contract.\n     * - The contract must not already be added.\n     * - The contract must support balanceOf().\n     */\n    function addEntitlementContract(address entitlementContract) external onlyRole(OPERATOR_ROLE) override {\n        require(entitlementContract != address(_neuContract), \"Cannot add NEU contract\");\n        require(_entitlementContracts.add(entitlementContract), \"Entitlement contract already added\");\n\n        // We won't check for the IERC721 interface, since any token that supports balanceOf() can be used\n        // slither-disable-next-line unused-return (we don't need the return value, only to check if the function exists)\n        try IERC721(entitlementContract).balanceOf(address(this)) {} catch {\n            revert(\"Contract does not support balanceOf()\");\n        }\n\n        emit EntitlementContractAdded(entitlementContract);\n    }\n\n    /**\n     * @notice Removes an entitlement contract.\n     * @dev Only callable by addresses with OPERATOR_ROLE.\n     * @param entitlementContract The address of the entitlement contract to remove.\n     *\n     * Emits {EntitlementContractRemoved} event.\n     *\n     * Requirements:\n     * - The contract must be present in the entitlement set.\n     */\n    function removeEntitlementContract(address entitlementContract) external onlyRole(OPERATOR_ROLE) override {\n        require(_entitlementContracts.remove(entitlementContract), \"Entitlement contract not found\");\n\n        emit EntitlementContractRemoved(entitlementContract);\n    }\n\n    /**\n     * @notice Checks if a user has entitlement via any registered contract.\n     * @dev Checks both NeuTokenV3 and all added entitlement contracts.\n     * @param user The address of the user to check entitlement for.\n     * @return True if the user has entitlement, false otherwise.\n     */\n    function hasEntitlement(address user) external view override returns (bool) {\n        if (_callerHasNeuEntitlement(user)) {\n            return true;\n        }\n\n        uint256 contractsLength = _entitlementContracts.length();\n\n        for (uint256 i = 0; i < contractsLength; i++) {\n            if (_callerHasContractEntitlement(user, _entitlementContracts.at(i))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Checks if a user has entitlement with a specific contract.\n     * @dev Checks entitlement for either NeuTokenV3 or a specified entitlement contract.\n     * @param user The address of the user to check entitlement for.\n     * @param entitlementContract The address of the entitlement contract to check.\n     * @return True if the user has entitlement with the specified contract, false otherwise.\n     */\n    function hasEntitlementWithContract(address user, address entitlementContract) external view override returns (bool) {\n        if (entitlementContract == address(_neuContract)) {\n            return _callerHasNeuEntitlement(user);\n        }\n\n        if (_entitlementContracts.contains(entitlementContract)) {\n            return _callerHasContractEntitlement(user, entitlementContract);\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Returns the list of entitlement contracts where the user has entitlement.\n     * @dev Checks NeuTokenV3 and all added entitlement contracts for user entitlement.\n     * @param user The address of the user to check entitlement for.\n     * @return An array of addresses of entitlement contracts where the user has entitlement.\n     */\n    function userEntitlementContracts(address user) external view override returns (address[] memory) {\n        uint256 contractsLength = _entitlementContracts.length();\n\n        address[] memory userEntitlements = new address[](contractsLength + 1);\n        uint256 count = 0;\n\n        if (_callerHasNeuEntitlement(user)) {\n            userEntitlements[0] = address(_neuContract);\n            count++;\n        }\n\n        for (uint256 i = 0; i < contractsLength; i++) {\n            address entitlementContract = _entitlementContracts.at(i);\n\n            if (_callerHasContractEntitlement(user, entitlementContract)) {\n                userEntitlements[count] = entitlementContract;\n                count++;\n            }\n        }\n\n        assembly {\n            mstore(userEntitlements, count)\n        }\n\n        return userEntitlements;\n    }\n\n    function _callerHasContractEntitlement(address user, address contractAddress) private view returns (bool) {\n        // slither-disable-next-line calls-loop (will only revert if contract has been upgraded and doesn't support balanceOf(); in this case, we don't want to fail silently)\n        return IERC721(contractAddress).balanceOf(user) > 0;\n    }\n\n    function _callerHasNeuEntitlement(address user) private view returns (bool) {\n        uint256 userNeuBalance = _neuContract.balanceOf(user);\n\n        for (uint256 i = 0; i < userNeuBalance; i++) {\n            uint256 tokenId = _neuContract.tokenOfOwnerByIndex(user, i);\n\n            // slither-disable-next-line block-timestamp (with a granularity of days for the entitlement cooldown, we can tolerate miner manipulation)\n            if (block.timestamp >= _neuContract.entitlementAfterTimestamps(tokenId)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Authorizes contract upgrades.\n     * @dev Only addresses with UPGRADER_ROLE can upgrade the contract. Required by UUPS pattern.\n     * @param newImplementation The address of the new contract implementation.\n     */\n    function _authorizeUpgrade(address newImplementation) internal onlyRole(UPGRADER_ROLE) override {}\n}\n"
    }
}