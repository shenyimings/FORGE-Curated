{
    "vfp_id": "vfp_00618",
    "project_name": "f(x) v2 Audit.md",
    "findings": [
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unused Code in _getTick",
            "description": "1.  **Description:** The `_getTick` function in `TickLogic.sol` computes a ratio value that is never used in subsequent logic.\n2.  **Cause:** A line of code was left in the function that performs a calculation but does not utilize the result, likely due to refactoring or oversight.\n3.  **Exploitation:** This issue cannot be exploited by an attacker as it does not affect functionality or security.\n4.  **Impact:** The impact is minimal, limited to slight gas inefficiency and reduced code clarity. It does not pose a security risk.\n",
            "severity": "Low",
            "location": [
                "TickLogic.sol::_getTick#114"
            ],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/TickLogic.sol"
            ]
        },
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Critical Issue in Tick and Node Logic",
            "description": "1.  **Description:** A critical-severity issue was identified involving manipulation of tick and node logic that could block the operate functionality of the protocol.\n2.  **Cause:** The root cause is not fully detailed in this chunk but appears to stem from improper validation or state management in the tick/node system.\n3.  **Exploitation:** An attacker could potentially manipulate the tick or node state to prevent certain operations from executing.\n4.  **Impact:** The impact is described as critical, suggesting a complete blockage of core functionality, possibly leading to denial of service for key features.\n",
            "severity": "Critical",
            "location": [],
            "files": [
                "fx-protocol-contracts/contracts/core/pool/TickLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "TickLogic.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport { WordCodec } from \"../../common/codec/WordCodec.sol\";\nimport { TickBitmap } from \"../../libraries/TickBitmap.sol\";\nimport { TickMath } from \"../../libraries/TickMath.sol\";\nimport { PoolStorage } from \"./PoolStorage.sol\";\n\nabstract contract TickLogic is PoolStorage {\n  using TickBitmap for mapping(int8 => uint256);\n  using WordCodec for bytes32;\n\n  /*************\n   * Constants *\n   *************/\n\n  /// @dev Below are offsets of each variables in `TickTreeNode.metadata`.\n  uint256 private constant PARENT_OFFSET = 0;\n  uint256 private constant TICK_OFFSET = 48;\n  uint256 private constant COLL_RATIO_OFFSET = 64;\n  uint256 private constant DEBT_RATIO_OFFSET = 128;\n\n  /// @dev Below are offsets of each variables in `TickTreeNode.value`.\n  uint256 internal constant COLL_SHARE_OFFSET = 0;\n  uint256 internal constant DEBT_SHARE_OFFSET = 128;\n\n  /***************\n   * Constructor *\n   ***************/\n\n  function __TickLogic_init() internal onlyInitializing {\n    _updateNextTreeNodeId(1);\n    _updateTopTick(type(int16).min);\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /// @dev Internal function to get the root of the given tree node.\n  /// @param node The id of the given tree node.\n  /// @return root The root node id.\n  /// @return collRatio The actual collateral ratio of the given node, multiplied by 2^60.\n  /// @return debtRatio The actual debt ratio of the given node, multiplied by 2^60.\n  function _getRootNode(uint256 node) internal view returns (uint256 root, uint256 collRatio, uint256 debtRatio) {\n    collRatio = E60;\n    debtRatio = E60;\n    while (true) {\n      bytes32 metadata = tickTreeData[node].metadata;\n      uint256 parent = metadata.decodeUint(PARENT_OFFSET, 48);\n      collRatio = (collRatio * metadata.decodeUint(COLL_RATIO_OFFSET, 64)) >> 60;\n      debtRatio = (debtRatio * metadata.decodeUint(DEBT_RATIO_OFFSET, 64)) >> 60;\n      if (parent == 0) break;\n      node = parent;\n    }\n    root = node;\n  }\n\n  /// @dev Internal function to get the root of the given tree node and compress path.\n  /// @param node The id of the given tree node.\n  /// @return root The root node id.\n  /// @return collRatio The actual collateral ratio of the given node, multiplied by 2^60.\n  /// @return debtRatio The actual debt ratio of the given node, multiplied by 2^60.\n  function _getRootNodeAndCompress(uint256 node) internal returns (uint256 root, uint256 collRatio, uint256 debtRatio) {\n    // @note We can change it to non-recursive version to avoid stack overflow. Normally, the depth should be `log(n)`,\n    // where `n` is the total number of tree nodes. So we don't need to worry much about this.\n    bytes32 metadata = tickTreeData[node].metadata;\n    uint256 parent = metadata.decodeUint(PARENT_OFFSET, 48);\n    collRatio = metadata.decodeUint(COLL_RATIO_OFFSET, 64);\n    debtRatio = metadata.decodeUint(DEBT_RATIO_OFFSET, 64);\n    if (parent == 0) {\n      root = node;\n    } else {\n      uint256 collRatioCompressed;\n      uint256 debtRatioCompressed;\n      (root, collRatioCompressed, debtRatioCompressed) = _getRootNodeAndCompress(parent);\n      collRatio = (collRatio * collRatioCompressed) >> 60;\n      debtRatio = (debtRatio * debtRatioCompressed) >> 60;\n      metadata = metadata.insertUint(root, PARENT_OFFSET, 48);\n      metadata = metadata.insertUint(collRatio, COLL_RATIO_OFFSET, 64);\n      metadata = metadata.insertUint(debtRatio, DEBT_RATIO_OFFSET, 64);\n      tickTreeData[node].metadata = metadata;\n    }\n  }\n\n  /// @dev Internal function to create a new tree node.\n  /// @param tick The tick where this tree node belongs to.\n  /// @return node The created tree node id.\n  function _newTickTreeNode(int16 tick) internal returns (uint48 node) {\n    unchecked {\n      node = _getNextTreeNodeId();\n      _updateNextTreeNodeId(node + 1);\n    }\n    tickData[tick] = node;\n\n    bytes32 metadata = bytes32(0);\n    metadata = metadata.insertInt(tick, TICK_OFFSET, 16); // set tick\n    metadata = metadata.insertUint(E60, COLL_RATIO_OFFSET, 64); // set coll ratio\n    metadata = metadata.insertUint(E60, DEBT_RATIO_OFFSET, 64); // set debt ratio\n    tickTreeData[node].metadata = metadata;\n  }\n\n  /// @dev Internal function to find first tick such that `TickMath.getRatioAtTick(tick) >= debts/colls`.\n  /// @param colls The collateral shares.\n  /// @param debts The debt shares.\n  /// @return tick The value of found first tick.\n  function _getTick(uint256 colls, uint256 debts) internal pure returns (int256 tick) {\n    uint256 ratio = (debts * TickMath.ZERO_TICK_SCALED_RATIO) / colls;\n    uint256 ratioAtTick;\n    (tick, ratioAtTick) = TickMath.getTickAtRatio(ratio);\n    if (ratio != ratioAtTick) {\n      tick++;\n      ratio = (ratioAtTick * 10015) / 10000;\n    }\n  }\n\n  /// @dev Internal function to retrieve or create a tree node.\n  /// @param tick The tick where this tree node belongs to.\n  /// @return node The tree node id.\n  function _getOrCreateTickNode(int256 tick) internal returns (uint48 node) {\n    node = tickData[tick];\n    if (node == 0) {\n      node = _newTickTreeNode(int16(tick));\n    }\n  }\n\n  /// @dev Internal function to add position collaterals and debts to some tick.\n  /// @param colls The collateral shares.\n  /// @param debts The debt shares.\n  /// @param checkDebts Whether we should check the value of `debts`.\n  /// @return tick The tick where this position belongs to.\n  /// @return node The corresponding tree node id for this tick.\n  function _addPositionToTick(\n    uint256 colls,\n    uint256 debts,\n    bool checkDebts\n  ) internal returns (int256 tick, uint48 node) {\n    if (debts > 0) {\n      if (checkDebts && int256(debts) < MIN_DEBT) {\n        revert ErrorDebtTooSmall();\n      }\n\n      tick = _getTick(colls, debts);\n      node = _getOrCreateTickNode(tick);\n      bytes32 value = tickTreeData[node].value;\n      uint256 newColls = value.decodeUint(COLL_SHARE_OFFSET, 128) + colls;\n      uint256 newDebts = value.decodeUint(DEBT_SHARE_OFFSET, 128) + debts;\n      value = value.insertUint(newColls, COLL_SHARE_OFFSET, 128);\n      value = value.insertUint(newDebts, DEBT_SHARE_OFFSET, 128);\n      tickTreeData[node].value = value;\n\n      if (newDebts == debts) {\n        tickBitmap.flipTick(int16(tick));\n      }\n\n      // update top tick\n      if (tick > _getTopTick()) {\n        _updateTopTick(int16(tick));\n      }\n    }\n  }\n\n  /// @dev Internal function to remove position from tick.\n  /// @param position The position struct to remove.\n  function _removePositionFromTick(PositionInfo memory position) internal {\n    if (position.nodeId == 0) return;\n\n    bytes32 value = tickTreeData[position.nodeId].value;\n    uint256 oldDebts = value.decodeUint(DEBT_SHARE_OFFSET, 128);\n    uint256 newColls = value.decodeUint(COLL_SHARE_OFFSET, 128) - position.colls;\n    uint256 newDebts = oldDebts - position.debts;\n    value = value.insertUint(newColls, COLL_SHARE_OFFSET, 128);\n    value = value.insertUint(newDebts, DEBT_SHARE_OFFSET, 128);\n    tickTreeData[position.nodeId].value = value;\n\n    if (newDebts == 0 && oldDebts > 0) {\n      int16 tick = int16(tickTreeData[position.nodeId].metadata.decodeInt(TICK_OFFSET, 16));\n      tickBitmap.flipTick(tick);\n\n      // top tick gone, update it to new one\n      int16 topTick = _getTopTick();\n      if (topTick == tick) {\n        _resetTopTick(topTick);\n      }\n    }\n  }\n\n  /// @dev Internal function to liquidate a tick.\n  ///      The caller make sure `max(liquidatedColl, liquidatedDebt) > 0`.\n  ///\n  /// @param tick The id of tick to liquidate.\n  /// @param liquidatedColl The amount of collateral shares liquidated.\n  /// @param liquidatedDebt The amount of debt shares liquidated.\n  function _liquidateTick(int16 tick, uint256 liquidatedColl, uint256 liquidatedDebt, uint256 price) internal {\n    uint48 node = tickData[tick];\n    // create new tree node for this tick\n    _newTickTreeNode(tick);\n    // clear bitmap first, and it will be updated later if needed.\n    tickBitmap.flipTick(tick);\n\n    bytes32 value = tickTreeData[node].value;\n    bytes32 metadata = tickTreeData[node].metadata;\n    uint256 tickColl = value.decodeUint(COLL_SHARE_OFFSET, 128);\n    uint256 tickDebt = value.decodeUint(DEBT_SHARE_OFFSET, 128);\n    uint256 tickCollAfter = tickColl - liquidatedColl;\n    uint256 tickDebtAfter = tickDebt - liquidatedDebt;\n    uint256 collRatio = (tickCollAfter * E60) / tickColl;\n    uint256 debtRatio = (tickDebtAfter * E60) / tickDebt;\n\n    // update metadata\n    metadata = metadata.insertUint(collRatio, COLL_RATIO_OFFSET, 64);\n    metadata = metadata.insertUint(debtRatio, DEBT_RATIO_OFFSET, 64);\n\n    int256 newTick = type(int256).min;\n    if (tickDebtAfter > 0) {\n      // partial liquidated, move funds to another tick\n      uint48 parentNode;\n      (newTick, parentNode) = _addPositionToTick(tickCollAfter, tickDebtAfter, false);\n      metadata = metadata.insertUint(parentNode, PARENT_OFFSET, 48);\n    }\n    if (newTick == type(int256).min) {\n      emit TickMovement(tick, type(int16).min, tickCollAfter, tickDebtAfter, price);\n    } else {\n      emit TickMovement(tick, int16(newTick), tickCollAfter, tickDebtAfter, price);\n    }\n\n    // top tick liquidated, update it to new one\n    int16 topTick = _getTopTick();\n    if (topTick == tick && newTick != int256(tick)) {\n      _resetTopTick(topTick);\n    }\n    tickTreeData[node].metadata = metadata;\n  }\n\n  /// @dev Internal function to reset top tick.\n  /// @param oldTopTick The previous value of top tick.\n  function _resetTopTick(int16 oldTopTick) internal {\n    while (oldTopTick > type(int16).min) {\n      bool hasDebt;\n      (oldTopTick, hasDebt) = tickBitmap.nextDebtPositionWithinOneWord(oldTopTick - 1);\n      if (hasDebt) break;\n    }\n    _updateTopTick(oldTopTick);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private __gap;\n}\n"
    }
}