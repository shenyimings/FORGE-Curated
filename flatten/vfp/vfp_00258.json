{
    "vfp_id": "vfp_00258",
    "project_name": "Frax0 Mesh - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "Incorrect proxy contract addresses",
            "description": "The UpgradeAdapterEthereum.s.sol script uses Fraxtal-specific proxy addresses (e.g., fraxtalFrxUsdLockbox) when upgrading contracts on Ethereum, where those addresses do not have deployed contracts. This error occurs in the upgradeExistingLockboxes function, which passes incorrect addresses to the upgrade function. When executed, the script will fail because the proxy admin cannot interact with a non-existent contract, halting the upgrade process. This prevents successful deployment of new implementations and could delay critical updates or security fixes.\n",
            "severity": "Informational",
            "location": [
                "UpgradeAdapterEthereum.s.sol::upgradeExistingLockboxes",
                "UpgradeAdapterEthereum.s.sol::upgradeExistingLockbox"
            ],
            "files": [
                "b8d76da3a2bb5ff1fc557c194f8fe6496873959d/frax-oft-upgradeable/scripts/ops/V110/ethereum/UpgradeAdapterEthereum.s.sol"
            ]
        }
    ],
    "affected_files": {
        "UpgradeAdapterEthereum.s.sol": "pragma solidity ^0.8.0;\n\nimport \"scripts/DeployFraxOFTProtocol/DeployFraxOFTProtocol.s.sol\";\nimport { FraxOFTMintableAdapterUpgradeable } from \"contracts/FraxOFTMintableAdapterUpgradeable.sol\";\nimport { ERC1967Utils } from \"@openzeppelin-5/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n\ninterface IERC20PermitPermissionedOptiMintable {\n    function addMinter(address) external;\n}\n\n// forge script scripts/ops/V110/ethereum/UpgradeAdapterEthereum.s.sol --rpc-url https://eth-mainnet.public.blastapi.io\ncontract UpgradeAdapter is DeployFraxOFTProtocol {\n    \n    address frxUsd = 0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29;\n    address sfrxUsd = 0xcf62F905562626CfcDD2261162a51fd02Fc9c5b6;\n\n    address frxUsdMintableLockboxImp;\n    address sfrxUsdMintableLockboxImp;\n\n    modifier prankAndWriteTxs(address who) {\n        vm.startPrank(who);\n        _;\n        vm.stopPrank();\n\n        new SafeTxUtil().writeTxs(serializedTxs, filename());\n        delete serializedTxs;\n    }\n\n    function filename() public view override returns (string memory) {\n        string memory root = vm.projectRoot();\n        root = string.concat(root, \"/scripts/ops/V110/ethereum/txs/UpgradeAdapter\");\n\n        return string.concat(root, \"-comptroller.json\");\n    }\n\n    function run() public override {\n        deployMintableLockboxes();\n        generateComptrollerTxs();\n    }\n\n    function generateComptrollerTxs() public prankAndWriteTxs(broadcastConfig.delegate) {\n        addMinterRoles();\n        upgradeExistingLockboxes();\n    }\n\n    function addMinterRoles() public {\n        addMinterRole(frxUsd, ethFrxUsdLockbox);\n        addMinterRole(sfrxUsd, ethSFrxUsdLockbox);\n    }\n\n    function addMinterRole(address _token, address _lockbox) public {\n        bytes memory data = abi.encodeCall(\n            IERC20PermitPermissionedOptiMintable.addMinter,\n            (_lockbox)\n        );\n        (bool success, ) = _token.call(data);\n        require(success, \"Add minter role failed\");\n        serializedTxs.push(\n            SerializedTx({\n                name: \"Add minter role\",\n                to: _token,\n                value: 0,\n                data: data\n            })\n        );\n    }\n\n    /// @dev to prevent the script from reverting due to inherited validation\n    function _validateAndPopulateMainnetOfts() internal override {}\n\n    function deployMintableLockboxes() broadcastAs(senderDeployerPK) public {\n        frxUsdMintableLockboxImp = deployMintableLockbox(frxUsd);\n        sfrxUsdMintableLockboxImp = deployMintableLockbox(sfrxUsd);\n    }\n\n    function deployMintableLockbox(address _token) public returns (address) {\n        return address(\n            new FraxOFTMintableAdapterUpgradeable(\n                _token,\n                broadcastConfig.endpoint\n            )\n        );\n    }\n\n    function upgradeExistingLockboxes() public {\n        upgradeExistingLockbox(fraxtalFrxUsdLockbox, frxUsdMintableLockboxImp);\n        upgradeExistingLockbox(fraxtalSFrxUsdLockbox, sfrxUsdMintableLockboxImp);\n    }\n\n    function upgradeExistingLockbox(\n        address _lockbox,\n        address _implementation\n    ) public {\n        bytes memory data = abi.encodeCall(\n            ProxyAdmin.upgrade,\n            (\n                TransparentUpgradeableProxy(payable(_lockbox)),\n                _implementation\n            )\n        );\n\n        bytes32 adminSlot = vm.load(_lockbox, ERC1967Utils.ADMIN_SLOT);\n        proxyAdmin = address(uint160(uint256(adminSlot)));\n        (bool success, ) = proxyAdmin.call(data);\n        require(success, \"Upgrade failed\");\n        serializedTxs.push(\n            SerializedTx({\n                name: \"Upgrade Lockbox\",\n                to: _lockbox,\n                value: 0,\n                data: data\n            })\n        );\n    }\n}"
    }
}