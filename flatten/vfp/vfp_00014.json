{
    "vfp_id": "vfp_00014",
    "project_name": "cantina_maker_dss_exec_lib_jan2026.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing checks in the DssExecLib.sol",
            "description": "1. **Description:** Two distinct issues were identified in DssExecLib.sol. First, there is an asymmetry between the functions setIlkMaxLiquidationAmount and setIlkMinVaultAmount, where the former lacks a check against the dust parameter, potentially leading to incorrect state initialization. Second, the tip parameter is cast to uint192 when being set, but the operation _amount * RAD could exceed the maximum value representable by uint192, risking overflow.\n\n2. **Cause:** The first issue arises from inconsistent validation logic between two related functions, creating a dependency on the order of execution. The second issue stems from insufficient range checking when assigning a potentially large value to a smaller integer type.\n\n3. **Exploitation:** An attacker or misconfigured operation could exploit the first issue by setting parameters in the wrong order, leading to inconsistent collateral configuration. For the second, if a large value is assigned to tip, it could overflow, resulting in a truncated or incorrect fee being set.\n\n4. **Impact:** The impact includes potential misconfiguration of collateral parameters and incorrect fee settings, which could disrupt protocol operations or lead to economic imbalances. However, the issues were classified as informational due to mitigating factors such as correct usage in existing spells.\n",
            "severity": "Informational",
            "location": [
                "DssExecLib.sol#L832-L835",
                "DssExecLib.sol#L883-L886"
            ],
            "files": [
                "dss-exec-lib/src/DssExecLib.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Minor issues, Typos & Documentation",
            "description": "1. **Description:** This finding encompasses five minor issues: (1) use of a legacy flip function instead of clip; (2) inaccurate comment describing tip as a \"max amount\" when it is a flat fee; (3) lack of calc parameter setting (tau/cut/step) in addCollateralBase; (4) reference to a missing GOV_GUARD key in the chainlog; and (5) failure to add the ilk to LINE_MOM in addNewCollateral.\n\n2. **Cause:** These issues stem from outdated code patterns, inaccurate documentation, and incomplete function encapsulation due to Solidity's limitations in polymorphism.\n\n3. **Exploitation:** These are not directly exploitable security vulnerabilities but could lead to confusion, incorrect assumptions, or require additional manual steps during deployment.\n\n4. **Impact:** The impact is minimal, primarily affecting code maintainability, clarity, and operational safety. Some fixes were implemented, while others were acknowledged for future updates.\n",
            "severity": "Informational",
            "location": [
                "DssExecLib.sol#L354",
                "DssExecLib.sol#L880",
                "DssExecLib.sol#L992",
                "DssExecLib.sol#L298-L300",
                "DssExecLib.sol#L1045"
            ],
            "files": [
                "dss-exec-lib/src/DssExecLib.sol"
            ]
        }
    ],
    "affected_files": {
        "DssExecLib.sol": "// SPDX-FileCopyrightText: 2025 Dai Foundation <www.daifoundation.org>\n// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.16;\n\nimport {CollateralOpts} from \"./CollateralOpts.sol\";\n\ninterface Initializable {\n    function init(bytes32) external;\n}\n\ninterface Authorizable {\n    function rely(address) external;\n    function deny(address) external;\n    function setAuthority(address) external;\n}\n\ninterface Kissable {\n    function kiss(address) external;\n    function diss(address) external;\n    function bud(address) external view returns (uint256);\n}\n\ninterface Fileable {\n    function file(bytes32, address) external;\n    function file(bytes32, uint256) external;\n    function file(bytes32, bytes32, uint256) external;\n    function file(bytes32, bytes32, address) external;\n}\n\ninterface Drippable {\n    function drip() external returns (uint256);\n    function drip(bytes32) external returns (uint256);\n}\n\ninterface Pokeable {\n    function poke(bytes32) external;\n}\n\ninterface ERC20 {\n    function decimals() external returns (uint8);\n}\n\ninterface DssVat {\n    function hope(address) external;\n    function nope(address) external;\n    function ilks(bytes32) external returns (uint256 Art, uint256 rate, uint256 spot, uint256 line, uint256 dust);\n    function Line() external view returns (uint256);\n    function suck(address, address, uint256) external;\n}\n\ninterface PauseLike {\n    function setDelay(uint256) external;\n}\n\ninterface ClipLike {\n    function vat() external returns (address);\n    function dog() external returns (address);\n    function spotter() external view returns (address);\n    function calc() external view returns (address);\n    function ilk() external returns (bytes32);\n}\n\ninterface DogLike {\n    function ilks(bytes32) external returns (address clip, uint256 chop, uint256 hole, uint256 dirt);\n}\n\ninterface JoinLike {\n    function vat() external returns (address);\n    function ilk() external returns (bytes32);\n    function gem() external returns (address);\n    function dec() external returns (uint256);\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n\ninterface OsmLike is Kissable {\n    function src() external view returns (address);\n}\n\ninterface OsmMomLike {\n    function setOsm(bytes32, address) external;\n}\n\ninterface ClipperMomLike {\n    function setPriceTolerance(address, uint256) external;\n}\n\ninterface RegistryLike {\n    function add(address) external;\n    function xlip(bytes32) external view returns (address);\n}\n\n// https://github.com/makerdao/dss-chain-log\ninterface ChainlogLike {\n    function setVersion(string calldata) external;\n    function setIPFS(string calldata) external;\n    function setSha256sum(string calldata) external;\n    function getAddress(bytes32) external view returns (address);\n    function setAddress(bytes32, address) external;\n    function removeAddress(bytes32) external;\n}\n\ninterface IAMLike {\n    function ilks(bytes32) external view returns (uint256, uint256, uint48, uint48, uint48);\n    function setIlk(bytes32, uint256, uint256, uint256) external;\n    function remIlk(bytes32) external;\n}\n\ninterface LerpFactoryLike {\n    function newLerp(\n        bytes32 name_,\n        address target_,\n        bytes32 what_,\n        uint256 startTime_,\n        uint256 start_,\n        uint256 end_,\n        uint256 duration_\n    ) external returns (address);\n    function newIlkLerp(\n        bytes32 name_,\n        address target_,\n        bytes32 ilk_,\n        bytes32 what_,\n        uint256 startTime_,\n        uint256 start_,\n        uint256 end_,\n        uint256 duration_\n    ) external returns (address);\n}\n\ninterface LerpLike {\n    function tick() external returns (uint256);\n}\n\ninterface RwaOracleLike {\n    function bump(bytes32 ilk, uint256 val) external;\n}\n\ninterface ProxyLike {\n    function exec(address target, bytes calldata args) external payable returns (bytes memory out);\n}\n\n/// @title DssExecLib - Sky Protocol's Executive Spellcrafting Library\n/// @notice This library provides a suite of functions for managing the Sky Protocol.\n/// @dev Includes functions for collateral management, system configuration, governance, and more.\nlibrary DssExecLib {\n    /* ----- Constants ----- */\n\n    address public constant LOG = 0xdA0Ab1e0017DEbCd72Be8599041a2aa3bA7e740F;\n\n    uint256 internal constant THOUSAND = 10 ** 3;\n    uint256 internal constant MILLION = 10 ** 6;\n    uint256 internal constant WAD = 10 ** 18;\n    uint256 internal constant RAY = 10 ** 27;\n    uint256 internal constant RAD = 10 ** 45;\n\n    uint256 internal constant BPS_ONE_HUNDRED_PCT = 100_00;\n    uint256 internal constant RATES_ONE_HUNDRED_PCT = 1000000021979553151239153027;\n\n    /* ----- Math Functions ----- */\n\n    /// @dev WAD division. The final result is rounded to the nearest integer.\n    /// Examples:\n    ///     wdiv(1, 2) = 0.5      * WAD = 500000000000000000\n    ///     wdiv(2, 3) = 0.666... * WAD = 666666666666666667\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * WAD + y / 2) / y;\n    }\n\n    /// @dev RAY division. The final result is rounded to the nearest integer.\n    /// Examples:\n    ///     rdiv(1, 2) = 0.5      * RAY = 500000000000000000000000000\n    ///     rdiv(2, 3) = 0.666... * RAY = 666666666666666666666666667\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * RAY + y / 2) / y;\n    }\n\n    /* ----- Core Address Helpers ----- */\n\n    /// @notice Get the DAI token contract address from the changelog\n    /// @return The address of the DAI token contract\n    function dai() public view returns (address) {\n        return getChangelogAddress(\"MCD_DAI\");\n    }\n\n    /// @notice Get the USDS token contract address from the changelog\n    /// @return The address of the USDS token contract\n    function usds() public view returns (address) {\n        return getChangelogAddress(\"USDS\");\n    }\n\n    /// @notice Get the MKR token contract address from the changelog\n    /// @return The address of the MKR token contract\n    function mkr() public view returns (address) {\n        return getChangelogAddress(\"MKR\");\n    }\n\n    /// @notice Get the SKY token contract address from the changelog\n    /// @return The address of the SKY token contract\n    function sky() public view returns (address) {\n        return getChangelogAddress(\"SKY\");\n    }\n\n    /// @notice Get the VAT (accounting core) contract address from the changelog\n    /// @return The address of the VAT contract\n    function vat() public view returns (address) {\n        return getChangelogAddress(\"MCD_VAT\");\n    }\n\n    /// @notice Get the DOG (liquidation module) contract address from the changelog\n    /// @return The address of the DOG contract\n    function dog() public view returns (address) {\n        return getChangelogAddress(\"MCD_DOG\");\n    }\n\n    /// @notice Get the JUG (stability fee collector) contract address from the changelog\n    /// @return The address of the JUG contract\n    function jug() public view returns (address) {\n        return getChangelogAddress(\"MCD_JUG\");\n    }\n\n    /// @notice Get the POT (DAI Savings Rate) contract address from the changelog\n    /// @return The address of the POT contract\n    function pot() public view returns (address) {\n        return getChangelogAddress(\"MCD_POT\");\n    }\n\n    /// @notice Get the SUSDS (SKY Savings Rate) contract address from the changelog\n    /// @return The address of the SUSDS contract\n    function susds() public view returns (address) {\n        return getChangelogAddress(\"SUSDS\");\n    }\n\n    /// @notice Get the VOW (system surplus and debt manager) contract address from the changelog\n    /// @return The address of the VOW contract\n    function vow() public view returns (address) {\n        return getChangelogAddress(\"MCD_VOW\");\n    }\n\n    /// @notice Get the END (emergency shutdown) contract address from the changelog\n    /// @return The address of the END contract\n    function end() public view returns (address) {\n        return getChangelogAddress(\"MCD_END\");\n    }\n\n    /// @notice Get the ESM (emergency shutdown module) contract address from the changelog\n    /// @return The address of the ESM contract\n    function esm() public view returns (address) {\n        return getChangelogAddress(\"MCD_ESM\");\n    }\n\n    /// @notice Get the ILK_REGISTRY (collateral registry) contract address from the changelog\n    /// @return The address of the ILK_REGISTRY contract\n    function reg() public view returns (address) {\n        return getChangelogAddress(\"ILK_REGISTRY\");\n    }\n\n    /// @notice Get the SPOTTER (price feed interface) contract address from the changelog\n    /// @return The address of the SPOTTER contract\n    function spotter() public view returns (address) {\n        return getChangelogAddress(\"MCD_SPOT\");\n    }\n\n    /// @notice Get the FLAP (surplus auction) contract address from the changelog\n    /// @return The address of the FLAP contract\n    function flap() public view returns (address) {\n        return getChangelogAddress(\"MCD_FLAP\");\n    }\n\n    /// @notice Get the FLOP (debt auction) contract address from the changelog\n    /// @return The address of the FLOP contract\n    function flop() public view returns (address) {\n        return getChangelogAddress(\"MCD_FLOP\");\n    }\n\n    /// @notice Get the OSM_MOM (oracle security module mom) contract address from the changelog\n    /// @return The address of the OSM_MOM contract\n    function osmMom() public view returns (address) {\n        return getChangelogAddress(\"OSM_MOM\");\n    }\n\n    /// @notice Get the GOV_GUARD (governance guard) contract address from the changelog\n    /// @return The address of the GOV_GUARD contract\n    function govGuard() public view returns (address) {\n        return getChangelogAddress(\"GOV_GUARD\");\n    }\n\n    /// @notice Get the CLIPPER_MOM (liquidation circuit breaker) contract address from the changelog\n    /// @return The address of the CLIPPER_MOM contract\n    function clipperMom() public view returns (address) {\n        return getChangelogAddress(\"CLIPPER_MOM\");\n    }\n\n    /// @notice Get the PAUSE_PROXY (governance proxy) contract address from the changelog\n    /// @return The address of the PAUSE_PROXY contract\n    function pauseProxy() public view returns (address) {\n        return getChangelogAddress(\"MCD_PAUSE_PROXY\");\n    }\n\n    /// @notice Get the IAM_AUTO_LINE (auto debt ceiling adjuster) contract address from the changelog\n    /// @return The address of the IAM_AUTO_LINE contract\n    function autoLine() public view returns (address) {\n        return getChangelogAddress(\"MCD_IAM_AUTO_LINE\");\n    }\n\n    /// @notice Get the DAI_JOIN (DAI token adapter) contract address from the changelog\n    /// @return The address of the DAI_JOIN contract\n    function daiJoin() public view returns (address) {\n        return getChangelogAddress(\"MCD_JOIN_DAI\");\n    }\n\n    /// @notice Get the USDS_JOIN (USDS token adapter) contract address from the changelog\n    /// @return The address of the USDS_JOIN contract\n    function usdsJoin() public view returns (address) {\n        return getChangelogAddress(\"USDS_JOIN\");\n    }\n\n    /// @notice Get the LERP_FAB (linear interpolation factory) contract address from the changelog\n    /// @return The address of the LERP_FAB contract\n    function lerpFab() public view returns (address) {\n        return getChangelogAddress(\"LERP_FAB\");\n    }\n\n    /// @notice Get the PAUSE (governance delay) contract address from the changelog\n    /// @return The address of the PAUSE contract\n    function pause() public view returns (address) {\n        return getChangelogAddress(\"MCD_PAUSE\");\n    }\n\n    /// @notice Get the collateral liquidation contract address for a given ilk\n    /// @param _ilk The collateral type identifier\n    /// @return _clip The address of the liquidation contract for the given ilk\n    function clip(bytes32 _ilk) public view returns (address _clip) {\n        _clip = RegistryLike(reg()).xlip(_ilk);\n    }\n\n    /// @notice Get the collateral auction contract address for a given ilk (legacy)\n    /// @param _ilk The collateral type identifier\n    /// @return _flip The address of the auction contract for the given ilk\n    function flip(bytes32 _ilk) public view returns (address _flip) {\n        _flip = RegistryLike(reg()).xlip(_ilk);\n    }\n\n    /// @notice Get the pricing calculator contract address for a given ilk\n    /// @param _ilk The collateral type identifier\n    /// @return _calc The address of the pricing calculator contract for the given ilk\n    function calc(bytes32 _ilk) public view returns (address _calc) {\n        _calc = ClipLike(clip(_ilk)).calc();\n    }\n\n    /// @dev Get an address from the chainlog.\n    /// @dev Reverts if the key does not exist\n    /// @param _key Access key for the address (e.g. \"MCD_VAT\")\n    /// @return The address associated with the key\n    function getChangelogAddress(bytes32 _key) public view returns (address) {\n        return ChainlogLike(LOG).getAddress(_key);\n    }\n\n    /* ----- Changelog Management ----- */\n\n    /// @dev Set an address in the Sky Protocol on-chain changelog.\n    /// @param _key Access key for the address (e.g. \"MCD_VAT\")\n    /// @param _val The address associated with the _key\n    function setChangelogAddress(bytes32 _key, address _val) public {\n        ChainlogLike(LOG).setAddress(_key, _val);\n    }\n\n    /// @dev Remove an address from the Sky Protocol on-chain changelog.\n    /// @param _key Access key for the address to remove (e.g. \"MCD_VAT\")\n    function removeChangelogAddress(bytes32 _key) public {\n        ChainlogLike(LOG).removeAddress(_key);\n    }\n\n    /// @dev Set version in the Sky Protocol on-chain changelog.\n    /// @param _version Changelog version (e.g. \"1.1.2\")\n    function setChangelogVersion(string memory _version) public {\n        ChainlogLike(LOG).setVersion(_version);\n    }\n\n    /// @dev Set IPFS hash of IPFS changelog in Sky Protocol on-chain changelog.\n    /// @param _ipfsHash IPFS hash (e.g. \"QmefQMseb3AiTapiAKKexdKHig8wroKuZbmLtPLv4u2YwW\")\n    function setChangelogIPFS(string memory _ipfsHash) public {\n        ChainlogLike(LOG).setIPFS(_ipfsHash);\n    }\n\n    /// @dev Set SHA256 hash in Sky Protocol on-chain changelog.\n    /// @param _SHA256Sum SHA256 hash (e.g. \"e42dc9d043a57705f3f097099e6b2de4230bca9a020c797508da079f9079e35b\")\n    function setChangelogSHA256(string memory _SHA256Sum) public {\n        ChainlogLike(LOG).setSha256sum(_SHA256Sum);\n    }\n\n    /* ----- Authorizations ----- */\n\n    /// @dev Give an address authorization to perform auth actions on the contract.\n    /// @param _base The address of the contract where the authorization will be set\n    /// @param _ward Address to be authorized\n    function authorize(address _base, address _ward) public {\n        Authorizable(_base).rely(_ward);\n    }\n\n    /// @dev Revoke contract authorization from an address.\n    /// @param _base The address of the contract where the authorization will be revoked\n    /// @param _ward Address to be deauthorized\n    function deauthorize(address _base, address _ward) public {\n        Authorizable(_base).deny(_ward);\n    }\n\n    /// @dev Adds an address to a contract's whitelist\n    /// @param _target Address of a contract that implements the kiss() function\n    /// @param _usr Address to add to whitelist\n    function addToWhitelist(address _target, address _usr) public {\n        Kissable(_target).kiss(_usr);\n    }\n\n    /// @dev Removes an address from a contract's whitelist\n    /// @param _target Address of a contract that implements the diss() function\n    /// @param _usr Address to remove from whitelist\n    function removeFromWhitelist(address _target, address _usr) public {\n        Kissable(_target).diss(_usr);\n    }\n\n    /// @dev Set the authority contract that manages access control for the target contract.\n    /// @param _base The address of the contract where the authority will be set\n    /// @param _authority Address of the authority contract that will manage privileged access (e.g., Chief managing who can call the Pause contract)\n    function setAuthority(address _base, address _authority) public {\n        Authorizable(_base).setAuthority(_authority);\n    }\n\n    /// @dev Delegate vat authority to the specified address.\n    /// @param _usr Address to be authorized\n    function delegateVat(address _usr) public {\n        DssVat(vat()).hope(_usr);\n    }\n\n    /// @dev Revoke vat authority to the specified address.\n    /// @param _usr Address to be deauthorized\n    function undelegateVat(address _usr) public {\n        DssVat(vat()).nope(_usr);\n    }\n\n    /* ----- OfficeHours Management ----- */\n\n    /// @dev Returns true if a time is within office hours range\n    /// @param _ts The timestamp to check, usually block.timestamp\n    /// @param _officeHours true if office hours is enabled.\n    /// @return true if time is in castable range\n    function canCast(uint40 _ts, bool _officeHours) public pure returns (bool) {\n        if (_officeHours) {\n            uint256 day = (_ts / 1 days + 3) % 7;\n            if (day >= 5) return false; // Can only be cast on a weekday\n            uint256 hour = _ts / 1 hours % 24;\n            if (hour < 14 || hour >= 21) return false; // Outside office hours\n        }\n        return true;\n    }\n\n    /// @dev Calculate the next available cast time in epoch seconds\n    /// @param _eta The scheduled time of the spell plus the pause delay\n    /// @param _ts The current timestamp, usually block.timestamp\n    /// @param _officeHours true if office hours is enabled.\n    /// @return castTime The next available cast timestamp\n    function nextCastTime(uint40 _eta, uint40 _ts, bool _officeHours) public pure returns (uint256 castTime) {\n        require(_eta != 0); // \"DssExecLib/invalid eta\"\n        require(_ts != 0); // \"DssExecLib/invalid ts\"\n        castTime = _ts > _eta ? _ts : _eta; // Any day at XX:YY\n\n        if (_officeHours) {\n            uint256 day = (castTime / 1 days + 3) % 7;\n            uint256 hour = castTime / 1 hours % 24;\n            uint256 minute = castTime / 1 minutes % 60;\n            uint256 second = castTime % 60;\n\n            if (day >= 5) {\n                castTime += (6 - day) * 1 days; // Go to Sunday XX:YY\n                castTime += (24 - hour + 14) * 1 hours; // Go to 14:YY UTC Monday\n                castTime -= minute * 1 minutes + second; // Go to 14:00 UTC\n            } else {\n                if (hour >= 21) {\n                    if (day == 4) castTime += 2 days; // If Friday, fast forward to Sunday XX:YY\n                    castTime += (24 - hour + 14) * 1 hours; // Go to 14:YY UTC next day\n                    castTime -= minute * 1 minutes + second; // Go to 14:00 UTC\n                } else if (hour < 14) {\n                    castTime += (14 - hour) * 1 hours; // Go to 14:YY UTC same day\n                    castTime -= minute * 1 minutes + second; // Go to 14:00 UTC\n                }\n            }\n        }\n    }\n\n    /* ----- Accumulating Rates ----- */\n\n    /// @dev Update rate accumulation for the Dai Savings Rate (DSR).\n    function accumulateDSR() public {\n        Drippable(pot()).drip();\n    }\n\n    /// @dev Update rate accumulation for the Sky Savings Rate (SSR).\n    function accumulateSSR() public {\n        Drippable(susds()).drip();\n    }\n\n    /// @dev Update rate accumulation for the stability fees of a given collateral type.\n    /// @param _ilk Collateral type\n    function accumulateCollateralStabilityFees(bytes32 _ilk) public {\n        Drippable(jug()).drip(_ilk);\n    }\n\n    /* ----- Price Updates ----- */\n\n    /// @dev Update price of a given collateral type.\n    /// @param _ilk Collateral type\n    function updateCollateralPrice(bytes32 _ilk) public {\n        Pokeable(spotter()).poke(_ilk);\n    }\n\n    /* ----- System Configuration ----- */\n\n    /// @dev Set a contract in another contract, defining the relationship (ex. set a new Calc contract in Clip)\n    /// @param _base The address of the contract where the new contract address will be filed\n    /// @param _what Name of contract to file\n    /// @param _addr Address of contract to file\n    function setContract(address _base, bytes32 _what, address _addr) public {\n        Fileable(_base).file(_what, _addr);\n    }\n\n    /// @dev Set a contract in another contract, defining the relationship (ex. set a new Calc contract in a Clip)\n    /// @param _base The address of the contract where the new contract address will be filed\n    /// @param _ilk Collateral type\n    /// @param _what Name of contract to file\n    /// @param _addr Address of contract to file\n    function setContract(address _base, bytes32 _ilk, bytes32 _what, address _addr) public {\n        Fileable(_base).file(_ilk, _what, _addr);\n    }\n\n    /// @dev Set a value in a contract, via a governance authorized File pattern.\n    /// @param _base The address of the contract where the new contract address will be filed\n    /// @param _what Name of tag for the value (e.g. \"Line\")\n    /// @param _amt The value to set or update\n    function setValue(address _base, bytes32 _what, uint256 _amt) public {\n        Fileable(_base).file(_what, _amt);\n    }\n\n    /// @dev Set an ilk-specific value in a contract, via a governance authorized File pattern.\n    /// @param _base The address of the contract where the new value will be filed\n    /// @param _ilk Collateral type\n    /// @param _what Name of tag for the value (e.g. \"Line\")\n    /// @param _amt The value to set or update\n    function setValue(address _base, bytes32 _ilk, bytes32 _what, uint256 _amt) public {\n        Fileable(_base).file(_ilk, _what, _amt);\n    }\n\n    /* ----- System Risk Parameters ----- */\n\n    /// @dev Set the global debt ceiling. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to set (ex. 10m amount == 10000000)\n    function setGlobalDebtCeiling(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-global-Line-precision\"\n        setValue(vat(), \"Line\", _amount * RAD);\n    }\n\n    /// @dev Increase the global debt ceiling by a specific amount. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to add (ex. 10m amount == 10000000)\n    function increaseGlobalDebtCeiling(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-Line-increase-precision\"\n        address _vat = vat();\n        setValue(_vat, \"Line\", DssVat(_vat).Line() + _amount * RAD);\n    }\n\n    /// @dev Decrease the global debt ceiling by a specific amount. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to reduce (ex. 10m amount == 10000000)\n    function decreaseGlobalDebtCeiling(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-Line-decrease-precision\"\n        address _vat = vat();\n        setValue(_vat, \"Line\", DssVat(_vat).Line() - _amount * RAD);\n    }\n\n    /// @dev Set the Dai Savings Rate. See: docs/rates.txt\n    /// @param _rate The accumulated rate (ex. 4% => 1000000001243680656318820312)\n    /// @param _doDrip `true` to accumulate interest owed\n    function setDSR(uint256 _rate, bool _doDrip) public {\n        require((_rate >= RAY) && (_rate <= RATES_ONE_HUNDRED_PCT)); // \"LibDssExec/dsr-out-of-bounds\"\n        if (_doDrip) Drippable(pot()).drip();\n        setValue(pot(), \"dsr\", _rate);\n    }\n\n    /// @dev Set the SKY Savings Rate. See: docs/rates.txt\n    /// @param _rate The accumulated rate (ex. 4% => 1000000001243680656318820312)\n    /// @param _doDrip `true` to accumulate interest owed\n    function setSSR(uint256 _rate, bool _doDrip) public {\n        require((_rate >= RAY) && (_rate <= RATES_ONE_HUNDRED_PCT)); // \"LibDssExec/ssr-out-of-bounds\"\n        if (_doDrip) Drippable(susds()).drip();\n        setValue(susds(), \"ssr\", _rate);\n    }\n\n    /// @dev Set the amount for system surplus auctions. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to set (ex. 10m amount == 10000000)\n    function setSurplusAuctionAmount(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-vow-bump-precision\"\n        setValue(vow(), \"bump\", _amount * RAD);\n    }\n\n    /// @dev Set the amount for system surplus buffer, must be exceeded before surplus auctions start. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to set (ex. 10m amount == 10000000)\n    function setSurplusBuffer(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-vow-hump-precision\"\n        setValue(vow(), \"hump\", _amount * RAD);\n    }\n\n    /// @dev Set the minimum price threshold for surplus auctions. Amount will be converted to the correct internal precision.\n    /// @dev Equation used for conversion is (pct / 10,000) * WAD\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 5% = 5 * 100 = 500)\n    function setSurplusAuctionMinPriceThreshold(uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-flap-beg-precision\"\n        setValue(flap(), \"want\", wdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Set the number of seconds that pass before system debt is auctioned for MKR tokens.\n    /// @param _duration Duration in seconds\n    function setDebtAuctionDelay(uint256 _duration) public {\n        setValue(vow(), \"wait\", _duration);\n    }\n\n    /// @dev Set the debt amount for system debt to be covered by each debt auction. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to set (ex. 10m debt amount == 10000000)\n    function setDebtAuctionDebtAmount(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-vow-sump-precision\"\n        setValue(vow(), \"sump\", _amount * RAD);\n    }\n\n    /// @dev Set the starting governance token amount to be auctioned off to cover system debt in debt auctions. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to set in governance tokens (ex. 250 governance token amount == 250)\n    function setDebtAuctionGovAmount(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-vow-dump-precision\"\n        setValue(vow(), \"dump\", _amount * WAD);\n    }\n\n    /// @dev Set minimum bid increase for debt auctions. Amount will be converted to the correct internal precision.\n    /// @dev Equation used for conversion is (1 + pct / 10,000) * WAD\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 5% = 5 * 100 = 500)\n    function setMinDebtAuctionBidIncrease(uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-flop-beg-precision\"\n        setValue(flop(), \"beg\", WAD + wdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Set bid duration for debt auctions.\n    /// @param _duration Amount of time for bids. (seconds)\n    function setDebtAuctionBidDuration(uint256 _duration) public {\n        require(_duration < type(uint48).max); // \"LibDssExec/incorrect-flop-ttl-precision\"\n        setValue(flop(), \"ttl\", _duration);\n    }\n\n    /// @dev Set total auction duration for debt auctions.\n    /// @param _duration Amount of time for auctions. (seconds)\n    function setDebtAuctionDuration(uint256 _duration) public {\n        require(_duration < type(uint48).max); // \"LibDssExec/incorrect-flop-tau-precision\"\n        setValue(flop(), \"tau\", _duration);\n    }\n\n    /// @dev Set the rate of increasing amount of MKR out for auction during debt auctions. Amount will be converted to the correct internal precision.\n    /// @dev MKR amount is increased by this rate every \"tick\" (if auction duration has passed and no one has bid on the MKR)\n    /// @dev Equation used for conversion is (1 + pct / 10,000) * WAD\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 5% = 5 * 100 = 500)\n    function setDebtAuctionMKRIncreaseRate(uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-flop-pad-precision\"\n        setValue(flop(), \"pad\", WAD + wdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Set the maximum total debt amount that can be out for liquidation in the system at any point. Amount will be converted to the correct internal precision.\n    /// @param _amount The amount to set (ex. 250,000 debt units == 250000)\n    function setMaxTotalDebtLiquidationAmount(uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-dog-Hole-precision\"\n        setValue(dog(), \"Hole\", _amount * RAD);\n    }\n\n    /// @dev Set the duration of time that has to pass during emergency shutdown before collateral can start being claimed by DAI holders.\n    /// @param _duration Time in seconds to set for ES processing time\n    function setEmergencyShutdownProcessingTime(uint256 _duration) public {\n        setValue(end(), \"wait\", _duration);\n    }\n\n    /// @dev Set the global stability fee (is not typically used, currently is 0).\n    ///        Many of the settings that change weekly rely on the rate accumulator\n    ///        described at https://docs.makerdao.com/smart-contract-modules/rates-module\n    ///        To check this yourself, use the following rate calculation (example 8%):\n    ///\n    ///        $ bc -l <<< 'scale=27; e( l(1.08)/(60 * 60 * 24 * 365) )'\n    ///\n    ///        A table of rates can also be found at:\n    ///        https://ipfs.io/ipfs/QmefQMseb3AiTapiAKKexdKHig8wroKuZbmLtPLv4u2YwW\n    /// @param _rate The accumulated rate (ex. 4% => 1000000001243680656318820312)\n    function setGlobalStabilityFee(uint256 _rate) public {\n        require((_rate >= RAY) && (_rate <= RATES_ONE_HUNDRED_PCT)); // \"LibDssExec/global-stability-fee-out-of-bounds\"\n        setValue(jug(), \"base\", _rate);\n    }\n\n    /// @dev Set the value of the stablecoin in the reference asset (e.g. $1 per unit). Value will be converted to the correct internal precision.\n    /// @dev Equation used for conversion is value * RAY / 1000\n    /// @param _value The value to set as integer (x1000) (ex. $1.025 == 1025)\n    function setParity(uint256 _value) public {\n        require(_value < WAD); // \"LibDssExec/incorrect-par-precision\"\n        setValue(spotter(), \"par\", rdiv(_value, 1000));\n    }\n\n    /* ----- Collateral Management ----- */\n\n    /// @dev Set a collateral debt ceiling. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The amount to set (ex. 10m amount == 10000000)\n    function setIlkDebtCeiling(bytes32 _ilk, uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-ilk-line-precision\"\n        setValue(vat(), _ilk, \"line\", _amount * RAD);\n    }\n\n    /// @dev Increase a collateral debt ceiling. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The amount to increase (ex. 10m amount == 10000000)\n    /// @param _global If true, increases the global debt ceiling by _amount\n    function increaseIlkDebtCeiling(bytes32 _ilk, uint256 _amount, bool _global) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-ilk-line-precision\"\n        address _vat = vat();\n        (,,, uint256 line_,) = DssVat(_vat).ilks(_ilk);\n        setValue(_vat, _ilk, \"line\", line_ + _amount * RAD);\n        if (_global) increaseGlobalDebtCeiling(_amount);\n    }\n\n    /// @dev Decrease a collateral debt ceiling. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The amount to decrease (ex. 10m amount == 10000000)\n    /// @param _global If true, decreases the global debt ceiling by _amount\n    function decreaseIlkDebtCeiling(bytes32 _ilk, uint256 _amount, bool _global) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-ilk-line-precision\"\n        address _vat = vat();\n        (,,, uint256 line_,) = DssVat(_vat).ilks(_ilk);\n        setValue(_vat, _ilk, \"line\", line_ - _amount * RAD);\n        if (_global) decreaseGlobalDebtCeiling(_amount);\n    }\n\n    /// @dev Set a RWA collateral debt ceiling by specifying its new oracle price.\n    /// @param _ilk The ilk to update (ex. bytes32(\"RWA001-A\"))\n    /// @param _ceiling The new debt ceiling in natural units (e.g. set 10m as 10_000_000)\n    /// @param _price The new oracle price in natural units\n    /// @dev note: currently only DAI is supported in RWA vaults.\n    /// @dev note: _price should enable DAI to be drawn over the loan period while taking into\n    ///                 account the configured ink amount, interest rate and liquidation ratio\n    /// @dev note: _price * WAD should be greater than or equal to the current oracle price\n    function setRWAIlkDebtCeiling(bytes32 _ilk, uint256 _ceiling, uint256 _price) public {\n        require(_price < WAD);\n        setIlkDebtCeiling(_ilk, _ceiling);\n        RwaOracleLike(getChangelogAddress(\"MIP21_LIQUIDATION_ORACLE\")).bump(_ilk, _price * WAD);\n        updateCollateralPrice(_ilk);\n    }\n\n    /// @dev Set the parameters for an ilk in the \"MCD_IAM_AUTO_LINE\" auto-line\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The Maximum value (ex. 100m amount == 100000000)\n    /// @param _gap The amount per step (ex. 5m gap == 5000000)\n    /// @param _ttl The amount of time (in seconds)\n    function setIlkAutoLineParameters(bytes32 _ilk, uint256 _amount, uint256 _gap, uint256 _ttl) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-auto-line-amount-precision\"\n        require(_gap < WAD); // \"LibDssExec/incorrect-auto-line-gap-precision\"\n        IAMLike(autoLine()).setIlk(_ilk, _amount * RAD, _gap * RAD, _ttl);\n    }\n\n    /// @dev Set the parameters for an ilk in the \"MCD_IAM_AUTO_LINE\" auto-line. Keeps the ttl unchanged.\n    ///      Requires the auto-line to be already configured for the ilk.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The Maximum value (ex. 100m amount == 100000000)\n    /// @param _gap The amount per step (ex. 5m gap == 5000000)\n    function setIlkAutoLineParameters(bytes32 _ilk, uint256 _amount, uint256 _gap) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-auto-line-amount-precision\"\n        require(_gap < WAD); // \"LibDssExec/incorrect-auto-line-gap-precision\"\n        address _autoLine = autoLine();\n        (,, uint48 ttl,,) = IAMLike(_autoLine).ilks(_ilk);\n        require(ttl != 0); // \"LibDssExec/auto-line-not-configured\"\n        IAMLike(_autoLine).setIlk(_ilk, _amount * RAD, _gap * RAD, uint256(ttl));\n    }\n\n    /// @dev Set the debt ceiling for an ilk in the \"MCD_IAM_AUTO_LINE\" auto-line without updating the time values\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The Maximum value (ex. 100m amount == 100000000)\n    function setIlkAutoLineDebtCeiling(bytes32 _ilk, uint256 _amount) public {\n        address _autoLine = autoLine();\n        (, uint256 gap, uint48 ttl,,) = IAMLike(_autoLine).ilks(_ilk);\n        require(gap != 0 && ttl != 0); // \"LibDssExec/auto-line-not-configured\"\n        IAMLike(_autoLine).setIlk(_ilk, _amount * RAD, uint256(gap), uint256(ttl));\n    }\n\n    /// @dev Remove an ilk in the \"MCD_IAM_AUTO_LINE\" auto-line\n    /// @param _ilk The ilk to remove (ex. bytes32(\"ETH-A\"))\n    function removeIlkFromAutoLine(bytes32 _ilk) public {\n        IAMLike(autoLine()).remIlk(_ilk);\n    }\n\n    /// @dev Set a collateral minimum vault amount. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The amount to set (ex. 10m amount == 10000000)\n    function setIlkMinVaultAmount(bytes32 _ilk, uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-ilk-dust-precision\"\n        (,, uint256 _hole,) = DogLike(dog()).ilks(_ilk);\n        require(_amount <= _hole / RAD); // Ensure ilk.hole >= dust\n        setValue(vat(), _ilk, \"dust\", _amount * RAD);\n        clip(_ilk).call(abi.encodeWithSignature(\"upchost()\"));\n    }\n\n    /// @dev Set a collateral liquidation penalty. Amount will be converted to the correct internal precision.\n    /// @dev Equation used for conversion is (1 + pct / 10,000) * WAD\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 10.25% = 10.25 * 100 = 1025)\n    function setIlkLiquidationPenalty(bytes32 _ilk, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-ilk-chop-precision\"\n        setValue(dog(), _ilk, \"chop\", WAD + wdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n        clip(_ilk).call(abi.encodeWithSignature(\"upchost()\"));\n    }\n\n    /// @dev Set max amount for liquidation per vault for collateral. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The amount to set (ex. 10m amount == 10000000)\n    function setIlkMaxLiquidationAmount(bytes32 _ilk, uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-ilk-hole-precision\"\n        (,,,, uint256 _dust) = DssVat(vat()).ilks(_ilk);\n        require(_amount * RAD >= _dust); // Ensure hole >= ilk.dust\n        setValue(dog(), _ilk, \"hole\", _amount * RAD);\n    }\n\n    /// @dev Set a collateral liquidation ratio. Amount will be converted to the correct internal precision.\n    /// @dev Equation used for conversion is pct * RAY / 10,000\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 150% = 150 * 100 = 15000)\n    function setIlkLiquidationRatio(bytes32 _ilk, uint256 _pct_bps) public {\n        require(_pct_bps < 10 * BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-ilk-mat-precision\" // Fails if pct >= 1000%\n        require(_pct_bps >= BPS_ONE_HUNDRED_PCT); // the liquidation ratio has to be bigger or equal to 100%\n        setValue(spotter(), _ilk, \"mat\", rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Set an auction starting multiplier. Amount will be converted to the correct internal precision.\n    /// @dev Equation used for conversion is pct * RAY / 10,000\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 1.3x starting multiplier = 130% = 13000)\n    function setStartingPriceMultiplicativeFactor(bytes32 _ilk, uint256 _pct_bps) public {\n        require(_pct_bps < 10 * BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-ilk-buf-precision\" // Fails if gt 10x\n        require(_pct_bps >= BPS_ONE_HUNDRED_PCT); // fail if start price is less than OSM price\n        setValue(clip(_ilk), \"buf\", rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Set the amount of time before an auction resets.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _duration Amount of time before auction resets (in seconds).\n    function setAuctionTimeBeforeReset(bytes32 _ilk, uint256 _duration) public {\n        setValue(clip(_ilk), \"tail\", _duration);\n    }\n\n    /// @dev Percentage drop permitted before auction reset\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _pct_bps The pct, in basis points, of drop to permit (x100).\n    function setAuctionPermittedDrop(bytes32 _ilk, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-clip-cusp-value\"\n        setValue(clip(_ilk), \"cusp\", rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Percentage of tab to suck from vow to incentivize keepers. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _pct_bps The pct, in basis points, of the tab to suck. (0.01% == 1)\n    function setKeeperIncentivePercent(bytes32 _ilk, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-clip-chip-precision\"\n        setValue(clip(_ilk), \"chip\", wdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Sets the amount for flat rate keeper incentive. Amount will be converted to the correct internal precision.\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _amount The amount to set (ex. 1000 amount == 1000)\n    function setKeeperIncentiveFlatRate(bytes32 _ilk, uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-clip-tip-precision\"\n        require(_amount * RAD <= type(uint192).max); // \"LibDssExec/clip-tip-precision-overflow\"\n        setValue(clip(_ilk), \"tip\", _amount * RAD);\n    }\n\n    /// @dev Sets the circuit breaker price tolerance in the clipper mom.\n    ///          This is somewhat counter-intuitive,\n    ///           to accept a 25% price drop, use a value of 75%\n    /// @param _clip The clipper to set the tolerance for\n    /// @param _pct_bps The pct, in basis points, to set in integer form (x100). (ex. 5% = 5 * 100 = 500)\n    function setLiquidationBreakerPriceTolerance(address _clip, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // \"LibDssExec/incorrect-clippermom-price-tolerance\"\n        ClipperMomLike(clipperMom()).setPriceTolerance(_clip, rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /// @dev Set the stability fee for a given ilk.\n    ///          Many of the settings that change weekly rely on the rate accumulator\n    ///          described at https://docs.makerdao.com/smart-contract-modules/rates-module\n    ///          To check this yourself, use the following rate calculation (example 8%):\n    ///\n    ///          $ bc -l <<< 'scale=27; e( l(1.08)/(60 * 60 * 24 * 365) )'\n    ///\n    ///          A table of rates can also be found at:\n    ///          https://ipfs.io/ipfs/QmefQMseb3AiTapiAKKexdKHig8wroKuZbmLtPLv4u2YwW\n    ///\n    /// @param _ilk The ilk to update (ex. bytes32(\"ETH-A\"))\n    /// @param _rate The accumulated rate (ex. 4% => 1000000001243680656318820312)\n    /// @param _doDrip `true` to accumulate stability fees for the collateral\n    function setIlkStabilityFee(bytes32 _ilk, uint256 _rate, bool _doDrip) public {\n        require((_rate >= RAY) && (_rate <= RATES_ONE_HUNDRED_PCT)); // \"LibDssExec/ilk-stability-fee-out-of-bounds\"\n        address _jug = jug();\n        if (_doDrip) Drippable(_jug).drip(_ilk);\n\n        setValue(_jug, _ilk, \"duty\", _rate);\n    }\n\n    /* ----- Abacus Management ----- */\n\n    /// @dev Set the number of seconds from the start when the auction reaches zero price.\n    /// @dev Abacus:LinearDecrease only.\n    /// @param _calc The address of the LinearDecrease pricing contract\n    /// @param _duration Amount of time for auctions.\n    function setLinearDecrease(address _calc, uint256 _duration) public {\n        setValue(_calc, \"tau\", _duration);\n    }\n\n    /// @dev Set the number of seconds for each price step.\n    /// @dev Abacus:StairstepExponentialDecrease only.\n    /// @param _calc The address of the StairstepExponentialDecrease pricing contract\n    /// @param _duration Length of time between price drops [seconds]\n    /// @param _pct_bps Per-step multiplicative factor in basis points. (ex. 99% == 9900)\n    function setStairstepExponentialDecrease(address _calc, uint256 _duration, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // DssExecLib/cut-too-high\n        setValue(_calc, \"cut\", rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n        setValue(_calc, \"step\", _duration);\n    }\n\n    /// @dev Set the number of seconds for each price step. (99% cut = 1% price drop per step)\n    ///           Amounts will be converted to the correct internal precision.\n    /// @dev Abacus:ExponentialDecrease only\n    /// @param _calc The address of the ExponentialDecrease pricing contract\n    /// @param _pct_bps Per-step multiplicative factor in basis points. (ex. 99% == 9900)\n    function setExponentialDecrease(address _calc, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // DssExecLib/cut-too-high\n        setValue(_calc, \"cut\", rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /* ----- Oracle Management ----- */\n\n    /// @dev Add OSM address to OSM mom, allowing it to be frozen by governance\n    /// @param _osm Oracle Security Module (OSM) core contract address\n    /// @param _ilk Collateral type using OSM\n    function allowOSMFreeze(address _osm, bytes32 _ilk) public {\n        OsmMomLike(osmMom()).setOsm(_ilk, _osm);\n    }\n\n    /* ----- Governance Security Module ----- */\n\n    /// @dev Sets the time delay between governance votes and execution in MCD_PAUSE.\n    /// @dev Enforces an arbitrary minimum delay of 12 hours.\n    /// @param _delay The time delay in seconds.\n    function setGSMDelay(uint256 _delay) public {\n        require(_delay >= 12 hours); // DssExecLib/delay-too-low\n        PauseLike(pause()).setDelay(_delay);\n    }\n\n    /* ----- Direct Deposit Module ----- */\n\n    /// @dev Sets the target rate threshold for a direct deposit module (ddm)\n    /// @dev Aave: Targets the variable borrow rate\n    /// @param _ddm The address of the DDM contract\n    /// @param _pct_bps Target rate in basis points. (ex. 4% == 400)\n    function setDDMTargetInterestRate(address _ddm, uint256 _pct_bps) public {\n        require(_pct_bps < BPS_ONE_HUNDRED_PCT); // DssExecLib/bar-too-high\n        setValue(_ddm, \"bar\", rdiv(_pct_bps, BPS_ONE_HUNDRED_PCT));\n    }\n\n    /* ----- Collateral Onboarding ----- */\n\n    /// @dev Performs basic collateral setup with core contract integrations and authorizations.\n    /// @dev This function handles the fundamental integration of a new collateral type into the core Sky Protocol\n    ///      contracts (VAT, DOG, JUG, etc.) without setting risk parameters. Use this when you need basic setup\n    ///      without full parameter configuration, or as a building block for more complex onboarding.\n    /// @param _ilk      Collateral type key code [Ex. \"ETH-A\"]\n    /// @param _gem      Address of token contract\n    /// @param _join     Address of join adapter\n    /// @param _clip     Address of liquidation agent\n    /// @param _calc     Address of the pricing function\n    /// @param _pip      Address of price feed\n    function addCollateralBase(bytes32 _ilk, address _gem, address _join, address _clip, address _calc, address _pip)\n        public\n    {\n        // Sanity checks\n        address _vat = vat();\n        address _dog = dog();\n        address _spotter = spotter();\n        uint256 _dec = ERC20(_gem).decimals();\n\n        require(JoinLike(_join).vat() == _vat); // \"join-vat-not-match\"\n        require(JoinLike(_join).ilk() == _ilk); // \"join-ilk-not-match\"\n        require(JoinLike(_join).gem() == _gem); // \"join-gem-not-match\"\n        require(JoinLike(_join).dec() == _dec); // \"join-dec-not-match\"\n        require(ClipLike(_clip).vat() == _vat); // \"clip-vat-not-match\"\n        require(ClipLike(_clip).dog() == _dog); // \"clip-dog-not-match\"\n        require(ClipLike(_clip).ilk() == _ilk); // \"clip-ilk-not-match\"\n        require(ClipLike(_clip).spotter() == _spotter); // \"clip-ilk-not-match\"\n\n        // Set the token PIP in the Spotter\n        setContract(spotter(), _ilk, \"pip\", _pip);\n\n        // Set the ilk Clipper in the Dog\n        setContract(_dog, _ilk, \"clip\", _clip);\n        // Set vow in the clip\n        setContract(_clip, \"vow\", vow());\n        // Set the pricing function for the Clipper\n        setContract(_clip, \"calc\", _calc);\n\n        // Init ilk in Vat & Jug\n        Initializable(_vat).init(_ilk);\n        Initializable(jug()).init(_ilk);\n\n        // Allow ilk Join to modify Vat registry\n        authorize(_vat, _join);\n        // Allow ilk Join to suck dai for keepers\n        authorize(_vat, _clip);\n        // Allow the ilk Clipper to reduce the Dog hole on deal()\n        authorize(_dog, _clip);\n        // Allow Dog to kick auctions in ilk Clipper\n        authorize(_clip, _dog);\n        // Allow End to yank auctions in ilk Clipper\n        authorize(_clip, end());\n        // Authorize the ESM to execute in the clipper\n        authorize(_clip, esm());\n\n        // Add new ilk to the IlkRegistry\n        RegistryLike(reg()).add(_join);\n    }\n\n    /// @dev Complete collateral onboarding with all necessary configurations and authorizations.\n    /// @dev This function performs comprehensive collateral setup including debt ceilings, liquidation parameters,\n    ///      stability fees, and oracle configurations. Use this for complete collateral onboarding.\n    /// @param co Struct containing all collateral configuration options and parameters\n    function addNewCollateral(CollateralOpts memory co) public {\n        // Add the collateral to the system.\n        addCollateralBase(co.ilk, co.gem, co.join, co.clip, co.calc, co.pip);\n        address clipperMom_ = clipperMom();\n\n        if (!co.isLiquidatable) {\n            // Disallow Dog to kick auctions in ilk Clipper\n            setValue(co.clip, \"stopped\", 3);\n        } else {\n            // Grant ClipperMom access to the ilk Clipper\n            authorize(co.clip, clipperMom_);\n        }\n\n        if (co.isOSM) {\n            // If pip == OSM\n            if (co.checkWhitelistedOSM) {\n                // Check whether the OSM was kissed in the underlying oracle\n                require(Kissable(OsmLike(co.pip).src()).bud(co.pip) == 1); // DssExecLib/osm-not-kissed\n            }\n            // Allow OsmMom to access to the TOKEN OSM\n            authorize(co.pip, osmMom());\n            // Whitelist Spotter to read the OSM data (only necessary if it is the first time the token is being added to an ilk)\n            addToWhitelist(co.pip, spotter());\n            // Whitelist Clipper on pip\n            addToWhitelist(co.pip, co.clip);\n            // Allow the clippermom to access the feed\n            addToWhitelist(co.pip, clipperMom_);\n            // Whitelist End to read the OSM data (only necessary if it is the first time the token is being added to an ilk)\n            addToWhitelist(co.pip, end());\n            // Set TOKEN OSM in the OsmMom for new ilk\n            allowOSMFreeze(co.pip, co.ilk);\n        }\n\n        // Increase the global debt ceiling by the ilk ceiling\n        increaseGlobalDebtCeiling(co.ilkDebtCeiling);\n        // Set the ilk debt ceiling\n        setIlkDebtCeiling(co.ilk, co.ilkDebtCeiling);\n        // Set the hole size\n        setIlkMaxLiquidationAmount(co.ilk, co.maxLiquidationAmount);\n        // Set the ilk dust\n        setIlkMinVaultAmount(co.ilk, co.minVaultAmount);\n        // Set the ilk liquidation penalty\n        setIlkLiquidationPenalty(co.ilk, co.liquidationPenalty);\n        // Set the ilk stability fee\n        setIlkStabilityFee(co.ilk, co.ilkStabilityFee, true);\n        // Set the auction starting price multiplier\n        setStartingPriceMultiplicativeFactor(co.ilk, co.startingPriceFactor);\n        // Set the amount of time before an auction resets.\n        setAuctionTimeBeforeReset(co.ilk, co.auctionDuration);\n        // Set the allowed auction drop percentage before reset\n        setAuctionPermittedDrop(co.ilk, co.permittedDrop);\n        // Set the ilk min collateralization ratio\n        setIlkLiquidationRatio(co.ilk, co.liquidationRatio);\n        // Set the price tolerance in the liquidation circuit breaker\n        setLiquidationBreakerPriceTolerance(co.clip, co.breakerTolerance);\n        // Set a flat rate for the keeper reward\n        setKeeperIncentiveFlatRate(co.ilk, co.kprFlatReward);\n        // Set the percentage of liquidation as keeper award\n        setKeeperIncentivePercent(co.ilk, co.kprPctReward);\n        // Update ilk spot value in Vat\n        updateCollateralPrice(co.ilk);\n    }\n\n    /* ----- Payment ----- */\n\n    /// @dev Send a payment in either ERC20 USDS or DAI from the surplus buffer.\n    /// @param _join The join adapter to exit the payment from.\n    /// @param _target The target address to send the payment to.\n    /// @param _amount The amount to send (ex. 10m amount == 10000000)\n    function sendPaymentFromSurplusBuffer(address _join, address _target, uint256 _amount) public {\n        require(_amount < WAD); // \"LibDssExec/incorrect-ilk-line-precision\"\n        DssVat(vat()).suck(vow(), address(this), _amount * RAD);\n        JoinLike(_join).exit(_target, _amount * WAD);\n    }\n\n    /* ----- Misc ----- */\n\n    /// @dev Initiate linear interpolation on an administrative value over time.\n    /// @param _name The label for this lerp instance\n    /// @param _target The target contract\n    /// @param _what The target parameter to adjust\n    /// @param _startTime The time for this lerp\n    /// @param _start The start value for the target parameter\n    /// @param _end The end value for the target parameter\n    /// @param _duration The duration of the interpolation\n    /// @return The address of the created lerp contract\n    function linearInterpolation(\n        bytes32 _name,\n        address _target,\n        bytes32 _what,\n        uint256 _startTime,\n        uint256 _start,\n        uint256 _end,\n        uint256 _duration\n    ) public returns (address) {\n        address lerp = LerpFactoryLike(lerpFab()).newLerp(_name, _target, _what, _startTime, _start, _end, _duration);\n        Authorizable(_target).rely(lerp);\n        LerpLike(lerp).tick();\n        return lerp;\n    }\n\n    /// @dev Initiate linear interpolation on an administrative value over time.\n    /// @param _name The label for this lerp instance\n    /// @param _target The target contract\n    /// @param _ilk The ilk to target\n    /// @param _what The target parameter to adjust\n    /// @param _startTime The time for this lerp\n    /// @param _start The start value for the target parameter\n    /// @param _end The end value for the target parameter\n    /// @param _duration The duration of the interpolation\n    /// @return The address of the created lerp contract\n    function linearInterpolation(\n        bytes32 _name,\n        address _target,\n        bytes32 _ilk,\n        bytes32 _what,\n        uint256 _startTime,\n        uint256 _start,\n        uint256 _end,\n        uint256 _duration\n    ) public returns (address) {\n        address lerp = LerpFactoryLike(lerpFab())\n            .newIlkLerp(_name, _target, _ilk, _what, _startTime, _start, _end, _duration);\n        Authorizable(_target).rely(lerp);\n        LerpLike(lerp).tick();\n        return lerp;\n    }\n\n    /* ----- SubDAO/Star Spells ----- */\n\n    /// @dev Execute a star spell through its star proxy.\n    /// @param _starProxy The proxy to execute the spell through.\n    /// @param _starSpell The spell to execute.\n    /// @return The return data from the spell execution.\n    function executeStarSpell(address _starProxy, address _starSpell) public returns (bytes memory) {\n        return ProxyLike(_starProxy).exec(_starSpell, abi.encodeWithSignature(\"execute()\"));\n    }\n\n    /// @dev Tries to execute a spell through its star proxy.\n    ///      Uses low-level call to avoid reverts in case of an error.\n    ///      Callers are expected to deal with failed calls.\n    /// @param _starProxy The proxy to execute the spell through.\n    /// @param _starSpell The spell to execute.\n    /// @return ok Whether the spell was executed successfully.\n    /// @return data The return data from the spell execution or error message.\n    function tryExecuteStarSpell(address _starProxy, address _starSpell) public returns (bool ok, bytes memory data) {\n        // Simple low-level call to handle errors without reverting\n        (bool success, bytes memory result) =\n            _starProxy.call(abi.encodeCall(ProxyLike.exec, (_starSpell, abi.encodeWithSignature(\"execute()\"))));\n\n        return (success, result);\n    }\n}\n"
    }
}