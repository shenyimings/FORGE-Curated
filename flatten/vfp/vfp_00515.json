{
    "vfp_id": "vfp_00515",
    "project_name": "cantina_centrifuge_aug2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "BalanceSheet::multicall() function can lose ETH in edge case scenario",
            "description": "The multicall() function in BalanceSheet implements batching functionality and is marked as payable, but it does not properly handle msg.value when processing empty data arrays. The root cause is the lack of validation or forwarding of msg.value to an appropriate handler, unlike Hub::multicall() and VaultRouter::multicall(), which do process msg.value. An attacker could call multicall() with a non-zero msg.value and an empty data array, causing the ETH to be lost since no operation is performed and no refund or deposit logic is triggered. This results in permanent loss of user funds in edge cases, especially when integrations assume safe handling of ETH payments during batched calls.\n",
            "severity": null,
            "location": [
                "BalanceSheet::multicall"
            ],
            "files": [
                "protocol-v3/src/spoke/BalanceSheet.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Inconsistent setting of isIncrease when delta is zero",
            "description": "When net deposits are zero, the isIncrease flag is set to true, which is inconsistent with the logic in submitQueuedShares, where shareQueue.isPositive returns false for zero delta. The cause is divergent logic in flag setting. This inconsistency could lead to incorrect state interpretation in frontends or off-chain systems that rely on isIncrease to determine deposit trends. While not a critical security flaw, it may result in misleading analytics or incorrect business logic decisions based on the flag.\n",
            "severity": null,
            "location": [
                "isIncrease",
                "submitQueuedShares"
            ],
            "files": [
                "protocol-v3/src/spoke/BalanceSheet.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ]
            },
            "title": "Gas savings by conditionally updating shareQueue",
            "description": "The shareQueue is updated unconditionally in certain functions, even when the new value is identical to the current one. This leads to unnecessary storage writes, increasing gas costs. The root cause is the lack of a dirty-check before updating. By adding a condition to only update when the value has changed, gas can be saved on every transaction where no actual change occurs. While the impact per transaction is small, the cumulative cost over many operations can be significant. No security impact, but optimization is recommended.\n",
            "severity": null,
            "location": [
                "shareQueue"
            ],
            "files": [
                "protocol-v3/src/spoke/BalanceSheet.sol"
            ]
        }
    ],
    "affected_files": {
        "BalanceSheet.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ISpoke} from \"./interfaces/ISpoke.sol\";\nimport {IShareToken} from \"./interfaces/IShareToken.sol\";\nimport {IBalanceSheet, ShareQueueAmount, AssetQueueAmount} from \"./interfaces/IBalanceSheet.sol\";\n\nimport {Auth} from \"../misc/Auth.sol\";\nimport {D18, d18} from \"../misc/types/D18.sol\";\nimport {IAuth} from \"../misc/interfaces/IAuth.sol\";\nimport {Recoverable} from \"../misc/Recoverable.sol\";\nimport {CastLib} from \"../misc/libraries/CastLib.sol\";\nimport {MathLib} from \"../misc/libraries/MathLib.sol\";\nimport {IERC6909} from \"../misc/interfaces/IERC6909.sol\";\nimport {Multicall, IMulticall} from \"../misc/Multicall.sol\";\nimport {SafeTransferLib} from \"../misc/libraries/SafeTransferLib.sol\";\nimport {TransientStorageLib} from \"../misc/libraries/TransientStorageLib.sol\";\n\nimport {PoolId} from \"../common/types/PoolId.sol\";\nimport {AssetId} from \"../common/types/AssetId.sol\";\nimport {IRoot} from \"../common/interfaces/IRoot.sol\";\nimport {IGateway} from \"../common/interfaces/IGateway.sol\";\nimport {ShareClassId} from \"../common/types/ShareClassId.sol\";\nimport {IPoolEscrow} from \"../common/interfaces/IPoolEscrow.sol\";\nimport {ISpokeMessageSender} from \"../common/interfaces/IGatewaySenders.sol\";\nimport {IBalanceSheetGatewayHandler} from \"../common/interfaces/IGatewayHandlers.sol\";\nimport {IPoolEscrowProvider} from \"../common/factories/interfaces/IPoolEscrowFactory.sol\";\n\n/// @title  Balance Sheet\n/// @notice Management contract that integrates all balance sheet functions of a pool:\n///         - Issuing and revoking shares\n///         - Depositing and withdrawing assets\n///         - Force transferring shares\n///\n///         Share and asset updates to the Hub are optionally queued, to reduce the cost\n///         per transaction. Dequeuing can be triggered locally by the manager or from the Hub.\ncontract BalanceSheet is Auth, Multicall, Recoverable, IBalanceSheet, IBalanceSheetGatewayHandler {\n    using MathLib for *;\n    using CastLib for bytes32;\n\n    IRoot public immutable root;\n\n    ISpoke public spoke;\n    ISpokeMessageSender public sender;\n    IPoolEscrowProvider public poolEscrowProvider;\n    IGateway public gateway;\n\n    mapping(PoolId => mapping(address => bool)) public manager;\n    mapping(PoolId poolId => mapping(ShareClassId scId => ShareQueueAmount)) public queuedShares;\n    mapping(PoolId poolId => mapping(ShareClassId scId => mapping(AssetId assetId => AssetQueueAmount))) public\n        queuedAssets;\n\n    constructor(IRoot root_, address deployer) Auth(deployer) {\n        root = root_;\n    }\n\n    /// @dev Check if the msg.sender is ward or a manager\n    modifier authOrManager(PoolId poolId) {\n        require(wards[msg.sender] == 1 || manager[poolId][msg.sender], IAuth.NotAuthorized());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheet\n    function file(bytes32 what, address data) external auth {\n        if (what == \"spoke\") spoke = ISpoke(data);\n        else if (what == \"sender\") sender = ISpokeMessageSender(data);\n        else if (what == \"gateway\") gateway = IGateway(data);\n        else if (what == \"poolEscrowProvider\") poolEscrowProvider = IPoolEscrowProvider(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IMulticall\n    /// @notice performs a multicall but all messages sent in the process will be batched\n    function multicall(bytes[] calldata data) public payable override {\n        bool wasBatching = gateway.isBatching();\n        if (!wasBatching) {\n            gateway.startBatching();\n        }\n\n        super.multicall(data);\n\n        if (!wasBatching) {\n            gateway.endBatching();\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Management functions\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheet\n    function deposit(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, uint128 amount)\n        external\n        authOrManager(poolId)\n    {\n        noteDeposit(poolId, scId, asset, tokenId, amount);\n\n        address escrow_ = address(escrow(poolId));\n        if (tokenId == 0) {\n            SafeTransferLib.safeTransferFrom(asset, msg.sender, escrow_, amount);\n        } else {\n            IERC6909(asset).transferFrom(msg.sender, escrow_, tokenId, amount);\n        }\n        emit Deposit(poolId, scId, asset, tokenId, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function noteDeposit(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, uint128 amount)\n        public\n        authOrManager(poolId)\n    {\n        AssetId assetId = spoke.assetToId(asset, tokenId);\n        escrow(poolId).deposit(scId, asset, tokenId, amount);\n\n        D18 pricePoolPerAsset_ = _pricePoolPerAsset(poolId, scId, assetId);\n        emit NoteDeposit(poolId, scId, asset, tokenId, amount, pricePoolPerAsset_);\n\n        _updateAssets(poolId, scId, assetId, amount, true);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function withdraw(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount\n    ) external authOrManager(poolId) {\n        AssetId assetId = spoke.assetToId(asset, tokenId);\n        IPoolEscrow escrow_ = escrow(poolId);\n        escrow_.withdraw(scId, asset, tokenId, amount);\n\n        D18 pricePoolPerAsset_ = _pricePoolPerAsset(poolId, scId, assetId);\n        emit Withdraw(poolId, scId, asset, tokenId, receiver, amount, pricePoolPerAsset_);\n\n        _updateAssets(poolId, scId, assetId, amount, false);\n\n        escrow_.authTransferTo(asset, tokenId, receiver, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function reserve(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, uint128 amount)\n        public\n        authOrManager(poolId)\n    {\n        escrow(poolId).reserve(scId, asset, tokenId, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function unreserve(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, uint128 amount)\n        public\n        authOrManager(poolId)\n    {\n        escrow(poolId).unreserve(scId, asset, tokenId, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function issue(PoolId poolId, ShareClassId scId, address to, uint128 shares) external authOrManager(poolId) {\n        emit Issue(poolId, scId, to, _pricePoolPerShare(poolId, scId), shares);\n\n        ShareQueueAmount storage shareQueue = queuedShares[poolId][scId];\n        if (shareQueue.isPositive || shareQueue.delta == 0) {\n            shareQueue.delta += shares;\n            shareQueue.isPositive = shareQueue.delta != 0;\n        } else if (shareQueue.delta >= shares) {\n            shareQueue.delta -= shares;\n            shareQueue.isPositive = false;\n        } else {\n            shareQueue.delta = shares - shareQueue.delta;\n            shareQueue.isPositive = true;\n        }\n\n        IShareToken token = spoke.shareToken(poolId, scId);\n        token.mint(to, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function revoke(PoolId poolId, ShareClassId scId, uint128 shares) external authOrManager(poolId) {\n        emit Revoke(poolId, scId, msg.sender, _pricePoolPerShare(poolId, scId), shares);\n\n        ShareQueueAmount storage shareQueue = queuedShares[poolId][scId];\n        if (!shareQueue.isPositive) {\n            shareQueue.delta += shares;\n        } else if (shareQueue.delta > shares) {\n            shareQueue.delta -= shares;\n        } else {\n            shareQueue.delta = shares - shareQueue.delta;\n            shareQueue.isPositive = false;\n        }\n\n        IShareToken token = spoke.shareToken(poolId, scId);\n        token.authTransferFrom(msg.sender, msg.sender, address(this), shares);\n        token.burn(address(this), shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function submitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId, uint128 extraGasLimit)\n        external\n        authOrManager(poolId)\n    {\n        AssetQueueAmount storage assetQueue = queuedAssets[poolId][scId][assetId];\n        ShareQueueAmount storage shareQueue = queuedShares[poolId][scId];\n\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, assetId);\n        uint32 assetCounter = (assetQueue.deposits != 0 || assetQueue.withdrawals != 0) ? 1 : 0;\n\n        ISpokeMessageSender.UpdateData memory data = ISpokeMessageSender.UpdateData({\n            netAmount: (assetQueue.deposits >= assetQueue.withdrawals)\n                ? assetQueue.deposits - assetQueue.withdrawals\n                : assetQueue.withdrawals - assetQueue.deposits,\n            isIncrease: assetQueue.deposits >= assetQueue.withdrawals,\n            isSnapshot: shareQueue.delta == 0 && shareQueue.queuedAssetCounter == assetCounter,\n            nonce: shareQueue.nonce\n        });\n\n        assetQueue.deposits = 0;\n        assetQueue.withdrawals = 0;\n        shareQueue.nonce++;\n        shareQueue.queuedAssetCounter -= assetCounter;\n\n        emit SubmitQueuedAssets(poolId, scId, assetId, data, pricePoolPerAsset);\n        sender.sendUpdateHoldingAmount(poolId, scId, assetId, data, pricePoolPerAsset, extraGasLimit);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function submitQueuedShares(PoolId poolId, ShareClassId scId, uint128 extraGasLimit)\n        external\n        authOrManager(poolId)\n    {\n        ShareQueueAmount storage shareQueue = queuedShares[poolId][scId];\n\n        ISpokeMessageSender.UpdateData memory data = ISpokeMessageSender.UpdateData({\n            netAmount: shareQueue.delta,\n            isIncrease: shareQueue.isPositive,\n            isSnapshot: queuedShares[poolId][scId].queuedAssetCounter == 0,\n            nonce: shareQueue.nonce\n        });\n\n        shareQueue.delta = 0;\n        shareQueue.isPositive = false;\n        shareQueue.nonce++;\n\n        emit SubmitQueuedShares(poolId, scId, data);\n        sender.sendUpdateShares(poolId, scId, data, extraGasLimit);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function transferSharesFrom(\n        PoolId poolId,\n        ShareClassId scId,\n        address sender_,\n        address from,\n        address to,\n        uint256 amount\n    ) external authOrManager(poolId) {\n        require(!root.endorsed(from), CannotTransferFromEndorsedContract());\n        IShareToken token = spoke.shareToken(poolId, scId);\n        token.authTransferFrom(sender_, from, to, amount);\n        emit TransferSharesFrom(poolId, scId, sender_, from, to, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function overridePricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 value)\n        external\n        authOrManager(poolId)\n    {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAsset\", poolId, scId, assetId)), value.raw());\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)), true);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function resetPricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId) external authOrManager(poolId) {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)), false);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function overridePricePoolPerShare(PoolId poolId, ShareClassId scId, D18 value) external authOrManager(poolId) {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerShare\", poolId, scId)), value.raw());\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerShareIsSet\", poolId, scId)), true);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function resetPricePoolPerShare(PoolId poolId, ShareClassId scId) external authOrManager(poolId) {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerShareIsSet\", poolId, scId)), false);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function updateManager(PoolId poolId, address who, bool canManage) external auth {\n        manager[poolId][who] = canManage;\n        emit UpdateManager(poolId, who, canManage);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheet\n    function escrow(PoolId poolId) public view returns (IPoolEscrow) {\n        return poolEscrowProvider.escrow(poolId);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function availableBalanceOf(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId)\n        public\n        view\n        returns (uint128)\n    {\n        return escrow(poolId).availableBalanceOf(scId, asset, tokenId);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal\n    //----------------------------------------------------------------------------------------------\n\n    function _updateAssets(PoolId poolId, ShareClassId scId, AssetId assetId, uint128 amount, bool isDeposit)\n        internal\n    {\n        if (amount == 0) return;\n        ShareQueueAmount storage shareQueue = queuedShares[poolId][scId];\n        AssetQueueAmount storage assetQueue = queuedAssets[poolId][scId][assetId];\n        if (assetQueue.deposits == 0 && assetQueue.withdrawals == 0) shareQueue.queuedAssetCounter++;\n        if (isDeposit) assetQueue.deposits += amount;\n        else assetQueue.withdrawals += amount;\n    }\n\n    function _pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId) internal view returns (D18) {\n        if (TransientStorageLib.tloadBool(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)))) {\n            return\n                d18(TransientStorageLib.tloadUint128(keccak256(abi.encode(\"pricePoolPerAsset\", poolId, scId, assetId))));\n        }\n\n        D18 pricePoolPerAsset = spoke.pricePoolPerAsset(poolId, scId, assetId, true);\n        return pricePoolPerAsset;\n    }\n\n    function _pricePoolPerShare(PoolId poolId, ShareClassId scId) internal view returns (D18) {\n        if (TransientStorageLib.tloadBool(keccak256(abi.encode(\"pricePoolPerShareIsSet\", poolId, scId)))) {\n            return d18(TransientStorageLib.tloadUint128(keccak256(abi.encode(\"pricePoolPerShare\", poolId, scId))));\n        }\n\n        D18 pricePoolPerShare = spoke.pricePoolPerShare(poolId, scId, true);\n        return pricePoolPerShare;\n    }\n}\n"
    }
}