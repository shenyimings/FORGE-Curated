{
    "vfp_id": "vfp_00201",
    "project_name": "EVM Emulator and Semi-abstracted Nonces Update Audit.md",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Unused Event",
            "description": "The `ValueSetUnderNonce` event is declared in the `INonceHolder` interface but is never emitted anywhere in the codebase.\nThe cause is the inclusion of an event definition without any corresponding emit statements, likely due to refactoring or oversight.\nWhile this does not pose a direct security risk, it can mislead developers into thinking the event is used for tracking state changes.\nThe impact is limited to reduced code clarity and maintainability, potentially leading to incorrect assumptions during future development.\n",
            "severity": "Low",
            "location": [
                "INonceHolder.sol#L14"
            ],
            "files": [
                "era-contracts/system-contracts/contracts/interfaces/INonceHolder.sol"
            ]
        }
    ],
    "affected_files": {
        "INonceHolder.sol": "// SPDX-License-Identifier: MIT\n// We use a floating point pragma here so it can be used within other projects that interact with the ZKsync ecosystem without using our exact pragma version.\npragma solidity ^0.8.20;\n\n/**\n * @author Matter Labs\n * @dev Interface of the nonce holder contract -- a contract used by the system to ensure\n * that there is always a unique identifier for a transaction with a particular account (we call it nonce).\n * In other words, the pair of (address, nonce) should always be unique.\n * @dev Custom accounts should use methods of this contract to store nonces or other possible unique identifiers\n * for the transaction.\n */\ninterface INonceHolder {\n    event ValueSetUnderNonce(address indexed accountAddress, uint256 indexed key, uint256 value);\n\n    /// @dev Returns the current minimal nonce for account.\n    function getMinNonce(address _address) external view returns (uint256);\n\n    /// @dev Returns the raw version of the current minimal nonce\n    /// (equal to minNonce + 2^128 * deployment nonce).\n    function getRawNonce(address _address) external view returns (uint256);\n\n    /// @dev Increases the minimal nonce for the msg.sender.\n    function increaseMinNonce(uint256 _value) external returns (uint256);\n\n    /// @dev A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`, for non-keyed nonces.\n    function incrementMinNonceIfEquals(uint256 _expectedNonce) external;\n\n    /// @dev A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`, for keyed nonces.\n    function incrementMinNonceIfEqualsKeyed(uint256 _expectedNonce) external;\n\n    /// @dev Returns the deployment nonce for the accounts used for CREATE opcode.\n    function getDeploymentNonce(address _address) external view returns (uint256);\n\n    /// @dev Increments the deployment nonce for the account and returns the previous one.\n    function incrementDeploymentNonce(address _address) external returns (uint256);\n\n    /// @dev Determines whether a certain nonce has been already used for an account.\n    function validateNonceUsage(address _address, uint256 _key, bool _shouldBeUsed) external view;\n\n    /// @dev Returns whether a nonce has been used for an account.\n    function isNonceUsed(address _address, uint256 _nonce) external view returns (bool);\n}\n"
    }
}