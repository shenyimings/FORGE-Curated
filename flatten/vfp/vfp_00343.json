{
    "vfp_id": "vfp_00343",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 57,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused code reduces readability",
            "description": "Several functions and variables (e.g., incrementMemberUnbondedValidatorCount, nodeRewards, penalties, onlyRPLWithdrawalAddressOrNode, \"node.megapool.minimum.stake\") are unused, likely legacy artifacts.\nThe cause is incomplete cleanup during development or upgrades.\nUnused code increases complexity, reduces readability, and risks accidental misuse in future changes.\nThe impact is maintenance burden and potential for bugs, though no direct security vulnerability exists.\n",
            "severity": "Informational",
            "location": [
                "RocketDAONodeTrusted.sol#L135-L142",
                "RocketMegapoolDelegateBase.sol#L72-L83",
                "RocketMegapoolStorageLayout.sol#L69",
                "RocketMegapoolStorageLayout.sol#L86",
                "RocketUpgradeOneDotFour.sol#L188"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrusted.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAONodeTrusted.sol": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../RocketBase.sol\";\nimport \"../../../interface/RocketVaultInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedProposalsInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedActionsInterface.sol\";\nimport \"../../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMembersInterface.sol\";\nimport \"../../../interface/dao/RocketDAOProposalInterface.sol\";\nimport \"../../../interface/util/AddressSetStorageInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n// The Trusted Node DAO \ncontract RocketDAONodeTrusted is RocketBase, RocketDAONodeTrustedInterface {\n\n    using SafeMath for uint;\n\n    // The namespace for any data stored in the trusted node DAO (do not change)\n    string constant daoNameSpace = \"dao.trustednodes.\";\n\n    // Min amount of trusted node members required in the DAO\n    uint256 constant daoMemberMinCount = 3;\n\n\n    // Only allow bootstrapping when enabled\n    modifier onlyBootstrapMode() {\n        require(getBootstrapModeDisabled() == false, \"Bootstrap mode not engaged\");\n        _;\n    }\n\n    // Only when the DAO needs new members due to being below the required min\n    modifier onlyLowMemberMode() {\n        require(getMemberCount() < daoMemberMinCount, \"Low member mode not engaged\");\n        _;\n    }\n    \n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Version\n        version = 1;\n    }\n\n\n\n    /**** DAO Properties **************/\n\n    // Returns true if bootstrap mode is disabled\n    function getBootstrapModeDisabled() override public view returns (bool) { \n        return getBool(keccak256(abi.encodePacked(daoNameSpace, \"bootstrapmode.disabled\"))); \n    }\n    \n\n    /*** Proposals ****************/\n\n    \n    // Return the amount of member votes need for a proposal to pass\n    function getMemberQuorumVotesRequired() override external view returns (uint256) {\n        // Load contracts\n        RocketDAONodeTrustedSettingsMembersInterface rocketDAONodeTrustedSettingsMembers = RocketDAONodeTrustedSettingsMembersInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMembers\"));\n        // Calculate and return votes required\n        return getMemberCount().mul(rocketDAONodeTrustedSettingsMembers.getQuorum());\n    }\n\n\n    /*** Members ******************/\n\n    // Return true if the node addressed passed is a member of the trusted node DAO\n    function getMemberIsValid(address _nodeAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoNameSpace, \"member\", _nodeAddress))); \n    }\n    \n    // Get a trusted node member address by index\n    function getMemberAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(daoNameSpace, \"member.index\")), _index);\n    }\n\n    // Total number of members in the current trusted node DAO\n    function getMemberCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(daoNameSpace, \"member.index\")));\n    }\n\n    // Min required member count for the DAO \n    function getMemberMinRequired() override external pure returns (uint256) {\n        return daoMemberMinCount;\n    }\n\n    // Get the last time this user made a proposal\n    function getMemberLastProposalTime(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.proposal.lasttime\", _nodeAddress)));\n    }\n\n    // Get the ID of a trusted node member\n    function getMemberID(address _nodeAddress) override external view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(daoNameSpace, \"member.id\", _nodeAddress))); \n    }\n\n    // Get the URL of a trusted node member\n    function getMemberUrl(address _nodeAddress) override external view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(daoNameSpace, \"member.url\", _nodeAddress))); \n    }\n\n    // Get the block the member joined at\n    function getMemberJoinedTime(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.joined.time\", _nodeAddress)));\n    } \n\n    // Get data that was recorded about a proposal that was executed\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.executed.time\", _proposalType, _nodeAddress)));\n    }\n\n    // Get the RPL bond amount the user deposited to join\n    function getMemberRPLBondAmount(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.bond.rpl\", _nodeAddress))); \n    }\n\n    // Is this member currently being 'challenged' to see if their node is responding\n    function getMemberIsChallenged(address _nodeAddress) override external view returns (bool) {\n        // Has this member been challenged recently and still within the challenge window to respond? If there is a challenge block recorded against them, they are actively being challenged.\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.challenged.time\", _nodeAddress))) > 0 ? true : false;\n    }\n\n    // How many unbonded validators this member has\n    function getMemberUnbondedValidatorCount(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoNameSpace, \"member.validator.unbonded.count\", _nodeAddress)));\n    }\n\n    // Increment/decrement a member's unbonded validator count\n    // Only accepts calls from the RocketMinipoolManager contract\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) override external onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) onlyLatestContract(\"rocketMinipoolManager\", msg.sender) {\n        addUint(keccak256(abi.encodePacked(daoNameSpace, \"member.validator.unbonded.count\", _nodeAddress)), 1);\n    }\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) override external onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        subUint(keccak256(abi.encodePacked(daoNameSpace, \"member.validator.unbonded.count\", _nodeAddress)), 1);\n    }\n\n\n    /**** Bootstrapping ***************/\n\n    \n    // Bootstrap mode - In bootstrap mode, guardian can add members at will\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) override external onlyGuardian onlyBootstrapMode onlyRegisteredNode(_nodeAddress) onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) {\n        // Ok good to go, lets add them\n        RocketDAONodeTrustedProposalsInterface(getContractAddress(\"rocketDAONodeTrustedProposals\")).proposalInvite(_id, _url, _nodeAddress);\n    }\n\n\n    // Bootstrap mode - Uint Setting\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) {\n        // Ok good to go, lets update the settings \n        RocketDAONodeTrustedProposalsInterface(getContractAddress(\"rocketDAONodeTrustedProposals\")).proposalSettingUint(_settingContractName, _settingPath, _value);\n    }\n\n    // Bootstrap mode - Bool Setting\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) {\n        // Ok good to go, lets update the settings \n        RocketDAONodeTrustedProposalsInterface(getContractAddress(\"rocketDAONodeTrustedProposals\")).proposalSettingBool(_settingContractName, _settingPath, _value);\n    }\n\n\n    // Bootstrap mode - Upgrade contracts or their ABI\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) {\n        // Ok good to go, lets update the settings \n        RocketDAONodeTrustedProposalsInterface(getContractAddress(\"rocketDAONodeTrustedProposals\")).proposalUpgrade(_type, _name, _contractAbi, _contractAddress);\n    }\n\n    // Bootstrap mode - Disable RP Access (only RP can call this to hand over full control to the DAO)\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) override external onlyGuardian onlyBootstrapMode onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) {\n        require(_confirmDisableBootstrapMode == true, \"You must confirm disabling bootstrap mode, it can only be done once!\");\n        setBool(keccak256(abi.encodePacked(daoNameSpace, \"bootstrapmode.disabled\")), true); \n    }\n\n \n    /**** Recovery ***************/\n        \n    // In an explicable black swan scenario where the DAO loses more than the min membership required (3), this method can be used by a regular node operator to join the DAO\n    // Must have their ID, URL, current RPL bond amount available and must be called by their current registered node account\n    function memberJoinRequired(string memory _id, string memory _url) override external onlyLowMemberMode onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrusted\", address(this)) {\n        // Ok good to go, lets update the settings \n        RocketDAONodeTrustedProposalsInterface(getContractAddress(\"rocketDAONodeTrustedProposals\")).proposalInvite(_id, _url, msg.sender);\n        // Get the to automatically join as a member (by a regular proposal, they would have to manually accept, but this is no ordinary situation)\n        RocketDAONodeTrustedActionsInterface(getContractAddress(\"rocketDAONodeTrustedActions\")).actionJoinRequired(msg.sender);\n    }\n\n}\n"
    }
}