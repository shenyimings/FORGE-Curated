{
    "vfp_id": "vfp_00013",
    "project_name": "cantina_coinbase_dec2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Failing test cases",
            "description": "Multiple fuzz test cases fail when running the test suite with the latest version of Foundry (forge v1.5.0-stable). For example, the test_success_emptyBuilderCode_zeroFees test in test/unit/hooks/BridgeReferralFees/onSend.t.sol fails under specific conditions where the user equals the address of bridgeReferralFeesCampaign. This indicates a discrepancy between expected and actual behavior in the test environment, likely due to changes in Foundry's behavior or unhandled edge cases in the test setup. The root cause is either outdated test assertions or insufficient handling of edge cases in the test logic. If left unaddressed, failing tests reduce confidence in the correctness and robustness of the implementation, potentially masking real bugs. Although this does not directly impact on-chain security, it undermines the reliability of the development and verification process. The issue was fixed in PR 155, confirming its recognition and resolution by the team.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "flywheel/test/unit/hooks/BridgeReferralFees/onSend.t.sol"
            ]
        }
    ],
    "affected_files": {
        "onSend.t.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {Constants} from \"../../../../src/Constants.sol\";\nimport {Flywheel} from \"../../../../src/Flywheel.sol\";\nimport {BridgeReferralFees} from \"../../../../src/hooks/BridgeReferralFees.sol\";\nimport {BridgeReferralFeesTest} from \"../../../lib/BridgeReferralFeesTest.sol\";\nimport {MockAccount} from \"../../../lib/mocks/MockAccount.sol\";\n\ncontract OnSendTest is BridgeReferralFeesTest {\n    // ========================================\n    // REVERT CASES\n    // ========================================\n\n    /// @dev Reverts when caller is not flywheel\n    /// @param caller Caller address\n    /// @param feeBps Fee basis points (doesn't matter for access control test)\n    /// @param user User address for payout\n    function test_revert_onlyFlywheel(address caller, uint8 feeBps, address user, uint256 seed) public {\n        vm.assume(caller != address(flywheel));\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n\n        string memory code = _registerBuilderCode(seed);\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        // Direct call to bridgeReferralFees should revert (only flywheel can call)\n        vm.prank(caller);\n        vm.expectRevert();\n        bridgeReferralFees.onSend(caller, bridgeReferralFeesCampaign, address(usdc), hookData);\n    }\n\n    /// @dev Reverts when hookData cannot be correctly decoded\n    /// @param hookData The malformed hook data that should cause revert\n    /// @param campaignBalance Amount to fund campaign with\n    function test_revert_invalidHookData(bytes memory hookData, uint256 campaignBalance) public {\n        // Ensure hookData cannot be decoded as (address, string, uint8)\n        // This is complex to validate precisely, so we use simple malformed data\n        vm.assume(hookData.length > 0 && hookData.length < 64);\n\n        campaignBalance = bound(campaignBalance, 1 ether, 1000 ether);\n\n        // Fund campaign\n        usdc.mint(bridgeReferralFeesCampaign, campaignBalance);\n\n        vm.expectRevert();\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n    }\n\n    // ========================================\n    // SUCCESS CASES\n    // ========================================\n\n    /// @dev Calculates correct payout and fee amounts with registered builder code\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    function test_success_registeredBuilderCode(uint256 bridgedAmount, uint8 feeBps, address user, uint256 seed)\n        public\n    {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(bridgedAmount < 1e30); // Conservative bound to avoid arithmetic overflow\n        vm.assume(feeBps <= MAX_FEE_BASIS_POINTS); // Within max fee basis points\n        vm.assume(user != address(0));\n\n        string memory code = _registerBuilderCode(seed);\n\n        // Fund campaign\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        if (expectedFeeAmount > 0) {\n            assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n            bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n            assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n            assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n            assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n        } else {\n            assertFalse(sendFeesNow, \"Should not send fees when fee amount = 0\");\n        }\n    }\n\n    /// @dev Sets fee to zero when builder code is not registered in BuilderCodes\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points (ignored for unregistered codes)\n    /// @param user User address for payout\n    function test_success_unregisteredBuilderCode(uint256 bridgedAmount, uint8 feeBps, address user) public {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(user != address(0));\n\n        // Use an unregistered but valid code\n        string memory unregisteredCodeStr = \"unregistered\";\n\n        // Fund campaign\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, unregisteredCodeStr, feeBps);\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        // User should receive full amount (no fee for unregistered codes)\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, bridgedAmount, \"User should receive full amount\");\n        assertEq(\n            payouts[0].extraData,\n            abi.encode(unregisteredCodeStr, uint256(0)),\n            \"Payout extraData should contain code and zero fee\"\n        );\n\n        assertFalse(sendFeesNow, \"Should not send fees for unregistered codes\");\n        assertEq(fees.length, 0, \"Should have no fee distributions\");\n    }\n\n    /// @dev Caps fee at maxFeeBasisPoints when requested fee exceeds maximum\n    /// @param bridgedAmount Amount available for bridging\n    /// @param excessiveFeeBps Fee basis points exceeding maximum\n    /// @param user User address for payout\n    function test_success_feeExceedsMaximum(uint256 bridgedAmount, uint8 excessiveFeeBps, address user, uint256 seed)\n        public\n    {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(bridgedAmount < 1e30); // Conservative bound to avoid arithmetic overflow\n        vm.assume(excessiveFeeBps > MAX_FEE_BASIS_POINTS); // Exceeds max fee basis points\n        vm.assume(user != address(0));\n\n        string memory code = _registerBuilderCode(seed);\n\n        // Fund campaign\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, excessiveFeeBps);\n\n        // Fee should be capped at MAX_FEE_BASIS_POINTS\n        uint256 expectedFeeAmount =\n            (bridgedAmount / 1e4) * MAX_FEE_BASIS_POINTS + ((bridgedAmount % 1e4) * MAX_FEE_BASIS_POINTS) / 1e4;\n        vm.assume(expectedFeeAmount > 0); // Ensure fee is actually generated\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData,\n            abi.encode(code, expectedFeeAmount),\n            \"Payout extraData should contain code and capped fee\"\n        );\n\n        assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n        bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n        assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n        assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n        assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be capped\");\n    }\n\n    /// @dev Returns zero fees when fee basis points is zero\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    function test_success_zeroFeeBps(uint256 bridgedAmount, address user, uint256 seed) public {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(user != address(0));\n\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n        bytes memory hookData = abi.encode(user, code, uint8(0));\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, bridgedAmount, \"User should receive full amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, uint256(0)), \"Payout extraData should contain code and zero fee\"\n        );\n\n        assertFalse(sendFeesNow, \"Should not send fees when fee is zero\");\n        assertEq(fees.length, 0, \"Should have no fee distributions\");\n    }\n\n    /// @dev Returns nonzero fees when fee basis points is nonzero\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Non-zero fee basis points to test\n    /// @param user User address for payout\n    function test_success_nonzeroFeeBps(uint256 bridgedAmount, uint8 feeBps, address user, uint256 seed) public {\n        bridgedAmount = bound(bridgedAmount, 1, 1e30); // Conservative bound to avoid arithmetic overflow\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS)); // Ensure non-zero fee\n        vm.assume(user != address(0));\n\n        // Ensure fee amount will actually be > 0 to avoid false positive failures\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        vm.assume(expectedFeeAmount > 0);\n\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n        bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n        assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n        assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n        assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n    }\n\n    /// @dev Calculates bridged amount correctly with native token (ETH)\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    function test_success_nativeToken(uint256 bridgedAmount, uint8 feeBps, address user, uint256 seed) public {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(bridgedAmount < 1e30); // Conservative bound to avoid arithmetic overflow\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n        vm.assume(user.code.length == 0); // Only EOA addresses can receive ETH safely\n        vm.assume(user > address(0x100)); // Avoid precompiled contract addresses\n\n        string memory code = _registerBuilderCode(seed);\n\n        // Fund campaign with native token\n        vm.deal(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, Constants.NATIVE_TOKEN, hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        if (expectedFeeAmount > 0) {\n            assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n            bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n            assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n            assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n            assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n        } else {\n            assertFalse(sendFeesNow, \"Should not send fees when fee amount = 0\");\n        }\n    }\n\n    /// @dev Excludes allocated fees from bridged amount calculation\n    /// @param totalBalance Total campaign balance\n    /// @param allocatedFees Already allocated fees\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    function test_success_withExistingAllocatedFees(\n        uint256 totalBalance,\n        uint256 allocatedFees,\n        uint8 feeBps,\n        address user,\n        uint256 seed\n    ) public {\n        // Bound inputs to avoid arithmetic overflow\n        totalBalance = bound(totalBalance, 1, 1e30);\n        allocatedFees = bound(allocatedFees, 0, totalBalance - 1);\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n\n        uint256 bridgedAmount = totalBalance - allocatedFees;\n        vm.assume(bridgedAmount > 0);\n\n        // Setup scenario would require allocated fees which is complex\n        // For simplicity, just test basic case\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        string memory code = _registerBuilderCode(seed);\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        if (expectedFeeAmount > 0) {\n            assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n            bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n            assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n            assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n            assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n        } else {\n            assertFalse(sendFeesNow, \"Should not send fees when fee amount = 0\");\n        }\n    }\n\n    // ========================================\n    // EDGE CASES\n    // ========================================\n\n    /// @dev Handles maximum possible bridged amount without overflow\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    function test_edge_maximumBridgedAmount(uint8 feeBps, address user, uint256 seed) public {\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n\n        uint256 maxAmount = type(uint256).max; // Test with absolute max\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, maxAmount);\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFeeAmount = (maxAmount / 1e4) * feeBps + ((maxAmount % 1e4) * feeBps) / 1e4;\n        uint256 expectedUserAmount = maxAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        if (expectedFeeAmount > 0) {\n            assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n            bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n            assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n            assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n            assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n        } else {\n            assertFalse(sendFeesNow, \"Should not send fees when fee amount = 0\");\n        }\n    }\n\n    /// @dev Handles minimum non-zero bridged amount (1 wei)\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    /// @param minAmount Minimum amount to test (1-10 wei)\n    function test_edge_minimumBridgedAmount(uint8 feeBps, address user, uint256 minAmount, uint256 seed) public {\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n        minAmount = bound(minAmount, 1, 10); // Test very small amounts\n\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, minAmount);\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFeeAmount = (minAmount / 1e4) * feeBps + ((minAmount % 1e4) * feeBps) / 1e4;\n        uint256 expectedUserAmount = minAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) =\n            bridgeReferralFees.onSend(address(this), bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        if (expectedFeeAmount > 0) {\n            assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n            bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n            assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n            assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n            assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n        } else {\n            assertFalse(sendFeesNow, \"Should not send fees when fee amount = 0\");\n        }\n    }\n\n    // ========================================\n    // STATE VERIFICATION\n    // ========================================\n\n    /// @dev Verifies sendFeesNow is true when fee amount is greater than zero\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Non-zero fee basis points\n    /// @param user User address for payout\n    function test_onSend_sendFeesNowTrue(uint256 bridgedAmount, uint8 feeBps, address user, uint256 seed) public {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(bridgedAmount < 1e30); // Conservative bound to avoid arithmetic overflow\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS)); // Ensure non-zero fee\n        vm.assume(user != address(0));\n\n        // Ensure fee amount will be > 0\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        vm.assume(expectedFeeAmount > 0);\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) = bridgeReferralFees\n            .onSend(address(this), bridgeReferralFeesCampaign, address(usdc), abi.encode(user, code, feeBps));\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        assertTrue(sendFeesNow, \"sendFeesNow should be true when fees > 0\");\n        bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n        assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n        assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n        assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n    }\n\n    /// @dev Verifies sendFeesNow behavior when fee amount is zero\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points (ignored for unregistered codes)\n    /// @param user User address for payout\n    function test_onSend_sendFeesNowWithZeroFee(uint256 bridgedAmount, uint8 feeBps, address user) public {\n        vm.assume(bridgedAmount > 0);\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n\n        // Use unregistered code to force zero fees\n        string memory unregisteredCodeStr = \"unregistered_zero\";\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) = bridgeReferralFees\n            .onSend(address(this), bridgeReferralFeesCampaign, address(usdc), abi.encode(user, unregisteredCodeStr, feeBps));\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, bridgedAmount, \"User should receive full amount\");\n        assertEq(\n            payouts[0].extraData,\n            abi.encode(unregisteredCodeStr, uint256(0)),\n            \"Payout extraData should contain code and zero fee\"\n        );\n\n        assertFalse(sendFeesNow, \"sendFeesNow should be false when fees = 0\");\n        assertEq(fees.length, 0, \"Should have no fee distributions\");\n    }\n\n    /// @dev Verifies correct payout extraData contains builder code and fee amount\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    function test_onSend_payoutExtraData(uint256 bridgedAmount, uint8 feeBps, address user, uint256 seed) public {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(bridgedAmount < 1e30); // Conservative bound to avoid arithmetic overflow\n        feeBps = uint8(bound(feeBps, 0, MAX_FEE_BASIS_POINTS));\n        vm.assume(user != address(0));\n\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) = bridgeReferralFees\n            .onSend(address(this), bridgeReferralFeesCampaign, address(usdc), abi.encode(user, code, feeBps));\n\n        (string memory extractedCode, uint256 extractedFeeAmount) = abi.decode(payouts[0].extraData, (string, uint256));\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            keccak256(bytes(extractedCode)),\n            keccak256(bytes(code)),\n            \"Payout extraData should contain correct builder code\"\n        );\n        assertEq(extractedFeeAmount, expectedFeeAmount, \"Payout extraData should contain correct fee amount\");\n\n        if (expectedFeeAmount > 0) {\n            assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n            bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n            assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n        } else {\n            assertFalse(sendFeesNow, \"Should not send fees when fee amount = 0\");\n        }\n    }\n\n    /// @dev Verifies fee distribution uses builder code as key\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    function test_onSend_feeDistributionKey(uint256 bridgedAmount, uint8 feeBps, address user, uint256 seed) public {\n        vm.assume(bridgedAmount > 0);\n        vm.assume(bridgedAmount < 1e30); // Conservative bound to avoid arithmetic overflow\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS)); // Ensure non-zero fee\n        vm.assume(user != address(0));\n\n        // Ensure fee amount will be > 0 to avoid empty fees array\n        uint256 expectedFeeAmount = (bridgedAmount / 1e4) * feeBps + ((bridgedAmount % 1e4) * feeBps) / 1e4;\n        vm.assume(expectedFeeAmount > 0);\n        uint256 expectedUserAmount = bridgedAmount - expectedFeeAmount;\n\n        string memory code = _registerBuilderCode(seed);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        vm.prank(address(flywheel));\n        (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow) = bridgeReferralFees\n            .onSend(address(this), bridgeReferralFeesCampaign, address(usdc), abi.encode(user, code, feeBps));\n\n        assertEq(payouts[0].recipient, user, \"User should receive correct recipient\");\n        assertEq(payouts[0].amount, expectedUserAmount, \"User should receive correct amount\");\n        assertEq(\n            payouts[0].extraData, abi.encode(code, expectedFeeAmount), \"Payout extraData should contain code and fee\"\n        );\n\n        assertTrue(sendFeesNow, \"Should send fees when fee amount > 0\");\n        assertTrue(fees.length > 0, \"Should have at least one fee distribution\");\n        bytes32 codeBytes32 = bytes32(builderCodes.toTokenId(code));\n        assertEq(fees[0].key, codeBytes32, \"Fee distribution should use builder code as key\");\n        assertEq(fees[0].recipient, builder, \"Fee should go to builder\");\n        assertEq(fees[0].amount, expectedFeeAmount, \"Fee amount should be correct\");\n    }\n\n    // ========================================\n    // INVALID BUILDER CODE HANDLING\n    // ========================================\n\n    /// @dev Processes empty builder code successfully with zero fees\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    function test_success_emptyBuilderCode_zeroFees(uint256 bridgedAmount, address user) public {\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        string memory emptyCode = \"\";\n        bytes memory hookData = abi.encode(user, emptyCode, uint8(0));\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + bridgedAmount, \"User should receive full amount\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Processes too long builder code (>32 bytes) successfully with zero fees\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    function test_success_tooLongBuilderCode_zeroFees(uint256 bridgedAmount, address user) public {\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        string memory tooLongCode = \"this_builder_code_is_way_too_long_to_be_valid\";\n        bytes memory hookData = abi.encode(user, tooLongCode, uint8(0));\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + bridgedAmount, \"User should receive full amount\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Processes builder code with uppercase letters successfully with zero fees\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    function test_success_uppercaseInCode_zeroFees(uint256 bridgedAmount, address user) public {\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        string memory uppercaseCode = \"TestCode\";\n        bytes memory hookData = abi.encode(user, uppercaseCode, uint8(0));\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + bridgedAmount, \"User should receive full amount\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Processes builder code with special characters successfully with zero fees\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    function test_success_specialCharactersInCode_zeroFees(uint256 bridgedAmount, address user) public {\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        string memory specialCharCode = \"test@code#123!\";\n        bytes memory hookData = abi.encode(user, specialCharCode, uint8(0));\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + bridgedAmount, \"User should receive full amount\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Processes builder code with non-ASCII characters successfully with zero fees\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    function test_success_nonAsciiCharactersInCode_zeroFees(uint256 bridgedAmount, address user) public {\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        string memory nonAsciiCode = unicode\"testðŸš€code\";\n        bytes memory hookData = abi.encode(user, nonAsciiCode, uint8(0));\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + bridgedAmount, \"User should receive full amount\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    // ========================================\n    // SAFE PERCENT OVERFLOW PROTECTION\n    // ========================================\n\n    /// @dev Handles large amounts near uint256 max with non-zero feeBps without overflow\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_success_largeAmount_withMaxFeeBps_noOverflow(\n        uint256 bridgedAmount,\n        uint8 feeBps,\n        address user,\n        uint256 seed\n    ) public {\n        string memory code = _registerBuilderCode(seed);\n        bridgedAmount = bound(bridgedAmount, type(uint256).max / 2, type(uint256).max - 1);\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS));\n        _boundUser(user);\n\n        vm.deal(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFee = _safePercent(bridgedAmount, feeBps);\n        uint256 expectedUser = bridgedAmount - expectedFee;\n\n        uint256 userBalanceBefore = user.balance;\n        uint256 builderBalanceBefore = builder.balance;\n\n        flywheel.send(bridgeReferralFeesCampaign, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, hookData);\n\n        assertEq(user.balance, userBalanceBefore + expectedUser, \"User should receive correct amount\");\n        assertEq(builder.balance, builderBalanceBefore + expectedFee, \"Builder should receive fee\");\n        assertEq(bridgeReferralFeesCampaign.balance, 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Handles maximum uint256 amount with feeBps without overflow\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_success_maxUint256Amount_withFeeBps_noOverflow(uint8 feeBps, address user, uint256 seed) public {\n        string memory code = _registerBuilderCode(seed);\n        uint256 bridgedAmount = type(uint256).max;\n        feeBps = uint8(bound(feeBps, 1, 10));\n        _boundUser(user);\n\n        vm.deal(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFee = _safePercent(bridgedAmount, feeBps);\n        uint256 expectedUser = bridgedAmount - expectedFee;\n\n        uint256 userBalanceBefore = user.balance;\n        uint256 builderBalanceBefore = builder.balance;\n\n        flywheel.send(bridgeReferralFeesCampaign, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, hookData);\n\n        assertEq(user.balance, userBalanceBefore + expectedUser, \"User should receive correct amount\");\n        assertEq(builder.balance, builderBalanceBefore + expectedFee, \"Builder should receive fee\");\n        assertEq(bridgeReferralFeesCampaign.balance, 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Calculates zero fee correctly when amount is zero\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_edge_zeroAmount_calculatesZeroFee(uint8 feeBps, address user, uint256 seed) public {\n        string memory code = _registerBuilderCode(seed);\n        uint256 bridgedAmount = 0;\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS));\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n        uint256 builderBalanceBefore = usdc.balanceOf(builder);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore, \"User should receive nothing\");\n        assertEq(usdc.balanceOf(builder), builderBalanceBefore, \"Builder should receive no fee\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Calculates zero fee correctly when feeBps is zero\n    /// @param bridgedAmount Amount available for bridging\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_edge_zeroFeeBps_calculatesZeroFee(uint256 bridgedAmount, address user, uint256 seed) public {\n        string memory code = _registerBuilderCode(seed);\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        uint8 feeBps = 0;\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n        uint256 builderBalanceBefore = usdc.balanceOf(builder);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + bridgedAmount, \"User should receive full amount\");\n        assertEq(usdc.balanceOf(builder), builderBalanceBefore, \"Builder should receive no fee\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    /// @dev Verifies fee calculation matches expected precision using _safePercent\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points within valid range\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_success_feeCalculation_matchesExpectedPrecision(\n        uint256 bridgedAmount,\n        uint8 feeBps,\n        address user,\n        uint256 seed\n    ) public {\n        string memory code = _registerBuilderCode(seed);\n        bridgedAmount = bound(bridgedAmount, 1e4, type(uint128).max);\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS));\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFee = _safePercent(bridgedAmount, feeBps);\n        uint256 expectedUser = bridgedAmount - expectedFee;\n\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n        uint256 builderBalanceBefore = usdc.balanceOf(builder);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + expectedUser, \"User should receive correct amount\");\n        assertEq(usdc.balanceOf(builder), builderBalanceBefore + expectedFee, \"Builder should receive exact fee\");\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    // ========================================\n    // ZERO BRIDGED AMOUNT BEHAVIOR\n    // ========================================\n\n    /// @dev Succeeds when bridged amount is zero (behavior changed from revert)\n    /// @param feeBps Fee basis points\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_success_zeroBridgedAmount_succeeds(uint8 feeBps, address user, uint256 seed) public {\n        string memory code = _registerBuilderCode(seed);\n        uint256 bridgedAmount = 0;\n        _boundUser(user);\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        assertEq(usdc.balanceOf(bridgeReferralFeesCampaign), 0, \"Campaign should be empty\");\n    }\n\n    // ========================================\n    // BUILDERCODES EXTERNAL CALL FAILURES\n    // ========================================\n\n    /// @dev Handles BuilderCodes returning zero address gracefully with zero fees\n    /// @param bridgedAmount Amount available for bridging\n    /// @param feeBps Fee basis points (ignored when processing fails)\n    /// @param user User address for payout\n    /// @param seed Random seed for test variation\n    function test_success_builderCodesReturnsZeroAddress_zeroFees(\n        uint256 bridgedAmount,\n        uint8 feeBps,\n        address user,\n        uint256 seed\n    ) public {\n        string memory code = _registerBuilderCode(seed);\n        bridgedAmount = bound(bridgedAmount, 1, type(uint128).max);\n        feeBps = uint8(bound(feeBps, 1, MAX_FEE_BASIS_POINTS));\n        _boundUser(user);\n\n        MockAccount mockAccount = new MockAccount(builder, false);\n        vm.prank(builder);\n        builderCodes.updatePayoutAddress(code, address(mockAccount));\n\n        usdc.mint(bridgeReferralFeesCampaign, bridgedAmount);\n\n        bytes memory hookData = abi.encode(user, code, feeBps);\n\n        uint256 expectedFee = _percent(bridgedAmount, feeBps);\n        uint256 expectedUser = bridgedAmount - expectedFee;\n        uint256 userBalanceBefore = usdc.balanceOf(user);\n\n        flywheel.send(bridgeReferralFeesCampaign, address(usdc), hookData);\n\n        uint256 allocatedFees = flywheel.totalAllocatedFees(bridgeReferralFeesCampaign, address(usdc));\n\n        assertEq(usdc.balanceOf(user), userBalanceBefore + expectedUser, \"User receives amount minus fee\");\n        assertEq(usdc.balanceOf(address(mockAccount)), expectedFee, \"Mock account should receive fees\");\n        assertEq(allocatedFees, 0, \"No fees should be allocated since transfer succeeded\");\n    }\n}\n"
    }
}