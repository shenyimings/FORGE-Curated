{
    "vfp_id": "vfp_00077",
    "project_name": "cantina_sky_spark_alm_controller_july2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Withdrawing from ERC4626 and Aave requires deposit rate limits to be set",
            "description": "The vulnerability arises when users attempt to withdraw from ERC4626 or Aave vaults via withdrawERC4626, redeemERC4626, or withdrawAave functions, which consume the WITHDRAW rate limit and reset the corresponding DEPOSIT rate limits. The root cause is that resetting the DEPOSIT limit requires the existing DEPOSIT limit to be non-zero, as enforced by a require statement in the rate limiter: require(maxAmount > 0, \"RateLimits/zero-maxAmount\"). An attacker cannot trigger a reset if the DEPOSIT limit was previously zero, potentially blocking legitimate withdrawals that depend on this reset mechanism. This leads to a functional restriction where operators must maintain a non-zero deposit limit, even if deposits are not intended, to allow withdrawals to succeed.\n",
            "severity": "Low",
            "location": [
                "MainnetController.sol::withdrawERC4626#L319",
                "MainnetController.sol::redeemERC4626#L319",
                "MainnetController.sol::withdrawAave#L319"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol",
                "spark-alm-controller/src/ForeignController.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Cannot perform a pure staking farm rewards claim",
            "description": "The contract does not support claiming staking rewards without also performing a withdrawal from the farm, due to the withdraw function reverting when the amount is zero. The root cause is the require(amount > 0, \"Cannot withdraw 0\") check in the farm's withdraw function, which forces any call to withdrawFromFarm to include a non-zero withdrawal even if the intent is only to claim rewards. This leads to an inability to perform a claim-only operation, limiting flexibility for users who wish to harvest rewards without altering their staked position. While not a security vulnerability per se, it reduces usability and may force unnecessary balance changes. The recommendation is to conditionally execute the withdrawal only when usdsAmount > 0, allowing zero-amount reward claims.\n",
            "severity": "Informational",
            "location": [
                "MainnetController.sol::withdrawFromFarm#L878"
            ],
            "files": [
                "spark-alm-controller/src/MainnetController.sol"
            ]
        }
    ],
    "affected_files": {
        "MainnetController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\n// This interface has been reviewed, and is compliant with the specs: https://eips.ethereum.org/EIPS/eip-7540\nimport { IERC7540 } from \"forge-std/interfaces/IERC7540.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IERC20 }   from \"openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\n\nimport { Ethereum } from \"spark-address-registry/Ethereum.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport  \"./interfaces/ILayerZero.sol\";\n\nimport { CCTPLib }                        from \"./libraries/CCTPLib.sol\";\nimport { CurveLib }                       from \"./libraries/CurveLib.sol\";\nimport { IDaiUsdsLike, IPSMLike, PSMLib } from \"./libraries/PSMLib.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ninterface IEthenaMinterLike {\n    function setDelegatedSigner(address delegateSigner) external;\n    function removeDelegatedSigner(address delegateSigner) external;\n}\n\ninterface ICentrifugeToken is IERC7540 {\n    function cancelDepositRequest(uint256 requestId, address controller) external;\n    function cancelRedeemRequest(uint256 requestId, address controller) external;\n    function claimCancelDepositRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 assets);\n    function claimCancelRedeemRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 shares);\n}\n\ninterface IMapleTokenLike is IERC4626 {\n    function requestRedeem(uint256 shares, address receiver) external;\n    function removeShares(uint256 shares, address receiver) external;\n}\n\ninterface IFarmLike {\n    function stake(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n}\n\ninterface ISSRedemptionLike is IERC20 {\n    function calculateUsdcOut(uint256 ustbAmount)\n        external view returns (uint256 usdcOutAmount, uint256 usdPerUstbChainlinkRaw);\n    function redeem(uint256 ustbAmout) external;\n}\n\ninterface ISUSDELike is IERC4626 {\n    function cooldownAssets(uint256 usdeAmount) external;\n    function cooldownShares(uint256 susdeAmount) external;\n    function unstake(address receiver) external;\n}\n\ninterface IUSTBLike is IERC20 {\n    function subscribe(uint256 inAmount, address stablecoin) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function draw(uint256 usdsAmount) external;\n    function wipe(uint256 usdsAmount) external;\n}\n\ncontract MainnetController is AccessControl {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n    event MaxSlippageSet(address indexed pool, uint256 maxSlippage);\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT         = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW        = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_7540_DEPOSIT         = keccak256(\"LIMIT_7540_DEPOSIT\");\n    bytes32 public constant LIMIT_7540_REDEEM          = keccak256(\"LIMIT_7540_REDEEM\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT         = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW        = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_ASSET_TRANSFER       = keccak256(\"LIMIT_ASSET_TRANSFER\");\n    bytes32 public constant LIMIT_CURVE_DEPOSIT        = keccak256(\"LIMIT_CURVE_DEPOSIT\");\n    bytes32 public constant LIMIT_CURVE_SWAP           = keccak256(\"LIMIT_CURVE_SWAP\");\n    bytes32 public constant LIMIT_CURVE_WITHDRAW       = keccak256(\"LIMIT_CURVE_WITHDRAW\");\n    bytes32 public constant LIMIT_LAYERZERO_TRANSFER   = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public constant LIMIT_MAPLE_REDEEM         = keccak256(\"LIMIT_MAPLE_REDEEM\");\n    bytes32 public constant LIMIT_FARM_DEPOSIT         = keccak256(\"LIMIT_FARM_DEPOSIT\");\n    bytes32 public constant LIMIT_FARM_WITHDRAW        = keccak256(\"LIMIT_FARM_WITHDRAW\");\n    bytes32 public constant LIMIT_SUPERSTATE_REDEEM    = keccak256(\"LIMIT_SUPERSTATE_REDEEM\");\n    bytes32 public constant LIMIT_SUPERSTATE_SUBSCRIBE = keccak256(\"LIMIT_SUPERSTATE_SUBSCRIBE\");\n    bytes32 public constant LIMIT_SUSDE_COOLDOWN       = keccak256(\"LIMIT_SUSDE_COOLDOWN\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP         = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN       = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n    bytes32 public constant LIMIT_USDE_BURN            = keccak256(\"LIMIT_USDE_BURN\");\n    bytes32 public constant LIMIT_USDE_MINT            = keccak256(\"LIMIT_USDE_MINT\");\n    bytes32 public constant LIMIT_USDS_MINT            = keccak256(\"LIMIT_USDS_MINT\");\n    bytes32 public constant LIMIT_USDS_TO_USDC         = keccak256(\"LIMIT_USDS_TO_USDC\");\n\n    uint256 internal constant CENTRIFUGE_REQUEST_ID = 0;\n\n    address public immutable buffer;\n\n    IALMProxy         public immutable proxy;\n    ICCTPLike         public immutable cctp;\n    IDaiUsdsLike      public immutable daiUsds;\n    IEthenaMinterLike public immutable ethenaMinter;\n    IPSMLike          public immutable psm;\n    IRateLimits       public immutable rateLimits;\n    ISSRedemptionLike public immutable superstateRedemption;\n    IVaultLike        public immutable vault;\n\n    IERC20     public immutable dai;\n    IERC20     public immutable usds;\n    IERC20     public immutable usde;\n    IERC20     public immutable usdc;\n    IUSTBLike  public immutable ustb;\n    ISUSDELike public immutable susde;\n\n    uint256 public immutable psmTo18ConversionFactor;\n\n    mapping(address pool => uint256 maxSlippage) public maxSlippages;  // 1e18 precision\n\n    mapping(uint32 destinationDomain     => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId => bytes32 layerZeroRecipient) public layerZeroRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address vault_,\n        address psm_,\n        address daiUsds_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        vault      = IVaultLike(vault_);\n        buffer     = IVaultLike(vault_).buffer();\n        psm        = IPSMLike(psm_);\n        daiUsds    = IDaiUsdsLike(daiUsds_);\n        cctp       = ICCTPLike(cctp_);\n\n        ethenaMinter         = IEthenaMinterLike(Ethereum.ETHENA_MINTER);\n        superstateRedemption = ISSRedemptionLike(Ethereum.SUPERSTATE_REDEMPTION);\n\n        susde = ISUSDELike(Ethereum.SUSDE);\n        ustb  = IUSTBLike(Ethereum.USTB);\n        dai   = IERC20(daiUsds.dai());\n        usdc  = IERC20(psm.gem());\n        usds  = IERC20(Ethereum.USDS);\n        usde  = IERC20(Ethereum.USDE);\n\n        psmTo18ConversionFactor = psm.to18ConversionFactor();\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(\n        uint32  destinationEndpointId,\n        bytes32 layerZeroRecipient\n    )\n        external\n    {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    function setMaxSlippage(address pool, uint256 maxSlippage) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        maxSlippages[pool] = maxSlippage;\n        emit MaxSlippageSet(pool, maxSlippage);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external {\n        _checkRole(FREEZER);\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer vault functions                                                                ***/\n    /**********************************************************************************************/\n\n    function mintUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDS_MINT, usdsAmount);\n\n        // Mint USDS into the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.draw, (usdsAmount))\n        );\n\n        // Transfer USDS from the buffer to the proxy\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transferFrom, (buffer, address(proxy), usdsAmount))\n        );\n    }\n\n    function burnUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _cancelRateLimit(LIMIT_USDS_MINT, usdsAmount);\n\n        // Transfer USDS from the proxy to the buffer\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transfer, (buffer, usdsAmount))\n        );\n\n        // Burn USDS from the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.wipe, (usdsAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC20 functions                                                                ***/\n    /**********************************************************************************************/\n\n    function transferAsset(address asset, address destination, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            RateLimitHelpers.makeAssetDestinationKey(LIMIT_ASSET_TRANSFER, asset, destination),\n            amount\n        );\n\n        proxy.doCall(\n            asset,\n            abi.encodeCall(IERC20(asset).transfer, (destination, amount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount);\n\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        _cancelRateLimit(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, token), amount);\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares) external returns (uint256 assets) {\n        _checkRole(RELAYER);\n\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n\n        _cancelRateLimit(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, token), assets);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC7540 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function requestDepositERC7540(address token, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_7540_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC7540(token).asset());\n\n        // Approve asset to vault from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Submit deposit request by transferring assets\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestDeposit, (amount, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimDepositERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        uint256 shares = IERC7540(token).maxMint(address(proxy));\n\n        // Claim shares from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC4626(token).mint, (shares, address(proxy)))\n        );\n    }\n\n    function requestRedeemERC7540(address token, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_7540_REDEEM,\n            token,\n            IERC7540(token).convertToAssets(shares)\n        );\n\n        // Submit redeem request by transferring shares\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestRedeem, (shares, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimRedeemERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        uint256 assets = IERC7540(token).maxWithdraw(address(proxy));\n\n        // Claim assets from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).withdraw, (assets, address(proxy), address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Centrifuge functions                                                           ***/\n    /**********************************************************************************************/\n\n    // NOTE: These cancelation methods are compatible with ERC-7887\n\n    function cancelCentrifugeDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        // NOTE: While the cancelation is pending, no new deposit request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    function cancelCentrifugeRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        // NOTE: While the cancelation is pending, no new redeem request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount);\n\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        _checkRole(RELAYER);\n\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n\n        _cancelRateLimit(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_DEPOSIT, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Curve StableSwap functions                                                     ***/\n    /**********************************************************************************************/\n\n    function swapCurve(\n        address pool,\n        uint256 inputIndex,\n        uint256 outputIndex,\n        uint256 amountIn,\n        uint256 minAmountOut\n    )\n        external returns (uint256 amountOut)\n    {\n        _checkRole(RELAYER);\n\n        amountOut = CurveLib.swap(CurveLib.SwapCurveParams({\n            proxy        : proxy,\n            rateLimits   : rateLimits,\n            pool         : pool,\n            rateLimitId  : LIMIT_CURVE_SWAP,\n            inputIndex   : inputIndex,\n            outputIndex  : outputIndex,\n            amountIn     : amountIn,\n            minAmountOut : minAmountOut,\n            maxSlippage  : maxSlippages[pool]\n        }));\n    }\n\n    function addLiquidityCurve(\n        address pool,\n        uint256[] memory depositAmounts,\n        uint256 minLpAmount\n    )\n        external returns (uint256 shares)\n    {\n        _checkRole(RELAYER);\n\n        shares = CurveLib.addLiquidity(CurveLib.AddLiquidityParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            pool                    : pool,\n            addLiquidityRateLimitId : LIMIT_CURVE_DEPOSIT,\n            swapRateLimitId         : LIMIT_CURVE_SWAP,\n            minLpAmount             : minLpAmount,\n            maxSlippage             : maxSlippages[pool],\n            depositAmounts          : depositAmounts\n        }));\n    }\n\n    function removeLiquidityCurve(\n        address pool,\n        uint256 lpBurnAmount,\n        uint256[] memory minWithdrawAmounts\n    )\n        external returns (uint256[] memory withdrawnTokens)\n    {\n        _checkRole(RELAYER);\n\n        withdrawnTokens = CurveLib.removeLiquidity(CurveLib.RemoveLiquidityParams({\n            proxy              : proxy,\n            rateLimits         : rateLimits,\n            pool               : pool,\n            rateLimitId        : LIMIT_CURVE_WITHDRAW,\n            lpBurnAmount       : lpBurnAmount,\n            minWithdrawAmounts : minWithdrawAmounts,\n            maxSlippage        : maxSlippages[pool]\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Ethena functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.setDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    function removeDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.removeDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    // Note that Ethena's mint/redeem per-block limits include other users\n    function prepareUSDeMint(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_MINT, usdcAmount);\n        _approve(address(usdc), address(ethenaMinter), usdcAmount);\n    }\n\n    function prepareUSDeBurn(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_BURN, usdeAmount);\n        _approve(address(usde), address(ethenaMinter), usdeAmount);\n    }\n\n    function cooldownAssetsSUSDe(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUSDE_COOLDOWN, usdeAmount);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.cooldownAssets, (usdeAmount))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function cooldownSharesSUSDe(uint256 susdeAmount)\n        external\n        returns (uint256 cooldownAmount)\n    {\n        _checkRole(RELAYER);\n\n        cooldownAmount = abi.decode(\n            proxy.doCall(\n                address(susde),\n                abi.encodeCall(susde.cooldownShares, (susdeAmount))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUSDE_COOLDOWN, cooldownAmount);\n    }\n\n    function unstakeSUSDe() external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.unstake, (address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Maple functions                                                                ***/\n    /**********************************************************************************************/\n\n    function requestMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_MAPLE_REDEEM,\n            mapleToken,\n            IMapleTokenLike(mapleToken).convertToAssets(shares)\n        );\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).requestRedeem, (shares, address(proxy)))\n        );\n    }\n\n    function cancelMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_MAPLE_REDEEM, mapleToken));\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).removeShares, (shares, address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Superstate functions                                                           ***/\n    /**********************************************************************************************/\n\n    function subscribeSuperstate(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUPERSTATE_SUBSCRIBE, usdcAmount);\n\n        _approve(address(usdc), address(ustb), usdcAmount);\n\n        proxy.doCall(\n            address(ustb),\n            abi.encodeCall(ustb.subscribe, (usdcAmount, address(usdc)))\n        );\n    }\n\n    // NOTE: Rate limited outside of modifier because of tuple return\n    function redeemSuperstate(uint256 ustbAmount) external {\n        _checkRole(RELAYER);\n\n        ( uint256 usdcAmount, ) = superstateRedemption.calculateUsdcOut(ustbAmount);\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUPERSTATE_REDEEM, usdcAmount);\n\n        _approve(address(ustb), address(superstateRedemption), ustbAmount);\n\n        proxy.doCall(\n            address(superstateRedemption),\n            abi.encodeCall(superstateRedemption.redeem, (ustbAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer DaiUsds functions                                                              ***/\n    /**********************************************************************************************/\n\n    function swapUSDSToDAI(uint256 usdsAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(address(usds), address(daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.usdsToDai, (address(proxy), usdsAmount))\n        );\n    }\n\n    function swapDAIToUSDS(uint256 daiAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(address(dai), address(daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.daiToUsds, (address(proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    // NOTE: The param `usdcAmount` is denominated in 1e6 precision to match how PSM uses\n    //       USDC precision for both `buyGemNoFee` and `sellGemNoFee`\n    function swapUSDSToUSDC(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDSToUSDC(PSMLib.SwapUSDSToUSDCParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            usds                    : usds,\n            dai                     : dai,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    function swapUSDCToUSDS(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n\n        PSMLib.swapUSDCToUSDS(PSMLib.SwapUSDCToUSDSParams({\n            proxy                   : proxy,\n            rateLimits              : rateLimits,\n            daiUsds                 : daiUsds,\n            psm                     : psm,\n            dai                     : dai,\n            usdc                    : usdc,\n            rateLimitId             : LIMIT_USDS_TO_USDC,\n            usdcAmount              : usdcAmount,\n            psmTo18ConversionFactor : psmTo18ConversionFactor\n        }));\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external payable\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        // NOTE: Full integration testing of this logic is not possible without OFTs with\n        //       approvalRequired == false. Add integration testing for this case before\n        //       using in production.\n        if (ILayerZero(oftAddress).approvalRequired()) {\n            _approve(ILayerZero(oftAddress).token(), oftAddress, amount);\n        }\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue{value: fee.nativeFee}(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain) external {\n        _checkRole(RELAYER);\n\n        CCTPLib.transferUSDCToCCTP(CCTPLib.TransferUSDCToCCTPParams({\n            proxy             : proxy,\n            rateLimits        : rateLimits,\n            cctp              : cctp,\n            usdc              : usdc,\n            domainRateLimitId : LIMIT_USDC_TO_DOMAIN,\n            cctpRateLimitId   : LIMIT_USDC_TO_CCTP,\n            mintRecipient     : mintRecipients[destinationDomain],\n            destinationDomain : destinationDomain,\n            usdcAmount        : usdcAmount\n        }));\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer SPK Farm functions                                                             ***/\n    /**********************************************************************************************/\n\n    function depositToFarm(address farm, uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_FARM_DEPOSIT, farm)),\n            usdsAmount\n        );\n\n        _approve(address(usds), farm, usdsAmount);\n\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.stake, (usdsAmount))\n        );\n    }\n\n    function withdrawFromFarm(address farm, uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_FARM_WITHDRAW, farm)),\n            usdsAmount\n        );\n\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.withdraw, (usdsAmount))\n        );\n        proxy.doCall(\n            farm,\n            abi.encodeCall(IFarmLike.getReward, ())\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        bytes memory approveCallReturnData;\n\n        if (success) {\n            // Data is the ABI-encoding of the approve call bytes return data, need to\n            // decode it first\n            approveCallReturnData = abi.decode(data, (bytes));\n            // Approve was successful if 1) no return value or 2) true return value\n            if (approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool))) {\n                return;\n            }\n        }\n\n        // If call was unsuccessful, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n\n        approveCallReturnData = proxy.doCall(token, approveData);\n\n        // Revert if approve returns false\n        require(\n            approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool)),\n            \"MainnetController/approve-failed\"\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Rate Limit helper functions                                                            ***/\n    /**********************************************************************************************/\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n    function _rateLimitedAsset(bytes32 key, address asset, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n    }\n\n    function _cancelRateLimit(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitIncrease(key, amount);\n    }\n\n    function _rateLimitExists(bytes32 key) internal view {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"MainnetController/invalid-action\"\n        );\n    }\n\n}\n\n",
        "ForeignController.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IERC20 }   from \"openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\n\nimport { IPSM3 } from \"spark-psm/src/interfaces/IPSM3.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport  \"./interfaces/ILayerZero.sol\";\n\nimport { OptionsBuilder } from \"layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ncontract ForeignController is AccessControl {\n\n    using OptionsBuilder for bytes;\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    // NOTE: This is used to track individual transfers for offchain processing of CCTP transactions\n    event CCTPTransferInitiated(\n        uint64  indexed nonce,\n        uint32  indexed destinationDomain,\n        bytes32 indexed mintRecipient,\n        uint256 usdcAmount\n    );\n\n    event LayerZeroRecipientSet(uint32 indexed destinationEndpointId, bytes32 layerZeroRecipient);\n\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT       = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW      = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT       = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW      = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_LAYERZERO_TRANSFER = keccak256(\"LIMIT_LAYERZERO_TRANSFER\");\n    bytes32 public constant LIMIT_PSM_DEPOSIT        = keccak256(\"LIMIT_PSM_DEPOSIT\");\n    bytes32 public constant LIMIT_PSM_WITHDRAW       = keccak256(\"LIMIT_PSM_WITHDRAW\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP       = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN     = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n\n    IALMProxy   public immutable proxy;\n    ICCTPLike   public immutable cctp;\n    IPSM3       public immutable psm;\n    IRateLimits public immutable rateLimits;\n\n    IERC20 public immutable usdc;\n\n    mapping(uint32 destinationDomain     => bytes32 mintRecipient)      public mintRecipients;\n    mapping(uint32 destinationEndpointId => bytes32 layerZeroRecipient) public layerZeroRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address psm_,\n        address usdc_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        psm        = IPSM3(psm_);\n        usdc       = IERC20(usdc_);\n        cctp       = ICCTPLike(cctp_);\n    }\n\n    /**********************************************************************************************/\n    /*** Modifiers                                                                              ***/\n    /**********************************************************************************************/\n\n    modifier rateLimited(bytes32 key, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n        _;\n    }\n\n    modifier rateLimitedAsset(bytes32 key, address asset, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n        _;\n    }\n\n    modifier rateLimitExists(bytes32 key) {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"ForeignController/invalid-action\"\n        );\n        _;\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setLayerZeroRecipient(uint32 destinationEndpointId, bytes32 layerZeroRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        layerZeroRecipients[destinationEndpointId] = layerZeroRecipient;\n        emit LayerZeroRecipientSet(destinationEndpointId, layerZeroRecipient);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external onlyRole(FREEZER) {\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    function depositPSM(address asset, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_PSM_DEPOSIT, asset, amount)\n        returns (uint256 shares)\n    {\n        // Approve `asset` to PSM from the proxy (assumes the proxy has enough `asset`).\n        _approve(asset, address(psm), amount);\n\n        // Deposit `amount` of `asset` in the PSM, decode the result to get `shares`.\n        shares = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.deposit,\n                    (asset, address(proxy), amount)\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawPSM(address asset, uint256 maxAmount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assetsWithdrawn)\n    {\n        // Withdraw up to `maxAmount` of `asset` in the PSM, decode the result\n        // to get `assetsWithdrawn` (assumes the proxy has enough PSM shares).\n        assetsWithdrawn = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.withdraw,\n                    (asset, address(proxy), maxAmount)\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_PSM_WITHDRAW, asset),\n            assetsWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain)\n        external\n        onlyRole(RELAYER)\n        rateLimited(LIMIT_USDC_TO_CCTP, usdcAmount)\n        rateLimited(\n            RateLimitHelpers.makeDomainKey(LIMIT_USDC_TO_DOMAIN, destinationDomain),\n            usdcAmount\n        )\n    {\n        bytes32 mintRecipient = mintRecipients[destinationDomain];\n\n        require(mintRecipient != 0, \"ForeignController/domain-not-configured\");\n\n        // Approve USDC to CCTP from the proxy (assumes the proxy has enough USDC).\n        _approve(address(usdc), address(cctp), usdcAmount);\n\n        // If amount is larger than limit it must be split into multiple calls.\n        uint256 burnLimit = cctp.localMinter().burnLimitsPerMessage(address(usdc));\n\n        while (usdcAmount > burnLimit) {\n            _initiateCCTPTransfer(burnLimit, destinationDomain, mintRecipient);\n            usdcAmount -= burnLimit;\n        }\n\n        // Send remaining amount (if any)\n        if (usdcAmount > 0) {\n            _initiateCCTPTransfer(usdcAmount, destinationDomain, mintRecipient);\n        }\n    }\n\n    // NOTE: !!! This function was deployed without integration testing !!!\n    //       KEEP RATE LIMIT AT ZERO until LayerZero dependencies are live and\n    //       all functionality has been thoroughly integration tested.\n    function transferTokenLayerZero(\n        address oftAddress,\n        uint256 amount,\n        uint32  destinationEndpointId\n    )\n        external payable\n    {\n        _checkRole(RELAYER);\n        _rateLimited(\n            keccak256(abi.encode(LIMIT_LAYERZERO_TRANSFER, oftAddress, destinationEndpointId)),\n            amount\n        );\n\n        // NOTE: Full integration testing of this logic is not possible without OFTs with\n        //       approvalRequired == true. Add integration testing for this case before \n        //       using in production.\n        if (ILayerZero(oftAddress).approvalRequired()) {\n            _approve(ILayerZero(oftAddress).token(), oftAddress, amount);\n        }\n\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200_000, 0);\n\n        SendParam memory sendParams = SendParam({\n            dstEid       : destinationEndpointId,\n            to           : layerZeroRecipients[destinationEndpointId],\n            amountLD     : amount,\n            minAmountLD  : 0,\n            extraOptions : options,\n            composeMsg   : \"\",\n            oftCmd       : \"\"\n        });\n\n        // Query the min amount received on the destination chain and set it.\n        ( ,, OFTReceipt memory receipt ) = ILayerZero(oftAddress).quoteOFT(sendParams);\n        sendParams.minAmountLD = receipt.amountReceivedLD;\n\n        MessagingFee memory fee = ILayerZero(oftAddress).quoteSend(sendParams, false);\n\n        proxy.doCallWithValue{value: fee.nativeFee}(\n            oftAddress,\n            abi.encodeCall(ILayerZero.send, (sendParams, fee, address(proxy))),\n            fee.nativeFee\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount)\n        returns (uint256 shares)\n    {\n        // Note that whitelist is done by rate limits.\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount)\n        returns (uint256 shares)\n    {\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitIncrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, token),\n            amount\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assets)\n    {\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n        rateLimits.triggerRateLimitIncrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, token),\n            assets\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount)\n    {\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens.\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 amountWithdrawn)\n    {\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n\n        rateLimits.triggerRateLimitIncrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_DEPOSIT, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Morpho functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setSupplyQueueMorpho(address morphoVault, Id[] memory newSupplyQueue)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).setSupplyQueue, (newSupplyQueue))\n        );\n    }\n\n    function updateWithdrawQueueMorpho(address morphoVault, uint256[] calldata indexes)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).updateWithdrawQueue, (indexes))\n        );\n    }\n\n    function reallocateMorpho(address morphoVault, MarketAllocation[] calldata allocations)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).reallocate, (allocations))\n        );\n    }\n\n\n    /**********************************************************************************************/\n    /*** Internal helper functions                                                              ***/\n    /**********************************************************************************************/\n\n    // NOTE: This logic was inspired by OpenZeppelin's forceApprove in SafeERC20 library\n    function _approve(address token, address spender, uint256 amount) internal {\n        bytes memory approveData = abi.encodeCall(IERC20.approve, (spender, amount));\n\n        // Call doCall on proxy to approve the token\n        ( bool success, bytes memory data )\n            = address(proxy).call(abi.encodeCall(IALMProxy.doCall, (token, approveData)));\n\n        bytes memory approveCallReturnData;\n\n        if (success) {\n            // Data is the ABI-encoding of the approve call bytes return data, need to\n            // decode it first\n            approveCallReturnData = abi.decode(data, (bytes));\n            // Approve was successful if 1) no return value or 2) true return value\n            if (approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool))) {\n                return;\n            }\n        }\n\n        // If call was unsuccessful, set to zero and try again\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, 0)));\n\n        approveCallReturnData = proxy.doCall(token, approveData);\n\n        // Revert if approve returns false\n        require(\n            approveCallReturnData.length == 0 || abi.decode(approveCallReturnData, (bool)),\n            \"ForeignController/approve-failed\"\n        );\n    }\n\n    function _initiateCCTPTransfer(\n        uint256 usdcAmount,\n        uint32  destinationDomain,\n        bytes32 mintRecipient\n    )\n        internal\n    {\n        uint64 nonce = abi.decode(\n            proxy.doCall(\n                address(cctp),\n                abi.encodeCall(\n                    cctp.depositForBurn,\n                    (\n                        usdcAmount,\n                        destinationDomain,\n                        mintRecipient,\n                        address(usdc)\n                    )\n                )\n            ),\n            (uint64)\n        );\n\n        emit CCTPTransferInitiated(nonce, destinationDomain, mintRecipient, usdcAmount);\n    }\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n}\n"
    }
}