{
    "vfp_id": "vfp_00191",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect comments in _verifyCallConfig()",
            "description": "1. **Description:** The comments in _verifyCallConfig() incorrectly reference invertsBidValue when describing disallowed configurations involving multipleSuccessfulSolvers, while the actual code correctly enforces the restrictions.\n2. **Cause:** Outdated or inaccurate inline documentation.\n3. **Exploitation:** Could mislead developers into thinking the logic involves invertsBidValue, potentially leading to incorrect modifications.\n4. **Impact:** Risk of future bugs due to misunderstanding of the code logic based on incorrect comments.\n",
            "severity": "Informational",
            "location": [
                "AtlasVerification.sol#L285-L296"
            ],
            "files": [
                "atlas/src/contracts/atlas/AtlasVerification.sol"
            ]
        }
    ],
    "affected_files": {
        "AtlasVerification.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { EIP712 } from \"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\";\nimport { ECDSA } from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { DAppIntegration } from \"./DAppIntegration.sol\";\nimport { NonceManager } from \"./NonceManager.sol\";\n\nimport { CallBits } from \"../libraries/CallBits.sol\";\nimport { CallVerification } from \"../libraries/CallVerification.sol\";\nimport { GasAccLib } from \"../libraries/GasAccLib.sol\";\nimport { AccountingMath } from \"../libraries/AccountingMath.sol\";\nimport { AtlasErrors } from \"../types/AtlasErrors.sol\";\nimport \"../types/SolverOperation.sol\";\nimport \"../types/UserOperation.sol\";\nimport \"../types/ConfigTypes.sol\";\nimport \"../types/DAppOperation.sol\";\nimport \"../types/EscrowTypes.sol\";\nimport \"../types/ValidCalls.sol\";\n\n/// @title AtlasVerification\n/// @author FastLane Labs\n/// @notice AtlasVerification handles the verification of DAppConfigs, UserOperations, SolverOperations, and\n/// DAppOperations within a metacall to ensure that calldata sourced from various parties is safe and valid.\ncontract AtlasVerification is EIP712, NonceManager, DAppIntegration {\n    using ECDSA for bytes32;\n    using CallBits for uint32;\n    using CallVerification for UserOperation;\n    using GasAccLib for SolverOperation[];\n\n    constructor(\n        address atlas,\n        address l2GasCalculator\n    )\n        EIP712(\"AtlasVerification\", \"1.5\")\n        DAppIntegration(atlas, l2GasCalculator)\n    { }\n\n    /// @notice The validateCalls function verifies the validity of the metacall calldata components.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp The UserOperation struct of the metacall.\n    /// @param solverOps An array of SolverOperation structs.\n    /// @param dAppOp The DAppOperation struct of the metacall.\n    /// @param metacallGasLeft The gasleft at the start of the metacall.\n    /// @param msgValue The ETH value sent with the metacall transaction.\n    /// @param msgSender The forwarded msg.sender of the original metacall transaction in the Atlas contract.\n    /// @param isSimulation A boolean indicating if the call is a simulation.\n    /// @return allSolversGasLimit The calldata and execution gas limits of all solverOps summed.\n    /// @return allSolversCalldataGas The sum of all solverOp calldata gas (excl. non-solver calldata).\n    /// @return bidFindOverhead The gas overhead for bid-finding loop in exPostBids mode.\n    /// @return verifyCallsResult The result of the ValidCalls check, in enum ValidCallsResult form.\n    function validateCalls(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        DAppOperation calldata dAppOp,\n        uint256 metacallGasLeft,\n        uint256 msgValue,\n        address msgSender,\n        bool isSimulation\n    )\n        external\n        returns (\n            uint256 allSolversGasLimit,\n            uint256 allSolversCalldataGas,\n            uint256 bidFindOverhead,\n            ValidCallsResult verifyCallsResult\n        )\n    {\n        if (msg.sender != ATLAS) revert AtlasErrors.InvalidCaller();\n        // Verify that the calldata injection came from the dApp frontend\n        // and that the signatures are valid.\n\n        bytes32 _userOpHash = _getUserOperationHash(userOp, userOp.callConfig.allowsTrustedOpHash());\n\n        {\n            // Check user signature\n            verifyCallsResult = _verifyUser(dConfig, userOp, _userOpHash, msgSender, isSimulation);\n            if (verifyCallsResult != ValidCallsResult.Valid) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, verifyCallsResult);\n            }\n\n            // allowUnapprovedDAppSignatories still verifies signature match, but does not check\n            // if dApp owner approved the signer.\n            bool allowUnapprovedDAppSignatories;\n            (verifyCallsResult, allowUnapprovedDAppSignatories) =\n                _verifyAuctioneer(dConfig, userOp, solverOps, dAppOp, msgSender);\n\n            if (verifyCallsResult != ValidCallsResult.Valid && !isSimulation) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, verifyCallsResult);\n            }\n\n            // Check dapp signature\n            verifyCallsResult = _verifyDApp(dConfig, dAppOp, msgSender, allowUnapprovedDAppSignatories, isSimulation);\n            if (verifyCallsResult != ValidCallsResult.Valid) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, verifyCallsResult);\n            }\n        }\n\n        // Check if the call configuration is valid\n        verifyCallsResult = _verifyCallConfig(dConfig.callConfig);\n        if (verifyCallsResult != ValidCallsResult.Valid) {\n            return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, verifyCallsResult);\n        }\n\n        // CASE: Solvers trust app to update content of UserOp after submission of solverOp\n        if (dConfig.callConfig.allowsTrustedOpHash()) {\n            // SessionKey must match explicitly - cannot be skipped\n            if (userOp.sessionKey != dAppOp.from && !isSimulation) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.InvalidAuctioneer);\n            }\n\n            // msgSender (the bundler) must be userOp.from, userOp.sessionKey / dappOp.from, or dappOp.bundler\n            if (!(msgSender == dAppOp.from || msgSender == dAppOp.bundler || msgSender == userOp.from) && !isSimulation)\n            {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.InvalidBundler);\n            }\n        }\n\n        uint256 _solverOpCount = solverOps.length;\n\n        {\n            // Check number of solvers not greater than max, to prevent overflows in `solverIndex`\n            if (_solverOpCount > _MAX_SOLVERS) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.TooManySolverOps);\n            }\n\n            // Check if past user's deadline\n            if (userOp.deadline != 0 && block.number > userOp.deadline) {\n                return\n                    (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.UserDeadlineReached);\n            }\n\n            // Check if past dapp's deadline\n            if (dAppOp.deadline != 0 && block.number > dAppOp.deadline) {\n                return\n                    (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.DAppDeadlineReached);\n            }\n\n            // Check gas price is within user's limit\n            if (tx.gasprice > userOp.maxFeePerGas) {\n                return\n                    (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.GasPriceHigherThanMax);\n            }\n\n            // Check that the value of the tx is greater than or equal to the value specified\n            if (msgValue < userOp.value) {\n                return (\n                    allSolversGasLimit,\n                    allSolversCalldataGas,\n                    bidFindOverhead,\n                    ValidCallsResult.TxValueLowerThanCallValue\n                );\n            }\n\n            // Check the call config read from DAppControl at start of metacall matches userOp value\n            if (dConfig.callConfig != userOp.callConfig) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.CallConfigMismatch);\n            }\n\n            // Check the dappGasLimit read from DAppControl at start of metacall matches userOp value\n            if (dConfig.dappGasLimit != userOp.dappGasLimit) {\n                return\n                    (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.DAppGasLimitMismatch);\n            }\n\n            // Check the solverGasLimit read from DAppControl at start of metacall matches userOp value\n            if (dConfig.solverGasLimit != userOp.solverGasLimit) {\n                return (\n                    allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.SolverGasLimitMismatch\n                );\n            }\n\n            // Check the bundlerSurchargeRate read from DAppControl at start of metacall matches userOp value\n            if (dConfig.bundlerSurchargeRate != userOp.bundlerSurchargeRate) {\n                return (\n                    allSolversGasLimit,\n                    allSolversCalldataGas,\n                    bidFindOverhead,\n                    ValidCallsResult.BundlerSurchargeRateMismatch\n                );\n            }\n        }\n\n        // Check gasleft() measured at start of metacall is in line with expected gas limit\n        (verifyCallsResult, allSolversGasLimit, allSolversCalldataGas, bidFindOverhead) =\n            _getAndVerifyGasLimits(solverOps, dConfig, userOp.gas, metacallGasLeft);\n        if (verifyCallsResult != ValidCallsResult.Valid) {\n            return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, verifyCallsResult);\n        }\n\n        // Some checks are only needed when call is not a simulation\n        if (isSimulation) {\n            // Add all solver ops if simulation\n            return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.Valid);\n        }\n\n        // Verify a solver was successfully verified.\n        if (_solverOpCount == 0) {\n            if (!dConfig.callConfig.allowsZeroSolvers()) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.NoSolverOp);\n            }\n\n            if (dConfig.callConfig.needsFulfillment()) {\n                return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.NoSolverOp);\n            }\n        }\n\n        if (_userOpHash != dAppOp.userOpHash) {\n            return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.OpHashMismatch);\n        }\n\n        return (allSolversGasLimit, allSolversCalldataGas, bidFindOverhead, ValidCallsResult.Valid);\n    }\n\n    /// @notice The verifySolverOp function verifies the validity of a SolverOperation.\n    /// @param solverOp The SolverOperation struct to verify.\n    /// @param userOpHash The hash of the associated UserOperation struct.\n    /// @param userMaxFeePerGas The maximum fee per gas the user is willing to pay.\n    /// @param bundler The address of the bundler.\n    /// @return result The result of the SolverOperation verification, containing SolverOutcome info in a bitmap.\n    function verifySolverOp(\n        SolverOperation calldata solverOp,\n        bytes32 userOpHash,\n        uint256 userMaxFeePerGas,\n        address bundler,\n        bool allowsTrustedOpHash\n    )\n        external\n        view\n        returns (uint256 result)\n    {\n        if (bundler == solverOp.from || _verifySolverSignature(solverOp)) {\n            // Validate solver signature\n            // NOTE: First two failures are the bundler's fault - solver does not\n            // owe a gas refund to the bundler.\n            if (solverOp.userOpHash != userOpHash) {\n                result |= (1 << uint256(SolverOutcome.InvalidUserHash));\n            }\n\n            if (solverOp.to != ATLAS) result |= (1 << uint256(SolverOutcome.InvalidTo));\n\n            // NOTE: The next three failures below here are the solver's fault, and as a result\n            // they are on the hook for their own gas cost.\n            if (tx.gasprice > solverOp.maxFeePerGas) result |= (1 << uint256(SolverOutcome.GasPriceOverCap));\n\n            if (solverOp.maxFeePerGas < userMaxFeePerGas) {\n                result |= (\n                    1\n                        << (\n                            allowsTrustedOpHash\n                                ? uint256(SolverOutcome.GasPriceBelowUsersAlt)\n                                : uint256(SolverOutcome.GasPriceBelowUsers)\n                        )\n                );\n            }\n\n            if (solverOp.solver == ATLAS || solverOp.solver == address(this)) {\n                result |= (1 << uint256(SolverOutcome.InvalidSolver));\n            }\n            // NOTE: If result is not set above, result stays 0, therefore result is `canExecute == true`\n        } else {\n            // No refund\n            result |= (1 << uint256(SolverOutcome.InvalidSignature));\n        }\n    }\n\n    /// @notice External function to call the internal _verifyCallConfig function\n    /// @param callConfig The call configuration struct to verify.\n    /// @return The result of the ValidCalls check, in enum ValidCallsResult form.\n    function verifyCallConfig(uint32 callConfig) external pure returns (ValidCallsResult) {\n        return _verifyCallConfig(callConfig);\n    }\n\n    /// @notice The _verifyCallConfig internal function verifies the validity of the call configuration.\n    /// @param callConfig The call configuration to verify.\n    /// @return The result of the ValidCalls check, in enum ValidCallsResult form.\n    function _verifyCallConfig(uint32 callConfig) internal pure returns (ValidCallsResult) {\n        if (callConfig.needsPreOpsReturnData() && callConfig.needsUserReturnData()) {\n            // Max one of preOps or userOp return data can be tracked, not both\n            return ValidCallsResult.InvalidCallConfig;\n        }\n        if (callConfig.multipleSuccessfulSolvers() && callConfig.exPostBids()) {\n            // Max one of multipleSolvers or exPostBids can be used, not both\n            return ValidCallsResult.ExPostBidsAndMultipleSuccessfulSolversNotSupportedTogether;\n        }\n        if (callConfig.multipleSuccessfulSolvers() && callConfig.invertsBidValue()) {\n            // Max one of multipleSolvers or invertsBidValue can be used, not both\n            return ValidCallsResult.InvertsBidValueAndMultipleSuccessfulSolversNotSupportedTogether;\n        }\n        if (callConfig.multipleSuccessfulSolvers() && callConfig.allowsZeroSolvers()) {\n            // Max one of multipleSolvers or invertsBidValue can be used, not both\n            return ValidCallsResult.NeedSolversForMultipleSuccessfulSolvers;\n        }\n        if (callConfig.multipleSuccessfulSolvers() && callConfig.allowsSolverAuctioneer()) {\n            // Max one of multipleSolvers or invertsBidValue can be used, not both\n            return ValidCallsResult.SolverCannotBeAuctioneerForMultipleSuccessfulSolvers;\n        }\n        if (callConfig.multipleSuccessfulSolvers() && callConfig.needsFulfillment()) {\n            // Max one of multipleSolvers or invertsBidValue can be used, not both\n            return ValidCallsResult.CannotRequireFulfillmentForMultipleSuccessfulSolvers;\n        }\n        if (callConfig.needsSequentialUserNonces() && callConfig.needsSequentialDAppNonces()) {\n            // Max one of user or dapp nonces can be sequential, not both\n            return ValidCallsResult.BothUserAndDAppNoncesCannotBeSequential;\n        }\n        if (callConfig.invertsBidValue() && callConfig.exPostBids()) {\n            // If both invertBidValue and exPostBids are true, solver's retrieved bid cannot be determined\n            return ValidCallsResult.InvertBidValueCannotBeExPostBids;\n        }\n        return ValidCallsResult.Valid;\n    }\n\n    /// @notice The _verifyAuctioneer internal function is called by _validCalls to verify that the auctioneer of the\n    /// metacall is valid according to the rules set in the DAppConfig.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp The UserOperation struct of the metacall.\n    /// @param solverOps An array of SolverOperation structs.\n    /// @param dAppOp The DAppOperation struct of the metacall.\n    /// @param msgSender The bundler (msg.sender) of the metacall transaction in the Atlas contract.\n    /// @return validCallsResult The result of the ValidCalls check, in enum ValidCallsResult form.\n    /// @return allowUnapprovedDAppSignatories A boolean indicating if the signatory approval check should be bypassed.\n    function _verifyAuctioneer(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        DAppOperation calldata dAppOp,\n        address msgSender\n    )\n        internal\n        pure\n        returns (ValidCallsResult validCallsResult, bool allowUnapprovedDAppSignatories)\n    {\n        if (\n            dConfig.callConfig.verifyCallChainHash()\n                && dAppOp.callChainHash != CallVerification.getCallChainHash(userOp, solverOps)\n        ) return (ValidCallsResult.InvalidCallChainHash, false);\n\n        if (dConfig.callConfig.allowsUserAuctioneer() && dAppOp.from == userOp.sessionKey) {\n            return (ValidCallsResult.Valid, true);\n        }\n\n        if (dConfig.callConfig.allowsSolverAuctioneer() && solverOps.length > 0) {\n            // If the solver is the auctioneer, there must be exactly 1 solver\n            if (dAppOp.from == solverOps[0].from) {\n                if (solverOps.length != 1) {\n                    // If not exactly one solver and first solver is auctioneer\n                    // => invalid\n                    return (ValidCallsResult.TooManySolverOps, false);\n                } else if (msgSender == solverOps[0].from) {\n                    // If exactly one solver AND that solver is auctioneer,\n                    // AND the solver is also the bundler,\n                    // => valid AND bypass sig approval\n                    return (ValidCallsResult.Valid, true);\n                }\n            }\n            // If first solver is not the auctioneer,\n            // => valid BUT do not bypass sig approval\n        }\n\n        if (dConfig.callConfig.allowsUnknownAuctioneer()) return (ValidCallsResult.Valid, true);\n        return (ValidCallsResult.Valid, false);\n    }\n\n    /// @notice The getSolverPayload function returns the hash of a SolverOperation struct for use in signatures.\n    /// @param solverOp The SolverOperation struct to hash.\n    function getSolverPayload(SolverOperation calldata solverOp) external view returns (bytes32 payload) {\n        payload = _hashTypedDataV4(_getSolverOpHash(solverOp));\n    }\n\n    /// @notice The internal _verifySolverSignature function verifies the signature of a SolverOperation.\n    /// @param solverOp The SolverOperation struct to verify.\n    /// @return A boolean indicating if the signature is valid.\n    function _verifySolverSignature(SolverOperation calldata solverOp) internal view returns (bool) {\n        (address _signer,,) = _hashTypedDataV4(_getSolverOpHash(solverOp)).tryRecover(solverOp.signature);\n        return _signer == solverOp.from;\n    }\n\n    /// @notice The _getSolverOpHash internal function returns the hash of a SolverOperation struct.\n    /// @param solverOp The SolverOperation struct to hash.\n    /// @return solverOpHash The hash of the SolverOperation struct.\n    function _getSolverOpHash(SolverOperation calldata solverOp) internal pure returns (bytes32 solverOpHash) {\n        return keccak256(\n            abi.encode(\n                SOLVER_TYPEHASH,\n                solverOp.from,\n                solverOp.to,\n                solverOp.value,\n                solverOp.gas,\n                solverOp.maxFeePerGas,\n                solverOp.deadline,\n                solverOp.solver,\n                solverOp.control,\n                solverOp.userOpHash,\n                solverOp.bidToken,\n                solverOp.bidAmount,\n                keccak256(solverOp.data)\n            )\n        );\n    }\n\n    //\n    // DAPP VERIFICATION\n    //\n\n    /// @notice Verifies that the dapp's data matches the data submitted by the user and solvers. NOTE: The dapp's front\n    /// end is the last party in the supply chain to submit data.  If any other party (user, solver, FastLane,  or a\n    /// collusion between all of them) attempts to alter it, this check will fail.\n    /// @param dConfig The DAppConfig containing configuration details.\n    /// @param dAppOp The DAppOperation struct of the metacall.\n    /// @param msgSender The forwarded msg.sender of the original metacall transaction in the Atlas contract.\n    /// @param allowUnapprovedDAppSignatories Boolean indicating whether to bypass signatory approval.\n    /// @param isSimulation Boolean indicating whether the execution is a simulation.\n    /// @return The result of the ValidCalls check, in enum ValidCallsResult form.\n    function _verifyDApp(\n        DAppConfig memory dConfig,\n        DAppOperation calldata dAppOp,\n        address msgSender,\n        bool allowUnapprovedDAppSignatories,\n        bool isSimulation\n    )\n        internal\n        returns (ValidCallsResult)\n    {\n        if (dAppOp.to != ATLAS) return ValidCallsResult.DAppToInvalid;\n\n        bool _bypassSignature = msgSender == dAppOp.from || (isSimulation && dAppOp.signature.length == 0);\n\n        if (!_bypassSignature && !_verifyDAppSignature(dAppOp)) {\n            return ValidCallsResult.DAppSignatureInvalid;\n        }\n\n        if (dAppOp.control != dConfig.to) {\n            return ValidCallsResult.InvalidControl;\n        }\n\n        // Some checks skipped if call is `simUserOperation()`, because the dAppOp struct is not available.\n        bool _skipDAppOpChecks = isSimulation && dAppOp.from == address(0);\n\n        // If the dApp enabled sequential nonces (IE for FCFS execution), check and make sure the order is correct\n        // NOTE: enabling sequential nonces could create a scenario in which builders or validators may be able to\n        // profit via censorship. DApps are encouraged to rely on the deadline parameter.\n        if (!_skipDAppOpChecks && dConfig.callConfig.needsSequentialDAppNonces()) {\n            // When not in a simulation, nonces are stored even if the metacall fails, to prevent replay attacks.\n            if (!_handleDAppNonces(dAppOp.from, dAppOp.nonce, isSimulation)) {\n                return ValidCallsResult.InvalidDAppNonce;\n            }\n        }\n\n        // If `_verifyAuctioneer()` allows bypassing signatory approval, the checks below are skipped and we can return\n        // Valid here, considering the checks above have all passed.\n        if (allowUnapprovedDAppSignatories) return ValidCallsResult.Valid;\n\n        // Check actual bundler matches the dApp's intended `dAppOp.bundler`\n        if (dAppOp.bundler != address(0) && msgSender != dAppOp.bundler && !isSimulation) {\n            if (!_isDAppSignatory(dAppOp.control, msgSender)) {\n                return ValidCallsResult.InvalidBundler;\n            }\n        }\n\n        // Make sure the signer is currently enabled by dapp owner. Only need to check if msgSender != dAppOp.from (i.e.\n        // _bypassSignature == false), because msgSender checked above.\n        if (!_skipDAppOpChecks && !_bypassSignature && !_isDAppSignatory(dAppOp.control, dAppOp.from)) {\n            return ValidCallsResult.DAppNotEnabled;\n        }\n\n        return ValidCallsResult.Valid;\n    }\n\n    /// @notice Generates the hash of a DAppOperation struct.\n    /// @param dAppOp The DAppOperation struct to hash.\n    /// @return dappOpHash The hash of the DAppOperation struct.\n    function _getDAppOpHash(DAppOperation calldata dAppOp) internal pure returns (bytes32 dappOpHash) {\n        dappOpHash = keccak256(\n            abi.encode(\n                DAPP_TYPEHASH,\n                dAppOp.from,\n                dAppOp.to,\n                dAppOp.nonce,\n                dAppOp.deadline,\n                dAppOp.control,\n                dAppOp.bundler,\n                dAppOp.userOpHash,\n                dAppOp.callChainHash\n            )\n        );\n    }\n\n    /// @notice Verifies the signature of a DAppOperation struct.\n    /// @param dAppOp The DAppOperation struct to verify.\n    /// @return A boolean indicating if the signature is valid.\n    function _verifyDAppSignature(DAppOperation calldata dAppOp) internal view returns (bool) {\n        (address _signer,,) = _hashTypedDataV4(_getDAppOpHash(dAppOp)).tryRecover(dAppOp.signature);\n        return _signer == dAppOp.from;\n    }\n\n    /// @notice Generates the hash of a DAppOperation struct.\n    /// @param dAppOp The DAppOperation struct to hash.\n    /// @return payload The hash of the DAppOperation struct.\n    function getDAppOperationPayload(DAppOperation calldata dAppOp) public view returns (bytes32 payload) {\n        payload = _hashTypedDataV4(_getDAppOpHash(dAppOp));\n    }\n\n    /// @notice Returns the domain separator for the EIP712 signature scheme.\n    /// @return domainSeparator The domain separator for the EIP712 signature scheme.\n    function getDomainSeparator() external view returns (bytes32 domainSeparator) {\n        domainSeparator = _domainSeparatorV4();\n    }\n\n    //\n    // USER VERIFICATION\n    //\n\n    /// @notice Verifies the validity of a UserOperation struct.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp The UserOperation struct to verify.\n    /// @param msgSender The forwarded msg.sender of the original metacall transaction in the Atlas contract.\n    /// @param isSimulation A boolean indicating if the call is a simulation.\n    /// @return The result of the UserOperation verification, in enum ValidCallsResult form.\n    function _verifyUser(\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        address msgSender,\n        bool isSimulation\n    )\n        internal\n        returns (ValidCallsResult)\n    {\n        if (userOp.from == address(this) || userOp.from == ATLAS) {\n            return ValidCallsResult.UserFromInvalid;\n        }\n\n        if (userOp.to != ATLAS) {\n            return ValidCallsResult.UserToInvalid;\n        }\n\n        // Verify the signature before storing any data to avoid\n        // spoof transactions clogging up dapp userNonces\n\n        bool _userIsBundler = userOp.from == msgSender;\n        bool _hasNoSignature = userOp.signature.length == 0;\n        bool _signatureValid;\n\n        if (!_userIsBundler) {\n            if (userOp.callConfig.allowsTrustedOpHash()) {\n                // Use full untrusted hash for signature verification to ensure all operation parameters are included.\n                userOpHash = _getUserOperationHash(userOp, false);\n            }\n            _signatureValid = SignatureChecker.isValidSignatureNow(userOp.from, userOpHash, userOp.signature);\n        }\n\n        if (!(_signatureValid || _userIsBundler || (isSimulation && _hasNoSignature))) {\n            return ValidCallsResult.UserSignatureInvalid;\n        }\n\n        if (userOp.control != dConfig.to) {\n            return ValidCallsResult.ControlMismatch;\n        }\n\n        // If the dapp indicated that they only accept sequential userNonces\n        // (IE for FCFS execution), check and make sure the order is correct\n        // NOTE: allowing only sequential userNonces could create a scenario in\n        // which builders or validators may be able to profit via censorship.\n        // DApps are encouraged to rely on the deadline parameter\n        // to prevent replay attacks.\n        if (!_handleUserNonces(userOp.from, userOp.nonce, dConfig.callConfig.needsSequentialUserNonces(), isSimulation))\n        {\n            return ValidCallsResult.UserNonceInvalid;\n        }\n\n        return ValidCallsResult.Valid;\n    }\n\n    /// @notice Generates the payload hash of a UserOperation struct used in signatures.\n    /// @param userOp The UserOperation struct to generate the payload for.\n    /// @return payload The hash of the UserOperation struct for use in signatures.\n    function getUserOperationPayload(UserOperation calldata userOp) public view returns (bytes32 payload) {\n        payload = _getUserOperationHash(userOp, false);\n    }\n\n    /// @notice Generates the hash of a UserOperation struct used for inter-operation references.\n    /// @param userOp The UserOperation struct to generate the hash for.\n    /// @return userOpHash The hash of the UserOperation struct for in inter-operation references.\n    function getUserOperationHash(UserOperation calldata userOp) public view returns (bytes32 userOpHash) {\n        userOpHash = _getUserOperationHash(userOp, userOp.callConfig.allowsTrustedOpHash());\n    }\n\n    function _getUserOperationHash(\n        UserOperation memory userOp,\n        bool trusted\n    )\n        internal\n        view\n        returns (bytes32 userOpHash)\n    {\n        if (trusted) {\n            userOpHash = _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        USER_TYPEHASH_TRUSTED,\n                        userOp.from,\n                        userOp.to,\n                        userOp.dapp,\n                        userOp.control,\n                        userOp.callConfig,\n                        userOp.dappGasLimit,\n                        userOp.solverGasLimit,\n                        userOp.bundlerSurchargeRate,\n                        userOp.sessionKey\n                    )\n                )\n            );\n        } else {\n            userOpHash = _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        USER_TYPEHASH_DEFAULT,\n                        userOp.from,\n                        userOp.to,\n                        userOp.value,\n                        userOp.gas,\n                        userOp.maxFeePerGas,\n                        userOp.nonce,\n                        userOp.deadline,\n                        userOp.dapp,\n                        userOp.control,\n                        userOp.callConfig,\n                        userOp.dappGasLimit,\n                        userOp.solverGasLimit,\n                        userOp.bundlerSurchargeRate,\n                        userOp.sessionKey,\n                        keccak256(userOp.data)\n                    )\n                )\n            );\n        }\n    }\n\n    /// @notice Calculates 2 gas limits/maxes used in the metacall gas accounting.\n    /// @param solverOps The SolverOperations array of the current metacall.\n    /// @param dConfig The DAppConfig struct of the current metacall.\n    /// @param userOpGas The gas limit of the UserOperation.\n    /// @param metacallGasLeft The gasleft at the start of the metacall.\n    /// @return verifyCallsResult A ValidCallsResult enum which can be {Valid, MetacallGasLimitTooLow,\n    /// MetacallGasLimitTooHigh}.\n    /// @return allSolversGasLimit The sum of all solverOp calldata and execution gas limits.\n    /// @return allSolversCalldataGas The sum of all solverOp calldata gas (excl. non-solver calldata).\n    /// @return bidFindOverhead The gas overhead for bid-finding loop in exPostBids mode.\n    function _getAndVerifyGasLimits(\n        SolverOperation[] calldata solverOps,\n        DAppConfig calldata dConfig,\n        uint256 userOpGas,\n        uint256 metacallGasLeft\n    )\n        internal\n        view\n        returns (\n            ValidCallsResult verifyCallsResult,\n            uint256 allSolversGasLimit,\n            uint256 allSolversCalldataGas,\n            uint256 bidFindOverhead\n        )\n    {\n        uint256 solverOpsLen = solverOps.length;\n        uint256 dConfigSolverGasLimit = dConfig.solverGasLimit;\n        uint256 solverDataLenSum; // Calculated as sum of solverOps[i].data.length below\n        uint256 allSolversExecutionGas; // Calculated as sum of solverOps[i].gas below\n\n        for (uint256 i = 0; i < solverOpsLen; ++i) {\n            // Sum calldata length of all solverOp.data fields in the array\n            solverDataLenSum += solverOps[i].data.length;\n            // Sum all solverOp.gas values in the array, each with a max of dConfig.solverGasLimit\n            allSolversExecutionGas +=\n                (solverOps[i].gas > dConfigSolverGasLimit) ? dConfigSolverGasLimit : solverOps[i].gas;\n        }\n\n        allSolversCalldataGas =\n            GasAccLib.calldataGas(solverDataLenSum + (_SOLVER_OP_BASE_CALLDATA * solverOps.length), L2_GAS_CALCULATOR);\n\n        uint256 metacallExecutionGas = _BASE_TX_GAS_USED + AccountingMath._FIXED_GAS_OFFSET + userOpGas\n            + dConfig.dappGasLimit + allSolversExecutionGas;\n\n        // In both exPostBids and normal bid modes, solvers pay for their own execution gas.\n        allSolversGasLimit = allSolversExecutionGas;\n\n        if (dConfig.callConfig.exPostBids()) {\n            // Add extra execution gas for bid-finding loop of each solverOp\n            bidFindOverhead = (solverOpsLen * _BID_FIND_OVERHEAD) + allSolversExecutionGas;\n            metacallExecutionGas += bidFindOverhead;\n            // NOTE: allSolversGasLimit excludes calldata in exPostBids mode.\n        } else {\n            // Solvers only pay for their calldata if exPostBids = false\n            allSolversGasLimit += allSolversCalldataGas;\n        }\n\n        uint256 _execGasUpperTolerance = _UPPER_BASE_EXEC_GAS_TOLERANCE + solverOpsLen * _TOLERANCE_PER_SOLVER;\n        uint256 _execGasLowerTolerance = _LOWER_BASE_EXEC_GAS_TOLERANCE + solverOpsLen * _TOLERANCE_PER_SOLVER;\n\n        // Gas limit set by the bundler cannot be too high or too low. Use Simulator contract to estimate gas limit.\n        // If gas limit is too low, the bonded balance threshold checked may not cover all gas reimbursements.\n        if (metacallGasLeft < metacallExecutionGas - _execGasLowerTolerance) {\n            verifyCallsResult = ValidCallsResult.MetacallGasLimitTooLow;\n        }\n        // If gas limit is too high, the bonded balance threshold checked could unexpectedly price out solvers.\n        if (metacallGasLeft > metacallExecutionGas + _execGasUpperTolerance) {\n            verifyCallsResult = ValidCallsResult.MetacallGasLimitTooHigh;\n        }\n\n        return (verifyCallsResult, allSolversGasLimit, allSolversCalldataGas, bidFindOverhead);\n    }\n}\n"
    }
}