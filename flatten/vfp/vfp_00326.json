{
    "vfp_id": "vfp_00326",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for megapool.time.before.dissolve can prevent validators from being dissolved",
            "description": "The megapool.time.before.dissolve parameter, used to control how long before a megapool validator can be dissolved, lacks an upper guardrail. While RPIP-59/RPIP-72 define lower bounds (2/10 days), no upper limit exists, allowing the pDAO to set it to an arbitrarily large value, effectively preventing dissolution. The root cause is incomplete specification. A malicious pDAO could exploit this to lock validators indefinitely. The impact includes reduced flexibility for node operators and potential fund immobilization.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L23",
                "RocketDAOProtocolSettingsMegapool.sol#L40-L41",
                "RocketMegapoolDelegate.sol#L342-L343"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail on notify_threshold allows all exiting validators to be penalized",
            "description": "The notify.threshold parameter lacks an upper bound, allowing the pDAO to set it to an arbitrarily high value, which could result in all exiting validators being penalized for late notification.\n\nThe root cause is the absence of an upper limit in the parameter validation logic, despite RPIP-72 specifying only a lower guardrail.\n\nA malicious or misconfigured pDAO could exploit this to set a very high threshold (e.g., weeks), ensuring that nearly all node operators fail to notify in time, leading to widespread penalties.\n\nThe impact is unjust financial penalties on node operators and potential operational disruption.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L25-L26",
                "RocketDAOProtocolSettingsMegapool.sol#L44-L45",
                "RocketMegapoolDelegate.sol#L560-L564"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Incorrect operator prevents the application of the maximum allowed late notification fine",
            "description": "The setSettingUint() function uses '<' instead of '<=' when enforcing the upper limit on late.notify.fine, preventing the value from being set to exactly 0.5 ETH, which is allowed by RPIP-72.\n\nThe root cause is a logical error in the require statement, making the validation stricter than intended.\n\nThis bug prevents the protocol from applying the maximum penalty allowed by the specification, limiting governance flexibility.\n\nThe impact is reduced effectiveness of the penalty mechanism, as the maximum fine cannot be enforced even when justified.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L46-L47"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing lower guardrail on late.notify.fine allows exiting validators to never incur any late notification fine",
            "description": "The late.notify.fine parameter has an upper guardrail (≤0.5 ETH) but no lower guardrail, allowing the pDAO to set it to zero.\n\nThe root cause is the lack of a minimum value enforcement in the parameter setting logic.\n\nA malicious or self-interested pDAO could set the fine to zero, eliminating the penalty for late notification, which undermines the incentive for timely reporting.\n\nThe impact is reduced protocol security and fairness, as node operators face no penalty for late notification, increasing operational risk for the protocol.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L26",
                "RocketDAOProtocolSettingsMegapool.sol#L46-L47",
                "RocketMegapoolDelegate.sol#L560-L564"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Compromised oDAO can apply MEV theft penalty to arbitrary validators",
            "description": "The oDAO has the authority to apply MEV theft penalties without requiring cryptographic proof of theft, relying instead on trust and consensus.\n\nThe root cause is the lack of objective, verifiable criteria for determining MEV theft, combined with centralized control by a small group (13 members).\n\nIf the oDAO is compromised, members could collude to penalize innocent validators within the ETH cap, leading to unjust loss of funds.\n\nThe impact is significant financial risk to node operators and erosion of trust in the protocol's fairness, especially if penalties are applied maliciously.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L24",
                "RocketMegapoolPenalties.sol#L124-L147"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail on maximum.megapool.eth.penalty allows validators to be arbitrarily penalized for MEV theft",
            "description": "The maximum.megapool.eth.penalty parameter has a lower guardrail (>300 ETH) but no upper guardrail, allowing the pDAO to set it to an unbounded value.\n\nThe root cause is the absence of an upper limit in the parameter validation logic.\n\nA malicious or compromised pDAO could increase this value arbitrarily, enabling excessive penalties on validators even for minor or non-existent theft.\n\nThe impact is the potential for catastrophic financial loss to node operators and abuse of governance power.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L24",
                "RocketDAOProtocolSettingsMegapool.sol#L42-L43"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Outdated implementation of >= 2 days lower guardrail for megapool.time.before.dissolve deviates from specification",
            "description": "The implementation enforces a lower guardrail of >=2 days for megapool.time.before.dissolve, but RPIP-72 updated the specification to require ≥10 days.\n\nThe root cause is a failure to update the on-chain validation logic after the specification change.\n\nThis allows the pDAO to set the dissolve time lower than intended, enabling watchers to dissolve prestaked validators earlier than expected.\n\nThe impact is deviation from protocol specification and potential operational disruption, forcing validators to complete staking externally.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L23",
                "RocketDAOProtocolSettingsMegapool.sol#L40-L41",
                "RocketMegapoolDelegate.sol#L340-L344"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAOProtocolSettingsMegapool.sol": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.30;\n\nimport {RocketStorageInterface} from \"../../../../interface/RocketStorageInterface.sol\";\nimport {RocketDAOProtocolSettingsMegapoolInterface} from \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMegapoolInterface.sol\";\nimport {RocketBase} from \"../../../RocketBase.sol\";\nimport {RocketDAOProtocolSettings} from \"./RocketDAOProtocolSettings.sol\";\n\n/// @notice Network megapool settings\ncontract RocketDAOProtocolSettingsMegapool is RocketDAOProtocolSettings, RocketDAOProtocolSettingsMegapoolInterface {\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, \"megapool\") {\n        version = 1;\n        // Initialise settings on deployment\n        if (!rocketStorage.getDeployedStatus()) {\n            initialise();\n        }\n    }\n\n    /// @notice Called during deployment or upgrade to set initial values for settings\n    function initialise() override public {\n        // Set defaults\n        _setSettingUint(\"megapool.time.before.dissolve\", 28 days);               // Time that must be waited before dissolving a megapool validator (RPIP-59)\n        _setSettingUint(\"maximum.megapool.eth.penalty\", 612 ether);              // Maximum ETH penalty that can be applied over a rolling 50400 block window (RPIP-42)\n        _setSettingUint(\"notify.threshold\", 12 hours);                           // Time before withdrawable_epoch a node operator must notify exit (RPIP-72)\n        _setSettingUint(\"late.notify.fine\", 0.05 ether);                         // Fine applied to node operator for not notifying exit in time (RPIP-72)\n        _setSettingUint(\"user.distribute.window.length\", 7 days);                // How long a user must wait before distributing someone else's megapool (RPIP-72)\n        // Update deploy flag\n        require (!getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\"))), \"Already initialised\");\n        setBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")), true);\n    }\n\n    /// @notice Update a setting, overrides inherited setting method with extra checks for this contract\n    /// @param _settingPath The path of the setting within this contract's namespace\n    /// @param _value The value to set it to\n    function setSettingUint(string memory _settingPath, uint256 _value) override public onlyDAOProtocolProposal {\n        if(getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            // Some safety guards for certain settings\n            bytes32 settingKey = keccak256(abi.encodePacked(_settingPath));\n            if (settingKey == keccak256(abi.encodePacked(\"megapool.time.before.dissolve\"))) {\n                require(_value >= 2 days, \"Value must be greater or equal to 2 days\");                  // Per RPIP-59\n            } else if (settingKey == keccak256(abi.encodePacked(\"maximum.megapool.eth.penalty\"))) {\n                require(_value >= 300 ether, \"Maximum penalty must equal or exceed 300 ETH\");           // Per RPIP-42\n            } else if (settingKey == keccak256(abi.encodePacked(\"notify.threshold\"))) {\n                require(_value >= 2 hours, \"Notify threshold must be greater or equal to 2 hours\");     // Per RPIP-72\n            } else if (settingKey == keccak256(abi.encodePacked(\"late.notify.fine\"))) {\n                require(_value < 0.5 ether, \"Fine must be less than or equal to 0.5 ETH\");              // Per RPIP-72\n            } else if (settingKey == keccak256(abi.encodePacked(\"user.distribute.window.length\"))) {\n                require(_value >= 1 days && _value <= 30 days, \"Value must be between 1 and 30 days\");  // Per RPIP-72\n            }\n        }\n        // Update setting now\n        _setSettingUint(_settingPath, _value);\n    }\n\n    /// @dev Directly updates a setting, no guardrails applied\n    function _setSettingUint(string memory _settingPath, uint256 _value) internal {\n        setUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    /// @notice Returns how long after an assignment a watcher must wait to dissolve a megapool validator (seconds)\n    function getTimeBeforeDissolve() override external view returns (uint256) {\n        return getSettingUint(\"megapool.time.before.dissolve\");\n    }\n\n    /// @notice Returns the maximum amount a megapool can be penalised in 50,400 consecutive slots (~7 days)\n    function getMaximumEthPenalty() override external view returns (uint256) {\n        return getSettingUint(\"maximum.megapool.eth.penalty\");\n    }\n\n    /// @notice Returns the amount of time before `withdrawable_epoch` a node operator must notify their exit\n    function getNotifyThreshold() override external view returns (uint256) {\n        return getSettingUint(\"notify.threshold\");\n    }\n\n    /// @notice Returns the amount a node operator is fined for notifying their exit late\n    function getLateNotifyFine() override external view returns (uint256) {\n        return getSettingUint(\"late.notify.fine\");\n    }\n\n    /// @notice Returns the amount of time a user must wait before distributing another node's megapool\n    function getUserDistributeWindowLength() override external view returns (uint256) {\n        return getSettingUint(\"user.distribute.window.length\");\n    }\n}\n"
    }
}