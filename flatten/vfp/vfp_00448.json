{
    "vfp_id": "vfp_00448",
    "project_name": "cantina_stryke_aug2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Users can exercise other user's options",
            "description": "The exerciseOption function in ExerciseOptionFirewall.sol performs ownership and validation checks using the top-level optionId parameter but uses settleParams.optionId for the actual settlement. There is no validation ensuring these two IDs are identical, allowing a malicious user to pass a different optionId in the settleParams struct. The root cause is the lack of an explicit equality check between the two IDs. An attacker who owns any option can force the settlement of another user's option by setting settleParams.optionId to the victim's option ID. This leads to premature exercise of the victim's option, potentially destroying its time value and preventing the rightful owner from exercising it later under better conditions. The impact includes economic loss for option holders due to forced early exercise and loss of optionality, undermining user trust in the protocol's authorization model.\n",
            "severity": "Medium",
            "location": [
                "ExerciseOptionFirewall.sol#L71-L84"
            ],
            "files": [
                "contracts/src/periphery/firewalls/ExerciseOptionFirewall.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Premiums & AMM fees are custody-routed to feeReceiver with no on-chain entitlement for LPers",
            "description": "Option premiums and AMM fees are sent directly to a centralized feeReceiver address without on-chain accounting or attribution to individual LPs. The root cause is the lack of a trustless, on-chain reward distribution mechanism. Although the project claims to distribute rewards off-chain via Merkle claims, this introduces custodial risk and availability dependency, as LPs must rely on an external operator to claim their rewards. An attacker or malicious operator could delay, censor, or misappropriate distributions. The impact is that LPs' earnings exist only as an off-chain promise, reducing transparency and increasing counterparty risk. This undermines the decentralized ethos of DeFi and could lead to disputes or loss of funds if the off-chain system fails.\n",
            "severity": "Medium",
            "location": [
                "V3BaseHandler.sol#L442-L472"
            ],
            "files": [
                "contracts/src/handlers/V3BaseHandler.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "EIP-712 RangeCheck typehash/struct mismatch breaks signature verification",
            "description": "The declared EIP-712 typehash for RangeCheck in the firewall contracts does not match the actual data encoded during signature verification. The type string is missing the 'market' field and contains a typo ('maxSprtPriceX96' instead of 'maxSqrtPriceX96'), while the on-chain encoding includes the correct fields. The root cause is a mismatch between the declared and actual struct layout. This causes valid signatures to be rejected, leading to a denial-of-service for users trying to mint or exercise options. The impact is functional disruption of critical user flows, undermining the reliability of the protocol's off-chain signing system. This was fixed by aligning the type string with the encoded fields.\n",
            "severity": "Low",
            "location": [
                "ExerciseOptionFirewall.sol#L55-L57",
                "MintOptionFirewall.sol#L59-L61"
            ],
            "files": [
                "contracts/src/periphery/firewalls/ExerciseOptionFirewall.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ],
                "3": [
                    "CWE-628"
                ],
                "4": [
                    "CWE-688"
                ]
            },
            "title": "Incorrect argument passed to LogWithdrawReserveLiquidity event",
            "description": "The LogWithdrawReserveLiquidity event is emitted with amount1 passed twice instead of amount0 and amount1. The root cause is a coding error in the event emission. This leads to incorrect data being logged, making it difficult to debug or audit reserve withdrawals. The impact is reduced observability and potential confusion during monitoring or forensic analysis, though it does not affect the core logic or security of the protocol.\n",
            "severity": "Low",
            "location": [
                "V3BaseHandler.sol#L533"
            ],
            "files": [
                "contracts/src/handlers/V3BaseHandler.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "No per-account pro-rata withdrawal cap lets fast LPs drain the ”free bucket”",
            "description": "The V3BaseHandler contract aggregates liquidity for a given (pool, hook, tickLower, tickUpper) into a single tokenId and allows applications to consume liquidity from this shared bucket. When LPs withdraw, the contract only checks aggregate liquidity availability without enforcing a per-account cap based on their pro-rata share. This allows the first LP to withdraw all newly freed liquidity, even if it exceeds their fair share, creating a race condition. The root cause is the lack of per-user accounting for free liquidity. An attacker (or fast actor) can exploit this by being the first to submit a withdrawal after liquidity is freed, thereby draining more than their share. The impact is unfair distribution of liquidity and potential temporary stranding of slower LPs, though no direct fund loss occurs.\n",
            "severity": "Low",
            "location": [
                "V3BaseHandler.sol#L315-L319"
            ],
            "files": [
                "contracts/src/handlers/V3BaseHandler.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emission on critical parameter updates",
            "description": "Several admin setter functions across the codebase modify critical parameters affecting pricing, permissions, and payouts but do not emit events. This includes functions in OptionPricingLinearV2, MintOptionFirewall, ExerciseOptionFirewall, OpenSettlement, V3BaseHandler, and others. The root cause is the absence of event emission in these functions. Without events, external systems such as indexers, UIs, and risk monitors cannot detect changes, reducing transparency. An attacker could exploit governance changes without detection, though the direct impact is limited to reduced observability. The impact is weakened protocol transparency and potential delayed response to risky parameter changes.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "contracts/src/apps/options/pricing/OptionPricingLinearV2.sol",
                "contracts/src/periphery/firewalls/MintOptionFirewall.sol",
                "contracts/src/periphery/firewalls/ExerciseOptionFirewall.sol",
                "contracts/src/periphery/OpenSettlement.sol",
                "contracts/src/handlers/V3BaseHandler.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Remove unused event",
            "description": "The SwapperWhitelisted event is defined but never emitted in the codebase, found in V3BaseHandler.sol and OnSwapReceiver.sol. The root cause is leftover code from prior development. This has no runtime impact, but increases contract size unnecessarily. No exploitation is possible. The impact is minor bloat in the deployed bytecode.\n",
            "severity": "Informational",
            "location": [
                "V3BaseHandler.sol#L135",
                "OnSwapReceiver.sol#L41"
            ],
            "files": [
                "contracts/src/handlers/V3BaseHandler.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Prefer custom error to raw revert",
            "description": "In OptionPricingLinearV2.sol, a raw revert is used without a message, making debugging difficult. The root cause is lack of descriptive error handling. While not exploitable, this reduces transparency during failures. The impact is harder debugging and less informative reverts for users and developers.\n",
            "severity": "Informational",
            "location": [
                "OptionPricingLinearV2.sol#L257"
            ],
            "files": [
                "contracts/src/apps/options/pricing/OptionPricingLinearV2.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "ExerciseOptionFirewall.settleOption reverts in-range due to missing allowances",
            "description": "The settleOption function in ExerciseOptionFirewall is gated by whitelisted executors but does not enforce price-range or expiry checks. When called for in-range options, it delegates to the market, which attempts to pull funds from the firewall. However, the firewall has no balance or allowance, causing the call to revert. The root cause is missing preconditions and funding setup. This is expected behavior per the team, but the impact is that the function cannot be used for in-range settlements, which may confuse users if not documented.\n",
            "severity": "Informational",
            "location": [
                "ExerciseOptionFirewall.sol#L109-L131"
            ],
            "files": [
                "contracts/src/periphery/firewalls/ExerciseOptionFirewall.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading option-type flag comment contradicts BlackScholes interface",
            "description": "In OptionPricingLinearV2.sol, the comment for the option-type flag incorrectly states \"0 - Put, 1 - Call\", while the BlackScholes library uses 0 = Call, 1 = Put. The root cause is an inaccurate inline comment. Although the code correctly maps _params.isPut ? 1 : 0, the misleading comment could confuse developers. The impact is potential misunderstanding during maintenance or integration, leading to logic errors if the comment is trusted.\n",
            "severity": "Informational",
            "location": [
                "OptionPricingLinearV2.sol#L187"
            ],
            "files": [
                "contracts/src/apps/options/pricing/OptionPricingLinearV2.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect comment in minOptionPricePercentage",
            "description": "The minOptionPricePercentage variable is documented as using 1e8 precision, but the implementation divides by 1e10. The root cause is a mismatch between documentation and code. This could lead operators to set values 100x smaller than intended, resulting in a much lower price floor. The impact is potential underpricing of options if governance relies on the incorrect comment.\n",
            "severity": "Informational",
            "location": [
                "OptionPricingLinearV2.sol#L20"
            ],
            "files": [
                "contracts/src/apps/options/pricing/OptionPricingLinearV2.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "MintOptionFirewall over-collects maxCostAllowance and doesn’t refund the unused amount",
            "description": "MintOptionFirewall.mintOption transfers the full maxCostAllowance from the user to itself but only uses part of it (premium + fee) when calling the market. The remainder is not refunded and stays in the firewall. The root cause is lack of refund logic after cost reconciliation. An attacker can exploit this by backrunning mint transactions to use stranded funds. Users are overcharged, and excess funds can be used by others to mint options for free. The team acknowledges this and relies on a sweep function, but the impact is user fund loss and potential abuse.\n",
            "severity": "Informational",
            "location": [
                "MintOptionFirewall.sol#L126-L132"
            ],
            "files": [
                "contracts/src/periphery/firewalls/MintOptionFirewall.sol"
            ]
        }
    ],
    "affected_files": {
        "ExerciseOptionFirewall.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {EIP712} from \"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\";\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {IV3Pool} from \"../../interfaces/handlers/V3/IV3Pool.sol\";\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\nimport {IOptionMarketOTMFE} from \"../../interfaces/apps/options/IOptionMarketOTMFE.sol\";\nimport {ISwapper} from \"../../interfaces/ISwapper.sol\";\n\ncontract ExerciseOptionFirewall is Multicall, Ownable, EIP712 {\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    mapping(address => bool) public whitelistedExecutors;\n    mapping(address => bool) public whitelistedMarkets;\n\n    error NotWhitelistedMarket();\n    error NotWhitelistedExecutor();\n    error ArrayLenMismatch();\n    error NotOwner();\n    error OptionExpired();\n    error InvalidSignature();\n    error InvalidDeadline();\n    error InvalidTick();\n    error InvalidSqrtPriceX96();\n    error OptionNotExpired();\n\n    struct RangeCheckData {\n        address user;\n        address pool;\n        address market;\n        int24 minTickLower;\n        int24 maxTickUpper;\n        uint160 minSqrtPriceX96;\n        uint160 maxSqrtPriceX96;\n        uint256 deadline;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct PoolData {\n        uint160 sqrtPriceX96;\n        int24 tick;\n    }\n\n    bytes32 private constant RANGE_CHECK_TYPEHASH = keccak256(\n        \"RangeCheck(address user,address pool,int24 minTickLower,int24 maxTickUpper,uint160 minSqrtPriceX96,uint160 maxSprtPriceX96,uint256 deadline)\"\n    );\n\n    constructor(address _signer) EIP712(\"ExerciseOptionFirewall\", \"1\") Ownable(msg.sender) {\n        whitelistedExecutors[_signer] = true;\n    }\n\n    function updateWhitelistedExecutor(address executor, bool isWhitelisted) external onlyOwner {\n        whitelistedExecutors[executor] = isWhitelisted;\n    }\n\n    function updateWhitelistedMarket(address market, bool isWhitelisted) external onlyOwner {\n        whitelistedMarkets[market] = isWhitelisted;\n    }\n\n    function exerciseOption(\n        IOptionMarketOTMFE market,\n        uint256 optionId,\n        IOptionMarketOTMFE.SettleOptionParams memory settleParams,\n        RangeCheckData[] calldata rangeCheckData,\n        Signature[] calldata signature\n    ) external returns (IOptionMarketOTMFE.AssetsCache memory) {\n        if (!whitelistedMarkets[address(market)]) {\n            revert NotWhitelistedMarket();\n        }\n\n        if (market.ownerOf(optionId) != msg.sender) {\n            revert NotOwner();\n        }\n\n        IOptionMarketOTMFE.OptionData memory oData = market.opData(optionId);\n\n        if (oData.opTickArrayLen != rangeCheckData.length) {\n            revert ArrayLenMismatch();\n        }\n\n        for (uint256 i; i < oData.opTickArrayLen; i++) {\n            _checkRange(market, market.opTickMap(optionId, i), rangeCheckData[i], signature[i]);\n        }\n\n        (IOptionMarketOTMFE.AssetsCache memory ac) = market.settleOption(settleParams);\n\n        if (ac.isSettle) {\n            revert OptionExpired();\n        }\n\n        if (ac.totalProfit > 0) {\n            IERC20(address(ac.assetToGet)).safeTransfer(market.ownerOf(settleParams.optionId), ac.totalProfit);\n        }\n\n        return ac;\n    }\n\n    function settleOption(\n        IOptionMarketOTMFE market,\n        uint256 optionId,\n        IOptionMarketOTMFE.SettleOptionParams memory settleParams\n    ) external returns (IOptionMarketOTMFE.AssetsCache memory) {\n        if (!whitelistedMarkets[address(market)]) {\n            revert NotWhitelistedMarket();\n        }\n\n        if (!whitelistedExecutors[msg.sender]) {\n            revert NotWhitelistedExecutor();\n        }\n\n        (IOptionMarketOTMFE.AssetsCache memory ac) = market.settleOption(settleParams);\n\n        if (!ac.isSettle) revert OptionNotExpired();\n\n        if (ac.totalProfit > 0) {\n            IERC20(address(ac.assetToGet)).safeTransfer(market.ownerOf(settleParams.optionId), ac.totalProfit);\n        }\n\n        return ac;\n    }\n\n    function _checkRange(\n        IOptionMarketOTMFE market,\n        IOptionMarketOTMFE.OptionTicks memory optionTicks,\n        RangeCheckData calldata rangeCheckData,\n        Signature calldata signature\n    ) internal view {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                RANGE_CHECK_TYPEHASH,\n                msg.sender,\n                address(optionTicks.pool),\n                address(market),\n                rangeCheckData.minTickLower,\n                rangeCheckData.maxTickUpper,\n                rangeCheckData.minSqrtPriceX96,\n                rangeCheckData.maxSqrtPriceX96,\n                rangeCheckData.deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        if (!whitelistedExecutors[hash.recover(signature.v, signature.r, signature.s)]) {\n            revert InvalidSignature();\n        }\n\n        if (rangeCheckData.deadline < block.timestamp) {\n            revert InvalidDeadline();\n        }\n\n        PoolData memory poolData;\n        (, bytes memory result) = address(optionTicks.pool).staticcall(abi.encodeWithSignature(\"slot0()\"));\n        (poolData.sqrtPriceX96, poolData.tick) = abi.decode(result, (uint160, int24));\n\n        if (poolData.tick < rangeCheckData.minTickLower || poolData.tick > rangeCheckData.maxTickUpper) {\n            revert InvalidTick();\n        }\n\n        if (\n            poolData.sqrtPriceX96 < rangeCheckData.minSqrtPriceX96\n                || poolData.sqrtPriceX96 > rangeCheckData.maxSqrtPriceX96\n        ) revert InvalidSqrtPriceX96();\n    }\n\n    function hashTypedDataV4(bytes32 structHash) public view returns (bytes32) {\n        return _hashTypedDataV4(structHash);\n    }\n\n    function getRangeCheckTypehash() public pure returns (bytes32) {\n        return RANGE_CHECK_TYPEHASH;\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n",
        "OpenSettlement.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IOptionMarketOTMFE} from \"../interfaces/apps/options/IOptionMarketOTMFE.sol\";\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport {ISwapper} from \"../interfaces/ISwapper.sol\";\n\n/// @title OpenSettlement\n/// @notice Contract that handles the settlement of expired options with a two-tier fee structure\n/// @dev Inherits from Ownable and uses SafeERC20 for token transfers\ncontract OpenSettlement is Ownable {\n    using SafeERC20 for ERC20;\n\n    // events\n\n    event LogSettleOptionsOpen(\n        address indexed market,\n        uint256 indexed optionId,\n        uint256 totalProfitForUser,\n        uint256 settledFeeProtocol,\n        uint256 settledFeePublic\n    );\n\n    // errors\n    /// @notice Thrown when attempting to settle an option that hasn't been settled by the market\n    error OptionNotSettled();\n\n    /// @notice Fee percentage for whitelisted settlers (in SETTLE_FEE_PRECISION basis points)\n    uint256 public settleFeeProtocol;\n\n    /// @notice Fee percentage for public settlers (in SETTLE_FEE_PRECISION basis points)\n    uint256 public settleFeePublic;\n\n    /// @notice Precision for fee calculations (10,000 = 100%)\n    uint256 public constant SETTLE_FEE_PRECISION = 10_000;\n\n    /// @notice Address that receives settlement fees\n    address public publicFeeRecipient;\n\n    /// @notice Mapping of addresses to their whitelisted settler status\n    mapping(address => bool) public isWhitelistedSettler;\n\n    /// @notice Constructs the OpenSettlement contract\n    /// @param _isWhitelistedSettler Initial whitelisted settler address\n    /// @param _publicFeeRecipient Address to receive settlement fees\n    /// @param _settleFeeProtocol Fee percentage for whitelisted settlers\n    /// @param _settleFeePublic Fee percentage for public settlers\n    constructor(\n        address _isWhitelistedSettler,\n        address _publicFeeRecipient,\n        uint256 _settleFeeProtocol,\n        uint256 _settleFeePublic\n    ) Ownable(msg.sender) {\n        settleFeeProtocol = _settleFeeProtocol;\n        settleFeePublic = _settleFeePublic;\n        isWhitelistedSettler[_isWhitelistedSettler] = true;\n        publicFeeRecipient = _publicFeeRecipient;\n    }\n\n    /// @notice Settles an option and distributes profits according to the fee structure\n    /// @dev Whitelisted settlers pay a lower fee than public settlers\n    /// @param market The option market contract\n    /// @param optionId The ID of the option to settle\n    /// @param settleParams Parameters required for settlement\n    /// @return AssetsCache struct containing settlement results\n    function openSettle(\n        IOptionMarketOTMFE market,\n        uint256 optionId,\n        IOptionMarketOTMFE.SettleOptionParams memory settleParams\n    ) external returns (IOptionMarketOTMFE.AssetsCache memory) {\n        (IOptionMarketOTMFE.AssetsCache memory ac) = market.settleOption(settleParams);\n\n        if (!ac.isSettle) revert OptionNotSettled();\n\n        if (ac.totalProfit > 0) {\n            if (settleFeeProtocol > 0) {\n                uint256 feeProtocol;\n                uint256 feePublic;\n\n                if (isWhitelistedSettler[msg.sender]) {\n                    feeProtocol = (ac.totalProfit * settleFeeProtocol) / SETTLE_FEE_PRECISION;\n                    ac.assetToGet.safeTransfer(publicFeeRecipient, feeProtocol);\n                    ac.assetToGet.safeTransfer(market.ownerOf(optionId), ac.totalProfit - feeProtocol);\n                } else {\n                    feeProtocol = (ac.totalProfit * (settleFeeProtocol - settleFeePublic)) / SETTLE_FEE_PRECISION;\n                    feePublic = (ac.totalProfit * settleFeePublic) / SETTLE_FEE_PRECISION;\n                    ac.assetToGet.safeTransfer(publicFeeRecipient, feeProtocol);\n                    ac.assetToGet.safeTransfer(msg.sender, feePublic);\n                    ac.assetToGet.safeTransfer(market.ownerOf(optionId), ac.totalProfit - feeProtocol - feePublic);\n                }\n\n                emit LogSettleOptionsOpen(\n                    address(market), optionId, ac.totalProfit - feeProtocol - feePublic, feeProtocol, feePublic\n                );\n            } else {\n                ac.assetToGet.safeTransfer(market.ownerOf(optionId), ac.totalProfit);\n                emit LogSettleOptionsOpen(address(market), optionId, ac.totalProfit, 0, 0);\n            }\n        }\n\n        return ac;\n    }\n\n    /// @notice Updates the protocol fee percentage for whitelisted settlers\n    /// @param _settleFeeProtocol New fee percentage in SETTLE_FEE_PRECISION basis points\n    function setSettleFeeProtocol(uint256 _settleFeeProtocol) external onlyOwner {\n        settleFeeProtocol = _settleFeeProtocol;\n    }\n\n    /// @notice Updates the public fee percentage for non-whitelisted settlers\n    /// @param _settleFeePublic New fee percentage in SETTLE_FEE_PRECISION basis points\n    function setSettleFeePublic(uint256 _settleFeePublic) external onlyOwner {\n        settleFeePublic = _settleFeePublic;\n    }\n\n    /// @notice Updates the whitelisted status of a settler address\n    /// @param _isWhitelistedSettler Address to update\n    /// @param _isWhitelistedSettlerStatus New whitelisted status\n    function setIsWhitelistedSettler(address _isWhitelistedSettler, bool _isWhitelistedSettlerStatus)\n        external\n        onlyOwner\n    {\n        isWhitelistedSettler[_isWhitelistedSettler] = _isWhitelistedSettlerStatus;\n    }\n\n    /// @notice Updates the address that receives settlement fees\n    /// @param _publicFeeRecipient New fee recipient address\n    function setPublicFeeRecipient(address _publicFeeRecipient) external onlyOwner {\n        publicFeeRecipient = _publicFeeRecipient;\n    }\n}\n",
        "OptionPricingLinearV2.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Libraries\nimport {SafeMath} from \"../../../libraries/math/SafeMath.sol\";\nimport {BlackScholes} from \"./external/BlackScholes.sol\";\n\n// Contracts\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\n\ncontract OptionPricingLinearV2 is Ownable {\n    using SafeMath for uint256;\n\n    // The offset for volatility calculation in 1e4 precision\n    mapping(address => uint256) public volatilityOffset;\n\n    // The multiplier for volatility calculation in 1e4 precision\n    mapping(address => uint256) public volatilityMultiplier;\n\n    // The % of the price of asset which is the minimum option price possible in 1e8 precision\n    mapping(address => uint256) public minOptionPricePercentage;\n\n    // The decimal precision for volatility calculation\n    uint256 public constant VOLATILITY_PRECISION = 1e4;\n\n    // Time to expiry => volatility\n    mapping(address => mapping(uint256 => uint256)) public ttlToVol;\n\n    // IV Setter addresses\n    mapping(address => bool) public ivSetter;\n\n    error NotIVSetter();\n    error Vol_Not_Set();\n    error ArrayLengthMismatch();\n\n    constructor() Ownable(msg.sender) {\n        ivSetter[msg.sender] = true;\n    }\n\n    /*---- GOVERNANCE FUNCTIONS ----*/\n\n    /// @notice Updates the IV setter\n    /// @param _setter Address of the setter\n    /// @param _status Status  to set\n    /// @dev Only the owner of the contract can call this function\n    function updateIVSetter(address _setter, bool _status) external onlyOwner {\n        ivSetter[_setter] = _status;\n    }\n\n    /// @notice Updates the implied volatility (IV) for the given time to expirations (TTLs).\\\n    /// @param _optionsMarket The address of the options market\n    /// @param _ttls The TTLs to update the IV for.\n    /// @param _ttlIV The new IVs for the given TTLs.\n    /// @dev Only the IV SETTER can call this function.\n    function updateIVs(address _optionsMarket, uint256[] calldata _ttls, uint256[] calldata _ttlIV) external {\n        if (!ivSetter[msg.sender]) revert NotIVSetter();\n        if (_ttls.length != _ttlIV.length) revert ArrayLengthMismatch();\n\n        for (uint256 i; i < _ttls.length; i++) {\n            ttlToVol[_optionsMarket][_ttls[i]] = _ttlIV[i];\n        }\n    }\n\n    /// @notice updates the offset for volatility calculation\n    /// @param _optionsMarket The address of the options market\n    /// @param _volatilityOffset the new offset\n    /// @return whether offset was updated\n    function updateVolatilityOffset(address _optionsMarket, uint256 _volatilityOffset)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        volatilityOffset[_optionsMarket] = _volatilityOffset;\n\n        return true;\n    }\n\n    /// @notice updates the multiplier for volatility calculation\n    /// @param _optionsMarket The address of the options market\n    /// @param _volatilityMultiplier the new multiplier\n    /// @return whether multiplier was updated\n    function updateVolatilityMultiplier(address _optionsMarket, uint256 _volatilityMultiplier)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        volatilityMultiplier[_optionsMarket] = _volatilityMultiplier;\n\n        return true;\n    }\n\n    /// @notice updates % of the price of asset which is  the minimum option price possible\n    /// @param _optionsMarket The address of the options market\n    /// @param _minOptionPricePercentage the new %\n    /// @return whether % was updated\n    function updateMinOptionPricePercentage(address _optionsMarket, uint256 _minOptionPricePercentage)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minOptionPricePercentage[_optionsMarket] = _minOptionPricePercentage;\n\n        return true;\n    }\n\n    /*---- VIEWS ----*/\n\n    struct OptionPriceParams {\n        address optionsMarket;\n        address hook;\n        bool isPut;\n        uint256 expiry;\n        uint256 ttl;\n        uint256 strike;\n        uint256 lastPrice;\n    }\n\n    /// @notice computes the option price (with liquidity multiplier)\n    /// @param _hook The address of the hook\n    /// @param _isPut is put option\n    /// @param _expiry expiry timestamp\n    /// @param _ttl time to live for the option\n    /// @param _strike strike price\n    /// @param _lastPrice current price\n    function getOptionPrice(\n        address _hook,\n        bool _isPut,\n        uint256 _expiry,\n        uint256 _ttl,\n        uint256 _strike,\n        uint256 _lastPrice\n    ) external view returns (uint256) {\n        return _getOptionPrice(\n            OptionPriceParams({\n                optionsMarket: msg.sender,\n                hook: _hook,\n                isPut: _isPut,\n                expiry: _expiry,\n                ttl: _ttl,\n                strike: _strike,\n                lastPrice: _lastPrice\n            })\n        );\n    }\n\n    /// @notice computes the option price (with liquidity multiplier)\n    /// @param _optionsMarket the address of the options market\n    /// @param _hook The address of the hook\n    /// @param _isPut is put option\n    /// @param _expiry expiry timestamp\n    /// @param _ttl time to live for the option\n    /// @param _strike strike price\n    /// @param _lastPrice current price\n    function getOptionPriceViaAdddress(\n        address _optionsMarket,\n        address _hook,\n        bool _isPut,\n        uint256 _expiry,\n        uint256 _ttl,\n        uint256 _strike,\n        uint256 _lastPrice\n    ) external view returns (uint256) {\n        return _getOptionPrice(\n            OptionPriceParams({\n                optionsMarket: _optionsMarket,\n                hook: _hook,\n                isPut: _isPut,\n                expiry: _expiry,\n                ttl: _ttl,\n                strike: _strike,\n                lastPrice: _lastPrice\n            })\n        );\n    }\n\n    function _getOptionPrice(OptionPriceParams memory _params) internal view returns (uint256) {\n        uint256 timeToExpiry = _params.expiry.sub(block.timestamp).div(864);\n\n        uint256 volatility = ttlToVol[_params.optionsMarket][_params.ttl];\n\n        if (volatility == 0) revert Vol_Not_Set();\n\n        volatility = getVolatility(_params.optionsMarket, _params.strike, _params.lastPrice, volatility);\n\n        uint256 optionPrice = BlackScholes.calculate(\n            _params.isPut ? 1 : 0, _params.lastPrice, _params.strike, timeToExpiry, 0, volatility\n        ) // 0 - Put, 1 - Call\n                // Number of days to expiry mul by 100\n            .div(BlackScholes.DIVISOR);\n\n        uint256 minOptionPrice = _params.lastPrice.mul(minOptionPricePercentage[_params.optionsMarket]).div(1e10);\n\n        if (minOptionPrice > optionPrice) {\n            return minOptionPrice;\n        }\n\n        return optionPrice;\n    }\n    /// @notice computes the option price (with liquidity multiplier)\n    /// @param hook the address of the hook\n    /// @param isPut is put option\n    /// @param ttl time to live for the option\n    /// @param strike strike price\n    /// @param lastPrice current price\n\n    function getOptionPriceViaTTL(address hook, bool isPut, uint256 ttl, uint256 strike, uint256 lastPrice)\n        external\n        view\n        returns (uint256)\n    {\n        return _getOptionPriceViaTTL(\n            OptionPriceParams({\n                optionsMarket: msg.sender,\n                hook: hook,\n                isPut: isPut,\n                expiry: 0,\n                ttl: ttl,\n                strike: strike,\n                lastPrice: lastPrice\n            })\n        );\n    }\n\n    /// @notice computes the option price (with liquidity multiplier)\n    /// @param optionsMarket the address of the options market\n    /// @param hook the address of the hook\n    /// @param isPut is put option\n    /// @param ttl time to live for the option\n    /// @param strike strike price\n    /// @param lastPrice current price\n    function getOptionPriceViaTTLViaAddress(\n        address optionsMarket,\n        address hook,\n        bool isPut,\n        uint256 ttl,\n        uint256 strike,\n        uint256 lastPrice\n    ) external view returns (uint256) {\n        return _getOptionPriceViaTTL(\n            OptionPriceParams({\n                optionsMarket: optionsMarket,\n                hook: hook,\n                isPut: isPut,\n                expiry: 0,\n                ttl: ttl,\n                strike: strike,\n                lastPrice: lastPrice\n            })\n        );\n    }\n\n    function _getOptionPriceViaTTL(OptionPriceParams memory _params) internal view returns (uint256) {\n        uint256 timeToExpiry = _params.ttl.div(864);\n\n        uint256 volatility = ttlToVol[_params.optionsMarket][_params.ttl];\n\n        if (volatility == 0) revert();\n\n        volatility = getVolatility(_params.optionsMarket, _params.strike, _params.lastPrice, volatility);\n\n        uint256 optionPrice = BlackScholes.calculate(\n            _params.isPut ? 1 : 0, _params.lastPrice, _params.strike, timeToExpiry, 0, volatility\n        ) // 0 - Put, 1 - Call\n                // Number of days to expiry mul by 100\n            .div(BlackScholes.DIVISOR);\n\n        uint256 minOptionPrice = _params.lastPrice.mul(minOptionPricePercentage[_params.optionsMarket]).div(1e10);\n\n        if (minOptionPrice > optionPrice) {\n            return minOptionPrice;\n        }\n\n        return optionPrice;\n    }\n\n    /// @notice computes the volatility for a strike\n    /// @param _optionsMarket the address of the options market\n    /// @param strike strike price\n    /// @param lastPrice current price\n    /// @param volatility volatility\n    function getVolatility(address _optionsMarket, uint256 strike, uint256 lastPrice, uint256 volatility)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 percentageDifference = strike.mul(1e2).mul(VOLATILITY_PRECISION).div(lastPrice); // 1e4 in percentage precision (1e6 is 100%)\n\n        if (strike > lastPrice) {\n            percentageDifference = percentageDifference.sub(1e6);\n        } else {\n            percentageDifference = uint256(1e6).sub(percentageDifference);\n        }\n\n        uint256 scaleFactor = volatilityOffset[_optionsMarket]\n            + (percentageDifference.mul(volatilityMultiplier[_optionsMarket]).div(VOLATILITY_PRECISION));\n\n        return (volatility.mul(scaleFactor).div(VOLATILITY_PRECISION));\n    }\n}\n",
        "V3BaseHandler.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IHandler} from \"../interfaces/IHandler.sol\";\nimport {IHook} from \"../interfaces/IHook.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {IV3Pool} from \"../interfaces/handlers/V3/IV3Pool.sol\";\n\nimport {ERC6909} from \"../libraries/tokens/ERC6909.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LiquidityAmounts} from \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport {TickMath} from \"v3-core/libraries/TickMath.sol\";\nimport {FullMath} from \"v3-core/libraries/FullMath.sol\";\nimport {FixedPoint128} from \"v3-core/libraries/FixedPoint128.sol\";\n\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n/// @title V3BaseHandler\n/// @author 0xcarrot\n/// @notice Abstract contract for handling Uniswap V3 liquidity positions\n/// @dev Implements IHandler interface and inherits from ERC6909 and Ownable\nabstract contract V3BaseHandler is IHandler, ERC6909, Ownable {\n    using Math for uint128;\n    using TickMath for int24;\n    using SafeERC20 for IERC20;\n\n    /// @notice Struct to store information about a token ID\n    struct TokenIdInfo {\n        uint128 totalLiquidity;\n        uint128 liquidityUsed;\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n        address token0;\n        address token1;\n        uint24 fee;\n        uint128 reservedLiquidity;\n    }\n\n    /// @notice Struct for minting a new position\n    struct MintPositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n    }\n\n    /// @notice Struct for burning an existing position\n    struct BurnPositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n    }\n\n    /// @notice Struct for reserving liquidity\n    struct ReserveOperation {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        bool isReserve;\n    }\n\n    /// @notice Struct for using a position\n    struct UsePositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidityToUse;\n    }\n\n    /// @notice Struct for un-using a position\n    struct UnusePositionParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidityToUnuse;\n    }\n\n    /// @notice Struct for donating to a position\n    struct DonateParams {\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 amount0;\n        uint128 amount1;\n    }\n\n    /// @notice Enum for wildcard actions\n    enum WildcardActions {\n        RESERVE_LIQUIDITY,\n        COLLECT_FEES\n    }\n\n    /// @notice Struct for reserved liquidity information\n    struct ReserveLiquidityInfo {\n        uint128 liquidity;\n        uint64 lastReserve;\n    }\n\n    /// @notice Mapping of token IDs to their information\n    mapping(uint256 => TokenIdInfo) public tokenIds;\n    /// @notice Mapping of whitelisted applications\n    mapping(address => bool) public whitelistedApps;\n    /// @notice Mapping of reserved liquidity per user for each token ID\n    mapping(uint256 => mapping(address => ReserveLiquidityInfo)) public reservedLiquidityPerUser;\n\n    /// @notice Mapping of reserve cooldown per hook\n    mapping(address => uint64) public reserveCooldownHook;\n\n    /// @notice Mapping of registered hooks\n    mapping(address => bool) public hookRegistered;\n\n    /// @notice Mapping of hook permissions\n    mapping(address => HookPermInfo) public hookPerms;\n\n    /// @notice Address of the fee receiver\n    address public feeReceiver;\n\n    /// @notice Pause state of the contract\n    bool pause;\n\n    error NotWhitelisted();\n    error InsufficientLiquidity();\n    error BeforeReserveCooldown();\n    error InvalidTicks();\n    error HookNotRegistered();\n    error Paused();\n    error HookAlreadyRegistered();\n\n    event LogMintPositionHandler(MintPositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogBurnPositionHandler(BurnPositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogUsePositionHandler(UsePositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogUnusePositionHandler(UnusePositionParams params, address context, uint256 amount0, uint256 amount1);\n    event LogDonateToPosition(DonateParams params, address context);\n    event LogReservedLiquidity(ReserveOperation params, address context, uint256 lastReserve);\n    event LogWithdrawReserveLiquidity(ReserveOperation params, address context, uint256 amount0, uint256 amount1);\n    event LogCollectedFees(\n        IV3Pool pool, address hook, int24 tickLower, int24 tickUpper, uint256 tokensOwed0, uint256 tokensOwed1\n    );\n\n    /// @notice Constructor for V3BaseHandler\n    /// @param _feeReceiver Address to receive fees\n    constructor(address _feeReceiver) Ownable(msg.sender) {\n        feeReceiver = _feeReceiver;\n    }\n\n    /// @notice Checks if the caller is whitelisted\n    function onlyWhitelisted() private view {\n        if (!whitelistedApps[msg.sender]) revert NotWhitelisted();\n        if (pause) revert Paused();\n    }\n\n    /// @notice Registers a new hook\n    /// @param _hook Address of the hook to register\n    /// @param _info Permission information for the hook\n    function registerHook(address _hook, IHandler.HookPermInfo memory _info) external onlyOwner {\n        if (hookRegistered[_hook]) {\n            revert HookAlreadyRegistered();\n        }\n\n        hookPerms[_hook] = _info;\n        hookRegistered[_hook] = true;\n    }\n\n    struct MintLiquidityInternalCache {\n        bool self;\n        uint256 tokenId;\n        IV3Pool pool;\n        address hook;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        int24 tickLower;\n        int24 tickUpper;\n        address context;\n    }\n\n    /// @notice Mints a new position in the Uniswap V3 pool\n    /// @param context The address context for minting\n    /// @param _mintPositionData Encoded data for minting position\n    /// @return sharesMinted The amount of shares minted\n    function mintPositionHandler(address context, bytes calldata _mintPositionData) external returns (uint256) {\n        onlyWhitelisted();\n\n        (MintPositionParams memory _params, bytes memory hookData) =\n            abi.decode(_mintPositionData, (MintPositionParams, bytes));\n\n        if (hookPerms[_params.hook].onMint && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onMintBefore(hookData);\n        }\n\n        (uint128 liquidity,,) = mintInternal(\n            MintLiquidityInternalCache({\n                self: false,\n                tokenId: uint256(\n                    keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n                ),\n                pool: _params.pool,\n                hook: _params.hook,\n                liquidity: _params.liquidity,\n                amount0: 0,\n                amount1: 0,\n                tickLower: _params.tickLower,\n                tickUpper: _params.tickUpper,\n                context: context\n            })\n        );\n\n        return liquidity;\n    }\n\n    function mintInternal(MintLiquidityInternalCache memory cache) private returns (uint128, uint256, uint256) {\n        TokenIdInfo storage tki = tokenIds[cache.tokenId];\n\n        if (tki.token0 == address(0)) {\n            tki.token0 = cache.pool.token0();\n            tki.token1 = cache.pool.token1();\n            tki.fee = cache.pool.fee();\n        }\n\n        (uint160 sqrtPriceX96,) = _getCurrentSqrtPriceX96(cache.pool);\n\n        if (cache.liquidity == 0) {\n            cache.liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96,\n                cache.tickLower.getSqrtRatioAtTick(),\n                cache.tickUpper.getSqrtRatioAtTick(),\n                cache.amount0,\n                cache.amount1\n            );\n        }\n\n        if (cache.amount0 == 0 && cache.amount1 == 0) {\n            (cache.amount0, cache.amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                sqrtPriceX96,\n                cache.tickLower.getSqrtRatioAtTick(),\n                cache.tickUpper.getSqrtRatioAtTick(),\n                cache.liquidity\n            );\n        }\n\n        (cache.liquidity, cache.amount0, cache.amount1) =\n            _addLiquidity(cache.self, tki, cache.tickLower, cache.tickUpper, cache.amount0, cache.amount1);\n\n        _feeCalculation(tki, cache.pool, cache.tickLower, cache.tickUpper);\n\n        tki.totalLiquidity += cache.liquidity;\n\n        _mint(cache.context, cache.tokenId, cache.liquidity);\n\n        emit LogMintPositionHandler(\n            MintPositionParams(cache.pool, cache.hook, cache.tickLower, cache.tickUpper, cache.liquidity),\n            cache.context,\n            cache.amount0,\n            cache.amount1\n        );\n\n        return (cache.liquidity, cache.amount0, cache.amount1);\n    }\n\n    struct BurnLiquidityInternalCache {\n        uint256 tokenId;\n        IV3Pool pool;\n        address hook;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        address context;\n        address receiver;\n    }\n\n    /// @notice Burns an existing position in the Uniswap V3 pool\n    /// @param context The address context for burning\n    /// @param _burnPositionData Encoded data for burning position\n    /// @return The amount of liquidity burned\n    function burnPositionHandler(address context, bytes calldata _burnPositionData) external returns (uint256) {\n        onlyWhitelisted();\n\n        (BurnPositionParams memory _params, bytes memory hookData) =\n            abi.decode(_burnPositionData, (BurnPositionParams, bytes));\n\n        if (hookPerms[_params.hook].onBurn && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onBurnBefore(hookData);\n        }\n\n        burnInternal(\n            BurnLiquidityInternalCache({\n                tokenId: uint256(\n                    keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n                ),\n                pool: _params.pool,\n                hook: _params.hook,\n                tickLower: _params.tickLower,\n                tickUpper: _params.tickUpper,\n                liquidity: _params.liquidity,\n                context: context,\n                receiver: context\n            })\n        );\n\n        return _params.liquidity;\n    }\n\n    function burnInternal(BurnLiquidityInternalCache memory cache) private returns (uint256, uint256) {\n        TokenIdInfo storage tki = tokenIds[cache.tokenId];\n\n        if ((tki.totalLiquidity - tki.liquidityUsed) < cache.liquidity) {\n            revert InsufficientLiquidity();\n        }\n\n        (uint256 amount0, uint256 amount1) = cache.pool.burn(cache.tickLower, cache.tickUpper, cache.liquidity);\n\n        _feeCalculation(tki, cache.pool, cache.tickLower, cache.tickUpper);\n\n        cache.pool.collect(cache.receiver, cache.tickLower, cache.tickUpper, uint128(amount0), uint128(amount1));\n\n        tki.totalLiquidity -= cache.liquidity;\n\n        _burn(cache.context, cache.tokenId, cache.liquidity);\n\n        emit LogBurnPositionHandler(\n            BurnPositionParams(cache.pool, cache.hook, cache.tickLower, cache.tickUpper, cache.liquidity),\n            cache.context,\n            amount0,\n            amount1\n        );\n\n        return (amount0, amount1);\n    }\n\n    /// @notice Uses a portion of liquidity from an existing position\n    /// @param _usePositionData Encoded data for using position\n    /// @return An array of token addresses, an array of amounts, and the liquidity used\n    function usePositionHandler(bytes calldata _usePositionData)\n        external\n        returns (address[] memory, uint256[] memory, uint256)\n    {\n        onlyWhitelisted();\n\n        (UsePositionParams memory _params, bytes memory hookData) =\n            abi.decode(_usePositionData, (UsePositionParams, bytes));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        if (hookPerms[_params.hook].onUse && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onPositionUseBefore(hookData);\n        }\n\n        if ((tki.totalLiquidity - tki.liquidityUsed) < _params.liquidityToUse) {\n            revert InsufficientLiquidity();\n        }\n\n        (uint256 amount0, uint256 amount1) =\n            _removeLiquidity(_params.pool, _params.tickLower, _params.tickUpper, _params.liquidityToUse);\n\n        _params.pool.collect(msg.sender, _params.tickLower, _params.tickUpper, uint128(amount0), uint128(amount1));\n\n        _feeCalculation(tki, _params.pool, _params.tickLower, _params.tickUpper);\n\n        tki.liquidityUsed += _params.liquidityToUse;\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tki.token0;\n        tokens[1] = tki.token1;\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n\n        emit LogUsePositionHandler(_params, msg.sender, amount0, amount1);\n\n        return (tokens, amounts, _params.liquidityToUse);\n    }\n\n    /// @notice Returns previously used liquidity to a position\n    /// @param _unusePositionData Encoded data for un-using position\n    /// @return An array of amounts and the liquidity returned\n    function unusePositionHandler(bytes calldata _unusePositionData) external returns (uint256[] memory, uint256) {\n        onlyWhitelisted();\n\n        (UnusePositionParams memory _params, bytes memory hookData) =\n            abi.decode(_unusePositionData, (UnusePositionParams, bytes));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        if (hookPerms[_params.hook].onUnuse && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onPositionUnUseBefore(hookData);\n        }\n\n        (uint160 sqrtPriceX96,) = _getCurrentSqrtPriceX96(_params.pool);\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            _params.tickLower.getSqrtRatioAtTick(),\n            _params.tickUpper.getSqrtRatioAtTick(),\n            uint128(_params.liquidityToUnuse)\n        );\n\n        (uint128 liquidity,,) = _addLiquidity(false, tki, _params.tickLower, _params.tickUpper, amount0, amount1);\n\n        _feeCalculation(tki, _params.pool, _params.tickLower, _params.tickUpper);\n\n        if (tki.liquidityUsed >= liquidity) {\n            tki.liquidityUsed -= liquidity;\n        } else {\n            tki.totalLiquidity += (liquidity - tki.liquidityUsed);\n            tki.liquidityUsed = 0;\n        }\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n\n        _params.liquidityToUnuse = liquidity;\n\n        emit LogUnusePositionHandler(_params, msg.sender, amount0, amount1);\n\n        return (amounts, uint256(liquidity));\n    }\n\n    /// @notice Allows donation of tokens to a specific position\n    /// @param _donateData Encoded data for donation\n    /// @return An array of amounts and a placeholder value\n    function donateToPosition(bytes calldata _donateData) external returns (uint256[] memory, uint256) {\n        onlyWhitelisted();\n\n        (DonateParams memory _params, bytes memory hookData) = abi.decode(_donateData, (DonateParams, bytes));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        if (hookPerms[_params.hook].onDonate && hookRegistered[_params.hook]) {\n            IHook(_params.hook).onDonationBefore(hookData);\n        }\n\n        TokenIdInfo memory tki = tokenIds[tokenId];\n\n        if (_params.amount0 > 0) {\n            IERC20(tki.token0).safeTransferFrom(msg.sender, feeReceiver, _params.amount0);\n        }\n\n        if (_params.amount1 > 0) {\n            IERC20(tki.token1).safeTransferFrom(msg.sender, feeReceiver, _params.amount1);\n        }\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = _params.amount0;\n        amounts[1] = _params.amount1;\n\n        emit LogDonateToPosition(_params, msg.sender);\n\n        return (amounts, 0);\n    }\n\n    /// @notice Handles various wildcard actions\n    /// @param context The address context for the action\n    /// @param _wildcardData Encoded data for the wildcard action\n    /// @return Encoded result of the wildcard action\n    function wildcardHandler(address context, bytes calldata _wildcardData) external returns (bytes memory) {\n        onlyWhitelisted();\n\n        (WildcardActions wca, bytes memory _data) = abi.decode(_wildcardData, (WildcardActions, bytes));\n\n        if (wca == WildcardActions.RESERVE_LIQUIDITY) {\n            _reserveOps(context, _data);\n        } else if (wca == WildcardActions.COLLECT_FEES) {\n            _collectFees(_data);\n        }\n        return bytes(\"\");\n    }\n\n    /// @notice Internal function to reserve liquidity\n    /// @param context The address context for the operation\n    /// @param _reserveOperation Encoded data for the reserve operation\n    function _reserveOps(address context, bytes memory _reserveOperation) private {\n        ReserveOperation memory _params = abi.decode(_reserveOperation, (ReserveOperation));\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encode(address(this), _params.pool, _params.hook, _params.tickLower, _params.tickUpper))\n        );\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        ReserveLiquidityInfo storage rld = reservedLiquidityPerUser[tokenId][context];\n\n        if (_params.isReserve) {\n            rld.liquidity += _params.liquidity;\n            rld.lastReserve = uint64(block.timestamp);\n\n            tki.totalLiquidity -= _params.liquidity;\n\n            tki.reservedLiquidity += _params.liquidity;\n\n            _burn(context, tokenId, _params.liquidity);\n\n            emit LogReservedLiquidity(_params, context, rld.lastReserve);\n        } else {\n            if (rld.lastReserve + reserveCooldownHook[_params.hook] > block.timestamp) revert BeforeReserveCooldown();\n\n            if (((tki.totalLiquidity + tki.reservedLiquidity) - tki.liquidityUsed) < _params.liquidity) {\n                revert InsufficientLiquidity();\n            }\n\n            (uint256 amount0, uint256 amount1) =\n                _params.pool.burn(_params.tickLower, _params.tickUpper, _params.liquidity);\n\n            _params.pool.collect(context, _params.tickLower, _params.tickUpper, uint128(amount0), uint128(amount1));\n\n            _feeCalculation(tki, _params.pool, _params.tickLower, _params.tickUpper);\n\n            tki.reservedLiquidity -= _params.liquidity;\n            rld.liquidity -= _params.liquidity;\n\n            emit LogWithdrawReserveLiquidity(_params, context, amount1, amount1);\n        }\n    }\n\n    /// @notice Calculates the tokens required for a position\n    /// @param _positionData Encoded position data\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function _tokensToPull(bytes calldata _positionData) private view returns (address[] memory, uint256[] memory) {\n        (MintPositionParams memory _params,) = abi.decode(_positionData, (MintPositionParams, bytes));\n\n        (uint160 sqrtPriceX96,) = _getCurrentSqrtPriceX96(_params.pool);\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            _params.tickLower.getSqrtRatioAtTick(),\n            _params.tickUpper.getSqrtRatioAtTick(),\n            uint128(_params.liquidity)\n        );\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = _params.pool.token0();\n        tokens[1] = _params.pool.token1();\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n\n        return (tokens, amounts);\n    }\n\n    /// @notice Calculates tokens required for un-using a position\n    /// @param _unusePositionData Encoded data for un-using a position\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function tokensToPullForUnUse(bytes calldata _unusePositionData)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        return _tokensToPull(_unusePositionData);\n    }\n\n    /// @notice Calculates tokens required for donating to a position\n    /// @param _donatePosition Encoded data for donation\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function tokensToPullForDonate(bytes calldata _donatePosition)\n        external\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        (DonateParams memory _params,) = abi.decode(_donatePosition, (DonateParams, bytes));\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = _params.pool.token0();\n        tokens[1] = _params.pool.token1();\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = _params.amount0;\n        amounts[1] = _params.amount1;\n\n        return (tokens, amounts);\n    }\n\n    /// @notice Calculates tokens required for wildcard actions\n    /// @param _data wildcard data (unused in this implementation)\n    /// @return tokens An array of token addresses (empty in this implementation)\n    /// @return amounts An array of token amounts (empty in this implementation)\n    function tokensToPullForWildcard(bytes calldata _data) external view returns (address[] memory, uint256[] memory) {\n        address[] memory tokens = new address[](2);\n        uint256[] memory amounts = new uint256[](2);\n        return (tokens, amounts);\n    }\n\n    /// @notice Generates a unique identifier for a handler\n    /// @param _data Encoded data for generating the identifier\n    /// @return handlerIdentifierId The unique identifier\n    function getHandlerIdentifier(bytes calldata _data) external view returns (uint256 handlerIdentifierId) {\n        (address pool, address hook, int24 tickLower, int24 tickUpper) =\n            abi.decode(_data, (address, address, int24, int24));\n\n        return uint256(keccak256(abi.encode(address(this), pool, hook, tickLower, tickUpper)));\n    }\n\n    /// @notice Calculates tokens required for minting a position\n    /// @param _mintPositionData Encoded data for minting a position\n    /// @return tokens An array of token addresses\n    /// @return amounts An array of token amounts\n    function tokensToPullForMint(bytes calldata _mintPositionData)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        return _tokensToPull(_mintPositionData);\n    }\n\n    /// @notice Internal function to get the current sqrt price from a pool\n    /// @param pool The Uniswap V3 pool\n    /// @return sqrtPriceX96 The current sqrt price\n    /// @return tick The current tick\n    function _getCurrentSqrtPriceX96(IV3Pool pool) internal view returns (uint160 sqrtPriceX96, int24 tick) {\n        (sqrtPriceX96, tick,,,,,) = pool.slot0();\n    }\n\n    /// @notice Internal function to add liquidity to a position\n    /// @param self Whether the operation is performed by the contract itself\n    /// @param tki Token ID information\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0\n    /// @param amount1 The amount of token1\n    /// @return liquidity The amount of liquidity added\n    /// @return amount0 The actual amount of token0 used\n    /// @return amount1 The actual amount of token1 used\n    function _addLiquidity(\n        bool self,\n        TokenIdInfo memory tki,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    ) internal virtual returns (uint128, uint256, uint256) {}\n\n    /// @notice Internal function to remove liquidity from a position\n    /// @param _pool The Uniswap V3 pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidity The amount of liquidity to remove\n    /// @return amount0 The amount of token0 received\n    /// @return amount1 The amount of token1 received\n    function _removeLiquidity(IV3Pool _pool, int24 tickLower, int24 tickUpper, uint128 liquidity)\n        internal\n        virtual\n        returns (uint256, uint256)\n    {}\n\n    /// @notice Internal function to compute the position key\n    /// @param owner The owner of the position\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @return The position key\n    function _computePositionKey(address owner, int24 tickLower, int24 tickUpper) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n    }\n\n    /// @notice Internal function to collect fees from a position\n    /// @param _collectFeesData Encoded data for fee collection\n    function _collectFees(bytes memory _collectFeesData) internal virtual {\n        (IV3Pool _pool, address _hook, int24 _tickLower, int24 _tickUpper) =\n            abi.decode(_collectFeesData, (IV3Pool, address, int24, int24));\n\n        uint256 tokenId = uint256(keccak256(abi.encode(address(this), _pool, _hook, _tickLower, _tickUpper)));\n\n        TokenIdInfo storage tki = tokenIds[tokenId];\n\n        _removeLiquidity(_pool, _tickLower, _tickUpper, 0);\n\n        _feeCalculation(tki, _pool, _tickLower, _tickUpper);\n\n        emit LogCollectedFees(_pool, _hook, _tickLower, _tickUpper, tki.tokensOwed0, tki.tokensOwed1);\n\n        _pool.collect(feeReceiver, _tickLower, _tickUpper, tki.tokensOwed0, tki.tokensOwed1);\n\n        tki.tokensOwed0 = 0;\n        tki.tokensOwed1 = 0;\n    }\n\n    /// @notice Internal function to calculate fees for a position\n    /// @param _tki Token ID information\n    /// @param _pool The Uniswap V3 pool\n    /// @param _tickLower The lower tick of the position\n    /// @param _tickUpper The upper tick of the position\n    function _feeCalculation(TokenIdInfo storage _tki, IV3Pool _pool, int24 _tickLower, int24 _tickUpper)\n        internal\n        virtual\n    {\n        bytes32 positionKey = _computePositionKey(address(this), _tickLower, _tickUpper);\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128,,) = _pool.positions(positionKey);\n        unchecked {\n            _tki.tokensOwed0 += uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0LastX128 - _tki.feeGrowthInside0LastX128,\n                    _tki.totalLiquidity + _tki.reservedLiquidity - _tki.liquidityUsed,\n                    FixedPoint128.Q128\n                )\n            );\n            _tki.tokensOwed1 += uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1LastX128 - _tki.feeGrowthInside1LastX128,\n                    _tki.totalLiquidity + _tki.reservedLiquidity - _tki.liquidityUsed,\n                    FixedPoint128.Q128\n                )\n            );\n\n            _tki.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n            _tki.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n        }\n    }\n\n    // Admin Functions\n\n    /// @notice Updates various handler settings\n    /// @param _app The app to update the whitelist status of\n    /// @param _status The new whitelist status of the app\n    /// @param _hook The hook to update the reserve cooldown for\n    /// @param _newReserveCooldown The new reserve cooldown for the hook\n    /// @param _newFeeReceiver The new fee receiver address\n    function updateHandlerSettings(\n        address _app,\n        bool _status,\n        address _hook,\n        uint64 _newReserveCooldown,\n        address _newFeeReceiver\n    ) external onlyOwner {\n        whitelistedApps[_app] = _status;\n        reserveCooldownHook[_hook] = _newReserveCooldown;\n        feeReceiver = _newFeeReceiver;\n    }\n\n    // SOS admin functions\n\n    /// @notice Sweeps tokens from the contract\n    /// @param _token The token to sweep\n    /// @param _amount The amount of tokens to sweep\n    function sweepTokens(address _token, uint256 _amount) external onlyOwner {\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /// @notice Emergency pauses the contract\n    function emergencyPause() external onlyOwner {\n        pause = true;\n    }\n\n    /// @notice Emergency unpauses the contract\n    function emergencyUnpause() external onlyOwner {\n        pause = false;\n    }\n\n    /// @notice Checks if the contract supports an interface\n    /// @param interfaceId The Id of the interface\n    /// @return bool True if the interface is supported\n    function supportsInterface(bytes4 interfaceId) public view override(ERC6909) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n",
        "MintOptionFirewall.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IOptionMarketOTMFE} from \"../../interfaces/apps/options/IOptionMarketOTMFE.sol\";\nimport {ISwapper} from \"../../interfaces/ISwapper.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {EIP712} from \"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\";\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {IV3Pool} from \"../../interfaces/handlers/V3/IV3Pool.sol\";\n\ncontract MintOptionFirewall is Multicall, EIP712, Ownable, IERC721Receiver {\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    mapping(address => bool) public whitelistedSigners;\n\n    error InvalidSignature();\n    error InvalidDeadline();\n    error InvalidTick();\n    error InvalidSqrtPriceX96();\n    error InvalidOptionParams();\n    error InvalidSignatureLen();\n\n    struct RangeCheckData {\n        address user;\n        address pool;\n        address market;\n        int24 minTickLower;\n        int24 maxTickUpper;\n        uint160 minSqrtPriceX96;\n        uint160 maxSqrtPriceX96;\n        uint256 deadline;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct PoolData {\n        uint160 sqrtPriceX96;\n        int24 tick;\n    }\n\n    struct OptionData {\n        IOptionMarketOTMFE market;\n        IOptionMarketOTMFE.OptionParams optionParams;\n        address optionRecipient;\n        bool self;\n    }\n\n    bytes32 private constant RANGE_CHECK_TYPEHASH = keccak256(\n        \"RangeCheck(address user,address pool,int24 minTickLower,int24 maxTickUpper,uint160 minSqrtPriceX96,uint160 maxSprtPriceX96,uint256 deadline)\"\n    );\n\n    constructor(address _signer) EIP712(\"MintOptionFirewall\", \"1\") Ownable(msg.sender) {\n        whitelistedSigners[_signer] = true;\n    }\n\n    function updateWhitelistedSigner(address _signer, bool _isWhitelisted) external onlyOwner {\n        whitelistedSigners[_signer] = _isWhitelisted;\n    }\n\n    /// @notice Emitted when an option is minted through this router\n    /// @param user The address initiating the mint\n    /// @param receiver The address receiving the minted option\n    /// @param market The address of the option market\n    /// @param optionId The ID of the minted option\n    event MintOption(address user, address receiver, address market, uint256 optionId);\n\n    /// @notice Wraps ETH into WETH\n    /// @param weth The address of the WETH contract\n    /// @param amount The amount of ETH to wrap\n    function wrap(address weth, uint256 amount) external payable {\n        IWETH(weth).deposit{value: amount}();\n        IERC20(weth).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice Executes multiple token swaps through specified swapper contracts\n    /// @param swapper Array of swapper contract addresses\n    /// @param tokensIn Array of input token addresses\n    /// @param tokensOut Array of output token addresses\n    /// @param amounts Array of input amounts\n    /// @param swapData Array of encoded swap data for each swap\n    function swap(\n        address[] calldata swapper,\n        address[] calldata tokensIn,\n        address[] calldata tokensOut,\n        uint256[] calldata amounts,\n        bytes[] calldata swapData\n    ) external {\n        for (uint256 i; i < tokensIn.length; i++) {\n            IERC20(tokensIn[i]).safeTransferFrom(msg.sender, swapper[i], amounts[i]);\n            ISwapper(swapper[i]).onSwapReceived(tokensIn[i], tokensOut[i], amounts[i], swapData[i]);\n        }\n    }\n\n    function mintOption(\n        OptionData memory optionData,\n        RangeCheckData[] calldata rangeCheckData,\n        Signature[] calldata signature\n    ) external {\n        if (rangeCheckData.length != signature.length) {\n            revert InvalidSignatureLen();\n        }\n\n        if (optionData.optionParams.optionTicks.length != rangeCheckData.length) {\n            revert InvalidSignatureLen();\n        }\n\n        for (uint256 i; i < rangeCheckData.length; i++) {\n            _checkRange(optionData.market, optionData.optionParams.optionTicks[i], rangeCheckData[i], signature[i]);\n        }\n\n        address callAsset = optionData.market.callAsset();\n        address putAsset = optionData.market.putAsset();\n\n        if (!optionData.self) {\n            if (optionData.optionParams.isCall) {\n                IERC20(callAsset).safeTransferFrom(msg.sender, address(this), optionData.optionParams.maxCostAllowance);\n                IERC20(callAsset).approve(address(optionData.market), optionData.optionParams.maxCostAllowance);\n            } else {\n                IERC20(putAsset).safeTransferFrom(msg.sender, address(this), optionData.optionParams.maxCostAllowance);\n                IERC20(putAsset).approve(address(optionData.market), optionData.optionParams.maxCostAllowance);\n            }\n        } else {\n            if (optionData.optionParams.isCall) {\n                IERC20(callAsset).safeIncreaseAllowance(\n                    address(optionData.market), optionData.optionParams.maxCostAllowance\n                );\n            } else {\n                IERC20(putAsset).safeIncreaseAllowance(\n                    address(optionData.market), optionData.optionParams.maxCostAllowance\n                );\n            }\n        }\n\n        optionData.market.mintOption(optionData.optionParams);\n\n        uint256 tokenId = optionData.market.optionIds();\n\n        IERC721(address(optionData.market)).transferFrom(address(this), optionData.optionRecipient, tokenId);\n\n        emit MintOption(msg.sender, optionData.optionRecipient, address(optionData.market), tokenId);\n    }\n\n    /// @notice Sweeps any remaining tokens from the contract to a specified address\n    /// @param token The token address to sweep\n    /// @param to The address to send the tokens to\n    function sweep(address token, address to) external {\n        IERC20(token).safeTransfer(to, IERC20(token).balanceOf(address(this)));\n    }\n\n    /// @notice Required implementation for IERC721Receiver\n    /// @dev Allows this contract to receive ERC721 tokens\n    /// @return bytes4 The function selector\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function _checkRange(\n        IOptionMarketOTMFE market,\n        IOptionMarketOTMFE.OptionTicks memory optionTicks,\n        RangeCheckData calldata rangeCheckData,\n        Signature calldata signature\n    ) internal view {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                RANGE_CHECK_TYPEHASH,\n                msg.sender,\n                address(optionTicks.pool),\n                address(market),\n                rangeCheckData.minTickLower,\n                rangeCheckData.maxTickUpper,\n                rangeCheckData.minSqrtPriceX96,\n                rangeCheckData.maxSqrtPriceX96,\n                rangeCheckData.deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        if (!whitelistedSigners[hash.recover(signature.v, signature.r, signature.s)]) {\n            revert InvalidSignature();\n        }\n\n        if (rangeCheckData.deadline < block.timestamp) {\n            revert InvalidDeadline();\n        }\n\n        PoolData memory poolData;\n        (, bytes memory result) = address(optionTicks.pool).staticcall(abi.encodeWithSignature(\"slot0()\"));\n        (poolData.sqrtPriceX96, poolData.tick) = abi.decode(result, (uint160, int24));\n\n        if (poolData.tick < rangeCheckData.minTickLower || poolData.tick > rangeCheckData.maxTickUpper) {\n            revert InvalidTick();\n        }\n\n        if (\n            poolData.sqrtPriceX96 < rangeCheckData.minSqrtPriceX96\n                || poolData.sqrtPriceX96 > rangeCheckData.maxSqrtPriceX96\n        ) revert InvalidSqrtPriceX96();\n    }\n\n    function hashTypedDataV4(bytes32 structHash) public view returns (bytes32) {\n        return _hashTypedDataV4(structHash);\n    }\n\n    function getRangeCheckTypehash() public pure returns (bytes32) {\n        return RANGE_CHECK_TYPEHASH;\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    }
}