{
    "vfp_id": "vfp_00547",
    "project_name": "cantina_eco_february2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "An incorrect predicate operator allows anyone to prevent fillers from withdrawing rewards by overfunding intent vaults",
            "description": "The IntentVault contract uses an incorrect predicate `amount < balance` in a conditional check that reverts if the balance is insufficient. This logic is flawed because it allows an attacker to deposit excess tokens into the vault, making the balance greater than the intended reward amount. As a result, when a filler attempts to withdraw rewards, the condition `amount < balance` becomes true, causing the transaction to revert due to an assumed insufficient balance, even though sufficient funds are present.\n\nThe root cause is the misuse of the comparison operator in the balance validation logic. Instead of checking if the available balance is sufficient (i.e., `balance >= amount`), the code checks the inverse, leading to incorrect reverts.\n\nAn attacker can exploit this by funding an intent vault with more tokens than specified in the reward structure. This can be done by anyone, including a malicious intent creator, who can then block legitimate fillers from claiming their rewards.\n\nThe impact is critical as it disrupts the core functionality of reward distribution, potentially leading to denial of service for fillers and undermining trust in the protocol.\n",
            "severity": "Critical",
            "location": [
                "IntentVault.sol#L69-L72"
            ],
            "files": [
                "eco-routes/contracts/Vault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Malicious reward token can block legitimate reward claims",
            "description": "The IntentVault contract attempts to transfer all reward tokens atomically to the claimant upon intent fulfillment. If one of the reward tokens has malicious logic (e.g., reverts on transfer), the entire withdrawal transaction will fail, blocking all other legitimate transfers.\n\nThe root cause is the use of high-level transfer calls in a loop without handling potential failures individually. This creates a single point of failure for the entire reward distribution process.\n\nAn attacker can exploit this by creating or specifying a malicious ERC20 token as a reward, which reverts on transfer. Once such a token is included in an intent, no filler can successfully claim rewards, even if other tokens are legitimate and transferable.\n\nThe impact is high as it allows a single malicious token to disrupt the reward mechanism, leading to denial of service and potential loss of incentives for honest participants.\n",
            "severity": "High",
            "location": [
                "IntentVault.sol#L52-L83"
            ],
            "files": [
                "eco-routes/contracts/Vault.sol"
            ]
        }
    ],
    "affected_files": {
        "Vault.sol": "/* -*- c-basic-offset: 4 -*- */\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IIntentSource} from \"./interfaces/IIntentSource.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IPermit} from \"./interfaces/IPermit.sol\";\n\nimport {Reward} from \"./types/Intent.sol\";\n\n/**\n * @title Vault\n * @notice A self-destructing contract that handles reward distribution for intents\n * @dev Created by IntentSource for each intent, handles token and native currency transfers,\n * then self-destructs after distributing rewards\n */\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Creates and immediately executes reward distribution\n     * @dev Contract self-destructs after execution\n     */\n    constructor(bytes32 intentHash, Reward memory reward) {\n        IIntentSource intentSource = IIntentSource(msg.sender);\n        VaultState memory state = intentSource.getVaultState(intentHash);\n\n        if (state.mode == uint8(VaultMode.Fund)) {\n            _fundIntent(intentSource, intentHash, state, reward);\n        } else if (state.mode == uint8(VaultMode.Claim)) {\n            _processRewardTokens(reward, state.target);\n            _processNativeReward(reward, state.target);\n        } else if (state.mode == uint8(VaultMode.Refund)) {\n            _processRewardTokens(reward, reward.creator);\n        } else if (state.mode == uint8(VaultMode.RecoverToken)) {\n            _recoverToken(state.target, reward.creator);\n        }\n\n        selfdestruct(payable(reward.creator));\n    }\n\n    /**\n     * @dev Funds the intent with required tokens\n     */\n    function _fundIntent(\n        IIntentSource intentSource,\n        bytes32 intentHash,\n        VaultState memory state,\n        Reward memory reward\n    ) internal {\n        // Get the address that is providing the tokens for funding\n        address fundingSource = state.target;\n        uint256 rewardsLength = reward.tokens.length;\n        address permitContract;\n\n        if (state.usePermit == 1) {\n            permitContract = intentSource.getPermitContract(intentHash);\n        }\n\n        // Iterate through each token in the reward structure\n        for (uint256 i; i < rewardsLength; ++i) {\n            // Get token address and required amount for current reward\n            address token = reward.tokens[i].token;\n            uint256 amount = reward.tokens[i].amount;\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            // Only proceed if vault needs more tokens and we have permission to transfer them\n            if (amount > balance) {\n                // Calculate how many more tokens the vault needs to be fully funded\n                uint256 remainingAmount = amount - balance;\n\n                if (permitContract != address(0)) {\n                    remainingAmount = _transferFromPermit(\n                        IPermit(permitContract),\n                        fundingSource,\n                        token,\n                        remainingAmount\n                    );\n                }\n\n                if (remainingAmount > 0) {\n                    _transferFrom(\n                        fundingSource,\n                        token,\n                        remainingAmount,\n                        state.allowPartialFunding\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Processes all reward tokens\n     */\n    function _processRewardTokens(\n        Reward memory reward,\n        address claimant\n    ) internal {\n        uint256 rewardsLength = reward.tokens.length;\n\n        for (uint256 i; i < rewardsLength; ++i) {\n            address token = reward.tokens[i].token;\n            uint256 amount = reward.tokens[i].amount;\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            if (claimant == reward.creator || balance < amount) {\n                if (claimant != reward.creator) {\n                    emit RewardTransferFailed(token, claimant, amount);\n                }\n                if (balance > 0) {\n                    _tryTransfer(token, claimant, balance);\n                }\n            } else {\n                _tryTransfer(token, claimant, amount);\n\n                // Return excess balance to creator\n                if (balance > amount) {\n                    _tryTransfer(token, reward.creator, balance - amount);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Processes native token reward\n     */\n    function _processNativeReward(\n        Reward memory reward,\n        address claimant\n    ) internal {\n        if (reward.nativeValue > 0) {\n            uint256 amount = reward.nativeValue;\n            if (address(this).balance < reward.nativeValue) {\n                emit RewardTransferFailed(address(0), claimant, amount);\n                amount = address(this).balance;\n            }\n\n            (bool success, ) = payable(claimant).call{value: amount}(\"\");\n            if (!success) {\n                emit RewardTransferFailed(address(0), claimant, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Processes refund token if specified\n     */\n    function _recoverToken(address refundToken, address creator) internal {\n        uint256 refundAmount = IERC20(refundToken).balanceOf(address(this));\n        if (refundAmount > 0) {\n            IERC20(refundToken).safeTransfer(creator, refundAmount);\n        }\n    }\n\n    /**\n     * @notice Attempts to transfer tokens to a recipient, emitting an event on failure\n     * @param token Address of the token being transferred\n     * @param to Address of the recipient\n     * @param amount Amount of tokens to transfer\n     */\n    function _tryTransfer(address token, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        if (!success || (data.length > 0 && !abi.decode(data, (bool)))) {\n            emit RewardTransferFailed(token, to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfers tokens from funding source to vault\n     * @param fundingSource Address that is providing the tokens for funding\n     * @param token Address of the token being transferred\n     * @param amount Amount of tokens to transfer\n     * @param allowPartialFunding Whether to allow partial funding\n     */\n    function _transferFrom(\n        address fundingSource,\n        address token,\n        uint256 amount,\n        uint8 allowPartialFunding\n    ) internal {\n        // Check how many tokens this contract is allowed to transfer from funding source\n        uint256 allowance = IERC20(token).allowance(\n            fundingSource,\n            address(this)\n        );\n\n        uint256 transferAmount;\n        // Calculate transfer amount as minimum of what's needed and what's allowed\n        if (allowance >= amount) {\n            transferAmount = amount;\n        } else if (allowPartialFunding == 1) {\n            transferAmount = allowance;\n        } else {\n            revert InsufficientTokenAllowance(token, fundingSource, amount);\n        }\n\n        if (transferAmount > 0) {\n            // Transfer tokens from funding source to vault using safe transfer\n            IERC20(token).safeTransferFrom(\n                fundingSource,\n                address(this),\n                transferAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Transfers tokens from funding source to vault using external Permit contract\n     * @param permit Permit2 like contract to use for token transfer\n     * @param fundingSource Address that is providing the tokens for funding\n     * @param token Address of the token being transferred\n     * @param amount Amount of tokens to transfer\n     * @return remainingAmount Amount of tokens that still need to be transferred\n     */\n    function _transferFromPermit(\n        IPermit permit,\n        address fundingSource,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 remainingAmount) {\n        // Check how many tokens this contract is allowed to transfer from funding source\n        (uint160 allowance, , ) = permit.allowance(\n            fundingSource,\n            token,\n            address(this)\n        );\n\n        uint256 transferAmount;\n        // Calculate transfer amount as minimum of what's needed and what's allowed\n        if (allowance >= amount) {\n            transferAmount = amount;\n            remainingAmount = 0;\n        } else {\n            transferAmount = allowance;\n            remainingAmount = amount - allowance;\n        }\n\n        if (transferAmount > 0) {\n            // Transfer tokens from funding source to vault using Permit.transferFrom\n            permit.transferFrom(\n                fundingSource,\n                address(this),\n                uint160(transferAmount),\n                token\n            );\n        }\n    }\n}\n"
    }
}