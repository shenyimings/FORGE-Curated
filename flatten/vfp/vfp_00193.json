{
    "vfp_id": "vfp_00193",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Use OZ Math.min()",
            "description": "1. **Description:** The code uses ternary operators to compute the minimum of two values in multiple locations, such as in Atlas.sol and GasAccounting.sol.\n2. **Cause:** Manual implementation instead of using OpenZeppelin's Math.min(), which is more gas-efficient and readable.\n3. **Exploitation:** Not exploitable for security breaches, but represents a missed optimization.\n4. **Impact:** Slightly higher gas costs during execution and reduced code readability.\n",
            "severity": "Informational",
            "location": [
                "Atlas.sol#L295-L296",
                "GasAccounting.sol#L300"
            ],
            "files": [
                "atlas/src/contracts/atlas/Atlas.sol"
            ]
        }
    ],
    "affected_files": {
        "Atlas.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { LibSort } from \"solady/utils/LibSort.sol\";\n\nimport { Escrow } from \"./Escrow.sol\";\nimport { Factory } from \"./Factory.sol\";\n\nimport \"../types/SolverOperation.sol\";\nimport \"../types/UserOperation.sol\";\nimport \"../types/LockTypes.sol\";\nimport \"../types/ConfigTypes.sol\";\nimport \"../types/DAppOperation.sol\";\nimport \"../types/ValidCalls.sol\";\n\nimport { CallBits } from \"../libraries/CallBits.sol\";\nimport { SafetyBits } from \"../libraries/SafetyBits.sol\";\nimport { GasAccLib, GasLedger } from \"../libraries/GasAccLib.sol\";\nimport { IL2GasCalculator } from \"../interfaces/IL2GasCalculator.sol\";\nimport { IDAppControl } from \"../interfaces/IDAppControl.sol\";\n\n/// @title Atlas V1.5\n/// @author FastLane Labs\n/// @notice The Execution Abstraction protocol.\ncontract Atlas is Escrow, Factory {\n    using CallBits for uint32;\n    using SafetyBits for Context;\n    using GasAccLib for uint256;\n    using GasAccLib for GasLedger;\n\n    constructor(\n        uint256 escrowDuration,\n        uint256 atlasSurchargeRate,\n        address verification,\n        address simulator,\n        address initialSurchargeRecipient,\n        address l2GasCalculator,\n        address factoryLib\n    )\n        Escrow(escrowDuration, atlasSurchargeRate, verification, simulator, initialSurchargeRecipient, l2GasCalculator)\n        Factory(factoryLib)\n    { }\n\n    /// @notice metacall is the entrypoint function for the Atlas transactions.\n    /// @dev Any ETH sent as msg.value with a metacall should be considered a potential subsidy for the winning solver's\n    /// gas repayment.\n    /// @param userOp The UserOperation struct containing the user's transaction data.\n    /// @param solverOps The SolverOperation array containing the solvers' transaction data.\n    /// @param dAppOp The DAppOperation struct containing the DApp's transaction data.\n    /// @param gasRefundBeneficiary The address to receive the gas refund.\n    /// @return auctionWon A boolean indicating whether there was a successful, winning solver.\n    function metacall(\n        UserOperation calldata userOp, // set by user\n        SolverOperation[] calldata solverOps, // supplied by ops relay\n        DAppOperation calldata dAppOp, // supplied by front end via atlas SDK\n        address gasRefundBeneficiary // address(0) = msg.sender\n    )\n        external\n        payable\n        returns (bool auctionWon)\n    {\n        // _gasMarker calculated as (Execution gas cost) + (Calldata gas cost). Any gas left at the end of the metacall\n        // is deducted from this _gasMarker, resulting in actual execution gas used + calldata gas costs + buffer.\n        // The calldata component is added below, only if exPostBids = false.\n        uint256 _gasLeft = gasleft();\n        uint256 _gasMarker = _gasLeft + _BASE_TX_GAS_USED + FIXED_GAS_OFFSET; // This part is only execution gas.\n\n        DAppConfig memory _dConfig;\n        bool _isSimulation = msg.sender == SIMULATOR;\n        address _executionEnvironment;\n        address _bundler = _isSimulation ? dAppOp.bundler : msg.sender;\n        (_executionEnvironment, _dConfig) = _getOrCreateExecutionEnvironment(userOp);\n\n        // Validate metacall params, and get back vars used in gas accounting logic\n        (\n            uint256 _allSolversGasLimit,\n            uint256 _allSolversCalldataGas,\n            uint256 _bidFindOverhead,\n            ValidCallsResult _validCallsResult\n        ) = VERIFICATION.validateCalls({\n            dConfig: _dConfig,\n            userOp: userOp,\n            solverOps: solverOps,\n            dAppOp: dAppOp,\n            metacallGasLeft: _gasLeft,\n            msgValue: msg.value,\n            msgSender: _bundler,\n            isSimulation: _isSimulation\n        });\n\n        // Solvers pay for calldata when exPostBids = false\n        if (!_dConfig.callConfig.exPostBids()) {\n            // total calldata gas = solver calldata gas + (userOp + dAppOp + offset) calldata gas\n            _gasMarker += _allSolversCalldataGas\n                + GasAccLib.metacallCalldataGas(\n                    userOp.data.length + USER_OP_STATIC_LENGTH + DAPP_OP_LENGTH + _EXTRA_CALLDATA_LENGTH, L2_GAS_CALCULATOR\n                );\n        }\n\n        // Handle the ValidCallsResult\n        if (_validCallsResult != ValidCallsResult.Valid) {\n            if (_isSimulation) revert VerificationSimFail(_validCallsResult);\n\n            // Gracefully return for results that need nonces to be stored and prevent replay attacks\n            if (uint8(_validCallsResult) >= _GRACEFUL_RETURN_THRESHOLD && !_dConfig.callConfig.allowsReuseUserOps()) {\n                return false;\n            }\n\n            // Revert for all other results\n            revert ValidCalls(_validCallsResult);\n        }\n\n        // Initialize the environment lock and accounting values\n        _setEnvironmentLock(_dConfig, _executionEnvironment);\n\n        // _gasMarker - _bidFindOverhead = estimated winning solver gas liability (not charged for bid-find gas)\n        // userOp.bundlerSurchargeRate is checked against the value set in the DAppControl in `validateCalls()` above\n        _initializeAccountingValues({\n            gasMarker: _gasMarker - _bidFindOverhead,\n            allSolverOpsGas: _allSolversGasLimit,\n            bundlerSurchargeRate: userOp.bundlerSurchargeRate\n        });\n\n        // Calculate `execute` gas limit such that it can fail due to an OOG error caused by any of the hook calls, and\n        // the metacall will still have enough gas to gracefully finish and return, storing any nonces required.\n        uint256 _gasLimit = gasleft() * 63 / 64 - _GRACEFUL_RETURN_GAS_OFFSET;\n\n        // userOpHash has already been calculated and verified in validateCalls at this point, so rather\n        // than re-calculate it, we can simply take it from the dAppOp here. It's worth noting that this will\n        // be either a TRUSTED or DEFAULT hash, depending on the allowsTrustedOpHash setting.\n        try this.execute{ gas: _gasLimit }(\n            _dConfig, userOp, solverOps, dAppOp.userOpHash, _executionEnvironment, _bundler, _isSimulation\n        ) returns (Context memory ctx) {\n            GasLedger memory _gL = t_gasLedger.toGasLedger(); // Final load, no need to persist changes after this\n            uint256 _unreachedCalldataValuePaid;\n\n            // Only charge unreached solverOps for their calldata if NOT in exPostBids mode\n            if (!_dConfig.callConfig.exPostBids()) {\n                _unreachedCalldataValuePaid = _chargeUnreachedSolversForCalldata(\n                    solverOps,\n                    _gL,\n                    ctx.solverIndex,\n                    dAppOp.userOpHash,\n                    userOp.maxFeePerGas,\n                    _bundler,\n                    _dConfig.callConfig.allowsTrustedOpHash()\n                );\n            }\n\n            // Gas Refund to sender only if execution is successful, or if multipleSuccessfulSolvers\n            (uint256 _ethPaidToBundler, uint256 _netGasSurcharge) = _settle(\n                ctx,\n                _gL,\n                _gasMarker,\n                gasRefundBeneficiary,\n                _unreachedCalldataValuePaid,\n                _dConfig.callConfig.multipleSuccessfulSolvers()\n            );\n\n            auctionWon = ctx.solverSuccessful;\n            emit MetacallResult(msg.sender, userOp.from, auctionWon, _ethPaidToBundler, _netGasSurcharge);\n        } catch (bytes memory revertData) {\n            // Bubble up some specific errors\n            _handleErrors(revertData, _dConfig.callConfig);\n            // Set lock to FullyLocked to prevent any reentrancy possibility\n            _setLockPhase(uint8(ExecutionPhase.FullyLocked));\n\n            // Refund the msg.value to sender if it errored\n            // WARNING: If msg.sender is a disposable address such as a session key, make sure to remove ETH from it\n            // before disposal\n            if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value);\n\n            // Emit event indicating the metacall failed in `execute()`\n            emit MetacallResult(msg.sender, userOp.from, false, 0, 0);\n        }\n\n        // The environment lock is explicitly released here to allow multiple (sequential, not nested) metacalls in a\n        // single transaction.\n        _releaseLock();\n    }\n\n    /// @notice execute is called above, in a try-catch block in metacall.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param userOpHash The hash of the UserOperation.\n    /// @param executionEnvironment The address of the execution environment.\n    /// @param bundler The address of the bundler.\n    /// @param isSimulation Whether the current execution is a simulation.\n    /// @return ctx Context struct containing relevant context information for the Atlas auction.\n    function execute(\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes32 userOpHash,\n        address executionEnvironment,\n        address bundler,\n        bool isSimulation\n    )\n        external\n        payable\n        returns (Context memory ctx)\n    {\n        // This is a self.call made externally so that it can be used with try/catch\n        if (msg.sender != address(this)) revert InvalidAccess();\n\n        // Build the context object\n        ctx = _buildContext(\n            userOpHash, executionEnvironment, bundler, dConfig.dappGasLimit, uint8(solverOps.length), isSimulation\n        );\n\n        bytes memory _returnData;\n\n        // PreOps Call\n        if (dConfig.callConfig.needsPreOpsCall()) {\n            _returnData = _executePreOpsCall(ctx, dConfig, userOp);\n        }\n\n        // UserOp Call\n        _returnData = _executeUserOperation(ctx, dConfig, userOp, _returnData);\n\n        // SolverOps Calls\n        uint256 _winningBidAmount = dConfig.callConfig.exPostBids()\n            ? _bidFindingIteration(ctx, dConfig, userOp, solverOps, _returnData)\n            : _bidKnownIteration(ctx, dConfig, userOp, solverOps, _returnData);\n\n        // AllocateValue Call\n        _allocateValue(ctx, dConfig, _winningBidAmount, _returnData);\n    }\n\n    /// @notice Called above in `execute` if the DAppConfig requires ex post bids. Sorts solverOps by bid amount and\n    /// executes them in descending order until a successful winner is found.\n    /// @param ctx Context struct containing the current state of the escrow lock.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param returnData Return data from the preOps and userOp calls.\n    /// @return The winning bid amount or 0 when no solverOps.\n    function _bidFindingIteration(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 _gasWaterMark = gasleft(); // track bid-finding gas, to be written off.\n        uint256 solverOpsLength = solverOps.length; // computed once for efficiency\n\n        // Return early if no solverOps (e.g. in simUserOperation)\n        if (solverOpsLength == 0) {\n            if (ctx.isSimulation) revert SolverSimFail(0);\n            if (dConfig.callConfig.needsFulfillment()) revert UserNotFulfilled();\n            return 0;\n        }\n\n        ctx.bidFind = true;\n\n        uint256[] memory _bidsAndIndices = new uint256[](solverOpsLength);\n        uint256 _bidAmountFound;\n        uint256 _solverExecutionGas;\n        uint256 _bidsAndIndicesLastIndex = solverOpsLength - 1; // Start from the last index\n\n        // Get a snapshot of the GasLedger from transient storage, to reset to after bid-finding below\n        uint256 _gasLedgerSnapshot = t_gasLedger;\n\n        // First, get all bid amounts. Bids of zero are ignored by only storing non-zero bids in the array, from right\n        // to left. If there are any zero bids they will end up on the left as uint(0) values - in their sorted\n        // position. This reduces operations needed later when sorting the array in ascending order.\n        // Each non-zero bid amount is packed with its original solverOps array index, to fit into a uint256 value. The\n        // order of bidAmount and index is important - with bidAmount using the most significant bits, and considering\n        // we do not store zero bids in the array, the index values within the uint256 should not impact the sorting.\n\n        // |<------------------------- uint256 (256 bits) ------------------------->|\n        // |                                                                        |\n        // |<------------------ uint240 ----------------->|<-------- uint16 ------->|\n        // |                                              |                         |\n        // |                    bidAmount                 |          index          |\n        // |                                              |                         |\n        // |<------------------ 240 bits ---------------->|<------- 16 bits ------->|\n\n        for (uint256 i; i < solverOpsLength; ++i) {\n            _bidAmountFound = _getBidAmount(ctx, dConfig, userOp, solverOps[i], returnData);\n\n            // In `_getBidAmount()` above, unreachedSolverGas is decreased while remainingMaxGas does not change, as it\n            // is normally decreased in `_handleSolverFailAccounting()` which is not called in a bid-finding context. To\n            // adjust for this difference so GasLedger.solverGasLiability() still works, we have to decrease\n            // remainingMaxGas separately here. This decrease does not include calldata gas as solvers are not charged\n            // for calldata gas in exPostBids mode.\n            GasLedger memory _gL = t_gasLedger.toGasLedger();\n            // Deduct solverOp.gas, with a max of dConfig.solverGasLimit, from remainingMaxGas\n            _solverExecutionGas =\n                (solverOps[i].gas > dConfig.solverGasLimit) ? dConfig.solverGasLimit : solverOps[i].gas;\n            _gL.remainingMaxGas -= uint40(_solverExecutionGas);\n            t_gasLedger = _gL.pack();\n\n            // skip zero and overflow bid's\n            if (_bidAmountFound != 0 && _bidAmountFound <= type(uint240).max) {\n                // Non-zero bids are packed with their original solverOps index.\n                // The array is filled with non-zero bids from the right.\n                _bidsAndIndices[_bidsAndIndicesLastIndex] = uint256(_bidAmountFound << _BITS_FOR_INDEX | uint16(i));\n                unchecked {\n                    --_bidsAndIndicesLastIndex;\n                }\n            }\n        }\n\n        // Reset transient GasLedger to its state before the bid-finding loop above\n        t_gasLedger = _gasLedgerSnapshot;\n\n        // Reinitialize _bidsAndIndicesLastIndex to iterate through the sorted array in descending order\n        _bidsAndIndicesLastIndex = solverOpsLength - 1;\n\n        // Then, sorts the uint256 array in-place, in ascending order.\n        LibSort.insertionSort(_bidsAndIndices);\n\n        ctx.bidFind = false;\n\n        // Write off the gas cost involved in on-chain bid-finding execution of all solverOps, as these costs should be\n        // paid by the bundler.\n        _writeOffBidFindGas(_gasWaterMark - gasleft());\n\n        // Finally, iterate through sorted bidsAndIndices array in descending order of bidAmount.\n        for (uint256 i = _bidsAndIndicesLastIndex;; /* breaks when 0 */ --i) {\n            // Now, track gas watermark to charge/writeoff gas for each solverOp\n            _gasWaterMark = gasleft();\n\n            // Isolate the bidAmount from the packed uint256 value\n            _bidAmountFound = _bidsAndIndices[i] >> _BITS_FOR_INDEX;\n\n            // If we reach the zero bids on the left of array, break as all valid bids already checked.\n            if (_bidAmountFound == 0) break;\n\n            // NOTE: We reuse the ctx.solverIndex variable to store the count of solver ops that have been executed.\n            // This count is useful in `_settle()` when we may penalize the bundler for overestimating gas limit of the\n            // metacall tx.\n            ctx.solverIndex = uint8(_bidsAndIndicesLastIndex - i);\n\n            // Isolate the original solverOps index from the packed uint256 value\n            uint256 _solverIndex = uint8(_bidsAndIndices[i] & _FIRST_16_BITS_TRUE_MASK);\n\n            // Execute the solver operation. If solver won, allocate value and return. Otherwise continue looping.\n            _bidAmountFound = _executeSolverOperation(\n                ctx, dConfig, userOp, solverOps[_solverIndex], _bidAmountFound, _gasWaterMark, true, returnData\n            );\n\n            if (ctx.solverSuccessful) {\n                return _bidAmountFound;\n            }\n\n            if (i == 0) break; // break to prevent underflow in next loop\n        }\n        if (ctx.isSimulation) revert SolverSimFail(uint256(ctx.solverOutcome));\n        if (dConfig.callConfig.needsFulfillment()) revert UserNotFulfilled();\n        return 0;\n    }\n\n    /// @notice Called above in `execute` as an alternative to `_bidFindingIteration`, if solverOps have already been\n    /// reliably sorted. Executes solverOps in order until a successful winner is found.\n    /// @param ctx Context struct containing the current state of the escrow lock.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param returnData Return data from the preOps and userOp calls.\n    /// @return The winning bid amount or 0 when no solverOps.\n    function _bidKnownIteration(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 _bidAmount;\n\n        uint8 solverOpsLen = uint8(solverOps.length);\n        for (; ctx.solverIndex < solverOpsLen; ctx.solverIndex++) {\n            // track gas watermark to charge/writeoff gas for each solverOp\n            uint256 _gasWaterMark = gasleft();\n\n            SolverOperation calldata solverOp = solverOps[ctx.solverIndex];\n\n            // if multipleSuccessfulSolvers = true, solver bids are summed here. Otherwise, 0 bids are returned on\n            // solverOp failure, and only the first successful solver's bid is added to `_bidAmount`.\n            _bidAmount += _executeSolverOperation(\n                ctx, dConfig, userOp, solverOp, solverOp.bidAmount, _gasWaterMark, false, returnData\n            );\n\n            // If a winning solver is found, stop iterating through the solverOps and return the winning bid\n            if (ctx.solverSuccessful) {\n                return _bidAmount;\n            }\n        }\n\n        // If no winning solver, but multipleSuccessfulSolvers is true, return the sum of solver bid amounts\n        if (dConfig.callConfig.multipleSuccessfulSolvers()) {\n            // Considered a fail for simulation purposes when only one solverOp in the metacall, and it fails. If more\n            // than 1 solverOp, any of them could fail and simulation could still be successful.\n            if (ctx.isSimulation && solverOpsLen == 1 && ctx.solverOutcome != 0) {\n                revert SolverSimFail(uint256(ctx.solverOutcome));\n            }\n\n            return _bidAmount;\n        }\n\n        if (ctx.isSimulation) revert SolverSimFail(uint256(ctx.solverOutcome));\n        if (dConfig.callConfig.needsFulfillment()) revert UserNotFulfilled();\n        return 0;\n    }\n\n    /// @notice Called at the end of `metacall` to bubble up specific error info in a revert.\n    /// @param revertData Revert data from a failure during the execution of the metacall.\n    /// @param callConfig The CallConfig of the current metacall tx.\n    function _handleErrors(bytes memory revertData, uint32 callConfig) internal view {\n        bytes4 _errorSwitch = bytes4(revertData);\n\n        if (msg.sender == SIMULATOR) {\n            if (_errorSwitch == SolverSimFail.selector) {\n                // Expects revertData in form [bytes4, uint256]\n                uint256 _solverOutcomeResult;\n                assembly {\n                    let dataLocation := add(revertData, 0x20)\n                    _solverOutcomeResult := mload(add(dataLocation, sub(mload(revertData), 32)))\n                }\n                revert SolverSimFail(_solverOutcomeResult);\n            } else if (\n                _errorSwitch == PreOpsSimFail.selector || _errorSwitch == UserOpSimFail.selector\n                    || _errorSwitch == AllocateValueSimFail.selector\n            ) {\n                assembly {\n                    mstore(0, _errorSwitch)\n                    revert(0, 4)\n                }\n            }\n        }\n\n        // NOTE: If error was UserNotFulfilled, we revert and bubble up the error.\n        // For any other error, we only bubble up the revert if allowReuseUserOps = true. This is to prevent storing the\n        // nonce as used so the userOp can be reused. Otherwise, the whole metacall doesn't revert but the inner\n        // execute() does so, no operation changes are persisted.\n        if (_errorSwitch == UserNotFulfilled.selector || callConfig.allowsReuseUserOps()) {\n            assembly {\n                mstore(0, _errorSwitch)\n                revert(0, 4)\n            }\n        }\n    }\n\n    /// @notice Returns whether or not the execution environment address matches what's expected from the set of inputs.\n    /// @param environment ExecutionEnvironment address\n    /// @param user User address\n    /// @param control DAppControl contract address\n    /// @param callConfig CallConfig of the current metacall tx.\n    /// @return A bool indicating whether the execution environment address is the same address that the factory would\n    /// deploy an Execution Environment to, given the user, control, and callConfig params.\n    function _verifyUserControlExecutionEnv(\n        address environment,\n        address user,\n        address control,\n        uint32 callConfig\n    )\n        internal\n        override\n        returns (bool)\n    {\n        return environment == _getExecutionEnvironmentCustom(user, control, callConfig);\n    }\n}\n"
    }
}