{
    "vfp_id": "vfp_00193",
    "project_name": "cantina_fastlane_april2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-649"
                ]
            },
            "title": "Solvers may receive less gas than they expect",
            "description": "1. **Description:** In Atlas v1.6, the gas limit forwarded to solvers is set to the minimum of solverOp.gas and dConfig.solverGasLimit. This change introduces a risk where solvers may receive less gas than expected if dConfig.solverGasLimit is lowered after the solver signs the operation.\n2. **Cause:** The userOp hash does not include dConfig.solverGasLimit, so changes to this value after signing are not reflected in the solver's expectations.\n3. **Exploitation:** A malicious DAppControl could intentionally lower dConfig.solverGasLimit after a solver has signed, causing the solver to receive less gas than required for execution.\n4. **Impact:** Solvers may fail to execute their operations due to insufficient gas, leading to financial loss or operational disruption.\n",
            "severity": "Medium",
            "location": [
                "Escrow.sol#L367-L368"
            ],
            "files": [
                "atlas/src/contracts/atlas/Escrow.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Net repayments can be counted across multiple solverOps",
            "description": "1. **Description:** The _isBalanceReconciled() function in GasAccounting.sol incorrectly considers a solverOp's balance as reconciled when multipleSuccessfulSolvers == true, because it does not track how much of the net repayment has already been used by previous solverOps.\n2. **Cause:** The logic allows the same net repayment to be reused across multiple solverOps, as it does not deduct used repayments from a shared pool.\n3. **Exploitation:** An attacker could construct multiple solverOps that each claim the same net repayment, falsely satisfying the reconciliation check.\n4. **Impact:** This can result in a gas reimbursement shortfall during the final settle() call, forcing the bundler to cover the difference, potentially leading to financial loss.\n",
            "severity": "Medium",
            "location": [
                "GasAccounting.sol#L605"
            ],
            "files": [
                "atlas/src/contracts/atlas/GasAccounting.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Unsafe typecasts",
            "description": "1. **Description:** Several variables are downcasted from uint256 to uint40 without overflow checks, which could result in silent truncation if the value exceeds the range of uint40.\n2. **Cause:** Direct typecasting without using SafeCast or similar safeguards.\n3. **Exploitation:** If a value exceeds 2^40 - 1, it will wrap around, potentially leading to incorrect state or miscalculations.\n4. **Impact:** Could result in incorrect gas accounting, reward calculations, or other state inconsistencies, depending on the context of the cast.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "atlas/src/contracts/atlas/GasAccounting.sol",
                "atlas/src/contracts/atlas/Escrow.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Analytics consider all solvers as failed when multipleSuccessfulSolvers == true",
            "description": "1. **Description:** When multipleSuccessfulSolvers is true, the system treats all solverOps as failed in analytics by calling _handleSolverFailAccounting() regardless of success, leading to inaccurate monitoring and reporting.\n2. **Cause:** The accounting logic does not differentiate between success and failure in this mode.\n3. **Exploitation:** Not a security exploit, but results in loss of visibility into actual solver performance.\n4. **Impact:** Inaccurate analytics and operational insights, potentially affecting decision-making and system monitoring.\n",
            "severity": "Informational",
            "location": [
                "GasAccounting.sol#L328"
            ],
            "files": [
                "atlas/src/contracts/atlas/GasAccounting.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing Natspec",
            "description": "1. **Description:** The _settle() function has a new argument multipleSuccessfulSolvers that lacks Natspec documentation.\n2. **Cause:** Omission during code updates.\n3. **Exploitation:** Could lead to misuse or misunderstanding of the function's parameters by external developers or auditors.\n4. **Impact:** Reduced code clarity and maintainability, increasing the risk of integration errors.\n",
            "severity": "Informational",
            "location": [
                "GasAccounting.sol#L439-L449"
            ],
            "files": [
                "atlas/src/contracts/atlas/GasAccounting.sol"
            ]
        }
    ],
    "affected_files": {
        "GasAccounting.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\nimport { SafeCast } from \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport { SafetyLocks } from \"./SafetyLocks.sol\";\nimport { EscrowBits } from \"../libraries/EscrowBits.sol\";\nimport { AccountingMath } from \"../libraries/AccountingMath.sol\";\nimport { GasAccLib, GasLedger, BorrowsLedger } from \"../libraries/GasAccLib.sol\";\nimport { SolverOperation } from \"../types/SolverOperation.sol\";\nimport { DAppConfig } from \"../types/ConfigTypes.sol\";\nimport { IL2GasCalculator } from \"../interfaces/IL2GasCalculator.sol\";\nimport \"../types/EscrowTypes.sol\";\nimport \"../types/LockTypes.sol\";\n\n/// @title GasAccounting\n/// @author FastLane Labs\n/// @notice GasAccounting manages the accounting of gas surcharges and escrow balances for the Atlas protocol.\nabstract contract GasAccounting is SafetyLocks {\n    using EscrowBits for uint256;\n    using AccountingMath for uint256;\n    using SafeCast for uint256;\n    using GasAccLib for uint256;\n    using GasAccLib for GasLedger;\n    using GasAccLib for BorrowsLedger;\n    using FixedPointMathLib for uint256;\n\n    constructor(\n        uint256 escrowDuration,\n        uint256 atlasSurchargeRate,\n        address verification,\n        address simulator,\n        address initialSurchargeRecipient,\n        address l2GasCalculator\n    )\n        SafetyLocks(escrowDuration, atlasSurchargeRate, verification, simulator, initialSurchargeRecipient, l2GasCalculator)\n    { }\n\n    /// @notice Sets the initial gas accounting values for the metacall transaction in transient storage.\n    /// @dev Resets `t_gasLedger`, `t_borrowsLedger`, `t_solverLock`, and `t_solverTo` at the start of each metacall.\n    ///      Initializes `remainingMaxGas` with the overall gas estimate and `unreachedSolverGas` with the precalculated\n    ///      gas for all potential solver operations. Sets initial `repays` based on `msg.value`.\n    /// @param gasMarker The gas measurement at the start of the metacall, which includes Execution gas limits, Calldata\n    /// gas costs, and an additional buffer for safety.\n    /// @param allSolverOpsGas The sum of (C + E) gas limits for all solverOps in the metacall.\n    function _initializeAccountingValues(\n        uint256 gasMarker,\n        uint256 allSolverOpsGas,\n        uint24 bundlerSurchargeRate\n    )\n        internal\n    {\n        t_gasLedger = GasLedger({\n            remainingMaxGas: uint40(gasMarker),\n            writeoffsGas: 0,\n            solverFaultFailureGas: 0,\n            unreachedSolverGas: uint40(allSolverOpsGas),\n            maxApprovedGasSpend: 0,\n            atlasSurchargeRate: _atlasSurchargeRate(),\n            bundlerSurchargeRate: bundlerSurchargeRate\n        }).pack();\n\n        // If any native token sent in the metacall, add to the repays account\n        t_borrowsLedger = BorrowsLedger({ borrows: 0, repays: uint128(msg.value) }).pack();\n\n        t_solverLock = 0;\n        t_solverTo = address(0);\n\n        // The Lock slot is cleared at the end of the metacall, so no need to zero again here.\n    }\n\n    /// @notice Contributes ETH to the contract, increasing the deposits if a non-zero value is sent.\n    function contribute() external payable {\n        address _activeEnv = _activeEnvironment();\n        if (_activeEnv != msg.sender) revert InvalidExecutionEnvironment(_activeEnv);\n        _contribute();\n    }\n\n    /// @notice Borrows ETH from the contract, transferring the specified amount to the caller if available.\n    /// @dev Borrowing is only available until the end of the SolverOperation phase, for solver protection.\n    /// @param amount The amount of ETH to borrow.\n    function borrow(uint256 amount) external {\n        if (amount == 0) return;\n\n        // borrow() can only be called by the Execution Environment (by delegatecalling a DAppControl hook), and only\n        // during or before the SolverOperation phase.\n        (address _activeEnv,, uint8 _currentPhase) = _lock();\n        if (_activeEnv != msg.sender) revert InvalidExecutionEnvironment(_activeEnv);\n        if (_currentPhase > uint8(ExecutionPhase.SolverOperation)) revert WrongPhase();\n\n        // borrow() will revert if called after solver calls reconcile()\n        (, bool _calledBack,) = _solverLockData();\n        if (_calledBack) revert WrongPhase();\n\n        if (_borrow(amount)) {\n            SafeTransferLib.safeTransferETH(msg.sender, amount);\n        } else {\n            revert InsufficientAtlETHBalance(address(this).balance, amount);\n        }\n    }\n\n    /// @notice Calculates the current shortfall currently owed by the winning solver.\n    /// @dev The shortfall is calculated `(claims + withdrawals + fees - writeoffs) - deposits`. If this value is less\n    /// than zero, shortfall returns 0 as there is no shortfall because the solver is in surplus.\n    /// @return gasLiability The total gas charge (base + surcharges) owed by the solver. Can be repaid using bonded\n    /// balance or native token.\n    /// @return borrowLiability The total value of ETH borrowed but not yet repaid, only repayable using native token.\n    function shortfall() external view returns (uint256 gasLiability, uint256 borrowLiability) {\n        gasLiability = t_gasLedger.toGasLedger().solverGasLiability();\n\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        borrowLiability = (_bL.borrows < _bL.repays) ? 0 : _bL.borrows - _bL.repays;\n    }\n\n    /// @notice Allows a solver to settle any outstanding ETH owed, either to repay gas used by their solverOp or to\n    /// repay any ETH borrowed from Atlas. This debt can be paid either by sending ETH when calling this function\n    /// (msg.value) or by approving Atlas to use a certain amount of the solver's bonded AtlETH.\n    /// @param maxApprovedGasSpend The maximum amount of the solver's bonded AtlETH that Atlas can deduct to cover the\n    /// solver's debt.\n    /// @return owed The gas and borrow liability owed by the solver. The full gasLiability + borrowLiability amount is\n    /// returned, unless the fulfilled, in which case 0 is returned.\n    /// @dev The solver can call this function multiple times until the owed amount is zero.\n    /// @dev Note: `reconcile()` must be called by the solver to avoid a `CallbackNotCalled` error in `solverCall()`.\n    function reconcile(uint256 maxApprovedGasSpend) external payable returns (uint256 owed) {\n        // NOTE: maxApprovedGasSpend is the amount of the solver's atlETH that the solver is allowing\n        // to be used to cover what they owe. Assuming they're successful, a value up to this amount\n        // will be subtracted from the solver's bonded AtlETH during _settle().\n\n        // NOTE: After reconcile is called for the first time by the solver, neither the claims nor the borrows values\n        // can be increased.\n\n        // NOTE: While anyone can call this function, it can only be called in the SolverOperation phase. Because Atlas\n        // calls directly to the solver contract in this phase, the solver should be careful to not call malicious\n        // contracts which may call reconcile() on their behalf, with an excessive maxApprovedGasSpend.\n        if (_phase() != uint8(ExecutionPhase.SolverOperation)) revert WrongPhase();\n        if (msg.sender != t_solverTo) revert InvalidAccess();\n\n        (address _currentSolver, bool _calledBack,) = _solverLockData();\n        uint256 _bondedBalance = uint256(S_accessData[_currentSolver].bonded);\n\n        // Solver can only approve up to their bonded balance, not more\n        if (maxApprovedGasSpend > _bondedBalance) maxApprovedGasSpend = _bondedBalance;\n\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n\n        uint256 _borrows = _bL.borrows; // total native borrows\n        uint256 _repays = _bL.repays; // total native repayments of borrows\n        uint256 _maxGasLiability = _gL.solverGasLiability(); // max gas liability of winning solver\n\n        // Store update to repays in t_borrowLedger, if any msg.value sent\n        if (msg.value > 0) {\n            _repays += msg.value;\n            _bL.repays = _repays.toUint128();\n            t_borrowsLedger = _bL.pack();\n        }\n\n        // Store solver's maxApprovedGasSpend for use in the _isBalanceReconciled() check\n        if (maxApprovedGasSpend > 0) {\n            // Convert maxApprovedGasSpend from wei (native token) units to gas units\n            _gL.maxApprovedGasSpend = uint40(maxApprovedGasSpend / tx.gasprice);\n            t_gasLedger = _gL.pack();\n        }\n\n        // Check if fullfilled:\n        // - native borrows must be repaid (using only native token)\n        // - gas liabilities must be repaid (using bonded AtlETH or native token)\n\n        if (_borrows > _repays) {\n            if (!_calledBack) t_solverLock = (uint256(uint160(_currentSolver)) | _SOLVER_CALLED_BACK_MASK);\n            return _maxGasLiability + (_borrows - _repays);\n        } else {\n            uint256 _excess = _repays - _borrows;\n            if (maxApprovedGasSpend + _excess < _maxGasLiability) {\n                if (!_calledBack) t_solverLock = (uint256(uint160(_currentSolver)) | _SOLVER_CALLED_BACK_MASK);\n                return _maxGasLiability - _excess;\n            }\n        }\n\n        // If we get here, native borrows have been repaid, and enough approved to cover gas liabilities\n        t_solverLock = (uint256(uint160(_currentSolver)) | _SOLVER_CALLED_BACK_MASK | _SOLVER_FULFILLED_MASK);\n        return 0;\n    }\n\n    /// @notice Internal function to handle ETH contribution, increasing deposits if a non-zero value is sent.\n    function _contribute() internal {\n        if (msg.value == 0) return;\n\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        _bL.repays += msg.value.toUint128();\n        t_borrowsLedger = _bL.pack();\n    }\n\n    /// @notice Borrows ETH from the contract, transferring the specified amount to the caller if available.\n    /// @dev Borrowing should never be allowed after the SolverOperation phase, for solver safety. This is enforced in\n    /// the external `borrow` function, and the only other time this internal `_borrow` function is called is in\n    /// `_solverOpInner` which happens at the beginning of the SolverOperation phase.\n    /// @param amount The amount of ETH to borrow.\n    /// @return valid A boolean indicating whether the borrowing operation was successful.\n    function _borrow(uint256 amount) internal returns (bool valid) {\n        if (amount == 0) return true;\n        if (address(this).balance < amount) return false;\n\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        _bL.borrows += amount.toUint128();\n        t_borrowsLedger = _bL.pack();\n\n        return true;\n    }\n\n    /// @notice Takes AtlETH from the owner's bonded balance and, if necessary, from the owner's unbonding balance.\n    /// @dev No GasLedger accounting changes are made in this function - should be done separately.\n    /// @param accountData The EscrowAccountAccessData memory struct of the account being charged.\n    /// @param account The address of the account from which AtlETH is taken.\n    /// @param amount The amount of AtlETH to be taken.\n    /// @return deficit The amount of AtlETH that was not repaid, if any.\n    function _assign(\n        EscrowAccountAccessData memory accountData,\n        address account,\n        uint256 amount\n    )\n        internal\n        returns (uint256 deficit)\n    {\n        uint112 _amt = amount.toUint112();\n\n        if (_amt > accountData.bonded) {\n            // The bonded balance does not cover the amount owed. Check if there is enough unbonding balance to\n            // make up for the missing difference. If not, there is a deficit. Atlas does not consider drawing from\n            // the regular AtlETH balance (not bonded nor unbonding) to cover the remaining deficit because it is\n            // not meant to be used within an Atlas transaction, and must remain independent.\n\n            EscrowAccountBalance memory _bData = s_balanceOf[account];\n            uint256 _total = uint256(_bData.unbonding) + uint256(accountData.bonded);\n\n            if (_amt > _total) {\n                // The unbonding balance is insufficient to cover the remaining amount owed. There is a deficit. Set\n                // both bonded and unbonding balances to 0 and adjust the \"amount\" variable to reflect the amount\n                // that was actually deducted.\n                deficit = amount - _total;\n\n                s_balanceOf[account].unbonding = 0;\n                accountData.bonded = 0;\n                amount -= deficit; // Set amount equal to total to accurately track the changing bondedTotalSupply\n            } else {\n                // The unbonding balance is sufficient to cover the remaining amount owed. Draw everything from the\n                // bonded balance, and adjust the unbonding balance accordingly.\n                s_balanceOf[account].unbonding = _total.toUint112() - _amt;\n                accountData.bonded = 0;\n            }\n        } else {\n            // The bonded balance is sufficient to cover the amount owed.\n            accountData.bonded -= _amt;\n        }\n\n        S_bondedTotalSupply -= amount;\n\n        // update lastAccessedBlock since bonded balance is decreasing\n        accountData.lastAccessedBlock = uint32(block.number);\n        // NOTE: accountData changes must be persisted to storage separately\n    }\n\n    /// @notice Increases the owner's bonded balance by the specified amount.\n    /// @param accountData The EscrowAccountAccessData memory struct of the account being credited.\n    /// @param amount The amount by which to increase the owner's bonded balance.\n    function _credit(EscrowAccountAccessData memory accountData, uint256 amount) internal {\n        accountData.bonded += SafeCast.toUint112(amount);\n        S_bondedTotalSupply += amount;\n        // NOTE: accountData changes must be persisted to storage separately\n    }\n\n    /// @notice Accounts for the gas cost of a failed SolverOperation, either by increasing writeoffs (if the bundler is\n    /// blamed for the failure) or by assigning the gas cost to the solver's bonded AtlETH balance (if the solver is\n    /// blamed for the failure).\n    /// @param solverOp The current SolverOperation for which to account.\n    /// @param dConfigSolverGasLimit The gas limit for the solver operation, as specified in the DAppConfig.\n    /// @param gasWaterMark The `gasleft()` watermark taken at the start of executing the SolverOperation.\n    /// @param result The result bitmap of the SolverOperation execution.\n    /// @param exPostBids A boolean indicating whether exPostBids is set to true in the current metacall.\n    function _handleSolverFailAccounting(\n        SolverOperation calldata solverOp,\n        uint256 dConfigSolverGasLimit,\n        uint256 gasWaterMark,\n        uint256 result,\n        bool exPostBids\n    )\n        internal\n    {\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n\n        // Solvers do not pay for calldata gas in exPostBids mode.\n        uint256 _calldataGas;\n        if (!exPostBids) {\n            _calldataGas = GasAccLib.solverOpCalldataGas(solverOp.data.length, L2_GAS_CALCULATOR);\n        }\n\n        // Solver execution max gas is calculated as solverOp.gas, with a max of dConfig.solverGasLimit\n        uint256 _executionMaxGas = (solverOp.gas > dConfigSolverGasLimit) ? dConfigSolverGasLimit : solverOp.gas;\n\n        // Deduct solver's max (C + E) gas from remainingMaxGas, for future solver gas liability calculations\n        _gL.remainingMaxGas -= uint40(_executionMaxGas + _calldataGas);\n\n        uint256 _gasUsed = _calldataGas + (gasWaterMark - gasleft());\n\n        // Calculate what the solver owes\n        // NOTE: This will cause an error if you are simulating with a gasPrice of 0\n        if (result.bundlersFault()) {\n            // CASE: Solver is not responsible for the failure of their operation, so we blame the bundler\n            // and reduce the total amount refunded to the bundler\n            _gasUsed += _BUNDLER_FAULT_OFFSET;\n            _gL.writeoffsGas += uint40(_gasUsed);\n        } else {\n            // CASE: Solver failed, so we calculate what they owe.\n            _gasUsed += _SOLVER_FAULT_OFFSET;\n            uint256 _gasValueWithSurcharges = _gasUsed.withSurcharge(_gL.totalSurchargeRate()) * tx.gasprice;\n\n            EscrowAccountAccessData memory _solverAccountData = S_accessData[solverOp.from];\n\n            // In `_assign()`, the solver's bonded AtlETH balance is reduced by `_gasValueWithSurcharges`. Any deficit\n            // from that operation is returned as `_assignDeficit` below. GasLedger is not modified in _assign().\n            uint256 _assignDeficit = _assign(_solverAccountData, solverOp.from, _gasValueWithSurcharges);\n\n            // Solver's analytics updated:\n            // - increment auctionFails\n            // - increase totalGasValueUsed by gas cost + surcharges paid by solver, less any deficit\n            _updateAnalytics(_solverAccountData, false, _gasValueWithSurcharges - _assignDeficit);\n\n            // Persist the updated solver account data to storage\n            S_accessData[solverOp.from] = _solverAccountData;\n\n            if (_assignDeficit > 0) {\n                // If any deficit, calculate the gas units unpaid for due to assign deficit.\n                // Gas units written off = gas used * (deficit / gas value with surcharges) ratio.\n                // `mulDivUp()` rounds in favor of writeoffs, so we don't overestimate gas that was actually paid for\n                // and end up reimbursing the bundler for more than was actually taken from the solvers.\n                uint256 _gasWrittenOff = _gasUsed.mulDivUp(_assignDeficit, _gasValueWithSurcharges);\n\n                // No risk of underflow in subtraction below, because:\n                // _assignDeficit is <= _gasValueWithSurcharges, so _gasWrittenOff is <= _gasUsed.\n\n                // Deduct gas written off from gas tracked as \"paid for\" by failed solver\n                _gasUsed -= _gasWrittenOff;\n                _gL.writeoffsGas += uint40(_gasWrittenOff); // add to writeoffs in gasLedger\n            }\n\n            // The gas paid for here by failed solver, and gas written off due to shortfall in `_assign()`, will offset\n            // what the winning solver owes in `_settle()`.\n            _gL.solverFaultFailureGas += uint40(_gasUsed);\n        }\n\n        // Persist the updated gas ledger to transient storage\n        t_gasLedger = _gL.pack();\n    }\n\n    /// @notice Records the gas used during the `bidFind` phase of exPostBids as a write-off.\n    /// @dev Gas used for `bidFind` is considered an overhead paid by the bundler (via reduced refund)\n    ///      and is not charged to any specific solver. It's added to `writeoffsGas` in the GasLedger.\n    /// @param gasUsed The amount of gas consumed during the `bidFind` phase.\n    function _writeOffBidFindGas(uint256 gasUsed) internal {\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n        _gL.writeoffsGas += uint40(gasUsed);\n        t_gasLedger = _gL.pack();\n    }\n\n    /// @notice Charges solvers that were not reached during the metacall for the calldata gas cost of their solverOps.\n    /// @dev Iterates through `solverOps` starting from the index *after* `winningSolverIdx`. For each unreached\n    /// operation, `VERIFICATION.verifySolverOp` is called to determine fault.\n    ///      - If bundler fault: The calldata gas is added to `gL.writeoffsGas` (reducing bundler's refund).\n    ///      - If solver fault: Attempts to charge the solver's bonded `AtlETH` using `_assign` for the calldata\n    ///        gas cost (no surcharges added). Any deficit is added to `gL.writeoffsGas`.\n    ///      The gas cost of executing this loop is also added to `gL.writeoffsGas` to ensure the bundler pays for it.\n    /// @param solverOps The SolverOperation array containing the solvers' transaction data.\n    /// @param gL The GasLedger struct (memory); `gL.writeoffsGas` is updated within this function.\n    /// @param winningSolverIdx Index of the winning/last attempted solver; the loop starts after this index.\n    /// @param userOpHash Hash of the UserOperation, used for verification.\n    /// @param maxFeePerGas userOp.maxFeePerGas, used for verification.\n    /// @param bundler The metacall caller (msg.sender), used for verification.\n    /// @param allowsTrustedOpHash Flag indicating with trustedOpHash is enabled in the metacall.\n    /// @return unreachedCalldataValuePaid Total value successfully charged to unreached solvers (cost - deficits).\n    function _chargeUnreachedSolversForCalldata(\n        SolverOperation[] calldata solverOps,\n        GasLedger memory gL,\n        uint256 winningSolverIdx,\n        bytes32 userOpHash,\n        uint256 maxFeePerGas,\n        address bundler,\n        bool allowsTrustedOpHash\n    )\n        internal\n        returns (uint256 unreachedCalldataValuePaid)\n    {\n        uint256 _writeoffGasMarker = gasleft();\n\n        // Start at the solver after the current solverIdx, because current solverIdx is the winner\n        for (uint256 i = winningSolverIdx + 1; i < solverOps.length; ++i) {\n            address _from = solverOps[i].from;\n            uint256 _calldataGasCost =\n                GasAccLib.solverOpCalldataGas(solverOps[i].data.length, L2_GAS_CALCULATOR) * tx.gasprice;\n\n            // Verify the solverOp, and write off solver's calldata gas if included due to bundler fault\n            uint256 _result =\n                VERIFICATION.verifySolverOp(solverOps[i], userOpHash, maxFeePerGas, bundler, allowsTrustedOpHash);\n\n            if (_result.bundlersFault()) {\n                gL.writeoffsGas += _calldataGasCost.divUp(tx.gasprice).toUint40();\n                continue;\n            }\n\n            // If solverOp inclusion was not bundler fault, charge solver for calldata gas\n            EscrowAccountAccessData memory _solverData = S_accessData[_from];\n\n            // No surcharges added to calldata cost for unreached solvers\n            uint256 _deficit = _assign(_solverData, _from, _calldataGasCost);\n\n            // Persist _assign() changes to solver account data to storage\n            S_accessData[_from] = _solverData;\n\n            // The sum of value paid less deficits is tracked and used in `_settle()`\n            unreachedCalldataValuePaid += _calldataGasCost - _deficit;\n\n            // Any deficits from the `_assign()` operations are converted to gas units and written off so as not to\n            // charge the winning solver for calldata that is not their responsibility, in `_settle()`.\n            if (_deficit > 0) gL.writeoffsGas += _deficit.divUp(tx.gasprice).toUint40();\n        }\n\n        // The gas cost of this loop is always paid by the bundler so as not to charge the winning solver for an\n        // excessive number of loops and SSTOREs via `_assign()`. This gas is therefore added to writeoffs.\n        gL.writeoffsGas += (_writeoffGasMarker - gasleft()).toUint40();\n    }\n\n    /// @notice Finalizes gas accounting at the end of the metacall, settles balances, and pays refunds/surcharges.\n    /// @param ctx The context struct (memory), used for ctx.bundler and ctx.solverSuccessful.\n    /// @param gL The final state of the GasLedger struct (memory), used for gas calculations.\n    /// @param gasMarker The initial gas measurement taken at the start of the metacall.\n    /// @param gasRefundBeneficiary The address designated to receive the bundler's gas refund. Defaults to\n    /// `ctx.bundler`.\n    /// @param unreachedCalldataValuePaid The total value successfully collected from unreached solvers for their\n    /// calldata costs (from `_chargeUnreachedSolversForCalldata`).\n    /// @return claimsPaidToBundler The net amount of ETH transferred to the `gasRefundBeneficiary`.\n    /// @return netAtlasGasSurcharge The net amount of ETH taken as Atlas surcharge during the metacall.\n    function _settle(\n        Context memory ctx,\n        GasLedger memory gL,\n        uint256 gasMarker,\n        address gasRefundBeneficiary,\n        uint256 unreachedCalldataValuePaid,\n        bool multipleSuccessfulSolvers\n    )\n        internal\n        returns (uint256 claimsPaidToBundler, uint256 netAtlasGasSurcharge)\n    {\n        EscrowAccountAccessData memory _winningSolverData;\n        BorrowsLedger memory _bL = t_borrowsLedger.toBorrowsLedger();\n        (address _winningSolver,,) = _solverLockData();\n\n        // No need to SLOAD bonded balance etc. if no winning solver\n        if (ctx.solverSuccessful) _winningSolverData = S_accessData[_winningSolver];\n\n        // Send gas refunds to bundler if no gas refund beneficiary specified\n        if (gasRefundBeneficiary == address(0)) gasRefundBeneficiary = ctx.bundler;\n\n        // First check if all borrows have been repaid.\n        // Borrows can only be repaid in native token, not bonded AtlETH.\n        // This is also done at end of solverCall(), so check here only needed for zero solvers case.\n        int256 _netRepayments = _bL.netRepayments();\n        if (_netRepayments < 0) revert BorrowsNotRepaid(_bL.borrows, _bL.repays);\n\n        uint256 _winnerGasCharge;\n        uint256 _gasLeft = gasleft();\n\n        // NOTE: Trivial for bundler to run a different EOA for solver so no bundler == solver carveout.\n        if (ctx.solverSuccessful) {\n            // CASE: Winning solver.\n\n            // Winning solver should pay for:\n            // - Gas (C + E) used by their solverOp\n            // - Gas (C + E) used by userOp, dapp hooks, and other metacall overhead\n            // Winning solver should not pay for:\n            // - Gas (C + E) used by other reached solvers (bundler or solver fault failures)\n            // - Gas (C only) used by unreached solvers\n            // - Gas (E only) used during the bid-finding or unreached solver calldata charge loops\n            _winnerGasCharge = gasMarker - gL.writeoffsGas - gL.solverFaultFailureGas\n                - (unreachedCalldataValuePaid / tx.gasprice) - _gasLeft;\n            uint256 _surchargedGasPaidBySolvers = gL.solverFaultFailureGas + _winnerGasCharge;\n\n            // Bundler gets base gas cost + bundler surcharge of (solver fault fails + winning solver charge)\n            // Bundler also gets reimbursed for the calldata of unreached solvers (only base, no surcharge)\n            claimsPaidToBundler = (_surchargedGasPaidBySolvers.withSurcharge(gL.bundlerSurchargeRate) * tx.gasprice)\n                + unreachedCalldataValuePaid;\n\n            // Atlas gets only the Atlas surcharge of (solver fault fails + winning solver charge)\n            netAtlasGasSurcharge = _surchargedGasPaidBySolvers.getSurcharge(gL.atlasSurchargeRate) * tx.gasprice;\n\n            // Calculate what winning solver pays: add surcharges and multiply by gas price\n            _winnerGasCharge = _winnerGasCharge.withSurcharge(gL.totalSurchargeRate()) * tx.gasprice;\n\n            uint256 _deficit; // Any shortfall that the winning solver is not able to repay from bonded balance\n            if (_winnerGasCharge < uint256(_netRepayments)) {\n                // CASE: solver recieves more than they pay --> net credit to account\n                _credit(_winningSolverData, uint256(_netRepayments) - _winnerGasCharge);\n            } else {\n                // CASE: solver pays more than they recieve --> net assign to account\n                _deficit = _assign(_winningSolverData, _winningSolver, _winnerGasCharge - uint256(_netRepayments));\n            }\n\n            if (_deficit > claimsPaidToBundler) revert AssignDeficitTooLarge(_deficit, claimsPaidToBundler);\n            claimsPaidToBundler -= _deficit;\n\n            _updateAnalytics(_winningSolverData, true, _winnerGasCharge);\n\n            // Persist the updated winning solver account data to storage\n            S_accessData[_winningSolver] = _winningSolverData;\n        } else {\n            // CASE: No winning solver.\n\n            // Bundler may still recover a partial refund (from solver fault failure charges) up to 80% of the gas cost\n            // of the metacall. The remaining 20% could be recovered through storage refunds, and it is important that\n            // metacalls with no winning solver are not profitable for the bundler.\n            // The exception to this rule is when multipleSuccessfulSolvers is set to true. In this case, all solvers\n            // should be able to execute and pay for their own gas + surcharges, but the bundler refund should not be\n            // capped.\n\n            uint256 _maxRefund;\n            if (multipleSuccessfulSolvers) {\n                _maxRefund = type(uint256).max;\n            } else {\n                _maxRefund = (gasMarker - gL.writeoffsGas - _gasLeft).maxBundlerRefund() * tx.gasprice;\n            }\n\n            // Bundler gets (base gas cost + bundler surcharge) of solver fault failures, plus base gas cost of\n            // unreached solver calldata. This is compared to _maxRefund below. Net repayments is added after the 80%\n            // cap has been applied to the gas refund components.\n            // `unreachedCalldataValuePaid` is not added here as it should always be 0 when solverSuccessful = false,\n            // because there should then be no unreached solvers.\n            uint256 _bundlerCutBeforeLimit =\n                uint256(gL.solverFaultFailureGas).withSurcharge(gL.bundlerSurchargeRate) * tx.gasprice;\n\n            // Atlas only keeps the Atlas surcharge of solver fault failures, and any gas due to bundler that exceeds\n            // the 80% limit.\n            netAtlasGasSurcharge = uint256(gL.solverFaultFailureGas).getSurcharge(gL.atlasSurchargeRate) * tx.gasprice;\n\n            if (_bundlerCutBeforeLimit > _maxRefund) {\n                // More than max gas refund was taken by failed/unreached solvers, excess goes to Atlas\n                claimsPaidToBundler = _maxRefund;\n                netAtlasGasSurcharge += _bundlerCutBeforeLimit - _maxRefund;\n            } else {\n                // Otherwise, the bundler can receive the full solver fault failure gas\n                claimsPaidToBundler = _bundlerCutBeforeLimit;\n            }\n\n            // Finally, add any net repayments, which should not be subject to the 80% cap, to the bundler's claims\n            claimsPaidToBundler += uint256(_netRepayments);\n        }\n\n        S_cumulativeSurcharge += netAtlasGasSurcharge;\n\n        // Set lock to FullyLocked to prevent any reentrancy possibility in refund transfer below\n        _setLockPhase(uint8(ExecutionPhase.FullyLocked));\n\n        if (claimsPaidToBundler != 0) SafeTransferLib.safeTransferETH(gasRefundBeneficiary, claimsPaidToBundler);\n    }\n\n    /// @notice Updates auctionWins, auctionFails, and totalGasUsed values of a solver's EscrowAccountAccessData.\n    /// @dev This function is only ever called in the context of bidFind = false so no risk of doublecounting changes.\n    /// @param aData The Solver's EscrowAccountAccessData struct to update.\n    /// @param auctionWon A boolean indicating whether the solver's solverOp won the auction.\n    /// @param gasValueUsed The ETH value of gas used by the solverOp. Should be calculated as gasUsed * tx.gasprice.\n    function _updateAnalytics(\n        EscrowAccountAccessData memory aData,\n        bool auctionWon,\n        uint256 gasValueUsed\n    )\n        internal\n        pure\n    {\n        if (auctionWon) {\n            unchecked {\n                ++aData.auctionWins;\n            }\n        } else {\n            unchecked {\n                ++aData.auctionFails;\n            }\n        }\n\n        // Track total ETH value of gas spent by solver in metacalls. Measured in gwei (1e9 digits truncated).\n        aData.totalGasValueUsed += SafeCast.toUint64(gasValueUsed / _GAS_VALUE_DECIMALS_TO_DROP);\n    }\n\n    /// @notice Checks all obligations have been reconciled: native borrows AND gas liabilities.\n    /// @return True if both dimensions are reconciled, false otherwise.\n    function _isBalanceReconciled() internal view returns (bool) {\n        GasLedger memory gL = t_gasLedger.toGasLedger();\n        BorrowsLedger memory bL = t_borrowsLedger.toBorrowsLedger();\n\n        // DApp's excess repayments via `contribute()` can offset solverGasLiability\n        uint256 _netRepayments;\n        if (bL.repays > bL.borrows) _netRepayments = bL.repays - bL.borrows;\n\n        // gL.maxApprovedGasSpend only stores the gas units, must be scaled by tx.gasprice\n        uint256 _maxApprovedGasValue = gL.maxApprovedGasSpend * tx.gasprice;\n\n        return (bL.repays >= bL.borrows) && (_maxApprovedGasValue + _netRepayments >= gL.solverGasLiability());\n    }\n}\n",
        "Escrow.sol": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport { SafeCast } from \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport { AtlETH } from \"./AtlETH.sol\";\nimport { IExecutionEnvironment } from \"../interfaces/IExecutionEnvironment.sol\";\nimport { IAtlas } from \"../interfaces/IAtlas.sol\";\nimport { ISolverContract } from \"../interfaces/ISolverContract.sol\";\nimport { IAtlasVerification } from \"../interfaces/IAtlasVerification.sol\";\nimport { IDAppControl } from \"../interfaces/IDAppControl.sol\";\n\nimport { SafeCall } from \"../libraries/SafeCall/SafeCall.sol\";\nimport { EscrowBits } from \"../libraries/EscrowBits.sol\";\nimport { CallBits } from \"../libraries/CallBits.sol\";\nimport { SafetyBits } from \"../libraries/SafetyBits.sol\";\nimport { AccountingMath } from \"../libraries/AccountingMath.sol\";\nimport { GasAccLib, GasLedger } from \"../libraries/GasAccLib.sol\";\nimport { DAppConfig } from \"../types/ConfigTypes.sol\";\nimport \"../types/SolverOperation.sol\";\nimport \"../types/UserOperation.sol\";\nimport \"../types/EscrowTypes.sol\";\nimport \"../types/LockTypes.sol\";\n\n/// @title Escrow\n/// @author FastLane Labs\n/// @notice This Escrow component of Atlas handles execution of stages by calling corresponding functions on the\n/// Execution Environment contract.\nabstract contract Escrow is AtlETH {\n    using EscrowBits for uint256;\n    using CallBits for uint32;\n    using SafetyBits for Context;\n    using SafeCall for address;\n    using SafeCast for uint256;\n    using AccountingMath for uint256;\n    using GasAccLib for uint256;\n    using GasAccLib for GasLedger;\n\n    constructor(\n        uint256 escrowDuration,\n        uint256 atlasSurchargeRate,\n        address verification,\n        address simulator,\n        address initialSurchargeRecipient,\n        address l2GasCalculator\n    )\n        AtlETH(escrowDuration, atlasSurchargeRate, verification, simulator, initialSurchargeRecipient, l2GasCalculator)\n    {\n        if (escrowDuration == 0) revert InvalidEscrowDuration();\n    }\n\n    /// @notice Executes the preOps logic defined in the Execution Environment.\n    /// @param ctx Metacall context data from the Context struct.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @return preOpsData The data returned by the preOps call, if successful.\n    function _executePreOpsCall(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp\n    )\n        internal\n        withLockPhase(ExecutionPhase.PreOps)\n        returns (bytes memory)\n    {\n        uint256 _dappGasWaterMark = gasleft();\n\n        (bool _success, bytes memory _data) = ctx.executionEnvironment.call{ gas: ctx.dappGasLeft }(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.preOpsWrapper, userOp), ctx.setAndPack(ExecutionPhase.PreOps)\n            )\n        );\n\n        _updateDAppGasLeft(ctx, _dappGasWaterMark);\n\n        if (_success) {\n            if (dConfig.callConfig.needsPreOpsReturnData()) {\n                return abi.decode(_data, (bytes));\n            } else {\n                return new bytes(0);\n            }\n        }\n\n        if (ctx.isSimulation) revert PreOpsSimFail();\n        revert PreOpsFail();\n    }\n\n    /// @notice Executes the user operation logic defined in the Execution Environment.\n    /// @param ctx Metacall context data from the Context struct.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct containing the user's transaction data.\n    /// @param returnData Data returned from previous call phases.\n    /// @return userData Data returned from executing the UserOperation, if the call was successful.\n    function _executeUserOperation(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        bytes memory returnData\n    )\n        internal\n        withLockPhase(ExecutionPhase.UserOperation)\n        returns (bytes memory)\n    {\n        bool _success;\n        bytes memory _data;\n\n        if (!_borrow(userOp.value)) {\n            revert InsufficientEscrow();\n        }\n\n        (_success, _data) = ctx.executionEnvironment.call{ value: userOp.value, gas: userOp.gas }(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.userWrapper, userOp), ctx.setAndPack(ExecutionPhase.UserOperation)\n            )\n        );\n\n        if (_success) {\n            // Handle formatting of returnData\n            if (dConfig.callConfig.needsUserReturnData()) {\n                return abi.decode(_data, (bytes));\n            } else {\n                return returnData;\n            }\n        }\n\n        // revert for failed\n        if (ctx.isSimulation) revert UserOpSimFail();\n        revert UserOpFail();\n    }\n\n    /// @notice Checks if the trusted operation hash matches and sets the appropriate error bit if it doesn't.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param prevalidated Boolean flag indicating whether the SolverOperation has been prevalidated to skip certain\n    /// checks.\n    /// @param userOp UserOperation struct containing the user's transaction data relevant to this SolverOperation.\n    /// @param solverOp SolverOperation struct containing the solver's bid and execution data.\n    /// @param result The current result bitmask that tracks the status of various checks and validations.\n    /// @return The updated result bitmask with the AltOpHashMismatch bit set if the operation hash does not match.\n    function _checkTrustedOpHash(\n        DAppConfig memory dConfig,\n        bool prevalidated,\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp,\n        uint256 result\n    )\n        internal\n        returns (uint256)\n    {\n        if (dConfig.callConfig.allowsTrustedOpHash() && !prevalidated && !_handleAltOpHash(userOp, solverOp)) {\n            result |= 1 << uint256(SolverOutcome.AltOpHashMismatch);\n        }\n        return result;\n    }\n\n    /// @notice Attempts to execute a SolverOperation and determine if it wins the auction.\n    /// @param ctx Context struct containing the current state of the escrow lock.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct containing the user's transaction data relevant to this SolverOperation.\n    /// @param solverOp SolverOperation struct containing the solver's bid and execution data.\n    /// @param bidAmount The amount of bid submitted by the solver for this operation.\n    /// @param gasWaterMark The gas left at the start of the current solverOp's execution, to be used to charge/write\n    /// off solverOp gas.\n    /// @param prevalidated Boolean flag indicating if the solverOp has been prevalidated in bidFind (exPostBids).\n    /// @param returnData Data returned from UserOp execution, used as input if necessary.\n    /// @return bidAmount The determined bid amount for the SolverOperation if all validations pass and the operation is\n    /// executed successfully; otherwise, returns 0.\n    function _executeSolverOperation(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp,\n        uint256 bidAmount,\n        uint256 gasWaterMark,\n        bool prevalidated,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256)\n    {\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n        uint256 _result;\n\n        // Decrease unreachedSolverGas and reset maxApprovedGasSpend at the start of each solverOp\n        _adjustGasLedgerAtSolverOpStart(_gL, dConfig, solverOp);\n        t_gasLedger = _gL.pack(); // Persist changes to transient storage\n\n        if (!prevalidated) {\n            _result = VERIFICATION.verifySolverOp(\n                solverOp, ctx.userOpHash, userOp.maxFeePerGas, ctx.bundler, dConfig.callConfig.allowsTrustedOpHash()\n            );\n            _result = _checkSolverBidToken(solverOp.bidToken, dConfig.bidToken, _result);\n        }\n\n        // Verify the transaction.\n        if (_result.canExecute()) {\n            uint256 _gasLimit;\n            // Verify gasLimit again\n            (_result, _gasLimit) = _validateSolverOpGasAndValue(_gL, dConfig, solverOp, gasWaterMark, _result);\n            _result |= _validateSolverOpDeadline(solverOp, dConfig);\n\n            // Check for trusted operation hash\n            _result = _checkTrustedOpHash(dConfig, prevalidated, userOp, solverOp, _result);\n\n            // If there are no errors, attempt to execute\n            if (_result.canExecute()) {\n                SolverTracker memory _solverTracker;\n\n                // Execute the solver call\n                (_result, _solverTracker) = _solverOpWrapper(ctx, solverOp, bidAmount, _gasLimit, returnData);\n\n                // First successful solver call that paid what it bid\n                if (_result.executionSuccessful()) {\n                    // Logic done above `_handleSolverFailAccounting()` is to charge solver for gas used here\n                    ctx.solverOutcome = uint24(_result);\n\n                    emit SolverTxResult(\n                        solverOp.solver,\n                        solverOp.from,\n                        dConfig.to,\n                        solverOp.bidToken,\n                        _solverTracker.bidAmount,\n                        true,\n                        true,\n                        _result\n                    );\n\n                    // Keep executing solvers without ending the auction if multipleSuccessfulSolvers is set\n                    if (dConfig.callConfig.multipleSuccessfulSolvers()) {\n                        // multipleSuccessfulSolvers mode:\n                        // - `ctx.solverSuccessful` is implicitly left as false\n                        // - `_result` should be 0 (successful) below, which should charge the solver for their own\n                        //   gas + surcharges, as 0 is not captured in the bundler fault block.\n                        // - exPostBids is not supported in multipleSuccessfulSolvers mode, so exPostBids = false here.\n                        _handleSolverFailAccounting(solverOp, dConfig.solverGasLimit, gasWaterMark, _result, false);\n                    } else {\n                        // If not in multipleSuccessfulSolvers mode, end the auction with the first successful solver\n                        // that paid what it bid.\n                        // We intentionally do not change GasLedger here as we have found a winning solver and don't\n                        // need it anymore\n                        ctx.solverSuccessful = true;\n                    }\n\n                    return _solverTracker.bidAmount;\n                }\n            }\n        }\n\n        // If we reach this point, the solver call did not execute successfully.\n        ctx.solverOutcome = uint24(_result);\n\n        emit SolverTxResult(\n            solverOp.solver,\n            solverOp.from,\n            dConfig.to,\n            solverOp.bidToken,\n            bidAmount,\n            _result.executedWithError(),\n            false,\n            _result\n        );\n\n        // Account for failed SolverOperation gas costs\n        _handleSolverFailAccounting(\n            solverOp, dConfig.solverGasLimit, gasWaterMark, _result, dConfig.callConfig.exPostBids()\n        );\n\n        return 0;\n    }\n\n    /// @notice Allocates the winning bid amount after a successful SolverOperation execution.\n    /// @dev This function handles the allocation of the bid amount to the appropriate recipients as defined in the\n    /// DApp's configuration. It calls the allocateValue function in the Execution Environment, which is responsible for\n    /// distributing the bid amount. Note that balance discrepancies leading to payment failures are typically due to\n    /// issues in the DAppControl contract, not the execution environment itself.\n    /// @param ctx Context struct containing the current state of the escrow lock.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param bidAmount The winning solver's bid amount, to be allocated.\n    /// @param returnData Data returned from the execution of the UserOperation, which may influence how the bid amount\n    /// is allocated.\n    function _allocateValue(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        uint256 bidAmount,\n        bytes memory returnData\n    )\n        internal\n        withLockPhase(ExecutionPhase.AllocateValue)\n    {\n        uint256 _dappGasWaterMark = gasleft();\n\n        (bool _success,) = ctx.executionEnvironment.call{ gas: ctx.dappGasLeft }(\n            abi.encodePacked(\n                abi.encodeCall(\n                    IExecutionEnvironment.allocateValue, (ctx.solverSuccessful, dConfig.bidToken, bidAmount, returnData)\n                ),\n                ctx.setAndPack(ExecutionPhase.AllocateValue)\n            )\n        );\n\n        _updateDAppGasLeft(ctx, _dappGasWaterMark);\n\n        // Revert if allocateValue failed at any point.\n        if (!_success) {\n            if (ctx.isSimulation) revert AllocateValueSimFail();\n            revert AllocateValueFail();\n        }\n    }\n\n    /// @notice Adjusts the gas ledger before evaluating a SolverOperation.\n    /// @dev Updates the in-memory `gL` by decreasing `unreachedSolverGas` based on the current solverOp's max potential\n    /// gas (execution + calldata if not exPostBids) and resets `maxApprovedGasSpend` to 0. Caller must persist `gL`\n    /// changes to transient storage separately.\n    /// @param gL The GasLedger struct (in memory) to modify.\n    /// @param dConfig DApp configuration containing `solverGasLimit` and `callConfig`.\n    /// @param solverOp The SolverOperation being evaluated.\n    function _adjustGasLedgerAtSolverOpStart(\n        GasLedger memory gL,\n        DAppConfig memory dConfig,\n        SolverOperation calldata solverOp\n    )\n        internal\n        view\n    {\n        // Decrease unreachedSolverGas by the current solverOp's (C + E) max gas\n        uint256 _calldataGas;\n\n        // Solver's execution gas is solverOp.gas with a max of dConfig.solverGasLimit\n        uint256 _executionGas = (solverOp.gas > dConfig.solverGasLimit) ? dConfig.solverGasLimit : solverOp.gas;\n\n        // Calldata gas is only included if NOT in exPostBids mode.\n        if (!dConfig.callConfig.exPostBids()) {\n            _calldataGas = GasAccLib.solverOpCalldataGas(solverOp.data.length, L2_GAS_CALCULATOR);\n        }\n\n        // Reset solver's max approved gas spend to 0 at start of each new solver execution\n        gL.maxApprovedGasSpend = 0;\n        gL.unreachedSolverGas -= (_executionGas + _calldataGas).toUint40();\n\n        // NOTE: GasLedger changes must be persisted to transient storage separately after this function call\n    }\n\n    /// @notice Validates a SolverOperation's gas requirements against the escrow state.\n    /// @dev Performs a series of checks to ensure that a SolverOperation can be executed within the defined parameters\n    /// and limits. This includes verifying that the operation is within the gas limit and that the solver has\n    /// sufficient balance in escrow to cover the gas costs.\n    /// @param gL The GasLedger memory struct containing the current gas accounting state.\n    /// @param dConfig DApp configuration data, including solver gas limits and operation parameters.\n    /// @param solverOp The SolverOperation being validated.\n    /// @param gasWaterMark The initial gas measurement before validation begins, used to ensure enough gas remains for\n    /// validation logic.\n    /// @param result The current result bitmap, which will be updated with the outcome of the gas validation checks.\n    /// @return result Updated result flags after performing the validation checks, including any new errors\n    /// encountered.\n    /// @return gasLimit The calculated gas limit for the SolverOperation, considering the operation's gas usage and\n    /// the protocol's gas buffers.\n    function _validateSolverOpGasAndValue(\n        GasLedger memory gL,\n        DAppConfig memory dConfig,\n        SolverOperation calldata solverOp,\n        uint256 gasWaterMark,\n        uint256 result\n    )\n        internal\n        view\n        returns (uint256, uint256 gasLimit)\n    {\n        // gasLimit is solverOp.gas, with a max of dConfig.solverGasLimit\n        gasLimit = (solverOp.gas > dConfig.solverGasLimit) ? dConfig.solverGasLimit : solverOp.gas;\n\n        if (gasWaterMark < _VALIDATION_GAS_LIMIT + gasLimit) {\n            // Make sure to leave enough gas for dApp validation calls\n            result |= 1 << uint256(SolverOutcome.UserOutOfGas);\n            return (result, gasLimit);\n        }\n\n        // Verify that we can lend the solver their tx value\n        if (solverOp.value > address(this).balance) {\n            result |= 1 << uint256(SolverOutcome.CallValueTooHigh);\n            return (result, gasLimit);\n        }\n\n        uint256 _solverBalance = S_accessData[solverOp.from].bonded;\n\n        // Checks if solver's bonded balance is enough to cover the max charge should they win, including surcharges\n        if (_solverBalance < gL.solverGasLiability()) {\n            result |= 1 << uint256(SolverOutcome.InsufficientEscrow);\n        }\n\n        return (result, gasLimit);\n    }\n\n    /// @notice Validates a SolverOperation's deadline against the current block.\n    /// @param solverOp The SolverOperation being validated.\n    /// @param dConfig DApp configuration data, including solver gas limits and operation parameters.\n    /// @return result Updated result flags after performing the validation checks, including any new errors\n    function _validateSolverOpDeadline(\n        SolverOperation calldata solverOp,\n        DAppConfig memory dConfig\n    )\n        internal\n        view\n        returns (uint256 result)\n    {\n        if (solverOp.deadline != 0 && block.number > solverOp.deadline) {\n            result |= (\n                1\n                    << uint256(\n                        dConfig.callConfig.allowsTrustedOpHash()\n                            ? uint256(SolverOutcome.DeadlinePassedAlt)\n                            : uint256(SolverOutcome.DeadlinePassed)\n                    )\n            );\n            return result;\n        }\n\n        uint256 lastAccessedBlock = S_accessData[solverOp.from].lastAccessedBlock;\n\n        if (lastAccessedBlock >= block.number) {\n            result |= 1 << uint256(SolverOutcome.PerBlockLimit);\n        }\n    }\n\n    /// @notice Determines the bid amount for a SolverOperation based on verification and validation results.\n    /// @dev This function assesses whether a SolverOperation meets the criteria for execution by verifying it against\n    /// the Atlas protocol's rules and the current Context lock state. It checks for valid execution based on the\n    /// SolverOperation's specifics, like gas usage and deadlines. The function aims to protect against malicious\n    /// bundlers by ensuring solvers are not unfairly charged for on-chain bid finding gas usage. If the operation\n    /// passes verification and validation, and if it's eligible for bid amount determination, the function\n    /// attempts to execute and determine the bid amount.\n    /// @param ctx The Context struct containing the current state of the escrow lock.\n    /// @param dConfig The DApp configuration data, including parameters relevant to solver bid validation.\n    /// @param userOp The UserOperation associated with this SolverOperation, providing context for the bid amount\n    /// determination.\n    /// @param solverOp The SolverOperation being assessed, containing the solver's bid amount.\n    /// @param returnData Data returned from the execution of the UserOp call.\n    /// @return bidAmount The determined bid amount for the SolverOperation if all validations pass and the operation is\n    /// executed successfully; otherwise, returns 0.\n    function _getBidAmount(\n        Context memory ctx,\n        DAppConfig memory dConfig,\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256 bidAmount)\n    {\n        // NOTE: To prevent a malicious bundler from aggressively collecting storage refunds,\n        // solvers should not be on the hook for any 'onchain bid finding' gas usage.\n\n        uint256 _gasWaterMark = gasleft();\n        uint256 _gasLimit;\n        GasLedger memory _gL = t_gasLedger.toGasLedger();\n\n        // Decrease unreachedSolverGas and reset maxApprovedGasSpend at the start of each solverOp\n        _adjustGasLedgerAtSolverOpStart(_gL, dConfig, solverOp);\n        t_gasLedger = _gL.pack(); // Persist changes to transient storage\n\n        uint256 _result = VERIFICATION.verifySolverOp(\n            solverOp, ctx.userOpHash, userOp.maxFeePerGas, ctx.bundler, dConfig.callConfig.allowsTrustedOpHash()\n        );\n\n        _result = _checkSolverBidToken(solverOp.bidToken, dConfig.bidToken, _result);\n        (_result, _gasLimit) = _validateSolverOpGasAndValue(_gL, dConfig, solverOp, _gasWaterMark, _result);\n        _result |= _validateSolverOpDeadline(solverOp, dConfig);\n\n        // Verify the transaction.\n        if (!_result.canExecute()) return 0;\n\n        if (dConfig.callConfig.allowsTrustedOpHash()) {\n            if (!_handleAltOpHash(userOp, solverOp)) {\n                return (0);\n            }\n        }\n\n        (bool _success, bytes memory _data) = address(this).call{ gas: _gasLimit }(\n            abi.encodeCall(this.solverCall, (ctx, solverOp, solverOp.bidAmount, returnData))\n        );\n\n        // The `solverCall()` above should always revert as key.bidFind is always true when it's called in the context\n        // of this function. Therefore `success` should always be false below, and the revert should be unreachable.\n        if (_success) {\n            revert Unreachable();\n        }\n\n        if (bytes4(_data) == BidFindSuccessful.selector) {\n            // Get the uint256 from the memory array\n            assembly {\n                let dataLocation := add(_data, 0x20)\n                bidAmount := mload(add(dataLocation, sub(mload(_data), 32)))\n            }\n            return bidAmount;\n        }\n\n        return 0;\n    }\n\n    /// @notice Validates UserOp hashes provided by the SolverOperation, using the alternative set of hashed parameters.\n    /// @param userOp The UserOperation struct, providing the baseline parameters for comparison.\n    /// @param solverOp The SolverOperation struct being validated against the UserOperation.\n    /// @return A boolean value indicating whether the SolverOperation passed the alternative hash check, with `true`\n    /// meaning it is considered valid\n    function _handleAltOpHash(\n        UserOperation calldata userOp,\n        SolverOperation calldata solverOp\n    )\n        internal\n        returns (bool)\n    {\n        // These failures should be attributed to bundler maliciousness\n        if (userOp.control != solverOp.control) {\n            return false;\n        }\n        if (!(userOp.deadline == 0 || solverOp.deadline == 0 || solverOp.deadline == userOp.deadline)) {\n            return false;\n        }\n        bytes32 _hashId = keccak256(abi.encodePacked(solverOp.userOpHash, solverOp.from, solverOp.deadline));\n        if (S_solverOpHashes[_hashId]) {\n            return false;\n        }\n        S_solverOpHashes[_hashId] = true;\n        return true;\n    }\n\n    /// @notice Checks if the solver's bid token matches the dApp's bid token.\n    /// @param solverBidToken The solver's bid token address.\n    /// @param dConfigBidToken The dApp's bid token address.\n    /// @param result The current result bitmap, which will be updated with the outcome of the bid token check.\n    /// @return The updated result bitmap, with the SolverOutcome.InvalidBidToken flag set if the bid token check fails.\n    function _checkSolverBidToken(\n        address solverBidToken,\n        address dConfigBidToken,\n        uint256 result\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (solverBidToken != dConfigBidToken) {\n            return result | 1 << uint256(SolverOutcome.InvalidBidToken);\n        }\n        return result;\n    }\n\n    /// @notice Wraps the execution of a SolverOperation and handles potential errors.\n    /// @param ctx The current lock data.\n    /// @param solverOp The SolverOperation struct containing the operation's execution data.\n    /// @param bidAmount The bid amount associated with the SolverOperation.\n    /// @param gasLimit The gas limit for executing the SolverOperation, calculated based on the operation's\n    /// requirements and protocol buffers.\n    /// @param returnData Data returned from the execution of the associated UserOperation, which may be required\n    /// for the SolverOperation's logic.\n    /// @return result SolverOutcome enum value encoded as a uint256 bitmap, representing the result of the\n    /// SolverOperation\n    /// @return solverTracker Tracking data for the solver's bid\n    function _solverOpWrapper(\n        Context memory ctx,\n        SolverOperation calldata solverOp,\n        uint256 bidAmount,\n        uint256 gasLimit,\n        bytes memory returnData\n    )\n        internal\n        returns (uint256 result, SolverTracker memory solverTracker)\n    {\n        // Calls the solverCall function, just below this function, which will handle calling solverPreTryCatch and\n        // solverPostTryCatch via the ExecutionEnvironment, and in between those two hooks, the actual solver call\n        // directly from Atlas to the solver contract (not via the ExecutionEnvironment).\n        (bool _success, bytes memory _data) =\n            address(this).call{ gas: gasLimit }(abi.encodeCall(this.solverCall, (ctx, solverOp, bidAmount, returnData)));\n\n        if (_success) {\n            // If solverCall() was successful, intentionally leave uint256 result unset as 0 indicates success.\n            solverTracker = abi.decode(_data, (SolverTracker));\n        } else {\n            // If solverCall() failed, catch the error and encode the failure case in the result uint accordingly.\n            bytes4 _errorSwitch = bytes4(_data);\n            if (_errorSwitch == AlteredControl.selector) {\n                result = 1 << uint256(SolverOutcome.AlteredControl);\n            } else if (_errorSwitch == InsufficientEscrow.selector) {\n                result = 1 << uint256(SolverOutcome.InsufficientEscrow);\n            } else if (_errorSwitch == PreSolverFailed.selector) {\n                result = 1 << uint256(SolverOutcome.PreSolverFailed);\n            } else if (_errorSwitch == SolverOpReverted.selector) {\n                result = 1 << uint256(SolverOutcome.SolverOpReverted);\n            } else if (_errorSwitch == PostSolverFailed.selector) {\n                result = 1 << uint256(SolverOutcome.PostSolverFailed);\n            } else if (_errorSwitch == BidNotPaid.selector) {\n                result = 1 << uint256(SolverOutcome.BidNotPaid);\n            } else if (_errorSwitch == InvalidSolver.selector) {\n                result = 1 << uint256(SolverOutcome.InvalidSolver);\n            } else if (_errorSwitch == BalanceNotReconciled.selector) {\n                result = 1 << uint256(SolverOutcome.BalanceNotReconciled);\n            } else if (_errorSwitch == CallbackNotCalled.selector) {\n                result = 1 << uint256(SolverOutcome.CallbackNotCalled);\n            } else if (_errorSwitch == InvalidEntry.selector) {\n                // DAppControl is attacking solver contract - treat as AlteredControl\n                result = 1 << uint256(SolverOutcome.AlteredControl);\n            } else {\n                result = 1 << uint256(SolverOutcome.EVMError);\n            }\n        }\n    }\n\n    /// @notice Executes the SolverOperation logic, including preSolver and postSolver hooks via the Execution\n    /// Environment, as well as the actual solver call directly from Atlas to the solver contract.\n    /// @param ctx The Context struct containing lock data and the Execution Environment address.\n    /// @param solverOp The SolverOperation to be executed.\n    /// @param bidAmount The bid amount associated with the SolverOperation.\n    /// @param returnData Data returned from previous call phases.\n    /// @return solverTracker Additional data for handling the solver's bid in different scenarios.\n    function solverCall(\n        Context memory ctx,\n        SolverOperation calldata solverOp,\n        uint256 bidAmount,\n        bytes calldata returnData\n    )\n        external\n        payable\n        returns (SolverTracker memory solverTracker)\n    {\n        if (msg.sender != address(this)) revert InvalidEntry();\n\n        bytes memory _data;\n        bool _success;\n\n        // Set the solver lock and solver address at the beginning to ensure reliability\n        t_solverLock = uint256(uint160(solverOp.from));\n        t_solverTo = solverOp.solver;\n\n        // ------------------------------------- //\n        //             Pre-Solver Call           //\n        // ------------------------------------- //\n\n        _setLockPhase(uint8(ExecutionPhase.PreSolver));\n\n        (_success, _data) = ctx.executionEnvironment.call(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.solverPreTryCatch, (bidAmount, solverOp, returnData)),\n                ctx.setAndPack(ExecutionPhase.PreSolver)\n            )\n        );\n\n        // If ExecutionEnvironment.solverPreTryCatch() failed, bubble up the error\n        if (!_success) {\n            assembly {\n                revert(add(_data, 32), mload(_data))\n            }\n        }\n\n        // Update solverTracker with returned data\n        solverTracker = abi.decode(_data, (SolverTracker));\n\n        // ------------------------------------- //\n        //              Solver Call              //\n        // ------------------------------------- //\n\n        _setLockPhase(uint8(ExecutionPhase.SolverOperation));\n\n        // Make sure there's enough value in Atlas for the Solver\n        if (!_borrow(solverOp.value)) revert InsufficientEscrow();\n\n        // Load callConfig from transient storage once here, to be used below.\n        uint32 _callConfig = _activeCallConfig();\n\n        // NOTE: The solver's bidAmount is always sent to their solver contract during the solver call. In exPostBids\n        // mode, it is possible for a solver to encode some infomation calculated during the bid-finding process, which\n        // the bundler pays for as that gas cost is written off, in the least significant bits of their bidAmount. This\n        // information can be used to minimize the gas cost a solver is charged for during real execution. This is seen\n        // as a feature, because the decrease in gas cost paid by the solver should result in a higher bid they are able\n        // to make - a better outcome for the bid recipient.\n\n        // Optimism's SafeCall lib allows us to limit how much returndata gets copied to memory, to prevent OOG attacks.\n        _success = solverOp.solver.safeCall(\n            gasleft(),\n            solverOp.value,\n            abi.encodeCall(\n                ISolverContract.atlasSolverCall,\n                (\n                    solverOp.from,\n                    ctx.executionEnvironment,\n                    solverOp.bidToken,\n                    bidAmount,\n                    solverOp.data,\n                    // Only pass the returnData (either from userOp or preOps) if the dApp requires it\n                    _callConfig.forwardReturnData() ? returnData : new bytes(0)\n                )\n            )\n        );\n\n        if (!_success) revert SolverOpReverted();\n\n        // ------------------------------------- //\n        //            Post-Solver Call           //\n        // ------------------------------------- //\n\n        _setLockPhase(uint8(ExecutionPhase.PostSolver));\n\n        (_success, _data) = ctx.executionEnvironment.call(\n            abi.encodePacked(\n                abi.encodeCall(IExecutionEnvironment.solverPostTryCatch, (solverOp, returnData, solverTracker)),\n                ctx.setAndPack(ExecutionPhase.PostSolver)\n            )\n        );\n\n        // If ExecutionEnvironment.solverPostTryCatch() failed, bubble up the error\n        if (!_success) {\n            assembly {\n                revert(add(_data, 32), mload(_data))\n            }\n        }\n\n        // Update solverTracker with returned data\n        solverTracker = abi.decode(_data, (SolverTracker));\n\n        // ------------------------------------- //\n        //              Final Checks             //\n        // ------------------------------------- //\n\n        // Verify that the solver repaid their borrowed solverOp.value by calling `reconcile()`. If `reconcile()` did\n        // not fully repay the borrowed amount, the `postSolverCall` might have covered the outstanding debt via\n        // `contribute()`. This final check ensures that the solver has fulfilled their repayment obligations before\n        // proceeding.\n        (, bool _calledback, bool _fulfilled) = _solverLockData();\n        if (!_calledback) revert CallbackNotCalled();\n        if (!_fulfilled && !_isBalanceReconciled()) revert BalanceNotReconciled();\n\n        // Check if this is an on-chain, ex post bid search by verifying the `ctx.bidFind` flag.\n        // If the flag is set, revert with `BidFindSuccessful` and include the solver's bid amount in `solverTracker`.\n        // This indicates that the bid search process has completed successfully.\n        if (ctx.bidFind) revert BidFindSuccessful(solverTracker.bidAmount);\n    }\n\n    /// Updates ctx.dappGasLeft based on the gas used in the DApp hook call just performed.\n    /// @dev Measure the gasWaterMarkBefore using `gasleft()` just before performing the DApp hook call.\n    /// @dev Will revert if the gas used exceeds the remaining dappGasLeft.\n    /// @param ctx Memory pointer to the metacalls' Context object.\n    /// @param gasWaterMarkBefore The gasleft() value just before the DApp hook call.\n    function _updateDAppGasLeft(Context memory ctx, uint256 gasWaterMarkBefore) internal view {\n        uint256 _gasUsed = gasWaterMarkBefore - gasleft();\n\n        if (_gasUsed > ctx.dappGasLeft) revert DAppGasLimitReached();\n\n        // No need to SafeCast - will revert above if too large for uint32\n        ctx.dappGasLeft -= uint32(_gasUsed);\n    }\n\n    receive() external payable { }\n}\n"
    }
}