{
    "vfp_id": "vfp_00511",
    "project_name": "USDT0 Child Token Audit.md",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Missing Support for EIP-3009",
            "description": "The developer documentation claims support for EIP-3009 (gasless transfers), but the `UChildUSDT0` contract does not implement the required `transferWithAuthorization` and `receiveWithAuthorization` functions. This discrepancy misleads developers and users who expect gasless transfer functionality, potentially leading to integration errors or failed transactions. The cause is an omission in the contract implementation despite documentation claims. This undermines trust in the project's documentation and limits the utility of the token.\n",
            "severity": "Low",
            "location": [
                "UChildUSDT0.sol#L9-L197",
                "developer documentation"
            ],
            "files": [
                "UChildERC20Proxy/UChildERC20Proxy.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Redundant Event Emission",
            "description": "The `addToBlockedList` and `removeFromBlockedList` functions in `WithBlockedList.sol` emit events without first checking if the blocklist state has actually changed. This can result in redundant events being emitted when an address is added or removed multiple times, leading to unnecessary gas costs and potentially misleading off-chain monitoring systems. The root cause is the absence of a state-diff check before event emission. While the impact is minor, it affects efficiency and data reliability.\n",
            "severity": "Low",
            "location": [
                "WithBlockedList.sol#L37",
                "WithBlockedList.sol#L42"
            ],
            "files": [
                "UChildERC20Proxy/UChildERC20Proxy.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing ERC-165 Support",
            "description": "The `UChildUSDT0` contract implements EIP-7802 but does not support ERC-165, meaning it lacks the `supportsInterface` function to advertise its interface compliance. This makes it harder for external contracts to reliably detect whether the contract supports specific standards, reducing interoperability. The cause is the omission of the `IERC165` interface and implementation. Although the functionality exists, the lack of standard discovery mechanism is a compatibility issue.\n",
            "severity": "Low",
            "location": [
                "UChildUSDT0.sol#L9-L197"
            ],
            "files": [
                "UChildERC20Proxy/UChildERC20Proxy.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Zero-Address Check",
            "description": "The `upgradeToUSDT0` function in `UChildUSDT0.sol` does not validate that the `newAdmin` parameter is not the zero address. If accidentally set to zero, the contract could become unmanageable, as administrative functions would be inaccessible. This is a common configuration risk in upgradeable contracts. The root cause is the lack of input validation for critical address parameters. This could lead to permanent loss of control if triggered.\n",
            "severity": "Low",
            "location": [
                "UChildUSDT0.sol#L16"
            ],
            "files": [
                "UChildERC20Proxy/UChildERC20Proxy.sol"
            ]
        }
    ],
    "affected_files": {
        "UChildERC20Proxy.sol": "\n// File: contracts/common/Proxy/IERCProxy.sol\n\npragma solidity 0.6.6;\n\ninterface IERCProxy {\n    function proxyType() external pure returns (uint256 proxyTypeId);\n\n    function implementation() external view returns (address codeAddr);\n}\n\n// File: contracts/common/Proxy/Proxy.sol\n\npragma solidity 0.6.6;\n\n\nabstract contract Proxy is IERCProxy {\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let result := delegatecall(\n                sub(gas(), 10000),\n                _dst,\n                add(_calldata, 0x20),\n                mload(_calldata),\n                0,\n                0\n            )\n            let size := returndatasize()\n\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n\n    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {\n        // Upgradeable proxy\n        proxyTypeId = 2;\n    }\n\n    function implementation() external virtual override view returns (address);\n}\n\n// File: contracts/common/Proxy/UpgradableProxy.sol\n\npragma solidity 0.6.6;\n\n\ncontract UpgradableProxy is Proxy {\n    event ProxyUpdated(address indexed _new, address indexed _old);\n    event ProxyOwnerUpdate(address _new, address _old);\n\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"matic.network.proxy.implementation\");\n    bytes32 constant OWNER_SLOT = keccak256(\"matic.network.proxy.owner\");\n\n    constructor(address _proxyTo) public {\n        setProxyOwner(msg.sender);\n        setImplementation(_proxyTo);\n    }\n\n    fallback() external payable {\n        delegatedFwd(loadImplementation(), msg.data);\n    }\n\n    receive() external payable {\n        delegatedFwd(loadImplementation(), msg.data);\n    }\n\n    modifier onlyProxyOwner() {\n        require(loadProxyOwner() == msg.sender, \"NOT_OWNER\");\n        _;\n    }\n\n    function proxyOwner() external view returns(address) {\n        return loadProxyOwner();\n    }\n\n    function loadProxyOwner() internal view returns(address) {\n        address _owner;\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            _owner := sload(position)\n        }\n        return _owner;\n    }\n\n    function implementation() external override view returns (address) {\n        return loadImplementation();\n    }\n\n    function loadImplementation() internal view returns(address) {\n        address _impl;\n        bytes32 position = IMPLEMENTATION_SLOT;\n        assembly {\n            _impl := sload(position)\n        }\n        return _impl;\n    }\n\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());\n        setProxyOwner(newOwner);\n    }\n\n    function setProxyOwner(address newOwner) private {\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            sstore(position, newOwner)\n        }\n    }\n\n    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\n\n        emit ProxyUpdated(_newProxyTo, loadImplementation());\n        \n        setImplementation(_newProxyTo);\n    }\n\n    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\n        updateImplementation(_newProxyTo);\n\n        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);\n        require(success, string(returnData));\n    }\n\n    function setImplementation(address _newProxyTo) private {\n        bytes32 position = IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(position, _newProxyTo)\n        }\n    }\n    \n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        return size > 0;\n    }\n}\n\n// File: contracts/child/ChildToken/UpgradeableChildERC20/UChildERC20Proxy.sol\n\npragma solidity 0.6.6;\n\n\ncontract UChildERC20Proxy is UpgradableProxy {\n    constructor(address _proxyTo)\n        public\n        UpgradableProxy(_proxyTo)\n    {}\n}\n"
    }
}