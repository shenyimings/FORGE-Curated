{
    "vfp_id": "vfp_00238",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Legacy CreditManager Cannot Be Fully Configured",
            "description": "After migrating legacy credit suites to the new governance system via MarketConfiguratorLegacy, certain functions like setMaxEnabledTokens() and makeTokenQuoted() cannot be called because they are not supported by the CreditFactory's encoding logic. This limits post-migration configuration capabilities. An attacker could exploit this by forcing a migration before configurations are finalized, leading to permanently misconfigured markets. The impact is reduced flexibility and potential for increased risk in legacy markets.\n",
            "severity": "High",
            "location": [
                "MarketConfiguratorLegacy.sol",
                "CreditFactory.sol"
            ],
            "files": [
                "permissionless/contracts/market/legacy/MarketConfiguratorLegacy.sol"
            ]
        }
    ],
    "affected_files": {
        "MarketConfiguratorLegacy.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\nimport {ICreditConfiguratorV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditConfiguratorV3.sol\";\nimport {ICreditFacadeV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {IPoolQuotaKeeperV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolQuotaKeeperV3.sol\";\nimport {IPoolV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol\";\n\nimport {DefaultLossPolicy} from \"../../helpers/DefaultLossPolicy.sol\";\n\nimport {IACL} from \"../../interfaces/IACL.sol\";\nimport {IContractsRegister} from \"../../interfaces/IContractsRegister.sol\";\nimport {Call, MarketFactories} from \"../../interfaces/Types.sol\";\n\nimport {\n    AP_MARKET_CONFIGURATOR_LEGACY,\n    AP_CROSS_CHAIN_GOVERNANCE_PROXY,\n    NO_VERSION_CONTROL,\n    ROLE_EMERGENCY_LIQUIDATOR,\n    ROLE_PAUSABLE_ADMIN,\n    ROLE_UNPAUSABLE_ADMIN\n} from \"../../libraries/ContractLiterals.sol\";\n\nimport {MarketConfigurator} from \"../MarketConfigurator.sol\";\n\ninterface IACLLegacy {\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function transferOwnership(address newOwner) external;\n    function claimOwnership() external;\n\n    function isPausableAdmin(address account) external view returns (bool);\n    function addPausableAdmin(address account) external;\n    function removePausableAdmin(address account) external;\n\n    function isUnpausableAdmin(address account) external view returns (bool);\n    function addUnpausableAdmin(address account) external;\n    function removeUnpausableAdmin(address account) external;\n}\n\ninterface IContractsRegisterLegacy {\n    function getPools() external view returns (address[] memory);\n    function addPool(address pool) external;\n    function getCreditManagers() external view returns (address[] memory);\n    function addCreditManager(address creditManager) external;\n}\n\ncontract MarketConfiguratorLegacy is MarketConfigurator {\n    using Address for address;\n\n    /// @notice Contract version\n    uint256 public constant override version = 3_10;\n\n    /// @notice Contract type\n    bytes32 public constant override contractType = AP_MARKET_CONFIGURATOR_LEGACY;\n\n    address public immutable crossChainGovernanceProxy;\n\n    address public immutable aclLegacy;\n    address public immutable contractsRegisterLegacy;\n    address public immutable gearStakingLegacy;\n\n    error AddressIsNotPausableAdminException(address admin);\n    error AddressIsNotUnpausableAdminException(address admin);\n    error CallerIsNotCrossChainGovernanceProxyException(address caller);\n    error CallsToLegacyContractsAreForbiddenException();\n    error CollateralTokenIsNotQuotedException(address creditManager, address token);\n    error CreditManagerIsMisconfiguredException(address creditManager);\n\n    modifier onlyCrossChainGovernanceProxy() {\n        if (msg.sender != crossChainGovernanceProxy) revert CallerIsNotCrossChainGovernanceProxyException(msg.sender);\n        _;\n    }\n\n    /// @dev There's no way to validate that `pausableAdmins_` and `unpausableAdmins_` are exhaustive\n    ///      because the legacy ACL contract doesn't provide needed getters, so don't screw up :)\n    constructor(\n        address addressProvider_,\n        address admin_,\n        address emergencyAdmin_,\n        string memory curatorName_,\n        bool deployGovernor_,\n        address aclLegacy_,\n        address contractsRegisterLegacy_,\n        address gearStakingLegacy_,\n        address[] memory pausableAdmins_,\n        address[] memory unpausableAdmins_,\n        address[] memory emergencyLiquidators_\n    ) MarketConfigurator(addressProvider_, admin_, emergencyAdmin_, address(0), curatorName_, deployGovernor_) {\n        crossChainGovernanceProxy = _getAddressOrRevert(AP_CROSS_CHAIN_GOVERNANCE_PROXY, NO_VERSION_CONTROL);\n\n        aclLegacy = aclLegacy_;\n        contractsRegisterLegacy = contractsRegisterLegacy_;\n        gearStakingLegacy = gearStakingLegacy_;\n\n        uint256 num = pausableAdmins_.length;\n        for (uint256 i; i < num; ++i) {\n            address admin = pausableAdmins_[i];\n            if (!IACLLegacy(aclLegacy).isPausableAdmin(admin)) revert AddressIsNotPausableAdminException(admin);\n            IACL(acl).grantRole(ROLE_PAUSABLE_ADMIN, admin);\n            emit GrantRole(ROLE_PAUSABLE_ADMIN, admin);\n        }\n        num = unpausableAdmins_.length;\n        for (uint256 i; i < num; ++i) {\n            address admin = unpausableAdmins_[i];\n            if (!IACLLegacy(aclLegacy).isUnpausableAdmin(admin)) revert AddressIsNotUnpausableAdminException(admin);\n            IACL(acl).grantRole(ROLE_UNPAUSABLE_ADMIN, admin);\n            emit GrantRole(ROLE_UNPAUSABLE_ADMIN, admin);\n        }\n        num = emergencyLiquidators_.length;\n        for (uint256 i; i < num; ++i) {\n            address liquidator = emergencyLiquidators_[i];\n            IACL(acl).grantRole(ROLE_EMERGENCY_LIQUIDATOR, liquidator);\n            emit GrantRole(ROLE_EMERGENCY_LIQUIDATOR, liquidator);\n        }\n\n        address[] memory pools = IContractsRegisterLegacy(contractsRegisterLegacy).getPools();\n        uint256 numPools = pools.length;\n        for (uint256 i; i < numPools; ++i) {\n            address pool = pools[i];\n            if (!_isV3Contract(pool)) continue;\n\n            address[] memory creditManagers = IPoolV3(pool).creditManagers();\n            uint256 numCreditManagers = creditManagers.length;\n            if (numCreditManagers == 0) continue;\n\n            address quotaKeeper = _quotaKeeper(pool);\n            address priceOracle = _priceOracle(creditManagers[0]);\n            address interestRateModel = _interestRateModel(pool);\n            address rateKeeper = _rateKeeper(quotaKeeper);\n            address lossPolicy = address(new DefaultLossPolicy(acl));\n\n            _createMarket(pool, quotaKeeper, priceOracle, interestRateModel, rateKeeper, lossPolicy);\n\n            for (uint256 j; j < numCreditManagers; ++j) {\n                address creditManager = creditManagers[j];\n                if (!_isV3Contract(creditManager) || _priceOracle(creditManager) != priceOracle) {\n                    revert CreditManagerIsMisconfiguredException(creditManager);\n                }\n\n                uint256 numTokens = ICreditManagerV3(creditManager).collateralTokensCount();\n                for (uint256 k = 1; k < numTokens; ++k) {\n                    address token = ICreditManagerV3(creditManager).getTokenByMask(1 << k);\n                    if (!IPoolQuotaKeeperV3(quotaKeeper).isQuotedToken(token)) {\n                        revert CollateralTokenIsNotQuotedException(creditManager, token);\n                    }\n                }\n\n                _createCreditSuite(creditManager);\n            }\n        }\n    }\n\n    function _createMarket(\n        address pool,\n        address quotaKeeper,\n        address priceOracle,\n        address interestRateModel,\n        address rateKeeper,\n        address lossPolicy\n    ) internal {\n        IContractsRegister(contractsRegister).registerMarket(pool, priceOracle, lossPolicy);\n        MarketFactories memory factories = _getLatestMarketFactories(version);\n        _marketFactories[pool] = factories;\n        _authorizeFactory(factories.poolFactory, pool, pool);\n        _authorizeFactory(factories.poolFactory, pool, quotaKeeper);\n        _authorizeFactory(factories.priceOracleFactory, pool, priceOracle);\n        _authorizeFactory(factories.interestRateModelFactory, pool, interestRateModel);\n        _authorizeFactory(factories.rateKeeperFactory, pool, rateKeeper);\n        _authorizeFactory(factories.lossPolicyFactory, pool, lossPolicy);\n\n        emit CreateMarket(pool, priceOracle, interestRateModel, rateKeeper, lossPolicy, factories);\n    }\n\n    function _createCreditSuite(address creditManager) internal {\n        IContractsRegister(contractsRegister).registerCreditSuite(creditManager);\n\n        address factory = _getLatestCreditFactory(version);\n        _creditFactories[creditManager] = factory;\n        address creditConfigurator = ICreditManagerV3(creditManager).creditConfigurator();\n        _authorizeFactory(factory, creditManager, creditConfigurator);\n        _authorizeFactory(factory, creditManager, ICreditManagerV3(creditManager).creditFacade());\n        address[] memory adapters = ICreditConfiguratorV3(creditConfigurator).allowedAdapters();\n        uint256 numAdapters = adapters.length;\n        for (uint256 k; k < numAdapters; ++k) {\n            _authorizeFactory(factory, creditManager, adapters[k]);\n        }\n\n        emit CreateCreditSuite(creditManager, factory);\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function finalizeMigration() external onlyCrossChainGovernanceProxy {\n        // NOTE: on some chains, legacy ACL implements a 2-step ownership transfer\n        try IACLLegacy(aclLegacy).pendingOwner() {\n            IACLLegacy(aclLegacy).claimOwnership();\n        } catch {}\n\n        IACLLegacy(aclLegacy).addPausableAdmin(address(this));\n        IACLLegacy(aclLegacy).addUnpausableAdmin(address(this));\n    }\n\n    function configureGearStaking(bytes calldata data) external onlyCrossChainGovernanceProxy {\n        gearStakingLegacy.functionCall(data);\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    function _grantRole(bytes32 role, address account) internal override {\n        super._grantRole(role, account);\n        if (role == ROLE_PAUSABLE_ADMIN) IACLLegacy(aclLegacy).addPausableAdmin(account);\n        else if (role == ROLE_UNPAUSABLE_ADMIN) IACLLegacy(aclLegacy).addUnpausableAdmin(account);\n    }\n\n    function _revokeRole(bytes32 role, address account) internal override {\n        super._revokeRole(role, account);\n        if (role == ROLE_PAUSABLE_ADMIN) IACLLegacy(aclLegacy).removePausableAdmin(account);\n        else if (role == ROLE_UNPAUSABLE_ADMIN) IACLLegacy(aclLegacy).removeUnpausableAdmin(account);\n    }\n\n    function _registerMarket(address pool, address priceOracle, address lossPolicy) internal override {\n        super._registerMarket(pool, priceOracle, lossPolicy);\n        IContractsRegisterLegacy(contractsRegisterLegacy).addPool(pool);\n    }\n\n    function _registerCreditSuite(address creditManager) internal override {\n        super._registerCreditSuite(creditManager);\n        IContractsRegisterLegacy(contractsRegisterLegacy).addCreditManager(creditManager);\n    }\n\n    function _validateCallTarget(address target, address factory) internal override {\n        super._validateCallTarget(target, factory);\n        if (target == aclLegacy || target == contractsRegisterLegacy || target == gearStakingLegacy) {\n            revert CallsToLegacyContractsAreForbiddenException();\n        }\n    }\n\n    function _isV3Contract(address contract_) internal view returns (bool) {\n        try IVersion(contract_).version() returns (uint256 version_) {\n            return version_ >= 300 && version_ < 400;\n        } catch {\n            return false;\n        }\n    }\n\n    function _priceOracle(address creditManager) internal view returns (address) {\n        return ICreditManagerV3(creditManager).priceOracle();\n    }\n}\n"
    }
}