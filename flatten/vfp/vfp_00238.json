{
    "vfp_id": "vfp_00238",
    "project_name": "ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Factory Migration Will Fail",
            "description": "In MarketConfigurator._migrateFactoryTargets(), the loop that processes target contracts incorrectly modifies the array during iteration, leading to an out-of-bounds access when more than one target exists. This causes the migration transaction to revert, preventing upgrades to new factory versions. Attackers could exploit this by forcing a migration attempt that fails, blocking system upgrades. The impact is a denial of service to the upgrade mechanism, reducing system liveness and maintainability.\n",
            "severity": "High",
            "location": [
                "MarketConfigurator.sol::_migrateFactoryTargets"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Legacy PriceOracle Cannot Be Updated",
            "description": "When updating the PriceOracle via PriceOracleFactory, the system attempts to call reservePriceFeeds() on the old oracle. However, legacy versions (pre-3.10) do not implement this function, causing the update to revert. This prevents oracle upgrades for legacy markets. Attackers could exploit this to block critical oracle updates, leaving outdated or insecure oracles in place. The impact is reduced upgradability and potential price manipulation in legacy markets.\n",
            "severity": "Medium",
            "location": [
                "PriceOracleFactory.sol::_getPriceFeed",
                "PriceOracleV3.sol"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing Sanity Checks on minorVersion",
            "description": "When creating a new market or credit suite, the admin can specify an arbitrary minor version for the factories, potentially leading to mismatched interfaces between components such as pools and credit managers.\nCause: The system lacks validation to ensure version compatibility across interdependent components during deployment.\nExploitation: An admin could intentionally or accidentally deploy components with incompatible versions, leading to unexpected behavior or failures in the system.\nImpact: The mismatch in component interfaces could result in operational failures, broken functionality, or incorrect state transitions within the protocol.\n",
            "severity": "Medium",
            "location": [
                "MarketConfigurator::enforces version to be 3_XY"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Rate Keeper Cannot Be Updated",
            "description": "Updating the rate keeper through the market configurator fails because the quota keeper checks for tokens to be added to the new rate keeper before they are actually added.\nCause: The order of operations is incorrectâ€”the tokens are added in a later hook after the check has already occurred.\nExploitation: Any attempt to update the rate keeper will revert due to the premature validation, preventing necessary upgrades.\nImpact: The inability to update the rate keeper blocks protocol upgrades and maintenance, potentially leading to outdated or insecure configurations persisting.\n",
            "severity": "Medium",
            "location": [
                "MarketConfigurator::onUpdateRateKeeper",
                "PoolFactory::setGauge",
                "QuotaKeeper",
                "RateKeeperFactory::install hook"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Shutting Down a Market Configurator",
            "description": "The shutdown function for a market configurator reverts when it should succeed, due to incorrect logic in the use of EnumerableSet.add.\nCause: The code reverts when the market configurator is successfully added to the shutdown set, but EnumerableSet.add returns true on successful addition, making the revert condition trigger incorrectly.\nExploitation: An admin attempting to shut down a market configurator will find the operation impossible due to the revert.\nImpact: Market shutdown functionality is broken, preventing proper deprecation or retirement of outdated or compromised markets.\n",
            "severity": "Medium",
            "location": [
                "_shutdownMarketConfiguratorsSet.add(marketConfigurator)"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        }
    ],
    "affected_files": {
        "MarketConfigurator.sol": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\nimport {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {IPoolQuotaKeeperV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolQuotaKeeperV3.sol\";\nimport {IPoolV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol\";\n\nimport {ICreditFactory} from \"../interfaces/factories/ICreditFactory.sol\";\nimport {IFactory} from \"../interfaces/factories/IFactory.sol\";\nimport {IInterestRateModelFactory} from \"../interfaces/factories/IInterestRateModelFactory.sol\";\nimport {ILossPolicyFactory} from \"../interfaces/factories/ILossPolicyFactory.sol\";\nimport {IMarketFactory} from \"../interfaces/factories/IMarketFactory.sol\";\nimport {IPoolFactory} from \"../interfaces/factories/IPoolFactory.sol\";\nimport {IPriceOracleFactory} from \"../interfaces/factories/IPriceOracleFactory.sol\";\nimport {IRateKeeperFactory} from \"../interfaces/factories/IRateKeeperFactory.sol\";\n\nimport {IACL} from \"../interfaces/IACL.sol\";\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {IBytecodeRepository} from \"../interfaces/IBytecodeRepository.sol\";\nimport {IContractsRegister} from \"../interfaces/IContractsRegister.sol\";\nimport {IGovernor} from \"../interfaces/IGovernor.sol\";\nimport {IMarketConfigurator} from \"../interfaces/IMarketConfigurator.sol\";\nimport {Call, DeployParams, DeployResult, MarketFactories} from \"../interfaces/Types.sol\";\n\nimport {\n    AP_ACL,\n    AP_CONTRACTS_REGISTER,\n    AP_CREDIT_FACTORY,\n    AP_GOVERNOR,\n    AP_INTEREST_RATE_MODEL_FACTORY,\n    AP_LOSS_POLICY_FACTORY,\n    AP_MARKET_CONFIGURATOR,\n    AP_POOL_FACTORY,\n    AP_PRICE_ORACLE_FACTORY,\n    AP_RATE_KEEPER_FACTORY,\n    AP_TREASURY,\n    AP_TREASURY_SPLITTER,\n    NO_VERSION_CONTROL,\n    ROLE_PAUSABLE_ADMIN,\n    ROLE_UNPAUSABLE_ADMIN\n} from \"../libraries/ContractLiterals.sol\";\nimport {Domain} from \"../libraries/Domain.sol\";\n\nimport {DeployerTrait} from \"../traits/DeployerTrait.sol\";\n\n/// @title Market configurator\ncontract MarketConfigurator is DeployerTrait, IMarketConfigurator {\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using LibString for string;\n    using LibString for bytes32;\n\n    // --------------- //\n    // STATE VARIABLES //\n    // --------------- //\n\n    address public immutable override admin;\n    address public override emergencyAdmin;\n    bytes32 internal immutable _curatorName;\n\n    address public immutable override acl;\n    address public immutable override contractsRegister;\n    address public immutable override treasury;\n\n    mapping(bytes32 domain => EnumerableSet.AddressSet) internal _peripheryContracts;\n\n    mapping(address pool => MarketFactories) internal _marketFactories;\n    mapping(address creditManager => address) internal _creditFactories;\n\n    mapping(address target => address) internal _authorizedFactories;\n    mapping(address factory => mapping(address suite => EnumerableSet.AddressSet)) internal _factoryTargets;\n\n    // --------- //\n    // MODIFIERS //\n    // --------- //\n\n    modifier onlySelf() {\n        _ensureCallerIsSelf();\n        _;\n    }\n\n    modifier onlyAdmin() {\n        _ensureCallerIsAdmin();\n        _;\n    }\n\n    modifier onlyEmergencyAdmin() {\n        _ensureCallerIsEmergencyAdmin();\n        _;\n    }\n\n    modifier onlyRegisteredMarket(address pool) {\n        _ensureRegisteredMarket(pool);\n        _;\n    }\n\n    modifier onlyRegisteredCreditSuite(address creditManager) {\n        _ensureRegisteredCreditSuite(creditManager);\n        _;\n    }\n\n    // ----------- //\n    // CONSTRUCTOR //\n    // ----------- //\n\n    constructor(\n        address addressProvider_,\n        address admin_,\n        address emergencyAdmin_,\n        address adminFeeTreasury_,\n        string memory curatorName_,\n        bool deployGovernor_\n    ) DeployerTrait(addressProvider_) {\n        if (deployGovernor_) {\n            address governor = _deployLatestPatch({\n                contractType: AP_GOVERNOR,\n                minorVersion: 3_10,\n                constructorParams: abi.encode(admin_, emergencyAdmin_, 1 days, false),\n                salt: 0\n            });\n            admin = IGovernor(governor).timeLock();\n        } else {\n            admin = admin_;\n        }\n        emergencyAdmin = emergencyAdmin_;\n        _curatorName = curatorName_.toSmallString();\n\n        acl = _deployLatestPatch({\n            contractType: AP_ACL,\n            minorVersion: 3_10,\n            constructorParams: abi.encode(address(this)),\n            salt: 0\n        });\n        contractsRegister = _deployLatestPatch({\n            contractType: AP_CONTRACTS_REGISTER,\n            minorVersion: 3_10,\n            constructorParams: abi.encode(acl),\n            salt: 0\n        });\n        if (adminFeeTreasury_ != address(0)) {\n            treasury = _deployLatestPatch({\n                contractType: AP_TREASURY_SPLITTER,\n                minorVersion: 3_10,\n                constructorParams: abi.encode(addressProvider, admin, adminFeeTreasury_),\n                salt: 0\n            });\n        } else {\n            treasury = _getAddressOrRevert(AP_TREASURY, NO_VERSION_CONTROL);\n        }\n\n        IACL(acl).grantRole(ROLE_PAUSABLE_ADMIN, address(this));\n        IACL(acl).grantRole(ROLE_UNPAUSABLE_ADMIN, address(this));\n\n        emit SetEmergencyAdmin(emergencyAdmin_);\n        emit GrantRole(ROLE_PAUSABLE_ADMIN, address(this));\n        emit GrantRole(ROLE_UNPAUSABLE_ADMIN, address(this));\n    }\n\n    // -------- //\n    // METADATA //\n    // -------- //\n\n    /// @notice Contract version\n    /// @dev `MarketConfiguratorLegacy` might have different version, hence the `virtual` modifier\n    function version() external view virtual override returns (uint256) {\n        return 3_10;\n    }\n\n    /// @notice Contract type\n    /// @dev `MarketConfiguratorLegacy` has different type, hence the `virtual` modifier\n    function contractType() external view virtual override returns (bytes32) {\n        return AP_MARKET_CONFIGURATOR;\n    }\n\n    /// @notice Curator name\n    function curatorName() external view override returns (string memory) {\n        return _curatorName.fromSmallString();\n    }\n\n    // ---------------- //\n    // ROLES MANAGEMENT //\n    // ---------------- //\n\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyAdmin {\n        if (newEmergencyAdmin == emergencyAdmin) return;\n        emergencyAdmin = newEmergencyAdmin;\n        emit SetEmergencyAdmin(newEmergencyAdmin);\n    }\n\n    function grantRole(bytes32 role, address account) external override onlyAdmin {\n        _grantRole(role, account);\n        emit GrantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) external override onlyAdmin {\n        _revokeRole(role, account);\n        emit RevokeRole(role, account);\n    }\n\n    function emergencyRevokeRole(bytes32 role, address account) external override onlyEmergencyAdmin {\n        _revokeRole(role, account);\n        emit EmergencyRevokeRole(role, account);\n    }\n\n    // ----------------- //\n    // MARKET MANAGEMENT //\n    // ----------------- //\n\n    function previewCreateMarket(uint256 minorVersion, address underlying, string calldata name, string calldata symbol)\n        external\n        view\n        override\n        returns (address)\n    {\n        MarketFactories memory factories = _getLatestMarketFactories(minorVersion);\n        return IPoolFactory(factories.poolFactory).computePoolAddress(address(this), underlying, name, symbol);\n    }\n\n    function createMarket(\n        uint256 minorVersion,\n        address underlying,\n        string calldata name,\n        string calldata symbol,\n        DeployParams calldata interestRateModelParams,\n        DeployParams calldata rateKeeperParams,\n        DeployParams calldata lossPolicyParams,\n        address underlyingPriceFeed\n    ) external override onlyAdmin returns (address pool) {\n        MarketFactories memory factories = _getLatestMarketFactories(minorVersion);\n        pool = _deployPool(factories.poolFactory, underlying, name, symbol);\n        address priceOracle = _deployPriceOracle(factories.priceOracleFactory, pool);\n        address interestRateModel =\n            _deployInterestRateModel(factories.interestRateModelFactory, pool, interestRateModelParams);\n        address rateKeeper = _deployRateKeeper(factories.rateKeeperFactory, pool, rateKeeperParams);\n        address lossPolicy = _deployLossPolicy(factories.lossPolicyFactory, pool, lossPolicyParams);\n        _marketFactories[pool] = factories;\n\n        _registerMarket(pool, priceOracle, lossPolicy);\n        _executeMarketHooks(\n            pool,\n            abi.encodeCall(\n                IMarketFactory.onCreateMarket,\n                (pool, priceOracle, interestRateModel, rateKeeper, lossPolicy, underlyingPriceFeed)\n            )\n        );\n        emit CreateMarket(pool, priceOracle, interestRateModel, rateKeeper, lossPolicy, factories);\n    }\n\n    function shutdownMarket(address pool) external override onlyAdmin onlyRegisteredMarket(pool) {\n        _executeMarketHooks(pool, abi.encodeCall(IMarketFactory.onShutdownMarket, (pool)));\n        IContractsRegister(contractsRegister).shutdownMarket(pool);\n        emit ShutdownMarket(pool);\n    }\n\n    function addToken(address pool, address token, address priceFeed)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _executeMarketHooks(pool, abi.encodeCall(IMarketFactory.onAddToken, (pool, token, priceFeed)));\n        emit AddToken(pool, token);\n    }\n\n    function configurePool(address pool, bytes calldata data) external override onlyAdmin onlyRegisteredMarket(pool) {\n        _configure(_marketFactories[pool].poolFactory, pool, data);\n        emit ConfigurePool(pool, data);\n    }\n\n    function emergencyConfigurePool(address pool, bytes calldata data)\n        external\n        override\n        onlyEmergencyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _emergencyConfigure(_marketFactories[pool].poolFactory, pool, data);\n        emit EmergencyConfigurePool(pool, data);\n    }\n\n    function _deployPool(address factory, address underlying, string calldata name, string calldata symbol)\n        internal\n        returns (address)\n    {\n        DeployResult memory deployResult = IPoolFactory(factory).deployPool(underlying, name, symbol);\n        _executeHook(factory, deployResult.onInstallOps);\n        return deployResult.newContract;\n    }\n\n    // ----------------------- //\n    // CREDIT SUITE MANAGEMENT //\n    // ----------------------- //\n\n    function previewCreateCreditSuite(uint256 minorVersion, address pool, bytes calldata encodedParams)\n        external\n        view\n        override\n        returns (address)\n    {\n        address factory = _getLatestCreditFactory(minorVersion);\n        return ICreditFactory(factory).computeCreditManagerAddress(address(this), pool, encodedParams);\n    }\n\n    function createCreditSuite(uint256 minorVersion, address pool, bytes calldata encodedParams)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n        returns (address creditManager)\n    {\n        address factory = _getLatestCreditFactory(minorVersion);\n        creditManager = _deployCreditSuite(factory, pool, encodedParams);\n        _creditFactories[creditManager] = factory;\n\n        _registerCreditSuite(creditManager);\n        _executeMarketHooks(pool, abi.encodeCall(IMarketFactory.onCreateCreditSuite, (creditManager)));\n        emit CreateCreditSuite(creditManager, factory);\n    }\n\n    function shutdownCreditSuite(address creditManager)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredCreditSuite(creditManager)\n    {\n        address pool = ICreditManagerV3(creditManager).pool();\n        _executeMarketHooks(pool, abi.encodeCall(IMarketFactory.onShutdownCreditSuite, (creditManager)));\n        IContractsRegister(contractsRegister).shutdownCreditSuite(creditManager);\n        emit ShutdownCreditSuite(creditManager);\n    }\n\n    function configureCreditSuite(address creditManager, bytes calldata data)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredCreditSuite(creditManager)\n    {\n        _configure(_creditFactories[creditManager], creditManager, data);\n        emit ConfigureCreditSuite(creditManager, data);\n    }\n\n    function emergencyConfigureCreditSuite(address creditManager, bytes calldata data)\n        external\n        override\n        onlyEmergencyAdmin\n        onlyRegisteredCreditSuite(creditManager)\n    {\n        _emergencyConfigure(_creditFactories[creditManager], creditManager, data);\n        emit EmergencyConfigureCreditSuite(creditManager, data);\n    }\n\n    function _deployCreditSuite(address factory, address pool, bytes calldata encodedParams)\n        internal\n        returns (address)\n    {\n        DeployResult memory deployResult = ICreditFactory(factory).deployCreditSuite(pool, encodedParams);\n        _executeHook(factory, deployResult.onInstallOps);\n        return deployResult.newContract;\n    }\n\n    // ----------------------- //\n    // PRICE ORACLE MANAGEMENT //\n    // ----------------------- //\n\n    function updatePriceOracle(address pool)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n        returns (address priceOracle)\n    {\n        address oldPriceOracle = IContractsRegister(contractsRegister).getPriceOracle(pool);\n        priceOracle = _deployPriceOracle(_marketFactories[pool].priceOracleFactory, pool);\n\n        IContractsRegister(contractsRegister).setPriceOracle(pool, priceOracle);\n        _executeMarketHooks(\n            pool, abi.encodeCall(IMarketFactory.onUpdatePriceOracle, (pool, priceOracle, oldPriceOracle))\n        );\n\n        address[] memory creditManagers = _registeredCreditManagers(pool);\n        uint256 numManagers = creditManagers.length;\n        for (uint256 i; i < numManagers; ++i) {\n            address creditManager = creditManagers[i];\n            _executeHook(\n                _creditFactories[creditManager],\n                abi.encodeCall(ICreditFactory.onUpdatePriceOracle, (creditManager, priceOracle, oldPriceOracle))\n            );\n        }\n        emit UpdatePriceOracle(pool, priceOracle);\n    }\n\n    function configurePriceOracle(address pool, bytes calldata data)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _configure(_marketFactories[pool].priceOracleFactory, pool, data);\n        emit ConfigurePriceOracle(pool, data);\n    }\n\n    function emergencyConfigurePriceOracle(address pool, bytes calldata data)\n        external\n        override\n        onlyEmergencyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _emergencyConfigure(_marketFactories[pool].priceOracleFactory, pool, data);\n        emit EmergencyConfigurePriceOracle(pool, data);\n    }\n\n    function _deployPriceOracle(address factory, address pool) internal returns (address) {\n        DeployResult memory deployResult = IPriceOracleFactory(factory).deployPriceOracle(pool);\n        _executeHook(factory, deployResult.onInstallOps);\n        return deployResult.newContract;\n    }\n\n    // -------------- //\n    // IRM MANAGEMENT //\n    // -------------- //\n\n    function updateInterestRateModel(address pool, DeployParams calldata params)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n        returns (address interestRateModel)\n    {\n        address oldInterestRateModel = _interestRateModel(pool);\n        interestRateModel = _deployInterestRateModel(_marketFactories[pool].interestRateModelFactory, pool, params);\n\n        _executeMarketHooks(\n            pool,\n            abi.encodeCall(IMarketFactory.onUpdateInterestRateModel, (pool, interestRateModel, oldInterestRateModel))\n        );\n        emit UpdateInterestRateModel(pool, interestRateModel);\n    }\n\n    function configureInterestRateModel(address pool, bytes calldata data)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _configure(_marketFactories[pool].interestRateModelFactory, pool, data);\n        emit ConfigureInterestRateModel(pool, data);\n    }\n\n    function emergencyConfigureInterestRateModel(address pool, bytes calldata data)\n        external\n        override\n        onlyEmergencyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _emergencyConfigure(_marketFactories[pool].interestRateModelFactory, pool, data);\n        emit EmergencyConfigureInterestRateModel(pool, data);\n    }\n\n    function _deployInterestRateModel(address factory, address pool, DeployParams calldata params)\n        internal\n        returns (address)\n    {\n        DeployResult memory deployResult = IInterestRateModelFactory(factory).deployInterestRateModel(pool, params);\n        _executeHook(factory, deployResult.onInstallOps);\n        return deployResult.newContract;\n    }\n\n    // ---------------------- //\n    // RATE KEEPER MANAGEMENT //\n    // ---------------------- //\n\n    function updateRateKeeper(address pool, DeployParams calldata params)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n        returns (address rateKeeper)\n    {\n        address oldRateKeeper = _rateKeeper(_quotaKeeper(pool));\n        rateKeeper = _deployRateKeeper(_marketFactories[pool].rateKeeperFactory, pool, params);\n\n        _executeMarketHooks(pool, abi.encodeCall(IMarketFactory.onUpdateRateKeeper, (pool, rateKeeper, oldRateKeeper)));\n        emit UpdateRateKeeper(pool, rateKeeper);\n    }\n\n    function configureRateKeeper(address pool, bytes calldata data)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _configure(_marketFactories[pool].rateKeeperFactory, pool, data);\n        emit ConfigureRateKeeper(pool, data);\n    }\n\n    function emergencyConfigureRateKeeper(address pool, bytes calldata data)\n        external\n        override\n        onlyEmergencyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _emergencyConfigure(_marketFactories[pool].rateKeeperFactory, pool, data);\n        emit EmergencyConfigureRateKeeper(pool, data);\n    }\n\n    function _deployRateKeeper(address factory, address pool, DeployParams calldata params)\n        internal\n        returns (address)\n    {\n        DeployResult memory deployResult = IRateKeeperFactory(factory).deployRateKeeper(pool, params);\n        _executeHook(factory, deployResult.onInstallOps);\n        return deployResult.newContract;\n    }\n\n    // ---------------------- //\n    // LOSS POLICY MANAGEMENT //\n    // ---------------------- //\n\n    function updateLossPolicy(address pool, DeployParams calldata params)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n        returns (address lossPolicy)\n    {\n        address oldLossPolicy = IContractsRegister(contractsRegister).getLossPolicy(pool);\n        lossPolicy = _deployLossPolicy(_marketFactories[pool].lossPolicyFactory, pool, params);\n\n        IContractsRegister(contractsRegister).setLossPolicy(pool, lossPolicy);\n        _executeMarketHooks(pool, abi.encodeCall(IMarketFactory.onUpdateLossPolicy, (pool, lossPolicy, oldLossPolicy)));\n\n        address[] memory creditManagers = _registeredCreditManagers(pool);\n        uint256 numManagers = creditManagers.length;\n        for (uint256 i; i < numManagers; ++i) {\n            address creditManager = creditManagers[i];\n            _executeHook(\n                _creditFactories[creditManager],\n                abi.encodeCall(ICreditFactory.onUpdateLossPolicy, (creditManager, lossPolicy, oldLossPolicy))\n            );\n        }\n        emit UpdateLossPolicy(pool, lossPolicy);\n    }\n\n    function configureLossPolicy(address pool, bytes calldata data)\n        external\n        override\n        onlyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _configure(_marketFactories[pool].lossPolicyFactory, pool, data);\n        emit ConfigureLossPolicy(pool, data);\n    }\n\n    function emergencyConfigureLossPolicy(address pool, bytes calldata data)\n        external\n        override\n        onlyEmergencyAdmin\n        onlyRegisteredMarket(pool)\n    {\n        _emergencyConfigure(_marketFactories[pool].lossPolicyFactory, pool, data);\n        emit EmergencyConfigureLossPolicy(pool, data);\n    }\n\n    function _deployLossPolicy(address factory, address pool, DeployParams calldata params)\n        internal\n        returns (address)\n    {\n        DeployResult memory deployResult = ILossPolicyFactory(factory).deployLossPolicy(pool, params);\n        _executeHook(factory, deployResult.onInstallOps);\n        return deployResult.newContract;\n    }\n\n    // --------- //\n    // FACTORIES //\n    // --------- //\n\n    function getMarketFactories(address pool) external view override returns (MarketFactories memory) {\n        return _marketFactories[pool];\n    }\n\n    function getCreditFactory(address creditManager) external view override returns (address) {\n        return _creditFactories[creditManager];\n    }\n\n    function getAuthorizedFactory(address target) external view override returns (address) {\n        return _authorizedFactories[target];\n    }\n\n    function getFactoryTargets(address factory, address suite) external view override returns (address[] memory) {\n        return _factoryTargets[factory][suite].values();\n    }\n\n    function authorizeFactory(address factory, address suite, address target) external override onlySelf {\n        if (_authorizedFactories[target] != address(0)) revert UnauthorizedFactoryException(factory, target);\n        _authorizeFactory(factory, suite, target);\n    }\n\n    function unauthorizeFactory(address factory, address suite, address target) external override onlySelf {\n        if (_authorizedFactories[target] != factory) revert UnauthorizedFactoryException(factory, target);\n        _unauthorizeFactory(factory, suite, target);\n    }\n\n    function upgradePoolFactory(address pool) external override onlyAdmin {\n        address oldFactory = _marketFactories[pool].poolFactory;\n        address newFactory = _getLatestPatch(oldFactory);\n        if (newFactory == oldFactory) return;\n        _marketFactories[pool].poolFactory = newFactory;\n        _migrateFactoryTargets(oldFactory, newFactory, pool);\n        emit UpgradePoolFactory(pool, newFactory);\n    }\n\n    function upgradePriceOracleFactory(address pool) external override onlyAdmin {\n        address oldFactory = _marketFactories[pool].priceOracleFactory;\n        address newFactory = _getLatestPatch(oldFactory);\n        if (newFactory == oldFactory) return;\n        _marketFactories[pool].priceOracleFactory = newFactory;\n        _migrateFactoryTargets(oldFactory, newFactory, pool);\n        emit UpgradePriceOracleFactory(pool, newFactory);\n    }\n\n    function upgradeInterestRateModelFactory(address pool) external override onlyAdmin {\n        address oldFactory = _marketFactories[pool].interestRateModelFactory;\n        address newFactory = _getLatestPatch(oldFactory);\n        if (newFactory == oldFactory) return;\n        _marketFactories[pool].interestRateModelFactory = newFactory;\n        _migrateFactoryTargets(oldFactory, newFactory, pool);\n        emit UpgradeInterestRateModelFactory(pool, newFactory);\n    }\n\n    function upgradeRateKeeperFactory(address pool) external override onlyAdmin {\n        address oldFactory = _marketFactories[pool].rateKeeperFactory;\n        address newFactory = _getLatestPatch(oldFactory);\n        if (newFactory == oldFactory) return;\n        _marketFactories[pool].rateKeeperFactory = newFactory;\n        _migrateFactoryTargets(oldFactory, newFactory, pool);\n        emit UpgradeRateKeeperFactory(pool, newFactory);\n    }\n\n    function upgradeLossPolicyFactory(address pool) external override onlyAdmin {\n        address oldFactory = _marketFactories[pool].lossPolicyFactory;\n        address newFactory = _getLatestPatch(oldFactory);\n        if (newFactory == oldFactory) return;\n        _marketFactories[pool].lossPolicyFactory = newFactory;\n        _migrateFactoryTargets(oldFactory, newFactory, pool);\n        emit UpgradeLossPolicyFactory(pool, newFactory);\n    }\n\n    function upgradeCreditFactory(address creditManager) external override onlyAdmin {\n        address oldFactory = _creditFactories[creditManager];\n        address newFactory = _getLatestPatch(oldFactory);\n        if (newFactory == oldFactory) return;\n        _creditFactories[creditManager] = newFactory;\n        _migrateFactoryTargets(oldFactory, newFactory, creditManager);\n        emit UpgradeCreditFactory(creditManager, newFactory);\n    }\n\n    // --------- //\n    // PERIPHERY //\n    // --------- //\n\n    function getPeripheryContracts(bytes32 domain) external view override returns (address[] memory) {\n        return _peripheryContracts[domain].values();\n    }\n\n    function isPeripheryContract(bytes32 domain, address peripheryContract) external view override returns (bool) {\n        return _peripheryContracts[domain].contains(peripheryContract);\n    }\n\n    function addPeripheryContract(address peripheryContract) external override onlyAdmin {\n        if (IBytecodeRepository(bytecodeRepository).deployedContracts(peripheryContract) == 0) {\n            revert IncorrectPeripheryContractException(peripheryContract);\n        }\n        bytes32 domain = _getDomain(peripheryContract);\n        if (_peripheryContracts[domain].add(peripheryContract)) {\n            emit AddPeripheryContract(domain, peripheryContract);\n        }\n    }\n\n    function removePeripheryContract(address peripheryContract) external override onlyAdmin {\n        bytes32 domain = _getDomain(peripheryContract);\n        if (_peripheryContracts[domain].remove(peripheryContract)) {\n            emit RemovePeripheryContract(domain, peripheryContract);\n        }\n    }\n\n    function _getDomain(address peripheryContract) internal view returns (bytes32) {\n        try IVersion(peripheryContract).contractType() returns (bytes32 type_) {\n            return Domain.extractDomain(type_);\n        } catch {\n            revert IncorrectPeripheryContractException(peripheryContract);\n        }\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    function _ensureCallerIsSelf() internal view {\n        if (msg.sender != address(this)) revert CallerIsNotSelfException(msg.sender);\n    }\n\n    function _ensureCallerIsAdmin() internal view {\n        if (msg.sender != admin) revert CallerIsNotAdminException(msg.sender);\n    }\n\n    function _ensureCallerIsEmergencyAdmin() internal view {\n        if (msg.sender != emergencyAdmin) revert CallerIsNotEmergencyAdminException(msg.sender);\n    }\n\n    function _ensureRegisteredMarket(address pool) internal view {\n        if (!IContractsRegister(contractsRegister).isPool(pool)) {\n            revert MarketNotRegisteredException(pool);\n        }\n    }\n\n    function _ensureRegisteredCreditSuite(address creditManager) internal view {\n        if (!IContractsRegister(contractsRegister).isCreditManager(creditManager)) {\n            revert CreditSuiteNotRegisteredException(creditManager);\n        }\n    }\n\n    /// @dev `MarketConfiguratorLegacy` performs additional actions, hence the `virtual` modifier\n    function _grantRole(bytes32 role, address account) internal virtual {\n        IACL(acl).grantRole(role, account);\n    }\n\n    /// @dev `MarketConfiguratorLegacy` performs additional actions, hence the `virtual` modifier\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        IACL(acl).revokeRole(role, account);\n    }\n\n    /// @dev `MarketConfiguratorLegacy` performs additional actions, hence the `virtual` modifier\n    function _registerMarket(address pool, address priceOracle, address lossPolicy) internal virtual {\n        IContractsRegister(contractsRegister).registerMarket(pool, priceOracle, lossPolicy);\n    }\n\n    /// @dev `MarketConfiguratorLegacy` performs additional actions, hence the `virtual` modifier\n    function _registerCreditSuite(address creditManager) internal virtual {\n        IContractsRegister(contractsRegister).registerCreditSuite(creditManager);\n    }\n\n    /// @dev `MarketConfiguratorLegacy` performs additional checks, hence the `virtual` modifier\n    function _validateCallTarget(address target, address factory) internal virtual {\n        if (target != address(this) && _authorizedFactories[target] != factory) {\n            revert UnauthorizedFactoryException(factory, target);\n        }\n    }\n\n    function _getLatestPatch(bytes32 key, uint256 minorVersion) internal view returns (address) {\n        return _getAddressOrRevert(\n            key, IAddressProvider(addressProvider).getLatestPatchVersion(key.fromSmallString(), minorVersion)\n        );\n    }\n\n    function _getLatestPatch(address factory) internal view returns (address) {\n        return _getLatestPatch(IVersion(factory).contractType(), IVersion(factory).version());\n    }\n\n    function _getLatestMarketFactories(uint256 minorVersion) internal view returns (MarketFactories memory) {\n        return MarketFactories({\n            poolFactory: _getLatestPatch(AP_POOL_FACTORY, minorVersion),\n            priceOracleFactory: _getLatestPatch(AP_PRICE_ORACLE_FACTORY, minorVersion),\n            interestRateModelFactory: _getLatestPatch(AP_INTEREST_RATE_MODEL_FACTORY, minorVersion),\n            rateKeeperFactory: _getLatestPatch(AP_RATE_KEEPER_FACTORY, minorVersion),\n            lossPolicyFactory: _getLatestPatch(AP_LOSS_POLICY_FACTORY, minorVersion)\n        });\n    }\n\n    function _getLatestCreditFactory(uint256 minorVersion) internal view returns (address) {\n        return _getLatestPatch(AP_CREDIT_FACTORY, minorVersion);\n    }\n\n    function _authorizeFactory(address factory, address suite, address target) internal {\n        _authorizedFactories[target] = factory;\n        _factoryTargets[factory][suite].add(target);\n        emit AuthorizeFactory(factory, suite, target);\n    }\n\n    function _unauthorizeFactory(address factory, address suite, address target) internal {\n        _authorizedFactories[target] = address(0);\n        _factoryTargets[factory][suite].remove(target);\n        emit UnauthorizeFactory(factory, suite, target);\n    }\n\n    function _migrateFactoryTargets(address oldFactory, address newFactory, address suite) internal {\n        EnumerableSet.AddressSet storage targets = _factoryTargets[oldFactory][suite];\n        uint256 numTargets = targets.length();\n        for (uint256 i; i < numTargets; ++i) {\n            address target = targets.at(i);\n            targets.remove(target);\n            _factoryTargets[newFactory][suite].add(target);\n            _authorizedFactories[target] = newFactory;\n            emit UnauthorizeFactory(oldFactory, suite, target);\n            emit AuthorizeFactory(newFactory, suite, target);\n        }\n    }\n\n    function _executeMarketHooks(address pool, bytes memory data) internal {\n        MarketFactories memory factories = _marketFactories[pool];\n        _executeHook(factories.poolFactory, data);\n        _executeHook(factories.priceOracleFactory, data);\n        _executeHook(factories.interestRateModelFactory, data);\n        _executeHook(factories.rateKeeperFactory, data);\n        _executeHook(factories.lossPolicyFactory, data);\n    }\n\n    function _executeHook(address factory, bytes memory data) internal {\n        _executeHook(factory, abi.decode(factory.functionCall(data), (Call[])));\n    }\n\n    function _configure(address factory, address target, bytes calldata callData) internal {\n        _executeHook(factory, IFactory(factory).configure(target, callData));\n    }\n\n    function _emergencyConfigure(address factory, address target, bytes calldata callData) internal {\n        _executeHook(factory, IFactory(factory).emergencyConfigure(target, callData));\n    }\n\n    function _executeHook(address factory, Call[] memory calls) internal {\n        uint256 len = calls.length;\n        for (uint256 i; i < len; ++i) {\n            address target = calls[i].target;\n            bytes memory callData = calls[i].callData;\n            _validateCallTarget(target, factory);\n            target.functionCall(callData);\n            emit ExecuteHook(target, callData);\n        }\n    }\n\n    function _registeredCreditManagers() internal view returns (address[] memory) {\n        return IContractsRegister(contractsRegister).getCreditManagers();\n    }\n\n    function _registeredCreditManagers(address pool) internal view returns (address[] memory creditManagers) {\n        return IContractsRegister(contractsRegister).getCreditManagers(pool);\n    }\n\n    function _quotaKeeper(address pool) internal view returns (address) {\n        return IPoolV3(pool).poolQuotaKeeper();\n    }\n\n    function _interestRateModel(address pool) internal view returns (address) {\n        return IPoolV3(pool).interestRateModel();\n    }\n\n    function _rateKeeper(address quotaKeeper) internal view returns (address) {\n        return IPoolQuotaKeeperV3(quotaKeeper).gauge();\n    }\n}\n"
    }
}