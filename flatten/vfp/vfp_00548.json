{
    "vfp_id": "vfp_00548",
    "project_name": "Across Audit.md",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Attempts to Bridge WETH Using ZkStack_CustomGasToken_Adapter Will Fail",
            "description": "When attempting to bridge WETH using the `ZkStack_CustomGasToken_Adapter`, the `relayTokens` function sends a non-zero deposit amount to the `bridgeHubDeposit` function, which explicitly requires the amount to be zero when bridging ETH. This mismatch causes the transaction to revert, preventing WETH from being successfully bridged to L2. The root cause is a logic error in the adapter where the amount is not set to zero for ETH deposits, violating the requirement of the target bridge contract. This issue prevents users from transferring WETH to ZkStack chains, resulting in a denial of service for WETH bridging functionality.\n",
            "severity": "Low",
            "location": [
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#141",
                "BridgeHub::bridgeHubDeposit#L291",
                "L1SharedBridge.sol::bridgeHubDeposit#328"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Transfers of The Target Chain's Gas Token Will Fail",
            "description": "The `relayTokens` function in both `ZkStack_Adapter` and `ZkStack_CustomGasToken_Adapter` contracts fails when transferring the target chain's gas token due to a mismatch between `msg.value` and `mintValue` in the `requestL2TransactionDirect` call. The `mintValue` is only set to `txBaseCost`, while `msg.value` includes both `txBaseCost` and `amount`, causing the transaction to revert. Additionally, `l2Value` is hardcoded to 0, so no value is delivered to the L2 contract. The root cause is incorrect parameter assignment in the bridging logic. This results in a complete failure of ETH or custom gas token transfers to ZkStack chains, leading to a denial of service for native token bridging.\n",
            "severity": "Low",
            "location": [
                "ZkStack_Adapter.sol::relayTokens#109-122",
                "ZkStack_Adapter.sol::requestL2TransactionDirect#132",
                "BridgeHub::requestL2TransactionDirect#222",
                "ZkStack_CustomGasToken_Adapter.sol::relayTokens#176"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_Adapter.sol",
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Potentially Mutable Variable Treated as Immutable",
            "description": "The `ZkStack_Adapter` and `ZkStack_CustomGasToken_Adapter` contracts approve tokens to the `SHARED_BRIDGE` address, which is a hardcoded constant, but the actual bridge used is `BRIDGE_HUB.sharedBridge()`, a mutable variable. If the `sharedBridge` address changes, the allowance will be invalid, and token bridging will fail. The root cause is treating a potentially mutable address as immutable. This creates a single point of failure where a bridge upgrade would break all existing adapters. The impact is a denial of service for token bridging until adapters are redeployed with updated constants.\n",
            "severity": "Low",
            "location": [
                "ZkStack_Adapter.sol::SHARED_BRIDGE",
                "ZkStack_Adapter.sol::requestL2TransactionTwoBridges#148-160",
                "Bridgehub::requestL2TransactionTwoBridges#290",
                "L1SharedBridge.sol::bridgehubDeposit#295"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_Adapter.sol",
                "contracts/contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Griefing Attacks Are Possible in ZK Adapters",
            "description": "A malicious user can manipulate the `tx.gasprice` parameter during a transaction to inflate the estimated L2 transaction cost, causing the HubPool to transfer excessive ETH to the L2 network. The root cause is the direct use of `tx.gasprice` in the `_computeETHTxCost` function without any upper limit, making it susceptible to manipulation by validators who can profit from inflated fees. An attacker can invoke the `executeRootBundle` function, triggering the `relayMessage` call in the adapter, which uses the manipulated gas price to calculate costs. This leads to a loss of funds from the HubPool as ETH is transferred to L2 based on the inflated estimate, enabling griefing attacks.\n",
            "severity": "High",
            "location": [
                "ZkStack_Adapter.sol::_computeETHTxCost#188",
                "ZkStack_Adapter.sol::relayMessage#91",
                "HubPool.sol::executeRootBundle#620",
                "ZkStack_CustomGasToken_Adapter.sol::_pullCustomGas#36"
            ],
            "files": [
                "contracts/contracts/chain-adapters/ZkStack_Adapter.sol"
            ]
        }
    ],
    "affected_files": {
        "ZkStack_CustomGasToken_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with a custom gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_CustomGasToken_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://era.zksync.io/docs/dev/developer-guides/bridging/l1-l2.html#getting-the-base-cost\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // SharedBridge address, which is read from the BridgeHub at construction.\n    address public immutable SHARED_BRIDGE;\n\n    // Custom gas token address, which is read from the BridgeHub at construction.\n    address public immutable CUSTOM_GAS_TOKEN;\n\n    // Custom gas token funder\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    event ZkStackMessageRelayed(bytes32 canonicalTxHash);\n    error ETHGasTokenNotAllowed();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit\n    ) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        L2_GAS_LIMIT = _l2GasLimit;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        SHARED_BRIDGE = BRIDGE_HUB.sharedBridge();\n        CUSTOM_GAS_TOKEN = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (CUSTOM_GAS_TOKEN == address(1)) {\n            revert ETHGasTokenNotAllowed();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        IERC20(CUSTOM_GAS_TOKEN).safeIncreaseAllowance(SHARED_BRIDGE, txBaseCost);\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = BRIDGE_HUB.requestL2TransactionDirect(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkStackMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost of custom gas tokens.\n            L1_WETH.withdraw(amount);\n            IERC20(CUSTOM_GAS_TOKEN).safeIncreaseAllowance(SHARED_BRIDGE, txBaseCost);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: amount }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: BRIDGE_HUB.sharedBridge(),\n                    secondBridgeValue: amount,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, address(1), amount)\n                })\n            );\n        } else if (l1Token == CUSTOM_GAS_TOKEN) {\n            // The chain's custom gas token.\n            IERC20(l1Token).safeIncreaseAllowance(SHARED_BRIDGE, txBaseCost + amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Contract: to,\n                    l2Value: 0,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else {\n            // An ERC20 that is not WETH and not the custom gas token.\n            IERC20(CUSTOM_GAS_TOKEN).safeIncreaseAllowance(SHARED_BRIDGE, txBaseCost);\n            IERC20(l1Token).safeIncreaseAllowance(SHARED_BRIDGE, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: BRIDGE_HUB.sharedBridge(),\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkStackMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of tokens needed, pulls them from the funder, and\n     * returns the amount.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _pullCustomGas(uint256 l2GasLimit) internal returns (uint256) {\n        uint256 cost = BRIDGE_HUB.l2TransactionBaseCost(\n            CHAIN_ID,\n            tx.gasprice,\n            l2GasLimit,\n            L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT\n        );\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(IERC20(CUSTOM_GAS_TOKEN), cost);\n\n        return cost;\n    }\n}\n",
        "ZkStack_Adapter.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with ETH as the gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://era.zksync.io/docs/dev/developer-guides/bridging/l1-l2.html#getting-the-base-cost\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // SharedBridge address, which is read from the BridgeHub at construction.\n    address public immutable SHARED_BRIDGE;\n\n    event ZkStackMessageRelayed(bytes32 canonicalTxHash);\n    error ETHGasTokenRequired();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit\n    ) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        L2_GAS_LIMIT = _l2GasLimit;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        SHARED_BRIDGE = BRIDGE_HUB.sharedBridge();\n        address gasToken = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (gasToken != address(1)) {\n            revert ETHGasTokenRequired();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = BRIDGE_HUB.requestL2TransactionDirect{ value: txBaseCost }(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkStackMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost.\n            L1_WETH.withdraw(amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect{ value: amount + txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Contract: to,\n                    l2Value: 0,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else {\n            // An ERC20 that is not WETH.\n            IERC20(l1Token).safeIncreaseAllowance(SHARED_BRIDGE, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: BRIDGE_HUB.sharedBridge(),\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkStackMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of ETH needed and\n     * returns the amount.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _computeETHTxCost(uint256 l2GasLimit) internal view returns (uint256) {\n        return BRIDGE_HUB.l2TransactionBaseCost(CHAIN_ID, tx.gasprice, l2GasLimit, L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT);\n    }\n}\n"
    }
}