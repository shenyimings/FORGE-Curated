{
    "vfp_id": "vfp_00286",
    "project_name": "ChainSecurity_Liquity_Bold_Audit.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect Code Comments",
            "description": "The code contains outdated, inaccurate, or misleading comments and natspec documentation across several functions and contracts. For example, references to the deprecated \"composite debt\" concept from Liquity V1 persist in V2, where gas compensation is now handled in WETH. Additionally, some comments describe logic that no longer applies, such as redemption order based on collateral ratio when it is now based on interest rate.\n\nThe cause is that the comments were not updated during the transition from Liquity V1 to V2 or during subsequent logic changes. Some are the result of copy-paste from older versions or incomplete refactoring.\n\nWhile the code itself is correct, misleading comments could lead developers or auditors to misunderstand the system's behavior, potentially introducing bugs during future maintenance or upgrades.\n\nThe primary impact is reduced code maintainability and increased risk of human error during development or auditing. Although the runtime behavior is unaffected, incorrect documentation may lead to incorrect assumptions and future vulnerabilities.\n",
            "severity": "Low",
            "location": [
                "ActivePool._mintBatchManagementFeeAndAccountForChange",
                "BorrowerOperations._openTrove",
                "BorrowerOperations._applyUpfrontFee",
                "TroveManager.redeemCollateral",
                "LiquityMath._decPow",
                "StabilityPool.sortedTroves",
                "TroveManager.Batch",
                "MainnetPriceFeedBase.priceFeedDisabled",
                "TroveManager._urgentRedeemCollateralFromTrove",
                "BorrowerOperations.adjustUnredeemableTrove"
            ],
            "files": [
                "bold/contracts/src/ActivePool.sol"
            ]
        }
    ],
    "affected_files": {
        "ActivePool.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"./Dependencies/Constants.sol\";\nimport \"./Interfaces/IActivePool.sol\";\nimport \"./Interfaces/IAddressesRegistry.sol\";\nimport \"./Interfaces/IBoldToken.sol\";\nimport \"./Interfaces/IInterestRouter.sol\";\nimport \"./Interfaces/IDefaultPool.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n * The Active Pool holds the collateral and Bold debt (but not Bold tokens) for all active troves.\n *\n * When a trove is liquidated, it's Coll and Bold debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is IActivePool {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"ActivePool\";\n\n    IERC20 public immutable collToken;\n    address public immutable borrowerOperationsAddress;\n    address public immutable troveManagerAddress;\n    address public immutable defaultPoolAddress;\n\n    IBoldToken boldToken;\n\n    IInterestRouter public interestRouter;\n    IBoldRewardsReceiver public stabilityPool;\n\n    uint256 internal collBalance; // deposited ether tracker\n\n    // Aggregate recorded debt tracker. Updated whenever a Trove's debt is touched AND whenever the aggregate pending interest is minted.\n    // \"D\" in the spec.\n    uint256 public aggRecordedDebt;\n\n    /* Sum of individual recorded Trove debts weighted by their respective chosen interest rates.\n    * Updated at individual Trove operations.\n    * \"S\" in the spec.\n    */\n    uint256 public aggWeightedDebtSum;\n\n    // Last time at which the aggregate recorded debt and weighted sum were updated\n    uint256 public lastAggUpdateTime;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    // Aggregate batch fees tracker\n    uint256 public aggBatchManagementFees;\n    /* Sum of individual recorded Trove debts weighted by their respective batch management fees\n     * Updated at individual batched Trove operations.\n     */\n    uint256 public aggWeightedBatchManagementFeeSum;\n    // Last time at which the aggregate batch fees and weighted sum were updated\n    uint256 public lastAggBatchManagementFeesUpdateTime;\n\n    // --- Events ---\n\n    event CollTokenAddressChanged(address _newCollTokenAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event EtherSent(address _to, uint256 _amount);\n    event ActivePoolBoldDebtUpdated(uint256 _recordedDebtSum);\n    event ActivePoolCollBalanceUpdated(uint256 _collBalance);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());\n        troveManagerAddress = address(_addressesRegistry.troveManager());\n        stabilityPool = IBoldRewardsReceiver(_addressesRegistry.stabilityPool());\n        defaultPoolAddress = address(_addressesRegistry.defaultPool());\n        interestRouter = _addressesRegistry.interestRouter();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit CollTokenAddressChanged(address(collToken));\n        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(troveManagerAddress);\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit DefaultPoolAddressChanged(defaultPoolAddress);\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(defaultPoolAddress, type(uint256).max);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the Coll state variable.\n    *\n    *Not necessarily equal to the the contract's raw Coll balance - ether can be forcibly sent to contracts.\n    */\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function calcPendingAggInterest() public view returns (uint256) {\n        if (shutdownTime != 0) return 0;\n\n        // We use the ceiling of the division here to ensure positive error, while we use regular floor division\n        // when calculating the interest accrued by individual Troves.\n        // This ensures that `system debt >= sum(trove debt)` always holds, and thus system debt won't turn negative\n        // even if all Trove debt is repaid. The difference should be small and it should scale with the number of\n        // interest minting events.\n        return Math.ceilDiv(aggWeightedDebtSum * (block.timestamp - lastAggUpdateTime), ONE_YEAR * DECIMAL_PRECISION);\n    }\n\n    function calcPendingSPYield() external view returns (uint256) {\n        return calcPendingAggInterest() * SP_YIELD_SPLIT / DECIMAL_PRECISION;\n    }\n\n    function calcPendingAggBatchManagementFee() public view returns (uint256) {\n        uint256 periodEnd = shutdownTime != 0 ? shutdownTime : block.timestamp;\n        uint256 periodStart = Math.min(lastAggBatchManagementFeesUpdateTime, periodEnd);\n\n        return Math.ceilDiv(aggWeightedBatchManagementFeeSum * (periodEnd - periodStart), ONE_YEAR * DECIMAL_PRECISION);\n    }\n\n    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)\n        external\n        view\n        returns (uint256)\n    {\n        // We are ignoring the upfront fee when calculating the approx. avg. interest rate.\n        // This is a simple way to resolve the circularity in:\n        //   fee depends on avg. interest rate -> avg. interest rate is weighted by debt -> debt includes fee -> ...\n        assert(_troveChange.upfrontFee == 0);\n\n        if (shutdownTime != 0) return 0;\n\n        uint256 newAggRecordedDebt = aggRecordedDebt;\n        newAggRecordedDebt += calcPendingAggInterest();\n        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;\n        newAggRecordedDebt += _troveChange.debtIncrease;\n        newAggRecordedDebt += _troveChange.batchAccruedManagementFee;\n        newAggRecordedDebt -= _troveChange.debtDecrease;\n\n        uint256 newAggWeightedDebtSum = aggWeightedDebtSum;\n        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;\n        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;\n\n        // Avoid division by 0 if the first ever borrower tries to borrow 0 BOLD\n        // Borrowing 0 BOLD is not allowed, but our check of debt >= MIN_DEBT happens _after_ calculating the upfront\n        // fee, which involves getting the new approx. avg. interest rate\n        return newAggRecordedDebt > 0 ? newAggWeightedDebtSum / newAggRecordedDebt : 0;\n    }\n\n    // Returns sum of agg.recorded debt plus agg. pending interest. Excludes pending redist. gains.\n    function getBoldDebt() external view returns (uint256) {\n        return aggRecordedDebt + calcPendingAggInterest() + aggBatchManagementFees + calcPendingAggBatchManagementFee();\n    }\n\n    // --- Pool functionality ---\n\n    function sendColl(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n\n        _accountForSendColl(_account, _amount);\n\n        collToken.safeTransfer(_account, _amount);\n    }\n\n    function sendCollToDefaultPool(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n\n        _accountForSendColl(defaultPoolAddress, _amount);\n\n        IDefaultPool(defaultPoolAddress).receiveColl(_amount);\n    }\n\n    function _accountForSendColl(address _account, uint256 _amount) internal {\n        uint256 newCollBalance = collBalance - _amount;\n        collBalance = newCollBalance;\n        emit ActivePoolCollBalanceUpdated(newCollBalance);\n        emit EtherSent(_account, _amount);\n    }\n\n    function receiveColl(uint256 _amount) external {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n\n        _accountForReceivedColl(_amount);\n\n        // Pull Coll tokens from sender\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function accountForReceivedColl(uint256 _amount) public {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n\n        _accountForReceivedColl(_amount);\n    }\n\n    function _accountForReceivedColl(uint256 _amount) internal {\n        uint256 newCollBalance = collBalance + _amount;\n        collBalance = newCollBalance;\n\n        emit ActivePoolCollBalanceUpdated(newCollBalance);\n    }\n\n    // --- Aggregate interest operations ---\n\n    // This function is called inside all state-changing user ops: borrower ops, liquidations, redemptions and SP deposits/withdrawals.\n    // Some user ops trigger debt changes to Trove(s), in which case _troveDebtChange will be non-zero.\n    // The aggregate recorded debt is incremented by the aggregate pending interest, plus the net Trove debt change.\n    // The net Trove debt change consists of the sum of a) any debt issued/repaid and b) any redistribution debt gain applied in the encapsulating operation.\n    // It does *not* include the Trove's individual accrued interest - this gets accounted for in the aggregate accrued interest.\n    // The net Trove debt change could be positive or negative in a repayment (depending on whether its redistribution gain or repayment amount is larger),\n    // so this function accepts both the increase and the decrease to avoid using (and converting to/from) signed ints.\n    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchAddress)\n        external\n    {\n        _requireCallerIsBOorTroveM();\n\n        // Batch management fees\n        if (_batchAddress != address(0)) {\n            _mintBatchManagementFeeAndAccountForChange(boldToken, _troveChange, _batchAddress);\n        }\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggRecordedDebt = aggRecordedDebt; // 1 SLOAD\n        newAggRecordedDebt += _mintAggInterest(boldToken, _troveChange.upfrontFee); // adds minted agg. interest + upfront fee\n        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;\n        newAggRecordedDebt += _troveChange.debtIncrease;\n        newAggRecordedDebt -= _troveChange.debtDecrease;\n        aggRecordedDebt = newAggRecordedDebt; // 1 SSTORE\n\n        // assert(aggRecordedDebt >= 0) // This should never be negative. If all redistribution gians and all aggregate interest was applied\n        // and all Trove debts were repaid, it should become 0.\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggWeightedDebtSum = aggWeightedDebtSum; // 1 SLOAD\n        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;\n        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;\n        aggWeightedDebtSum = newAggWeightedDebtSum; // 1 SSTORE\n    }\n\n    function mintAggInterest() external override {\n        _requireCallerIsBOorSP();\n        aggRecordedDebt += _mintAggInterest(boldToken, 0);\n    }\n\n    function _mintAggInterest(IBoldToken _boldToken, uint256 _upfrontFee) internal returns (uint256 mintedAmount) {\n        mintedAmount = calcPendingAggInterest() + _upfrontFee;\n\n        // Mint part of the BOLD interest to the SP and part to the router for LPs.\n        if (mintedAmount > 0) {\n            uint256 spYield = SP_YIELD_SPLIT * mintedAmount / DECIMAL_PRECISION;\n            uint256 remainderToLPs = mintedAmount - spYield;\n\n            _boldToken.mint(address(interestRouter), remainderToLPs);\n            _boldToken.mint(address(stabilityPool), spYield);\n\n            stabilityPool.triggerBoldRewards(spYield);\n        }\n\n        lastAggUpdateTime = block.timestamp;\n    }\n\n    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)\n        external\n        override\n    {\n        _requireCallerIsBOorTroveM();\n        _mintBatchManagementFeeAndAccountForChange(boldToken, _troveChange, _batchAddress);\n    }\n\n    function _mintBatchManagementFeeAndAccountForChange(\n        IBoldToken _boldToken,\n        TroveChange memory _troveChange,\n        address _batchAddress\n    ) internal {\n        aggRecordedDebt += _troveChange.batchAccruedManagementFee;\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggBatchManagementFees = aggBatchManagementFees; // 1 SLOAD\n        newAggBatchManagementFees += calcPendingAggBatchManagementFee();\n        newAggBatchManagementFees -= _troveChange.batchAccruedManagementFee;\n        aggBatchManagementFees = newAggBatchManagementFees; // 1 SSTORE\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggWeightedBatchManagementFeeSum = aggWeightedBatchManagementFeeSum; // 1 SLOAD\n        newAggWeightedBatchManagementFeeSum += _troveChange.newWeightedRecordedBatchManagementFee;\n        newAggWeightedBatchManagementFeeSum -= _troveChange.oldWeightedRecordedBatchManagementFee;\n        aggWeightedBatchManagementFeeSum = newAggWeightedBatchManagementFeeSum; // 1 SSTORE\n\n        // mint fee to batch address\n        if (_troveChange.batchAccruedManagementFee > 0) {\n            _boldToken.mint(_batchAddress, _troveChange.batchAccruedManagementFee);\n        }\n\n        lastAggBatchManagementFeesUpdateTime = block.timestamp;\n    }\n\n    // --- Shutdown ---\n\n    function setShutdownFlag() external {\n        _requireCallerIsTroveManager();\n        shutdownTime = block.timestamp;\n    }\n\n    function hasBeenShutDown() external view returns (bool) {\n        return shutdownTime != 0;\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress\n                || msg.sender == address(stabilityPool),\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == address(stabilityPool),\n            \"ActivePool: Caller is not BorrowerOperations nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"ActivePool: Caller is not TroveManager\");\n    }\n}\n"
    }
}