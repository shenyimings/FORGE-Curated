{
    "vfp_id": "vfp_00286",
    "project_name": "blocksec_BedRock_BR-Token_v1.0-signed.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "Missing Initialization of Critical Variables in Constructor",
            "description": "The contract BR does not initialize the FREEZER_ROLE role or the freezeToRecipient variable in its constructor, despite their importance in controlling the freeze mechanism to curb illicit fund flows. This omission could lead to a situation where the freeze functionality is not properly set up at deployment, rendering it ineffective until manually configured later. The cause is the lack of explicit initialization in the constructor code. An attacker could potentially exploit the delay between contract deployment and role assignment to perform unauthorized actions if the system relies on immediate freeze capability. The impact includes reduced security guarantees and potential failure of the freeze mechanism during a critical window.\n",
            "severity": null,
            "location": [
                "BR.sol::constructor#13-18"
            ],
            "files": [
                "BR/contracts/BR.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing Input Validation for Empty Arrays in freezeUsers and unfreezeUsers",
            "description": "The freezeUsers() and unfreezeUsers() functions do not validate whether the input 'users' array has a non-zero length before proceeding. As a result, these functions can emit UsersFrozen or UsersUnfrozen events even when no users are provided, which may lead to unexpected behavior in off-chain event processors or frontends that assume emitted events correspond to actual state changes. The root cause is the absence of a precondition check on users.length. While this does not directly enable malicious exploitation, it introduces inconsistency in event semantics. The impact is limited to potential confusion or errors in external systems relying on accurate event logging.\n",
            "severity": null,
            "location": [
                "BR.sol::unfreezeUsers#81-86"
            ],
            "files": [
                "BR/contracts/BR.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Lack of Sender Validation in batchTransfer Function",
            "description": "The batchTransfer() function does not validate whether the _msgSender() is frozen before entering the loop that calls _transfer(). If the sender is frozen, each call to _transfer() will revert unless the recipient is the designated freezeToRecipient, causing the entire transaction to fail after partial execution (if any transfers succeeded before the revert). This leads to a poor user experience and wasted gas. The root cause is the absence of a pre-check for the sender's frozen status. An attacker could potentially trigger repeated failed transactions from a frozen account, leading to gas waste. The impact includes inefficient execution and potential denial-of-service through gas exhaustion for frozen accounts attempting batch transfers.\n",
            "severity": null,
            "location": [
                "BR.sol::batchTransfer#102-109"
            ],
            "files": [
                "BR/contracts/BR.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ]
            },
            "title": "Potential Centralization Risk from Privileged Roles",
            "description": "The contract employs privileged roles such as MINTER_ROLE and FREEZER_ROLE, which allow specific addresses to mint tokens or freeze/unfreeze user accounts. This creates a centralization risk, as compromise of the private key controlling these roles could enable an attacker to mint unlimited tokens or freeze arbitrary users, leading to significant financial loss or disruption. The cause is the reliance on centralized control mechanisms without proposed mitigations like multi-signature wallets or timelocks. If exploited, the impact could be severe, including total loss of trust and value in the token system. This is a design-level risk rather than a code-level vulnerability.\n",
            "severity": null,
            "location": [],
            "files": [
                "BR/contracts/BR.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Unmodified Burning Feature Allows Frozen Users to Burn Tokens",
            "description": "The BR contract inherits the burn functionality from ERC20Burnable without restrictions, meaning even frozen users can burn their own tokens. While burning reduces the total supply, this behavior may introduce unintended consequences in future business logic that depends on accurate tracking of frozen balances versus total supply. The root cause is the lack of override logic to disable burning for frozen accounts. An attacker who controls a frozen account could manipulate supply-based calculations by selectively burning tokens. The impact is currently low but could become significant if future features rely on invariant assumptions about frozen balances or total supply.\n",
            "severity": null,
            "location": [],
            "files": [
                "BR/contracts/BR.sol"
            ]
        }
    ],
    "affected_files": {
        "BR.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Bedrock is ERC20Burnable, AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant FREEZER_ROLE = keccak256(\"FREEZER_ROLE\");\n    address public freezeToRecipient;\n    mapping(address => bool) public frozenUsers;\n\n    constructor(address defaultAdmin, address minter) ERC20(\"Bedrock\", \"BR\") {\n        require(defaultAdmin != address(0), \"SYS001\");\n        require(minter != address(0), \"SYS001\");\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(MINTER_ROLE, minter);\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    /**\n     * ======================================================================================\n     *\n     * Internal Override FUNCTIONS\n     *\n     * ======================================================================================\n     */\n\n    /**\n     * @dev Override _transfer function to check if sender is frozen.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        if (frozenUsers[sender]) {\n            require(recipient == freezeToRecipient, \"USR016\");\n        }\n        super._transfer(sender, recipient, amount);\n    }\n\n    /**\n     * ======================================================================================\n     *\n     * ADMIN FUNCTIONS\n     *\n     * ======================================================================================\n     */\n\n    /**\n     * @dev set freezeToRecipient using for frozen users\n     * @param recipient address to set as freezeToRecipient\n     */\n    function setFreezeToRecipient(address recipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        freezeToRecipient = recipient;\n    }\n\n    /**\n     * ======================================================================================\n     *\n     *  FREEZER ROLE FUNCTIONS\n     *\n     * ======================================================================================\n     */\n\n    /**\n     * @dev Set users to be frozen, and they can only transfer to freezeToRecipient.\n     * @param users Array of users to be frozen.\n     */\n    function freezeUsers(address[] memory users) public onlyRole(FREEZER_ROLE) {\n        for (uint256 i = 0; i < users.length; ++i) {\n            frozenUsers[users[i]] = true;\n        }\n        emit UsersFrozen(users);\n    }\n\n    /**\n     * @dev Set users to be unfrozen, and they can transfer to any address.\n     * @param users Array of users to be unfrozen.\n     */\n    function unfreezeUsers(address[] memory users) public onlyRole(FREEZER_ROLE) {\n        for (uint256 i = 0; i < users.length; ++i) {\n            frozenUsers[users[i]] = false;\n        }\n        emit UsersUnfrozen(users);\n    }\n\n    /**\n     * ======================================================================================\n     *\n     * External FUNCTIONS\n     *\n     * ======================================================================================\n     */\n\n    /**\n     * @dev Batch transfer amount to recipient.\n     * @notice That excessive gas consumption causes transaction revert.\n     * @param recipients Array of recipients.\n     * @param amounts Array of amounts for recipients.\n     */\n    function batchTransfer(address[] memory recipients, uint256[] memory amounts) external {\n        require(recipients.length > 0, \"USR001\");\n        require(recipients.length == amounts.length, \"USR002\");\n\n        for (uint256 i = 0; i < recipients.length; ++i) {\n            _transfer(_msgSender(), recipients[i], amounts[i]);\n        }\n    }\n\n    /**\n     * ======================================================================================\n     *\n     * EVENTS\n     *\n     * ======================================================================================\n     */\n\n    ///@notice This event is emitted when users are frozen.\n    event UsersFrozen(address[] users);\n\n    ///@notice This event is emitted when users are unfrozen.\n    event UsersUnfrozen(address[] users);\n}\n"
    }
}