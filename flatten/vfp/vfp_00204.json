{
    "vfp_id": "vfp_00204",
    "project_name": "EVM Emulator and Semi-abstracted Nonces Update Audit.md",
    "findings": [
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Lack of Input Validation",
            "description": "The `increaseMinNonce` function in `NonceHolder.sol` accepts a `_value` parameter without validating that it is greater than zero. This allows callers to pass zero, which would result in no change to the nonce but consume gas.\n\nThe cause is missing input validation logic, which violates secure coding practices that require all user inputs to be checked for validity.\n\nAn attacker could exploit this by calling `increaseMinNonce(0)` repeatedly to waste gas or disrupt expected behavior, although no direct fund loss occurs.\n\nThe impact is inefficient gas usage and potential for denial-of-service-like behavior through unnecessary transactions, reducing system efficiency.\n",
            "severity": "Low",
            "location": [
                "NonceHolder.sol::increaseMinNonce#82"
            ],
            "files": [
                "era-contracts/system-contracts/contracts/NonceHolder.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Implicit Casting",
            "description": "In the `_combineKeyedNonce` function, a `uint64` value (`nonceValue`) is implicitly cast to `uint256`, which can lead to confusion and potential bugs if type expectations change.\nThe root cause is the lack of explicit type casting, relying on the compiler to handle the conversion, which reduces code clarity.\nWhile this is currently safe, it could introduce vulnerabilities in future updates if the context changes and the implicit behavior is misunderstood.\nThe impact is primarily on code maintainability and safety, increasing the risk of subtle bugs during future development or refactoring.\n",
            "severity": "Low",
            "location": [
                "NonceHolder.sol::_combineKeyedNonce#119"
            ],
            "files": [
                "era-contracts/system-contracts/contracts/NonceHolder.sol"
            ]
        }
    ],
    "affected_files": {
        "NonceHolder.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\n\nimport {INonceHolder} from \"./interfaces/INonceHolder.sol\";\nimport {SystemContractBase} from \"./abstract/SystemContractBase.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT} from \"./Constants.sol\";\nimport {NonceIncreaseError, ValueMismatch, NonceAlreadyUsed, NonceNotUsed, Unauthorized, InvalidNonceKey} from \"./SystemContractErrors.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice A contract used for managing nonces for accounts. Together with bootloader,\n * this contract ensures that the pair (sender, nonce) is always unique, ensuring\n * unique transaction hashes.\n * @dev The account allows for increasing their `minNonce` by 1 or any value up to 2^32.\n * This way all the nonces less than `minNonce` will become used. The account can also\n * manage keyed nonces, where the nonce is split into key:value parts, 192:64 bits.\n * For each nonce key, the nonce value is tracked separately.\n * @dev Apart from transaction nonces, this contract also stores the deployment nonce for accounts, that\n * will be used for address derivation using CREATE. For the economy of space, this nonce is stored tightly\n * packed with the `minNonce`.\n * @dev The behavior of some of the methods depends on the nonce ordering of the account. Nonce ordering is a mere suggestion and all the checks that are present\n * here serve more as a help to users to prevent from doing mistakes, rather than any invariants.\n */\ncontract NonceHolder is INonceHolder, SystemContractBase {\n    uint256 private constant DEPLOY_NONCE_MULTIPLIER = 2 ** 128;\n    /// The minNonce can be increased by 2^32 at a time to prevent it from\n    /// overflowing beyond 2**128.\n    uint256 private constant MAXIMAL_MIN_NONCE_INCREMENT = 2 ** 32;\n\n    /// RawNonces for accounts are stored in format\n    /// minNonce + 2^128 * deploymentNonce, where deploymentNonce\n    /// is the nonce used for deploying smart contracts,\n    /// and minNonce is the first unused nonce with nonceKey (upper 192 bits) zero.\n    mapping(uint256 account => uint256 packedMinAndDeploymentNonce) internal rawNonces;\n\n    /// Mapping of values under nonces for accounts.\n    /// The main key of the mapping is the 256-bit address of the account, while the\n    /// inner mapping is a mapping from a nonce to the value stored there.\n    /// DEPRECATED: users can no longer set values under nonces.\n    mapping(uint256 account => mapping(uint256 nonce => uint256 storedValue)) internal __DEPRECATED_nonceValues;\n\n    /// This mapping tracks minNonce for non-zero nonce keys.\n    mapping(uint256 account => mapping(uint192 nonceKey => uint64 nonceValue)) internal keyedNonces;\n\n    /// @notice Returns the current minimal nonce for account.\n    /// @param _address The account to return the minimal nonce for\n    /// @return The current minimal nonce for this account.\n    function getMinNonce(address _address) public view returns (uint256) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (, uint256 minNonce) = _splitRawNonce(rawNonces[addressAsKey]);\n\n        return minNonce;\n    }\n\n    /// @notice Returns the current keyed nonce for account given its nonce key.\n    /// @param _address The account to return the nonce for.\n    /// @param _key The key of the nonce to return.\n    /// @return The current keyed nonce with the given key for this account.\n    /// Returns the full nonce (including the provided key), not just the nonce value.\n    function getKeyedNonce(address _address, uint192 _key) public view returns (uint256) {\n        if (_key == 0) {\n            return getMinNonce(_address);\n        }\n        uint256 addressAsKey = uint256(uint160(_address));\n        return _combineKeyedNonce(_key, keyedNonces[addressAsKey][_key]);\n    }\n\n    /// @notice Returns the raw version of the current minimal nonce\n    /// @dev It is equal to minNonce + 2^128 * deployment nonce.\n    /// @param _address The account to return the raw nonce for\n    /// @return The raw nonce for this account.\n    function getRawNonce(address _address) public view returns (uint256) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        return rawNonces[addressAsKey];\n    }\n\n    /// @notice Increases the minimal nonce for the msg.sender and returns the previous one.\n    /// @param _value The number by which to increase the minimal nonce for msg.sender.\n    /// @return oldMinNonce The value of the minimal nonce for msg.sender before the increase.\n    function increaseMinNonce(uint256 _value) public onlySystemCall returns (uint256 oldMinNonce) {\n        if (_value > MAXIMAL_MIN_NONCE_INCREMENT) {\n            revert NonceIncreaseError(MAXIMAL_MIN_NONCE_INCREMENT, _value);\n        }\n\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n        (, oldMinNonce) = _splitRawNonce(oldRawNonce);\n\n        // Although unrealistic in practice, we still forbid `minNonce` overflow\n        // to prevent collisions with keyed nonces.\n        if (oldMinNonce + _value > type(uint64).max) {\n            uint256 maxAllowedIncrement = type(uint64).max - oldMinNonce;\n            revert NonceIncreaseError(maxAllowedIncrement, _value);\n        }\n\n        unchecked {\n            rawNonces[addressAsKey] = (oldRawNonce + _value);\n        }\n    }\n\n    /// @notice Splits a keyed nonce into its key and value components (192:64 bits).\n    /// `_combineKeyedNonce`'s counterpart.\n    /// @param _nonce The nonce to split.\n    /// @return nonceKey The upper 192 bits of the nonce -- the nonce key.\n    /// @return nonceValue The lower 64 bits of the nonce -- the nonce value.\n    function _splitKeyedNonce(uint256 _nonce) private pure returns (uint192 nonceKey, uint64 nonceValue) {\n        nonceKey = uint192(_nonce >> 64);\n        nonceValue = uint64(_nonce);\n    }\n\n    /// @notice Combines a nonce key and a nonce value into a single 256-bit nonce.\n    /// `_splitKeyedNonce`'s counterpart.\n    /// @param _nonceKey The upper 192 bits of the nonce -- the nonce key.\n    /// @param _nonceValue The lower 64 bits of the nonce -- the nonce value.\n    /// @return The full 256-bit keyed nonce.\n    function _combineKeyedNonce(uint192 _nonceKey, uint64 _nonceValue) private pure returns (uint256) {\n        return (uint256(_nonceKey) << 64) + _nonceValue;\n    }\n\n    /// @notice A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`.\n    /// @dev This function only increments `minNonce` for nonces with nonceKey == 0.\n    /// AAs that try to use this method with a keyed nonce will revert.\n    /// For keyed nonces, `incrementMinNonceIfEqualsKeyed` should be used.\n    /// This is to prevent DefaultAccount and other deployed AAs from\n    /// unintentionally allowing keyed nonces to be used.\n    /// @param _expectedNonce The expected minimal nonce for the account.\n    function incrementMinNonceIfEquals(uint256 _expectedNonce) external onlySystemCall {\n        (uint192 nonceKey, ) = _splitKeyedNonce(_expectedNonce);\n        if (nonceKey != 0) {\n            revert InvalidNonceKey(nonceKey);\n        }\n\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n\n        (, uint256 oldMinNonce) = _splitRawNonce(oldRawNonce);\n        if (oldMinNonce != _expectedNonce) {\n            revert ValueMismatch(_expectedNonce, oldMinNonce);\n        }\n\n        // Although unrealistic in practice, we still forbid `minNonce` overflow\n        // to prevent collisions with keyed nonces.\n        if (oldMinNonce + 1 > type(uint64).max) {\n            revert NonceIncreaseError(0, 1);\n        }\n\n        unchecked {\n            rawNonces[addressAsKey] = oldRawNonce + 1;\n        }\n    }\n\n    /// @notice A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`. This is a keyed counterpart to `incrementMinNonceIfEquals`.\n    /// Reverts for nonces with nonceKey == 0.\n    /// @param _expectedNonce The expected minimal nonce for the account.\n    function incrementMinNonceIfEqualsKeyed(uint256 _expectedNonce) external onlySystemCall {\n        (uint192 nonceKey, uint64 nonceValue) = _splitKeyedNonce(_expectedNonce);\n        if (nonceKey == 0) {\n            revert InvalidNonceKey(nonceKey);\n        }\n\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        uint64 oldNonceValue = keyedNonces[addressAsKey][nonceKey];\n        if (oldNonceValue != nonceValue) {\n            revert ValueMismatch(nonceValue, oldNonceValue);\n        }\n\n        unchecked {\n            keyedNonces[addressAsKey][nonceKey] = nonceValue + 1;\n        }\n    }\n\n    /// @notice Returns the deployment nonce for the accounts used for CREATE opcode.\n    /// @param _address The address to return the deploy nonce of.\n    /// @return deploymentNonce The deployment nonce of the account.\n    function getDeploymentNonce(address _address) external view returns (uint256 deploymentNonce) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (deploymentNonce, ) = _splitRawNonce(rawNonces[addressAsKey]);\n\n        return deploymentNonce;\n    }\n\n    /// @notice Increments the deployment nonce for the account and returns the previous one.\n    /// @param _address The address of the account which to return the deploy nonce for.\n    /// @return prevDeploymentNonce The deployment nonce at the time this function is called.\n    function incrementDeploymentNonce(address _address) external returns (uint256 prevDeploymentNonce) {\n        if (msg.sender != address(DEPLOYER_SYSTEM_CONTRACT)) {\n            revert Unauthorized(msg.sender);\n        }\n        uint256 addressAsKey = uint256(uint160(_address));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n\n        unchecked {\n            rawNonces[addressAsKey] = (oldRawNonce + DEPLOY_NONCE_MULTIPLIER);\n        }\n\n        (prevDeploymentNonce, ) = _splitRawNonce(oldRawNonce);\n    }\n\n    /// @notice A method that checks whether the nonce has been used before.\n    /// @param _address The address the nonce of which is being checked.\n    /// @param _nonce The nonce value which is checked.\n    /// @return `true` if the nonce has been used, `false` otherwise.\n    function isNonceUsed(address _address, uint256 _nonce) public view returns (bool) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (uint192 nonceKey, uint64 nonceValue) = _splitKeyedNonce(_nonce);\n        // We keep the `nonceValues` check here, until it is confirmed that this mapping has never been used by anyone.\n        return\n            _nonce < getMinNonce(_address) ||\n            nonceValue < keyedNonces[addressAsKey][nonceKey] ||\n            __DEPRECATED_nonceValues[addressAsKey][_nonce] > 0;\n    }\n\n    /// @notice Checks and reverts based on whether the nonce is used (not used).\n    /// @param _address The address the nonce of which is being checked.\n    /// @param _key The nonce value which is tested.\n    /// @param _shouldBeUsed The flag for the method. If `true`, the method checks that whether this nonce\n    /// is marked as used and reverts if this is not the case. If `false`, this method will check that the nonce\n    /// has *not* been used yet, and revert otherwise.\n    /// @dev This method should be used by the bootloader.\n    function validateNonceUsage(address _address, uint256 _key, bool _shouldBeUsed) external view {\n        bool isUsed = isNonceUsed(_address, _key);\n\n        if (isUsed && !_shouldBeUsed) {\n            revert NonceAlreadyUsed(_address, _key);\n        } else if (!isUsed && _shouldBeUsed) {\n            revert NonceNotUsed(_address, _key);\n        }\n    }\n\n    /// @notice Splits the raw nonce value into the deployment nonce and the minimal nonce.\n    /// @param _rawMinNonce The value of the raw minimal nonce (equal to minNonce + deploymentNonce* 2**128).\n    /// @return deploymentNonce and minNonce.\n    function _splitRawNonce(uint256 _rawMinNonce) internal pure returns (uint256 deploymentNonce, uint256 minNonce) {\n        deploymentNonce = _rawMinNonce / DEPLOY_NONCE_MULTIPLIER;\n        minNonce = _rawMinNonce % DEPLOY_NONCE_MULTIPLIER;\n    }\n}\n"
    }
}