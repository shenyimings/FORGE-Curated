{
    "vfp_id": "vfp_00594",
    "project_name": "Lido V3 _ Consensys Diligence.md",
    "findings": [
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "No Incentive for Node Operator to Increase Rewards Adjustments",
            "description": "Node operators have no incentive to increase `rewardsAdjustment`, which reduces their fee entitlement, leading to potential overpayment by vaults.\n\nThe root cause is the lack of reward or obligation for NOs to adjust fees in favor of vaults.\n\nThis is not directly exploitable but leads to suboptimal economic outcomes.\n\nThe impact is reduced net rewards for vaults and potential distrust in NO behavior.\n",
            "severity": "Low",
            "location": [
                "NodeOperatorFee.sol::increaseRewardsAdjustment#L265-L272"
            ],
            "files": [
                "core/contracts/0.8.25/vaults/dashboard/NodeOperatorFee.sol"
            ]
        }
    ],
    "affected_files": {
        "NodeOperatorFee.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.25;\n\nimport {VaultHub} from \"../VaultHub.sol\";\nimport {LazyOracle} from \"../LazyOracle.sol\";\nimport {Permissions} from \"./Permissions.sol\";\n\n/**\n * @title NodeOperatorFee\n * @author Lido\n * @notice An accounting contract for a vault's node operator fee:\n *   • Calculates the node operator's share of each reward period,\n *   • Ignores any vault value changes that aren't true rewards,\n *   • Permissionless on-demand fee disbursement,\n *   • Critical parameter changes require vault-owner<>node operator approval.\n */\ncontract NodeOperatorFee is Permissions {\n    /**\n     * @notice Total basis points; 1bp = 0.01%, 100_00bp = 100.00%.\n     */\n    uint256 internal constant TOTAL_BASIS_POINTS = 100_00;\n\n    /**\n     * @notice Maximum value that can be set via manual adjustment\n     */\n    uint256 public constant MANUAL_REWARDS_ADJUSTMENT_LIMIT = 10_000_000 ether;\n\n    /**\n     * @notice Node operator manager role:\n     * - confirms confirm expiry;\n     * - confirms node operator fee changes;\n     * - confirms the transfer of the StakingVault ownership;\n     * - sets the node operator fee recipient.\n     */\n    bytes32 public constant NODE_OPERATOR_MANAGER_ROLE = keccak256(\"vaults.NodeOperatorFee.NodeOperatorManagerRole\");\n\n    /**\n     * @notice Adjusts rewards to allow fee correction during side deposits or consolidations\n     */\n    bytes32 public constant NODE_OPERATOR_REWARDS_ADJUST_ROLE = keccak256(\"vaults.NodeOperatorFee.RewardsAdjustRole\");\n\n    /**\n     * @notice Node operator fee in basis points; cannot exceed 100.00%.\n     * The node operator's disbursable fee in ether is returned by `nodeOperatorDisbursableFee()`.\n     */\n    uint256 public nodeOperatorFeeRate;\n\n    /**\n     * @notice The last report for which node operator fee was disbursed. Updated on each disbursement.\n     */\n    VaultHub.Report public feePeriodStartReport;\n\n    /**\n     * @notice The address of the node operator fee recipient.\n     */\n    address public nodeOperatorFeeRecipient;\n\n    struct RewardsAdjustment {\n        uint128 amount;\n        uint64 latestTimestamp;\n    }\n\n    /**\n     * @notice Adjustment to allow fee correction during side deposits or consolidations.\n     *          - can be increased manually by `increaseRewardsAdjustment` by NODE_OPERATOR_REWARDS_ADJUST_ROLE\n     *          - can be set via `setRewardsAdjustment` by `confirmingRoles()`\n     *          - increased automatically with `unguaranteedDepositToBeaconChain` by total ether amount of deposits\n     *          - reset to zero after `disburseNodeOperatorFee`\n     *        This amount will be deducted from rewards during NO fee calculation and can be used effectively write off NO's accrued fees.\n     *\n     */\n    RewardsAdjustment public rewardsAdjustment;\n\n    /**\n     * @notice Passes the address of the vault hub up the inheritance chain.\n     * @param _vaultHub The address of the vault hub.\n     * @param _lidoLocator The address of the Lido locator.\n     */\n    constructor(address _vaultHub, address _lidoLocator) Permissions(_vaultHub, _lidoLocator) {}\n\n    /**\n     * @dev Calls the parent's initializer, sets the node operator fee, assigns the node operator manager role,\n     * and makes the node operator manager the admin for the node operator roles.\n     * @param _defaultAdmin The address of the default admin\n     * @param _nodeOperatorManager The address of the node operator manager\n     * @param _nodeOperatorFeeRate The node operator fee rate\n     * @param _confirmExpiry The confirmation expiry time in seconds\n     */\n    function _initialize(\n        address _defaultAdmin,\n        address _nodeOperatorManager,\n        uint256 _nodeOperatorFeeRate,\n        uint256 _confirmExpiry\n    ) internal {\n        _requireNotZero(_nodeOperatorManager);\n\n        super._initialize(_defaultAdmin, _confirmExpiry);\n\n        _validateNodeOperatorFeeRate(_nodeOperatorFeeRate);\n        _setNodeOperatorFeeRate(_nodeOperatorFeeRate);\n        _setNodeOperatorFeeRecipient(_nodeOperatorManager);\n\n        _grantRole(NODE_OPERATOR_MANAGER_ROLE, _nodeOperatorManager);\n        _setRoleAdmin(NODE_OPERATOR_MANAGER_ROLE, NODE_OPERATOR_MANAGER_ROLE);\n        _setRoleAdmin(NODE_OPERATOR_REWARDS_ADJUST_ROLE, NODE_OPERATOR_MANAGER_ROLE);\n    }\n\n    /**\n     * @notice Returns the roles that can:\n     * - change the confirm expiry;\n     * - set the node operator fee;\n     * - set a new owner of the StakingVault.\n     * @return roles is an array of roles that form the confirming roles.\n     */\n    function confirmingRoles() public pure override returns (bytes32[] memory roles) {\n        roles = new bytes32[](2);\n        roles[0] = DEFAULT_ADMIN_ROLE;\n        roles[1] = NODE_OPERATOR_MANAGER_ROLE;\n    }\n\n    /**\n     * @notice Returns the latest report data containing the total value and in-out delta.\n     * @return report The latest report.\n     */\n    function latestReport() public view returns (VaultHub.Report memory) {\n        return VAULT_HUB.latestReport(address(_stakingVault()));\n    }\n\n    /**\n     * @notice Calculates the node operator's disbursable fee.\n     *\n     * The fee presently owed to the node-operator,\n     * computed as a portion of staking rewards accrued between\n     * `feePeriodStartReport` and `latestReport()`.\n     *\n     * Staking rewards for an accounting interval are derived as:\n     *     rewards = Δ(totalValue) − Δ(inOutDelta) − rewardsAdjustment\n     *\n     * where\n     *  • Δ(totalValue)     — change in totalValue (CL + EL balances) between reports;\n     *  • Δ(inOutDelta)     — net funds/withdrawals in the same interval;\n     *  • rewardsAdjustment — rewards offset that excludes side deposits and consolidations\n     *                        (e.g. CL topups that are not subject to node operator fee).\n     *\n     * If the rewards are negative, for the purposes of fee calculation, they are considered to be zero.\n     * The node-operator's fee is therefore:\n     *     fee = max(0, rewards) × nodeOperatorFeeBP / TOTAL_BASIS_POINTS\n     *\n     * @return fee The node operator's disbursable fee.\n     */\n    function nodeOperatorDisbursableFee() public view returns (uint256) {\n        VaultHub.Report memory periodStart = feePeriodStartReport;\n        VaultHub.Report memory periodEnd = latestReport();\n        int256 adjustment = _toSignedClamped(rewardsAdjustment.amount);\n\n        // the total increase/decrease of the vault value during the fee period\n        int256 growth = int112(periodEnd.totalValue) - int112(periodStart.totalValue) -\n                        (periodEnd.inOutDelta - periodStart.inOutDelta);\n\n        // the actual rewards that are subject to the fee\n        int256 rewards = growth - adjustment;\n\n        return rewards <= 0 ? 0 : (uint256(rewards) * nodeOperatorFeeRate) / TOTAL_BASIS_POINTS;\n    }\n\n    /**\n     * @notice Transfers the node-operator's accrued fee (if any).\n     * Steps:\n     *  • Compute the current fee via `nodeOperatorDisbursableFee()`.\n     *  • If there are no rewards, do nothing.\n     *  • Otherwise, move `feePeriodStartReport` to `latestReport()`,\n     *    reset `rewardsAdjustment` and transfer `fee` wei to `nodeOperatorFeeRecipient`.\n     */\n    function disburseNodeOperatorFee() public {\n        uint256 fee = nodeOperatorDisbursableFee();\n        // it's important not to revert here if there is no fee,\n        // because the fee is automatically disbursed during `voluntaryDisconnect`\n        if (fee == 0) return;\n\n        if (rewardsAdjustment.amount != 0) _setRewardsAdjustment(0);\n        feePeriodStartReport = latestReport();\n\n        VAULT_HUB.withdraw(address(_stakingVault()), nodeOperatorFeeRecipient, fee);\n        emit NodeOperatorFeeDisbursed(msg.sender, fee);\n    }\n\n    /**\n     * @notice Updates the node-operator's fee rate (basis-points share).\n     * @param _newNodeOperatorFeeRate The new node operator fee rate.\n     * @return bool Whether the node operator fee rate was set.\n     */\n    function setNodeOperatorFeeRate(uint256 _newNodeOperatorFeeRate) external returns (bool) {\n        // The report must be fresh so that the total value of the vault is up to date\n        // and all the node operator fees are paid out fairly up to the moment of the latest fresh report\n        if (!VAULT_HUB.isReportFresh(address(_stakingVault()))) revert ReportStale();\n\n        // Latest adjustment must be earlier than the latest fresh report timestamp\n        if (rewardsAdjustment.latestTimestamp >= _lazyOracle().latestReportTimestamp())\n            revert AdjustmentNotReported();\n\n        // Adjustment must be settled before the fee rate change\n        if (rewardsAdjustment.amount != 0) revert AdjustmentNotSettled();\n\n        // If the vault is quarantined, the total value is reduced and may not reflect the adjustment\n        if (_lazyOracle().vaultQuarantine(address(_stakingVault())).isActive) revert VaultQuarantined();\n\n        // Validate fee rate before collecting confirmations\n        _validateNodeOperatorFeeRate(_newNodeOperatorFeeRate);\n\n        // store the caller's confirmation; only proceed if the required number of confirmations is met.\n        if (!_collectAndCheckConfirmations(msg.data, confirmingRoles())) return false;\n\n        // To follow the check-effects-interaction pattern, we need to remember the fee here\n        // because the fee calculation variables will be reset in the following lines\n        uint256 fee = nodeOperatorDisbursableFee();\n\n        // Start a new fee period\n        feePeriodStartReport = latestReport();\n\n        _setNodeOperatorFeeRate(_newNodeOperatorFeeRate);\n\n        if (fee > 0) {\n            VAULT_HUB.withdraw(address(_stakingVault()), nodeOperatorFeeRecipient, fee);\n            emit NodeOperatorFeeDisbursed(msg.sender, fee);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Sets the confirm expiry.\n     * Confirm expiry is a period during which the confirm is counted. Once the period is over,\n     * the confirm is considered expired, no longer counts and must be recasted.\n     * @param _newConfirmExpiry The new confirm expiry in seconds.\n     * @return bool Whether the confirm expiry was set.\n     */\n    function setConfirmExpiry(uint256 _newConfirmExpiry) external returns (bool) {\n        _validateConfirmExpiry(_newConfirmExpiry);\n\n        if (!_collectAndCheckConfirmations(msg.data, confirmingRoles())) return false;\n\n        _setConfirmExpiry(_newConfirmExpiry);\n\n        return true;\n    }\n\n    /**\n     * @notice Sets the node operator fee recipient.\n     * @param _newNodeOperatorFeeRecipient The address of the new node operator fee recipient.\n     */\n    function setNodeOperatorFeeRecipient(\n        address _newNodeOperatorFeeRecipient\n    ) external onlyRoleMemberOrAdmin(NODE_OPERATOR_MANAGER_ROLE) {\n        _setNodeOperatorFeeRecipient(_newNodeOperatorFeeRecipient);\n    }\n\n    /**\n     * @notice Increases rewards adjustment to correct fee calculation due to non-rewards ether on CL\n     * @param _adjustmentIncrease amount to increase adjustment by\n     * @dev will revert if final adjustment is more than `MANUAL_REWARDS_ADJUSTMENT_LIMIT`\n     */\n    function increaseRewardsAdjustment(\n        uint256 _adjustmentIncrease\n    ) external onlyRoleMemberOrAdmin(NODE_OPERATOR_REWARDS_ADJUST_ROLE) {\n        uint256 newAdjustment = rewardsAdjustment.amount + _adjustmentIncrease;\n        // sanity check, though value will be cast safely during fee calculation\n        if (newAdjustment > MANUAL_REWARDS_ADJUSTMENT_LIMIT) revert IncreasedOverLimit();\n        _setRewardsAdjustment(newAdjustment);\n    }\n\n    /**\n     * @notice set `rewardsAdjustment` to a new proposed value if `confirmingRoles()` agree\n     * @param _proposedAdjustment new adjustment amount\n     * @param _expectedAdjustment current adjustment value for invalidating old confirmations\n     * @return bool Whether the rewards adjustment was set.\n     * @dev will revert if new adjustment is more than `MANUAL_REWARDS_ADJUSTMENT_LIMIT`\n     */\n    function setRewardsAdjustment(\n        uint256 _proposedAdjustment,\n        uint256 _expectedAdjustment\n    ) external returns (bool) {\n        if (rewardsAdjustment.amount != _expectedAdjustment)\n            revert InvalidatedAdjustmentVote(rewardsAdjustment.amount, _expectedAdjustment);\n        if (_proposedAdjustment > MANUAL_REWARDS_ADJUSTMENT_LIMIT) revert IncreasedOverLimit();\n        if (!_collectAndCheckConfirmations(msg.data, confirmingRoles())) return false;\n        _setRewardsAdjustment(_proposedAdjustment);\n        return true;\n    }\n\n    function _setNodeOperatorFeeRate(uint256 _newNodeOperatorFeeRate) internal {\n        _validateNodeOperatorFeeRate(_newNodeOperatorFeeRate);\n\n        uint256 oldNodeOperatorFeeRate = nodeOperatorFeeRate;\n        nodeOperatorFeeRate = _newNodeOperatorFeeRate;\n\n        emit NodeOperatorFeeRateSet(msg.sender, oldNodeOperatorFeeRate, _newNodeOperatorFeeRate);\n    }\n\n    function _setNodeOperatorFeeRecipient(address _newNodeOperatorFeeRecipient) internal {\n        _requireNotZero(_newNodeOperatorFeeRecipient);\n        if (_newNodeOperatorFeeRecipient == nodeOperatorFeeRecipient) revert SameRecipient();\n\n        address oldNodeOperatorFeeRecipient = nodeOperatorFeeRecipient;\n        nodeOperatorFeeRecipient = _newNodeOperatorFeeRecipient;\n        emit NodeOperatorFeeRecipientSet(msg.sender, oldNodeOperatorFeeRecipient, _newNodeOperatorFeeRecipient);\n    }\n\n    /**\n     * @notice sets InOut adjustment for correct fee calculation\n     * @param _newAdjustment new adjustment value\n     */\n    function _setRewardsAdjustment(uint256 _newAdjustment) internal {\n        uint256 oldAdjustment = rewardsAdjustment.amount;\n\n        if (_newAdjustment == oldAdjustment) revert SameAdjustment();\n\n        rewardsAdjustment.amount = uint128(_newAdjustment);\n        rewardsAdjustment.latestTimestamp = uint64(block.timestamp);\n\n        emit RewardsAdjustmentSet(_newAdjustment, oldAdjustment);\n    }\n\n    function _toSignedClamped(uint128 _adjustment) internal pure returns (int128) {\n        if (_adjustment > uint128(type(int128).max)) return type(int128).max;\n        return int128(_adjustment);\n    }\n\n    /**\n     * @notice Validates that the node operator fee rate is within acceptable bounds\n     * @param _nodeOperatorFeeRate The fee rate to validate\n     */\n    function _validateNodeOperatorFeeRate(uint256 _nodeOperatorFeeRate) internal pure {\n        if (_nodeOperatorFeeRate > TOTAL_BASIS_POINTS) revert FeeValueExceed100Percent();\n    }\n\n    function _lazyOracle() internal view returns (LazyOracle) {\n        return LazyOracle(LIDO_LOCATOR.lazyOracle());\n    }\n\n    // ==================== Events ====================\n\n    /**\n     * @dev Emitted when the node operator fee is set.\n     * @param oldNodeOperatorFeeRate The old node operator fee rate.\n     * @param newNodeOperatorFeeRate The new node operator fee rate.\n     */\n    event NodeOperatorFeeRateSet(address indexed sender, uint256 oldNodeOperatorFeeRate, uint256 newNodeOperatorFeeRate);\n\n    /**\n     * @dev Emitted when the node operator fee is disbursed.\n     * @param fee the amount of disbursed fee.\n     */\n    event NodeOperatorFeeDisbursed(address indexed sender, uint256 fee);\n\n    /**\n     * @dev Emitted when the new rewards adjustment is set.\n     * @param newAdjustment the new adjustment value\n     * @param oldAdjustment previous adjustment value\n     */\n    event RewardsAdjustmentSet(uint256 newAdjustment, uint256 oldAdjustment);\n\n    /**\n     * @dev Emitted when the node operator fee recipient is set.\n     * @param sender the address of the sender who set the recipient\n     * @param oldNodeOperatorFeeRecipient the old node operator fee recipient\n     * @param newNodeOperatorFeeRecipient the new node operator fee recipient\n     */\n    event NodeOperatorFeeRecipientSet(address indexed sender, address oldNodeOperatorFeeRecipient, address newNodeOperatorFeeRecipient);\n\n    // ==================== Errors ====================\n\n    /**\n     * @dev Error emitted when the combined feeBPs exceed 100%.\n     */\n    error FeeValueExceed100Percent();\n\n    /**\n     * @dev Error emitted when the increased adjustment exceeds the `MANUAL_REWARDS_ADJUSTMENT_LIMIT`.\n     */\n    error IncreasedOverLimit();\n\n    /**\n     * @dev Error emitted when the adjustment setting vote is not valid due to changed state\n     */\n    error InvalidatedAdjustmentVote(uint256 currentAdjustment, uint256 currentAtPropositionAdjustment);\n\n    /**\n     * @dev Error emitted when trying to set same value for adjustment\n     */\n    error SameAdjustment();\n\n    /**\n     * @dev Error emitted when trying to set same value for recipient\n     */\n    error SameRecipient();\n\n    /**\n     * @dev Error emitted when the report is stale.\n     */\n    error ReportStale();\n\n    /**\n     * @dev Error emitted when the adjustment has not been reported yet.\n     */\n    error AdjustmentNotReported();\n\n    /**\n     * @dev Error emitted when the adjustment is not settled.\n     */\n    error AdjustmentNotSettled();\n\n    /**\n     * @dev Error emitted when the vault is quarantined.\n     */\n    error VaultQuarantined();\n}\n"
    }
}