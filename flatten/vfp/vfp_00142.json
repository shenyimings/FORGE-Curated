{
    "vfp_id": "vfp_00142",
    "project_name": "Likwid - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Checkpointed state used in LikwidMarginPosition differs from the core implementation",
            "description": "The StateLibrary.getCurrentState() function used in LikwidMarginPosition diverges from the core Pool.updateInterests() logic, particularly in how protocol fees are loaded. StateLibrary.getSlot0() retrieves fees directly from Slot0 without applying defaults, potentially leading to incorrect fee calculations. Additionally, state.lastUpdated is not set to block.timestamp, causing time-based calculations to use stale data. This inconsistency can result in divergent state views between different parts of the system, leading to incorrect margin levels, unfair liquidations, or incorrect fee distributions.\n",
            "severity": "High",
            "location": [
                "StateLibrary.sol"
            ],
            "files": [
                "likwid-margin/src/libraries/StateLibrary.sol"
            ]
        }
    ],
    "affected_files": {
        "StateLibrary.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IMarginBase} from \"../interfaces/IMarginBase.sol\";\nimport {Slot0, Slot0Library} from \"../types/Slot0.sol\";\nimport {Reserves, ReservesLibrary, toReserves} from \"../types/Reserves.sol\";\nimport {PoolState} from \"../types/PoolState.sol\";\nimport {PairPosition} from \"./PairPosition.sol\";\nimport {LendPosition} from \"./LendPosition.sol\";\nimport {TimeLibrary} from \"./TimeLibrary.sol\";\nimport {PositionLibrary} from \"./PositionLibrary.sol\";\nimport {InterestMath} from \"./InterestMath.sol\";\nimport {PriceMath} from \"./PriceMath.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/// @title A helper library to provide state getters for a Likwid pool\n/// @notice This library provides functions to read the state of a Likwid pool from storage.\nlibrary StateLibrary {\n    using SafeCast for *;\n    using Slot0Library for Slot0;\n    using ReservesLibrary for Reserves;\n    using PositionLibrary for address;\n    using TimeLibrary for uint32;\n\n    /// @notice The storage slot of the `lastStageTimestampStore` mapping in the MarginBase contract.\n    /// @dev This is an assumption. If the storage layout of MarginBase changes, this value needs to be updated.\n    bytes32 public constant LAST_STAGE_TIMESTAMP_STORE_SLOT = bytes32(uint256(3));\n    /// @notice The storage slot of the `liquidityLockedQueue` mapping in the MarginBase contract.\n    /// @dev This is an assumption. If the storage layout of MarginBase changes, this value needs to be updated.\n    bytes32 public constant LIQUIDITY_LOCKED_QUEUE_SLOT = bytes32(uint256(4));\n\n    /// @notice The storage slot of the `_pools` mapping in the LikwidVault contract.\n    bytes32 public constant POOLS_SLOT = bytes32(uint256(10));\n\n    // Offsets for fields within the Pool.State struct\n    uint256 internal constant BORROW_0_CUMULATIVE_LAST_OFFSET = 1;\n    uint256 internal constant BORROW_1_CUMULATIVE_LAST_OFFSET = 2;\n    uint256 internal constant DEPOSIT_0_CUMULATIVE_LAST_OFFSET = 3;\n    uint256 internal constant DEPOSIT_1_CUMULATIVE_LAST_OFFSET = 4;\n    uint256 internal constant REAL_RESERVES_OFFSET = 5;\n    uint256 internal constant MIRROR_RESERVES_OFFSET = 6;\n    uint256 internal constant PAIR_RESERVES_OFFSET = 7;\n    uint256 internal constant TRUNCATED_RESERVES_OFFSET = 8;\n    uint256 internal constant LEND_RESERVES_OFFSET = 9;\n    uint256 internal constant INTEREST_RESERVES_OFFSET = 10;\n    uint256 internal constant POSITIONS_OFFSET = 11;\n    uint256 internal constant LEND_POSITIONS_OFFSET = 12;\n\n    /**\n     * @notice Get the unpacked Slot0 of the pool.\n     * @dev Corresponds to pools[poolId].slot0\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return totalSupply The total supply of liquidity tokens.\n     * @return lastUpdated The timestamp of the last update.\n     * @return protocolFee The protocol fee of the pool.\n     * @return lpFee The swap fee of the pool.\n     * @return marginFee The margin fee of the pool.\n     */\n    function getSlot0(IVault vault, PoolId poolId)\n        internal\n        view\n        returns (uint128 totalSupply, uint32 lastUpdated, uint24 protocolFee, uint24 lpFee, uint24 marginFee)\n    {\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n        Slot0 slot0 = Slot0.wrap(vault.extsload(stateSlot));\n        totalSupply = slot0.totalSupply();\n        lastUpdated = slot0.lastUpdated();\n        protocolFee = slot0.protocolFee();\n        lpFee = slot0.lpFee();\n        marginFee = slot0.marginFee();\n    }\n\n    /**\n     * @notice Retrieves the cumulative borrow and deposit rates of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return borrow0CumulativeLast The cumulative borrow rate for currency 0.\n     * @return borrow1CumulativeLast The cumulative borrow rate for currency 1.\n     * @return deposit0CumulativeLast The cumulative deposit rate for currency 0.\n     * @return deposit1CumulativeLast The cumulative deposit rate for currency 1.\n     */\n    function getBorrowDepositCumulative(IVault vault, PoolId poolId)\n        internal\n        view\n        returns (\n            uint256 borrow0CumulativeLast,\n            uint256 borrow1CumulativeLast,\n            uint256 deposit0CumulativeLast,\n            uint256 deposit1CumulativeLast\n        )\n    {\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n        bytes32 startSlot = bytes32(uint256(stateSlot) + BORROW_0_CUMULATIVE_LAST_OFFSET);\n\n        bytes32[] memory data = vault.extsload(startSlot, 4);\n        assembly (\"memory-safe\") {\n            borrow0CumulativeLast := mload(add(data, 0x20))\n            borrow1CumulativeLast := mload(add(data, 0x40))\n            deposit0CumulativeLast := mload(add(data, 0x60))\n            deposit1CumulativeLast := mload(add(data, 0x80))\n        }\n    }\n\n    /**\n     * @notice Retrieves the pair reserves of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return The packed pair reserves of the pool.\n     */\n    function getPairReserves(IVault vault, PoolId poolId) internal view returns (Reserves) {\n        bytes32 slot = bytes32(uint256(_getPoolStateSlot(poolId)) + PAIR_RESERVES_OFFSET);\n        return Reserves.wrap(uint256(vault.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the real reserves of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return The packed real reserves of the pool.\n     */\n    function getRealReserves(IVault vault, PoolId poolId) internal view returns (Reserves) {\n        bytes32 slot = bytes32(uint256(_getPoolStateSlot(poolId)) + REAL_RESERVES_OFFSET);\n        return Reserves.wrap(uint256(vault.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the mirror reserves of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return The packed mirror reserves of the pool.\n     */\n    function getMirrorReserves(IVault vault, PoolId poolId) internal view returns (Reserves) {\n        bytes32 slot = bytes32(uint256(_getPoolStateSlot(poolId)) + MIRROR_RESERVES_OFFSET);\n        return Reserves.wrap(uint256(vault.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the truncated reserves of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return The packed truncated reserves of the pool.\n     */\n    function getTruncatedReserves(IVault vault, PoolId poolId) internal view returns (Reserves) {\n        bytes32 slot = bytes32(uint256(_getPoolStateSlot(poolId)) + TRUNCATED_RESERVES_OFFSET);\n        return Reserves.wrap(uint256(vault.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the lending reserves of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return The packed lending reserves of the pool.\n     */\n    function getLendReserves(IVault vault, PoolId poolId) internal view returns (Reserves) {\n        bytes32 slot = bytes32(uint256(_getPoolStateSlot(poolId)) + LEND_RESERVES_OFFSET);\n        return Reserves.wrap(uint256(vault.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the interest reserves of a pool.\n     * @param vault The vault contract.\n     * @param poolId The ID of the pool.\n     * @return The packed interest reserves of the pool.\n     */\n    function getInterestReserves(IVault vault, PoolId poolId) internal view returns (Reserves) {\n        bytes32 slot = bytes32(uint256(_getPoolStateSlot(poolId)) + INTEREST_RESERVES_OFFSET);\n        return Reserves.wrap(uint256(vault.extsload(slot)));\n    }\n\n    function getLastStageTimestamp(IVault vault, PoolId poolId) internal view returns (uint256) {\n        bytes32 slot = keccak256(abi.encodePacked(PoolId.unwrap(poolId), LAST_STAGE_TIMESTAMP_STORE_SLOT));\n        return uint256(vault.extsload(slot));\n    }\n\n    function getPairPositionState(IVault vault, PoolId poolId, address owner, bytes32 salt)\n        internal\n        view\n        returns (PairPosition.State memory _position)\n    {\n        bytes32 positionKey = owner.calculatePositionKey(salt);\n\n        bytes32 poolStateSlot = _getPoolStateSlot(poolId);\n        bytes32 positionsMappingSlot = bytes32(uint256(poolStateSlot) + POSITIONS_OFFSET);\n        bytes32 positionSlot = keccak256(abi.encodePacked(positionKey, positionsMappingSlot));\n\n        bytes32[] memory data = vault.extsload(positionSlot, 2);\n        _position.liquidity = uint128(uint256(data[0]));\n        _position.totalInvestment = uint256(data[1]);\n    }\n\n    function getLendPositionState(IVault vault, PoolId poolId, address owner, bool lendForOne, bytes32 salt)\n        internal\n        view\n        returns (LendPosition.State memory _position)\n    {\n        bytes32 positionKey = owner.calculatePositionKey(lendForOne, salt);\n\n        bytes32 poolStateSlot = _getPoolStateSlot(poolId);\n        bytes32 positionsMappingSlot = bytes32(uint256(poolStateSlot) + LEND_POSITIONS_OFFSET);\n        bytes32 positionSlot = keccak256(abi.encodePacked(positionKey, positionsMappingSlot));\n\n        bytes32[] memory data = vault.extsload(positionSlot, 2);\n        uint256 slot0 = uint256(data[0]);\n        _position.lendAmount = uint128(slot0);\n        _position.depositCumulativeLast = uint256(data[1]);\n    }\n\n    function getRawStageLiquidities(IVault vault, PoolId poolId) internal view returns (uint256[] memory liquidities) {\n        bytes32 dequeSlot = keccak256(abi.encodePacked(PoolId.unwrap(poolId), LIQUIDITY_LOCKED_QUEUE_SLOT));\n        bytes32 dequeValue = vault.extsload(dequeSlot);\n\n        uint128 front;\n        uint128 back;\n        assembly (\"memory-safe\") {\n            front := and(dequeValue, 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff)\n            back := shr(128, dequeValue)\n        }\n\n        uint256 len = back - front;\n        liquidities = new uint256[](len);\n        bytes32 valuesSlot = bytes32(uint256(dequeSlot) + 1);\n\n        for (uint256 i = 0; i < len; i++) {\n            uint256 valueIndex = front + i;\n            bytes32 valueSlot = keccak256(abi.encodePacked(valueIndex, valuesSlot));\n            liquidities[i] = uint256(vault.extsload(valueSlot));\n        }\n    }\n\n    /**\n     * @notice Calculates the storage slot for a specific pool's state.\n     * @param poolId The ID of the pool.\n     * @return The storage slot of the Pool.State struct.\n     */\n    function _getPoolStateSlot(PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PoolId.unwrap(poolId), POOLS_SLOT));\n    }\n\n    function getCurrentState(IVault vault, PoolId poolId) internal view returns (PoolState memory state) {\n        bytes32 poolStateSlot = _getPoolStateSlot(poolId);\n\n        // 1. Get slot0\n        (state.totalSupply, state.lastUpdated, state.protocolFee, state.lpFee, state.marginFee) =\n            getSlot0(vault, poolId);\n\n        // 2. Get all other data in one call\n        bytes32 startSlot = bytes32(uint256(poolStateSlot) + 1); // BORROW_0_CUMULATIVE_LAST_OFFSET\n        bytes32[] memory data = vault.extsload(startSlot, 10); // read 10 slots\n\n        uint256 borrow0CumulativeBefore = uint256(data[0]);\n        uint256 borrow1CumulativeBefore = uint256(data[1]);\n        uint256 deposit0CumulativeBefore = uint256(data[2]);\n        uint256 deposit1CumulativeBefore = uint256(data[3]);\n        state.realReserves = Reserves.wrap(uint256(data[4]));\n        state.mirrorReserves = Reserves.wrap(uint256(data[5]));\n        state.pairReserves = Reserves.wrap(uint256(data[6]));\n        Reserves _truncatedReserves = Reserves.wrap(uint256(data[7]));\n        state.lendReserves = Reserves.wrap(uint256(data[8]));\n        state.interestReserves = Reserves.wrap(uint256(data[9]));\n\n        // 3. Get marginState\n        state.marginState = IMarginBase(address(vault)).marginState();\n\n        // 4. Get timeElapsed\n        uint256 timeElapsed = state.lastUpdated.getTimeElapsed();\n\n        (uint256 mirrorReserve0, uint256 mirrorReserve1) = state.mirrorReserves.reserves();\n        (uint256 pairReserve0, uint256 pairReserve1) = state.pairReserves.reserves();\n        (uint256 lendReserve0, uint256 lendReserve1) = state.lendReserves.reserves();\n        (uint256 interestReserve0, uint256 interestReserve1) = state.interestReserves.reserves();\n\n        (uint256 borrow0CumulativeLast, uint256 borrow1CumulativeLast) = InterestMath.getBorrowRateCumulativeLast(\n            timeElapsed,\n            borrow0CumulativeBefore,\n            borrow1CumulativeBefore,\n            state.marginState,\n            state.realReserves,\n            state.mirrorReserves\n        );\n\n        InterestMath.InterestUpdateParams memory params0 = InterestMath.InterestUpdateParams({\n            mirrorReserve: mirrorReserve0,\n            borrowCumulativeLast: borrow0CumulativeLast,\n            borrowCumulativeBefore: borrow0CumulativeBefore,\n            interestReserve: interestReserve0,\n            pairReserve: pairReserve0,\n            lendReserve: lendReserve0,\n            depositCumulativeLast: deposit0CumulativeBefore,\n            protocolFee: state.protocolFee\n        });\n\n        InterestMath.InterestUpdateResult memory result0 = InterestMath.updateInterestForOne(params0);\n        if (result0.changed) {\n            mirrorReserve0 = result0.newMirrorReserve;\n            pairReserve0 = result0.newPairReserve;\n            lendReserve0 = result0.newLendReserve;\n            interestReserve0 = result0.newInterestReserve;\n        }\n        state.deposit0CumulativeLast = result0.newDepositCumulativeLast;\n        state.borrow0CumulativeLast = borrow0CumulativeLast;\n\n        InterestMath.InterestUpdateParams memory params1 = InterestMath.InterestUpdateParams({\n            mirrorReserve: mirrorReserve1,\n            borrowCumulativeLast: borrow1CumulativeLast,\n            borrowCumulativeBefore: borrow1CumulativeBefore,\n            interestReserve: interestReserve1,\n            pairReserve: pairReserve1,\n            lendReserve: lendReserve1,\n            depositCumulativeLast: deposit1CumulativeBefore,\n            protocolFee: state.protocolFee\n        });\n\n        InterestMath.InterestUpdateResult memory result1 = InterestMath.updateInterestForOne(params1);\n        if (result1.changed) {\n            mirrorReserve1 = result1.newMirrorReserve;\n            pairReserve1 = result1.newPairReserve;\n            lendReserve1 = result1.newLendReserve;\n            interestReserve1 = result1.newInterestReserve;\n        }\n        state.borrow1CumulativeLast = borrow1CumulativeLast;\n        state.deposit1CumulativeLast = result1.newDepositCumulativeLast;\n\n        if (result0.changed || result1.changed) {\n            state.mirrorReserves = toReserves(mirrorReserve0.toUint128(), mirrorReserve1.toUint128());\n            state.pairReserves = toReserves(pairReserve0.toUint128(), pairReserve1.toUint128());\n            state.lendReserves = toReserves(lendReserve0.toUint128(), lendReserve1.toUint128());\n            state.truncatedReserves = PriceMath.transferReserves(\n                _truncatedReserves, state.pairReserves, timeElapsed, state.marginState.maxPriceMovePerSecond()\n            );\n        } else {\n            state.truncatedReserves = state.pairReserves;\n        }\n\n        state.interestReserves = toReserves(interestReserve0.toUint128(), interestReserve1.toUint128());\n    }\n}\n"
    }
}