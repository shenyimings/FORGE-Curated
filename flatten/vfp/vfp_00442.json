{
    "vfp_id": "vfp_00442",
    "project_name": "ackee-blockchain-lido-csm-v2-report.pdf",
    "findings": [
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-369"
                ]
            },
            "title": "W8: Division by zero in processBadPerformanceProof",
            "description": "The `processBadPerformanceProof` function in the CSStrikes contract performs a modulus operation using `keyStrikesList.length` as the divisor without validating that the length is non-zero. The cause is the absence of input validation before arithmetic operations. If `keyStrikesList.length` is zero, this results in a division by zero, triggering a Solidity panic (0x12), which causes the transaction to revert with a low-level panic error instead of a meaningful revert message. This impacts user experience and error handling clarity, as callers cannot distinguish between different failure modes. While it does not lead to fund loss or privilege escalation, it results in poor error reporting and potential confusion during interaction.\n",
            "severity": "Informational",
            "location": [
                "CSStrikes.sol::processBadPerformanceProof#136"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSStrikes.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "W1: Duplicate getSigningKeys call in processBadPerformanceProof",
            "description": "The processBadPerformanceProof function in CSStrikes.sol calls getSigningKeys to obtain a validator's public key, and then passes control to _ejectByStrikes, which calls ejectBadPerformer in CSEjector.sol. The ejectBadPerformer function then calls getSigningKeys again to recompute the same public key, despite the value already being available. This results in unnecessary gas consumption. The root cause is redundant computation across contract boundaries. Although the team acknowledged this and accepted the gas cost for trust boundary reasons, it remains a gas optimization issue. The function is called in a context where the pubkey could be passed as a parameter, eliminating the duplicate call.\n",
            "severity": "Informational",
            "location": [
                "CSStrikes.sol::_ejectByStrikes#221-245",
                "CSEjector.sol::ejectBadPerformer#207-212"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSStrikes.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSEjector.sol"
            ]
        }
    ],
    "affected_files": {
        "CSEjector.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\";\n\nimport { AssetRecoverer } from \"./abstract/AssetRecoverer.sol\";\nimport { ExitTypes } from \"./abstract/ExitTypes.sol\";\n\nimport { PausableUntil } from \"./lib/utils/PausableUntil.sol\";\nimport { SigningKeys } from \"./lib/SigningKeys.sol\";\n\nimport { ICSEjector } from \"./interfaces/ICSEjector.sol\";\nimport { ICSModule } from \"./interfaces/ICSModule.sol\";\nimport { ITriggerableWithdrawalsGateway, ValidatorData } from \"./interfaces/ITriggerableWithdrawalsGateway.sol\";\n\ncontract CSEjector is\n    ICSEjector,\n    ExitTypes,\n    AccessControlEnumerable,\n    PausableUntil,\n    AssetRecoverer\n{\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE = keccak256(\"RESUME_ROLE\");\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n\n    uint256 public immutable STAKING_MODULE_ID;\n    ICSModule public immutable MODULE;\n    address public immutable STRIKES;\n\n    modifier onlyStrikes() {\n        if (msg.sender != STRIKES) {\n            revert SenderIsNotStrikes();\n        }\n\n        _;\n    }\n\n    constructor(\n        address module,\n        address strikes,\n        uint256 stakingModuleId,\n        address admin\n    ) {\n        if (module == address(0)) {\n            revert ZeroModuleAddress();\n        }\n        if (strikes == address(0)) {\n            revert ZeroStrikesAddress();\n        }\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        STRIKES = strikes;\n        MODULE = ICSModule(module);\n        STAKING_MODULE_ID = stakingModuleId;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc ICSEjector\n    function resume() external onlyRole(RESUME_ROLE) {\n        _resume();\n    }\n\n    /// @inheritdoc ICSEjector\n    function pauseFor(uint256 duration) external onlyRole(PAUSE_ROLE) {\n        _pauseFor(duration);\n    }\n\n    /// @inheritdoc ICSEjector\n    function voluntaryEject(\n        uint256 nodeOperatorId,\n        uint256 startFrom,\n        uint256 keysCount,\n        address refundRecipient\n    ) external payable whenResumed {\n        _onlyNodeOperatorOwner(nodeOperatorId);\n\n        {\n            // A key must be deposited to prevent ejecting unvetted keys that can intersect with\n            // other modules.\n            uint256 maxKeyIndex = startFrom + keysCount;\n            if (\n                maxKeyIndex >\n                MODULE.getNodeOperatorTotalDepositedKeys(nodeOperatorId)\n            ) {\n                revert SigningKeysInvalidOffset();\n            }\n            // A key must be non-withdrawn to restrict unlimited exit requests consuming sanity\n            // checker limits, although a deposited key can be requested to exit multiple times.\n            // But, it will eventually be withdrawn, so potentially malicious behaviour stops when\n            // there are no active keys available\n            for (uint256 i = startFrom; i < maxKeyIndex; ++i) {\n                if (MODULE.isValidatorWithdrawn(nodeOperatorId, i)) {\n                    revert AlreadyWithdrawn();\n                }\n            }\n        }\n\n        bytes memory pubkeys = MODULE.getSigningKeys(\n            nodeOperatorId,\n            startFrom,\n            keysCount\n        );\n        ValidatorData[] memory exitsData = new ValidatorData[](keysCount);\n        for (uint256 i; i < keysCount; ++i) {\n            bytes memory pubkey = new bytes(SigningKeys.PUBKEY_LENGTH);\n            assembly {\n                let keyLen := mload(pubkey) // PUBKEY_LENGTH\n                let offset := mul(keyLen, i) // PUBKEY_LENGTH * i\n                let keyPos := add(add(pubkeys, 0x20), offset) // pubkeys[offset]\n                mcopy(add(pubkey, 0x20), keyPos, keyLen) // pubkey = pubkeys[offset:offset+PUBKEY_LENGTH]\n            }\n            exitsData[i] = ValidatorData({\n                stakingModuleId: STAKING_MODULE_ID,\n                nodeOperatorId: nodeOperatorId,\n                pubkey: pubkey\n            });\n        }\n\n        // @dev This call might revert if the limits are exceeded on the protocol side.\n        triggerableWithdrawalsGateway().triggerFullWithdrawals{\n            value: msg.value\n        }(\n            exitsData,\n            refundRecipient == address(0) ? msg.sender : refundRecipient,\n            VOLUNTARY_EXIT_TYPE_ID\n        );\n    }\n\n    /// @dev Additional method for non-sequential keys to save gas and decrease fee amount compared\n    /// to separate transactions.\n    /// @inheritdoc ICSEjector\n    function voluntaryEjectByArray(\n        uint256 nodeOperatorId,\n        uint256[] calldata keyIndices,\n        address refundRecipient\n    ) external payable whenResumed {\n        _onlyNodeOperatorOwner(nodeOperatorId);\n\n        uint256 totalDepositedKeys = MODULE.getNodeOperatorTotalDepositedKeys(\n            nodeOperatorId\n        );\n        ValidatorData[] memory exitsData = new ValidatorData[](\n            keyIndices.length\n        );\n        for (uint256 i = 0; i < keyIndices.length; i++) {\n            // A key must be deposited to prevent ejecting unvetted keys that can intersect with\n            // other modules.\n            if (keyIndices[i] >= totalDepositedKeys) {\n                revert SigningKeysInvalidOffset();\n            }\n            // A key must be non-withdrawn to restrict unlimited exit requests consuming sanity\n            // checker limits, although a deposited key can be requested to exit multiple times.\n            // But, it will eventually be withdrawn, so potentially malicious behaviour stops when\n            // there are no active keys available\n            if (MODULE.isValidatorWithdrawn(nodeOperatorId, keyIndices[i])) {\n                revert AlreadyWithdrawn();\n            }\n            bytes memory pubkey = MODULE.getSigningKeys(\n                nodeOperatorId,\n                keyIndices[i],\n                1\n            );\n            exitsData[i] = ValidatorData({\n                stakingModuleId: STAKING_MODULE_ID,\n                nodeOperatorId: nodeOperatorId,\n                pubkey: pubkey\n            });\n        }\n\n        // @dev This call might revert if the limits are exceeded on the protocol side.\n        triggerableWithdrawalsGateway().triggerFullWithdrawals{\n            value: msg.value\n        }(\n            exitsData,\n            refundRecipient == address(0) ? msg.sender : refundRecipient,\n            VOLUNTARY_EXIT_TYPE_ID\n        );\n    }\n\n    /// @inheritdoc ICSEjector\n    function ejectBadPerformer(\n        uint256 nodeOperatorId,\n        uint256 keyIndex,\n        address refundRecipient\n    ) external payable whenResumed onlyStrikes {\n        // A key must be deposited to prevent ejecting unvetted keys that can intersect with\n        // other modules.\n        if (\n            keyIndex >= MODULE.getNodeOperatorTotalDepositedKeys(nodeOperatorId)\n        ) {\n            revert SigningKeysInvalidOffset();\n        }\n        // A key must be non-withdrawn to restrict unlimited exit requests consuming sanity checker\n        // limits, although a deposited key can be requested to exit multiple times. But, it will\n        // eventually be withdrawn, so potentially malicious behaviour stops when there are no\n        // active keys available\n        if (MODULE.isValidatorWithdrawn(nodeOperatorId, keyIndex)) {\n            revert AlreadyWithdrawn();\n        }\n\n        ValidatorData[] memory exitsData = new ValidatorData[](1);\n        bytes memory pubkey = MODULE.getSigningKeys(\n            nodeOperatorId,\n            keyIndex,\n            1\n        );\n        exitsData[0] = ValidatorData({\n            stakingModuleId: STAKING_MODULE_ID,\n            nodeOperatorId: nodeOperatorId,\n            pubkey: pubkey\n        });\n\n        // @dev This call might revert if the limits are exceeded on the protocol side.\n        triggerableWithdrawalsGateway().triggerFullWithdrawals{\n            value: msg.value\n        }(exitsData, refundRecipient, STRIKES_EXIT_TYPE_ID);\n    }\n\n    /// @inheritdoc ICSEjector\n    function triggerableWithdrawalsGateway()\n        public\n        view\n        returns (ITriggerableWithdrawalsGateway)\n    {\n        return\n            ITriggerableWithdrawalsGateway(\n                MODULE.LIDO_LOCATOR().triggerableWithdrawalsGateway()\n            );\n    }\n\n    /// @dev Verifies that the sender is the owner of the node operator\n    function _onlyNodeOperatorOwner(uint256 nodeOperatorId) internal view {\n        address owner = MODULE.getNodeOperatorOwner(nodeOperatorId);\n        if (owner == address(0)) {\n            revert NodeOperatorDoesNotExist();\n        }\n        if (owner != msg.sender) {\n            revert SenderIsNotEligible();\n        }\n    }\n\n    function _onlyRecoverer() internal view override {\n        _checkRole(RECOVERER_ROLE);\n    }\n}\n",
        "CSStrikes.sol": "// SPDX-FileCopyrightText: 2025 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.24;\n\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\n\nimport { ICSModule } from \"./interfaces/ICSModule.sol\";\nimport { ICSAccounting } from \"./interfaces/ICSAccounting.sol\";\nimport { ICSExitPenalties } from \"./interfaces/ICSExitPenalties.sol\";\nimport { ICSParametersRegistry } from \"./interfaces/ICSParametersRegistry.sol\";\nimport { ICSEjector } from \"./interfaces/ICSEjector.sol\";\nimport { ICSStrikes } from \"./interfaces/ICSStrikes.sol\";\n\n/// @author vgorkavenko\ncontract CSStrikes is\n    ICSStrikes,\n    Initializable,\n    AccessControlEnumerableUpgradeable\n{\n    address public immutable ORACLE;\n    ICSModule public immutable MODULE;\n    ICSAccounting public immutable ACCOUNTING;\n    ICSExitPenalties public immutable EXIT_PENALTIES;\n    ICSParametersRegistry public immutable PARAMETERS_REGISTRY;\n\n    ICSEjector public ejector;\n\n    /// @notice The latest Merkle Tree root\n    bytes32 public treeRoot;\n\n    /// @notice CID of the last published Merkle tree\n    string public treeCid;\n\n    modifier onlyOracle() {\n        if (msg.sender != ORACLE) {\n            revert SenderIsNotOracle();\n        }\n\n        _;\n    }\n\n    constructor(\n        address module,\n        address oracle,\n        address exitPenalties,\n        address parametersRegistry\n    ) {\n        if (module == address(0)) {\n            revert ZeroModuleAddress();\n        }\n        if (oracle == address(0)) {\n            revert ZeroOracleAddress();\n        }\n        if (exitPenalties == address(0)) {\n            revert ZeroExitPenaltiesAddress();\n        }\n        if (parametersRegistry == address(0)) {\n            revert ZeroParametersRegistryAddress();\n        }\n\n        MODULE = ICSModule(module);\n        ACCOUNTING = MODULE.accounting();\n        EXIT_PENALTIES = ICSExitPenalties(exitPenalties);\n        ORACLE = oracle;\n        PARAMETERS_REGISTRY = ICSParametersRegistry(parametersRegistry);\n\n        _disableInitializers();\n    }\n\n    function initialize(address admin, address _ejector) external initializer {\n        if (admin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n\n        _setEjector(_ejector);\n\n        __AccessControlEnumerable_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc ICSStrikes\n    function setEjector(\n        address _ejector\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setEjector(_ejector);\n    }\n\n    /// @inheritdoc ICSStrikes\n    function processOracleReport(\n        bytes32 _treeRoot,\n        string calldata _treeCid\n    ) external onlyOracle {\n        // @dev should be both empty or not empty\n        bool isNewRootEmpty = _treeRoot == bytes32(0);\n        bool isNewCidEmpty = bytes(_treeCid).length == 0;\n        if (isNewRootEmpty != isNewCidEmpty) {\n            revert InvalidReportData();\n        }\n\n        if (isNewRootEmpty) {\n            if (treeRoot != bytes32(0)) {\n                delete treeRoot;\n                delete treeCid;\n                emit StrikesDataWiped();\n            }\n            return;\n        }\n\n        bool isSameRoot = _treeRoot == treeRoot;\n        bool isSameCid = keccak256(bytes(_treeCid)) ==\n            keccak256(bytes(treeCid));\n        if (isSameRoot != isSameCid) {\n            revert InvalidReportData();\n        }\n\n        if (!isSameRoot) {\n            treeRoot = _treeRoot;\n            treeCid = _treeCid;\n            emit StrikesDataUpdated(_treeRoot, _treeCid);\n        }\n    }\n\n    /// @inheritdoc ICSStrikes\n    function processBadPerformanceProof(\n        KeyStrikes[] calldata keyStrikesList,\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        address refundRecipient\n    ) external payable {\n        // NOTE: We allow empty proofs to be delivered because there’s no way to use the tree’s\n        // internal nodes without brute-forcing the input data.\n\n        if (msg.value % keyStrikesList.length > 0) {\n            revert ValueNotEvenlyDivisible();\n        }\n\n        bytes[] memory pubkeys = new bytes[](keyStrikesList.length);\n        for (uint256 i; i < pubkeys.length; ++i) {\n            pubkeys[i] = MODULE.getSigningKeys(\n                keyStrikesList[i].nodeOperatorId,\n                keyStrikesList[i].keyIndex,\n                1\n            );\n        }\n\n        if (!verifyProof(keyStrikesList, pubkeys, proof, proofFlags)) {\n            revert InvalidProof();\n        }\n\n        refundRecipient = refundRecipient == address(0)\n            ? msg.sender\n            : refundRecipient;\n\n        uint256 valuePerKey = msg.value / keyStrikesList.length;\n        for (uint256 i; i < keyStrikesList.length; ++i) {\n            _ejectByStrikes(\n                keyStrikesList[i],\n                pubkeys[i],\n                valuePerKey,\n                refundRecipient\n            );\n        }\n    }\n\n    /// @inheritdoc ICSStrikes\n    function getInitializedVersion() external view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    /// @inheritdoc ICSStrikes\n    function verifyProof(\n        KeyStrikes[] calldata keyStrikesList,\n        bytes[] memory pubkeys,\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags\n    ) public view returns (bool) {\n        bytes32[] memory leaves = new bytes32[](keyStrikesList.length);\n        for (uint256 i; i < leaves.length; i++) {\n            leaves[i] = hashLeaf(keyStrikesList[i], pubkeys[i]);\n        }\n\n        return\n            MerkleProof.multiProofVerifyCalldata(\n                proof,\n                proofFlags,\n                treeRoot,\n                leaves\n            );\n    }\n\n    /// @inheritdoc ICSStrikes\n    function hashLeaf(\n        KeyStrikes calldata keyStrikes,\n        bytes memory pubkey\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                bytes.concat(\n                    keccak256(\n                        abi.encode(\n                            keyStrikes.nodeOperatorId,\n                            pubkey,\n                            keyStrikes.data\n                        )\n                    )\n                )\n            );\n    }\n\n    function _setEjector(address _ejector) internal {\n        if (_ejector == address(0)) {\n            revert ZeroEjectorAddress();\n        }\n        ejector = ICSEjector(_ejector);\n        emit EjectorSet(_ejector);\n    }\n\n    function _ejectByStrikes(\n        KeyStrikes calldata keyStrikes,\n        bytes memory pubkey,\n        uint256 value,\n        address refundRecipient\n    ) internal {\n        uint256 strikes = 0;\n        for (uint256 i; i < keyStrikes.data.length; ++i) {\n            strikes += keyStrikes.data[i];\n        }\n\n        uint256 curveId = ACCOUNTING.getBondCurveId(keyStrikes.nodeOperatorId);\n\n        (, uint256 threshold) = PARAMETERS_REGISTRY.getStrikesParams(curveId);\n        if (strikes < threshold) {\n            revert NotEnoughStrikesToEject();\n        }\n\n        ejector.ejectBadPerformer{ value: value }(\n            keyStrikes.nodeOperatorId,\n            keyStrikes.keyIndex,\n            refundRecipient\n        );\n        EXIT_PENALTIES.processStrikesReport(keyStrikes.nodeOperatorId, pubkey);\n    }\n}\n"
    }
}