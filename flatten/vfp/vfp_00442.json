{
    "vfp_id": "vfp_00442",
    "project_name": "ackee-blockchain-safe-smart-account-report.pdf",
    "findings": [
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "ChangedThreshold event is emitted unconditionally",
            "description": "The OwnerManager.changeThreshold function emits the ChangedThreshold event even when the new threshold value is the same as the current one. This can mislead off-chain services into thinking a state change occurred when it did not. The root cause is the lack of a value comparison before event emission. While consistent with other events in the codebase, it reduces event reliability. The impact is informational. The client acknowledged the finding but chose not to fix it, citing low value and consistency with existing patterns.\n",
            "severity": "Informational",
            "location": [
                "OwnerManager.sol::changeThreshold#110-114"
            ],
            "files": [
                "safe-smart-account/contracts/base/OwnerManager.sol"
            ]
        }
    ],
    "affected_files": {
        "OwnerManager.sol": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IOwnerManager} from \"../interfaces/IOwnerManager.sol\";\n\n/**\n * @title OwnerManager - Manages Safe owners and a threshold to authorize transactions.\n * @dev Uses a linked list to store the owners because the code generated by the solidity compiler\n *      is more efficient than using a dynamic array.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\nabstract contract OwnerManager is SelfAuthorized, IOwnerManager {\n    // SENTINEL_OWNERS is used to traverse `owners`, so that:\n    //      1. `owners[SENTINEL_OWNERS]` contains the first owner\n    //      2. `owners[last_owner]` points back to SENTINEL_OWNERS\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /**\n     * @notice Sets the initial storage of the contract.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     */\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that the setup function can only be called once.\n        if (threshold > 0) revertWithError(\"GS200\");\n        // Validate that the threshold is smaller than the number of added owners.\n        if (_threshold > _owners.length) revertWithError(\"GS201\");\n        // There has to be at least one Safe owner.\n        if (_threshold == 0) revertWithError(\"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        uint256 ownersLength = _owners.length;\n        for (uint256 i = 0; i < ownersLength; ++i) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this) || currentOwner == owner)\n                revertWithError(\"GS203\");\n            // No duplicate owners allowed.\n            if (owners[owner] != address(0)) revertWithError(\"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = ownersLength;\n        threshold = _threshold;\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public override authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this)) revertWithError(\"GS203\");\n        // No duplicate owners allowed.\n        if (owners[owner] != address(0)) revertWithError(\"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ++ownerCount;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) public override authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // Here we do pre-decrement as it is cheaper and allows us to check if the threshold is still reachable.\n        if (--ownerCount < _threshold) revertWithError(\"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        if (owner == address(0) || owner == SENTINEL_OWNERS) revertWithError(\"GS203\");\n        if (owners[prevOwner] != owner) revertWithError(\"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) public override authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        if (newOwner == address(0) || newOwner == SENTINEL_OWNERS || newOwner == address(this)) revertWithError(\"GS203\");\n        // No duplicate owners allowed.\n        if (owners[newOwner] != address(0)) revertWithError(\"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        if (oldOwner == address(0) || oldOwner == SENTINEL_OWNERS) revertWithError(\"GS203\");\n        if (owners[prevOwner] != oldOwner) revertWithError(\"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function changeThreshold(uint256 _threshold) public override authorized {\n        // Validate that threshold is smaller than number of owners.\n        if (_threshold > ownerCount) revertWithError(\"GS201\");\n        // There has to be at least one Safe owner.\n        if (_threshold == 0) revertWithError(\"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(_threshold);\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function getThreshold() public view override returns (uint256) {\n        return threshold;\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function isOwner(address owner) public view override returns (bool) {\n        return !(owner == SENTINEL_OWNERS || owners[owner] == address(0));\n    }\n\n    /**\n     * @inheritdoc IOwnerManager\n     */\n    function getOwners() public view override returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            ++index;\n        }\n        return array;\n    }\n}\n"
    }
}