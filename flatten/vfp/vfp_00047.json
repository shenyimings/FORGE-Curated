{
    "vfp_id": "vfp_00047",
    "project_name": "ChainSecurity_MellowFinance_Multivault_Audit.pdf",
    "findings": [
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Lack of Events",
            "description": "Several important state changes (e.g., `transferPendingAssets`, `setRatio`) do not emit events, making it difficult for off-chain systems to track activity. Missing event emissions in key functions. Frontends and indexers cannot reliably monitor user actions or protocol state changes. Poor observability and degraded user experience due to lack of real-time updates.\n",
            "severity": "Informational",
            "location": [
                "SymbioticWithdrawalQueue.transferPendingAssets",
                "RatioStrategy.setRatio"
            ],
            "files": [
                "simple-lrt/src/queues/SymbioticWithdrawalQueue.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Inconsistent Event Argument Amount in Event Transfer",
            "description": "The `Transfer` event in `SymbioticWithdrawalQueue.transferPendingAssets` emits `_amount` in inconsistent unitsâ€”sometimes in shares, sometimes in tokens. The event is emitted with different value types depending on which epoch's assets are being transferred. External systems (e.g., indexers, frontends) may misinterpret the transferred amount, leading to incorrect balance tracking. Poor integration reliability and potential user confusion due to inconsistent event data.\n",
            "severity": "Informational",
            "location": [
                "SymbioticWithdrawalQueue.transferPendingAssets",
                "event Transfer"
            ],
            "files": [
                "simple-lrt/src/queues/SymbioticWithdrawalQueue.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-703"
                ]
            },
            "title": "Sending Pending Assets to Yourself Leads to Losses",
            "description": "The `SymbioticWithdrawalQueue.transferPendingAssets` function does not handle self-transfers correctly, leading to incorrect accounting where the sender's balance is deleted after being credited. The function adds shares to the receiver (which is the same as the sender) and then deletes the sender's record, resulting in a net loss of pending assets. A user transferring pending assets to themselves could lose those assets due to flawed accounting logic. Users may suffer unexpected fund loss when attempting self-transfers of pending withdrawals.\n",
            "severity": "Low",
            "location": [
                "SymbioticWithdrawalQueue.transferPendingAssets"
            ],
            "files": [
                "simple-lrt/src/queues/SymbioticWithdrawalQueue.sol"
            ]
        }
    ],
    "affected_files": {
        "SymbioticWithdrawalQueue.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.25;\n\nimport \"../interfaces/queues/ISymbioticWithdrawalQueue.sol\";\n\ncontract SymbioticWithdrawalQueue is ISymbioticWithdrawalQueue, Initializable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    /// @inheritdoc IWithdrawalQueue\n    address public immutable claimer;\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    address public vault;\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    ISymbioticVault public symbioticVault;\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    address public collateral;\n\n    mapping(uint256 epoch => EpochData data) private _epochData;\n    mapping(address account => AccountData data) private _accountData;\n\n    constructor(address claimer_) {\n        claimer = claimer_;\n        _disableInitializers();\n    }\n\n    function initialize(address vault_, address symbioticVault_) external initializer {\n        __init_SymbioticWithdrawalQueue(vault_, symbioticVault_);\n    }\n\n    function __init_SymbioticWithdrawalQueue(address vault_, address symbioticVault_)\n        internal\n        onlyInitializing\n    {\n        vault = vault_;\n        symbioticVault = ISymbioticVault(symbioticVault_);\n        collateral = ISymbioticVault(symbioticVault_).collateral();\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function getCurrentEpoch() public view returns (uint256) {\n        return symbioticVault.currentEpoch();\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function getAccountData(address account)\n        external\n        view\n        returns (\n            uint256 sharesToClaimPrev,\n            uint256 sharesToClaim,\n            uint256 claimableAssets,\n            uint256 claimEpoch\n        )\n    {\n        AccountData storage accountData = _accountData[account];\n        claimEpoch = accountData.claimEpoch;\n        sharesToClaimPrev = claimEpoch == 0 ? 0 : accountData.sharesToClaim[claimEpoch - 1];\n        sharesToClaim = accountData.sharesToClaim[claimEpoch];\n        claimableAssets = accountData.claimableAssets;\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function getEpochData(uint256 epoch) external view returns (EpochData memory) {\n        return _epochData[epoch];\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function pendingAssets() public view returns (uint256) {\n        uint256 epoch = getCurrentEpoch();\n        address this_ = address(this);\n        ISymbioticVault symbioticVault_ = symbioticVault;\n        return symbioticVault_.withdrawalsOf(epoch, this_)\n            + symbioticVault_.withdrawalsOf(epoch + 1, this_);\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function pendingAssetsOf(address account) public view returns (uint256 assets) {\n        uint256 epoch = getCurrentEpoch();\n\n        AccountData storage accountData = _accountData[account];\n        assets += _withdrawalsOf(epoch, accountData.sharesToClaim[epoch]);\n        epoch += 1;\n        assets += _withdrawalsOf(epoch, accountData.sharesToClaim[epoch]);\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function claimableAssetsOf(address account) public view returns (uint256 assets) {\n        AccountData storage accountData = _accountData[account];\n        assets = accountData.claimableAssets;\n\n        uint256 currentEpoch = getCurrentEpoch();\n        uint256 epoch = accountData.claimEpoch;\n        if (epoch > 0 && _isClaimableInSymbiotic(epoch - 1, currentEpoch)) {\n            assets += _claimable(accountData, epoch - 1);\n        }\n\n        if (_isClaimableInSymbiotic(epoch, currentEpoch)) {\n            assets += _claimable(accountData, epoch);\n        }\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function request(address account, uint256 amount) external {\n        require(msg.sender == vault, \"SymbioticWithdrawalQueue: forbidden\");\n        if (amount == 0) {\n            return;\n        }\n        AccountData storage accountData = _accountData[account];\n\n        uint256 epoch = getCurrentEpoch();\n        _handlePendingEpochs(accountData, epoch);\n\n        epoch = epoch + 1;\n        EpochData storage epochData = _epochData[epoch];\n        epochData.sharesToClaim += amount;\n\n        accountData.sharesToClaim[epoch] += amount;\n        accountData.claimEpoch = epoch;\n        emit WithdrawalRequested(account, epoch, amount);\n    }\n\n    /// @inheritdoc IWithdrawalQueue\n    function transferPendingAssets(address to, uint256 amount) external {\n        address from = msg.sender;\n        if (amount == 0 || from == to) {\n            return;\n        }\n\n        uint256 epoch = getCurrentEpoch();\n        uint256 nextEpoch = epoch + 1;\n        AccountData storage fromData = _accountData[from];\n        AccountData storage toData = _accountData[to];\n        _handlePendingEpochs(fromData, epoch);\n        _handlePendingEpochs(toData, epoch);\n\n        uint256 nextSharesToClaim = fromData.sharesToClaim[nextEpoch];\n        uint256 nextPending = _withdrawalsOf(nextEpoch, nextSharesToClaim);\n        if (nextPending >= amount) {\n            uint256 shares = nextSharesToClaim.mulDiv(amount, nextPending);\n            fromData.sharesToClaim[nextEpoch] -= shares;\n            toData.sharesToClaim[nextEpoch] += shares;\n            toData.claimEpoch = nextEpoch;\n            emit Transfer(from, to, nextEpoch, shares);\n        } else {\n            uint256 currentSharesToClaim = fromData.sharesToClaim[epoch];\n            uint256 currentPending = _withdrawalsOf(epoch, currentSharesToClaim);\n            require(\n                nextPending + currentPending >= amount,\n                \"SymbioticWithdrawalQueue: insufficient pending assets\"\n            );\n\n            if (nextSharesToClaim != 0) {\n                toData.sharesToClaim[nextEpoch] += nextSharesToClaim;\n                delete fromData.sharesToClaim[nextEpoch];\n                amount -= nextPending;\n                emit Transfer(from, to, nextEpoch, nextSharesToClaim);\n            }\n\n            uint256 shares = currentSharesToClaim.mulDiv(amount, currentPending);\n            fromData.sharesToClaim[epoch] = currentSharesToClaim - shares;\n            toData.sharesToClaim[epoch] += shares;\n            toData.claimEpoch = nextEpoch;\n            emit Transfer(from, to, epoch, shares);\n        }\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function pull(uint256 epoch) public {\n        require(\n            _isClaimableInSymbiotic(epoch, getCurrentEpoch()),\n            \"SymbioticWithdrawalQueue: invalid epoch\"\n        );\n        _pullFromSymbioticForEpoch(epoch);\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function claim(address account, address recipient, uint256 maxAmount)\n        external\n        returns (uint256 amount)\n    {\n        address sender = msg.sender;\n        require(sender == account || sender == claimer, \"SymbioticWithdrawalQueue: forbidden\");\n        AccountData storage accountData = _accountData[account];\n        _handlePendingEpochs(accountData, getCurrentEpoch());\n        amount = accountData.claimableAssets;\n        if (amount == 0) {\n            return 0;\n        }\n        if (amount <= maxAmount) {\n            accountData.claimableAssets = 0;\n        } else {\n            amount = maxAmount;\n            accountData.claimableAssets -= maxAmount;\n        }\n        if (amount != 0) {\n            IERC20(collateral).safeTransfer(recipient, amount);\n        }\n        emit Claimed(account, recipient, amount);\n    }\n\n    /// @inheritdoc ISymbioticWithdrawalQueue\n    function handlePendingEpochs(address account) public {\n        _handlePendingEpochs(_accountData[account], getCurrentEpoch());\n    }\n\n    /**\n     * @notice Calculates the amount of collateral that will be withdrawn for the given `shares` at the specified epoch.\n     * @param epoch The epoch number in the Symbiotic Vault.\n     * @param shares The amount of withdrawal shares.\n     * @return assets The corresponding amount of collateral that will be withdrawn based on the `shares`.\n     */\n    function _withdrawalsOf(uint256 epoch, uint256 shares) private view returns (uint256) {\n        if (shares == 0) {\n            return 0;\n        }\n        return shares.mulDiv(\n            symbioticVault.withdrawalsOf(epoch, address(this)), _epochData[epoch].sharesToClaim\n        );\n    }\n\n    /**\n     * @notice Claims collateral from the Symbiotic Vault for the given account at the current and previous epochs.\n     * @dev This function updates the `epochData` and `accountData` mappings accordingly.\n     * @param accountData The storage struct containing specific claim data for the account.\n     * @param currentEpoch The current epoch in the Symbiotic Vault.\n     *\n     * @custom:requirements\n     * - If `claimEpoch` is zero, no claims are made for `epochEpoch` - 1.\n     * - If `claimEpoch` is non-zero, collateral is claimed for both `claimEpoch` and `claimEpoch`-1.\n     * - Ensures that both `claimEpoch` and `claimEpoch`-1 are claimable.\n     *\n     * @custom:effects\n     * - Emits `EpochClaimed` event when claims are successfully made.\n     */\n    function _handlePendingEpochs(AccountData storage accountData, uint256 currentEpoch) private {\n        uint256 epoch = accountData.claimEpoch;\n        if (epoch > 0) {\n            _handlePendingEpoch(accountData, epoch - 1, currentEpoch);\n        }\n        _handlePendingEpoch(accountData, epoch, currentEpoch);\n    }\n\n    /**\n     * @notice Claims collateral from the Symbiotic Vault for the given `epoch`.\n     * @dev This function updates the `epochData` and `accountData` mappings.\n     * @param accountData The storage struct containing specific claim data for the account.\n     * @param epoch The epoch number from which the claim is made.\n     * @param currentEpoch The current epoch in the Symbiotic Vault.\n     *\n     * @custom:requirements\n     * - If `epoch` is not claimable, no claims are made.\n     *\n     * @custom:effects\n     * - Emits `EpochClaimed` event when claims are successfully made.\n     */\n    function _handlePendingEpoch(\n        AccountData storage accountData,\n        uint256 epoch,\n        uint256 currentEpoch\n    ) private {\n        if (!_isClaimableInSymbiotic(epoch, currentEpoch)) {\n            return;\n        }\n        uint256 shares = accountData.sharesToClaim[epoch];\n        if (shares == 0) {\n            return;\n        }\n        _pullFromSymbioticForEpoch(epoch);\n\n        EpochData storage epochData = _epochData[epoch];\n        uint256 assets = shares.mulDiv(epochData.claimableAssets, epochData.sharesToClaim);\n\n        epochData.sharesToClaim -= shares;\n        epochData.claimableAssets -= assets;\n\n        accountData.claimableAssets += assets;\n        delete accountData.sharesToClaim[epoch];\n    }\n\n    /**\n     * @notice Claims collateral from the Symbiotic Vault for the given `epoch`.\n     * @dev This function ensures that the withdrawals for the specified `epoch` are not claimed from the Symbiotic Vault.\n     * @param epoch The epoch number for which the collateral is being claimed.\n     *\n     * @custom:requirements\n     * - Checks that the collateral for the given `epoch` has not already been claimed.\n     * - Checks whether there are any claimable withdrawals for the given `epoch`.\n     *\n     * @custom:effects\n     * - Emits `EpochClaimed` event when the claim is successful.\n     */\n    function _pullFromSymbioticForEpoch(uint256 epoch) private {\n        EpochData storage epochData = _epochData[epoch];\n        if (epochData.isClaimed) {\n            return;\n        }\n        epochData.isClaimed = true;\n        address this_ = address(this);\n        ISymbioticVault symbioticVault_ = symbioticVault;\n        if (symbioticVault_.isWithdrawalsClaimed(epoch, this_)) {\n            return;\n        }\n        if (symbioticVault_.withdrawalsOf(epoch, this_) == 0) {\n            return;\n        }\n        uint256 claimedAssets = symbioticVault_.claim(this_, epoch);\n        epochData.claimableAssets = claimedAssets;\n        emit EpochClaimed(epoch, claimedAssets);\n    }\n\n    /**\n     * @notice Returns the claimable collateral amount for a given `accountData` at a specific `epoch`.\n     * @param accountData The storage struct containing specific claim data for the account.\n     * @param epoch The epoch number at which the claim is being checked.\n     * @return The amount of claimable collateral corresponding to the given account's shares at the specified epoch.\n     */\n    function _claimable(AccountData storage accountData, uint256 epoch)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 shares = accountData.sharesToClaim[epoch];\n        if (shares == 0) {\n            return 0;\n        }\n        EpochData storage epochData = _epochData[epoch];\n        if (epochData.isClaimed) {\n            return shares.mulDiv(epochData.claimableAssets, epochData.sharesToClaim);\n        }\n        return _withdrawalsOf(epoch, shares);\n    }\n\n    /**\n     * @notice Determines whether the given `epoch` is claimable based on the current epoch.\n     * @param epoch The epoch number to check.\n     * @param currentEpoch The current epoch in the Symbiotic Vault.\n     * @return True if the epoch is claimable (i.e., it is less than the current epoch), false otherwise.\n     */\n    function _isClaimableInSymbiotic(uint256 epoch, uint256 currentEpoch)\n        private\n        pure\n        returns (bool)\n    {\n        return epoch < currentEpoch;\n    }\n}\n"
    }
}