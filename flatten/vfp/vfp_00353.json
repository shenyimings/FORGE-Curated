{
    "vfp_id": "vfp_00353",
    "project_name": "Virtuals Protocol AI Agents - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "If two different AgentDAO have two proposals with the same proposalID it will be impossible to mint a contributionNFT",
            "description": "The ContributionNft::mint() function uses the proposalId derived from hashing proposal parameters, including description. If two different AgentDAOs create proposals with identical parameters (targets, values, calldatas, description), they will generate the same proposalId. Since NFT IDs are based on proposalId, minting a contributionNFT for the second proposal will fail due to ID collision. This is caused by the lack of scoping the proposalId to the AgentDAO contract address. The impact is that valid contributions may be blocked from minting NFTs, leading to loss of recognition or rewards.\n",
            "severity": "Low",
            "location": [
                "ContributionNf.solt"
            ],
            "files": [
                "protocol-contracts/contracts/contribution/ContributionNft.sol"
            ]
        }
    ],
    "affected_files": {
        "ContributionNft.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./IContributionNft.sol\";\nimport \"../virtualPersona/IAgentNft.sol\";\n\ncontract ContributionNft is\n    IContributionNft,\n    Initializable,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable\n{\n    address public personaNft;\n\n    mapping(uint256 => uint256) private _contributionVirtualId;\n    mapping(uint256 => uint256) private _parents;\n    mapping(uint256 => uint256[]) private _children;\n    mapping(uint256 => uint8) private _cores;\n\n    mapping(uint256 => bool) public modelContributions;\n    mapping(uint256 => uint256) public modelDatasets;\n\n    event NewContribution(\n        uint256 tokenId,\n        uint256 virtualId,\n        uint256 parentId,\n        uint256 datasetId\n    );\n\n    address private _admin; // Admin is able to create contribution proposal without votes\n\n    address private _eloCalculator;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address thePersonaAddress) public initializer {\n        __ERC721_init(\"Contribution\", \"VC\");\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        \n        personaNft = thePersonaAddress;\n        _admin = _msgSender();\n    }\n\n    function tokenVirtualId(uint256 tokenId) public view returns (uint256) {\n        return _contributionVirtualId[tokenId];\n    }\n\n    function getAgentDAO(uint256 virtualId) public view returns (IGovernor) {\n        return IGovernor(IAgentNft(personaNft).virtualInfo(virtualId).dao);\n    }\n\n    function isAccepted(uint256 tokenId) public view returns (bool) {\n        uint256 virtualId = _contributionVirtualId[tokenId];\n        IGovernor personaDAO = getAgentDAO(virtualId);\n        return personaDAO.state(tokenId) == IGovernor.ProposalState.Succeeded;\n    }\n\n    function mint(\n        address to,\n        uint256 virtualId,\n        uint8 coreId,\n        string memory newTokenURI,\n        uint256 proposalId,\n        uint256 parentId,\n        bool isModel_,\n        uint256 datasetId\n    ) external returns (uint256) {\n        IGovernor personaDAO = getAgentDAO(virtualId);\n        require(\n            msg.sender == personaDAO.proposalProposer(proposalId),\n            \"Only proposal proposer can mint Contribution NFT\"\n        );\n        require(parentId != proposalId, \"Cannot be parent of itself\");\n\n        _mint(to, proposalId);\n        _setTokenURI(proposalId, newTokenURI);\n        _contributionVirtualId[proposalId] = virtualId;\n        _parents[proposalId] = parentId;\n        _children[parentId].push(proposalId);\n        _cores[proposalId] = coreId;\n\n        if (isModel_) {\n            modelContributions[proposalId] = true;\n            modelDatasets[proposalId] = datasetId;\n        }\n\n        emit NewContribution(proposalId, virtualId, parentId, datasetId);\n\n        return proposalId;\n    }\n\n    function getAdmin() public view override returns (address) {\n        return _admin;\n    }\n\n    function setAdmin(address newAdmin) public {\n        require(_msgSender() == _admin, \"Only admin can set admin\");\n        _admin = newAdmin;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(\n            IContributionNft,\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable\n        )\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function getChildren(\n        uint256 tokenId\n    ) public view returns (uint256[] memory) {\n        return _children[tokenId];\n    }\n\n    function getParentId(uint256 tokenId) public view returns (uint256) {\n        return _parents[tokenId];\n    }\n\n    function getCore(uint256 tokenId) public view returns (uint8) {\n        return _cores[tokenId];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        return super._increaseBalance(account, amount);\n    }\n\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n\n    function isModel(uint256 tokenId) public view returns (bool) {\n        return modelContributions[tokenId];\n    }\n\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721Upgradeable) returns (address) {\n        return _ownerOf(tokenId);\n    }\n\n    function getDatasetId(uint256 tokenId) external view returns (uint256) {\n        return modelDatasets[tokenId];\n    }\n\n    function getEloCalculator() external view returns (address) {\n        return _eloCalculator;\n    }\n\n    function setEloCalculator(address eloCalculator_) public {\n        require(_msgSender() == _admin, \"Only admin can set elo calculator\");\n        _eloCalculator = eloCalculator_;\n    }\n}\n"
    }
}