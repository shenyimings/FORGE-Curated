{
    "vfp_id": "vfp_00057",
    "project_name": "cantina_centrifuge_may2025.pdf",
    "findings": [
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Non-batched Hub transactions may fail to relay payload data to adapters",
            "description": "Non-batched transactions in the Hub contract, specifically notifyDeposit and notifyRedeem, may fail to relay payload data correctly due to incorrect gas handling in the internal _pay function. The function attempts to subsidize multiple Gateway.send() calls but refunds gas after the first call, causing subsequent sends to be underpaid and fail. The root cause is improper gas budgeting and refund logic in a multi-call context. An attacker could exploit this by forcing non-batched execution paths and causing partial transaction failures, leading to inconsistent state. The impact is incomplete execution of cross-chain messages, resulting in failed updates on destination chains and poor user experience.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "protocol-v3/src/hub/Hub.sol"
            ]
        }
    ],
    "affected_files": {
        "Hub.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {Multicall, IMulticall} from \"src/misc/Multicall.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\n\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IHubGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {IPoolMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {IAccounting, JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\nimport {IHoldings, HoldingAccount} from \"src/hub/interfaces/IHoldings.sol\";\nimport {IHub, AccountType} from \"src/hub/interfaces/IHub.sol\";\n\n/// @title  Hub\n/// @notice Central pool management contract, that brings together all functions in one place.\n///         Pools can assign hub managers which have full rights over all actions.\n///\n///         Also acts as the central contract that routes messages from other chains to the Hub contracts.\ncontract Hub is Multicall, Auth, Recoverable, IHub, IHubGatewayHandler {\n    using MathLib for uint256;\n\n    IHubRegistry public immutable hubRegistry;\n\n    IGateway public gateway;\n    IHoldings public holdings;\n    IAccounting public accounting;\n    IPoolMessageSender public sender;\n    IShareClassManager public shareClassManager;\n\n    constructor(\n        IShareClassManager shareClassManager_,\n        IHubRegistry hubRegistry_,\n        IAccounting accounting_,\n        IHoldings holdings_,\n        IGateway gateway_,\n        address deployer\n    ) Auth(deployer) {\n        shareClassManager = shareClassManager_;\n        hubRegistry = hubRegistry_;\n        accounting = accounting_;\n        holdings = holdings_;\n        gateway = gateway_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // System methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function file(bytes32 what, address data) external {\n        _auth();\n\n        if (what == \"sender\") sender = IPoolMessageSender(data);\n        else if (what == \"holdings\") holdings = IHoldings(data);\n        else if (what == \"accounting\") accounting = IAccounting(data);\n        else if (what == \"shareClassManager\") shareClassManager = IShareClassManager(data);\n        else if (what == \"gateway\") gateway = IGateway(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IMulticall\n    /// @notice performs a multicall but all messages sent in the process will be batched\n    function multicall(bytes[] calldata data) public payable override {\n        bool wasBatching = gateway.isBatching();\n        if (!wasBatching) {\n            gateway.startBatching();\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n\n        super.multicall(data);\n\n        if (!wasBatching) {\n            gateway.endBatching();\n        }\n    }\n\n    /// @inheritdoc IHub\n    function createPool(PoolId poolId, address admin, AssetId currency) external payable {\n        _auth();\n\n        require(poolId.centrifugeId() == sender.localCentrifugeId(), InvalidPoolId());\n        hubRegistry.registerPool(poolId, admin, currency);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Permissionless methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function notifyDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable\n    {\n        _pay();\n\n        uint128 totalPayoutShareAmount;\n        uint128 totalPaymentAssetAmount;\n        uint128 cancelledAssetAmount;\n\n        for (uint32 i = 0; i < maxClaims; i++) {\n            (uint128 payoutShareAmount, uint128 paymentAssetAmount, uint128 cancelled, bool canClaimAgain) =\n                shareClassManager.claimDeposit(poolId, scId, investor, assetId);\n\n            totalPayoutShareAmount += payoutShareAmount;\n            totalPaymentAssetAmount += paymentAssetAmount;\n\n            // Should be written at most once with non-zero amount iff the last claimable epoch was processed and\n            // the user had a pending cancellation\n            // NOTE: Purposely delaying corresponding message dispatch after deposit fulfillment message\n            if (cancelled > 0) {\n                cancelledAssetAmount = cancelled;\n            }\n\n            if (!canClaimAgain) {\n                break;\n            }\n        }\n\n        sender.sendFulfilledDepositRequest(\n            poolId, scId, assetId, investor, totalPaymentAssetAmount, totalPayoutShareAmount\n        );\n\n        // If cancellation was queued, notify about delayed cancellation\n        if (cancelledAssetAmount > 0) {\n            sender.sendFulfilledCancelDepositRequest(poolId, scId, assetId, investor, cancelledAssetAmount);\n        }\n    }\n\n    /// @inheritdoc IHub\n    function notifyRedeem(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable\n    {\n        _pay();\n\n        uint128 totalPayoutAssetAmount;\n        uint128 totalPaymentShareAmount;\n        uint128 cancelledShareAmount;\n\n        for (uint32 i = 0; i < maxClaims; i++) {\n            (uint128 payoutAssetAmount, uint128 paymentShareAmount, uint128 cancelled, bool canClaimAgain) =\n                shareClassManager.claimRedeem(poolId, scId, investor, assetId);\n\n            totalPayoutAssetAmount += payoutAssetAmount;\n            totalPaymentShareAmount += paymentShareAmount;\n\n            // Should be written at most once with non-zero amount iff the last claimable epoch was processed and\n            // the user had a pending cancellation\n            // NOTE: Purposely delaying corresponding message dispatch after redemption fulfillment message\n            if (cancelled > 0) {\n                cancelledShareAmount = cancelled;\n            }\n\n            if (!canClaimAgain) {\n                break;\n            }\n        }\n\n        sender.sendFulfilledRedeemRequest(\n            poolId, scId, assetId, investor, totalPayoutAssetAmount, totalPaymentShareAmount\n        );\n\n        // If cancellation was queued, notify about delayed cancellation\n        if (cancelledShareAmount > 0) {\n            sender.sendFulfilledCancelRedeemRequest(poolId, scId, assetId, investor, cancelledShareAmount);\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Pool admin methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function notifyPool(PoolId poolId, uint16 centrifugeId) external payable {\n        _isManagerAndPaid(poolId);\n\n        emit NotifyPool(centrifugeId, poolId);\n        sender.sendNotifyPool(centrifugeId, poolId);\n    }\n\n    /// @inheritdoc IHub\n    function notifyShareClass(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook) external payable {\n        _isManagerAndPaid(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        (string memory name, string memory symbol, bytes32 salt) = shareClassManager.metadata(scId);\n        uint8 decimals = hubRegistry.decimals(poolId);\n\n        emit NotifyShareClass(centrifugeId, poolId, scId);\n        sender.sendNotifyShareClass(centrifugeId, poolId, scId, name, symbol, decimals, salt, hook);\n    }\n\n    /// @inheritdoc IHub\n    function notifyShareMetadata(PoolId poolId, ShareClassId scId, uint16 centrifugeId) public payable {\n        _isManagerAndPaid(poolId);\n\n        (string memory name, string memory symbol,) = shareClassManager.metadata(scId);\n\n        emit NotifySharePrice(centrifugeId, poolId, scId, name, symbol);\n        sender.sendNotifyShareMetadata(centrifugeId, poolId, scId, name, symbol);\n    }\n\n    /// @inheritdoc IHub\n    function updateShareHook(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook) public payable {\n        _isManagerAndPaid(poolId);\n\n        emit UpdateShareHook(centrifugeId, poolId, scId, hook);\n        sender.sendUpdateShareHook(centrifugeId, poolId, scId, hook);\n    }\n\n    /// @inheritdoc IHub\n    function notifySharePrice(PoolId poolId, ShareClassId scId, uint16 centrifugeId) public payable {\n        _isManagerAndPaid(poolId);\n\n        (, D18 poolPerShare) = shareClassManager.metrics(scId);\n\n        emit NotifySharePrice(centrifugeId, poolId, scId, poolPerShare);\n        sender.sendNotifyPricePoolPerShare(centrifugeId, poolId, scId, poolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function notifyAssetPrice(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManagerAndPaid(poolId);\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, assetId);\n        emit NotifyAssetPrice(assetId.centrifugeId(), poolId, scId, assetId, pricePoolPerAsset);\n        sender.sendNotifyPricePoolPerAsset(poolId, scId, assetId, pricePoolPerAsset);\n    }\n\n    /// @inheritdoc IHub\n    function triggerIssueShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, address who, uint128 shares)\n        public\n        payable\n    {\n        _isManagerAndPaid(poolId);\n\n        sender.sendTriggerIssueShares(centrifugeId, poolId, scId, who, shares);\n    }\n\n    /// @inheritdoc IHub\n    function triggerSubmitQueuedShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId) public payable {\n        _isManagerAndPaid(poolId);\n\n        sender.sendTriggerSubmitQueuedShares(centrifugeId, poolId, scId);\n    }\n\n    /// @inheritdoc IHub\n    function triggerSubmitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManagerAndPaid(poolId);\n\n        sender.sendTriggerSubmitQueuedAssets(poolId, scId, assetId);\n    }\n\n    /// @inheritdoc IHub\n    function setQueue(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bool enabled) public payable {\n        _isManagerAndPaid(poolId);\n\n        sender.sendSetQueue(centrifugeId, poolId, scId, enabled);\n    }\n\n    /// @inheritdoc IHub\n    function setPoolMetadata(PoolId poolId, bytes calldata metadata) external payable {\n        _isManager(poolId);\n\n        hubRegistry.setMetadata(poolId, metadata);\n    }\n\n    /// @inheritdoc IHub\n    function updateShareClassMetadata(PoolId poolId, ShareClassId scId, string calldata name, string calldata symbol)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        shareClassManager.updateMetadata(poolId, scId, name, symbol);\n    }\n\n    /// @inheritdoc IHub\n    function updateManager(PoolId poolId, address who, bool canManage) external payable {\n        _isManager(poolId);\n\n        hubRegistry.updateManager(poolId, who, canManage);\n    }\n\n    /// @inheritdoc IHub\n    function addShareClass(PoolId poolId, string calldata name, string calldata symbol, bytes32 salt)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        shareClassManager.addShareClass(poolId, name, symbol, salt);\n    }\n\n    /// @inheritdoc IHub\n    function approveDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowDepositEpochId,\n        uint128 approvedAssetAmount\n    ) external payable returns (uint128 pendingAssetAmount, uint128 approvedPoolAmount) {\n        _isManagerAndPaid(poolId);\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, depositAssetId);\n        (pendingAssetAmount, approvedPoolAmount) = shareClassManager.approveDeposits(\n            poolId, scId, depositAssetId, nowDepositEpochId, approvedAssetAmount, pricePoolPerAsset\n        );\n\n        sender.sendApprovedDeposits(poolId, scId, depositAssetId, approvedAssetAmount, pricePoolPerAsset);\n    }\n\n    /// @inheritdoc IHub\n    function approveRedeems(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRedeemEpochId,\n        uint128 approvedShareAmount\n    ) external payable returns (uint128 pendingShareAmount) {\n        _isManager(poolId);\n\n        D18 price = _pricePoolPerAsset(poolId, scId, payoutAssetId);\n        (pendingShareAmount) =\n            shareClassManager.approveRedeems(poolId, scId, payoutAssetId, nowRedeemEpochId, approvedShareAmount, price);\n    }\n\n    /// @inheritdoc IHub\n    function issueShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowIssueEpochId,\n        D18 navPoolPerShare\n    ) external payable returns (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount) {\n        _isManager(poolId);\n\n        (issuedShareAmount, depositAssetAmount, depositPoolAmount) =\n            shareClassManager.issueShares(poolId, scId, depositAssetId, nowIssueEpochId, navPoolPerShare);\n        sender.sendIssuedShares(poolId, scId, depositAssetId, issuedShareAmount, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function revokeShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRevokeEpochId,\n        D18 navPoolPerShare\n    ) external payable returns (uint128 revokedShareAmount, uint128 payoutAssetAmount, uint128 payoutPoolAmount) {\n        _isManagerAndPaid(poolId);\n\n        (revokedShareAmount, payoutAssetAmount, payoutPoolAmount) =\n            shareClassManager.revokeShares(poolId, scId, payoutAssetId, nowRevokeEpochId, navPoolPerShare);\n\n        sender.sendRevokedShares(poolId, scId, payoutAssetId, payoutAssetAmount, revokedShareAmount, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function updateRestriction(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes calldata payload)\n        external\n        payable\n    {\n        _isManagerAndPaid(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateRestriction(centrifugeId, poolId, scId, payload);\n        sender.sendUpdateRestriction(centrifugeId, poolId, scId, payload);\n    }\n\n    /// @inheritdoc IHub\n    function updateContract(\n        PoolId poolId,\n        ShareClassId scId,\n        uint16 centrifugeId,\n        bytes32 target,\n        bytes calldata payload\n    ) external payable {\n        _isManagerAndPaid(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateContract(centrifugeId, poolId, scId, target, payload);\n        sender.sendUpdateContract(centrifugeId, poolId, scId, target, payload);\n    }\n\n    /// @inheritdoc IHub\n    function updatePricePerShare(PoolId poolId, ShareClassId scId, D18 navPoolPerShare) public payable {\n        _isManager(poolId);\n\n        shareClassManager.updatePricePerShare(poolId, scId, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function createHolding(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        AccountId assetAccount,\n        AccountId equityAccount,\n        AccountId lossAccount,\n        AccountId gainAccount\n    ) external payable {\n        _isManager(poolId);\n\n        require(hubRegistry.isRegistered(assetId), IHubRegistry.AssetNotFound());\n        require(\n            accounting.exists(poolId, assetAccount) && accounting.exists(poolId, equityAccount)\n                && accounting.exists(poolId, lossAccount) && accounting.exists(poolId, gainAccount),\n            IAccounting.AccountDoesNotExist()\n        );\n\n        HoldingAccount[] memory accounts = new HoldingAccount[](4);\n        accounts[0] = HoldingAccount(assetAccount, uint8(AccountType.Asset));\n        accounts[1] = HoldingAccount(equityAccount, uint8(AccountType.Equity));\n        accounts[2] = HoldingAccount(lossAccount, uint8(AccountType.Loss));\n        accounts[3] = HoldingAccount(gainAccount, uint8(AccountType.Gain));\n\n        holdings.create(poolId, scId, assetId, valuation, false, accounts);\n    }\n\n    /// @inheritdoc IHub\n    function createLiability(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        AccountId expenseAccount,\n        AccountId liabilityAccount\n    ) external payable {\n        _isManager(poolId);\n\n        require(hubRegistry.isRegistered(assetId), IHubRegistry.AssetNotFound());\n        require(\n            accounting.exists(poolId, expenseAccount) && accounting.exists(poolId, liabilityAccount),\n            IAccounting.AccountDoesNotExist()\n        );\n\n        HoldingAccount[] memory accounts = new HoldingAccount[](2);\n        accounts[0] = HoldingAccount(expenseAccount, uint8(AccountType.Expense));\n        accounts[1] = HoldingAccount(liabilityAccount, uint8(AccountType.Liability));\n\n        holdings.create(poolId, scId, assetId, valuation, true, accounts);\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingValue(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManager(poolId);\n\n        accounting.unlock(poolId);\n\n        (bool isPositive, uint128 diff) = holdings.update(poolId, scId, assetId);\n\n        // NOTE: Safe a diff=0 update gas cost\n        if (isPositive && diff > 0) {\n            if (holdings.isLiability(poolId, scId, assetId)) {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Liability)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Expense)), diff);\n            } else {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Gain)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Asset)), diff);\n            }\n        } else {\n            if (holdings.isLiability(poolId, scId, assetId)) {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Expense)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Liability)), diff);\n            } else {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Asset)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Loss)), diff);\n            }\n        }\n\n        accounting.lock();\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingValuation(PoolId poolId, ShareClassId scId, AssetId assetId, IERC7726 valuation)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        holdings.updateValuation(poolId, scId, assetId, valuation);\n    }\n\n    /// @inheritdoc IHub\n    function setHoldingAccountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind, AccountId accountId)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        holdings.setAccountId(poolId, scId, assetId, kind, accountId);\n    }\n\n    /// @inheritdoc IHub\n    function createAccount(PoolId poolId, AccountId account, bool isDebitNormal) public payable {\n        _isManager(poolId);\n\n        accounting.createAccount(poolId, account, isDebitNormal);\n    }\n\n    /// @inheritdoc IHub\n    function setAccountMetadata(PoolId poolId, AccountId account, bytes calldata metadata) external payable {\n        _isManager(poolId);\n\n        accounting.setAccountMetadata(poolId, account, metadata);\n    }\n\n    /// @inheritdoc IHub\n    function updateJournal(PoolId poolId, JournalEntry[] memory debits, JournalEntry[] memory credits) external {\n        _isManager(poolId);\n\n        accounting.unlock(poolId);\n\n        accounting.addJournal(debits, credits);\n\n        accounting.lock();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway owner methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHubGatewayHandler\n    function registerAsset(AssetId assetId, uint8 decimals) external {\n        _auth();\n\n        hubRegistry.registerAsset(assetId, decimals);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function depositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId, uint128 amount)\n        external\n    {\n        _auth();\n\n        shareClassManager.requestDeposit(poolId, scId, amount, investor, depositAssetId);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function redeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId, uint128 amount)\n        external\n    {\n        _auth();\n\n        shareClassManager.requestRedeem(poolId, scId, amount, investor, payoutAssetId);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function cancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external\n    {\n        _auth();\n\n        uint128 cancelledAssetAmount = shareClassManager.cancelDepositRequest(poolId, scId, investor, depositAssetId);\n\n        // Cancellation might have been queued such that it will be executed in the future during claiming\n        if (cancelledAssetAmount > 0) {\n            sender.sendFulfilledCancelDepositRequest(poolId, scId, depositAssetId, investor, cancelledAssetAmount);\n        }\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function cancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId) external {\n        _auth();\n\n        uint128 cancelledShareAmount = shareClassManager.cancelRedeemRequest(poolId, scId, investor, payoutAssetId);\n\n        // Cancellation might have been queued such that it will be executed in the future during claiming\n        if (cancelledShareAmount > 0) {\n            sender.sendFulfilledCancelRedeemRequest(poolId, scId, payoutAssetId, investor, cancelledShareAmount);\n        }\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function updateHoldingAmount(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease\n    ) external {\n        _auth();\n\n        accounting.unlock(poolId);\n\n        bool isLiability = holdings.isLiability(poolId, scId, assetId);\n        AccountType debitAccountType = isLiability ? AccountType.Expense : AccountType.Asset;\n        AccountType creditAccountType = isLiability ? AccountType.Liability : AccountType.Equity;\n\n        if (isIncrease) {\n            uint128 value = holdings.increase(poolId, scId, assetId, pricePoolPerAsset, amount);\n            accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(debitAccountType)), value);\n            accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(creditAccountType)), value);\n        } else {\n            uint128 value = holdings.decrease(poolId, scId, assetId, pricePoolPerAsset, amount);\n            accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(creditAccountType)), value);\n            accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(debitAccountType)), value);\n        }\n\n        accounting.lock();\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function increaseShareIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external {\n        _auth();\n\n        shareClassManager.increaseShareClassIssuance(poolId, scId, amount);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function decreaseShareIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external {\n        _auth();\n\n        shareClassManager.decreaseShareClassIssuance(poolId, scId, amount);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    //  Internal methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev Ensure the sender is authorized\n    function _auth() internal auth {}\n\n    /// @dev Ensure the method can be used without reentrancy issues, and the sender is a pool admin\n    function _isManager(PoolId poolId) internal protected {\n        require(hubRegistry.manager(poolId, msg.sender), IHub.NotManager());\n    }\n\n    /// @dev Ensure the sender is authorized\n    function _isManagerAndPaid(PoolId poolId) internal {\n        _isManager(poolId);\n        _pay();\n    }\n\n    /// @notice Send native tokens to the gateway for transaction payment if it's not in a multicall.\n    function _pay() internal {\n        if (!gateway.isBatching()) {\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n    }\n\n    function _pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId) internal view returns (D18) {\n        AssetId poolCurrency = hubRegistry.currency(poolId);\n        // NOTE: We assume symmetric prices are provided by holdings valuation\n        IERC7726 valuation = holdings.valuation(poolId, scId, assetId);\n\n        // Retrieve amount of 1 asset unit in pool currency\n        uint128 assetUnitAmount = (10 ** hubRegistry.decimals(assetId.raw())).toUint128();\n        uint128 poolUnitAmount = (10 ** hubRegistry.decimals(poolCurrency.raw())).toUint128();\n        uint128 poolAmountPerAsset =\n            valuation.getQuote(assetUnitAmount, assetId.addr(), poolCurrency.addr()).toUint128();\n\n        // Retrieve price by normalizing by pool denomination\n        return d18(poolAmountPerAsset, poolUnitAmount);\n    }\n}\n"
    }
}