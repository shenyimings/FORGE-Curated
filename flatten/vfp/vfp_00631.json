{
    "vfp_id": "vfp_00631",
    "project_name": "Sorella - Zenith Audit Report.pdf",
    "findings": [
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant checks on params.liquidityDelta",
            "description": "The checks on params.liquidityDelta in PoolRewards.sol are redundant because the PoolManager already determines whether to call afterAddLiquidity or afterRemoveLiquidity based on the sign of liquidityDelta. These checks do not add security value and are duplicated logic. While they serve as a sanity check, they are not necessary for correctness. The impact is minimal, limited to slight gas inefficiency and code bloat.\n",
            "severity": "Informational",
            "location": [
                "PoolRewards.sol#L81",
                "PoolRewards.sol#L117"
            ],
            "files": [
                "l2-angstrom/src/types/PoolRewards.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The updateAfterLiquidityAdd() function doesn't initialize the reward accumulator of uninitialized ticks",
            "description": "The updateAfterLiquidityAdd() function attempts to initialize rewardGrowthOutsideX128 for uninitialized ticks, but the condition !pm.isInitialized is never true because ticks are already initialized during the afterAddLiquidity hook flow. This results in dead code that has no effect. The initialization is redundant because the values are not meaningful until used. The impact is negligible, limited to code clarity and minor gas savings if simplified.\n",
            "severity": "Informational",
            "location": [
                "PoolRewards.sol"
            ],
            "files": [
                "l2-angstrom/src/types/PoolRewards.sol"
            ]
        }
    ],
    "affected_files": {
        "PoolRewards.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IUniV4, IPoolManager, PoolId} from \"../interfaces/IUniV4.sol\";\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"solady/src/utils/SafeCastLib.sol\";\nimport {ModifyLiquidityParams} from \"v4-core/src/types/PoolOperation.sol\";\nimport {MixedSignLib} from \"../libraries/MixedSignLib.sol\";\nimport {TickLib} from \"../libraries/TickLib.sol\";\n\nstruct PoolRewards {\n    mapping(bytes32 uniPositionKey => Position position) positions;\n    mapping(int24 tick => uint256 growthOutsideX128) rewardGrowthOutsideX128;\n    uint256 globalGrowthX128;\n}\n\nstruct Position {\n    uint256 lastGrowthInsideX128;\n}\n\nusing PoolRewardsLib for PoolRewards global;\n\nlibrary PoolRewardsLib {\n    using IUniV4 for IPoolManager;\n    using FixedPointMathLib for uint256;\n    using MixedSignLib for uint128;\n    using SafeCastLib for int256;\n    using TickLib for int24;\n\n    error RewardOverflow();\n    error NegativeDeltaForAdd();\n    error PositiveDeltaForRemove();\n\n    function updateAfterLiquidityAdd(\n        PoolRewards storage self,\n        IPoolManager pm,\n        PoolId id,\n        int24 tickSpacing,\n        address sender,\n        ModifyLiquidityParams calldata params\n    ) internal {\n        uint256 growthInside;\n        {\n            int24 currentTick = pm.getSlot0(id).tick();\n            uint256 lowerGrowthX128 = self.rewardGrowthOutsideX128[params.tickLower];\n            uint256 upperGrowthX128 = self.rewardGrowthOutsideX128[params.tickUpper];\n\n            if (currentTick < params.tickLower) {\n                unchecked {\n                    growthInside = lowerGrowthX128 - upperGrowthX128;\n                }\n            } else if (params.tickUpper <= currentTick) {\n                // Following Uniswap's convention, if tick is below and uninitialized initialize growth\n                // outside to global accumulator.\n                if (!pm.isInitialized(id, params.tickLower, tickSpacing)) {\n                    self.rewardGrowthOutsideX128[params.tickLower] =\n                        lowerGrowthX128 = self.globalGrowthX128;\n                }\n                if (!pm.isInitialized(id, params.tickUpper, tickSpacing)) {\n                    self.rewardGrowthOutsideX128[params.tickUpper] =\n                        upperGrowthX128 = self.globalGrowthX128;\n                }\n                unchecked {\n                    growthInside = upperGrowthX128 - lowerGrowthX128;\n                }\n            } else {\n                if (!pm.isInitialized(id, params.tickLower, tickSpacing)) {\n                    self.rewardGrowthOutsideX128[params.tickLower] =\n                        lowerGrowthX128 = self.globalGrowthX128;\n                }\n                unchecked {\n                    growthInside = self.globalGrowthX128 - lowerGrowthX128 - upperGrowthX128;\n                }\n            }\n        }\n\n        (Position storage position, bytes32 positionKey) =\n            self.getPosition(sender, params.tickLower, params.tickUpper, params.salt);\n\n        uint128 newLiquidity = pm.getPositionLiquidity(id, positionKey);\n        if (!(params.liquidityDelta >= 0)) revert NegativeDeltaForAdd();\n        uint128 lastLiquidity = newLiquidity.sub(params.liquidityDelta.toInt128());\n\n        if (lastLiquidity == 0) {\n            position.lastGrowthInsideX128 = growthInside;\n        } else {\n            // We want to update `lastGrowthInside` such that any previously accrued rewards are\n            // preserved:\n            // rewards' == rewards\n            // (growth_inside - last') * L' = (growth_inside - last) * L\n            //  growth_inside - last' = (growth_inside - last) * L / L'\n            // last' = growth_inside - (growth_inside - last) * L / L'\n            unchecked {\n                uint256 lastGrowthAdjustment = FixedPointMathLib.fullMulDiv(\n                    growthInside - position.lastGrowthInsideX128, lastLiquidity, newLiquidity\n                );\n                position.lastGrowthInsideX128 = growthInside - lastGrowthAdjustment;\n            }\n        }\n    }\n\n    function updateAfterLiquidityRemove(\n        PoolRewards storage self,\n        IPoolManager pm,\n        PoolId id,\n        address sender,\n        ModifyLiquidityParams calldata params\n    ) internal returns (uint256 rewards) {\n        unchecked {\n            (Position storage position, bytes32 positionKey) =\n                self.getPosition(sender, params.tickLower, params.tickUpper, params.salt);\n            int24 currentTick = pm.getSlot0(id).tick();\n            uint256 growthInsideX128 =\n                self.getGrowthInsideX128(currentTick, params.tickLower, params.tickUpper);\n\n            uint128 newPositionLiquidity = pm.getPositionLiquidity(id, positionKey);\n            if (!(0 >= params.liquidityDelta)) revert PositiveDeltaForRemove();\n            uint128 lastPositionLiquidity =\n                newPositionLiquidity.sub(params.liquidityDelta.toInt128());\n            rewards = FixedPointMathLib.fullMulDivN(\n                growthInsideX128 - position.lastGrowthInsideX128, lastPositionLiquidity, 128\n            );\n\n            // Only reset `lastGrowthInsideX128` if there were any rewards to avoid unnecessarily\n            // rounding down someone's rewards.\n            if (rewards > 0) {\n                position.lastGrowthInsideX128 = growthInsideX128;\n            }\n        }\n    }\n\n    function getPendingPositionRewards(\n        PoolRewards storage self,\n        IPoolManager pm,\n        PoolId id,\n        address owner,\n        int24 lowerTick,\n        int24 upperTick,\n        bytes32 salt\n    ) internal view returns (uint256 rewards) {\n        unchecked {\n            (Position storage position, bytes32 positionKey) =\n                self.getPosition(owner, lowerTick, upperTick, salt);\n            int24 currentTick = pm.getSlot0(id).tick();\n            uint256 growthInsideX128 = self.getGrowthInsideX128(currentTick, lowerTick, upperTick);\n            uint128 positionLiquidity = pm.getPositionLiquidity(id, positionKey);\n            rewards = FixedPointMathLib.fullMulDivN(\n                growthInsideX128 - position.lastGrowthInsideX128, positionLiquidity, 128\n            );\n        }\n    }\n\n    function getPosition(\n        PoolRewards storage self,\n        address owner,\n        int24 lowerTick,\n        int24 upperTick,\n        bytes32 salt\n    ) internal view returns (Position storage position, bytes32 positionKey) {\n        assembly (\"memory-safe\") {\n            // Compute Uniswap position key `keccak256(abi.encodePacked(owner, lowerTick, upperTick, salt))`.\n            mstore(0x06, upperTick)\n            mstore(0x03, lowerTick)\n            mstore(0x00, owner)\n            // WARN: Free memory pointer temporarily invalid from here on.\n            mstore(0x26, salt)\n            positionKey := keccak256(12, add(add(3, 3), add(20, 32)))\n            // Upper bytes of free memory pointer cleared.\n            mstore(0x26, 0)\n        }\n        position = self.positions[positionKey];\n    }\n\n    function getGrowthInsideX128(\n        PoolRewards storage self,\n        int24 currentTick,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal view returns (uint256 growthInsideX128) {\n        unchecked {\n            uint256 lowerGrowthX128 = self.rewardGrowthOutsideX128[lowerTick];\n            uint256 upperGrowthX128 = self.rewardGrowthOutsideX128[upperTick];\n\n            if (currentTick < lowerTick) {\n                return lowerGrowthX128 - upperGrowthX128;\n            }\n            if (upperTick <= currentTick) {\n                return upperGrowthX128 - lowerGrowthX128;\n            }\n\n            return self.globalGrowthX128 - lowerGrowthX128 - upperGrowthX128;\n        }\n    }\n\n    /// @dev Update growth values for a valid tick move from `prevTick` to `newTick`. Expects\n    /// `prevTick` and `newTick` to be valid Uniswap ticks (defined as tick âˆˆ [TickMath.MIN_TICK;\n    /// TickMath.MAX_TICK]).\n    function updateAfterTickMove(\n        PoolRewards storage self,\n        PoolId id,\n        IPoolManager pm,\n        int24 prevTick,\n        int24 newTick,\n        int24 tickSpacing\n    ) internal {\n        if (newTick > prevTick) {\n            // We assume the ticks are valid so no risk of underflow with these calls.\n            if (newTick.normalizeUnchecked(tickSpacing) > prevTick) {\n                _updateTickMoveUp(self, pm, id, prevTick, newTick, tickSpacing);\n            }\n        } else if (newTick < prevTick) {\n            // We assume the ticks are valid so no risk of underflow with these calls.\n            if (newTick < prevTick.normalizeUnchecked(tickSpacing)) {\n                _updateTickMoveDown(self, pm, id, prevTick, newTick, tickSpacing);\n            }\n        }\n    }\n\n    function _updateTickMoveUp(\n        PoolRewards storage self,\n        IPoolManager pm,\n        PoolId id,\n        int24 tick,\n        int24 newTick,\n        int24 tickSpacing\n    ) private {\n        uint256 globalGrowthX128 = self.globalGrowthX128;\n        while (true) {\n            bool initialized;\n            (initialized, tick) = pm.getNextTickGt(id, tick, tickSpacing);\n\n            if (newTick < tick) break;\n            if (initialized) {\n                unchecked {\n                    self.rewardGrowthOutsideX128[tick] =\n                        globalGrowthX128 - self.rewardGrowthOutsideX128[tick];\n                }\n            }\n        }\n    }\n\n    function _updateTickMoveDown(\n        PoolRewards storage self,\n        IPoolManager pm,\n        PoolId id,\n        int24 tick,\n        int24 newTick,\n        int24 tickSpacing\n    ) private {\n        uint256 globalGrowthX128 = self.globalGrowthX128;\n        while (true) {\n            bool initialized;\n            (initialized, tick) = pm.getNextTickLe(id, tick, tickSpacing);\n\n            if (tick <= newTick) break;\n\n            if (initialized) {\n                unchecked {\n                    self.rewardGrowthOutsideX128[tick] =\n                        globalGrowthX128 - self.rewardGrowthOutsideX128[tick];\n                }\n            }\n            tick--;\n        }\n    }\n\n    function getGrowthDelta(uint256 reward, uint256 liquidity)\n        internal\n        pure\n        returns (uint256 growthDeltaX128)\n    {\n        if (!(reward < 1 << 128)) revert RewardOverflow();\n        return (reward << 128).rawDiv(liquidity);\n    }\n}\n"
    }
}