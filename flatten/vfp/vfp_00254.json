{
    "vfp_id": "vfp_00254",
    "project_name": "ChainSecurity_StudioV_Neulock_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "Royalty Payments With Native Tokens Break Marketplace Integrations",
            "description": "The NEU token implements EIP-2981 for royalty payments, which can be made in ETH or ERC20 tokens. However, the NeuV2 contract lacks a receive() function, causing any royalty payments in ETH to revert. This prevents the NEU token from being traded on marketplaces that enforce royalty payments in native tokens, limiting its marketability and usability.\n\nThe root cause is the absence of a receive() or fallback function in the NeuV2 contract to accept ETH payments. As a result, any marketplace attempting to send ETH royalties to the contract will have the transaction reverted.\n\nAn attacker is not directly exploiting this, but malicious actors or competitive projects could leverage this limitation to discourage trading on compliant marketplaces, pushing users toward non-compliant platforms where royalties are ignored.\n\nThe impact is a reduced trading capability of the NEU token on major marketplaces, leading to potential loss of revenue for the project and diminished user trust due to restricted functionality.\n",
            "severity": "High",
            "location": [
                "NeuV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Subscription Can Be Passed Around",
            "description": "The NEU NFT grants entitlement to use the Neulock service, but since the NFT is freely transferable, a single owner could lend or transfer it to multiple users, allowing them to access the service without purchasing their own NFT. This undermines the business model by enabling unauthorized sharing or flash-loaning of access rights.\n\nThe cause is the lack of a cooldown or lock mechanism on the NFT after minting, allowing immediate transfer and reuse of entitlement. This design flaw enables secondary markets or lending platforms to exploit the system.\n\nAn attacker could mint a NEU NFT, allow multiple users to access the service, and then transfer it back, effectively providing unlimited access without additional cost. Flash loan platforms could automate this process.\n\nThe impact includes loss of revenue due to bypassed purchases, dilution of NFT value, and potential abuse of system resources by unauthorized users.\n",
            "severity": "High",
            "location": [
                "NeuV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-913"
                ],
                "3": [
                    "CWE-915"
                ]
            },
            "title": "Metadata Contract Can Be Updated",
            "description": "The NeuV2 contract allows the OPERATOR_ROLE to update the metadata contract address via setMetadataContract() even after initialization. This introduces risk because the metadata contract manages critical data such as refund values and series information. A malicious or compromised operator could change the metadata contract to one that manipulates accounting or disables functionality.\n\nThe root cause is the lack of a mechanism to lock the metadata contract address after the initial setup, leaving it mutable indefinitely.\n\nA compromised OPERATOR_ROLE could deploy a malicious metadata contract that alters refund logic, inflates or erases sponsor points, or breaks compatibility with the NEU token.\n\nThe impact includes potential loss of funds, incorrect state tracking, and disruption of core functionality, especially around refunds and series management.\n",
            "severity": "Medium",
            "location": [
                "NeuV2.sol::setMetadataContract"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Refund Mechanism Can Be Abused to DOS a Series",
            "description": "The refund mechanism allows users to refund their NEU NFT within 7 days of minting. An attacker can exploit this by purchasing all available tokens in a series and immediately refunding them, effectively preventing others from minting and forcing the project to create a new series. This costs the attacker only gas, making it a low-cost denial-of-service attack.\n\nThe cause is the combination of a finite token supply per series and a refund feature that does not penalize or limit bulk refunds.\n\nAn attacker can automate the purchase and refund of all tokens in a high-demand series, blocking legitimate users and disrupting the release schedule.\n\nThe impact is a denial of service for specific token series, reputational damage, and operational overhead from having to deploy new series.\n",
            "severity": "Medium",
            "location": [
                "NeuMetadataV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Royalties in Non-Native Tokens Are Locked",
            "description": "The NEU token contract can receive royalties in non-native tokens (e.g., ERC20), but it lacks a mechanism to withdraw these tokens. Once received, they are permanently locked in the contract, making recovery impossible without an upgrade.\n\nThe cause is the absence of a withdrawal function for ERC20 tokens, which is a common oversight when handling multiple token types.\n\nWhile not directly exploitable by attackers, this represents a significant risk if marketplaces start paying royalties in non-native tokens, leading to irreversible loss of funds.\n\nThe impact is the permanent loss of royalty revenue paid in non-native tokens, reducing the project's income and financial flexibility.\n",
            "severity": "Medium",
            "location": [
                "NeuV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Burning Can Increase Withdraw Gas Cost",
            "description": "In NeuMetadataV2, the sumAllRefundableTokensValue() function loops backward through tokens to calculate refundable value. If tokens at the end of a series are burned, the loop continues until it finds an unburned token, increasing gas consumption. In extreme cases, this could exceed the block gas limit, preventing withdrawal.\n\nThe cause is inefficient loop logic that does not account for burned tokens when determining the end of the refundable window.\n\nAn attacker could burn tokens at the end of a series to increase the gas cost of withdrawals, effectively blocking the operator from withdrawing funds.\n\nThe impact is a potential denial of service on the withdraw function, preventing access to funds and disrupting operations.\n",
            "severity": "Low",
            "location": [
                "NeuMetadataV2.sol::sumAllRefundableTokensValue"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ]
            },
            "title": "Inconsistency in Initialization Steps",
            "description": "The initialization process is inconsistent across contracts. NeuStorageV2 allows full initialization via initialize() without requiring initializeV2(), while NeuV2 requires both initialize() and initializeV2() to be called. This inconsistency increases the risk of improper deployment.\n\nThe cause is a lack of standardized initialization patterns across the codebase.\n\nA developer might mistakenly assume that calling initialize() is sufficient for all contracts, leading to partially initialized contracts and potential security issues due to missing setup steps.\n\nThe impact is potential deployment errors, leading to malfunctioning contracts or security vulnerabilities due to missing setup steps.\n",
            "severity": "Low",
            "location": [
                "NeuStorageV2.sol::initialize",
                "NeuV2.sol::initialize"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol",
                "neulock-onchain/contracts/old/StorageV2.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Inconsistent Refund Period",
            "description": "There is a discrepancy between getRefundAmount() and sumAllRefundableTokensValue() regarding the refund window boundary. The former reverts when block.timestamp - mintedAt equals REFUND_WINDOW, while the latter includes the token if the condition is equal, leading to inconsistent behavior.\n\nThe cause is a mismatch in comparison operators: one uses < and the other uses >, creating a one-second ambiguity at the boundary.\n\nThis could lead to user confusion and disputes over whether a token is refundable at the exact cutoff time.\n\nThe impact is minor financial discrepancies and potential user dissatisfaction due to inconsistent refund eligibility.\n",
            "severity": "Low",
            "location": [
                "NeuMetadataV2.sol::getRefundAmount",
                "NeuMetadataV2.sol::sumAllRefundableTokensValue"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Events",
            "description": "The initialize() functions in NeuEntitlementV1 and NeuMetadataV2 do not emit events when critical state changes occur, such as adding the NEU contract as an entitlement or setting the logo contract address. This makes it difficult for off-chain systems to track contract state.\n\nThe cause is the omission of event emissions during initialization, which is a best practice for transparency and observability.\n\nWithout events, frontends and monitoring tools cannot reliably detect when key configurations are set, leading to potential synchronization issues.\n\nThe impact is reduced observability and increased complexity for external systems relying on event data.\n",
            "severity": "Low",
            "location": [
                "NeuEntitlementV1.sol::initialize",
                "NeuMetadataV2.sol::initialize"
            ],
            "files": [
                "neulock-onchain/contracts/old/EntitlementV1.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing Input Sanitization",
            "description": "The addSeries() and updatePrice() functions do not validate that the price is non-zero, and addSeries() does not enforce that maxTokens is at least 1. This allows the creation of series with zero price or zero length, which can break logic such as isUserMinted().\n\nThe cause is missing input validation checks for critical parameters.\n\nA malicious or mistaken operator could create invalid series, leading to unexpected behavior or denial of service.\n\nThe impact includes broken minting logic, unusable token IDs, and potential disruption of series management.\n",
            "severity": "Low",
            "location": [
                "NeuMetadataV2.sol::addSeries",
                "NeuMetadataV2.sol::updatePrice"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ]
            },
            "title": "EIP7496 Compliance",
            "description": "The EIP-7496 standard recommends using keccak256 hashes for trait keys, but NeuMetadataV2 uses the human-readable string \"points\" directly as the traitKey. This deviates from the standard and may cause interoperability issues with compliant systems.\n\nThe cause is non-compliance with the EIP-7496 specification regarding trait key formatting.\n\nSystems expecting hashed keys may fail to recognize the trait, leading to incorrect interpretation of NFT traits.\n\nThe impact is reduced interoperability with third-party platforms that strictly follow the EIP-7496 standard.\n",
            "severity": "Informational",
            "location": [
                "NeuMetadataV2.sol::_getTraitValue"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1176"
                ]
            },
            "title": "Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified across several functions in the contract suite, including unnecessary loops, redundant checks, inefficient memory usage, and suboptimal event emissions.\nInefficient coding patterns such as looping to truncate arrays, redundant address(0) checks, repeated SLOADs, redundant event emissions, and missing unchecked blocks contribute to higher gas consumption.\nWhile not directly exploitable for financial gain, these inefficiencies increase transaction costs for users and can be leveraged in gas griefing attacks if exploited at scale.\nIncreased operational costs for users and the system, reduced scalability, and potential for denial-of-service under extreme conditions due to high gas usage.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV1.userEntitlementContracts",
                "NeuDaoLockV1.withdraw",
                "NeuMetadataV2.setSeriesAvailability",
                "NeuMetadataV2.createTokenMetadata",
                "NeuMetadataV2._givesGovernanceAccess",
                "NeuV2._privateMint",
                "NeuV2._increaseSponsorPoints",
                "NeuMetadataV2.increaseSponsorPoints",
                "Bytes8Utils.toString",
                "NeuEntitlementV2.initializeV2"
            ],
            "files": [
                "neulock-onchain/contracts/old/EntitlementV1.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Loop Iterator Increment Optimization Is Unnecessary",
            "description": "In `NeuMetadataV2.getTraitValues()`, the loop iterator increment was placed inside an `unchecked` block, which is unnecessary because the Solidity compiler (since version 0.8.22) automatically optimizes `i++` in for-loops.\nDevelopers manually applied an optimization that is already handled by the compiler, adding redundant code.\nThis does not present a direct attack vector but reflects a misunderstanding of compiler behavior.\nMinimal impact; however, it adds unnecessary complexity and reduces code clarity.\n",
            "severity": "Informational",
            "location": [
                "NeuMetadataV2.getTraitValues"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing Natspec",
            "description": "The contracts lack NatSpec comments, which are used to document functions, parameters, return values, and events in Solidity.\nAbsence of documentation comments in the source code.\nNot exploitable, but hampers readability and integration efforts by external developers.\nReduced code maintainability and increased risk of misinterpretation during audits or upgrades.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol",
                "neulock-onchain/contracts/old/EntitlementV1.sol",
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "NEU Can Be Removed From the Entitlement Contracts List",
            "description": "The NEU contract could be removed from the entitlement contracts list via `NeuEntitlementV1.removeEntitlementContract()`, which poses a risk if the OPERATOR_ROLE is compromised.\nLack of a safeguard to prevent removal of a critical contract from the entitlement system.\nA malicious or compromised operator could remove the NEU contract, breaking expected functionality for users.\nUsers may lose access to expected features tied to holding NEU tokens, undermining trust in the system.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV1.removeEntitlementContract"
            ],
            "files": [
                "neulock-onchain/contracts/old/EntitlementV1.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1078"
                ]
            },
            "title": "Storage Variable Without Explicit Visibility",
            "description": "The storage variable `_traitMetadataURI` in `NeuMetadataV2` does not explicitly declare its visibility, relying on the default `internal`.\nOmission of explicit visibility specifier in variable declaration.\nWhile safe by default, this violates best practices and may lead to confusion or future errors if visibility assumptions change.\nReduced code clarity and maintainability; potential for accidental exposure if refactored without awareness.\n",
            "severity": "Informational",
            "location": [
                "_traitMetadataURI in NeuMetadataV2"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ]
            },
            "title": "Uninitialized Dependency",
            "description": "In `NeuV2`, the initializer function `__ERC721Royalty_init()` is not called during contract initialization, even though it is currently a no-op.\nFailure to follow proper inheritance initialization patterns in Solidity.\nIf the parent contract's initializer later becomes non-trivial, the uninitialized state could lead to incorrect behavior.\nRisk of future malfunction if dependencies evolve, leading to potential loss of functionality or incorrect royalty settings.\n",
            "severity": "Informational",
            "location": [
                "NeuV2 initializer functions"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        }
    ],
    "affected_files": {
        "EntitlementV1.sol": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport {INeuEntitlementV1} from \"../interfaces/IEntitlementV1.sol\";\n\ncontract NeuEntitlementV1 is\n    Initializable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable,\n    INeuEntitlementV1\n{\n    uint256 private constant VERSION = 1;\n\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    address[] public entitlementContracts;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address defaultAdmin,\n        address upgrader,\n        address operator,\n        address neuContract\n    ) public initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(UPGRADER_ROLE, upgrader);\n        _grantRole(OPERATOR_ROLE, operator);\n\n        entitlementContracts.push(neuContract);\n\n        emit InitializedEntitlement(VERSION, defaultAdmin, upgrader, operator, neuContract);\n    }\n\n    function addEntitlementContract(address entitlementContract) external onlyRole(OPERATOR_ROLE) override {\n        uint256 entitlementContractsLength = entitlementContracts.length;\n\n        for (uint256 i = 0; i < entitlementContractsLength; i++) {\n            require(entitlementContracts[i] != entitlementContract, \"Entitlement contract already added\");\n        }\n\n        // We won't check for the IERC721 interface, since any token that supports balanceOf() can be used\n        // slither-disable-next-line unused-return (we don't need the return value, only to check if the function exists)\n        try IERC721(entitlementContract).balanceOf(address(this)) {} catch {\n            revert(\"Contract does not support balanceOf()\");\n        }\n\n        entitlementContracts.push(entitlementContract);\n\n        emit EntitlementContractAdded(entitlementContract);\n    }\n\n    function removeEntitlementContract(address entitlementContract) external onlyRole(OPERATOR_ROLE) override {\n        for (uint256 i = 0; i < entitlementContracts.length; i++) {\n            if (entitlementContracts[i] == entitlementContract) {\n                entitlementContracts[i] = entitlementContracts[entitlementContracts.length - 1];\n                // slither-disable-next-line costly-loop (we only pop once and return)\n                entitlementContracts.pop();\n\n                emit EntitlementContractRemoved(entitlementContract);\n                return;\n            }\n        }\n\n        revert(\"Entitlement contract not found\");\n    }\n\n    function hasEntitlement(address user) external view override returns (bool) {\n        uint256 entitlementContractsLength = entitlementContracts.length;\n\n        for (uint256 i = 0; i < entitlementContractsLength; i++) {\n            IERC721 entitlementContract = IERC721(entitlementContracts[i]);\n\n            if (_callerHasContractEntitlement(user, entitlementContract)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function userEntitlementContracts(address user) external view override returns (address[] memory) {\n        address[] memory userEntitlements = new address[](entitlementContracts.length);\n        uint256 count = 0;\n\n        uint256 entitlementContractsLength = entitlementContracts.length;\n\n        for (uint256 i = 0; i < entitlementContractsLength; i++) {\n            IERC721 entitlementContract = IERC721(entitlementContracts[i]);\n\n            if (_callerHasContractEntitlement(user, entitlementContract)) {\n                userEntitlements[count] = entitlementContracts[i];\n                count++;\n            }\n        }\n\n        address[] memory result = new address[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = userEntitlements[i];\n        }\n\n        return result;\n    }\n\n    function _callerHasContractEntitlement(address user, IERC721 entitlementContract) private view returns (bool) {\n        // slither-disable-next-line calls-loop (will only revert if contract has been upgraded and doesn't support balanceOf(); in this case, we don't want to fail silently)\n        return entitlementContract.balanceOf(user) > 0;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal onlyRole(UPGRADER_ROLE) override {}\n}\n",
        "NeuV2.sol": "// SPDX-License-Identifier: CC0-1.0\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport {IERC7496} from \"../interfaces/IERC7496.sol\";\nimport {INeuMetadataV2} from \"../interfaces/INeuMetadataV2.sol\";\nimport {INeuV2} from \"../interfaces/INeuV2.sol\";\nimport {INeuDaoLockV1} from \"../interfaces/ILockV1.sol\";\n\ncontract NeuV2 is\n    INeuV2,\n    IERC7496,\n    Initializable,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    AccessControlUpgradeable,\n    ERC721BurnableUpgradeable,\n    ERC721RoyaltyUpgradeable,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    uint256 private constant VERSION = 2;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant POINTS_INCREASER_ROLE = keccak256(\"POINTS_INCREASER_ROLE\");\n\n    uint256 private constant GWEI = 1e9;\n\n    uint256 public weiPerSponsorPoint;\n    INeuMetadataV2 private _neuMetadata;\n    INeuDaoLockV1 private _neuDaoLock;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address defaultAdmin,\n        address upgrader,\n        address operator\n    ) public initializer {\n        __ERC721_init(\"Neulock\", \"NEU\");\n        __ERC721Enumerable_init();\n        __AccessControl_init();\n        __ERC721Burnable_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(UPGRADER_ROLE, upgrader);\n        _grantRole(OPERATOR_ROLE, operator);\n\n        _setDefaultRoyalty(address(this), 1000); // 10%\n\n        weiPerSponsorPoint = 1e14; // 0.0001 ETH\n\n        emit InitializedNeu(VERSION, defaultAdmin, upgrader, operator);\n    }\n\n    function initializeV2(address payable neuDaoLockAddress) public reinitializer(2) onlyRole(UPGRADER_ROLE) {\n        __ReentrancyGuard_init();\n\n        _neuDaoLock = INeuDaoLockV1(neuDaoLockAddress);\n\n        emit InitializedNeuV2(neuDaoLockAddress);\n    }\n\n    function getTraitMetadataURI()\n        external\n        view\n        override\n        returns (string memory uri)\n    {\n        return _neuMetadata.getTraitMetadataURI();\n    }\n\n    function _setTraitMetadataURI(string calldata uri) private {\n        emit IERC7496.TraitMetadataURIUpdated();\n        _neuMetadata.setTraitMetadataURI(uri);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireOwned(tokenId);\n\n        // slither-disable-start calls-loop (try-catch mitigates the DoS risk on revert)\n        try _neuMetadata.tokenURI(tokenId) returns (string memory result) {\n            return result;\n        } catch {\n            return \"\";\n        }\n        // slither-disable-end calls-loop\n    }\n\n    function setMetadataContract(address newMetadataContract) external onlyRole(OPERATOR_ROLE) {\n        _neuMetadata = INeuMetadataV2(newMetadataContract);\n\n        emit MetadataContractUpdated(newMetadataContract);\n    }\n\n    function setDaoLockContract(address payable newDaoLockContract) external onlyRole(OPERATOR_ROLE) {\n        _neuDaoLock = INeuDaoLockV1(newDaoLockContract);\n        \n        emit DaoLockContractUpdated(newDaoLockContract);\n    }\n\n    function setStorageContract(address newStorageContract) external onlyRole(OPERATOR_ROLE) {\n        _grantRole(POINTS_INCREASER_ROLE, newStorageContract);\n\n        emit StorageContractUpdated(newStorageContract);\n    }\n\n    function _privateMint(\n        address to,\n        uint16 seriesIndex,\n        uint256 originalPrice\n    ) private returns (uint256 tokenId, bool governance) {\n        (tokenId, governance) = _neuMetadata.createTokenMetadata(seriesIndex, originalPrice);\n\n        _safeMint(to, tokenId);\n    }\n\n    function _privateBurn(uint256 tokenId) private {\n        _burn(tokenId);\n        _neuMetadata.deleteTokenMetadata(tokenId);\n    }\n\n    function safeMint(address to, uint16 seriesIndex) public override onlyRole(OPERATOR_ROLE) {\n        _privateMint(to, seriesIndex, 0);\n    }\n\n    function safeMintPublic(uint16 seriesIndex) external payable {\n        uint256 seriesPrice = _neuMetadata.getSeriesMintingPrice(seriesIndex);\n\n        require(msg.value >= seriesPrice, \"Not enough ETH sent\");\n        _privateMint(msg.sender, seriesIndex, seriesPrice);\n    }\n\n    function burn (uint256 tokenId) public override {\n        super.burn(tokenId);\n        _neuMetadata.deleteTokenMetadata(tokenId);\n    }\n\n    function withdraw() external onlyRole(OPERATOR_ROLE) {\n        uint256 availableBalance = address(this).balance -\n            _neuMetadata.sumAllRefundableTokensValue();\n\n        if (availableBalance > 0) {\n            // slither-disable-next-line arbitrary-send-eth (msg.sender is operator, guaranteed by onlyRole check)\n            payable(msg.sender).transfer(availableBalance);\n        }\n    }\n\n    function refund(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, \"Caller is not token owner\");\n\n        uint256 refundAmount = _neuMetadata.getRefundAmount(tokenId);\n\n        _privateBurn(tokenId);\n\n        payable(msg.sender).transfer(refundAmount);\n    }\n\n    function increaseSponsorPoints(uint256 tokenId) external payable onlyRole(POINTS_INCREASER_ROLE) returns (uint256 newSponsorPoints, uint256 sponsorPointsIncrease) {\n        (newSponsorPoints, sponsorPointsIncrease) = _increaseSponsorPoints(tokenId, msg.value);\n\n        // slither-disable-next-line low-level-calls (calling like this is the best practice for sending Ether)\n        (bool sent, ) = address(_neuDaoLock).call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function _increaseSponsorPoints(uint256 tokenId, uint256 value) private nonReentrant() returns (uint256 newSponsorPoints, uint256 sponsorPointsIncrease) {\n        sponsorPointsIncrease = value / weiPerSponsorPoint;\n\n        if (sponsorPointsIncrease == 0) {\n            revert(\"Not enough ETH sent\");\n        }\n\n        newSponsorPoints = _neuMetadata.increaseSponsorPoints(tokenId, sponsorPointsIncrease);\n\n        emit IERC7496.TraitUpdated(bytes32(\"points\"), tokenId, bytes32(newSponsorPoints));\n    }\n\n    function setWeiPerSponsorPoint(uint256 newWeiPerSponsorPoint) external onlyRole(OPERATOR_ROLE) {\n        require(newWeiPerSponsorPoint >= GWEI, \"Must be at least 1 gwei\");\n        weiPerSponsorPoint = newWeiPerSponsorPoint;\n\n        emit WeiPerSponsorPointUpdated(newWeiPerSponsorPoint);\n    }\n\n    function setTrait(\n        uint256 /*tokenId*/,\n        bytes32 /*traitKey*/,\n        bytes32 /*newValue*/\n    ) pure public {\n        // We won't allow setting any trait individually.\n        revert(\"Trait cannot be set\");\n    }\n\n    function getTraitValue(\n        uint256 tokenId,\n        bytes32 traitKey\n    ) public view returns (bytes32 traitValue) {\n        _requireOwned(tokenId);\n\n        return _neuMetadata.getTraitValue(tokenId, traitKey);\n    }\n\n    function getTraitValues(\n        uint256 tokenId,\n        bytes32[] calldata traitKeys\n    ) public view virtual override returns (bytes32[] memory traitValues) {\n        _requireOwned(tokenId);\n\n        // slither-disable-next-line calls-loop (an unexpected revert here indicates a bug in our NeuMetadata contract that we would need to fix)\n        return _neuMetadata.getTraitValues(tokenId, traitKeys);\n    }\n\n    function setTraitMetadataURI(\n        string calldata uri\n    ) external onlyRole(OPERATOR_ROLE) {\n        _setTraitMetadataURI(uri);\n    }\n\n    function getTokensOfOwner(address owner) public view returns (uint256[] memory tokenIds) {\n        uint256 tokenCount = balanceOf(owner);\n\n        tokenIds = new uint256[](tokenCount);\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            tokenIds[i] = tokenOfOwnerByIndex(owner, i);\n        }\n    }\n\n    function getTokensWithData(uint256[] calldata tokenIds) external view returns (string[] memory tokenUris, bool[] memory isUserMinted) {\n        tokenUris = new string[](tokenIds.length);\n        isUserMinted = new bool[](tokenIds.length);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            tokenUris[i] = tokenURI(tokenIds[i]);\n            // slither-disable-next-line calls-loop (will only revert if there's a bug in our NeuMetadata contract; we don't want to fail silently)\n            isUserMinted[i] = _neuMetadata.isUserMinted(tokenIds[i]);\n        }\n    }\n\n    function getTokensTraitValues(uint256[] calldata tokenIds, bytes32[] calldata traitKeys) external view returns (bytes32[][] memory traitValues) {\n        traitValues = new bytes32[][](tokenIds.length);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            traitValues[i] = getTraitValues(tokenIds[i], traitKeys);\n        }\n    }\n\n    function isGovernanceToken(uint256 tokenId) external view returns (bool) {\n        _requireOwned(tokenId);\n\n        return _neuMetadata.isGovernanceToken(tokenId);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _update(address to, uint256 tokenId, address auth) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n\n    function _increaseBalance(address account, uint128 value) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._increaseBalance(account, value);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(\n            AccessControlUpgradeable,\n            ERC721EnumerableUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721Upgradeable\n        ) returns (bool)\n    {\n        return\n            super.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC7496).interfaceId;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n}",
        "StorageV2.sol": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport {INeuStorageV2} from \"../interfaces/INeuStorageV2.sol\";\nimport {INeuV1, INeuTokenV1} from \"../interfaces/INeuV1.sol\";\nimport {INeuEntitlementV1} from \"../interfaces/IEntitlementV1.sol\";\n\ncontract NeuStorageV2 is\n    Initializable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable,\n    INeuStorageV2\n{\n    uint256 private constant VERSION = 2;\n\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    INeuTokenV1 private _neuContract;\n    mapping(address => bytes) private _userdata;\n    INeuEntitlementV1 private _entitlementContract;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address defaultAdmin,\n        address upgrader,\n        address neuContractAddress,\n        address entitlementContractAddress\n    ) public initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(UPGRADER_ROLE, upgrader);\n\n        _neuContract = INeuTokenV1(neuContractAddress);\n        _entitlementContract = INeuEntitlementV1(entitlementContractAddress);\n\n        emit InitializedStorage(VERSION, defaultAdmin, upgrader, neuContractAddress, entitlementContractAddress);\n    }\n\n    function initializeV2(address entitlementContractAddress) public reinitializer(2) onlyRole(UPGRADER_ROLE) {\n        _entitlementContract = INeuEntitlementV1(entitlementContractAddress);\n\n        emit InitializedStorageV2(entitlementContractAddress);\n    }\n\n    function saveData(uint256 tokenId, bytes memory data) external payable {\n        // Call with tokenId = 0 if entitlement by token other than the NEU\n        require(_entitlementContract.hasEntitlement(msg.sender), \"Caller does not have entitlement\");\n        require(msg.value == 0 || _neuContract.ownerOf(tokenId) == msg.sender, \"Cannot add points to unowned NEU\");\n\n        _userdata[msg.sender] = data;\n\n        emit DataSaved(tokenId, data);\n\n        if (msg.value > 0) {\n            // slither-disable-next-line unused-return (we make this call only for the side effect)\n            _neuContract.increaseSponsorPoints{value: msg.value}(tokenId);\n        }\n    }\n\n    function retrieveData(address owner) external view returns (bytes memory) {\n        return _userdata[owner];\n    }\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyRole(UPGRADER_ROLE)\n        override\n    {}\n}\n\n",
        "MetadataV2.sol": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {Series, TokenMetadata, INeuMetadataV2} from \"../interfaces/INeuMetadataV2.sol\";\nimport {NeuLogoV2} from \"../current/LogoV2.sol\";\nimport {Bytes8Utils} from \"../lib/Utils.sol\";\n\nusing Bytes8Utils for bytes8;\nusing Strings for uint256;\nusing SafeCast for uint256;\n\ncontract NeuMetadataV2 is\n    Initializable,\n    AccessControlUpgradeable,\n    UUPSUpgradeable,\n    INeuMetadataV2\n{\n    uint256 private constant VERSION = 2;\n\n    bytes32 public constant NEU_ROLE = keccak256(\"NEU_ROLE\");\n    bytes32 public constant STORAGE_ROLE = keccak256(\"STORAGE_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    uint256 private constant REFUND_WINDOW = 7 days;\n\n    string _traitMetadataURI;\n    mapping(uint256 => TokenMetadata) private _tokenMetadata;\n    Series[] private _series;\n    uint16[] private _availableSeries;\n    NeuLogoV2 private _logo;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address defaultAdmin,\n        address upgrader,\n        address operator,\n        address neuContract,\n        address logoContract\n    ) public initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n        _grantRole(UPGRADER_ROLE, upgrader);\n        _grantRole(OPERATOR_ROLE, operator);\n        _grantRole(NEU_ROLE, neuContract);\n\n        _logo = NeuLogoV2(logoContract);\n\n        emit InitializedMetadata(VERSION, defaultAdmin, upgrader, operator, neuContract, logoContract);\n    }\n\n    function createTokenMetadata(uint16 seriesIndex, uint256 originalPrice) external onlyRole(NEU_ROLE) returns (\n        uint256 tokenId,\n        bool governance\n    ) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n        require(_series[seriesIndex].mintedTokens < _series[seriesIndex].maxTokens, \"Series has been fully minted\");\n\n        tokenId = _series[seriesIndex].firstToken + _series[seriesIndex].mintedTokens;\n\n        _setTokenMetadata(tokenId, TokenMetadata({\n            originalPriceInGwei: uint64(originalPrice / 1e9),\n            sponsorPoints: 0,\n            mintedAt: uint40(block.timestamp)\n        }));\n\n        _series[seriesIndex].mintedTokens++;\n\n        if (_series[seriesIndex].mintedTokens == _series[seriesIndex].maxTokens) {\n            _removeAvailableSeries(seriesIndex);\n        }\n\n        governance = _givesGovernanceAccess(seriesIndex);\n    }\n\n    function deleteTokenMetadata(uint256 tokenId) external onlyRole(NEU_ROLE) {\n        require(_metadataExists(tokenId), \"Token metadata does not exist\");\n\n        uint16 seriesIndex = _seriesOfToken(tokenId);\n\n        _series[seriesIndex].burntTokens++;\n        delete _tokenMetadata[tokenId];\n\n        emit TokenMetadataDeleted(tokenId);\n    }\n\n    function setTraitMetadataURI(string calldata uri) external onlyRole(NEU_ROLE) {\n        _setTraitMetadataURI(uri);\n    }\n\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        return string.concat(\n            \"data:application/json;base64,\",\n            Base64.encode(_makeJsonMetadata(tokenId))\n        );\n    }\n\n    function isUserMinted(uint256 tokenId) external view returns (bool) {\n        // slither-disable-next-line timestamp (block miner cannot set timestamp in the past of previous block, so mintedAt == 0 can only mean the token does not exist)\n        return _metadataExists(tokenId) && _tokenMetadata[tokenId].originalPriceInGwei > 0;\n    }\n\n    function getTraitValue(uint256 tokenId, bytes32 traitKey) external view returns (bytes32) {\n        return _getTraitValue(tokenId, traitKey);\n    }\n\n    function getTraitValues(uint256 tokenId, bytes32[] calldata traitKeys) external view returns (bytes32[] memory traitValues) {\n        uint256 length = traitKeys.length;\n        traitValues = new bytes32[](length);\n\n        for (uint256 i = 0; i < length; ) {\n            bytes32 traitKey = traitKeys[i];\n            traitValues[i] = _getTraitValue(tokenId, traitKey);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getTraitMetadataURI() external view returns (string memory) {\n        // Return the trait metadata URI.\n        return _traitMetadataURI;\n    }\n\n    function addSeries(bytes8 name, uint64 priceInGwei, uint32 firstToken, uint32 maxTokens, uint16 fgColorRGB565, uint16 bgColorRGB565, uint16 accentColorRGB565, bool makeAvailable) external onlyRole(OPERATOR_ROLE) returns (uint16) {\n        uint16 seriesIndex = uint16(_series.length);\n        uint256 maxToken = firstToken + maxTokens - 1;\n        uint256 seriesLength = _series.length;\n\n        for (uint16 i = 0; i < seriesLength; i++) {\n            require(_series[i].name != name, \"Series name already exists\");\n            require(maxToken < _series[i].firstToken || firstToken >= _series[i].firstToken + _series[i].maxTokens, \"Series overlaps with existing\");\n        }\n\n        _series.push(Series({\n            name: name,\n            priceInGwei: priceInGwei,\n            firstToken: firstToken,\n            maxTokens: maxTokens,\n            mintedTokens: 0,\n            burntTokens: 0,\n            fgColorRGB565: fgColorRGB565,\n            bgColorRGB565: bgColorRGB565,\n            accentColorRGB565: accentColorRGB565\n        }));\n\n        if (makeAvailable) {\n            _availableSeries.push(seriesIndex);\n        }\n\n        emit SeriesAdded(seriesIndex, name, priceInGwei, firstToken, maxTokens, fgColorRGB565, bgColorRGB565, accentColorRGB565, makeAvailable);\n        return seriesIndex;\n    }\n\n    function getSeries(uint16 seriesIndex) external view returns (\n        bytes8 name,\n        uint256 priceInGwei,\n        uint256 firstToken,\n        uint256 maxTokens,\n        uint256 mintedTokens,\n        uint256 burntTokens,\n        bool isAvailable,\n        string memory logoSvg\n    ) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n\n        Series memory series = _series[seriesIndex];\n\n        name = series.name;\n        priceInGwei = series.priceInGwei;\n        firstToken = series.firstToken;\n        maxTokens = series.maxTokens;\n        mintedTokens = series.mintedTokens;\n        burntTokens = series.burntTokens;\n        isAvailable = _isSeriesAvailable(seriesIndex);\n        logoSvg = _logo.makeLogo(\n            _makeMaskedTokenId(series), series.name.toString(), series.fgColorRGB565, series.bgColorRGB565, series.accentColorRGB565);\n    }\n\n    function isSeriesAvailable(uint16 seriesIndex) external view returns (bool) {\n        return _isSeriesAvailable(seriesIndex);\n    }\n\n    function setSeriesAvailability(uint16 seriesIndex, bool available) external onlyRole(OPERATOR_ROLE) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n\n        if (available) {\n            Series memory series = _series[seriesIndex];\n\n            if (series.mintedTokens == series.maxTokens) {\n                revert(\"Series has been fully minted\");\n            }\n        }\n\n        bool isAlreadyAvailable = _isSeriesAvailable(seriesIndex);\n\n        if (available && !isAlreadyAvailable) {\n            _availableSeries.push(seriesIndex);\n\n            emit SeriesAvailabilityUpdated(seriesIndex, available);\n        } else if (!available && isAlreadyAvailable) {\n            _removeAvailableSeries(seriesIndex);\n\n            emit SeriesAvailabilityUpdated(seriesIndex, available);\n        }\n    }\n\n    function getAvailableSeries() external view returns(uint16[] memory) {\n        return _availableSeries;\n    }\n\n    function setPriceInGwei(uint16 seriesIndex, uint64 price) external onlyRole(OPERATOR_ROLE) {\n        require(seriesIndex < _series.length, \"Invalid series index\");\n        _series[seriesIndex].priceInGwei = price;\n\n        emit SeriesPriceUpdated(seriesIndex, price);\n    }\n\n    function getSeriesMintingPrice(uint16 seriesIndex) external view returns (uint256) {\n        require(_isSeriesAvailable(seriesIndex), \"Public minting not available\");\n\n        return uint256(_series[seriesIndex].priceInGwei) * 1e9;\n    }\n\n    function sumAllRefundableTokensValue() external view returns (uint256) {\n        uint256 totalValue = 0;\n        uint256 seriesLength = _series.length;\n\n        for (uint16 s = 0; s < seriesLength; s++) {\n            for (uint256 i = _series[s].firstToken + _series[s].mintedTokens - 1; i >= _series[s].firstToken; i--) {\n                TokenMetadata memory metadata = _tokenMetadata[i];\n\n                if (!_metadataExists(i)) {\n                    // Token has been burned\n                    continue;\n                }\n\n                // slither-disable-next-line timestamp (with a granularity of days for refunds, we can tolerate miner manipulation)\n                if (block.timestamp - metadata.mintedAt > REFUND_WINDOW) {\n                    // All tokens before this one in the series are also expired\n                    break;\n                }\n\n                totalValue += metadata.originalPriceInGwei;\n            }\n        }\n\n        return totalValue * 1e9;\n    }\n\n    function getRefundAmount(uint256 tokenId) external view returns (uint256) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n\n        require(metadata.originalPriceInGwei > 0, \"Token is not refundable\");\n        // slither-disable-next-line timestamp (with a granularity of days for refunds, we can tolerate miner manipulation)\n        require(block.timestamp - metadata.mintedAt < REFUND_WINDOW, \"Refund window has passed\");\n\n        return metadata.originalPriceInGwei * 1e9;\n    }\n\n    function setLogoContract(address logoContract) external onlyRole(OPERATOR_ROLE) {\n        _logo = NeuLogoV2(logoContract);\n        \n        emit LogoUpdated(logoContract);\n    }\n\n    function _setTokenMetadata(\n        uint256 tokenId,\n        TokenMetadata memory metadata\n    ) internal {\n        // This function is to be called only on token mint. Won't emit TraitUpdated event.\n        _tokenMetadata[tokenId] = metadata;\n\n        emit TokenMetadataUpdated(tokenId, metadata);\n    }\n\n    function increaseSponsorPoints(uint256 tokenId, uint256 sponsorPointsIncrease) external onlyRole(NEU_ROLE) returns (uint256) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n\n        uint256 newSponsorPoints = metadata.sponsorPoints + sponsorPointsIncrease;\n\n        _tokenMetadata[tokenId] = TokenMetadata({\n            originalPriceInGwei: metadata.originalPriceInGwei,\n            sponsorPoints: newSponsorPoints.toUint64(),\n            mintedAt: metadata.mintedAt\n        });\n\n        emit TraitUpdated(bytes32(\"points\"), tokenId, bytes32(newSponsorPoints));\n        return newSponsorPoints;\n    }\n    function isGovernanceToken(uint256 tokenId) external view returns (bool) {\n        // This doesn't check if token has been minted, just if its ID belongs to the range of a governance series\n        uint16 seriesIndex = _seriesOfToken(tokenId);\n        return _givesGovernanceAccess(seriesIndex);\n    }\n\n    function _isSeriesAvailable(uint16 seriesIndex) private view returns (bool) {\n        uint256 availableSeriesLength = _availableSeries.length;\n\n        for (uint256 i = 0; i < availableSeriesLength; i++) {\n            if (_availableSeries[i] == seriesIndex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _removeAvailableSeries(uint16 seriesIndex) private {\n        for (uint256 i = 0; i < _availableSeries.length; i++) {\n            if (_availableSeries[i] == seriesIndex) {\n                _availableSeries[i] = _availableSeries[_availableSeries.length - 1];\n                _availableSeries.pop();\n                return;\n            }\n        }\n    }\n\n    function _getTraitValue(uint256 tokenId, bytes32 traitKey) private view returns (bytes32) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n\n        if (traitKey == \"points\") {\n            return bytes32(uint256(metadata.sponsorPoints));\n        } else {\n            revert(\"Trait key not found\");\n        }\n    }\n\n    function _makeJsonMetadata(uint256 tokenId) internal view returns (bytes memory) {\n        TokenMetadata memory metadata = _tokenMetadata[tokenId];\n        uint16 seriesIndex = _seriesOfToken(tokenId);\n        Series memory series = _series[seriesIndex];\n        string memory governance = _givesGovernanceAccess(seriesIndex) ? \"Yes\" : \"No\";\n        string memory seriesName = series.name.toString();\n        string memory tokenName = string.concat(tokenId.toString(), ' ', seriesName);\n        string memory logoSvg = Base64.encode(bytes(_logo.makeLogo(\n            tokenId.toString(), seriesName, series.fgColorRGB565, series.bgColorRGB565, series.accentColorRGB565)));\n\n        return bytes(string.concat(\n            '{\"description\": \"Neulock Password Manager membership NFT - neulock.app\", \"name\": \"NEU #',\n            tokenName,\n            '\", \"image\": \"data:image/svg+xml;base64,',\n            logoSvg,\n            '\", \"attributes\": [{\"trait_type\": \"Series\", \"value\": \"',\n            seriesName,\n            '\"},{\"trait_type\": \"Governance Access\", \"value\": \"',\n            governance,\n            '\"},{\"trait_type\": \"Series Max Supply\", \"value\": ',\n            uint256(series.maxTokens).toString(),\n            '},{\"trait_type\": \"Mint Date\", \"display_type\": \"date\", \"value\": ',\n            uint256(metadata.mintedAt).toString(),\n            '}]}'\n        ));\n    }\n\n    function _seriesOfToken(uint256 tokenId) private view returns (uint16) {\n        uint256 seriesLength = _series.length;\n\n        for (uint16 i = 0; i < seriesLength; i++) {\n            if (tokenId >= _series[i].firstToken && tokenId < _series[i].firstToken + _series[i].maxTokens) {\n                return i;\n            }\n        }\n\n        revert(\"Token does not belong to any series\");\n    }\n\n    function _makeMaskedTokenId(Series memory series) private pure returns (string memory) {\n        uint256 lastToken = series.firstToken + series.maxTokens - 1;\n        bytes memory lastTokenBytes = bytes(lastToken.toString());\n        bytes memory firstTokenBytes = bytes(uint256(series.firstToken).toString());\n\n        bool stoppedMatching = firstTokenBytes.length != lastTokenBytes.length;\n        bytes memory result = new bytes(lastTokenBytes.length);\n\n        for (uint256 i = 0; i < result.length; i++) {\n            if (!stoppedMatching && firstTokenBytes.length > i && lastTokenBytes[i] == firstTokenBytes[i]) {\n                result[i] = lastTokenBytes[i];\n            } else {\n                stoppedMatching = true;\n                result[i] = \"x\";\n            }\n        }\n\n        return string(result);\n    }\n\n    function _metadataExists(uint256 tokenId) private view returns (bool) {\n        // slither-disable-next-line timestamp (block miner cannot set timestamp in the past of previous block, so mintedAt == 0 can only mean the token does not exist)\n        return _tokenMetadata[tokenId].mintedAt != 0;\n    }\n\n    function _givesGovernanceAccess(uint16 seriesIndex) private view returns (bool) {\n        // Tokens whose name do not start with \"WAGMI\" give governance access\n        bytes32 wagmiNamePrefix = \"WAGMI\";\n\n        for (uint256 i = 0; i < 5; i++) {\n            if (_series[seriesIndex].name[i] != wagmiNamePrefix[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _setTraitMetadataURI(string memory uri) internal {\n        // Set the new trait metadata URI.\n        _traitMetadataURI = uri;\n\n        emit MetadataURIUpdated(uri);\n    }\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyRole(UPGRADER_ROLE)\n        override\n    {}\n}\n"
    }
}