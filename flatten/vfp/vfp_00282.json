{
    "vfp_id": "vfp_00282",
    "project_name": "Odos Router V3 - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "User-Controlled Referral Fee and Recipient",
            "description": "1. **Description:** The OdosRouterV3 contract now allows users to directly specify the referral fee and feeRecipient via the swapReferralInfo input parameter in multiple swap functions, removing reliance on an on-chain registry.\n\n2. **Cause:** The referral system was moved off-chain, and the contract no longer enforces referral data immutability or authorization. Instead, users can pass arbitrary values for fee and feeRecipient during swaps.\n\n3. **Exploitation:** A malicious actor could set a high fee and direct it to their own address, potentially misleading analytics or attempting to manipulate fee distribution systems, though actual fund diversion is limited by the contract's require checks.\n\n4. **Impact:** While the contract enforces that the feeRecipient is not zero and the fee is bounded (â‰¤2% of FEE_DENOM), the ability for any user to set arbitrary referral data may undermine the integrity of referral tracking and fee attribution, especially in systems relying on trust in referral sources.\n",
            "severity": "Low",
            "location": [
                "OdosRouterV3.sol::swapMulti",
                "OdosRouterV3.sol::_swap",
                "OdosRouterV3.sol::_swapMulti"
            ],
            "files": [
                "odos-router-v3/contracts/OdosRouterV3.sol"
            ]
        }
    ],
    "affected_files": {
        "OdosRouterV3.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"../interfaces/IOdosRouterV3.sol\";\nimport \"../interfaces/IOdosExecutor.sol\";\nimport \"../interfaces/IOdosHook.sol\";\nimport \"../interfaces/ISignatureTransfer.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n/// @title V3 Routing contract for Odos SOR\n/// @author Transaction Assembly\n/// @notice Wrapper with security gaurentees around execution of arbitrary operations on user tokens\ncontract OdosRouterV3 is IOdosRouterV3, Ownable2Step {\n  using SafeERC20 for IERC20;\n\n  /// @dev The zero address is uniquely used to represent eth since it is already\n  /// recognized as an invalid ERC20, and due to its gas efficiency\n  address constant _ETH = address(0);\n\n  /// @dev Address list where addresses can be cached for use when reading from storage is cheaper\n  // than reading from calldata. addressListStart is the storage slot of the first dynamic array element\n  uint256 private constant addressListStart = \n    29102676481673041902632991033461445430619272659676223336789171408008386403022;\n  address[] public addressList;\n\n  /// @dev Address which can access and liquidate funds held in the router\n  address public liquidatorAddress;\n\n  // @dev constant for the fee precision\n  uint256 public constant FEE_DENOM = 1e18;\n\n  constructor(address owner) Ownable(owner) { }\n\n  /// @dev Must exist in order for contract to receive eth\n  receive() external payable { }\n\n  /// @notice Custom decoder to swap with compact calldata for efficient execution on L2s\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    swapReferralInfo memory referralInfo;\n\n    address executor;\n    bytes calldata pathDefinition;\n    {\n      assembly {\n        // Define function to load in token address, either from calldata or from storage\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n\n          switch inputPos\n          // Reserve the null address as a special case that can be specified with 2 null bytes\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          // This case means that the address is encoded in the calldata directly following the code\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          // Otherwise we use the case to load in from the cached address list\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n\n        // Load in the input and output token addresses\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n\n        // Load in the input amount - a 0 byte means the full balance is to be used\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n\n        // Load in the quoted output amount\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n\n        // Load the slippage tolerance and use to get the minimum output amount\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n\n        // Load in the executor address\n        executor, pos := getAddress(pos)\n\n        // Load in the destination to send the input to - Zero denotes the executor\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n\n        // Load in the destination to send the output to - Zero denotes msg.sender\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0xC0), result)\n\n        let referralCode := shr(192, calldataload(pos))\n        pos := add(pos, 8)\n        mstore(referralInfo, referralCode)\n\n        let feeStatus := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n\n        if feeStatus {\n          let referralFee := shr(192, calldataload(pos))\n          pos := add(pos, 8)\n          mstore(add(referralInfo, 0x20), referralFee)\n\n          let referralBeneficiary := shr(96, calldataload(pos))\n          pos := add(pos, 20)\n          mstore(add(referralInfo, 0x40), referralBeneficiary)\n        }\n\n        // Set the offset and size for the pathDefinition portion of the msg.data\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing interface for swapping two tokens\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing interface for swapping two tokens with a call at the end\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  /// @param hookTarget the target address to call the hook on\n  /// @param hookData encoded data for a call to the hookTarget after the swap\n  function swapWithHook(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo,\n    address hookTarget,\n    bytes calldata hookData\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    amountOut = _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n    uint256[] memory hookAmountsIn = new uint256[](1);\n    hookAmountsIn[0] = amountOut;\n\n    IOdosHook(hookTarget).executeOdosHook(\n      hookData, \n      hookAmountsIn,\n      msg.sender\n    );\n  }\n\n  /// @notice Internal function for initiating approval transfers\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      // Support rebasing tokens by allowing the user to trade the entire balance\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, \"Wrong msg.value\");\n      }\n    }\n    else {\n      require(msg.value == 0, \"Wrong msg.value\");\n\n      // Support rebasing tokens by allowing the user to trade the entire balance\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing interface for swapping two tokens\n  /// @param permit2 All additional info for Permit2 transfers\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    return _swapPermit2(\n      permit2,\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing interface for swapping two tokens\n  /// @param permit2 All additional info for Permit2 transfers\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  /// @param hookTarget the target address to call the hook on\n  /// @param hookData encoded data for a call to the hookTarget after the swap\n  function swapPermit2WithHook(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo,\n    address hookTarget,\n    bytes calldata hookData\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    amountOut = _swapPermit2(\n      permit2,\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n    uint256[] memory hookAmountsIn = new uint256[](1);\n    hookAmountsIn[0] = amountOut;\n\n    IOdosHook(hookTarget).executeOdosHook(\n      hookData, \n      hookAmountsIn,\n      msg.sender\n    );\n  }\n\n  /// @notice Internal function for using permit2 before a swap\n  /// @param permit2 All additional info for Permit2 transfers\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function _swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice contains the main logic for swapping one token for another\n  /// Assumes input tokens have already been sent to their destinations and\n  /// that msg.value is set to expected ETH input value, or 0 for ERC20 input\n  /// @param tokenInfo All information about the tokens being swapped\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    // Check for valid output specifications\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, \"Minimum greater than quote\");\n    require(tokenInfo.outputMin > 0, \"Minimum output is zero\");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, \"Arbitrage not supported\");\n\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n\n    // Delegate the execution of the path to the specified Odos Executor\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n\n    if (referralInfo.fee > 0) {\n      require(referralInfo.feeRecipient != address(0), \"Null fee recipient\");\n      require(referralInfo.fee <= FEE_DENOM / 50, \"Fee too high\");\n\n      uint256 splitBPS = (referralInfo.code >> 32) & 65535;\n      if (splitBPS == 0) splitBPS = 8000;\n      require(splitBPS <= 10000, \"Invalid Ref Code\");\n\n      if (referralInfo.feeRecipient != address(this)) {\n        _universalTransfer(\n          tokenInfo.outputToken,\n          referralInfo.feeRecipient,\n          amountOut * referralInfo.fee * splitBPS / (FEE_DENOM * 10000)\n        );\n      }\n      amountOut = amountOut * (FEE_DENOM - referralInfo.fee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0 && (referralInfo.code >> 48) & 1 == 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, \"Slippage Limit Exceeded\");\n\n    // Transfer out the final output to the end user\n    _universalTransfer(\n      tokenInfo.outputToken, \n      tokenInfo.outputReceiver == address(0) ? msg.sender : tokenInfo.outputReceiver, \n      amountOut\n    );\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralInfo.code,\n      referralInfo.fee,\n      referralInfo.feeRecipient\n    );\n  }\n\n  /// @notice Custom decoder to swapMulti with compact calldata for efficient execution on L2s\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n\n    uint256 pos = 6;\n    {\n      uint256 numInputs;\n      uint256 numOutputs;\n\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n\n      assembly {\n        // Define function to load in token address, either from calldata or from storage\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n\n          switch inputPos\n          // Reserve the null address as a special case that can be specified with 2 null bytes\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          // This case means that the address is encoded in the calldata directly following the code\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          // Otherwise we use the case to load in from the cached address list\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n\n        let slippageTolerance := shr(232, calldataload(pos))\n        pos := add(pos, 3)\n\n        let result := 0\n        let memPos := 0\n\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n\n          // Load in the token address\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n\n          // Load in the input amount - a 0 byte means the full balance is to be used\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n\n          // Load in the token address\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n\n          // Load in the quoted output amount\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n\n          let outputQuote := shr(mul(sub(32, outputAmountLength), 8), calldataload(pos))\n          mstore(add(memPos, 0x20), outputQuote)\n          pos := add(pos, outputAmountLength)\n\n          // Set the minimum output amount as quote with slippage limit applied\n          mstore(add(memPos, 0x40), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n\n          result, pos := getAddress(pos)\n\n          mstore(add(memPos, 0x60), result)\n        }\n      }\n    }\n    swapReferralInfo memory referralInfo;\n    bytes calldata pathDefinition;\n\n    assembly {\n      let referralCode := shr(192, calldataload(pos))\n      pos := add(pos, 8)\n      mstore(referralInfo, referralCode)\n\n      let feeStatus := shr(248, calldataload(pos))\n      pos := add(pos, 1)\n\n      if feeStatus {\n        let referralFee := shr(192, calldataload(pos))\n        pos := add(pos, 8)\n        mstore(add(referralInfo, 0x20), referralFee)\n\n        let referralBeneficiary := shr(96, calldataload(pos))\n        pos := add(pos, 20)\n        mstore(add(referralInfo, 0x40), referralBeneficiary)\n      }\n\n      // Set the offset and size for the pathDefinition portion of the msg.data\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing interface for swapping between two sets of tokens\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing interface for swapping between two sets of tokens with a hook\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  /// @param hookTarget the target address to call the hook on\n  /// @param hookData encoded data for a call to the hookTarget after the swap\n  function swapMultiWithHook(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo,\n    address hookTarget,\n    bytes calldata hookData\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    amountsOut = _swapMultiApproval(\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n    IOdosHook(hookTarget).executeOdosHook(\n      hookData,\n      amountsOut,\n      msg.sender\n    );\n  }\n\n  /// @notice Internal logic for swapping between two sets of tokens with approvals\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    // If input amount is still 0 then that means the maximum possible input is to be used\n    uint256 expected_msg_value = 0;\n\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, \"Wrong msg.value\");\n\n    return _swapMulti(\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing function for swapping between two sets of tokens with Permit2\n  /// @param permit2 All additional info for Permit2 transfers\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiPermit2(\n      permit2,\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice Externally facing function for swapping between two sets of tokens with Permit2 with a hook\n  /// @param permit2 All additional info for Permit2 transfers\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  /// @param hookTarget the target address to call the hook on\n  /// @param hookData encoded data for a call to the hookTarget after the swap\n  function swapMultiPermit2WithHook(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo,\n    address hookTarget,\n    bytes calldata hookData\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    amountsOut = _swapMultiPermit2(\n      permit2,\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n    IOdosHook(hookTarget).executeOdosHook(\n      hookData,\n      amountsOut,\n      msg.sender\n    );\n  }\n\n  /// @notice Internal function for approcing with premit2 before swapping multiple tokens\n  /// @param permit2 All additional info for Permit2 transfers\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function _swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, \"Wrong msg.value\");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      pathDefinition,\n      executor,\n      referralInfo\n    );\n  }\n\n  /// @notice contains the main logic for swapping between two sets of tokens\n  /// assumes that inputs have already been sent to the right location and msg.value\n  /// is set correctly to be 0 for no native input and match native inpuit otherwise\n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  /// @param referralInfo referral info to specify the source of and fee for the swap\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor,\n    swapReferralInfo memory referralInfo\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    // Extract arrays of input amount values and tokens from the inputs struct list\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n\n    // Check input specification validity and transfer input tokens to executor\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            \"Duplicate source tokens\"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            \"Arbitrage not supported\"\n          );\n        }\n      }\n    }\n    // Check outputs for duplicates and record balances before swap\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      require(\n        outputs[i].amountMin <= outputs[i].amountQuote,\n        \"Minimum greater than quote\"\n      );\n      require(\n        outputs[i].amountMin > 0,\n        \"Minimum output is zero\"\n      );\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          \"Duplicate destination tokens\"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    // Delegate the execution of the path to the specified Odos Executor\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n\n    int256[] memory slippage = new int256[](outputs.length);\n    {\n      amountsOut = new uint256[](outputs.length);\n\n      uint256 splitBPS = (referralInfo.code >> 32) & 65535;\n      if (splitBPS == 0) splitBPS = 8000;\n      require(splitBPS <= 10000, \"Invalid Ref Code\");\n\n      for (uint256 i = 0; i < outputs.length; i++) {\n        // Record the destination token balance before the path is executed\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n\n        if (referralInfo.fee > 0) {\n          require(referralInfo.feeRecipient != address(0), \"Null fee recipient\");\n          require(referralInfo.fee <= FEE_DENOM / 50, \"Fee too high\");\n\n          if (referralInfo.feeRecipient != address(this)) {\n            _universalTransfer(\n              outputs[i].tokenAddress,\n              referralInfo.feeRecipient,\n              amountsOut[i] * referralInfo.fee * splitBPS / (FEE_DENOM * 10000)\n            );\n          }\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - referralInfo.fee) / FEE_DENOM;\n        }\n        slippage[i] = int256(amountsOut[i]) - int256(outputs[i].amountQuote);\n        if (slippage[i] > 0 && (referralInfo.code >> 48) & 1 == 0) {\n          amountsOut[i] = outputs[i].amountQuote;\n        }\n        require(amountsOut[i] >= outputs[i].amountMin, \"Slippage Limit Exceeded\");\n\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver == address(0) ? msg.sender : outputs[i].receiver,\n          amountsOut[i]\n        );\n      }\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      slippage,\n      referralInfo.code,\n      referralInfo.fee,\n      referralInfo.feeRecipient\n    );\n  }\n\n  /// @notice Changes the liquidator address\n  /// @param account The address of new liquidator\n  function changeLiquidatorAddress(address account)\n    external\n    onlyOwner\n  {\n    liquidatorAddress = account;\n    emit LiquidatorAddressChanged(account);\n  }\n\n  /// @notice Push new addresses to the cached address list for when storage is cheaper than calldata\n  /// @param addresses list of addresses to be added to the cached address list\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n\n  /// @notice Allows the owner to transfer funds held by the router contract\n  /// @param tokens List of token address to be transferred\n  /// @param amounts List of amounts of each token to be transferred\n  /// @param dest Address to which the funds should be sent\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n  {\n    require(msg.sender == liquidatorAddress || msg.sender == owner(), \"Address not allowed\");\n    require(tokens.length == amounts.length, \"Invalid funds transfer\");\n    \n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  \n  /// @notice Directly swap funds held in router \n  /// @param inputs list of input token structs for the path being executed\n  /// @param outputs list of output token structs for the path being executed\n  /// @param pathDefinition Encoded path definition for executor\n  /// @param executor Address of contract that will execute the path\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    returns (uint256[] memory amountsOut)\n  {\n    require(msg.sender == liquidatorAddress || msg.sender == owner(), \"Address not allowed\");\n\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    // Check outputs for duplicates and record balances before swap\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    // Delegate the execution of the path to the specified Odos Executor\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n\n      // Record the destination token balance before the path is executed\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n\n      require(amountsOut[i] >= outputs[i].amountMin, \"Slippage Limit Exceeded\");\n\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver == address(0) ? msg.sender : outputs[i].receiver,\n        amountsOut[i]\n      );\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      new int256[](outputs.length),\n      0,\n      0,\n      address(0)\n    );\n  }\n  \n  /// @notice helper function to get balance of ERC20 or native coin for this contract\n  /// @param token address of the token to check, null for native coin\n  /// @return balance of specified coin or token\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  \n  /// @notice helper function to transfer ERC20 or native coin\n  /// @param token address of the token being transferred, null for native coin\n  /// @param to address to transfer to\n  /// @param amount to transfer\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}(\"\");\n      require(success, \"ETH transfer failed\");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}\n"
    }
}