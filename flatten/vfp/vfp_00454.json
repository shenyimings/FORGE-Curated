{
    "vfp_id": "vfp_00454",
    "project_name": "ackee-blockchain-let's-get-hai-new-core-features-report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "User can claim all rewards, that StakingManager received from RewardPool",
            "description": "The StakingManager contract uses a reward accounting mechanism based on the `rewardIntegralFor` mapping to track per-user reward integrals. However, this mapping is only updated when users check their rewards via the `earned` function, not when they claim rewards via `getReward`. As a result, after claiming rewards, the integral remains unchanged, allowing a malicious user to repeatedly call `getReward` and drain all accumulated rewards from the StakingManager. This flaw stems from incorrect state management in the reward claiming logic. An attacker can exploit this by staking a minimal amount and repeatedly calling `getReward` after rewards are distributed, thereby claiming all available rewards before other legitimate stakers can claim theirs. The impact is severe, leading to complete loss of distributed rewards for honest users and undermining the fairness and integrity of the staking system.\n",
            "severity": "Critical",
            "location": [
                "StakingManager.sol::getReward",
                "StakingManager.sol::earned"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "User can inflate number of rewards by staking additional amount of rewards right before claiming them",
            "description": "The `StakingManager.sol` contract calculates rewards using the `rewardIntegral` and `rewardIntegralFor` variables, but it fails to update the `rewardIntegralFor` mapping before modifying the user's staked balance during stake or withdraw operations. This allows a user to manipulate the reward calculation by staking additional tokens just before claiming rewards. The root cause is incorrect ordering of operations in the reward calculation logic. An attacker can exploit this by staking a large amount of tokens right before claiming, thereby inflating their reward integral and receiving disproportionately high rewards. The impact is significant, as it can lead to substantial reward token inflation and financial loss for the protocol.\n",
            "severity": "Critical",
            "location": [
                "StakingManager.sol::stake",
                "StakingManager.sol::withdraw"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Front-running RewardDistributor.updateMerkleRoots allows double claim",
            "description": "The `updateMerkleRoots` function in the RewardDistributor contract does not prevent front-running attacks because it updates the active Merkle root without any safeguards. Since the contract maintains only one active root at a time, a malicious user can monitor the mempool for an upcoming root update transaction and front-run it by claiming rewards from the old root, then immediately claim again from the new root once the update is confirmed. This double claim is possible due to the lack of access control or pausing mechanism during root updates, despite such functionality existing in the contract. The root cause is the absence of a required pause-unpause procedure around root updates, despite such functionality existing in the contract. An attacker with sufficient capital and MEV infrastructure can exploit this by timing their claims around root updates, potentially draining the contract of funds and preventing other users from claiming their rightful rewards if the balance is exhausted. The impact includes financial loss and disruption of fair reward distribution.\n",
            "severity": "High",
            "location": [
                "RewardDistributor.sol::updateMerkleRoots",
                "RewardDistributor.sol::multiClaim"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "External interface IPessimisticVeloLpOracle is outdated",
            "description": "The `IPessimisticVeloLpOracle` interface defines a function `getCurrentPoolPrice`, but the actual implementation at the provided address uses `getCurrentPrice`, making the two incompatible. This mismatch causes any call to `_getPriceValue` through the interface to revert, breaking functionality in dependent contracts such as `BeefyVeloVaultRelayer` and `YearnVeloVaultRelayer`. The root cause is a failure to synchronize the interface definition with the deployed implementation, likely due to a refactor that was not reflected in the audited codebase. An attacker cannot directly exploit this for financial gain, but any user or protocol component relying on these oracle functions will experience failed transactions, leading to a denial of service. The impact is high in terms of system usability, as core oracle functionality becomes non-operational, potentially halting dependent processes in the protocol.\n",
            "severity": "High",
            "location": [
                "IPessimisticVeloLpOracle.sol::getCurrentPoolPrice",
                "BeefyVeloVaultRelayer.sol::getResultWithValidity",
                "YearnVeloVaultRelayer.sol::read"
            ],
            "files": [
                "core/src/interfaces/external/IPessimisticVeloLpOracle.sol",
                "core/src/contracts/oracles/BeefyVeloVaultRelayer.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "RewardPool._totalStaked variable updates incorrectly",
            "description": "The RewardPool contract maintains a _totalStaked variable to track the total amount of staked tokens in the StakingManager contract. This variable is updated when StakingManager stakes or withdraws tokens via the stake, increaseStake, and decreaseStake functions. However, when a new RewardPool contract connects to StakingManager after tokens are already staked, the _totalStaked variable in the new pool starts at zero and does not reflect the correct total staked amount. This leads to two potential exploit scenarios: first, a user's withdrawal may revert due to an incorrect balance check (when _wad > _totalStaked), and second, users may receive zero rewards from the new pool because reward calculations depend on _totalStaked being accurate. The root cause is the lack of initialization of _totalStaked with the actual total supply from the StakingToken contract upon deployment. This results in incorrect state tracking and potential denial of service for withdrawals or incorrect reward distribution.\n",
            "severity": "Medium",
            "location": [
                "RewardPool.sol::stake#100-104",
                "RewardPool.sol::increaseStake#107-110",
                "RewardPool.sol::decreaseStake#114-119"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "stakeToken can be transferred to any other address while it is still assumed staked",
            "description": "The `StakingManager.sol` contract tracks staked balances using the `stakedBalances` mapping, but it does not update this mapping when a user transfers their `stakeToken`. This creates a logic flaw where a user can sell or transfer their staked tokens while still retaining their staked balance record. The root cause is the lack of integration between token transfer events and staking balance updates. An attacker could exploit this by staking tokens, transferring them to another address (e.g., via a DEX), and still claiming rewards based on the original staked amount. This could lead to reward inflation and unfair distribution, allowing malicious actors to collect more rewards than they are entitled to.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Miscalculation of rewardToken distribution after withdrawal initiation in StakingManager",
            "description": "When a user initiates a withdrawal, their tokens enter a cooldown period during which they should no longer earn rewards. However, the reward distribution calculation still includes the total supply of staking tokens, including those in cooldown. This causes an incorrect distribution where part of the reward pool is not allocated and remains stuck in the contract. The root cause is the failure to exclude tokens in the withdrawal process from the reward calculation. While the impact is partially mitigated by the `emergencyWithdrawReward` function, this flaw still leads to inefficient reward distribution and potential loss of rewards for honest users.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect reward calculation when reward token is the same as staking token",
            "description": "When the staking token (KITE) is also used as a reward token, the `StakingManager.sol` contract fails to distinguish between staked tokens and reward tokens in its accounting. This leads to an inflation of rewards because the reward calculation erroneously includes staked tokens in the reward pool. The root cause is the lack of separate accounting for staked and reward balances when the tokens are the same. An attacker can exploit this by staking tokens and then claiming rewards, receiving a much larger amount than deserved due to the flawed calculation. This results in unfair reward distribution and potential depletion of the reward pool.\n",
            "severity": "Medium",
            "location": [
                "StakingManager.sol"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Queued rewards in RewardPool can become stuck",
            "description": "The RewardPool contract includes a queueNewRewards function that can place rewards into a queuedRewards state when the new reward ratio is less than or equal to the calculated _queuedRatio. These queued rewards are only moved into active distribution when a subsequent call to queueNewRewards occurs with a higher ratio. If no such call is made after existing rewards are fully distributed, the queued rewards remain permanently stuck in the contract and are never distributed to users. The root cause is the absence of an automatic mechanism to release queued rewards when the current reward period ends or when the reward balance is depleted. This creates a dependency on external intervention to release funds, which may never happen, leading to permanent loss of reward funds for users. Although the team acknowledged this as intentional, it still represents a logic flaw that could result in user funds being locked indefinitely.\n",
            "severity": "Low",
            "location": [
                "RewardDistributor.sol::queueNewRewards#172-177"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "A user can received rewards after withdrawal process has been initiated",
            "description": "In the StakingManager contract, users can initiate a withdrawal using initiateWithdrawal, wait for the cooldown period, and then call withdraw to retrieve their tokens. However, the contract continues to accrue rewards for a user's staked balance even after the withdrawal has been initiated and the tokens are eligible for withdrawal. This allows a user to stake tokens, immediately initiate withdrawal, and continue earning rewards indefinitely while still being able to withdraw their principal at any time after the cooldown. The root cause is the lack of logic to pause or stop reward accrual upon initiation of the withdrawal process. This undermines the intended staking mechanism by allowing users to effectively earn rewards without maintaining long-term stake, potentially leading to unfair reward distribution and reduced economic security of the protocol.\n",
            "severity": "Low",
            "location": [
                "StakingManager.sol::initiateWithdrawal",
                "StakingManager.sol::withdraw"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "StakingToken.burnFrom function does not emit StakingTokenBurn event",
            "description": "The StakingToken contract emits a StakingTokenBurn event in the burn function when tokens are burned by the owner, but fails to emit the same event in the burnFrom function, which allows approved spenders to burn tokens on behalf of another account. This inconsistency in event emission leads to incomplete off-chain tracking of token burns, as external systems relying on events will miss burns performed via burnFrom. The root cause is the omission of the event emission statement in the burnFrom function, despite calling _burn internally. This can result in inaccurate reporting of total burned supply and reduced transparency, potentially causing external services or users to lose trust in the protocol's data integrity.\n",
            "severity": "Low",
            "location": [
                "StakingToken.sol::burnFrom#77-80"
            ],
            "files": [
                "core/src/contracts/tokens/StakingToken.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Reward calculation state variables not updated in critical functions",
            "description": "The RewardPool contract uses several state variables—rewardPerTokenStored, lastUpdateTime, rewards, and rewardsPerTokenPaid—to calculate and distribute rewards accurately. However, these variables are not updated in the increaseStake and decreaseStake functions, which modify the staked balance and thus affect reward calculations. The root cause is the absence of the updateReward modifier on these functions, which is used elsewhere to synchronize reward state before balance changes. As a result, reward calculations may be based on outdated timestamps and reward rates, leading to incorrect or unfair reward distributions. This can cause users to receive less or more than their fair share of rewards, especially when stakes are increased or decreased between reward periods.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol::increaseStake#107-110",
                "RewardPool.sol::decreaseStake#114-119"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Potential underflow in math operations leads to unspecified errors",
            "description": "The RewardPool and StakingManager contracts contain arithmetic operations that are susceptible to underflow. In RewardPool, the expression `block.timestamp - (periodFinish - _params.duration)` can underflow if `block.timestamp + _params.duration < periodFinish`, which could occur if duration is decreased too much. In StakingManager, the line `stakedBalances[msg.sender] -= _wad` can underflow if `_wad` exceeds the user's balance during a withdrawal. The root cause is the lack of input validation and safe math checks before performing subtraction operations. Successful exploitation could lead to transaction reverts, denial of service, or in extreme cases, incorrect state updates if wrapped arithmetic is not enforced. This represents a data validation flaw that could disrupt normal contract operation.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol#168",
                "StakingManager.sol#143"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol",
                "core/src/contracts/tokens/StakingManager.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Oracle vault relayers lack non-zero price validation",
            "description": "The _getPriceValue function in both YearnVeloVaultRelayer and BeefyVeloVaultRelayer contracts computes a price using _veloLpBalance and _veloLpPrice, which are fetched from external sources. However, the function does not validate that these values are non-zero before using them in multiplication and division. If either value is zero due to a change in the external contract implementation or an oracle failure, the resulting price will be zero, which could lead to incorrect valuations and potentially catastrophic consequences for the protocol, such as incorrect collateral valuation or reward distribution. The root cause is the absence of a require() check ensuring that the final computed price is greater than zero. This is a data validation issue that increases reliance on external contracts' behavior without proper defensive programming.\n",
            "severity": "Informational",
            "location": [
                "YearnVeloVaultRelayer.sol::_getPriceValue#53-59",
                "BeefyVeloVaultRelayer.sol::_getPriceValue#53-59"
            ],
            "files": [
                "core/src/contracts/oracles/YearnVeloVaultRelayer.sol",
                "core/src/contracts/oracles/BeefyVeloVaultRelayer.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Unchecked return value of ERC20.transfer in RewardDistributor",
            "description": "The RewardDistributor contract calls ERC20.transfer in both the _claim and emergencyWithdraw functions but does not check the boolean return value. While most ERC-20 tokens revert on failure, some non-compliant tokens may return false instead of reverting. In such cases, the contract would proceed as if the transfer succeeded, emit a claim event, and mark the claim as completed, even though no tokens were transferred. This could result in permanent loss of user funds and prevent them from retrying the claim. The root cause is the lack of a return value check or use of a safe transfer library. Although a partial fix was implemented in _claim, the emergencyWithdraw function still lacks this check, leaving a critical function vulnerable.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::_claim",
                "RewardDistributor.sol::emergencyWithdraw"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emission for reward pool token staking",
            "description": "When users stake tokens through the StakingManager contract, the stake amount is distributed across active reward pools via internal calls to _rewardPool.stake(_wad). While the StakingManager emits a StakingManagerStaked event, it does not emit any event indicating which specific reward pools received the stake. This makes it difficult for off-chain services and users to track where their staked tokens are allocated. The root cause is the lack of an event emission after each _rewardPool.stake call. Although this does not affect on-chain functionality, it reduces transparency and complicates integration with external tools such as dashboards and analytics platforms.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol::stake",
                "StakingManager.sol#127-135"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol",
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "RewardDistributor._claim leaf is double hashed",
            "description": "In the RewardDistributor._claim function, the Merkle leaf is computed using double keccak256 hashing: `keccak256(bytes.concat(keccak256(abi.encode(...))))`. This is redundant because the Merkle proof verification only requires a single hash. The double hashing increases gas costs and requires off-chain systems to perform an extra hashing step, reducing computational efficiency. The root cause is unnecessary nesting of hash functions. While this does not introduce a security vulnerability, it represents a gas optimization and performance issue that could be improved by simplifying the leaf construction to a single hash.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::_claim#116"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol",
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "Magic numbers",
            "description": "The codebase contains multiple instances of magic numbers, such as 1e18 and 1000, used in calculations without explanatory context. For example, 1e18 is used as a fixed-point precision multiplier in reward calculations, and 1000 is used as a ratio multiplier in _queuedRatio. These values are not defined as named constants, making the code harder to read and maintain. The root cause is the direct use of numeric literals instead of symbolic constants. Although fixes were applied in later commits to replace 1e18 with WAD and 1000 with RATIO_MULTIPLIER, the initial code lacked this clarity, representing a code quality issue that could lead to errors during future modifications.\n",
            "severity": "Informational",
            "location": [
                "StakingManager.sol#335",
                "StakingManager.sol#351",
                "StakingManager.sol#367",
                "RewardPool.sol#150",
                "RewardPool.sol#155",
                "RewardPool.sol#170"
            ],
            "files": [
                "core/src/contracts/tokens/StakingManager.sol",
                "core/src/contracts/tokens/RewardPool.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1116"
                ]
            },
            "title": "Typos and missing documentation",
            "description": "The codebase contains several typos and documentation issues. Notably, the function emergencyWidthdraw in RewardDistributor contains a typo in its name and should be emergencyWithdraw. Additionally, the constructor parameter _cooldownPeriod is incorrectly documented as \"Address of the StakingToken contract\". Other issues include missing NatSpec documentation for struct fields, incorrect function names (e.g., authorizedAccounts instead of isAccountAuthorized), and missing source references in interface files. The root cause is insufficient code review and documentation hygiene. These issues reduce code readability and maintainability, and could mislead developers or auditors.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::emergencyWidthdraw",
                "StakingManager.sol#99",
                "Authorizable.sol::authorizedAccounts",
                "IStakingManager.sol::StakingManagerParams"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol",
                "core/src/interfaces/tokens/IStakingManager.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Code style inconsistencies",
            "description": "The codebase exhibits inconsistent style practices, such as unnecessary variable assignments (e.g., _uint256 = _data.toUint256()) when the value is used only once, and inconsistent use of curly braces for single-line if statements. Additionally, some _modifyParameters functions lack an else branch to revert on unrecognized parameters. The root cause is a lack of unified style guidelines across the team. While these do not affect functionality, they reduce code readability and maintainability. The issue was partially addressed by inlining variables in a later commit, but initial inconsistencies remained.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::_modifyParameters#130-136",
                "WrappedToken.sol::_modifyParameters#85",
                "StakingManager.sol::_modifyParameters#418-421"
            ],
            "files": [
                "core/src/contracts/tokens/RewardDistributor.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Optimization of function _getPriceValue",
            "description": "The _getPriceValue function is duplicated in both BeefyVeloVaultRelayer and YearnVeloVaultRelayer contracts, despite them sharing a common parent contract AbstractVeloVaultRelayer. This leads to code duplication and maintenance overhead. Furthermore, the function performs unnecessary multiplication and division (via wmul) when the price per share could be used directly. The root cause is failure to abstract shared logic into the parent contract and over-engineering of arithmetic operations. Although the team initially argued for readability, the function was later moved to the parent contract and optimized, confirming it as a valid code quality improvement.\n",
            "severity": "Informational",
            "location": [
                "BeefyVeloVaultRelayer.sol::_getPriceValue",
                "YearnVeloVaultRelayer.sol::_getPriceValue"
            ],
            "files": [
                "core/src/contracts/oracles/BeefyVeloVaultRelayer.sol",
                "core/src/contracts/oracles/YearnVeloVaultRelayer.sol",
                "core/src/contracts/oracles/AbstractVeloVaultRelayer.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused errors",
            "description": "Several custom errors are defined but never used in the codebase, including StakingManager_WithdrawNegativeAmount, StakingManager_InactiveRewardType, and relayer-specific InvalidPriceSource errors. These unused errors increase code bloat and may confuse developers. The root cause is either incomplete implementation or failure to remove deprecated code. Static analysis tools detected these issues. The errors were later removed in a commit, confirming they were unnecessary.\n",
            "severity": "Informational",
            "location": [
                "IStakingManager.sol#101",
                "IStakingManager.sol#116",
                "IBeefyVeloVaultRelayer.sol#14",
                "IYearnVeloVaultRelayer.sol#15"
            ],
            "files": [
                "core/src/interfaces/tokens/IStakingManager.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused using-for directives",
            "description": "The RewardPool and AbstractVeloVaultRelayer contracts include `using Math for uint256` directives, but the Math library functions are not used in these contracts. Similarly, a `using SafeERC20 for IERC20` directive was added to RewardDistributor but not used. These unused directives clutter the code and may mislead developers into thinking the library functions are being utilized. The root cause is incomplete cleanup after refactoring. Although some were removed in commits, new unused directives were introduced due to architectural changes, indicating an ongoing code hygiene issue.\n",
            "severity": "Informational",
            "location": [
                "RewardPool.sol#24",
                "AbstractVeloVaultRelayer.sol#15",
                "RewardDistributor.sol#23"
            ],
            "files": [
                "core/src/contracts/tokens/RewardPool.sol",
                "core/src/contracts/tokens/RewardDistributor.sol",
                "core/src/contracts/oracles/AbstractVeloVaultRelayer.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Variables should be immutable",
            "description": "Several state variables across multiple contracts (e.g., `protocolToken`, `rewardToken`, `factory`, `veloPool`, `veloLpOracle`) are declared as public but not marked as immutable, even though they are intended to remain constant after deployment. The root cause is the omission of the `immutable` keyword, which is a best practice for such variables. While these variables are not intended to be changed, not marking them as immutable may mislead developers into thinking they are mutable, and it also misses optimization opportunities. The impact is primarily on code clarity and gas efficiency, with no direct exploit path.\n",
            "severity": "Informational",
            "location": [
                "StakingToken.sol::protocolToken#39",
                "StakingManager.sol::protocolToken#35",
                "StakingManager.sol::stakingToken#38",
                "RewardPool.sol::rewardToken#30",
                "FactoryChild.sol::factory#14",
                "AbstractVeloVaultRelayer.sol::veloPool#20",
                "AbstractVeloVaultRelayer.sol::veloLpOracle#23"
            ],
            "files": [
                "core/src/contracts/tokens/StakingToken.sol",
                "core/src/contracts/tokens/StakingManager.sol",
                "core/src/contracts/tokens/RewardPool.sol",
                "core/src/contracts/oracles/AbstractVeloVaultRelayer.sol"
            ]
        }
    ],
    "affected_files": {
        "RewardPool.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {IRewardPool} from '@interfaces/tokens/IRewardPool.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\nimport {Math, RAY, WAD} from '@libraries/Math.sol';\n\n/**\n * @title  RewardPool\n * @notice This contract constitutes a reward pool for a given reward token\n */\ncontract RewardPool is Authorizable, Modifiable, IRewardPool {\n  using Encoding for bytes;\n  using Assertions for uint256;\n  using Assertions for address;\n  using Math for uint256;\n  using SafeERC20 for IERC20;\n\n  // --- Registry ---\n\n  /// @inheritdoc IRewardPool\n  IERC20 public rewardToken;\n\n  // --- Params ---\n\n  /// @inheritdoc IRewardPool\n  // solhint-disable-next-line private-vars-leading-underscore\n  RewardPoolParams public _params;\n\n  /// @inheritdoc IRewardPool\n  function params() external view returns (RewardPoolParams memory _rewardPoolParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  uint256 private _totalStaked;\n\n  /// @inheritdoc IRewardPool\n  function totalStaked() external view returns (uint256 _totalStakedAmt) {\n    return _totalStaked;\n  }\n\n  /// @inheritdoc IRewardPool\n  uint256 public rewardPerTokenStored;\n  /// @inheritdoc IRewardPool\n  uint256 public periodFinish = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewardRate = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public lastUpdateTime;\n  /// @inheritdoc IRewardPool\n  uint256 public queuedRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public currentRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public historicalRewards = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewardPerTokenPaid = 0;\n  /// @inheritdoc IRewardPool\n  uint256 public rewards = 0;\n\n  // --- Init ---\n\n  /**\n   * @param _rewardToken Address of the reward token\n   */\n  constructor(\n    address _rewardToken,\n    address _stakingManager,\n    uint256 _duration,\n    uint256 _newRewardRatio,\n    address _deployer\n  ) Authorizable(msg.sender) validParams {\n    if (_rewardToken == address(0)) revert RewardPool_InvalidRewardToken();\n    rewardToken = IERC20(_rewardToken);\n    _params.stakingManager = _stakingManager;\n    _params.duration = _duration;\n    _params.newRewardRatio = _newRewardRatio;\n    _addAuthorization(_deployer);\n    _addAuthorization(_stakingManager);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IRewardPool\n  function lastTimeRewardApplicable() public view returns (uint256 _lastTime) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  /// @inheritdoc IRewardPool\n  function stake(uint256 _wad) external updateReward isAuthorized {\n    if (_wad == 0) revert RewardPool_StakeNullAmount();\n    _totalStaked += _wad;\n    emit RewardPoolStaked(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function increaseStake(uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_IncreaseStakeNullAmount();\n    _totalStaked += _wad;\n    emit RewardPoolIncreaseStake(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function decreaseStake(uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_DecreaseStakeNullAmount();\n    if (_wad > _totalStaked) revert RewardPool_InsufficientBalance();\n    _totalStaked -= _wad;\n    emit RewardPoolDecreaseStake(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function withdraw(uint256 _wad, bool _claim) external updateReward isAuthorized {\n    if (_wad == 0) revert RewardPool_WithdrawNullAmount();\n    if (_wad > _totalStaked) revert RewardPool_InsufficientBalance();\n    if (_claim) {\n      _getReward();\n    }\n    _totalStaked -= _wad;\n    emit RewardPoolWithdrawn(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IRewardPool\n  function getReward() external updateReward isAuthorized {\n    _getReward();\n  }\n\n  function _getReward() internal {\n    uint256 _reward = earned();\n    if (_reward > 0) {\n      rewards = 0;\n      rewardToken.safeTransfer(_params.stakingManager, _reward);\n      emit RewardPoolRewardPaid(_params.stakingManager, _reward);\n    }\n  }\n\n  /// @inheritdoc IRewardPool\n  function rewardPerToken() public view returns (uint256 _rewardPerToken) {\n    if (_totalStaked == 0) return rewardPerTokenStored;\n    uint256 _timeElapsed = lastTimeRewardApplicable() - lastUpdateTime;\n    return rewardPerTokenStored + ((_timeElapsed * rewardRate * 1e18) / _totalStaked);\n  }\n\n  /// @inheritdoc IRewardPool\n  function earned() public view returns (uint256 _earned) {\n    return ((_totalStaked * (rewardPerToken() - rewardPerTokenPaid)) / 1e18) + rewards;\n  }\n\n  /// @inheritdoc IRewardPool\n  function queueNewRewards(uint256 _rewardsToQueue) external isAuthorized {\n    uint256 _totalRewards = _rewardsToQueue + queuedRewards;\n\n    if (block.timestamp >= periodFinish) {\n      notifyRewardAmount(_totalRewards);\n      queuedRewards = 0;\n      return;\n    }\n\n    uint256 _elapsedTime = block.timestamp - (periodFinish - _params.duration);\n    uint256 _currentAtNow = rewardRate * _elapsedTime;\n    uint256 _queuedRatio = (_currentAtNow * 1000) / _totalRewards;\n\n    if (_queuedRatio < _params.newRewardRatio) {\n      notifyRewardAmount(_totalRewards);\n      queuedRewards = 0;\n    } else {\n      queuedRewards = _totalRewards;\n    }\n  }\n\n  /// @inheritdoc IRewardPool\n  function notifyRewardAmount(uint256 _reward) public updateReward isAuthorized {\n    if (_reward == 0) revert RewardPool_InvalidRewardAmount();\n    historicalRewards = historicalRewards + _reward;\n    if (block.timestamp >= periodFinish) {\n      rewardRate = _reward / _params.duration;\n    } else {\n      uint256 _remaining = periodFinish - block.timestamp;\n      uint256 _leftover = _remaining * rewardRate;\n      _reward = _reward + _leftover;\n      rewardRate = _reward / _params.duration;\n    }\n    currentRewards = _reward;\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp + _params.duration;\n    emit RewardPoolRewardAdded(_reward);\n  }\n\n  /// @inheritdoc IRewardPool\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert RewardPool_WithdrawNullAmount();\n    IERC20(rewardToken).safeTransfer(_rescueReceiver, _wad);\n    emit RewardPoolEmergencyWithdrawal(msg.sender, _wad);\n  }\n\n  function updateRewardHelper() public updateReward isAuthorized {\n    // Empty function that just applies the modifier\n  }\n\n  // --- Modifiers ---\n\n  modifier updateReward() {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (msg.sender == _params.stakingManager) {\n      rewards = earned();\n      rewardPerTokenPaid = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    if (_param == 'stakingManager') {\n      _params.stakingManager = _data.toAddress();\n    } else if (_param == 'duration') {\n      _params.duration = _data.toUint256();\n    } else if (_param == 'newRewardRatio') {\n      _params.newRewardRatio = _data.toUint256();\n    } else {\n      revert UnrecognizedParam();\n    }\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    _params.duration.assertNonNull().assertGt(0);\n    _params.newRewardRatio.assertNonNull().assertGt(0);\n    address(_params.stakingManager).assertHasCode();\n  }\n}\n",
        "BeefyVeloVaultRelayer.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\n\nimport {IBeefyVeloVaultRelayer} from '@interfaces/oracles/IBeefyVeloVaultRelayer.sol';\n\nimport {IBeefyVaultV7} from '@interfaces/external/IBeefyVaultV7.sol';\nimport {IVeloPool} from '@interfaces/external/IVeloPool.sol';\nimport {IPessimisticVeloLpOracle} from '@interfaces/external/IPessimisticVeloLpOracle.sol';\n\nimport {Math, WAD} from '@libraries/Math.sol';\n\nimport {AbstractVeloVaultRelayer} from './AbstractVeloVaultRelayer.sol';\n\n/**\n * @title  BeefyVeloVaultRelayer\n * @notice Deconstructs a Beefy Vault to it's Velodrome liquidity pool and that pool's constituent tokens to return a price feed\n * @dev  Requires an underlying Velodrome pool and price feeds for the pool's tokens\n */\ncontract BeefyVeloVaultRelayer is AbstractVeloVaultRelayer, IBeefyVeloVaultRelayer {\n  using Math for uint256;\n\n  // --- Registry ---\n  /// @inheritdoc IBeefyVeloVaultRelayer\n  IBeefyVaultV7 public beefyVault;\n\n  // --- Init ---\n\n  /**\n   *\n   * @param  _beefyVault The address of the beefy vault contract\n   * @param  _veloPool The address of the velo pool underlying the beefy vault\n   * @param _veloLpOracle The address of the pessimistic velo lp oracle\n   */\n  constructor(\n    IBeefyVaultV7 _beefyVault,\n    IVeloPool _veloPool,\n    IPessimisticVeloLpOracle _veloLpOracle\n  ) AbstractVeloVaultRelayer(_veloPool, _veloLpOracle, string(abi.encodePacked(_beefyVault.symbol(), ' / USD'))) {\n    if (address(_beefyVault) == address(0)) {\n      revert BeefyVeloVaultRelayer_NullBeefyVault();\n    }\n\n    beefyVault = _beefyVault;\n  }\n\n  /// @notice Returns the price of the moo token\n  function _getPriceValue() internal view override returns (uint256 _combinedPriceValue) {\n    // 1 mooToken\n    uint256 _mooTokenBalance = 1_000_000_000_000_000_000;\n\n    // # of velo LP tokens in 1 mooToken\n    uint256 _veloLpBalance = _mooTokenBalance.wmul(beefyVault.getPricePerFullShare());\n\n    // price of 1 velo LP token in chainlink price decimals (8)\n    uint256 _veloLpPrice = veloLpOracle.getCurrentPoolPrice(address(veloPool));\n\n    return (_veloLpBalance * _veloLpPrice) / 1e8;\n  }\n}\n",
        "IPessimisticVeloLpOracle.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IPessimisticVeloLpOracle {\n  function getCurrentPoolPrice(address _pool) external view returns (uint256 _price);\n}\n",
        "YearnVeloVaultRelayer.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\n\nimport {IYearnVeloVaultRelayer} from '@interfaces/oracles/IYearnVeloVaultRelayer.sol';\n\nimport {IYearnVault} from '@interfaces/external/IYearnVault.sol';\nimport {IVeloPool} from '@interfaces/external/IVeloPool.sol';\nimport {IPessimisticVeloLpOracle} from '@interfaces/external/IPessimisticVeloLpOracle.sol';\n\nimport {Math, WAD} from '@libraries/Math.sol';\n\nimport {AbstractVeloVaultRelayer} from './AbstractVeloVaultRelayer.sol';\n\n/**\n * @title  YearnVeloVaultRelayer\n * @notice Deconstructs a Yearn Vault to it's Velodrome liquidity pool and that pool's constituent tokens to return a price feed\n * @dev  Requires an underlying Velodrome pool and price feeds for the pool's tokens\n */\ncontract YearnVeloVaultRelayer is AbstractVeloVaultRelayer, IYearnVeloVaultRelayer {\n  using Math for uint256;\n\n  // --- Registry ---\n  /// @inheritdoc IYearnVeloVaultRelayer\n  IYearnVault public yearnVault;\n\n  // --- Init ---\n\n  /**\n   *\n   * @param  _yearnVault The address of the yearn vault contract\n   * @param  _veloPool The address of the velo pool underlying the yearn vault\n   * @param _veloLpOracle The address of the pessimistic velo lp oracle\n   */\n  constructor(\n    IYearnVault _yearnVault,\n    IVeloPool _veloPool,\n    IPessimisticVeloLpOracle _veloLpOracle\n  ) AbstractVeloVaultRelayer(_veloPool, _veloLpOracle, string(abi.encodePacked(_yearnVault.symbol(), ' / USD'))) {\n    if (address(_yearnVault) == address(0)) {\n      revert YearnVeloVaultRelayer_NullYearnVault();\n    }\n\n    yearnVault = _yearnVault;\n  }\n\n  /// @notice Returns the price of the moo token\n  function _getPriceValue() internal view override returns (uint256 _combinedPriceValue) {\n    // 1 yvToken\n    uint256 _yvTokenBalance = 1_000_000_000_000_000_000;\n\n    // # of velo LP tokens in 1 yvToken\n    uint256 _veloLpBalance = _yvTokenBalance.wmul(yearnVault.pricePerShare());\n\n    // price of 1 velo LP token in chainlink price decimals (8)\n    uint256 _veloLpPrice = veloLpOracle.getCurrentPoolPrice(address(veloPool));\n\n    return (_veloLpBalance * _veloLpPrice) / 1e8;\n  }\n}\n",
        "StakingManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {IProtocolToken} from '@interfaces/tokens/IProtocolToken.sol';\nimport {IStakingToken} from '@interfaces/tokens/IStakingToken.sol';\n\nimport {IRewardPool} from '@interfaces/tokens/IRewardPool.sol';\n\nimport {IStakingManager} from '@interfaces/tokens/IStakingManager.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\n/**\n * @title  StakingManager\n * @notice This contract is used to manage staking positions\n *         and to distribute staking rewards\n */\ncontract StakingManager is Authorizable, Modifiable, IStakingManager {\n  using Encoding for bytes;\n  using Assertions for uint256;\n  using Assertions for address;\n  using SafeERC20 for IProtocolToken;\n  using SafeERC20 for IERC20;\n\n  // --- Registry ---\n\n  /// @inheritdoc IStakingManager\n  IProtocolToken public protocolToken;\n\n  /// @inheritdoc IStakingManager\n  IStakingToken public stakingToken;\n\n  // --- Params ---\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  StakingManagerParams public _params;\n\n  /// @inheritdoc IStakingManager\n  function params() external view returns (StakingManagerParams memory _stakingManagerParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IStakingManager\n  mapping(address => uint256) public stakedBalances;\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  mapping(address _account => PendingWithdrawal) public _pendingWithdrawals;\n\n  /// @inheritdoc IStakingManager\n  function pendingWithdrawals(address _account) external view returns (PendingWithdrawal memory _pendingWithdrawal) {\n    return _pendingWithdrawals[_account];\n  }\n\n  /// @inheritdoc IStakingManager\n  // solhint-disable-next-line private-vars-leading-underscore\n  mapping(uint256 _id => RewardType) public _rewardTypes;\n\n  /// @inheritdoc IStakingManager\n  function rewardTypes(uint256 _id) external view returns (RewardTypeInfo memory _rewardTypeInfo) {\n    RewardType storage _rewardType = _rewardTypes[_id];\n    return RewardTypeInfo({\n      rewardToken: _rewardType.rewardToken,\n      rewardPool: _rewardType.rewardPool,\n      isActive: _rewardType.isActive,\n      rewardIntegral: _rewardType.rewardIntegral,\n      rewardRemaining: _rewardType.rewardRemaining\n    });\n  }\n\n  /// @inheritdoc IStakingManager\n  function rewardIntegralFor(uint256 _id, address _user) external view returns (uint256 _rewardIntegral) {\n    return _rewardTypes[_id].rewardIntegralFor[_user];\n  }\n\n  /// @inheritdoc IStakingManager\n  function claimableReward(uint256 _id, address _user) external view returns (uint256 _claimableReward) {\n    return _rewardTypes[_id].claimableReward[_user];\n  }\n\n  /// @inheritdoc IStakingManager\n  uint256 public rewards;\n\n  // --- Init ---\n\n  /**\n   * @param  _protocolToken Address of the ProtocolToken contract\n   * @param  _stakingToken Address of the StakingToken contract\n   * @param  _cooldownPeriod Address of the StakingToken contract\n   */\n  constructor(\n    address _protocolToken,\n    address _stakingToken,\n    uint256 _cooldownPeriod\n  ) Authorizable(msg.sender) validParams {\n    stakingToken = IStakingToken(_stakingToken);\n    protocolToken = IProtocolToken(_protocolToken);\n    _params.cooldownPeriod = _cooldownPeriod;\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IStakingManager\n  function stake(address _account, uint256 _wad) external {\n    if (_account == address(0)) revert StakingManager_StakeNullReceiver();\n    if (_wad == 0) revert StakingManager_StakeNullAmount();\n\n    stakedBalances[_account] += _wad;\n\n    // Mint stKITE\n    stakingToken.mint(_account, _wad);\n\n    // transfer KITE\n    protocolToken.safeTransferFrom(msg.sender, address(this), _wad);\n\n    // Call stake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.stake(_wad);\n      }\n    }\n\n    emit StakingManagerStaked(_account, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function initiateWithdrawal(uint256 _wad) external {\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n    stakedBalances[msg.sender] -= _wad;\n\n    if (_existingWithdrawal.amount != 0) {\n      _existingWithdrawal.amount += _wad;\n      _existingWithdrawal.timestamp = block.timestamp;\n    } else {\n      _pendingWithdrawals[msg.sender] = PendingWithdrawal({amount: _wad, timestamp: block.timestamp});\n    }\n\n    // Call decreaseStake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.decreaseStake(_wad);\n      }\n    }\n\n    emit StakingManagerWithdrawalInitiated(msg.sender, _wad);\n  }\n  /// @inheritdoc IStakingManager\n\n  function cancelWithdrawal() external {\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n\n    if (_existingWithdrawal.amount == 0) {\n      revert StakingManager_NoPendingWithdrawal();\n    }\n\n    uint256 _withdrawalAmount = _existingWithdrawal.amount; // Store the amount before deleting\n\n    delete _pendingWithdrawals[msg.sender];\n\n    stakedBalances[msg.sender] += _withdrawalAmount; // use stored amount\n\n    // Call increaseStake in the reward pools\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      if (_rewardType.isActive) {\n        IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n        _rewardPool.increaseStake(_withdrawalAmount);\n      }\n    }\n\n    emit StakingManagerWithdrawalCancelled(msg.sender, _withdrawalAmount);\n  }\n\n  /// @inheritdoc IStakingManager\n  function withdraw() external {\n    PendingWithdrawal storage _existingWithdrawal = _pendingWithdrawals[msg.sender];\n\n    if (_existingWithdrawal.amount == 0) {\n      revert StakingManager_NoPendingWithdrawal();\n    }\n\n    if (block.timestamp - _existingWithdrawal.timestamp < _params.cooldownPeriod) {\n      revert StakingManager_CooldownPeriodNotElapsed();\n    }\n\n    uint256 _withdrawalAmount = _existingWithdrawal.amount; // Store amount first\n\n    delete _pendingWithdrawals[msg.sender];\n\n    stakingToken.burnFrom(msg.sender, _withdrawalAmount);\n\n    protocolToken.safeTransfer(msg.sender, _withdrawalAmount);\n\n    emit StakingManagerWithdrawn(msg.sender, _withdrawalAmount);\n  }\n\n  /// @inheritdoc IStakingManager\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    protocolToken.safeTransfer(_rescueReceiver, _wad);\n\n    emit StakingManagerEmergencyWithdrawal(_rescueReceiver, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function emergencyWithdrawReward(uint256 _id, address _rescueReceiver, uint256 _wad) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    if (_wad == 0) revert StakingManager_WithdrawNullAmount();\n\n    IERC20(_rewardTypes[_id].rewardToken).safeTransfer(_rescueReceiver, _wad);\n\n    // protocolToken.safeTransfer(_rescueReceiver, _wad);\n\n    emit StakingManagerEmergencyRewardWithdrawal(_rescueReceiver, _rewardTypes[_id].rewardToken, _wad);\n  }\n\n  /// @inheritdoc IStakingManager\n  function getReward(address _account) external {\n    _checkpointAndClaim([_account, _account]);\n  }\n\n  /// @inheritdoc IStakingManager\n  function getRewardAndForward(address _account, address _forwardTo) external {\n    if (msg.sender != _account) revert StakingManager_ForwardingOnly();\n\n    _checkpointAndClaim([_account, _forwardTo]);\n  }\n\n  /// @inheritdoc IStakingManager\n  function addRewardType(address _rewardToken, address _rewardPool) external isAuthorized {\n    if (_rewardToken == address(0)) revert StakingManager_NullRewardToken();\n    if (_rewardPool == address(0)) revert StakingManager_NullRewardPool();\n\n    uint256 _id = rewards;\n    rewards++;\n\n    RewardType storage _rewardType = _rewardTypes[_id];\n    _rewardType.rewardToken = _rewardToken;\n    _rewardType.rewardPool = _rewardPool;\n    _rewardType.isActive = true;\n    _rewardType.rewardIntegral = 0;\n    _rewardType.rewardRemaining = 0;\n\n    emit StakingManagerAddRewardType(_id, _rewardToken, _rewardPool);\n  }\n\n  /// @inheritdoc IStakingManager\n  function activateRewardType(uint256 _id) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    _rewardTypes[_id].isActive = true;\n    emit StakingManagerActivateRewardType(_id);\n  }\n\n  /// @inheritdoc IStakingManager\n  function deactivateRewardType(uint256 _id) external isAuthorized {\n    if (_rewardTypes[_id].rewardToken == address(0)) {\n      revert StakingManager_InvalidRewardType();\n    }\n    _rewardTypes[_id].isActive = false;\n    emit StakingManagerDeactivateRewardType(_id);\n  }\n\n  /// @inheritdoc IStakingManager\n  function earned(address _account) external returns (EarnedData[] memory _claimable) {\n    _checkpoint([_account, address(0)]);\n    return _earned(_account);\n  }\n\n  /// @inheritdoc IStakingManager\n  function checkpoint(address[2] memory _accounts) external {\n    _checkpoint(_accounts);\n  }\n\n  /// @inheritdoc IStakingManager\n  function userCheckpoint(address _account) external {\n    _checkpoint([_account, address(0)]);\n  }\n\n  function _earned(address _account) internal view returns (EarnedData[] memory _claimable) {\n    _claimable = new EarnedData[](rewards);\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n\n      if (_rewardType.rewardToken == address(0)) {\n        continue;\n      }\n\n      _claimable[_i].rewardToken = _rewardType.rewardToken;\n      _claimable[_i].rewardAmount = _rewardType.claimableReward[_account];\n    }\n    return _claimable;\n  }\n\n  // TODO: Check decimals\n  function _calcRewardIntegral(\n    uint256 _id,\n    address[2] memory _accounts,\n    uint256[2] memory _balances,\n    uint256 _supply,\n    bool _isClaim\n  ) internal {\n    RewardType storage _rewardType = _rewardTypes[_id];\n\n    if (!_rewardType.isActive) return;\n\n    uint256 _balance = IERC20(_rewardType.rewardToken).balanceOf(address(this));\n\n    // Checks if new rewards have been added by comparing current balance with rewardRemaining\n    if (_balance > _rewardType.rewardRemaining) {\n      uint256 _newRewards = _balance - _rewardType.rewardRemaining;\n      // If there are new rewards and there are existing stakers\n      if (_supply > 0) {\n        _rewardType.rewardIntegral += (_newRewards * 1e18) / _supply;\n        _rewardType.rewardRemaining = _balance;\n      }\n    }\n\n    for (uint256 _i = 0; _i < _accounts.length; _i++) {\n      if (_accounts[_i] == address(0)) continue;\n      if (_isClaim && _i != 0) continue; //only update/claim for first address and use second as forwarding\n\n      uint256 _userBalance = _balances[_i];\n      uint256 _userIntegral = _rewardType.rewardIntegralFor[_accounts[_i]];\n\n      if (_isClaim || _userIntegral < _rewardType.rewardIntegral) {\n        if (_isClaim) {\n          // Calculate total receiveable rewards\n          uint256 _receiveable = _rewardType.claimableReward[_accounts[_i]]\n            + (_userBalance * (_rewardType.rewardIntegral - _userIntegral)) / 1e18;\n\n          if (_receiveable > 0) {\n            // Reset claimable rewards to 0\n            _rewardType.claimableReward[_accounts[_i]] = 0;\n\n            // Transfer rewards to the next address in the array (forwarding address)\n            IERC20(_rewardType.rewardToken).safeTransfer(_accounts[_i + 1], _receiveable);\n\n            emit StakingManagerRewardPaid(_accounts[_i], _rewardType.rewardToken, _receiveable, _accounts[_i + 1]);\n            // Update the remaining balance\n            _balance = _balance - _receiveable;\n          }\n        } else {\n          // Just accumulate rewards without claiming\n          _rewardType.claimableReward[_accounts[_i]] = _rewardType.claimableReward[_accounts[_i]]\n            + (_userBalance * (_rewardType.rewardIntegral - _userIntegral)) / 1e18;\n\n          // Update user's reward integral\n          _rewardType.rewardIntegralFor[_accounts[_i]] = _rewardType.rewardIntegral;\n        }\n      }\n    }\n\n    // Update remaining reward here since balance could have changed if claiming\n    if (_balance != _rewardType.rewardRemaining) {\n      _rewardType.rewardRemaining = uint256(_balance);\n    }\n  }\n\n  function _checkpoint(address[2] memory _accounts) internal {\n    uint256 _supply = stakingToken.totalSupply();\n    uint256[2] memory _depositedBalance;\n    _depositedBalance[0] = stakingToken.balanceOf(_accounts[0]);\n    _depositedBalance[1] = stakingToken.balanceOf(_accounts[1]);\n\n    _claimManagerRewards();\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      _calcRewardIntegral(_i, _accounts, _depositedBalance, _supply, false);\n    }\n  }\n\n  function _checkpointAndClaim(address[2] memory _accounts) internal {\n    uint256 _supply = stakingToken.totalSupply();\n    uint256[2] memory _depositedBalance;\n    _depositedBalance[0] = stakingToken.balanceOf(_accounts[0]); //only do first slot\n\n    _claimManagerRewards();\n\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      _calcRewardIntegral(_i, _accounts, _depositedBalance, _supply, true);\n    }\n  }\n\n  function _claimManagerRewards() internal {\n    for (uint256 _i = 0; _i < rewards; _i++) {\n      RewardType storage _rewardType = _rewardTypes[_i];\n      IRewardPool _rewardPool = IRewardPool(_rewardType.rewardPool);\n      if (!_rewardType.isActive) continue;\n      _rewardPool.getReward();\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    if (_param == 'cooldownPeriod') _params.cooldownPeriod = _uint256;\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    _params.cooldownPeriod.assertNonNull().assertGt(0);\n    address(stakingToken).assertHasCode();\n    address(protocolToken).assertHasCode();\n  }\n}\n",
        "RewardDistributor.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport {Pausable} from '@openzeppelin/contracts/utils/Pausable.sol';\n\nimport {IRewardDistributor} from '@interfaces/tokens/IRewardDistributor.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\n/**\n * @title  RewardDistributor\n * @notice This contract distributes rewards to users to claim every 24 hours\n */\n\ncontract RewardDistributor is Authorizable, Modifiable, Pausable, IRewardDistributor {\n  using Encoding for bytes;\n\n  // --- Data ---\n\n  /// @inheritdoc IRewardDistributor\n  uint256 public epochCounter;\n  /// @inheritdoc IRewardDistributor\n  uint256 public epochDuration;\n  /// @inheritdoc IRewardDistributor\n  uint256 public lastUpdatedTime;\n  /// @inheritdoc IRewardDistributor\n  address public rootSetter;\n\n  /// @inheritdoc IRewardDistributor\n  mapping(address _token => bytes32 _root) public merkleRoots;\n  /// @inheritdoc IRewardDistributor\n  mapping(bytes32 _root => mapping(address _account => bool _hasClaimed)) public isClaimed;\n\n  // --- Init ---\n  constructor(uint256 _epochDuration, address _rootSetter) Authorizable(msg.sender) {\n    epochDuration = _epochDuration;\n    epochCounter = 0;\n    rootSetter = _rootSetter;\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IRewardDistributor\n  function pause() external isAuthorized {\n    _pause();\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function unpause() external isAuthorized {\n    _unpause();\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function updateMerkleRoots(address[] calldata _tokens, bytes32[] calldata _merkleRoots) external {\n    if (block.timestamp - lastUpdatedTime < epochDuration) {\n      revert RewardDistributor_TooSoonEpochNotElapsed();\n    }\n    if (msg.sender != rootSetter) revert RewardDistributor_NotRootSetter();\n    if (_tokens.length != _merkleRoots.length) {\n      revert RewardDistributor_ArrayLengthsMustMatch();\n    }\n\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n      if (_tokens[_i] == address(0)) {\n        revert RewardDistributor_InvalidTokenAddress();\n      }\n      if (_merkleRoots[_i] == bytes32(0)) {\n        revert RewardDistributor_InvalidMerkleRoot();\n      }\n      merkleRoots[_tokens[_i]] = _merkleRoots[_i];\n      emit RewardDistributorMerkleRootUpdated(_tokens[_i], _merkleRoots[_i], epochCounter);\n    }\n    lastUpdatedTime = block.timestamp;\n    epochCounter++;\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function claim(address _token, uint256 _wad, bytes32[] calldata _merkleProof) external whenNotPaused {\n    _claim(_token, _wad, _merkleProof);\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function multiClaim(\n    address[] calldata _tokens,\n    uint256[] calldata _wads,\n    bytes32[][] calldata _merkleProofs\n  ) external whenNotPaused {\n    if (_tokens.length != _wads.length || _wads.length != _merkleProofs.length) {\n      revert RewardDistributor_ArrayLengthsMustMatch();\n    }\n\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n      _claim(_tokens[_i], _wads[_i], _merkleProofs[_i]);\n    }\n  }\n\n  /// @inheritdoc IRewardDistributor\n  function emergencyWidthdraw(address _rescueReceiver, address _token, uint256 _wad) external isAuthorized {\n    if (_token == address(0)) {\n      revert RewardDistributor_InvalidTokenAddress();\n    }\n    if (_wad == 0) revert RewardDistributor_InvalidAmount();\n    IERC20(_token).transfer(_rescueReceiver, _wad);\n    emit RewardDistributorEmergencyWithdrawal(_rescueReceiver, _token, _wad);\n  }\n\n  function _claim(address _token, uint256 _wad, bytes32[] calldata _merkleProof) internal {\n    if (isClaimed[merkleRoots[_token]][msg.sender]) {\n      revert RewardDistributor_AlreadyClaimed();\n    }\n\n    bytes32 _leaf = keccak256(bytes.concat(keccak256(abi.encode(address(msg.sender), _wad))));\n\n    if (MerkleProof.verify(_merkleProof, merkleRoots[_token], _leaf)) {\n      isClaimed[merkleRoots[_token]][msg.sender] = true;\n      IERC20(_token).transfer(msg.sender, _wad);\n      emit RewardDistributorRewardClaimed(msg.sender, _token, _wad);\n    } else {\n      revert RewardDistributor_InvalidMerkleProof();\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    address _address = _data.toAddress();\n\n    if (_param == 'epochDuration') epochDuration = _uint256;\n    else if (_param == 'rootSetter') rootSetter = _address;\n    else revert UnrecognizedParam();\n  }\n}\n",
        "StakingToken.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IProtocolToken} from '@interfaces/tokens/IProtocolToken.sol';\nimport {IStakingToken} from '@interfaces/tokens/IStakingToken.sol';\n\nimport {IStakingManager} from '@interfaces/tokens/IStakingManager.sol';\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ERC20Permit, IERC20Permit} from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';\nimport {ERC20Votes} from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport {ERC20Burnable} from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\nimport {Time} from '@openzeppelin/contracts/utils/types/Time.sol';\nimport {Nonces} from '@openzeppelin/contracts/utils/Nonces.sol';\n\nimport {Authorizable} from '@contracts/utils/Authorizable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\n/**\n * @title  StakingToken\n * @notice This contract represents the staked protocol ERC20Votes token\n *         ERC20Votes is to potentially support voting with staked tokens in the future\n */\ncontract StakingToken is ERC20, ERC20Permit, ERC20Votes, ERC20Burnable, Authorizable, Modifiable, IStakingToken {\n  using Encoding for bytes;\n  using Assertions for address;\n\n  // --- Data ---\n\n  /// @notice Whether token transfers are enabled\n  bool public transfersEnabled;\n\n  // --- Registry ---\n\n  /// @inheritdoc IStakingToken\n  IProtocolToken public protocolToken;\n\n  /// @inheritdoc IStakingToken\n  IStakingManager public stakingManager;\n\n  // --- Init ---\n\n  /**\n   * @param  _name String with the name of the token\n   * @param  _symbol String with the symbol of the token\n   * @param  _protocolToken Address of the protocol token\n   */\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _protocolToken\n  ) ERC20(_name, _symbol) ERC20Permit(_name) Authorizable(msg.sender) {\n    if (_protocolToken == address(0)) {\n      revert StakingToken_NullProtocolToken();\n    }\n    protocolToken = IProtocolToken(_protocolToken);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IStakingToken\n  function mint(address _dst, uint256 _wad) external isAuthorized {\n    _mint(_dst, _wad);\n    emit StakingTokenMint(_dst, _wad);\n  }\n\n  /// @inheritdoc IStakingToken\n  function burn(uint256 _wad) public override(ERC20Burnable, IStakingToken) {\n    _burn(msg.sender, _wad);\n    emit StakingTokenBurn(msg.sender, _wad);\n  }\n\n  /// @inheritdoc IStakingToken\n  function burnFrom(address _account, uint256 _wad) public override(ERC20Burnable, IStakingToken) {\n    _spendAllowance(_account, msg.sender, _wad);\n    _burn(_account, _wad);\n  }\n\n  // --- Overrides ---\n\n  function _update(address _from, address _to, uint256 _value) internal override(ERC20, ERC20Votes) {\n    if (address(stakingManager) == address(0)) {\n      revert StakingToken_NullStakingManager();\n    }\n\n    // Check if transfers are enabled (skip check for minting and burning)\n    if (_from != address(0) && _to != address(0) && !transfersEnabled) {\n      revert StakingToken_TransfersDisabled();\n    }\n    stakingManager.checkpoint([_from, _to]);\n    super._update(_from, _to, _value);\n  }\n\n  function nonces(address _owner) public view override(ERC20Permit, IERC20Permit, Nonces) returns (uint256 _nonce) {\n    return super.nonces(_owner);\n  }\n\n  /**\n   * Set the clock to block timestamp, as opposed to the default block number.\n   */\n  function clock() public view override returns (uint48 _timestamp) {\n    return Time.timestamp();\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function CLOCK_MODE() public view virtual override returns (string memory _mode) {\n    return 'mode=timestamp';\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    if (_param == 'stakingManager') {\n      stakingManager = IStakingManager(_data.toAddress());\n    } else if (_param == 'transfersEnabled') {\n      transfersEnabled = _data.toBool();\n    } else {\n      revert UnrecognizedParam();\n    }\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    address(stakingManager).assertHasCode();\n  }\n}\n",
        "AbstractVeloVaultRelayer.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {IAbstractVeloVaultRelayer} from '@interfaces/oracles/IAbstractVeloVaultRelayer.sol';\nimport {IVeloPool} from '@interfaces/external/IVeloPool.sol';\nimport {IPessimisticVeloLpOracle} from '@interfaces/external/IPessimisticVeloLpOracle.sol';\nimport {Math, WAD} from '@libraries/Math.sol';\n\n/**\n * @title  AbstractVeloVaultRelayer\n * @notice Abstract contract for Velo vault relayers (Beefy, Yearn, etc.)\n */\nabstract contract AbstractVeloVaultRelayer is IAbstractVeloVaultRelayer {\n  using Math for uint256;\n\n  // --- Registry ---\n\n  /// @inheritdoc IAbstractVeloVaultRelayer\n  IVeloPool public veloPool;\n\n  /// @inheritdoc IAbstractVeloVaultRelayer\n  IPessimisticVeloLpOracle public veloLpOracle;\n\n  // --- Data ---\n\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  // --- Init ---\n\n  /**\n   *\n   * @param _veloPool The address of the velo pool underlying the yearn vault\n   * @param _veloLpOracle The address of the pessimistic velo lp oracle\n   * @param _symbol The symbol of the oracle\n   */\n  constructor(IVeloPool _veloPool, IPessimisticVeloLpOracle _veloLpOracle, string memory _symbol) {\n    if (address(_veloPool) == address(0)) {\n      revert AbstractVeloVaultRelayer_NullVeloPool();\n    }\n    if (address(_veloLpOracle) == address(0)) {\n      revert AbstractVeloVaultRelayer_NullVeloLpOracle();\n    }\n\n    veloPool = _veloPool;\n    veloLpOracle = _veloLpOracle;\n\n    symbol = _symbol;\n  }\n\n  /// @inheritdoc IBaseOracle\n  /// @notice This function always returns `_validity` as `true` since there are no conditions where the result would be invalid.\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    uint256 _totalValue = _getPriceValue();\n\n    return (_totalValue, true);\n  }\n  /// @inheritdoc IBaseOracle\n\n  function read() external view returns (uint256 _result) {\n    return _getPriceValue();\n  }\n\n  /// @notice Virtual function to be implemented by child contracts\n  function _getPriceValue() internal view virtual returns (uint256 _combinedPriceValue);\n}\n",
        "IStakingManager.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport {IProtocolToken} from '@interfaces/tokens/IProtocolToken.sol';\nimport {IStakingToken} from '@interfaces/tokens/IStakingToken.sol';\n\nimport {IAuthorizable} from '@interfaces/utils/IAuthorizable.sol';\nimport {IModifiable} from '@interfaces/utils/IModifiable.sol';\n\ninterface IStakingManager is IAuthorizable, IModifiable {\n  // --- Events ---\n\n  /**\n   * @notice Emitted when a new reward type is added\n   * @param  _id Id of the reward type\n   * @param  _rewardToken Address of the reward token\n   * @param  _rewardPool Address of the reward pool\n   */\n  event StakingManagerAddRewardType(uint256 indexed _id, address indexed _rewardToken, address indexed _rewardPool);\n\n  /**\n   * @notice Emitted when an existing reward type is activated\n   * @param  _id Id of the reward type\n   */\n  event StakingManagerActivateRewardType(uint256 indexed _id);\n\n  /**\n   * @notice Emitted when an existing reward type is deactivated\n   * @param  _id Id of the reward type\n   */\n  event StakingManagerDeactivateRewardType(uint256 indexed _id);\n\n  /**\n   * @notice Emitted when a user stakes tokens\n   * @param _account Address of the user staking the tokens\n   * @param _wad Amount of tokens staked\n   */\n  event StakingManagerStaked(address indexed _account, uint256 _wad);\n\n  /**\n   * @notice Emitted when a user initiates a withdrawal of staked tokens\n   * @param  _account Address of the user initiating the withdrawal\n   * @param  _wad Amount of tokens withdrawn\n   */\n  event StakingManagerWithdrawalInitiated(address indexed _account, uint256 _wad);\n\n  /**\n   * @notice Emitted when a user cancels a pending withdrawal of staked tokens\n   * @param  _account Address of the user that cancelled the withdrawal\n   * @param  _wad Amount of tokens in the cancelled withdrawal\n   */\n  event StakingManagerWithdrawalCancelled(address indexed _account, uint256 _wad);\n\n  /**\n   * @notice Emitted when a user withdraws staked tokens from a pending withdrawal\n   * @param  _account Address of the user that withdrew\n   * @param  _wad Amount of tokens withdrawn\n   */\n  event StakingManagerWithdrawn(address indexed _account, uint256 _wad);\n\n  /**\n   * @notice Emitted when an emergency withdrawal is executed\n   * @param  _account Address that the tokens were sent to from the emergency withdrawal\n   * @param  _wad Amount of tokens withdrawn\n   */\n  event StakingManagerEmergencyWithdrawal(address indexed _account, uint256 _wad);\n\n  /**\n   * @notice Emitted when an emergency reward withdrawal is executed\n   * @param  _account Address that the tokens were sent to from the emergency reward withdrawal\n   * @param  _rewardToken Address of the reward token\n   * @param  _wad Amount of reward tokens withdrawn\n   */\n  event StakingManagerEmergencyRewardWithdrawal(address indexed _account, address indexed _rewardToken, uint256 _wad);\n\n  /**\n   * @notice Emitted when a reward is paid to a user\n   * @param  _account Address of the user that earned the rewards\n   * @param  _rewardToken Address of the reward token\n   * @param  _wad Amount of rewards paid\n   * @param  _destination Address of the destination the rewards were sent to\n   */\n  event StakingManagerRewardPaid(\n    address indexed _account, address indexed _rewardToken, uint256 _wad, address indexed _destination\n  );\n\n  // --- Errors ---\n\n  /// @notice Throws when trying to access an invalid reward type\n  error StakingManager_InvalidRewardType();\n\n  /// @notice Throws when trying to stake a null amount\n  error StakingManager_StakeNullAmount();\n\n  /// @notice Throws when trying to stake and mint $stKITE to a null address\n  error StakingManager_StakeNullReceiver();\n\n  /// @notice Throws when trying to withdraw a null amount\n  error StakingManager_WithdrawNullAmount();\n\n  /// @notice Throws when trying to withdraw a negative amount\n  error StakingManager_WithdrawNegativeAmount();\n\n  /// @notice Throws when trying to cancel or withdraw with no pending withdrawal\n  error StakingManager_NoPendingWithdrawal();\n\n  /// @notice Throws when trying to withdraw and the cooldown period hasn't elapsed\n  error StakingManager_CooldownPeriodNotElapsed();\n\n  /// @notice Throws when trying to add a reward type with a null reward token\n  error StakingManager_NullRewardToken();\n\n  /// @notice Throws when trying to add a reward type with a null reward pool\n  error StakingManager_NullRewardPool();\n\n  /// @notice Throws when trying to calculate rewards on an inactive reward type\n  error StakingManager_InactiveRewardType();\n\n  /// @notice Throws when trying to forward rewards without being the account owner\n  error StakingManager_ForwardingOnly();\n\n  // --- Data ---\n\n  struct RewardType {\n    // Address of the reward token\n    address rewardToken;\n    // Address of the reward pool\n    address rewardPool;\n    // Flag if this reward type is currently active\n    bool isActive;\n    // Total amount of rewards accrued by the contract\n    uint256 rewardIntegral;\n    // Total amount of rewards remaining to be claimed\n    uint256 rewardRemaining;\n    // Stores reward integral for each user\n    mapping(address => uint256) rewardIntegralFor;\n    // Stores claimable rewards for each user\n    mapping(address => uint256) claimableReward;\n  }\n\n  struct RewardTypeInfo {\n    // Address of the reward token\n    address rewardToken;\n    // Address of the reward pool\n    address rewardPool;\n    // Flag if this reward type is currently active\n    bool isActive;\n    // Total amount of rewards accrued by the contract\n    uint256 rewardIntegral;\n    // Total amount of rewards remaining to be claimed\n    uint256 rewardRemaining;\n  }\n\n  struct EarnedData {\n    // Address of the reward token\n    address rewardToken;\n    // Amount of rewards\n    uint256 rewardAmount;\n  }\n\n  struct PendingWithdrawal {\n    // Amount of tokens withdrawal was initiated for\n    uint256 amount;\n    // Timestamp of when withdrawal was initiated\n    uint256 timestamp;\n  }\n\n  struct StakingManagerParams {\n    uint256 cooldownPeriod;\n  }\n\n  // --- Registry ---\n\n  /// @notice Address of the protocol token\n  function protocolToken() external view returns (IProtocolToken _protocolToken);\n\n  /// @notice Address of the staking token\n  function stakingToken() external view returns (IStakingToken _stakingToken);\n\n  // --- Params ---\n\n  /**\n   * @notice Getter for the contract parameters struct\n   * @return _params StakingManager parameters struct\n   */\n  function params() external view returns (StakingManagerParams memory _params);\n\n  /**\n   * @notice Getter for the unpacked contract parameters struct\n   * @return _cooldownPeriod How long a user has to wait before they can withdraw after initiating a withdrawal\n   */\n  // solhint-disable-next-line private-vars-leading-underscore\n  function _params() external view returns (uint256 _cooldownPeriod);\n\n  // --- Data ---\n\n  /**\n   * @notice The total amount of reward types\n   * @return _rewards Total amount of reward types [wad]\n   */\n  function rewards() external view returns (uint256 _rewards);\n\n  /**\n   * @notice Returns the reward type info for a given id\n   * @param  _id Id of the reward type\n   * @return _rewardTypeInfo RewardTypeInfo data struct containing non-mapping fields\n   */\n  function rewardTypes(uint256 _id) external view returns (RewardTypeInfo memory _rewardTypeInfo);\n\n  /**\n   * @notice Unpacked data of a reward type\n   * @param _id Id of the reward type\n   * @return _rewardToken Address of the reward token\n   * @return _rewardPool Address of the reward pool\n   * @return _isActive Flag if this reward type is currently active\n   * @return _rewardIntegral Total amount of rewards accrued by the contract\n   * @return _rewardRemaining Total amount of rewards remaining to be claimed\n   */\n  // solhint-disable-next-line private-vars-leading-underscore\n  function _rewardTypes(uint256 _id)\n    external\n    view\n    returns (\n      address _rewardToken,\n      address _rewardPool,\n      bool _isActive,\n      uint256 _rewardIntegral,\n      uint256 _rewardRemaining\n    );\n\n  /**\n   * @notice Returns the reward integral for a specific reward type and user\n   * @param  _id Id of the reward type\n   * @param  _user Address of the user\n   * @return _rewardIntegral The reward integral for the user\n   */\n  function rewardIntegralFor(uint256 _id, address _user) external view returns (uint256 _rewardIntegral);\n\n  /**\n   * @notice Returns the claimable reward for a specific reward type and user\n   * @param  _id Id of the reward type\n   * @param  _user Address of the user\n   * @return _claimableReward The claimable reward for the user\n   */\n  function claimableReward(uint256 _id, address _user) external view returns (uint256 _claimableReward);\n\n  /**\n   * @notice A mapping storing user's staked balances\n   * @param  _account Address of the user\n   * @return _stakedBalance User's staked balance [wad]\n   */\n  function stakedBalances(address _account) external view returns (uint256 _stakedBalance);\n\n  /**\n   * @notice Data of a pending withdrawal\n   * @param  _account Address of the user\n   * @return _pendingWithdrawal PendingWithdrawal type data struct\n   */\n  function pendingWithdrawals(address _account) external view returns (PendingWithdrawal memory _pendingWithdrawal);\n\n  /**\n   * @notice Unpacked data of a pending withdrawal\n   * @param _account Address of the user that initiated the withdrawal\n   * @return _amount Amount of tokens withdrawal was initiated for\n   * @return _timestamp Timestamp of when withdrawal was initiated\n   */\n  // solhint-disable-next-line private-vars-leading-underscore\n  function _pendingWithdrawals(address _account) external view returns (uint256 _amount, uint256 _timestamp);\n\n  // --- Methods ---\n\n  /**\n   * @notice Stake $KITE tokens\n   * @param _account Account that will receive the minted $stKITE\n   * @param _wad Amount of $KITE being staked [wad]\n   */\n  function stake(address _account, uint256 _wad) external;\n\n  /**\n   * @notice Initiates a pending withdrawal\n   * @param _wad Amount of $KITE being withdrawn [wad]\n   */\n  function initiateWithdrawal(uint256 _wad) external;\n\n  /**\n   * @notice Cancels a pending withdrawal\n   */\n  function cancelWithdrawal() external;\n\n  /**\n   * @notice Completes a pending withdrawal\n   */\n  function withdraw() external;\n\n  /**\n   * @notice Emergency withdraw all staked $KITE\n   * @param _rescueReceiver Account that will receive the withdrawn $KITE\n   * @param _wad Amount of $KITE being withdrawn [wad]\n   */\n  function emergencyWithdraw(address _rescueReceiver, uint256 _wad) external;\n\n  /**\n   * @notice Emergency withdraw rewards from the staking manager\n   * @param _id ID of the reward type\n   * @param _rescueReceiver Account that will receive the withdrawn tokens\n   * @param _wad Amount of tokens being withdrawn [wad]\n   */\n  function emergencyWithdrawReward(uint256 _id, address _rescueReceiver, uint256 _wad) external;\n\n  /**\n   * @notice Claims earned rewards\n   * @param _account Address of the account that will receive the rewards\n   */\n  function getReward(address _account) external;\n\n  /**\n   * @notice Claims and forwards earned rewards\n   * @param _account Address of the account that earned the rewards\n   * @param _forwardTo Address of the account that will receive the rewards\n   */\n  function getRewardAndForward(address _account, address _forwardTo) external;\n\n  /**\n   * @notice Add a new reward type\n   * @param _rewardToken Address of the reward token\n   * @param _rewardPool Address of the reward pool\n   */\n  function addRewardType(address _rewardToken, address _rewardPool) external;\n\n  /**\n   * @notice Activate an existing reward type\n   * @param _id ID of the reward type\n   */\n  function activateRewardType(uint256 _id) external;\n\n  /**\n   * @notice Deactivate an existing reward type\n   * @param _id ID of the reward type\n   */\n  function deactivateRewardType(uint256 _id) external;\n\n  /**\n   * @notice Check rewards earned for an account\n   * @param _account Account to check\n   */\n  function earned(address _account) external returns (EarnedData[] memory _claimable);\n\n  /**\n   * @notice Checkpoint account balances\n   * @param _accounts Accounts to checkpoint\n   */\n  function checkpoint(address[2] memory _accounts) external;\n\n  /**\n   * @notice Checkpoint account balance\n   * @param _account Account to checkpoint\n   */\n  function userCheckpoint(address _account) external;\n}\n"
    }
}