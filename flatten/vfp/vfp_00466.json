{
    "vfp_id": "vfp_00466",
    "project_name": "2025.05.03 - Final - Aegis.im YUSD Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Insolvency as YUSD will depeg overtime as the redemption fees are disbursed with no collaterals backing them.",
            "description": "1. **Description:** The protocol allows redemption of YUSD where the full collateral backing is sent to the user, but a fee is taken from the YUSD amount and burned, while the remaining YUSD is not backed by any collateral. This leads to an erosion of the collateral base over time, causing potential insolvency.\n2. **Cause:** The vulnerability arises because the redemption fee is taken from the YUSD amount without adjusting the collateral payout accordingly. The fee is not backed by any real collateral, yet it reduces the total YUSD supply without reducing the total collateral proportionally, leading to a negative yield for the protocol.\n3. **Exploitation:** As users continue to redeem YUSD, the accumulated fees (which are unbacked) increase, gradually depleting the effective collateral ratio. Over time, this causes the stablecoin to depeg due to loss of confidence in its backing.\n4. **Impact:** The protocol becomes insolvent as the collateral backing per YUSD decreases over time, leading to a collapse in the value of YUSD and loss of user funds.\n",
            "severity": "High",
            "location": [
                "AegisMinting.sol::approveRedeemRequest#(line numbers not specified)"
            ],
            "files": [
                "aegis-contracts/contracts/AegisMinting.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Collateral can get stuck in the minting contract under certain conditions or be accounted as profit",
            "description": "1. **Description:** Due to the untracked nature of collateral moved between the minting contract and custodial partners, collateral withdrawn for redemption can become stuck in the contract if the redemption request is rejected or canceled. Additionally, such stuck funds could be incorrectly treated as profit, leading to undercollateralized minting of YUSD.\n2. **Cause:** The system does not virtually account for funds that are pending redemption or income. The _untrackedAvailableAssetBalance function does not distinguish between funds intended for redemption and actual profit, creating ambiguity in fund usage.\n3. **Exploitation:** An attacker or regular user could trigger a redemption, cause it to fail post-withdrawal (e.g., via slippage, blacklisting, or expiration), leaving collateral stranded. Alternatively, an admin could intentionally classify stuck funds as profit and mint new YUSD without adding real collateral.\n4. **Impact:** Collateral remains locked in the contract and cannot be reused, harming the protocol's delta-neutral strategy. Worse, if these funds are declared as profit, undercollateralized YUSD is minted, accelerating de-pegging and risking insolvency.\n",
            "severity": "Medium",
            "location": [
                "AegisMinting.sol::_untrackedAvailableAssetBalance#(line numbers not specified)",
                "AegisMinting.sol::depositIncome#407-424"
            ],
            "files": [
                "aegis-contracts/contracts/AegisMinting.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "A whale adversary can grief the redeem functionality through redeem limit consumption",
            "description": "1. **Description:** The minting contract increments a global redemption limit when a redeem request is made but fails to decrement it when the request is withdrawn or rejected. This allows a malicious user to exhaust the redemption quota without consequence.\n2. **Cause:** The _checkMintRedeemLimit function increases the currentPeriodTotalAmount upon request, but no corresponding decrease occurs in withdrawRedeemRequest or _rejectRedeemRequest, creating a one-way accumulation of used limit.\n3. **Exploitation:** An attacker with sufficient YUSD can submit multiple redeem requests up to the period limit, blocking other users from redeeming. After the requests expire, the attacker withdraws their YUSD, leaving the limit still exhausted until the next period.\n4. **Impact:** Legitimate users are denied access to redemption functionality for the remainder of the period, resulting in a denial-of-service (DoS) that could lead to financial losses during critical market conditions.\n",
            "severity": "Medium",
            "location": [
                "AegisMinting.sol::_checkMintRedeemLimit#785-803",
                "AegisMinting.sol::withdrawRedeemRequest#373-390",
                "AegisMinting.sol::_rejectRedeemRequest#702-711"
            ],
            "files": [
                "aegis-contracts/contracts/AegisMinting.sol"
            ]
        }
    ],
    "affected_files": {
        "AegisMinting.sol": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/access/extensions/AccessControlDefaultAdminRules.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { FeedRegistryInterface } from \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport { Denominations } from \"@chainlink/contracts/src/v0.8/Denominations.sol\";\n\nimport { OrderLib } from \"./lib/OrderLib.sol\";\n\nimport { IAegisMintingEvents, IAegisMintingErrors } from \"./interfaces/IAegisMinting.sol\";\nimport { IAegisRewards } from \"./interfaces/IAegisRewards.sol\";\nimport { IAegisConfig } from \"./interfaces/IAegisConfig.sol\";\nimport { IAegisOracle } from \"./interfaces/IAegisOracle.sol\";\nimport { IYUSD } from \"./interfaces/IYUSD.sol\";\n\ncontract AegisMinting is IAegisMintingEvents, IAegisMintingErrors, AccessControlDefaultAdminRules, ReentrancyGuard {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using OrderLib for OrderLib.Order;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for IYUSD;\n\n  enum RedeemRequestStatus {\n    PENDING,\n    APPROVED,\n    REJECTED,\n    WITHDRAWN\n  }\n\n  struct RedeemRequest {\n    RedeemRequestStatus status;\n    OrderLib.Order order;\n    uint256 timestamp;\n  }\n\n  struct MintRedeemLimit {\n    uint32 periodDuration;\n    uint32 currentPeriodStartTime;\n    uint256 maxPeriodAmount;\n    uint256 currentPeriodTotalAmount;\n  }\n\n  uint16 constant MAX_BPS = 10_000;\n\n  /// @dev role enabling to update various settings\n  bytes32 private constant SETTINGS_MANAGER_ROLE = keccak256(\"SETTINGS_MANAGER_ROLE\");\n\n  /// @dev role enabling to deposit income/redeem and withdraw redeem\n  bytes32 private constant FUNDS_MANAGER_ROLE = keccak256(\"FUNDS_MANAGER_ROLE\");\n\n  /// @dev role enabling to transfer collateral to custody wallets\n  bytes32 private constant COLLATERAL_MANAGER_ROLE = keccak256(\"COLLATERAL_MANAGER_ROLE\");\n\n  /// @dev EIP712 domain\n  bytes32 private constant EIP712_DOMAIN = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  /// @dev EIP712 name\n  bytes32 private constant EIP712_NAME = keccak256(\"AegisMinting\");\n\n  /// @dev holds EIP712 revision\n  bytes32 private constant EIP712_REVISION = keccak256(\"1\");\n\n  /// @dev YUSD stablecoin\n  IYUSD public immutable yusd;\n\n  /// @dev AegisRewards contract\n  IAegisRewards public aegisRewards;\n\n  /// @dev AegisConfig contract\n  IAegisConfig public aegisConfig;\n\n  /// @dev AegisOracle contract providing YUSD/USD price\n  IAegisOracle public aegisOracle;\n\n  /// @dev InsuranceFund address\n  address public insuranceFundAddress;\n\n  /// @dev Percent of YUSD rewards that will be transferred to InsuranceFund address. Default: 5%\n  uint16 public incomeFeeBP = 500;\n\n  /// @dev Mint pause state\n  bool public mintPaused;\n\n  /// @dev Redeem pause state\n  bool public redeemPaused;\n\n  /// @dev Percent of YUSD that will be taken as a fee from mint amount\n  uint16 public mintFeeBP;\n\n  /// @dev Percent of YUSD that will be taken as a fee from redeem amount\n  uint16 public redeemFeeBP;\n\n  /// @dev Asset funds that were frozen and cannot be transfered to custody\n  mapping(address => uint256) public assetFrozenFunds;\n\n  /// @dev Mint limiting parameter\n  MintRedeemLimit public mintLimit;\n\n  /// @dev Redeem limiting parameters\n  MintRedeemLimit public redeemLimit;\n\n  /// @dev Tracks total amount of users locked YUSD for redeem requests\n  uint256 public totalRedeemLockedYUSD;\n\n  /// @dev Asset heartbeat of Chainlink feed in seconds\n  mapping(address => uint32) public chainlinkAssetHeartbeat;\n\n  /// @dev Chainlink FeedRegistry\n  FeedRegistryInterface private _feedRegistry;\n\n  /// @dev Supported assets\n  EnumerableSet.AddressSet private _supportedAssets;\n\n  /// @dev Custodian addresses\n  EnumerableSet.AddressSet private _custodianAddresses;\n\n  mapping(address => uint256) private _custodyTransferrableAssetFunds;\n\n  /// @dev Map of redeem request id to RedeemRequest struct\n  mapping(bytes32 => RedeemRequest) private _redeemRequests;\n\n  /// @dev holds computable chain id\n  uint256 private immutable _chainId;\n\n  /// @dev holds computable domain separator\n  bytes32 private immutable _domainSeparator;\n\n  /// @dev user order deduplication\n  mapping(address => mapping(uint256 => uint256)) private _orderBitmaps;\n\n  modifier onlyWhitelisted(address sender) {\n    if (!aegisConfig.isWhitelisted(sender)) {\n      revert NotWhitelisted();\n    }\n    _;\n  }\n\n  modifier onlySupportedAsset(address asset) {\n    if (!_supportedAssets.contains(asset)) {\n      revert InvalidAssetAddress(asset);\n    }\n    _;\n  }\n\n  modifier onlyCustodianAddress(address wallet) {\n    if (!_custodianAddresses.contains(wallet)) {\n      revert InvalidCustodianAddress(wallet);\n    }\n    _;\n  }\n\n  modifier whenRedeemUnpaused() {\n    if (redeemPaused) {\n      revert RedeemPaused();\n    }\n    _;\n  }\n\n  constructor(\n    IYUSD _yusd,\n    IAegisConfig _aegisConfig,\n    IAegisRewards _aegisRewards,\n    IAegisOracle _aegisOracle,\n    FeedRegistryInterface _fdRegistry,\n    address _insuranceFundAddress,\n    address[] memory _assets,\n    uint32[] memory _chainlinkAssetHeartbeats,\n    address[] memory _custodians,\n    address _admin\n  ) AccessControlDefaultAdminRules(3 days, _admin) {\n    if (address(_yusd) == address(0)) revert ZeroAddress();\n    if (address(_aegisRewards) == address(0)) revert ZeroAddress();\n    if (address(_aegisConfig) == address(0)) revert ZeroAddress();\n    if (_assets.length == 0) revert NotAssetsProvided();\n    require(_assets.length == _chainlinkAssetHeartbeats.length);\n\n    yusd = _yusd;\n    mintLimit.currentPeriodStartTime = uint32(block.timestamp);\n    redeemLimit.currentPeriodStartTime = uint32(block.timestamp);\n    _setAegisRewardsAddress(_aegisRewards);\n    _setAegisConfigAddress(_aegisConfig);\n    _setFeedRegistryAddress(_fdRegistry);\n    _setAegisOracleAddress(_aegisOracle);\n    _setInsuranceFundAddress(_insuranceFundAddress);\n\n    for (uint256 i = 0; i < _assets.length; i++) {\n      _addSupportedAsset(_assets[i], _chainlinkAssetHeartbeats[i]);\n    }\n\n    for (uint256 i = 0; i < _custodians.length; i++) {\n      _addCustodianAddress(_custodians[i]);\n    }\n\n    _chainId = block.chainid;\n    _domainSeparator = _computeDomainSeparator();\n  }\n\n  /// @dev Returns custody transferrable asset funds minus durty funds\n  function custodyAvailableAssetBalance(address asset) public view returns (uint256) {\n    return _custodyAvailableAssetBalance(asset);\n  }\n\n  /// @dev Returns asset balance minus custody transferrable and durty funds\n  function untrackedAvailableAssetBalance(address asset) public view returns (uint256) {\n    return _untrackedAvailableAssetBalance(asset);\n  }\n\n  /// @dev Returns RedeemRequest by id\n  function getRedeemRequest(string calldata requestId) public view returns (RedeemRequest memory) {\n    return _redeemRequests[keccak256(abi.encode(requestId))];\n  }\n\n  /// @dev Retuns asset/USD price from Chainlink feed\n  function assetChainlinkUSDPrice(address asset) public view returns (uint256) {\n    (uint256 price, ) = _getAssetUSDPriceChainlink(asset);\n    return price;\n  }\n\n  /// @dev Returns asset/YUSD price from AegisOracle\n  function assetAegisOracleYUSDPrice(address asset) public view returns (uint256) {\n    (uint256 price, ) = _getAssetYUSDPriceOracle(asset);\n    return price;\n  }\n\n  /**\n   * @dev Mints YUSD from assets\n   * @param order Struct containing order details\n   * @param signature Signature of trusted signer\n   */\n  function mint(\n    OrderLib.Order calldata order,\n    bytes calldata signature\n  ) external nonReentrant onlyWhitelisted(order.userWallet) onlySupportedAsset(order.collateralAsset) {\n    if (mintPaused) {\n      revert MintPaused();\n    }\n    if (order.orderType != OrderLib.OrderType.MINT) {\n      revert InvalidOrder();\n    }\n\n    _checkMintRedeemLimit(mintLimit, order.yusdAmount);\n    order.verify(getDomainSeparator(), aegisConfig.trustedSigner(), signature);\n    _deduplicateOrder(order.userWallet, order.nonce);\n\n    uint256 yusdAmount = _calculateMinYUSDAmount(order.collateralAsset, order.collateralAmount, order.yusdAmount);\n    if (yusdAmount < order.slippageAdjustedAmount) {\n      revert PriceSlippage();\n    }\n\n    // Take a fee, if it's applicable\n    (uint256 mintAmount, uint256 fee) = _calculateInsuranceFundFeeFromAmount(yusdAmount, mintFeeBP);\n    if (fee > 0) {\n      yusd.mint(insuranceFundAddress, fee);\n    }\n\n    IERC20(order.collateralAsset).safeTransferFrom(order.userWallet, address(this), order.collateralAmount);\n    yusd.mint(order.userWallet, mintAmount);\n    _custodyTransferrableAssetFunds[order.collateralAsset] += order.collateralAmount;\n\n    emit Mint(_msgSender(), order.collateralAsset, order.collateralAmount, mintAmount, fee);\n  }\n\n  /**\n   * @dev Creates new RedeemRequest and locks user's YUSD tokens\n   * @param order Struct containing order details\n   * @param signature Signature of trusted signer\n   */\n  function requestRedeem(\n    OrderLib.Order calldata order,\n    bytes calldata signature\n  ) external nonReentrant onlyWhitelisted(order.userWallet) whenRedeemUnpaused onlySupportedAsset(order.collateralAsset) {\n    if (order.orderType != OrderLib.OrderType.REDEEM) {\n      revert InvalidOrder();\n    }\n\n    _checkMintRedeemLimit(redeemLimit, order.yusdAmount);\n    order.verify(getDomainSeparator(), aegisConfig.trustedSigner(), signature);\n\n    uint256 collateralAmount = _calculateRedeemMinCollateralAmount(order.collateralAsset, order.collateralAmount, order.yusdAmount);\n    // Revert transaction when smallest amount is less than order minAmount\n    if (collateralAmount < order.slippageAdjustedAmount) {\n      revert PriceSlippage();\n    }\n\n    string memory requestId = abi.decode(order.additionalData, (string));\n    RedeemRequest memory request = _redeemRequests[keccak256(abi.encode(requestId))];\n    if (request.timestamp != 0) {\n      revert InvalidRedeemRequest();\n    }\n\n    _redeemRequests[keccak256(abi.encode(requestId))] = RedeemRequest(RedeemRequestStatus.PENDING, order, block.timestamp);\n\n    // Lock YUSD\n    yusd.safeTransferFrom(order.userWallet, address(this), order.yusdAmount);\n    totalRedeemLockedYUSD += order.yusdAmount;\n\n    emit CreateRedeemRequest(requestId, _msgSender(), order.collateralAsset, order.collateralAmount, order.yusdAmount);\n  }\n\n  /**\n   * @dev Approves pending RedeemRequest.\n   * @dev Burns locked YUSD and transfers collateral amount to request order benefactor\n   * @param requestId Id of RedeemRequest to approve\n   * @param amount Max collateral amount that will be transferred to user\n   */\n  function approveRedeemRequest(string calldata requestId, uint256 amount) external nonReentrant onlyRole(FUNDS_MANAGER_ROLE) whenRedeemUnpaused {\n    RedeemRequest storage request = _redeemRequests[keccak256(abi.encode(requestId))];\n    if (request.timestamp == 0 || request.status != RedeemRequestStatus.PENDING) {\n      revert InvalidRedeemRequest();\n    }\n    if (amount == 0 || amount > request.order.collateralAmount) {\n      revert InvalidAmount();\n    }\n\n    uint256 collateralAmount = _calculateRedeemMinCollateralAmount(request.order.collateralAsset, amount, request.order.yusdAmount);\n    /*\n     * Reject if:\n     * - asset is no longer supported\n     * - smallest amount is less than order minAmount\n     * - order expired\n     */\n    if (\n      !_supportedAssets.contains(request.order.collateralAsset) ||\n      collateralAmount < request.order.slippageAdjustedAmount ||\n      request.order.expiry < block.timestamp\n    ) {\n      _rejectRedeemRequest(requestId, request);\n      return;\n    }\n\n    uint256 availableAssetFunds = _untrackedAvailableAssetBalance(request.order.collateralAsset);\n    if (availableAssetFunds < collateralAmount) {\n      revert NotEnoughFunds();\n    }\n\n    // Take a fee, if it's applicable\n    (uint256 burnAmount, uint256 fee) = _calculateInsuranceFundFeeFromAmount(request.order.yusdAmount, redeemFeeBP);\n    if (fee > 0) {\n      yusd.safeTransfer(insuranceFundAddress, fee);\n    }\n\n    request.status = RedeemRequestStatus.APPROVED;\n    totalRedeemLockedYUSD -= request.order.yusdAmount;\n\n    IERC20(request.order.collateralAsset).safeTransfer(request.order.userWallet, collateralAmount);\n    yusd.burn(burnAmount);\n\n    emit ApproveRedeemRequest(requestId, _msgSender(), request.order.userWallet, request.order.collateralAsset, collateralAmount, burnAmount, fee);\n  }\n\n  /**\n   * @dev Rejects pending RedeemRequest and unlocks user's YUSD\n   * @param requestId Id of RedeemRequest to reject\n   */\n  function rejectRedeemRequest(string calldata requestId) external nonReentrant onlyRole(FUNDS_MANAGER_ROLE) whenRedeemUnpaused {\n    RedeemRequest storage request = _redeemRequests[keccak256(abi.encode(requestId))];\n    if (request.timestamp == 0 || request.status != RedeemRequestStatus.PENDING) {\n      revert InvalidRedeemRequest();\n    }\n\n    _rejectRedeemRequest(requestId, request);\n  }\n\n  /**\n   * @dev Withdraws expired RedeemRequest locked YUSD funds to user\n   * @param requestId Id of RedeemRequest to withdraw\n   */\n  function withdrawRedeemRequest(string calldata requestId) public nonReentrant whenRedeemUnpaused {\n    RedeemRequest storage request = _redeemRequests[keccak256(abi.encode(requestId))];\n    if (request.timestamp == 0 || request.status != RedeemRequestStatus.PENDING || request.order.expiry > block.timestamp) {\n      revert InvalidRedeemRequest();\n    }\n\n    request.status = RedeemRequestStatus.WITHDRAWN;\n\n    // Unlock YUSD\n    totalRedeemLockedYUSD -= request.order.yusdAmount;\n    yusd.safeTransfer(request.order.userWallet, request.order.yusdAmount);\n\n    emit WithdrawRedeemRequest(requestId, request.order.userWallet, request.order.yusdAmount);\n  }\n\n  /**\n   * @dev Mints YUSD rewards in exchange for collateral asset income\n   * @param order Struct containing order details\n   * @param signature Signature of trusted signer\n   */\n  function depositIncome(\n    OrderLib.Order calldata order,\n    bytes calldata signature\n  ) external nonReentrant onlyRole(FUNDS_MANAGER_ROLE) onlySupportedAsset(order.collateralAsset) {\n    if (order.orderType != OrderLib.OrderType.DEPOSIT_INCOME) {\n      revert InvalidOrder();\n    }\n    order.verify(getDomainSeparator(), aegisConfig.trustedSigner(), signature);\n    _deduplicateOrder(order.userWallet, order.nonce);\n\n    uint256 availableAssetFunds = _untrackedAvailableAssetBalance(order.collateralAsset);\n    if (availableAssetFunds < order.collateralAmount) {\n      revert NotEnoughFunds();\n    }\n\n    uint256 yusdAmount = _calculateMinYUSDAmount(order.collateralAsset, order.collateralAmount, order.yusdAmount);\n\n    _custodyTransferrableAssetFunds[order.collateralAsset] += order.collateralAmount;\n\n    // Transfer percent of YUSD rewards to insurance fund\n    (uint256 mintAmount, uint256 fee) = _calculateInsuranceFundFeeFromAmount(yusdAmount, incomeFeeBP);\n    if (fee > 0) {\n      yusd.mint(insuranceFundAddress, fee);\n    }\n\n    // Mint YUSD rewards to AegisRewards contract\n    yusd.mint(address(aegisRewards), mintAmount);\n    aegisRewards.depositRewards(order.additionalData, mintAmount);\n\n    emit DepositIncome(\n      abi.decode(order.additionalData, (string)),\n      _msgSender(),\n      order.collateralAsset,\n      order.collateralAmount,\n      mintAmount,\n      fee,\n      block.timestamp\n    );\n  }\n\n  /**\n   * @dev Transfers provided amount of asset to custodian wallet\n   * @param wallet Custodian address\n   * @param asset Asset address to transfer\n   * @param amount Asset amount to transfer\n   */\n  function transferToCustody(\n    address wallet,\n    address asset,\n    uint256 amount\n  ) external nonReentrant onlyRole(COLLATERAL_MANAGER_ROLE) onlySupportedAsset(asset) onlyCustodianAddress(wallet) {\n    uint256 availableBalance = _custodyAvailableAssetBalance(asset);\n    if (availableBalance < amount) {\n      revert NotEnoughFunds();\n    }\n\n    _custodyTransferrableAssetFunds[asset] -= amount;\n    IERC20(asset).safeTransfer(wallet, amount);\n\n    emit CustodyTransfer(wallet, asset, amount);\n  }\n\n  /**\n   * @dev Forcefully transfers all asset funds except frozen\n   * @param wallet Custodian address\n   * @param asset Asset address to transfer\n   */\n  function forceTransferToCustody(\n    address wallet,\n    address asset\n  ) external nonReentrant onlyRole(COLLATERAL_MANAGER_ROLE) onlySupportedAsset(asset) onlyCustodianAddress(wallet) {\n    uint256 availableBalance = _custodyAvailableAssetBalance(asset);\n    if (availableBalance == 0) {\n      revert NotEnoughFunds();\n    }\n\n    _custodyTransferrableAssetFunds[asset] -= availableBalance;\n    IERC20(asset).safeTransfer(wallet, availableBalance);\n\n    emit ForceCustodyTransfer(wallet, asset, availableBalance);\n  }\n\n  /// @dev Sets new AegisRewards address\n  function setAegisRewardsAddress(IAegisRewards _aegisRewards) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    if (address(_aegisRewards) == address(0)) {\n      revert ZeroAddress();\n    }\n    _setAegisRewardsAddress(_aegisRewards);\n  }\n\n  /// @dev Sets new AegisConfig address\n  function setAegisConfigAddress(IAegisConfig _config) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setAegisConfigAddress(_config);\n  }\n\n  /// @dev Sets new InsuranceFund address\n  function setInsuranceFundAddress(address _insuranceFundAddress) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    if (_insuranceFundAddress == address(this)) {\n      revert InvalidAddress();\n    }\n    _setInsuranceFundAddress(_insuranceFundAddress);\n  }\n\n  /// @dev Sets new FeedRegistry address\n  function setFeedRegistryAddress(FeedRegistryInterface _registry) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    _setFeedRegistryAddress(_registry);\n  }\n\n  /// @dev Sets new AegisOracle address\n  function setAegisOracleAddress(IAegisOracle _aegisOracle) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    _setAegisOracleAddress(_aegisOracle);\n  }\n\n  /// @dev Sets percent in basis points of YUSD that will be taken as a fee on depositIncome\n  function setIncomeFeeBP(uint16 value) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    // No more than 50%\n    if (value > MAX_BPS / 2) {\n      revert InvalidPercentBP(value);\n    }\n    incomeFeeBP = value;\n    emit SetIncomeFeeBP(value);\n  }\n\n  /// @dev Switches mint pause state\n  function setMintPaused(bool paused) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    mintPaused = paused;\n    emit MintPauseChanged(paused);\n  }\n\n  /// @dev Swtiches redeem pause state\n  function setRedeemPaused(bool paused) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    redeemPaused = paused;\n    emit RedeemPauseChanged(paused);\n  }\n\n  /// @dev Sets percent in basis points of YUSD that will be taken as a fee on mint\n  function setMintFeeBP(uint16 value) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    // No more than 50%\n    if (value > MAX_BPS / 2) {\n      revert InvalidPercentBP(value);\n    }\n    mintFeeBP = value;\n    emit SetMintFeeBP(value);\n  }\n\n  /// @dev Sets percent in basis points of YUSD that will be taken as a fee on redeem\n  function setRedeemFeeBP(uint16 value) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    // No more than 50%\n    if (value > MAX_BPS / 2) {\n      revert InvalidPercentBP(value);\n    }\n    redeemFeeBP = value;\n    emit SetRedeemFeeBP(value);\n  }\n\n  /// @dev Sets mint limit period duration and maximum amount\n  function setMintLimits(uint32 periodDuration, uint256 maxPeriodAmount) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    mintLimit.periodDuration = periodDuration;\n    mintLimit.maxPeriodAmount = maxPeriodAmount;\n    emit SetMintLimits(periodDuration, maxPeriodAmount);\n  }\n\n  /// @dev Sets redeem limit period duration and maximum amount\n  function setRedeemLimits(uint32 periodDuration, uint256 maxPeriodAmount) external onlyRole(SETTINGS_MANAGER_ROLE) {\n    redeemLimit.periodDuration = periodDuration;\n    redeemLimit.maxPeriodAmount = maxPeriodAmount;\n    emit SetRedeemLimits(periodDuration, maxPeriodAmount);\n  }\n\n  /// @dev Sets Chainlink feed heartbeat for asset\n  function setChainlinkAssetHeartbeat(address asset, uint32 heartbeat) external onlyRole(SETTINGS_MANAGER_ROLE) onlySupportedAsset(asset) {\n    chainlinkAssetHeartbeat[asset] = heartbeat;\n    emit SetChainlinkAssetHeartbeat(asset, heartbeat);\n  }\n\n  /// @dev Adds an asset to supporetd assets list\n  function addSupportedAsset(address asset, uint32 hearbeat) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addSupportedAsset(asset, hearbeat);\n  }\n\n  /// @dev Removes an asset from supported assets list\n  function removeSupportedAsset(address asset) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (!_supportedAssets.remove(asset)) {\n      revert InvalidAssetAddress(asset);\n    }\n    chainlinkAssetHeartbeat[asset] = 0;\n    emit AssetRemoved(asset);\n  }\n\n  /// @dev Checks if an asset is supported\n  function isSupportedAsset(address asset) public view returns (bool) {\n    return _supportedAssets.contains(asset);\n  }\n\n  /// @dev Adds custodian to custodians address list\n  function addCustodianAddress(address custodian) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addCustodianAddress(custodian);\n  }\n\n  /// @dev Removes custodian from custodians address list\n  function removeCustodianAddress(address custodian) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (!_custodianAddresses.remove(custodian)) {\n      revert InvalidCustodianAddress(custodian);\n    }\n    emit CustodianAddressRemoved(custodian);\n  }\n\n  /// @dev Freeze asset funds and prevent them from transferring to custodians or users\n  function freezeFunds(address asset, uint256 amount) external onlyRole(FUNDS_MANAGER_ROLE) onlySupportedAsset(asset) {\n    if (assetFrozenFunds[asset] + amount > IERC20(asset).balanceOf(address(this))) {\n      revert InvalidAmount();\n    }\n\n    assetFrozenFunds[asset] += amount;\n\n    emit FreezeFunds(asset, amount);\n  }\n\n  /// @dev Unfreeze asset funds and allow them for transferring to custodians or users\n  function unfreezeFunds(address asset, uint256 amount) external onlyRole(FUNDS_MANAGER_ROLE) onlySupportedAsset(asset) {\n    if (amount > assetFrozenFunds[asset]) {\n      revert InvalidAmount();\n    }\n\n    assetFrozenFunds[asset] -= amount;\n\n    emit UnfreezeFunds(asset, amount);\n  }\n\n  /// @dev Return cached value if chainId matches cache, otherwise recomputes separator\n  /// @return The domain separator at current chain\n  function getDomainSeparator() public view returns (bytes32) {\n    if (block.chainid == _chainId) {\n      return _domainSeparator;\n    }\n    return _computeDomainSeparator();\n  }\n\n  /// @dev verify validity of nonce by checking its presence\n  function verifyNonce(address sender, uint256 nonce) public view returns (uint256, uint256, uint256) {\n    if (nonce == 0) revert InvalidNonce();\n    uint256 invalidatorSlot = uint64(nonce) >> 8;\n    uint256 invalidatorBit = 1 << uint8(nonce);\n    uint256 invalidator = _orderBitmaps[sender][invalidatorSlot];\n    if (invalidator & invalidatorBit != 0) revert InvalidNonce();\n\n    return (invalidatorSlot, invalidator, invalidatorBit);\n  }\n\n  /// @dev deduplication of user order\n  function _deduplicateOrder(address sender, uint256 nonce) private {\n    (uint256 invalidatorSlot, uint256 invalidator, uint256 invalidatorBit) = verifyNonce(sender, nonce);\n    _orderBitmaps[sender][invalidatorSlot] = invalidator | invalidatorBit;\n  }\n\n  function _addSupportedAsset(address asset, uint32 heartbeat) internal {\n    if (asset == address(0) || asset == address(yusd) || !_supportedAssets.add(asset)) {\n      revert InvalidAssetAddress(asset);\n    }\n    chainlinkAssetHeartbeat[asset] = heartbeat;\n    emit AssetAdded(asset, heartbeat);\n  }\n\n  function _addCustodianAddress(address custodian) internal {\n    if (custodian == address(0) || custodian == address(yusd) || !_custodianAddresses.add(custodian)) {\n      revert InvalidCustodianAddress(custodian);\n    }\n    emit CustodianAddressAdded(custodian);\n  }\n\n  function _setInsuranceFundAddress(address _insuranceFundAddress) internal {\n    insuranceFundAddress = _insuranceFundAddress;\n    emit SetInsuranceFundAddress(insuranceFundAddress);\n  }\n\n  function _setAegisRewardsAddress(IAegisRewards _aegisRewards) internal {\n    aegisRewards = _aegisRewards;\n    emit SetAegisRewardsAddress(address(aegisRewards));\n  }\n\n  function _setAegisOracleAddress(IAegisOracle _aegisOracle) internal {\n    aegisOracle = _aegisOracle;\n    emit SetAegisOracleAddress(address(aegisOracle));\n  }\n\n  function _setAegisConfigAddress(IAegisConfig _config) internal {\n    if (address(_config) != address(0) && !IERC165(address(_config)).supportsInterface(type(IAegisConfig).interfaceId)) {\n      revert InvalidAddress();\n    }\n\n    aegisConfig = _config;\n    emit SetAegisConfigAddress(address(_config));\n  }\n\n  function _setFeedRegistryAddress(FeedRegistryInterface _registry) internal {\n    _feedRegistry = _registry;\n    emit SetFeedRegistryAddress(address(_registry));\n  }\n\n  function _rejectRedeemRequest(string calldata requestId, RedeemRequest storage request) internal {\n    request.status = RedeemRequestStatus.REJECTED;\n\n    // Unlock YUSD\n    totalRedeemLockedYUSD -= request.order.yusdAmount;\n    yusd.safeTransfer(request.order.userWallet, request.order.yusdAmount);\n\n    emit RejectRedeemRequest(requestId, _msgSender(), request.order.userWallet, request.order.yusdAmount);\n  }\n\n  function _custodyAvailableAssetBalance(address _asset) internal view returns (uint256) {\n    uint256 custodyTransferrableFunds = _custodyTransferrableAssetFunds[_asset];\n    uint256 balance = IERC20(_asset).balanceOf(address(this));\n    if (balance < custodyTransferrableFunds || custodyTransferrableFunds < assetFrozenFunds[_asset]) {\n      return 0;\n    }\n\n    return custodyTransferrableFunds - assetFrozenFunds[_asset];\n  }\n\n  function _untrackedAvailableAssetBalance(address _asset) internal view returns (uint256) {\n    uint256 balance = IERC20(_asset).balanceOf(address(this));\n    if (balance < _custodyTransferrableAssetFunds[_asset] + assetFrozenFunds[_asset]) {\n      return 0;\n    }\n\n    return balance - _custodyTransferrableAssetFunds[_asset] - assetFrozenFunds[_asset];\n  }\n\n  function _calculateInsuranceFundFeeFromAmount(uint256 amount, uint16 feeBP) internal view returns (uint256, uint256) {\n    if (insuranceFundAddress == address(0) || feeBP == 0) {\n      return (amount, 0);\n    }\n\n    uint256 fee = (amount * feeBP) / MAX_BPS;\n\n    return (amount - fee, fee);\n  }\n\n  function _calculateMinYUSDAmount(address collateralAsset, uint256 collateralAmount, uint256 yusdAmount) internal view returns (uint256) {\n    (uint256 chainlinkPrice, uint8 feedDecimals) = _getAssetUSDPriceChainlink(collateralAsset);\n    if (chainlinkPrice == 0) {\n      return yusdAmount;\n    }\n\n    uint256 chainlinkYUSDAmount = Math.mulDiv(\n      collateralAmount * 10 ** (18 - IERC20Metadata(collateralAsset).decimals()),\n      chainlinkPrice,\n      10 ** feedDecimals\n    );\n\n    // Return smallest amount\n    return Math.min(yusdAmount, chainlinkYUSDAmount);\n  }\n\n  function _calculateRedeemMinCollateralAmount(\n    address collateralAsset,\n    uint256 collateralAmount,\n    uint256 yusdAmount\n  ) internal view returns (uint256) {\n    // Calculate collateral amount for chainlink asset price.\n    (uint256 chainlinkPrice, uint8 feedDecimals) = _getAssetUSDPriceChainlink(collateralAsset);\n    if (chainlinkPrice > 0) {\n      uint256 chainlinkCollateralAmount = Math.mulDiv(\n        yusdAmount,\n        10 ** feedDecimals,\n        chainlinkPrice * 10 ** (18 - IERC20Metadata(collateralAsset).decimals())\n      );\n\n      // Get smallest amount\n      collateralAmount = Math.min(collateralAmount, chainlinkCollateralAmount);\n    }\n\n    // Calculate collateral amount for aegisOracle asset/YUSD price.\n    (uint256 oraclePrice, uint8 oracleDecimals) = _getAssetYUSDPriceOracle(collateralAsset);\n    if (oraclePrice > 0) {\n      uint256 oracleCollateralAmount = Math.mulDiv(\n        yusdAmount,\n        10 ** oracleDecimals,\n        oraclePrice * 10 ** (18 - IERC20Metadata(collateralAsset).decimals())\n      );\n\n      // Get smallest amount\n      collateralAmount = Math.min(collateralAmount, oracleCollateralAmount);\n    }\n\n    return collateralAmount;\n  }\n\n  function _checkMintRedeemLimit(MintRedeemLimit storage limits, uint256 yusdAmount) internal {\n    if (limits.periodDuration == 0 || limits.maxPeriodAmount == 0) {\n      return;\n    }\n    uint256 currentPeriodEndTime = limits.currentPeriodStartTime + limits.periodDuration;\n    if (\n      (currentPeriodEndTime >= block.timestamp && limits.currentPeriodTotalAmount + yusdAmount > limits.maxPeriodAmount) ||\n      (currentPeriodEndTime < block.timestamp && yusdAmount > limits.maxPeriodAmount)\n    ) {\n      revert LimitReached();\n    }\n    // Start new mint period\n    if (currentPeriodEndTime <= block.timestamp) {\n      limits.currentPeriodStartTime = uint32(block.timestamp);\n      limits.currentPeriodTotalAmount = 0;\n    }\n\n    limits.currentPeriodTotalAmount += yusdAmount;\n  }\n\n  function _getAssetUSDPriceChainlink(address asset) internal view returns (uint256, uint8) {\n    if (address(_feedRegistry) == address(0)) {\n      return (0, 0);\n    }\n\n    (, int256 answer, , uint256 updatedAt, ) = _feedRegistry.latestRoundData(asset, Denominations.USD);\n    require(answer > 0, \"Invalid price\");\n    require(updatedAt >= block.timestamp - chainlinkAssetHeartbeat[asset], \"Stale price\");\n\n    return (uint256(answer), _feedRegistry.decimals(asset, Denominations.USD));\n  }\n\n  function _getAssetYUSDPriceOracle(address asset) internal view returns (uint256, uint8) {\n    if (address(aegisOracle) == address(0)) {\n      return (0, 0);\n    }\n\n    int256 yusdUSDPrice = aegisOracle.yusdUSDPrice();\n    if (yusdUSDPrice == 0) {\n      return (0, 0);\n    }\n    uint8 yusdUSDPriceDecimals = aegisOracle.decimals();\n    (uint256 assetUSDPrice, ) = _getAssetUSDPriceChainlink(asset);\n\n    return ((assetUSDPrice * 10 ** yusdUSDPriceDecimals) / uint256(yusdUSDPrice), yusdUSDPriceDecimals);\n  }\n\n  function _computeDomainSeparator() internal view returns (bytes32) {\n    return keccak256(abi.encode(EIP712_DOMAIN, EIP712_NAME, EIP712_REVISION, block.chainid, address(this)));\n  }\n}\n"
    }
}