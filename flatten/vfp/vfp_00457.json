{
    "vfp_id": "vfp_00457",
    "project_name": "cantina_sky_lockstake_aug2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-732"
                ],
                "4": [
                    "CWE-279"
                ]
            },
            "title": "LockstakeInit.updateClipper is missing stUSDS.rely(clipper)",
            "description": "1. **Description:** The `updateClipper` function in `LockstakeInit` fails to call `stUSDS.rely(clipper)` when setting up a new clipper, which is necessary for the clipper to invoke `stUsds.cut(..)` during liquidations.\n2. **Cause:** The omission occurs despite logic to migrate state from the old clipper, suggesting an oversight in permission assignment during initialization.\n3. **Exploitation:** If the new clipper is activated without this reliance, any attempt to liquidate bad debt via `newClipper.take` will revert, disrupting the liquidation mechanism.\n4. **Impact:** This could lead to failure in handling undercollateralized positions, potentially resulting in unmanaged risk or loss of system stability until manually corrected.\n",
            "severity": "Low",
            "location": [
                "LockstakeInit.sol#L311"
            ],
            "files": [
                "lockstake/deploy/LockstakeInit.sol"
            ]
        }
    ],
    "affected_files": {
        "LockstakeInit.sol": "// SPDX-FileCopyrightText: Â© 2023 Dai Foundation <www.daifoundation.org>\n// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport { DssInstance } from \"dss-test/MCD.sol\";\nimport { LockstakeInstance } from \"./LockstakeInstance.sol\";\n\ninterface LockstakeSkyLike {\n    function rely(address) external;\n}\n\ninterface LockstakeEngineLike {\n    function voteDelegateFactory() external view returns (address);\n    function vat() external view returns (address);\n    function usdsJoin() external view returns (address);\n    function usds() external view returns (address);\n    function ilk() external view returns (bytes32);\n    function sky() external view returns (address);\n    function lssky() external view returns (address);\n    function fee() external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function file(bytes32, address) external;\n    function addFarm(address) external;\n}\n\ninterface LockstakeClipperLike {\n    function wards(address) external view returns (uint256);\n    function vat() external view returns (address);\n    function dog() external view returns (address);\n    function spotter() external view returns (address);\n    function engine() external view returns (address);\n    function calc() external view returns (address);\n    function cuttee() external view returns (address);\n    function ilk() external view returns (bytes32);\n    function buf() external view returns (uint256);\n    function tail() external view returns (uint256);\n    function cusp() external view returns (uint256);\n    function chip() external view returns (uint256);\n    function tip() external view returns (uint256);\n    function stopped() external view returns (uint256);\n    function count() external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function file(bytes32, address) external;\n    function file(bytes32, uint256) external;\n    function upchost() external;\n}\n\ninterface LockstakeMigratorLike {\n    function oldEngine() external view returns (address);\n    function newEngine() external view returns (address);\n    function mkrSky() external view returns (address);\n    function flash() external view returns (address);\n}\n\ninterface PipLike {\n    function rely(address) external;\n    function kiss(address) external;\n    function diss(address) external;\n}\n\ninterface CalcLike {\n    function file(bytes32, uint256) external;\n}\n\ninterface AutoLineLike {\n    function ilks(bytes32) external returns (uint256, uint256, uint48, uint48, uint48);\n    function remIlk(bytes32) external;\n}\n\ninterface OsmMomLike {\n    function setOsm(bytes32, address) external;\n}\n\ninterface LineMomLike {\n    function addIlk(bytes32) external;\n}\n\ninterface ClipperMomLike {\n    function tolerance(address) external view returns (uint256);\n    function setPriceTolerance(address, uint256) external;\n}\n\ninterface StakingRewardsLike {\n    function stakingToken() external view returns (address);\n}\n\ninterface IlkRegistryLike {\n    function file(bytes32, bytes32, address) external;\n    function put(bytes32, address, address, uint256, uint256, address, address, string memory, string memory) external;\n}\n\ninterface CutteeLike {\n    function rely(address) external;\n}\n\nstruct LockstakeConfig {\n    bytes32   ilk;\n    address[] farms;\n    uint256   fee;\n    uint256   dust;\n    uint256   duty;\n    uint256   mat;\n    uint256   buf;\n    uint256   tail;\n    uint256   cusp;\n    uint256   chip;\n    uint256   tip;\n    uint256   stopped;\n    uint256   chop;\n    uint256   hole;\n    uint256   tau;\n    uint256   cut;\n    uint256   step;\n    bool      lineMom;\n    uint256   tolerance;\n    string    name;\n    string    symbol;\n}\n\nstruct StackExtension {\n    LockstakeSkyLike lssky;\n    LockstakeEngineLike engine;\n    LockstakeClipperLike clipper;\n    CalcLike calc;\n    LockstakeMigratorLike migrator;\n    LockstakeEngineLike oldEngine;\n    AutoLineLike autoLine;\n    address sky;\n}\n\nlibrary LockstakeInit {\n    uint256 constant internal RATES_ONE_HUNDRED_PCT = 1000000021979553151239153027;\n    uint256 constant internal WAD = 10**18;\n    uint256 constant internal RAY = 10**27;\n    uint256 constant internal RAD = 10**45;\n\n    function initLockstake(\n        DssInstance        memory dss,\n        LockstakeInstance  memory lockstakeInstance,\n        LockstakeConfig    memory cfg\n    ) internal {\n        StackExtension memory se = StackExtension({\n            lssky:     LockstakeSkyLike(lockstakeInstance.lssky),\n            engine:    LockstakeEngineLike(lockstakeInstance.engine),\n            clipper:   LockstakeClipperLike(lockstakeInstance.clipper),\n            calc:      CalcLike(lockstakeInstance.clipperCalc),\n            migrator:  LockstakeMigratorLike(lockstakeInstance.migrator),\n            oldEngine: LockstakeEngineLike(dss.chainlog.getAddress(\"LOCKSTAKE_ENGINE\")),\n            autoLine:  AutoLineLike(dss.chainlog.getAddress(\"MCD_IAM_AUTO_LINE\")),\n            sky:       dss.chainlog.getAddress(\"SKY\")\n        });\n\n        bytes32 oldEngineIlk = se.oldEngine.ilk();\n\n        // Sanity checks\n        require(oldEngineIlk                    != cfg.ilk);\n        require(se.engine.voteDelegateFactory() == dss.chainlog.getAddress(\"VOTE_DELEGATE_FACTORY\"));\n        require(se.engine.vat()                 == address(dss.vat));\n        require(se.engine.usdsJoin()            == dss.chainlog.getAddress(\"USDS_JOIN\"));\n        require(se.engine.usds()                == dss.chainlog.getAddress(\"USDS\"));\n        require(se.engine.ilk()                 == cfg.ilk);\n        require(se.engine.sky()                 == se.sky);\n        require(se.engine.lssky()               == address(se.lssky));\n        require(se.engine.fee()                 == cfg.fee);\n        require(se.clipper.ilk()                == cfg.ilk);\n        require(se.clipper.vat()                == address(dss.vat));\n        require(se.clipper.engine()             == address(se.engine));\n        require(se.clipper.dog()                == address(dss.dog));\n        require(se.clipper.spotter()            == address(dss.spotter));\n        require(se.migrator.oldEngine()         == address(se.oldEngine));\n        require(se.migrator.newEngine()         == address(se.engine));\n        require(se.migrator.mkrSky()            == dss.chainlog.getAddress(\"MKR_SKY\"));\n        require(se.migrator.flash()             == dss.chainlog.getAddress(\"MCD_FLASH\"));\n        (,,, uint256 line,) = dss.vat.ilks(cfg.ilk);\n        require(line                            == 0);\n        (line,,,,) = se.autoLine.ilks(cfg.ilk);\n        require(line                            == 0);\n\n        require(cfg.dust <= cfg.hole);\n        require(cfg.duty >= RAY && cfg.duty <= RATES_ONE_HUNDRED_PCT);\n        require(cfg.mat >= RAY && cfg.mat < 10 * RAY);\n        require(cfg.buf >= RAY && cfg.buf < 10 * RAY);\n        require(cfg.cusp < RAY);\n        require(cfg.chip < WAD);\n        require(cfg.tip <= 1_000 * RAD);\n        require(cfg.chop >= WAD && cfg.chop < 2 * WAD);\n        require(cfg.tolerance < RAY);\n\n        se.oldEngine.rely(address(se.migrator));\n\n        dss.vat.file(oldEngineIlk, \"line\", 0); // Clean only ilk line, as there will probably be existing debt. Line can be adjusted in a later stage.\n        se.autoLine.remIlk(oldEngineIlk);\n\n        dss.vat.init(cfg.ilk);\n        dss.vat.file(cfg.ilk, \"dust\", cfg.dust);\n        dss.vat.rely(address(se.engine));\n        dss.vat.rely(address(se.clipper));\n        dss.vat.rely(address(se.migrator));\n\n        dss.jug.init(cfg.ilk);\n        dss.jug.file(cfg.ilk, \"duty\", cfg.duty);\n\n        address pip = dss.chainlog.getAddress(\"PIP_SKY\");\n        address clipperMom = dss.chainlog.getAddress(\"CLIPPER_MOM\");\n        PipLike(pip).kiss(address(dss.spotter));\n        PipLike(pip).kiss(address(se.clipper));\n        PipLike(pip).kiss(clipperMom);\n        PipLike(pip).kiss(address(dss.end));\n        // This assumes pip is a standard Osm sourced by a Median\n        {\n        address osmMom = dss.chainlog.getAddress(\"OSM_MOM\");\n        PipLike(pip).rely(osmMom);\n        OsmMomLike(osmMom).setOsm(cfg.ilk, pip);\n        }\n\n        dss.spotter.file(cfg.ilk, \"mat\", cfg.mat);\n        dss.spotter.file(cfg.ilk, \"pip\", pip);\n        dss.spotter.poke(cfg.ilk);\n\n        dss.dog.file(cfg.ilk, \"clip\", address(se.clipper));\n        dss.dog.file(cfg.ilk, \"chop\", cfg.chop);\n        dss.dog.file(cfg.ilk, \"hole\", cfg.hole);\n        dss.dog.rely(address(se.clipper));\n\n        se.lssky.rely(address(se.engine));\n\n        se.engine.file(\"jug\", address(dss.jug));\n        for (uint256 i = 0; i < cfg.farms.length; i++) {\n            require(StakingRewardsLike(cfg.farms[i]).stakingToken() == lockstakeInstance.lssky);\n            se.engine.addFarm(cfg.farms[i]);\n        }\n        se.engine.rely(address(se.clipper));\n\n        se.clipper.file(\"buf\",     cfg.buf);\n        se.clipper.file(\"tail\",    cfg.tail);\n        se.clipper.file(\"cusp\",    cfg.cusp);\n        se.clipper.file(\"chip\",    cfg.chip);\n        se.clipper.file(\"tip\",     cfg.tip);\n        se.clipper.file(\"stopped\", cfg.stopped);\n        se.clipper.file(\"vow\",     address(dss.vow));\n        se.clipper.file(\"calc\",    address(se.calc));\n        se.clipper.upchost();\n        se.clipper.rely(address(dss.dog));\n        se.clipper.rely(address(dss.end));\n        se.clipper.rely(clipperMom);\n\n        if (cfg.tau  > 0) se.calc.file(\"tau\",  cfg.tau);\n        if (cfg.cut  > 0) se.calc.file(\"cut\",  cfg.cut);\n        if (cfg.step > 0) se.calc.file(\"step\", cfg.step);\n\n        if (cfg.lineMom) {\n            LineMomLike(dss.chainlog.getAddress(\"LINE_MOM\")).addIlk(cfg.ilk);\n        }\n\n        if (cfg.tolerance > 0) {\n            ClipperMomLike(clipperMom).setPriceTolerance(address(se.clipper), cfg.tolerance);\n        }\n\n        IlkRegistryLike(dss.chainlog.getAddress(\"ILK_REGISTRY\")).put(\n            cfg.ilk,\n            address(0),\n            se.sky,\n            18,\n            7, // New class\n            pip,\n            address(se.clipper),\n            cfg.name,\n            cfg.symbol\n        );\n\n        dss.chainlog.setAddress(\"LOCKSTAKE_MKR_OLD_V1\",       dss.chainlog.getAddress(\"LOCKSTAKE_MKR\"));\n        dss.chainlog.setAddress(\"LOCKSTAKE_ENGINE_OLD_V1\",    address(se.oldEngine));\n        dss.chainlog.setAddress(\"LOCKSTAKE_CLIP_OLD_V1\",      dss.chainlog.getAddress(\"LOCKSTAKE_CLIP\"));\n        dss.chainlog.setAddress(\"LOCKSTAKE_CLIP_CALC_OLD_V1\", dss.chainlog.getAddress(\"LOCKSTAKE_CLIP_CALC\"));\n        dss.chainlog.removeAddress(\"LOCKSTAKE_MKR\");\n\n        dss.chainlog.setAddress(\"LOCKSTAKE_SKY\",       address(se.lssky));\n        dss.chainlog.setAddress(\"LOCKSTAKE_ENGINE\",    address(se.engine));\n        dss.chainlog.setAddress(\"LOCKSTAKE_CLIP\",      address(se.clipper));\n        dss.chainlog.setAddress(\"LOCKSTAKE_CLIP_CALC\", address(se.calc));\n        dss.chainlog.setAddress(\"LOCKSTAKE_MIGRATOR\",  address(se.migrator));\n    }\n\n    struct StackExtension2 {\n        LockstakeEngineLike engine;\n        LockstakeClipperLike clipper;\n        LockstakeClipperLike oldClipper;\n        ClipperMomLike clipperMom;\n    }\n\n    function updateClipper(\n        DssInstance memory dss,\n        address            clipper_,\n        address            cuttee\n    ) internal {\n        StackExtension2 memory se = StackExtension2({\n            engine:     LockstakeEngineLike(dss.chainlog.getAddress(\"LOCKSTAKE_ENGINE\")),\n            clipper:    LockstakeClipperLike(clipper_),\n            oldClipper: LockstakeClipperLike(dss.chainlog.getAddress(\"LOCKSTAKE_CLIP\")),\n            clipperMom: ClipperMomLike(dss.chainlog.getAddress(\"CLIPPER_MOM\"))\n        });\n\n        require(se.clipper.vat()                            == address(dss.vat));\n        require(se.clipper.engine()                         == address(se.engine));\n        require(se.clipper.dog()                            == address(dss.dog));\n        require(se.clipper.spotter()                        == address(dss.spotter));\n        require(se.oldClipper.stopped()                     == 3);\n        require(se.oldClipper.count()                       == 0);\n        require(se.oldClipper.wards(address(se.clipperMom)) == 0);\n\n        dss.vat.rely(address(se.clipper));\n        dss.vat.deny(address(se.oldClipper));\n\n        address pip = dss.chainlog.getAddress(\"PIP_SKY\");\n        PipLike(pip).kiss(address(se.clipper));\n        PipLike(pip).diss(address(se.oldClipper));\n\n        bytes32 ilk = se.clipper.ilk();\n        dss.dog.file(ilk, \"clip\", address(se.clipper));\n        dss.dog.rely(address(se.clipper));\n        dss.dog.deny(address(se.oldClipper));\n\n        se.engine.rely(address(se.clipper));\n        se.engine.deny(address(se.oldClipper));\n\n        se.clipper.file(\"buf\",     se.oldClipper.buf());\n        se.clipper.file(\"tail\",    se.oldClipper.tail());\n        se.clipper.file(\"cusp\",    se.oldClipper.cusp());\n        se.clipper.file(\"chip\",    se.oldClipper.chip());\n        se.clipper.file(\"tip\",     se.oldClipper.tip());\n        se.clipper.file(\"stopped\", 3);\n        se.clipper.file(\"vow\",     address(dss.vow));\n        se.clipper.file(\"calc\",    se.oldClipper.calc());\n        se.clipper.file(\"cuttee\",  cuttee);\n        se.clipper.upchost();\n        se.clipper.rely(address(dss.dog));\n        se.oldClipper.deny(address(dss.dog));\n        se.clipper.rely(address(dss.end));\n        se.oldClipper.deny(address(dss.end));\n\n        CutteeLike(se.clipper.cuttee()).rely(address(se.clipper));\n\n        se.clipperMom.setPriceTolerance(address(se.clipper), se.clipperMom.tolerance(address(se.oldClipper)));\n\n        IlkRegistryLike(dss.chainlog.getAddress(\"ILK_REGISTRY\")).file(ilk, \"xlip\", address(se.clipper));\n\n        dss.chainlog.setAddress(\"LOCKSTAKE_CLIP\", address(se.clipper));\n    }\n\n    function enableLiquidations(DssInstance memory dss) internal {\n        LockstakeClipperLike clipper = LockstakeClipperLike(dss.chainlog.getAddress(\"LOCKSTAKE_CLIP\"));\n        clipper.rely(dss.chainlog.getAddress(\"CLIPPER_MOM\"));\n        clipper.file(\"stopped\", 0);\n    }\n}\n"
    }
}