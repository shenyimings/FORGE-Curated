{
    "vfp_id": "vfp_00338",
    "project_name": "cantina_charm_june2025.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Fee rounding consistency in getPositionAmounts",
            "description": "1. **Description:** The function getPositionAmounts in AlphaProVault.sol uses a rounding method that differs from the one used in _burnAndCollect, leading to inconsistencies in fee calculations.\n2. **Cause:** The rounding logic for computing pending fees is not standardized across functions, relying on different formulas.\n3. **Exploitation:** While not directly exploitable for large gains, this inconsistency could lead to minor miscalculations in user shares or fee distributions during deposit and withdrawal operations.\n4. **Impact:** Users may receive slightly inaccurate amounts of tokens or shares, undermining fairness and precision in the protocol's financial calculations.\n",
            "severity": "Low",
            "location": [
                "AlphaProVault.sol#L589-L590"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Protocol fee could be fetched from factory after rebalance",
            "description": "1. **Description:** The AlphaProVault contract maintains its own protocol fee setting, while the factory also has a setter for future vaults. This creates redundancy and potential inconsistency.\n2. **Cause:** The vault does not fetch the protocol fee from the factory at critical points such as after a rebalance.\n3. **Exploitation:** A discrepancy between the factory's intended fee and the vault's stored fee could be exploited if not synchronized, especially after governance updates.\n4. **Impact:** This could lead to incorrect fee collection, either under-collecting or over-collecting fees, affecting revenue distribution and user trust.\n",
            "severity": "Low",
            "location": [
                "AlphaProVault.sol#L688-L693"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Manager can allow himself to rebalance unrestricted",
            "description": "1. **Description:** The checkCanRebalance function includes rate-limiting logic, but the manager can potentially bypass these restrictions.\n2. **Cause:** The access control mechanism does not sufficiently restrict the manager from manipulating rebalance conditions.\n3. **Exploitation:** A malicious or compromised manager could trigger rebalances more frequently than allowed, potentially to exploit price movements or execute sandwich attacks.\n4. **Impact:** This could lead to unfair advantages for the manager, increased gas costs for users, or manipulation of the vault’s position for personal gain.\n",
            "severity": "Low",
            "location": [
                "AlphaProVault.sol#L740-L743"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Vault can be drained if baseThreshold is equal to wideThreshold",
            "description": "1. **Description:** If baseThreshold equals wideThreshold, the assumption that wide and base positions are independent breaks down, leading to incorrect liquidity calculations.\n2. **Cause:** The code does not prevent or handle the case where baseThreshold == wideThreshold, which disrupts the expected behavior of deposit, rebalance, and withdraw functions.\n3. **Exploitation:** An attacker could set these thresholds to be equal, causing an imbalance in liquidity withdrawal—e.g., withdrawing 75% of liquidity when only 50% is intended.\n4. **Impact:** This could allow an attacker to drain the vault by withdrawing more liquidity than their share entitles them to, resulting in significant loss of funds.\n",
            "severity": "Low",
            "location": [
                "AlphaProVault.sol#L312-L314",
                "AlphaProVault.sol#L231-L239",
                "AlphaProVault.sol#L361-L371"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding error during direct deposit may Dos deposits",
            "description": "1. **Description:** During direct deposit, rounding up of amounts in _calcAmountsAndShares can cause the pulled amounts to exceed the desired amounts by a few wei.\n2. **Cause:** The amounts are rounded up three times in sequence, leading to a final value that slightly exceeds amount0Desired or amount1Desired.\n3. **Exploitation:** This could cause the deposit transaction to revert if the user does not have sufficient balance to cover the overage, effectively blocking deposits.\n4. **Impact:** Users may be unable to deposit funds due to minor rounding errors, leading to a denial-of-service condition for deposit functionality.\n",
            "severity": "Low",
            "location": [
                "AlphaProVault.sol#L228-L239"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "ERC777 tokens will enable caller to self sandwich mint to extract part of deposit",
            "description": "1. **Description:** If one of the tokens in the pool is an ERC777 token, the _callTokensToSend hook can be exploited by the caller to manipulate the Uniswap V3 pool price before minting liquidity.\n2. **Cause:** The integration does not account for the callback behavior of ERC777, which allows the sender to execute code during token transfer.\n3. **Exploitation:** A user depositing an ERC777 token can trigger a price manipulation via the hook, then mint liquidity at the manipulated price, extracting value from other LPs.\n4. **Impact:** This could lead to value extraction from the vault, harming other liquidity providers and undermining the fairness of the system.\n",
            "severity": "Low",
            "location": [
                "AlphaProVault.sol#L227-L229"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Storage variables can be immutable",
            "description": "1. **Description:** Several variables in AlphaProVault are set during initialization and never changed, yet they are stored in mutable storage.\n2. **Cause:** These variables are not declared as immutable, leading to higher gas costs on every read.\n3. **Exploitation:** Not directly exploitable, but represents inefficient code design.\n4. **Impact:** Increased gas consumption for all users interacting with the contract, leading to higher transaction costs.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L99-L102"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Storage variables can be packed",
            "description": "1. **Description:** Multiple storage variables in AlphaProVault are declared separately but can be packed into fewer slots.\n2. **Cause:** Variables like accruedProtocolFees0/1 and accruedManagerFees0/1 are not packed, wasting storage space.\n3. **Exploitation:** Not exploitable, but inefficient.\n4. **Impact:** Higher gas costs for storage operations; packing could save SSTORE and SLOAD costs.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L112-L116"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-193"
                ]
            },
            "title": "Tick boundary check is off by one in checkCanRebalance",
            "description": "1. **Description:** The checkCanRebalance function incorrectly rejects valid tick boundaries by using a strict inequality.\n2. **Cause:** The function reverts when newBaseLower == -maxTick or newBaseUpper == maxTick, even though these are valid bounds.\n3. **Exploitation:** Users or the manager cannot set the base range to the maximum allowable ticks, unnecessarily restricting functionality.\n4. **Impact:** Reduced flexibility in position management, potentially limiting optimal rebalancing strategies.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L459-L460"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Fee share may not be distributed to user in edge-case",
            "description": "1. **Description:** During withdrawal, fees are only collected if liquidity > 0, but in edge cases, fees may be due even when liquidity is zero.\n2. **Cause:** The condition `liquidity > 0` prevents fee collection when liquidity is zero, even if accrued fees exist.\n3. **Exploitation:** Not exploitable by attackers, but may lead to incorrect distribution.\n4. **Impact:** Users may not receive their full entitled fees in rare edge cases, leading to loss of expected rewards.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L337-L344"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Minor changes and renaming suggestions",
            "description": "1. **Description:** Several variable and function names are unclear or ambiguous and could be improved for readability.\n2. **Cause:** Names like `period` and `maxTwapDeviation` do not clearly indicate their purpose or units.\n3. **Exploitation:** Not exploitable.\n4. **Impact:** Reduced code clarity and maintainability; better naming would improve developer understanding.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Emergency burn action should have cooldown",
            "description": "1. **Description:** The emergencyBurn function can be misused by a malicious manager to disrupt normal operations.\n2. **Cause:** There is no cooldown or state restriction after emergencyBurn is called.\n3. **Exploitation:** A manager could repeatedly trigger emergency actions to block deposits or rebalances.\n4. **Impact:** Potential for denial-of-service or manipulation during rebalancing due to lack of safeguards.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L777-L780"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "_verifyTick is a misnomer",
            "description": "1. **Description:** The function _verifyTick does not verify a tick but instead clamps it to a valid range.\n2. **Cause:** The function name suggests validation, but it actually modifies the input.\n3. **Exploitation:** Not exploitable.\n4. **Impact:** Misleading function name could confuse developers, leading to incorrect assumptions about its behavior.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L483-L492"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1078"
                ]
            },
            "title": "Shadowed function name",
            "description": "1. **Description:** The variable name `totalSupply` is used as a local variable or parameter in multiple functions, shadowing the state variable.\n2. **Cause:** Use of `totalSupply` as a parameter shadows the contract's state variable of the same name.\n3. **Exploitation:** Could lead to confusion or bugs if developers误assume they are referencing the state variable.\n4. **Impact:** Reduced code clarity and potential for subtle bugs due to variable shadowing.\n",
            "severity": "Informational",
            "location": [
                "AlphaProVault.sol#L255",
                "AlphaProVault.sol#L302",
                "AlphaProVault.sol#L330"
            ],
            "files": [
                "alpha-contracts-v2.1/contracts/AlphaProVault.sol"
            ]
        }
    ],
    "affected_files": {
        "AlphaProVault.sol": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IUniswapV3MintCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3SwapCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {PositionKey} from \"@uniswap/v3-periphery/contracts/libraries/PositionKey.sol\";\nimport {TickMath} from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {LiquidityAmounts} from \"./library/LiquidityAmounts.sol\";\n\nimport \"./AlphaProVaultFactory.sol\";\nimport \"../interfaces/IVault.sol\";\n\n/**\n * @param pool Underlying Uniswap V3 pool address\n * @param manager Address of manager who can set parameters and call rebalance\n * @param rebalanceDelegate Address of an additional wallet that can call rebalance\n * @param managerFee % Fee charge by the vault manager multiplied by 1e4\n * @param maxTotalSupply Cap on the total supply of vault shares\n * @param wideRangeWeight Proportion of liquidity in wide range multiplied by 1e6\n * @param wideThreshold Wide range threshold in ticks\n * @param baseThreshold Half of the base order width in ticks\n * @param limitThreshold Limit order width in ticks\n * @param period Can only rebalance if this length of time (in seconds) has passed\n * @param minTickMove Can only rebalance if price has moved at least this much\n * @param maxTwapDeviation Max deviation (in ticks) from the TWAP during rebalance\n * @param twapDuration TWAP duration in seconds for maxTwapDeviation check\n * @param name name of the vault to be created\n * @param symbol symbol of the vault to be created\n * @param factory Address of AlphaProFactory contract\n */\nstruct VaultParams {\n    address pool;\n    address manager;\n    uint24 managerFee;\n    uint256 maxTotalSupply;\n    uint24 wideRangeWeight;\n    int24 wideThreshold;\n    int24 baseThreshold;\n    int24 limitThreshold;\n    uint32 period;\n    int24 minTickMove;\n    int24 maxTwapDeviation;\n    uint32 twapDuration;\n    string name;\n    string symbol;\n}\n\n/**\n * @title   Alpha Pro Vault\n * @notice  A vault that provides liquidity on Uniswap V3.\n */\ncontract AlphaProVault is\n    IVault,\n    IUniswapV3MintCallback,\n    IUniswapV3SwapCallback,\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1);\n    event Withdraw(address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1);\n    event CollectFees(\n        uint256 feesToVault0,\n        uint256 feesToVault1,\n        uint256 feesToProtocol0,\n        uint256 feesToProtocol1,\n        uint256 feesToManager0,\n        uint256 feesToManager1\n    );\n    event Snapshot(int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 totalSupply);\n    event CollectProtocol(uint256 amount0, uint256 amount1);\n    event CollectManager(uint256 amount0, uint256 amount1);\n\n    event UpdateManager(address manager);\n    event UpdatePendingManager(address manager);\n    event UpdateRebalanceDelegate(address delegate);\n    event UpdateDepositDelegate(address delegate);\n    event UpdateManagerFee(uint24 managerFee);\n    event UpdateProtocolFee(uint24 protocolFee);\n    event UpdateBaseThreshold(int24 threshold);\n    event UpdateLimitThreshold(int24 threshold);\n    event UpdateWideRangeWeight(uint24 weight);\n    event UpdateWideThreshold(int24 threshold);\n    event UpdatePeriod(uint32 period);\n    event UpdateMinTickMove(int24 minTickMove);\n    event UpdateMaxTwapDeviation(int24 maxTwapDeviation);\n    event UpdateTwapDuration(uint32 twapDuration);\n    event UpdateMaxTotalSupply(uint256 maxTotalSupply);\n\n    IUniswapV3Pool public override pool;\n    IERC20 public token0;\n    IERC20 public token1;\n    AlphaProVaultFactory public factory;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 1e3;\n    uint24 public constant HUNDRED_PERCENT = 1e6;\n\n    address public override manager;\n    address public override pendingManager;\n    address public override rebalanceDelegate;\n    address public override depositDelegate;\n    uint256 public override maxTotalSupply;\n    uint128 public override accruedProtocolFees0;\n    uint128 public override accruedProtocolFees1;\n    uint104 public override accruedManagerFees0;\n    uint104 public override accruedManagerFees1;\n    uint40 public override lastTimestamp;\n\n    uint32 public override period;\n    uint24 public override protocolFee;\n    uint24 public override managerFee;\n    uint24 public override pendingManagerFee;\n    uint24 public override pendingProtocolFee;\n    uint24 public override wideRangeWeight;\n    int24 public override baseThreshold;\n    int24 public override limitThreshold;\n    int24 public override wideThreshold;\n    int24 public override minTickMove;\n    int24 public override tickSpacing;\n    int24 public override maxTwapDeviation;\n    uint32 public override twapDuration;\n    int24 public override wideLower;\n    int24 public override wideUpper;\n    int24 public override baseLower;\n    int24 public override baseUpper;\n    int24 public override limitLower;\n    int24 public override limitUpper;\n    int24 public override lastTick;\n    int24 public maxTick;\n\n    function initialize(VaultParams memory _params, address _factory) public initializer {\n        __ERC20_init(_params.name, _params.symbol);\n        __ReentrancyGuard_init();\n\n        pool = IUniswapV3Pool(_params.pool);\n        token0 = IERC20(pool.token0());\n        token1 = IERC20(pool.token1());\n\n        int24 _tickSpacing = tickSpacing = pool.tickSpacing();\n        maxTick = TickMath.MAX_TICK / _tickSpacing * _tickSpacing;\n\n        manager = _params.manager;\n        rebalanceDelegate = _params.manager;\n        depositDelegate = _params.manager;\n        pendingManagerFee = _params.managerFee;\n        maxTotalSupply = _params.maxTotalSupply;\n        baseThreshold = _params.baseThreshold;\n        limitThreshold = _params.limitThreshold;\n        wideRangeWeight = _params.wideRangeWeight;\n        wideThreshold = _params.wideThreshold;\n        period = _params.period;\n        minTickMove = _params.minTickMove;\n        maxTwapDeviation = _params.maxTwapDeviation;\n        twapDuration = _params.twapDuration;\n\n        factory = AlphaProVaultFactory(_factory);\n        protocolFee = factory.protocolFee();\n\n        _checkThreshold(_params.baseThreshold, _tickSpacing);\n        _checkThreshold(_params.limitThreshold, _tickSpacing);\n        _checkThreshold(_params.wideThreshold, _tickSpacing);\n        require(_params.wideRangeWeight <= 1e6, \"wideRangeWeight must be <= 1e6\");\n        require(_params.minTickMove >= 0, \"minTickMove must be >= 0\");\n        require(_params.maxTwapDeviation >= 0, \"maxTwapDeviation must be >= 0\");\n        require(_params.twapDuration > 0, \"twapDuration must be > 0\");\n        require(_params.managerFee <= HUNDRED_PERCENT, \"managerFee must be <= 1000000\");\n        require(_params.wideThreshold != _params.baseThreshold, \"wideThreshold must be != baseThreshold\");\n    }\n\n    /**\n     * @notice Deposits tokens in proportion to the vault's current holdings.\n     * @dev These tokens sit in the vault and are not used for liquidity on\n     * Uniswap until the next rebalance. Also note it's not necessary to check\n     * if user manipulated price to deposit cheaper, as the value of range\n     * orders can only by manipulated higher.\n     * @param amount0Desired Max amount of token0 to deposit\n     * @param amount1Desired Max amount of token1 to deposit\n     * @param amount0Min Revert if resulting `amount0` is less than this\n     * @param amount1Min Revert if resulting `amount1` is less than this\n     * @param to Recipient of shares\n     * @return shares Number of shares minted\n     * @return amount0 Amount of token0 deposited\n     * @return amount1 Amount of token1 deposited\n     */\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (depositDelegate != address(0)) {\n            require(msg.sender == depositDelegate, \"depositDelegate\");\n        }\n        require(amount0Desired > 0 || amount1Desired > 0, \"amount0Desired or amount1Desired\");\n        require(to != address(0) && to != address(this), \"to\");\n        checkPriceNearTwap();\n\n        // Poke positions so vault's current holdings are up-to-date\n        int24[2][3] memory positions = [[wideLower, wideUpper], [baseLower, baseUpper], [limitLower, limitUpper]];\n        uint128[3] memory liquidities;\n        for (uint256 i = 0; i < 3; i++) {\n            (liquidities[i],,,,) = _position(positions[i][0], positions[i][1]);\n            if (liquidities[i] > 0) {\n                pool.burn(positions[i][0], positions[i][1], 0);\n            }\n        }\n\n        // Calculate amounts proportional to vault's holdings\n        (shares, amount0, amount1) = _calcSharesAndAmounts(amount0Desired, amount1Desired);\n        require(shares > 0, \"shares\");\n        require(amount0 >= amount0Min, \"amount0Min\");\n        require(amount1 >= amount1Min, \"amount1Min\");\n\n        // Permanently lock the first MINIMUM_LIQUIDITY tokens\n        if (totalSupply() == 0) {\n            _mint(address(factory), MINIMUM_LIQUIDITY);\n        }\n\n        // Pull in tokens from sender\n        if (amount0 > 0) token0.safeTransferFrom(msg.sender, address(this), amount0);\n        if (amount1 > 0) token1.safeTransferFrom(msg.sender, address(this), amount1);\n\n        uint256 _totalSupply = totalSupply();\n        (uint160 sqrtRatioX96,,,,,,) = pool.slot0();\n        (uint256 depositAmount0, uint256 depositAmount1) = (amount0, amount1);\n\n        for (uint256 i = 0; i < 3; i++) {\n            int24 tickLower = positions[i][0];\n            int24 tickUpper = positions[i][1];\n\n            if (liquidities[i] > 0) {\n                uint128 liquidityToMint = uint128(Math.mulDiv(liquidities[i], shares, _totalSupply));\n                uint128 liquidityFromAmounts =\n                    _liquidityForAmounts(tickLower, tickUpper, depositAmount0, depositAmount1, sqrtRatioX96);\n                liquidityToMint = liquidityToMint > liquidityFromAmounts ? liquidityFromAmounts : liquidityToMint;\n                (uint256 mintAmount0, uint256 mintAmount1) = _mintLiquidity(tickLower, tickUpper, liquidityToMint);\n                depositAmount0 -= mintAmount0;\n                depositAmount1 -= mintAmount1;\n            }\n        }\n\n        // Mint shares to recipient\n        _mint(to, shares);\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n        require(totalSupply() <= maxTotalSupply, \"maxTotalSupply\");\n    }\n\n    /// @dev Calculates the largest possible `amount0` and `amount1` such that\n    /// they're in the same proportion as total amounts, but not greater than\n    /// `amount0Desired` and `amount1Desired` respectively.\n    function _calcSharesAndAmounts(uint256 amount0Desired, uint256 amount1Desired)\n        internal\n        view\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _totalSupply = totalSupply();\n        (uint256 total0, uint256 total1) = getTotalAmounts(true);\n\n        // If total supply > 0, vault can't be empty\n        assert(_totalSupply == 0 || total0 > 0 || total1 > 0);\n\n        if (_totalSupply == 0) {\n            // For first deposit, just use the amounts desired\n            amount0 = amount0Desired;\n            amount1 = amount1Desired;\n            shares = (amount0 > amount1 ? amount0 : amount1) - MINIMUM_LIQUIDITY;\n        } else if (total0 == 0) {\n            amount1 = amount1Desired;\n            shares = amount1 * _totalSupply / total1;\n        } else if (total1 == 0) {\n            amount0 = amount0Desired;\n            shares = amount0 * _totalSupply / total0;\n        } else {\n            uint256 cross0 = amount0Desired * total1;\n            uint256 cross1 = amount1Desired * total0;\n            uint256 cross = cross0 > cross1 ? cross1 : cross0;\n            require(cross > 0, \"cross\");\n\n            // Round up amounts\n            amount0 = (cross - 1) / total1 + 1;\n            amount1 = (cross - 1) / total0 + 1;\n            shares = cross * _totalSupply / total0 / total1;\n        }\n    }\n\n    /**\n     * @notice Withdraws tokens in proportion to the vault's holdings.\n     * @param shares Shares burned by sender\n     * @param amount0Min Revert if resulting `amount0` is smaller than this\n     * @param amount1Min Revert if resulting `amount1` is smaller than this\n     * @param to Recipient of tokens\n     * @return amount0 Amount of token0 sent to recipient\n     * @return amount1 Amount of token1 sent to recipient\n     */\n    function withdraw(uint256 shares, uint256 amount0Min, uint256 amount1Min, address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(shares > 0, \"shares\");\n        require(to != address(0) && to != address(this), \"to\");\n        uint256 _totalSupply = totalSupply();\n\n        // Burn shares\n        _burn(msg.sender, shares);\n\n        // Calculate token amounts proportional to unused balances\n        amount0 = (getBalance0() * shares) / _totalSupply;\n        amount1 = (getBalance1() * shares) / _totalSupply;\n\n        // Withdraw proportion of liquidity from Uniswap pool\n        (uint256 wideAmount0, uint256 wideAmount1) = _burnLiquidityShare(wideLower, wideUpper, shares, _totalSupply);\n        (uint256 baseAmount0, uint256 baseAmount1) = _burnLiquidityShare(baseLower, baseUpper, shares, _totalSupply);\n        (uint256 limitAmount0, uint256 limitAmount1) = _burnLiquidityShare(limitLower, limitUpper, shares, _totalSupply);\n\n        // Sum up total amounts owed to recipient\n        amount0 = amount0 + wideAmount0 + baseAmount0 + limitAmount0;\n        amount1 = amount1 + wideAmount1 + baseAmount1 + limitAmount1;\n        require(amount0 >= amount0Min, \"amount0Min\");\n        require(amount1 >= amount1Min, \"amount1Min\");\n\n        // Push tokens to recipient\n        if (amount0 > 0) token0.safeTransfer(to, amount0);\n        if (amount1 > 0) token1.safeTransfer(to, amount1);\n\n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n\n    /// @dev Withdraws share of liquidity in a range from Uniswap pool.\n    function _burnLiquidityShare(int24 tickLower, int24 tickUpper, uint256 shares, uint256 totalSupply)\n        internal\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint128 totalLiquidity,,,,) = _position(tickLower, tickUpper);\n        uint128 liquidity = uint128(Math.mulDiv(totalLiquidity, shares, totalSupply));\n\n        if (liquidity > 0) {\n            (uint256 burned0, uint256 burned1, uint128 fees0, uint128 fees1) =\n                _burnAndCollect(tickLower, tickUpper, liquidity);\n\n            // Add share of fees\n            amount0 = burned0 + ((fees0 * shares) / totalSupply);\n            amount1 = burned1 + ((fees1 * shares) / totalSupply);\n        }\n    }\n\n    /**\n     * @notice Updates vault's positions.\n     * @dev Three orders are placed - a full-range order, a base order and a\n     * limit order. The full-range order is placed first. Then the base\n     * order is placed with as much remaining liquidity as possible. This order\n     * should use up all of one token, leaving only the other one. This excess\n     * amount is then placed as a single-sided bid or ask order.\n     */\n    function rebalance() external override nonReentrant {\n        checkCanRebalance();\n        if (rebalanceDelegate != address(0)) {\n            require(msg.sender == manager || msg.sender == rebalanceDelegate, \"rebalanceDelegate\");\n        }\n\n        // Withdraw all current liquidity from Uniswap pool\n        {\n            int24 _wideLower = wideLower;\n            int24 _wideUpper = wideUpper;\n            (uint128 wideLiquidity,,,,) = _position(_wideLower, _wideUpper);\n            (uint128 baseLiquidity,,,,) = _position(baseLower, baseUpper);\n            (uint128 limitLiquidity,,,,) = _position(limitLower, limitUpper);\n            _burnAndCollect(_wideLower, _wideUpper, wideLiquidity);\n            _burnAndCollect(baseLower, baseUpper, baseLiquidity);\n            _burnAndCollect(limitLower, limitUpper, limitLiquidity);\n        }\n\n        // Calculate new ranges\n        (uint160 sqrtRatioX96, int24 tick,,,,,) = pool.slot0();\n        int24 _bidLower;\n        int24 _bidUpper;\n        int24 _askLower;\n        int24 _askUpper;\n        {\n            int24 tickFloor = _floor(tick);\n            int24 tickCeil = tickFloor + tickSpacing;\n            int24 _maxTick = maxTick;\n            wideLower = _boundTick(tickFloor - wideThreshold, _maxTick);\n            wideUpper = _boundTick(tickCeil + wideThreshold, _maxTick);\n            baseLower = tickFloor - baseThreshold;\n            baseUpper = tickCeil + baseThreshold;\n            _bidLower = tickFloor - limitThreshold;\n            _bidUpper = tickFloor;\n            _askLower = tickCeil;\n            _askUpper = tickCeil + limitThreshold;\n        }\n\n        // Emit snapshot to record balances and supply\n        uint256 balance0 = getBalance0();\n        uint256 balance1 = getBalance1();\n        emit Snapshot(tick, balance0, balance1, totalSupply());\n\n        // Place wide range order on Uniswap\n        if (wideRangeWeight > 0) {\n            uint128 wideLiquidity = _liquidityForAmounts(wideLower, wideUpper, balance0, balance1, sqrtRatioX96);\n            wideLiquidity = _toUint128((uint256(wideLiquidity) * wideRangeWeight) / 1e6);\n            (uint256 mintAmount0, uint256 mintAmount1) = _mintLiquidity(wideLower, wideUpper, wideLiquidity);\n            balance0 -= mintAmount0;\n            balance1 -= mintAmount1;\n        }\n\n        // Place base order on Uniswap\n        {\n            uint128 baseLiquidity = _liquidityForAmounts(baseLower, baseUpper, balance0, balance1, sqrtRatioX96);\n            (uint256 mintAmount0, uint256 mintAmount1) = _mintLiquidity(baseLower, baseUpper, baseLiquidity);\n            balance0 -= mintAmount0;\n            balance1 -= mintAmount1;\n        }\n\n        //  Place bid or ask order on Uniswap depending on which token is left\n        {\n            uint128 bidLiquidity = _liquidityForAmounts(_bidLower, _bidUpper, balance0, balance1, sqrtRatioX96);\n            uint128 askLiquidity = _liquidityForAmounts(_askLower, _askUpper, balance0, balance1, sqrtRatioX96);\n            if (bidLiquidity > askLiquidity) {\n                _mintLiquidity(_bidLower, _bidUpper, bidLiquidity);\n                limitLower = _bidLower;\n                limitUpper = _bidUpper;\n            } else {\n                _mintLiquidity(_askLower, _askUpper, askLiquidity);\n                limitLower = _askLower;\n                limitUpper = _askUpper;\n            }\n        }\n\n        lastTimestamp = uint40(block.timestamp);\n        lastTick = tick;\n\n        // Update fee only at each rebalance, so that if fee is increased\n        // it won't be applied retroactively to current open positions\n        uint24 _protocolFee = protocolFee = pendingProtocolFee > 0 ? pendingProtocolFee : factory.protocolFee();\n        // Manager + protocol fee must be <= 100%\n        if (pendingManagerFee + _protocolFee <= HUNDRED_PERCENT) {\n            managerFee = pendingManagerFee;\n        } else {\n            managerFee = HUNDRED_PERCENT - _protocolFee;\n        }\n    }\n\n    function checkCanRebalance() public view override {\n        checkPriceNearTwap();\n        uint256 _lastTimestamp = lastTimestamp;\n\n        // check enough time has passed\n        require(block.timestamp >= (_lastTimestamp + period), \"PE\");\n\n        // check price has moved enough\n        (, int24 tick,,,,,) = pool.slot0();\n        int24 tickMove = tick > lastTick ? tick - lastTick : lastTick - tick;\n        require(_lastTimestamp == 0 || tickMove >= minTickMove, \"TM\");\n\n        // check price not too close to boundary\n        int24 maxThreshold = baseThreshold > limitThreshold ? baseThreshold : limitThreshold;\n        require(\n            tick >= TickMath.MIN_TICK + maxThreshold + tickSpacing\n                && tick <= TickMath.MAX_TICK - maxThreshold - tickSpacing,\n            \"PB\"\n        );\n    }\n\n    function checkPriceNearTwap() public view {\n        (, int24 tick,,,,,) = pool.slot0();\n        int24 twap = getTwap();\n        int24 twapDeviation = tick > twap ? tick - twap : twap - tick;\n        require(twapDeviation <= maxTwapDeviation, \"TP\");\n    }\n\n    /// @dev Fetches time-weighted average price in ticks from Uniswap pool.\n    function getTwap() public view returns (int24) {\n        uint32 _twapDuration = twapDuration;\n        uint32[] memory secondsAgo = new uint32[](2);\n        secondsAgo[0] = _twapDuration;\n        secondsAgo[1] = 0;\n\n        (int56[] memory tickCumulatives,) = pool.observe(secondsAgo);\n        return int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56((_twapDuration))));\n    }\n\n    /// @dev Verifies that tick is within the range boundaries\n    function _boundTick(int24 tick, int24 _maxTick) internal pure returns (int24) {\n        if (tick < -_maxTick) {\n            return -_maxTick;\n        }\n        if (tick > _maxTick) {\n            return _maxTick;\n        }\n        return tick;\n    }\n\n    /// @dev Rounds tick down towards negative infinity so that it's a multiple\n    /// of `tickSpacing`.\n    function _floor(int24 tick) internal view returns (int24) {\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--;\n        return compressed * tickSpacing;\n    }\n\n    function _checkThreshold(int24 threshold, int24 _tickSpacing) internal pure {\n        require(threshold > 0, \"threshold must be > 0\");\n        require(threshold % _tickSpacing == 0, \"threshold must be multiple of tickSpacing\");\n    }\n\n    /// @dev Withdraws liquidity from a range and collects all fees in the\n    /// process.\n    function _burnAndCollect(int24 tickLower, int24 tickUpper, uint128 liquidity)\n        internal\n        returns (uint256 burned0, uint256 burned1, uint128 feesToVault0, uint128 feesToVault1)\n    {\n        if (liquidity > 0) {\n            (burned0, burned1) = pool.burn(tickLower, tickUpper, liquidity);\n        }\n\n        // Collect all owed tokens including earned fees\n        (uint128 collect0, uint128 collect1) =\n            pool.collect(address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max);\n\n        feesToVault0 = uint128(collect0 - burned0);\n        feesToVault1 = uint128(collect1 - burned1);\n\n        // Update accrued protocol fees\n        uint24 _protocolFee = protocolFee;\n        uint128 feesToProtocol0 = feesToVault0 * _protocolFee / 1e6;\n        uint128 feesToProtocol1 = feesToVault1 * _protocolFee / 1e6;\n        accruedProtocolFees0 += feesToProtocol0;\n        accruedProtocolFees1 += feesToProtocol1;\n\n        // Update accrued manager fees\n        uint24 _managerFee = managerFee;\n        uint128 feesToManager0;\n        uint128 feesToManager1;\n        if (_managerFee > 0) {\n            feesToManager0 = feesToVault0 * _managerFee / 1e6;\n            feesToManager1 = feesToVault1 * _managerFee / 1e6;\n            accruedManagerFees0 += uint104(feesToManager0);\n            accruedManagerFees1 += uint104(feesToManager1);\n        }\n        feesToVault0 -= feesToProtocol0 + feesToManager0;\n        feesToVault1 -= feesToProtocol1 + feesToManager1;\n        emit CollectFees(feesToVault0, feesToVault1, feesToProtocol0, feesToProtocol1, feesToManager0, feesToManager1);\n    }\n\n    /// @dev Deposits liquidity in a range on the Uniswap pool.\n    function _mintLiquidity(int24 tickLower, int24 tickUpper, uint128 liquidity)\n        internal\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (liquidity > 0) {\n            (amount0, amount1) = pool.mint(address(this), tickLower, tickUpper, liquidity, \"\");\n        }\n    }\n\n    /**\n     * @notice Calculates the vault's total holdings of token0 and token1 - in\n     * other words, how much of each token the vault would hold if it withdrew\n     * all its liquidity from Uniswap.\n     */\n    function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {\n        (total0, total1) = getTotalAmounts(false);\n    }\n\n    function getTotalAmounts(bool roundUp) public view override returns (uint256 total0, uint256 total1) {\n        (uint256 wideAmount0, uint256 wideAmount1) = getPositionAmounts(wideLower, wideUpper, roundUp);\n        (uint256 baseAmount0, uint256 baseAmount1) = getPositionAmounts(baseLower, baseUpper, roundUp);\n        (uint256 limitAmount0, uint256 limitAmount1) = getPositionAmounts(limitLower, limitUpper, roundUp);\n        total0 = getBalance0() + wideAmount0 + baseAmount0 + limitAmount0;\n        total1 = getBalance1() + wideAmount1 + baseAmount1 + limitAmount1;\n    }\n\n    /**\n     * @notice Amounts of token0 and token1 held in vault's position. Includes\n     * owed fees but excludes the proportion of fees that will be paid to the\n     * protocol. Doesn't include fees accrued since last poke.\n     */\n    function getPositionAmounts(int24 tickLower, int24 tickUpper, bool roundUp)\n        public\n        view\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = _position(tickLower, tickUpper);\n        (amount0, amount1) = _amountsForLiquidity(tickLower, tickUpper, liquidity, roundUp);\n\n        // Subtract protocol and manager fees\n        uint128 managerFees0;\n        uint128 managerFees1;\n        uint24 _managerFee = managerFee;\n        if (_managerFee > 0) {\n            managerFees0 = tokensOwed0 * _managerFee / 1e6;\n            managerFees1 = tokensOwed1 * _managerFee / 1e6;\n        }\n        uint24 _protocolFee = protocolFee;\n        uint128 protocolFees0 = tokensOwed0 * _protocolFee / 1e6;\n        uint128 protocolFees1 = tokensOwed1 * _protocolFee / 1e6;\n\n        amount0 += tokensOwed0 - protocolFees0 - managerFees0;\n        amount1 += tokensOwed1 - protocolFees1 - managerFees1;\n    }\n\n    /**\n     * @notice Balance of token0 in vault not used in any position.\n     */\n    function getBalance0() public view override returns (uint256) {\n        return token0.balanceOf(address(this)) - accruedProtocolFees0 - accruedManagerFees0;\n    }\n\n    /**\n     * @notice Balance of token1 in vault not used in any position.\n     */\n    function getBalance1() public view override returns (uint256) {\n        return token1.balanceOf(address(this)) - accruedProtocolFees1 - accruedManagerFees1;\n    }\n\n    /// @dev Wrapper around `IUniswapV3Pool.positions()`.\n    function _position(int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint128, uint256, uint256, uint128, uint128)\n    {\n        bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);\n        return pool.positions(positionKey);\n    }\n\n    /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.\n    function _amountsForLiquidity(int24 tickLower, int24 tickUpper, uint128 liquidity, bool roundUp)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        (uint160 sqrtRatioX96,,,,,,) = pool.slot0();\n        return LiquidityAmounts.getAmountsForLiquidity(\n            sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            liquidity,\n            roundUp\n        );\n    }\n\n    /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.\n    function _liquidityForAmounts(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1,\n        uint160 sqrtRatioX96\n    ) internal pure returns (uint128) {\n        return LiquidityAmounts.getLiquidityForAmounts(\n            sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            amount0,\n            amount1\n        );\n    }\n\n    /// @dev Casts uint256 to uint128 with overflow check.\n    function _toUint128(uint256 x) internal pure returns (uint128) {\n        assert(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    /// @dev Callback for Uniswap V3 pool.\n    function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes calldata data) external override {\n        require(msg.sender == address(pool));\n        if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);\n        if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);\n    }\n\n    /// @dev Callback for Uniswap V3 pool.\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {\n        require(msg.sender == address(pool));\n        if (amount0Delta > 0) token0.safeTransfer(msg.sender, uint256(amount0Delta));\n        if (amount1Delta > 0) token1.safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Used to collect accumulated protocol fees.\n     */\n    function collectProtocol(address to) external {\n        require(msg.sender == factory.governance(), \"governance\");\n        uint256 _accruedProtocolFees0 = accruedProtocolFees0;\n        uint256 _accruedProtocolFees1 = accruedProtocolFees1;\n        accruedProtocolFees0 = 0;\n        accruedProtocolFees1 = 0;\n        if (_accruedProtocolFees0 > 0) token0.safeTransfer(to, _accruedProtocolFees0);\n        if (_accruedProtocolFees1 > 0) token1.safeTransfer(to, _accruedProtocolFees1);\n        emit CollectProtocol(_accruedProtocolFees0, _accruedProtocolFees1);\n    }\n\n    /**\n     * @notice Change the protocol fee charged on pool fees earned from\n     * Uniswap, expressed as multiple of 1e-6. Fee is hard capped at 25%.\n     */\n    function setProtocolFee(uint24 _pendingProtocolFee) external {\n        require(msg.sender == factory.governance(), \"governance\");\n        require(_pendingProtocolFee <= 25e4, \"protocolFee must be <= 250000\");\n        pendingProtocolFee = _pendingProtocolFee;\n        emit UpdateProtocolFee(_pendingProtocolFee);\n    }\n\n    /*\n     * @notice Used to collect accumulated manager fees.\n     */\n    function collectManager(address to) external onlyManager {\n        uint256 _accruedManagerFees0 = accruedManagerFees0;\n        uint256 _accruedManagerFees1 = accruedManagerFees1;\n        accruedManagerFees0 = 0;\n        accruedManagerFees1 = 0;\n        if (_accruedManagerFees0 > 0) token0.safeTransfer(to, _accruedManagerFees0);\n        if (_accruedManagerFees1 > 0) token1.safeTransfer(to, _accruedManagerFees1);\n        emit CollectManager(_accruedManagerFees0, _accruedManagerFees1);\n    }\n\n    /**\n     * @notice Removes tokens accidentally sent to this vault.\n     */\n    function sweep(IERC20 token, uint256 amount, address to) external onlyManager {\n        require(token != token0 && token != token1, \"token\");\n        token.safeTransfer(to, amount);\n    }\n\n    function setBaseThreshold(int24 _baseThreshold) external onlyManager {\n        require(_baseThreshold != wideThreshold, \"baseThreshold must be != wideThreshold\");\n        _checkThreshold(_baseThreshold, tickSpacing);\n        baseThreshold = _baseThreshold;\n        emit UpdateBaseThreshold(_baseThreshold);\n    }\n\n    function setLimitThreshold(int24 _limitThreshold) external onlyManager {\n        _checkThreshold(_limitThreshold, tickSpacing);\n        limitThreshold = _limitThreshold;\n        emit UpdateLimitThreshold(_limitThreshold);\n    }\n\n    function setWideRangeWeight(uint24 _wideRangeWeight) external onlyManager {\n        require(_wideRangeWeight <= 1e6, \"wideRangeWeight must be <= 1e6\");\n        wideRangeWeight = _wideRangeWeight;\n        emit UpdateWideRangeWeight(_wideRangeWeight);\n    }\n\n    function setWideThreshold(int24 _wideThreshold) external onlyManager {\n        require(_wideThreshold != baseThreshold, \"wideThreshold must be != baseThreshold\");\n        _checkThreshold(_wideThreshold, tickSpacing);\n        wideThreshold = _wideThreshold;\n        emit UpdateWideThreshold(_wideThreshold);\n    }\n\n    function setPeriod(uint32 _period) external onlyManager {\n        period = _period;\n        emit UpdatePeriod(_period);\n    }\n\n    function setMinTickMove(int24 _minTickMove) external onlyManager {\n        require(_minTickMove >= 0, \"minTickMove must be >= 0\");\n        minTickMove = _minTickMove;\n        emit UpdateMinTickMove(_minTickMove);\n    }\n\n    function setMaxTwapDeviation(int24 _maxTwapDeviation) external onlyManager {\n        require(_maxTwapDeviation >= 0, \"maxTwapDeviation must be >= 0\");\n        maxTwapDeviation = _maxTwapDeviation;\n        emit UpdateMaxTwapDeviation(_maxTwapDeviation);\n    }\n\n    function setTwapDuration(uint32 _twapDuration) external onlyManager {\n        require(_twapDuration > 0, \"twapDuration must be > 0\");\n        twapDuration = _twapDuration;\n        emit UpdateTwapDuration(_twapDuration);\n    }\n\n    /**\n     * @notice Used to change deposit cap for a guarded launch or to ensure\n     * vault doesn't grow too large relative to the pool. Cap is on total\n     * supply rather than amounts of token0 and token1 as those amounts\n     * fluctuate naturally over time.\n     */\n    function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyManager {\n        maxTotalSupply = _maxTotalSupply;\n        emit UpdateMaxTotalSupply(_maxTotalSupply);\n    }\n\n    /**\n     * @notice Removes liquidity in case of emergency.\n     */\n    function emergencyBurn(int24 tickLower, int24 tickUpper, uint128 liquidity) external onlyManager {\n        pool.burn(tickLower, tickUpper, liquidity);\n        pool.collect(address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max);\n    }\n\n    /**\n     * @notice Manager address is not updated until the new manager\n     * address has called `acceptManager()` to accept this responsibility.\n     */\n    function setManager(address _manager) external onlyManager {\n        pendingManager = _manager;\n        emit UpdatePendingManager(_manager);\n    }\n\n    function setDepositDelegate(address _depositDelegate) external onlyManager {\n        depositDelegate = _depositDelegate;\n        emit UpdateDepositDelegate(_depositDelegate);\n    }\n\n    function setRebalanceDelegate(address _rebalanceDelegate) external onlyManager {\n        rebalanceDelegate = _rebalanceDelegate;\n        emit UpdateRebalanceDelegate(_rebalanceDelegate);\n    }\n\n    /**\n     * @notice Change the manager fee charged on pool fees earned from\n     * Uniswap, expressed as multiple of 1e-6. Fee is hard capped at 20%.\n     */\n    function setManagerFee(uint24 _pendingManagerFee) external onlyManager {\n        require(_pendingManagerFee <= HUNDRED_PERCENT, \"managerFee must be <= 100%\");\n        pendingManagerFee = _pendingManagerFee;\n        emit UpdateManagerFee(_pendingManagerFee);\n    }\n\n    /**\n     * @notice `setManager()` should be called by the existing manager\n     * address prior to calling this function.\n     */\n    function acceptManager() external {\n        if (pendingManager == address(0) && msg.sender == manager) {\n            manager = address(0);\n            emit UpdateManager(address(0));\n        } else {\n            require(msg.sender == pendingManager, \"pendingManager\");\n            manager = msg.sender;\n            emit UpdateManager(msg.sender);\n        }\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"manager\");\n        _;\n    }\n}\n"
    }
}