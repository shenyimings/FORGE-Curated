{
    "vfp_id": "vfp_00122",
    "project_name": "Pyth Lazer EVM - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Signature malleability",
            "description": "1. **Description:** The contract uses the raw ecrecover function to recover the signer from a signature, which does not enforce strict signature standards. This allows for signature malleability, where multiple valid signatures can represent the same message and signer.\n2. **Cause:** The implementation does not use OpenZeppelin's ECDSA library, which includes protections against signature malleability by enforcing the s-value to be in the lower range and v to be either 27 or 28. The current code accepts both high and low s-values and both 27 and 28 for v, enabling malleable signatures.\n3. **Exploitation:** An attacker could generate multiple valid signatures for the same message and present them to a consumer contract. If the consumer contract tracks signatures (e.g., in a batch or uniqueness check), this could lead to replay-like behavior or unexpected state changes.\n4. **Impact:** While the core contract is not directly compromised, downstream consumer contracts may experience logic errors or inefficiencies due to accepting multiple valid signatures for the same data.\n",
            "severity": "Low",
            "location": [
                "PythLazer.sol::ecrecover"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Improper initialization within the UUPS pattern",
            "description": "1. **Description:** The implementation contract for the UUPS proxy pattern includes an initialize function that is callable on the implementation contract itself. Although self-destruct attacks are mitigated post-Shanghai, the initialize function could still be frontrun if not properly protected.\n2. **Cause:** The constructor of the implementation contract does not call _disableInitializers, leaving the initialization logic potentially callable by an attacker before the proxy delegates to it. This is a known design risk in upgradeable contracts.\n3. **Exploitation:** An attacker could frontrun the legitimate initialization of the proxy by calling initialize on the implementation contract directly, potentially taking ownership if the function assigns ownership and is not properly guarded.\n4. **Impact:** The impact is limited to the implementation contract and does not directly compromise the proxy, but it represents a critical design flaw that could allow an attacker to seize control of the implementation, affecting future upgrades.\n",
            "severity": "Low",
            "location": [
                "PythLazer.sol::initialize"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Performing duplicate checks within the same range of update length",
            "description": "1. **Description:** The verifyUpdate function performs redundant length checks on the input data, specifically checking if the update length is less than 71 twice in different parts of the function.\n2. **Cause:** The first check is at the beginning of the function, and a second, logically equivalent check is performed after extracting the payload length. This duplication is unnecessary as the second check already covers the first.\n3. **Exploitation:** There is no direct exploitation path as this is not a security vulnerability, but it results in higher gas consumption for every call to verifyUpdate.\n4. **Impact:** Users pay more in gas fees than necessary, reducing the efficiency of the contract. This is a code quality and optimization issue rather than a security risk.\n",
            "severity": "Informational",
            "location": [
                "PythLazer.sol::verifyUpdate#"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Inclusion of unnecessary migrate function",
            "description": "1. **Description:** The contract contains a migrate function that sets the verification_fee to 1 wei, a value that is already the default and never changes. This function serves no practical purpose.\n2. **Cause:** The function was likely included for initialization purposes but is redundant because the state variable is already initialized to the same value. It adds no upgrade or migration functionality.\n3. **Exploitation:** No exploitation is possible, but the function increases the attack surface slightly and consumes gas during deployment due to increased bytecode size.\n4. **Impact:** The main impact is on code clarity and gas efficiency. Unnecessary functions make the code harder to audit and slightly more expensive to deploy.\n",
            "severity": "Informational",
            "location": [
                "PythLazer.sol::migrate"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        }
    ],
    "affected_files": {
        "PythLazer.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract PythLazer is OwnableUpgradeable, UUPSUpgradeable {\n    TrustedSignerInfo[100] internal trustedSigners;\n    uint256 public verification_fee;\n\n    struct TrustedSignerInfo {\n        address pubkey;\n        uint256 expiresAt;\n    }\n\n    function initialize(address _topAuthority) public initializer {\n        __Ownable_init(_topAuthority);\n        __UUPSUpgradeable_init();\n\n        verification_fee = 1 wei;\n    }\n\n    function migrate() public onlyOwner {\n        verification_fee = 1 wei;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function updateTrustedSigner(\n        address trustedSigner,\n        uint256 expiresAt\n    ) external onlyOwner {\n        if (expiresAt == 0) {\n            for (uint8 i = 0; i < trustedSigners.length; i++) {\n                if (trustedSigners[i].pubkey == trustedSigner) {\n                    trustedSigners[i].pubkey = address(0);\n                    trustedSigners[i].expiresAt = 0;\n                    return;\n                }\n            }\n            revert(\"no such pubkey\");\n        } else {\n            for (uint8 i = 0; i < trustedSigners.length; i++) {\n                if (trustedSigners[i].pubkey == trustedSigner) {\n                    trustedSigners[i].expiresAt = expiresAt;\n                    return;\n                }\n            }\n            // Signer not found - adding a new signer.\n            for (uint8 i = 0; i < trustedSigners.length; i++) {\n                if (trustedSigners[i].pubkey == address(0)) {\n                    trustedSigners[i].pubkey = trustedSigner;\n                    trustedSigners[i].expiresAt = expiresAt;\n                    return;\n                }\n            }\n            revert(\"no space for new signer\");\n        }\n    }\n\n    function isValidSigner(address signer) public view returns (bool) {\n        for (uint8 i = 0; i < trustedSigners.length; i++) {\n            if (trustedSigners[i].pubkey == signer) {\n                return block.timestamp < trustedSigners[i].expiresAt;\n            }\n        }\n        return false;\n    }\n\n    function verifyUpdate(\n        bytes calldata update\n    ) external payable returns (bytes calldata payload, address signer) {\n        // Require fee and refund excess\n        require(msg.value >= verification_fee, \"Insufficient fee provided\");\n        if (msg.value > verification_fee) {\n            payable(msg.sender).transfer(msg.value - verification_fee);\n        }\n\n        if (update.length < 71) {\n            revert(\"input too short\");\n        }\n        uint32 EVM_FORMAT_MAGIC = 706910618;\n\n        uint32 evm_magic = uint32(bytes4(update[0:4]));\n        if (evm_magic != EVM_FORMAT_MAGIC) {\n            revert(\"invalid evm magic\");\n        }\n        uint16 payload_len = uint16(bytes2(update[69:71]));\n        if (update.length < 71 + payload_len) {\n            revert(\"input too short\");\n        }\n        payload = update[71:71 + payload_len];\n        bytes32 hash = keccak256(payload);\n        signer = ecrecover(\n            hash,\n            uint8(update[68]) + 27,\n            bytes32(update[4:36]),\n            bytes32(update[36:68])\n        );\n        if (signer == address(0)) {\n            revert(\"invalid signature\");\n        }\n        if (!isValidSigner(signer)) {\n            revert(\"invalid signer\");\n        }\n    }\n\n    function version() public pure returns (string memory) {\n        return \"0.1.1\";\n    }\n}\n"
    }
}