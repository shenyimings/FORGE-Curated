{
    "vfp_id": "vfp_00122",
    "project_name": "cantina_euler_swap_april2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Checks in EulerSwap.activate() prevent deploying pools with a one-sided curve",
            "description": "The activate function performs checks that make it impossible to deploy pools with one reserve set to zero, even when valid (e.g., x0 = 0). The checks call CurveLib.verify with modified reserves, but when reserve0 is 0, both calls use the same arguments, causing one to fail. The root cause is incorrect logic in the boundary checks. This prevents valid deployment configurations, limiting the protocol's flexibility. The impact is low as it is a usability limitation rather than a security flaw, but it restricts intended functionality.\n",
            "severity": "Low",
            "location": [
                "EulerSwap.sol#L87-L89"
            ],
            "files": [
                "euler-swap/src/EulerSwap.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Incompatibility with uniswapV2Call Interface Expectations",
            "description": "EulerSwap does not implement token0() and token1() getters, which are expected by contracts using the uniswapV2Call flash swap pattern. Additionally, it is not deployed via a UniswapV2Factory, so factory-based address validation fails. The root cause is incomplete interface compatibility. This breaks integration with existing flash swap routers and arbitrage bots that expect standard Uniswap V2 behavior. The impact is informational, as it limits interoperability but does not introduce a security flaw.\n",
            "severity": "Informational",
            "location": [
                "EulerSwap.sol#L163"
            ],
            "files": [
                "euler-swap/src/EulerSwap.sol"
            ]
        }
    ],
    "affected_files": {
        "EulerSwap.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport {IUniswapV2Callee} from \"./interfaces/IUniswapV2Callee.sol\";\n\nimport {EVCUtil} from \"evc/utils/EVCUtil.sol\";\nimport {IEVC} from \"evc/interfaces/IEthereumVaultConnector.sol\";\nimport {IEVault} from \"evk/EVault/IEVault.sol\";\n\nimport {IEulerSwap} from \"./interfaces/IEulerSwap.sol\";\nimport {UniswapHook} from \"./UniswapHook.sol\";\nimport {CtxLib} from \"./libraries/CtxLib.sol\";\nimport {FundsLib} from \"./libraries/FundsLib.sol\";\nimport {CurveLib} from \"./libraries/CurveLib.sol\";\nimport {QuoteLib} from \"./libraries/QuoteLib.sol\";\n\ncontract EulerSwap is IEulerSwap, EVCUtil, UniswapHook {\n    bytes32 public constant curve = bytes32(\"EulerSwap v1\");\n\n    event EulerSwapActivated(address indexed asset0, address indexed asset1);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        uint112 reserve0,\n        uint112 reserve1,\n        address indexed to\n    );\n\n    error Locked();\n    error AlreadyActivated();\n    error BadParam();\n    error AmountTooBig();\n    error AssetsOutOfOrderOrEqual();\n\n    constructor(address evc_, address poolManager_) EVCUtil(evc_) UniswapHook(evc_, poolManager_) {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n\n        s.status = 2; // can only be used via delegatecall proxy\n    }\n\n    modifier nonReentrant() {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n\n        require(s.status == 1, Locked());\n        s.status = 2;\n        _;\n        s.status = 1;\n    }\n\n    modifier nonReentrantView() {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n        require(s.status != 2, Locked());\n\n        _;\n    }\n\n    /// @inheritdoc IEulerSwap\n    function activate(InitialState calldata initialState) public {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n        Params memory p = CtxLib.getParams();\n\n        require(s.status == 0, AlreadyActivated());\n        s.status = 1;\n\n        // Parameter validation\n\n        require(p.fee < 1e18, BadParam());\n        require(p.priceX > 0 && p.priceY > 0, BadParam());\n        require(p.priceX <= 1e36 && p.priceY <= 1e36, BadParam());\n        require(p.concentrationX <= 1e18 && p.concentrationY <= 1e18, BadParam());\n\n        {\n            address asset0Addr = IEVault(p.vault0).asset();\n            address asset1Addr = IEVault(p.vault1).asset();\n            require(asset0Addr < asset1Addr, AssetsOutOfOrderOrEqual());\n            emit EulerSwapActivated(asset0Addr, asset1Addr);\n        }\n\n        // Initial state\n\n        s.reserve0 = initialState.currReserve0;\n        s.reserve1 = initialState.currReserve1;\n\n        require(CurveLib.verify(p, s.reserve0, s.reserve1), CurveLib.CurveViolation());\n        require(!CurveLib.verify(p, s.reserve0 > 0 ? s.reserve0 - 1 : 0, s.reserve1), CurveLib.CurveViolation());\n        require(!CurveLib.verify(p, s.reserve0, s.reserve1 > 0 ? s.reserve1 - 1 : 0), CurveLib.CurveViolation());\n\n        // Configure external contracts\n\n        FundsLib.approveVault(p.vault0);\n        FundsLib.approveVault(p.vault1);\n\n        IEVC(evc).enableCollateral(p.eulerAccount, p.vault0);\n        IEVC(evc).enableCollateral(p.eulerAccount, p.vault1);\n\n        // Uniswap hooks\n\n        if (address(poolManager) != address(0)) activateHook(p);\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getParams() external pure returns (Params memory) {\n        return CtxLib.getParams();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getAssets() external view returns (address asset0, address asset1) {\n        Params memory p = CtxLib.getParams();\n\n        asset0 = IEVault(p.vault0).asset();\n        asset1 = IEVault(p.vault1).asset();\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getReserves() external view nonReentrantView returns (uint112, uint112, uint32) {\n        CtxLib.Storage storage s = CtxLib.getStorage();\n\n        return (s.reserve0, s.reserve1, s.status);\n    }\n\n    /// @inheritdoc IEulerSwap\n    function computeQuote(address tokenIn, address tokenOut, uint256 amount, bool exactIn)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        Params memory p = CtxLib.getParams();\n\n        return QuoteLib.computeQuote(address(evc), p, QuoteLib.checkTokens(p, tokenIn, tokenOut), amount, exactIn);\n    }\n\n    /// @inheritdoc IEulerSwap\n    function getLimits(address tokenIn, address tokenOut) external view nonReentrantView returns (uint256, uint256) {\n        Params memory p = CtxLib.getParams();\n\n        if (!evc.isAccountOperatorAuthorized(p.eulerAccount, address(this))) return (0, 0);\n\n        return QuoteLib.calcLimits(p, QuoteLib.checkTokens(p, tokenIn, tokenOut));\n    }\n\n    /// @inheritdoc IEulerSwap\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data)\n        external\n        callThroughEVC\n        nonReentrant\n    {\n        require(amount0Out <= type(uint112).max && amount1Out <= type(uint112).max, AmountTooBig());\n\n        CtxLib.Storage storage s = CtxLib.getStorage();\n        Params memory p = CtxLib.getParams();\n\n        // Optimistically send tokens\n\n        if (amount0Out > 0) FundsLib.withdrawAssets(address(evc), p, p.vault0, amount0Out, to);\n        if (amount1Out > 0) FundsLib.withdrawAssets(address(evc), p, p.vault1, amount1Out, to);\n\n        // Invoke callback\n\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(_msgSender(), amount0Out, amount1Out, data);\n\n        // Deposit all available funds, adjust received amounts downward to collect fees\n\n        uint256 amount0In = FundsLib.depositAssets(address(evc), p, p.vault0);\n        uint256 amount1In = FundsLib.depositAssets(address(evc), p, p.vault1);\n\n        // Verify curve invariant is satisfied\n\n        {\n            uint256 newReserve0 = s.reserve0 + amount0In - amount0Out;\n            uint256 newReserve1 = s.reserve1 + amount1In - amount1Out;\n\n            require(CurveLib.verify(p, newReserve0, newReserve1), CurveLib.CurveViolation());\n\n            s.reserve0 = uint112(newReserve0);\n            s.reserve1 = uint112(newReserve1);\n        }\n\n        emit Swap(_msgSender(), amount0In, amount1In, amount0Out, amount1Out, s.reserve0, s.reserve1, to);\n    }\n}\n"
    }
}