{
    "vfp_id": "vfp_00613",
    "project_name": "2026-1-offchain-arbitrum-quorum-changes-securityreview.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "adjustTotalDelegation allows the new value to be zero",
            "description": "The adjustTotalDelegation function in L2ArbitrumToken.sol allows the DAO to set the total delegation value to zero via an adjustment. This occurs because while the function checks that the new value is non-negative, it does not prevent it from being exactly zero. The root cause is the lack of an explicit validation check to ensure the new value is greater than zero. An attacker with ownership privileges could set the total delegation to zero, which would cause the quorum calculation to fall back to using getPastCirculatingSupply, potentially altering quorum expectations for existing proposals. However, since the function is protected by the onlyOwner modifier, only the DAO can invoke it, limiting the risk. The impact is limited to a change in quorum calculation logic, which could affect governance outcomes if misused, but does not lead to fund loss or direct exploitation by unauthorized actors.\n",
            "severity": "Informational",
            "location": [
                "governance/src/L2ArbitrumToken.sol::adjustTotalDelegation"
            ],
            "files": [
                "governance/src/L2ArbitrumToken.sol"
            ]
        }
    ],
    "affected_files": {
        "L2ArbitrumToken.sol": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./TransferAndCallToken.sol\";\nimport \"@openzeppelin/contracts/utils/Checkpoints.sol\";\n\n/// @title  L2 Arbitrum Token\n/// @notice The L2 counterparty of the Arbitrum token.\n/// @dev    ERC20 with additional functionality:\n///         * Permit - single step transfers via sig\n///         * Votes - delegation and voting compatible with OZ governance\n///         * Burnable - user's can burn their own tokens. Can be used by the airdrop distributor\n///             after the claim period ends\n///         * Mint - allows the owner to mint a maximum of 2% per year\n///         * TransferAndCall - allows users to call a contract after doing a transfer\ncontract L2ArbitrumToken is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable,\n    OwnableUpgradeable,\n    TransferAndCallToken\n{\n    using Checkpoints for Checkpoints.History;\n\n    string private constant NAME = \"Arbitrum\";\n    string private constant SYMBOL = \"ARB\";\n    /// @notice The minimum amount of time that must elapse before a mint is allowed\n    uint256 public constant MIN_MINT_INTERVAL = 365 days;\n    /// @notice The maximum amount that can be can be minted - numerator\n    uint256 public constant MINT_CAP_NUMERATOR = 200;\n    /// @notice The maximum amount that can be can be minted - denominator\n    uint256 public constant MINT_CAP_DENOMINATOR = 10_000;\n\n    /// @notice The address of the L1 counterparty of this token\n    address public l1Address;\n    /// @notice The time at which the next mint is allowed - timestamp\n    uint256 public nextMint;\n\n    /// @dev History of the total amount of delegated tokens\n    ///      The initial value is an estimate of the total delegation at the time of upgrade proposal creation.\n    ///      Another proposal can be made later to update this value if needed.\n    Checkpoints.History private _totalDelegationHistory;\n\n    event TotalDelegationAdjusted(uint256 previousTotalDelegation, uint256 newTotalDelegation);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialise the L2 token\n    /// @param _l1TokenAddress The address of the counterparty L1 token\n    /// @param _initialSupply The amount of initial supply to mint\n    /// @param _owner The owner of this contract - controls minting, not upgradeability\n    function initialize(address _l1TokenAddress, uint256 _initialSupply, address _owner)\n        public\n        initializer\n    {\n        require(_l1TokenAddress != address(0), \"ARB: ZERO_L1TOKEN_ADDRESS\");\n        require(_initialSupply != 0, \"ARB: ZERO_INITIAL_SUPPLY\");\n        require(_owner != address(0), \"ARB: ZERO_OWNER\");\n\n        __ERC20_init(NAME, SYMBOL);\n        __ERC20Burnable_init();\n        __ERC20Permit_init(NAME);\n        __ERC20Votes_init();\n        __Ownable_init();\n\n        _mint(_owner, _initialSupply);\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n        l1Address = _l1TokenAddress;\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Called after upgrade to set the initial total delegation estimate\n    ///         The initial estimate may be manipulable with artificial delegation/undelegation prior to the upgrade.\n    ///         Since this value is only used for quorum calculation, and the quroum is clamped by the governors to an acceptable range,\n    ///         the risk/impact of manipulation is low.\n    /// @param  initialTotalDelegation The initial total delegation at the time of upgrade proposal creation.\n    ///         This is an estimate since it is chosen at proposal creation time and not effective until the proposal is executed.\n    function postUpgradeInit(uint256 initialTotalDelegation) external onlyOwner {\n        require(\n            _totalDelegationHistory._checkpoints.length == 0,\n            \"ARB: POST_UPGRADE_INIT_ALREADY_CALLED\"\n        );\n        _totalDelegationHistory.push(initialTotalDelegation);\n    }\n\n    /// @notice Adjusts total delegation value by the given amount\n    /// @param  adjustment The amount that the total delegation is off by, negated. This is added to the current total delegation.\n    function adjustTotalDelegation(int256 adjustment)\n        external\n        onlyOwner\n    {\n        uint256 latest = _totalDelegationHistory.latest();\n        int256 newValue = int256(latest) + adjustment;\n\n        // negative newValue should be impossible\n        // since the adjustment should bring the value to true total delegation\n        // which is at minimum zero\n        require(newValue >= 0, \"ARB: NEGATIVE_TOTAL_DELEGATION\");\n        _totalDelegationHistory.push(uint256(newValue));\n\n        emit TotalDelegationAdjusted(latest, uint256(newValue));\n    }\n\n    /// @notice Allows the owner to mint new tokens\n    /// @dev    Only allows minting below an inflation cap.\n    ///         Set to once per year, and a maximum of 2%.\n    function mint(address recipient, uint256 amount) external onlyOwner {\n        // function inspired by: https://github.com/ensdomains/governance/blob/548f3f3607c83717427d9ae3fc1f3a9e66fc7642/contracts/ENSToken.sol#L105\n        require(\n            amount <= (totalSupply() * MINT_CAP_NUMERATOR) / MINT_CAP_DENOMINATOR,\n            \"ARB: MINT_TOO_MUCH\"\n        );\n        require(block.timestamp >= nextMint, \"ARB: MINT_TOO_EARLY\");\n\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n        _mint(recipient, amount);\n    }\n\n    /// @notice Get the current total delegation\n    /// @return The current total delegation\n    function getTotalDelegation() external view returns (uint256) {\n        return _totalDelegationHistory.latest();\n    }\n\n    /// @notice Get the total delegation at a specific block number\n    ///         If the blockNumber is prior to the first checkpoint, returns 0\n    /// @param blockNumber The block number to get the total delegation at\n    /// @return The total delegation at the given block number\n    function getTotalDelegationAt(uint256 blockNumber) external view returns (uint256) {\n        return _totalDelegationHistory.getAtBlock(blockNumber);\n    }\n\n    /// @dev Checks if total delegation needs to be updated, and updates it if so\n    ///      by adding a new checkpoint.\n    /// @param fromDelegate The address of the delegate the tokens are being moved from\n    /// @param toDelegate The address of the delegate the tokens are being moved to\n    /// @param amount The amount of tokens being moved\n    function _updateDelegationHistory(address fromDelegate, address toDelegate, uint256 amount)\n        internal\n    {\n        if (fromDelegate != toDelegate) {\n            int256 delta = 0;\n            if (fromDelegate != address(0)) {\n                delta -= int256(amount);\n            }\n            if (toDelegate != address(0)) {\n                delta += int256(amount);\n            }\n            if (delta != 0) {\n                // if the initial estimate is too low, and a large amount of tokens are undelegated\n                // it is technically possible that the newValue is negative\n                // if this happens, we clamp it to zero to avoid underflow\n                int256 newValue = int256(_totalDelegationHistory.latest()) + delta;\n                _totalDelegationHistory.push(uint256(newValue < 0 ? int256(0) : newValue));\n            }\n        }\n    }\n\n    /// @dev Override ERC20VotesUpgradeable to update total delegation history when delegation changes\n    function _delegate(address delegator, address delegatee) internal virtual override {\n        _updateDelegationHistory(delegates(delegator), delegatee, balanceOf(delegator));\n        super._delegate(delegator, delegatee);\n    }\n\n    function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(from, to, amount);\n        _updateDelegationHistory(delegates(from), delegates(to), amount);\n    }\n\n    function _mint(address to, uint256 amount)\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._mint(to, amount);\n    }\n\n    function _burn(address account, uint256 amount)\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._burn(account, amount);\n    }\n}\n"
    }
}