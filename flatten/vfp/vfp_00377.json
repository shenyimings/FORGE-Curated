{
    "vfp_id": "vfp_00377",
    "project_name": "ChainSecurity_M0_MExtensions_Audit.pdf",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "disableEarning() on Base MExtension Might Revert",
            "description": "The `MExtension.disableEarning()` function reverts if earning is already disabled on the MToken. This creates a race condition where calling `stopEarning(wrapperAddr)` in the MToken contract first will prevent the wrapper's `disableEarning()` from being called. The cause is redundant validation in the wrapper. For current wrappers, this only suppresses event emission, but future extensions may rely on this event, leading to inconsistent state tracking.\n",
            "severity": "Informational",
            "location": [
                "MExtension::disableEarning"
            ],
            "files": [
                "evm-m-extensions/src/MExtension.sol"
            ]
        }
    ],
    "affected_files": {
        "MExtension.sol": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.26;\n\nimport { ERC20ExtendedUpgradeable } from \"../lib/common/src/ERC20ExtendedUpgradeable.sol\";\n\nimport { IERC20 } from \"../lib/common/src/interfaces/IERC20.sol\";\n\nimport { IMTokenLike } from \"./interfaces/IMTokenLike.sol\";\nimport { IMExtension } from \"./interfaces/IMExtension.sol\";\nimport { ISwapFacility } from \"./swap/interfaces/ISwapFacility.sol\";\n\nabstract contract MExtensionStorageLayout {\n    /// @custom:storage-location erc7201:M0.storage.MExtension\n    struct MExtensionStorageStruct {\n        address mToken;\n        address swapFacility;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"M0.storage.MExtension\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _M_EXTENSION_STORAGE_LOCATION =\n        0x4349758e51eb6c8ee9931b1f5b23d0b7b59124948c3d3d99ca2166d742d63d00;\n\n    function _getMExtensionStorageLocation() internal pure returns (MExtensionStorageStruct storage $) {\n        assembly {\n            $.slot := _M_EXTENSION_STORAGE_LOCATION\n        }\n    }\n}\n\n/**\n * @title MExtension\n * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.\n * @author M0 Labs\n */\nabstract contract MExtension is IMExtension, MExtensionStorageLayout, ERC20ExtendedUpgradeable {\n    /* ============ Modifiers ============ */\n\n    /// @dev Modifier to check if caller is SwapFacility.\n    modifier onlySwapFacility() {\n        if (msg.sender != swapFacility()) revert NotSwapFacility();\n        _;\n    }\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @notice Initializes the generic M extension token.\n     * @param name          The name of the token (e.g. \"HALO USD\").\n     * @param symbol        The symbol of the token (e.g. \"HUSD\").\n     * @param mToken_       The address of the M Token.\n     * @param swapFacility_ The address of the Swap Facility.\n     */\n    function __MExtension_init(\n        string memory name,\n        string memory symbol,\n        address mToken_,\n        address swapFacility_\n    ) internal onlyInitializing {\n        MExtensionStorageStruct storage $ = _getMExtensionStorageLocation();\n\n        if (($.mToken = mToken_) == address(0)) revert ZeroMToken();\n        if (($.swapFacility = swapFacility_) == address(0)) revert ZeroSwapFacility();\n\n        __ERC20ExtendedUpgradeable_init(name, symbol, 6);\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMExtension\n    function wrap(address recipient, uint256 amount) external onlySwapFacility {\n        // NOTE: `msg.sender` is always SwapFacility contract.\n        //       `swapFacility().msgSender()` is used to ensure that the original caller is passed to `_beforeWrap`.\n        _wrap(ISwapFacility(swapFacility()).msgSender(), recipient, amount);\n    }\n\n    /// @inheritdoc IMExtension\n    function unwrap(address /* recipient */, uint256 amount) external onlySwapFacility {\n        // NOTE: `msg.sender` is always SwapFacility contract.\n        //       `swapFacility().msgSender()` is used to ensure that the original caller is passed to `_beforeWrap`.\n        // NOTE: `recipient` is not used in this function as the $M is always sent to SwapFacility contract.\n        _unwrap(ISwapFacility(swapFacility()).msgSender(), amount);\n    }\n\n    /// @inheritdoc IMExtension\n    function enableEarning() external virtual {\n        if (isEarningEnabled()) revert EarningIsEnabled();\n\n        emit EarningEnabled(currentIndex());\n\n        IMTokenLike(mToken()).startEarning();\n    }\n\n    /// @inheritdoc IMExtension\n    function disableEarning() external virtual {\n        if (!isEarningEnabled()) revert EarningIsDisabled();\n\n        emit EarningDisabled(currentIndex());\n\n        IMTokenLike(mToken()).stopEarning(address(this));\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc IMExtension\n    function currentIndex() public view virtual returns (uint128) {\n        return IMTokenLike(mToken()).currentIndex();\n    }\n\n    /// @inheritdoc IMExtension\n    function isEarningEnabled() public view virtual returns (bool) {\n        return IMTokenLike(mToken()).isEarning(address(this));\n    }\n\n    /// @inheritdoc IMExtension\n    function mToken() public view returns (address) {\n        return _getMExtensionStorageLocation().mToken;\n    }\n\n    /// @inheritdoc IMExtension\n    function swapFacility() public view returns (address) {\n        return _getMExtensionStorageLocation().swapFacility;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256);\n\n    /* ============ Hooks For Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Hook called before approval of M Extension token.\n     * @param account   The sender's address.\n     * @param spender   The spender address.\n     * @param amount    The amount to be approved.\n     */\n    function _beforeApprove(address account, address spender, uint256 amount) internal virtual {}\n\n    /**\n     * @dev    Hook called before wrapping M into M Extension token.\n     * @param  account   The account from which M is deposited.\n     * @param  recipient The account receiving the minted M Extension token.\n     * @param  amount    The amount of M deposited.\n     */\n    function _beforeWrap(address account, address recipient, uint256 amount) internal virtual {}\n\n    /**\n     * @dev   Hook called before unwrapping M Extension token.\n     * @param account   The account from which M Extension token is burned.\n     * @param amount    The amount of M Extension token burned.\n     */\n    function _beforeUnwrap(address account, uint256 amount) internal virtual {}\n\n    /**\n     * @dev   Hook called before transferring M Extension token.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _beforeTransfer(address sender, address recipient, uint256 amount) internal virtual {}\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev Approve `spender` to spend `amount` of tokens from `account`.\n     * @param account The address approving the allowance.\n     * @param spender The address approved to spend the tokens.\n     * @param amount  The amount of tokens being approved for spending.\n     */\n    function _approve(address account, address spender, uint256 amount) internal override {\n        // NOTE: Add extension-specific checks before approval.\n        _beforeApprove(account, spender, amount);\n\n        super._approve(account, spender, amount);\n    }\n\n    /**\n     * @dev    Wraps `amount` M from `account` into M Extension for `recipient`.\n     * @param  account   The original caller of SwapFacility functions.\n     * @param  recipient The account receiving the minted M Extension token.\n     * @param  amount    The amount of M deposited.\n     */\n    function _wrap(address account, address recipient, uint256 amount) internal {\n        _revertIfInvalidRecipient(recipient);\n        _revertIfInsufficientAmount(amount);\n\n        // NOTE: Add extension-specific checks before wrapping.\n        _beforeWrap(account, recipient, amount);\n\n        // NOTE: Always transfer from SwapFacility as it is the only contract that can call this function.\n        // NOTE: The behavior of `IMTokenLike.transferFrom` is known, so its return can be ignored.\n        IMTokenLike(mToken()).transferFrom(swapFacility(), address(this), amount);\n\n        // NOTE: Mints precise amount of $M Extension token to `recipient`.\n        //       Option 1: $M transfer from an $M earner to another $M earner ($M Extension in earning state): rounds up → rounds up,\n        //                 0, 1, or XX extra wei may be locked in M Extension compared to the minted amount of $M Extension token.\n        //       Option 2: $M transfer from an $M non-earner to an $M earner ($M Extension in earning state): precise $M transfer → rounds down,\n        //                 0, -1, or -XX wei may be locked in $M Extension compared to the minted amount of $M Extension token.\n        //\n        // This method will be overridden by the inheriting M Extension contract.\n        _mint(recipient, amount);\n    }\n\n    /**\n     * @dev    Unwraps `amount` M Extension token from `account` into $M and transfers to SwapFacility.\n     * @param  account   The original caller of SwapFacility functions.\n     * @param  amount    The amount of M Extension token burned.\n     */\n    function _unwrap(address account, uint256 amount) internal {\n        _revertIfInsufficientAmount(amount);\n\n        // NOTE: Add extension-specific checks before unwrapping.\n        _beforeUnwrap(account, amount);\n\n        _revertIfInsufficientBalance(account, balanceOf(account), amount);\n\n        // NOTE: The behavior of `IMTokenLike.transfer` is known, so its return can be ignored.\n        // NOTE: Computes the actual decrease in the $M balance of the $M Extension contract.\n        //       Option 1: $M transfer from an $M earner ($M Extension in earning state) to another $M earner: round up → rounds up.\n        //       Option 2: $M transfer from an $M earner ($M Extension in earning state) to an $M non-earner: round up → precise $M transfer.\n        //       In both cases, 0, 1, or XX extra wei may be deducted from the $M Extension contract's $M balance compared to the burned amount of $M Extension token.\n        //\n        // This method will be overridden by the inheriting M Extension contract.\n        _burn(account, amount);\n\n        // NOTE: The behavior of `IMTokenLike.transfer` is known, so its return can be ignored.\n        IMTokenLike(mToken()).transfer(swapFacility(), amount);\n    }\n\n    /**\n     * @dev Mints `amount` tokens to `recipient`.\n     * @param recipient The address to which the tokens will be minted.\n     * @param amount    The amount of tokens to mint.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual;\n\n    /**\n     * @dev Burns `amount` tokens from `account`.\n     * @param account The address from which the tokens will be burned.\n     * @param amount  The amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal virtual;\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _update(address sender, address recipient, uint256 amount) internal virtual;\n\n    /**\n     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.\n     * @param sender    The sender's address.\n     * @param recipient The recipient's address.\n     * @param amount    The amount to be transferred.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        _revertIfInvalidRecipient(recipient);\n\n        // NOTE: Add extension-specific checks before transfers.\n        _beforeTransfer(sender, recipient, amount);\n\n        emit Transfer(sender, recipient, amount);\n\n        if (amount == 0) return;\n\n        _revertIfInsufficientBalance(sender, balanceOf(sender), amount);\n\n        // NOTE: This method will be overridden by the inheriting M Extension contract.\n        _update(sender, recipient, amount);\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev    Returns the M Token balance of `account`.\n     * @param  account The account being queried.\n     * @return balance The M Token balance of the account.\n     */\n    function _mBalanceOf(address account) internal view returns (uint256) {\n        return IMTokenLike(mToken()).balanceOf(account);\n    }\n\n    /**\n     * @dev   Reverts if `recipient` is address(0).\n     * @param recipient Address of a recipient.\n     */\n    function _revertIfInvalidRecipient(address recipient) internal pure {\n        if (recipient == address(0)) revert InvalidRecipient(recipient);\n    }\n\n    /**\n     * @dev   Reverts if `amount` is equal to 0.\n     * @param amount Amount of token.\n     */\n    function _revertIfInsufficientAmount(uint256 amount) internal pure {\n        if (amount == 0) revert InsufficientAmount(amount);\n    }\n\n    /**\n     * @dev   Reverts if `account` balance is below `balance`.\n     * @param account Address of an account.\n     * @param balance Balance of an account.\n     * @param amount Amount to transfer or burn.\n     */\n    function _revertIfInsufficientBalance(address account, uint256 balance, uint256 amount) internal pure {\n        if (balance < amount) revert InsufficientBalance(account, balance, amount);\n    }\n}\n"
    }
}