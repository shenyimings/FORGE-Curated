{
    "vfp_id": "vfp_00352",
    "project_name": "Polygon Staking - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1176"
                ],
                "5": [
                    "CWE-1067"
                ]
            },
            "title": "Gas optimization in the removeSplitter function",
            "description": "The removeSplitter function in LSTRewardsSplitterController removes a splitter by looping through an array to find the address, then replacing it with the last element and popping the array. This operation has variable gas costs depending on the array size.\n\nThe cause is the use of an O(n) linear search instead of leveraging the known index of the splitter, which could be provided by the caller or computed off-chain.\n\nAn attacker could force the function to process a large array, leading to high gas consumption, potentially making the function unusable if the gas limit is exceeded.\n\nThe impact is a potential denial of service that increases transaction costs unnecessarily, especially as the number of splitters grows, leading to suboptimal gas usage and reduced scalability.\n",
            "severity": "Informational",
            "location": [
                "LSTRewardsSplitterController::removeSplitter#"
            ],
            "files": [
                "contracts/contracts/core/lstRewardsSplitter/LSTRewardsSplitterController.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-770"
                ],
                "4": [
                    "CWE-1325"
                ]
            },
            "title": "Adding too many splitters can cause a denial of service",
            "description": "The `addSplitter` function in the `LSTRewardsSplitterController` contract allows the owner to add an unlimited number of splitters without any upper limit. While the function itself runs in constant time, the absence of a cap means that the `accounts` array can grow indefinitely. This can lead to gas exhaustion during operations that iterate over all accounts, such as protocol-wide updates or reward distributions.\n\nThe root cause is the lack of a hardcoded limit on the number of splitters, which exposes the system to potential denial-of-service attacks through resource exhaustion. Although `removeSplitter` is optimized to run in constant time for the first element, operations that require full iteration become increasingly expensive.\n\nAn attacker with ownership privileges (or a compromised owner) could exploit this by adding a large number of splitters, eventually making the contract unusable due to out-of-gas errors during normal operations. Even if the owner is honest, accidental accumulation over time could lead to the same outcome.\n\nThe impact is a potential denial of service that could disrupt protocol operations, requiring manual intervention to remove and re-add splitters in a more efficient order to restore functionality.\n",
            "severity": "Low",
            "location": [
                "LSTRewardsSplitterController.sol::addSplitter"
            ],
            "files": [
                "contracts/contracts/core/lstRewardsSplitter/LSTRewardsSplitterController.sol"
            ]
        }
    ],
    "affected_files": {
        "LSTRewardsSplitterController.sol": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.22;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IERC677.sol\";\nimport \"../interfaces/ILSTRewardsSplitter.sol\";\nimport \"./LSTRewardsSplitter.sol\";\n\n/**\n * @title LST Rewards Splitter Controller\n * @notice Manages multiple LSTRewardsSplitters\n */\ncontract LSTRewardsSplitterController is Ownable {\n    using SafeERC20 for IERC677;\n\n    // mapping of account address to corresponding splitter\n    mapping(address => ILSTRewardsSplitter) public splitters;\n    // list of accounts that have splitters\n    address[] internal accounts;\n\n    // address of liquid staking token\n    address public lst;\n    // min amount of new rewards required to split\n    uint256 public rewardThreshold;\n\n    error InvalidToken();\n    error SenderNotAuthorized();\n    error InvalidPerformData();\n    error SplitterAlreadyExists();\n    error SplitterNotFound();\n\n    /**\n     * @notice Initializes contract\n     * @param _lst address of liquid staking token\n     * @param _rewardThreshold min amount of new rewards required to split\n     */\n    constructor(address _lst, uint256 _rewardThreshold) {\n        lst = _lst;\n        rewardThreshold = _rewardThreshold;\n    }\n\n    /**\n     * @notice Returns a list of all accounts\n     * @return list of accounts\n     */\n    function getAccounts() external view returns (address[] memory) {\n        return accounts;\n    }\n\n    /**\n     * @notice ERC677 implementation to receive an LST deposit\n     **/\n    function onTokenTransfer(address _sender, uint256 _value, bytes calldata) external {\n        if (msg.sender != lst) revert InvalidToken();\n        if (address(splitters[_sender]) == address(0)) revert SenderNotAuthorized();\n\n        splitters[_sender].deposit(_value);\n    }\n\n    /**\n     * @notice Withdraws tokens\n     * @param _amount amount to withdraw\n     */\n    function withdraw(uint256 _amount) external {\n        if (address(splitters[msg.sender]) == address(0)) revert SenderNotAuthorized();\n        splitters[msg.sender].withdraw(_amount, msg.sender);\n    }\n\n    /**\n     * @notice Returns whether a call should be made to performUpkeep to split new rewards\n     * @return upkeepNeeded true if performUpkeep should be called, false otherwise\n     * @return performData abi encoded list of splitters to call\n     */\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        bool[] memory splittersToCall = new bool[](accounts.length);\n        bool overallUpkeepNeeded;\n\n        for (uint256 i = 0; i < splittersToCall.length; ++i) {\n            (bool upkeepNeeded, ) = splitters[accounts[i]].checkUpkeep(\"\");\n            splittersToCall[i] = upkeepNeeded;\n            if (upkeepNeeded) overallUpkeepNeeded = true;\n        }\n\n        return (overallUpkeepNeeded, abi.encode(splittersToCall));\n    }\n\n    /**\n     * @notice splits new rewards between receivers\n     * @param _performData abi encoded list of splitters to call\n     */\n    function performUpkeep(bytes calldata _performData) external {\n        bool[] memory splittersToCall = abi.decode(_performData, (bool[]));\n        bool splitterCalled;\n\n        for (uint256 i = 0; i < splittersToCall.length; ++i) {\n            if (splittersToCall[i] == true) {\n                splitters[accounts[i]].performUpkeep(\"\");\n                splitterCalled = true;\n            }\n        }\n\n        if (splitterCalled == false) {\n            revert InvalidPerformData();\n        }\n    }\n\n    /**\n     * @notice Deploys a new splitter\n     * @param _account address of account to deploy splitter for\n     * @param _fees list of splitter fees\n     */\n    function addSplitter(\n        address _account,\n        LSTRewardsSplitter.Fee[] memory _fees\n    ) external onlyOwner {\n        if (address(splitters[_account]) != address(0)) revert SplitterAlreadyExists();\n\n        address splitter = address(new LSTRewardsSplitter(lst, _fees, owner()));\n        splitters[_account] = ILSTRewardsSplitter(splitter);\n        accounts.push(_account);\n        IERC677(lst).safeApprove(splitter, type(uint256).max);\n    }\n\n    /**\n     * @notice Removes an account's splitter\n     * @param _account address of account\n     **/\n    function removeSplitter(address _account) external onlyOwner {\n        ILSTRewardsSplitter splitter = splitters[_account];\n        if (address(splitter) == address(0)) revert SplitterNotFound();\n\n        uint256 balance = IERC20(lst).balanceOf(address(splitter));\n        uint256 principalDeposits = splitter.principalDeposits();\n        if (balance != 0) {\n            if (balance != principalDeposits) splitter.splitRewards();\n            splitter.withdraw(splitter.principalDeposits(), _account);\n        }\n\n        delete splitters[_account];\n\n        uint256 numAccounts = accounts.length;\n        for (uint256 i = 0; i < numAccounts; ++i) {\n            if (accounts[i] == _account) {\n                accounts[i] = accounts[numAccounts - 1];\n                accounts.pop();\n                break;\n            }\n        }\n\n        IERC677(lst).safeApprove(address(splitter), 0);\n    }\n\n    /**\n     * @notice Sets the reward threshold\n     * @param _rewardThreshold min amount of new rewards required to split\n     */\n    function setRewardThreshold(uint256 _rewardThreshold) external onlyOwner {\n        rewardThreshold = _rewardThreshold;\n    }\n}\n"
    }
}