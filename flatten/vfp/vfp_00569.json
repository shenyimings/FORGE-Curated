{
    "vfp_id": "vfp_00569",
    "project_name": "Mitosis - Zellic Audit Report.pdf",
    "findings": [
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect cap reset in setCap function",
            "description": "The _setCap function in MitosisVault.sol resets the availableCap to the new cap value without subtracting the amount already deposited, which breaks the cap enforcement logic. The root cause is the failure to account for the current balance when updating the cap. This allows an attacker or admin to reset the cap and then deposit additional funds up to the new cap, effectively bypassing the intended maximum limit. For example, after depositing 50 tokens under a 100 cap, resetting the cap to 500 sets availableCap to 500, allowing another 500 deposits, resulting in a total of 550 tokensâ€”exceeding the intended cap. The impact is medium, as it could lead to over-collateralization, violate economic assumptions, and affect dependent systems that rely on accurate cap enforcement.\n",
            "severity": "Medium",
            "location": [
                "protocol/src/hub/vault/MitosisVault.sol"
            ],
            "files": [
                "f18b1965c3d5816e422edb206efe598f0fb39899/protocol/src/branch/MitosisVault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Missing availableCap update in withdraw function",
            "description": "The withdraw function in MitosisVault.sol does not increase the availableCap when users withdraw funds, while the _deposit function correctly decreases it. This inconsistency causes the availableCap to become increasingly inaccurate over time, as it only decreases and never recovers on withdrawals. The root cause is the omission of a line to increment availableCap in the withdraw function. Although not immediately exploitable, this leads to a gradual erosion of available deposit capacity, potentially blocking future deposits even when the vault has sufficient headroom. An attacker could exacerbate this by making repeated deposit-withdraw cycles to deplete availableCap. The impact is low, as it primarily affects usability and efficiency rather than leading to direct fund loss.\n",
            "severity": "Low",
            "location": [
                "protocol/src/branch/MitosisVault.sol"
            ],
            "files": [
                "f18b1965c3d5816e422edb206efe598f0fb39899/protocol/src/branch/MitosisVault.sol"
            ]
        }
    ],
    "affected_files": {
        "MitosisVault.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { IERC20 } from '@oz/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@oz/token/ERC20/utils/SafeERC20.sol';\nimport { Ownable2StepUpgradeable } from '@ozu/access/Ownable2StepUpgradeable.sol';\nimport { UUPSUpgradeable } from '@ozu/proxy/utils/UUPSUpgradeable.sol';\n\nimport { AssetAction, IMitosisVault } from '../interfaces/branch/IMitosisVault.sol';\nimport { IMitosisVaultEntrypoint } from '../interfaces/branch/IMitosisVaultEntrypoint.sol';\nimport { ERC7201Utils } from '../lib/ERC7201Utils.sol';\nimport { Pausable } from '../lib/Pausable.sol';\nimport { StdError } from '../lib/StdError.sol';\nimport { MitosisVaultEOL } from './MitosisVaultEOL.sol';\nimport { MitosisVaultMatrix } from './MitosisVaultMatrix.sol';\n\ncontract MitosisVault is\n  IMitosisVault,\n  Pausable,\n  Ownable2StepUpgradeable,\n  UUPSUpgradeable,\n  MitosisVaultMatrix,\n  MitosisVaultEOL\n{\n  using SafeERC20 for IERC20;\n  using ERC7201Utils for string;\n\n  struct AssetInfo {\n    bool initialized;\n    uint256 maxCap;\n    uint256 availableCap;\n    mapping(AssetAction => bool) isHalted;\n  }\n\n  struct StorageV1 {\n    IMitosisVaultEntrypoint entrypoint;\n    mapping(address asset => AssetInfo) assets;\n  }\n\n  string private constant _NAMESPACE = 'mitosis.storage.MitosisVaultStorage.v1';\n  bytes32 private immutable _slot = _NAMESPACE.storageSlot();\n\n  function _getStorageV1() internal view returns (StorageV1 storage $) {\n    bytes32 slot = _slot;\n    // slither-disable-next-line assembly\n    assembly {\n      $.slot := slot\n    }\n  }\n\n  //=========== NOTE: INITIALIZATION FUNCTIONS ===========//\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    revert StdError.NotSupported();\n  }\n\n  receive() external payable {\n    revert StdError.NotSupported();\n  }\n\n  function initialize(address owner_) public initializer {\n    __Pausable_init();\n    __Ownable2Step_init();\n    __Ownable_init(owner_);\n    __UUPSUpgradeable_init();\n  }\n\n  //=========== NOTE: VIEW FUNCTIONS ===========//\n\n  function maxCap(address asset) external view returns (uint256) {\n    return _getStorageV1().assets[asset].maxCap;\n  }\n\n  function availableCap(address asset) external view returns (uint256) {\n    return _getStorageV1().assets[asset].availableCap;\n  }\n\n  function isAssetActionHalted(address asset, AssetAction action) external view returns (bool) {\n    return _isHalted(_getStorageV1(), asset, action);\n  }\n\n  function isAssetInitialized(address asset) external view returns (bool) {\n    return _isAssetInitialized(_getStorageV1(), asset);\n  }\n\n  function entrypoint() public view override(IMitosisVault, MitosisVaultMatrix, MitosisVaultEOL) returns (address) {\n    return address(_getStorageV1().entrypoint);\n  }\n\n  //=========== NOTE: MUTATIVE - ASSET FUNCTIONS ===========//\n\n  function initializeAsset(address asset) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertAssetNotInitialized($, asset);\n\n    $.assets[asset].initialized = true;\n    emit AssetInitialized(asset);\n\n    // NOTE: we halt deposit and keep the cap at zero by default.\n    _haltAsset($, asset, AssetAction.Deposit);\n  }\n\n  function deposit(address asset, address to, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _deposit(asset, to, amount);\n\n    $.entrypoint.deposit(asset, to, amount);\n    emit Deposited(asset, to, amount);\n  }\n\n  function withdraw(address asset, address to, uint256 amount) external whenNotPaused {\n    StorageV1 storage $ = _getStorageV1();\n\n    _assertOnlyEntrypoint($);\n    _assertAssetInitialized(asset);\n\n    IERC20(asset).safeTransfer(to, amount);\n\n    emit Withdrawn(asset, to, amount);\n  }\n\n  //=========== NOTE: OWNABLE FUNCTIONS ===========//\n\n  function _authorizeUpgrade(address) internal override onlyOwner { }\n\n  function _authorizePause(address) internal view override onlyOwner { }\n\n  function setEntrypoint(address entrypoint_) external onlyOwner {\n    _getStorageV1().entrypoint = IMitosisVaultEntrypoint(entrypoint_);\n    emit EntrypointSet(address(entrypoint_));\n  }\n\n  function setCap(address asset, uint256 newCap) external onlyOwner {\n    StorageV1 storage $ = _getStorageV1();\n    _assertAssetInitialized(asset);\n\n    _setCap($, asset, newCap);\n  }\n\n  function haltAsset(address asset, AssetAction action) external onlyOwner {\n    StorageV1 storage $ = _getStorageV1();\n    _assertAssetInitialized(asset);\n    return _haltAsset($, asset, action);\n  }\n\n  function resumeAsset(address asset, AssetAction action) external onlyOwner {\n    StorageV1 storage $ = _getStorageV1();\n    _assertAssetInitialized(asset);\n    return _resumeAsset($, asset, action);\n  }\n\n  //=========== NOTE: INTERNAL FUNCTIONS ===========//\n\n  function _assertOnlyEntrypoint(StorageV1 storage $) internal view {\n    require(_msgSender() == address($.entrypoint), StdError.Unauthorized());\n  }\n\n  function _assertCapNotExceeded(StorageV1 storage $, address asset, uint256 amount) internal view {\n    uint256 available = $.assets[asset].availableCap;\n    require(available >= amount, IMitosisVault__ExceededCap(asset, amount, available));\n  }\n\n  function _assertAssetInitialized(address asset) internal view override(MitosisVaultMatrix, MitosisVaultEOL) {\n    require(_isAssetInitialized(_getStorageV1(), asset), IMitosisVault__AssetNotInitialized(asset));\n  }\n\n  function _assertAssetNotInitialized(StorageV1 storage $, address asset) internal view {\n    require(!_isAssetInitialized($, asset), IMitosisVault__AssetAlreadyInitialized(asset));\n  }\n\n  function _assertNotHalted(StorageV1 storage $, address asset, AssetAction action) internal view {\n    require(!_isHalted($, asset, action), StdError.Halted());\n  }\n\n  function _isHalted(StorageV1 storage $, address asset, AssetAction action) internal view returns (bool) {\n    return $.assets[asset].isHalted[action];\n  }\n\n  function _isAssetInitialized(StorageV1 storage $, address asset) internal view returns (bool) {\n    return $.assets[asset].initialized;\n  }\n\n  function _setCap(StorageV1 storage $, address asset, uint256 newCap) internal {\n    AssetInfo storage assetInfo = $.assets[asset];\n    uint256 prevCap = assetInfo.maxCap;\n    assetInfo.maxCap = newCap;\n    assetInfo.availableCap = newCap;\n    emit CapSet(_msgSender(), asset, prevCap, newCap);\n  }\n\n  function _haltAsset(StorageV1 storage $, address asset, AssetAction action) internal {\n    $.assets[asset].isHalted[action] = true;\n    emit AssetHalted(asset, action);\n  }\n\n  function _resumeAsset(StorageV1 storage $, address asset, AssetAction action) internal {\n    $.assets[asset].isHalted[action] = false;\n    emit AssetResumed(asset, action);\n  }\n\n  function _deposit(address asset, address to, uint256 amount) internal override(MitosisVaultMatrix, MitosisVaultEOL) {\n    StorageV1 storage $ = _getStorageV1();\n    require(to != address(0), StdError.ZeroAddress('to'));\n    require(amount != 0, StdError.ZeroAmount());\n\n    _assertAssetInitialized(asset);\n    _assertNotHalted($, asset, AssetAction.Deposit);\n    _assertCapNotExceeded($, asset, amount);\n\n    $.assets[asset].availableCap -= amount;\n    IERC20(asset).safeTransferFrom(_msgSender(), address(this), amount);\n  }\n}\n"
    }
}