{
    "vfp_id": "vfp_00450",
    "project_name": "Linea Burn Mechanism Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Unprotected Reinitializer Function",
            "description": "The RollupRevenueVault contract is an upgradeable contract using the OpenZeppelin Initializable pattern. It includes a reinitializer function (initializeRolesAndStorageVariables) intended for use during version 2 upgrades. The vulnerability arises because this function lacks access control. While the reinitializer(2) modifier prevents re-entry after version 2 initialization, it does not restrict who can call the function before that point. The root cause is the absence of role-based or ownership checks on a critical initialization function. A malicious actor could exploit this by calling the function before a legitimate upgrade, thereby setting all critical roles (e.g., DEFAULT_ADMIN_ROLE, BURNER_ROLE) to attacker-controlled addresses. This would result in a complete hostile takeover of the contract, allowing the attacker to drain funds or disrupt operations. The impact is severe for new deployments, potentially leading to total loss of funds and control.\n",
            "severity": "Medium",
            "location": [
                "RollupRevenueVault.sol::initializeRolesAndStorageVariables#L98-L123"
            ],
            "files": [
                "linea-monorepo/contracts/src/operational/RollupRevenueVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Generic DEX Interaction in RollupRevenueVault",
            "description": "The RollupRevenueVault contract performs ETH-to-LINEA swaps via a generic low-level call to a configurable DEX address using opaque _swapData. Instead of using the safer, high-level interface of the purpose-built V3DexSwap contract, it relies on externally provided calldata. The root cause is the design choice to use a generic .call() instead of enforcing a specific interface with validated parameters. This places full trust in the BURNER_ROLE to generate secure calldata, including correct slippage protection (e.g., _minLineaOut). An attacker with access to the BURNER_ROLE or a compromised off-chain service could craft malicious _swapData that results in excessive slippage or a failed swap, leading to loss of funds or denial of service. The impact is reduced economic efficiency and potential fund loss due to poor trade execution, though the core protocol functionality remains intact.\n",
            "severity": "Low",
            "location": [
                "RollupRevenueVault.sol::burnAndBridge#L211"
            ],
            "files": [
                "linea-monorepo/contracts/src/operational/RollupRevenueVault.sol"
            ]
        }
    ],
    "affected_files": {
        "RollupRevenueVault.sol": "// SPDX-License-Identifier: Apache-2.0 OR MIT\npragma solidity 0.8.30;\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { L2MessageService } from \"../messaging/l2/L2MessageService.sol\";\nimport { TokenBridge } from \"../bridging/token/TokenBridge.sol\";\nimport { IRollupRevenueVault } from \"./interfaces/IRollupRevenueVault.sol\";\n\n/**\n * @title Upgradeable Rollup Revenue Vault Contract.\n * @notice Accepts rollup revenue, and performs burning operations.\n * @author Consensys Software Inc.\n * @custom:security-contact security-report@linea.build\n */\ncontract RollupRevenueVault is AccessControlUpgradeable, IRollupRevenueVault {\n  bytes32 public constant INVOICE_SUBMITTER_ROLE = keccak256(\"INVOICE_SUBMITTER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n  /// @notice Percentage of ETH to be burnt when performing the burn and bridge operation.\n  uint256 public constant ETH_BURNT_PERCENTAGE = 20;\n\n  /// @notice Decentralized exchange contract for swapping ETH to LINEA tokens.\n  address public dex;\n  /// @notice Address to receive invoice payments.\n  address public invoicePaymentReceiver;\n  /// @notice Amount of invoice arrears.\n  uint256 public invoiceArrears;\n  /// @notice Timestamp of the last invoice.\n  uint256 public lastInvoiceDate;\n  /// @notice Address of the token bridge contract.\n  TokenBridge public tokenBridge;\n  /// @notice Address of the L2 message service contract.\n  L2MessageService public messageService;\n  /// @notice Address of the L1 LINEA token burner contract to which LINEA tokens are bridged for burning.\n  address public l1LineaTokenBurner;\n  /// @notice Address of the LINEA token contract.\n  address public lineaToken;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes the contract state.\n   * @param _lastInvoiceDate Timestamp of the last invoice.\n   * @param _defaultAdmin Address to be granted the default admin role.\n   * @param _invoiceSubmitter Address to be granted the invoice submitter role.\n   * @param _burner Address to be granted the burner role.\n   * @param _invoicePaymentReceiver Address to receive invoice payments.\n   * @param _tokenBridge Address of the token bridge contract.\n   * @param _messageService Address of the L2 message service contract.\n   * @param _l1LineaTokenBurner Address of the L1 LINEA token burner contract.\n   * @param _lineaToken Address of the LINEA token contract.\n   * @param _dex Address of the DEX contract.\n   */\n  function initialize(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) external initializer {\n    __AccessControl_init();\n    __RollupRevenueVault_init(\n      _lastInvoiceDate,\n      _defaultAdmin,\n      _invoiceSubmitter,\n      _burner,\n      _invoicePaymentReceiver,\n      _tokenBridge,\n      _messageService,\n      _l1LineaTokenBurner,\n      _lineaToken,\n      _dex\n    );\n  }\n\n  /**\n   * @notice Reinitializes the contract state for upgrade.\n   * @param _lastInvoiceDate Timestamp of the last invoice.\n   * @param _defaultAdmin Address to be granted the default admin role.\n   * @param _invoiceSubmitter Address to be granted the invoice submitter role.\n   * @param _burner Address to be granted the burner role.\n   * @param _invoicePaymentReceiver Address to receive invoice payments.\n   * @param _tokenBridge Address of the token bridge contract.\n   * @param _messageService Address of the L2 message service contract.\n   * @param _l1LineaTokenBurner Address of the L1 LINEA token burner contract.\n   * @param _lineaToken Address of the LINEA token contract.\n   * @param _dex Address of the DEX contract.\n   */\n  function initializeRolesAndStorageVariables(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) external reinitializer(2) {\n    __AccessControl_init();\n    __RollupRevenueVault_init(\n      _lastInvoiceDate,\n      _defaultAdmin,\n      _invoiceSubmitter,\n      _burner,\n      _invoicePaymentReceiver,\n      _tokenBridge,\n      _messageService,\n      _l1LineaTokenBurner,\n      _lineaToken,\n      _dex\n    );\n  }\n\n  function __RollupRevenueVault_init(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) internal onlyInitializing {\n    require(_lastInvoiceDate != 0, ZeroTimestampNotAllowed());\n    require(_defaultAdmin != address(0), ZeroAddressNotAllowed());\n    require(_invoiceSubmitter != address(0), ZeroAddressNotAllowed());\n    require(_burner != address(0), ZeroAddressNotAllowed());\n    require(_invoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n    require(_tokenBridge != address(0), ZeroAddressNotAllowed());\n    require(_messageService != address(0), ZeroAddressNotAllowed());\n    require(_l1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n    require(_lineaToken != address(0), ZeroAddressNotAllowed());\n    require(_dex != address(0), ZeroAddressNotAllowed());\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n    _grantRole(INVOICE_SUBMITTER_ROLE, _invoiceSubmitter);\n    _grantRole(BURNER_ROLE, _burner);\n\n    lastInvoiceDate = _lastInvoiceDate;\n\n    invoicePaymentReceiver = _invoicePaymentReceiver;\n    tokenBridge = TokenBridge(_tokenBridge);\n    messageService = L2MessageService(_messageService);\n    l1LineaTokenBurner = _l1LineaTokenBurner;\n    lineaToken = _lineaToken;\n    dex = _dex;\n  }\n\n  /**\n   * @notice Submit invoice to pay to the designated receiver.\n   * @param _startTimestamp Start of the period the invoice is covering.\n   * @param _endTimestamp End of the period the invoice is covering.\n   * @param _invoiceAmount New invoice amount.\n   */\n  function submitInvoice(\n    uint256 _startTimestamp,\n    uint256 _endTimestamp,\n    uint256 _invoiceAmount\n  ) external payable onlyRole(INVOICE_SUBMITTER_ROLE) {\n    require(_startTimestamp == lastInvoiceDate + 1, TimestampsNotInSequence());\n    require(_endTimestamp > _startTimestamp, EndTimestampMustBeGreaterThanStartTimestamp());\n    require(_invoiceAmount != 0, ZeroInvoiceAmount());\n\n    address payable receiver = payable(invoicePaymentReceiver);\n    uint256 balanceAvailable = address(this).balance;\n\n    uint256 totalAmountOwing = invoiceArrears + _invoiceAmount;\n    uint256 amountToPay = (balanceAvailable < totalAmountOwing) ? balanceAvailable : totalAmountOwing;\n\n    invoiceArrears = totalAmountOwing - amountToPay;\n    lastInvoiceDate = _endTimestamp;\n\n    if (amountToPay > 0) {\n      (bool success, ) = receiver.call{ value: amountToPay }(\"\");\n      require(success, InvoiceTransferFailed());\n    }\n\n    emit InvoiceProcessed(receiver, _startTimestamp, _endTimestamp, amountToPay, _invoiceAmount);\n  }\n\n  /**\n   * @notice Burns 20% of the ETH balance and uses the rest to buy LINEA tokens which are then bridged to L1 to be burned.\n   * @param _swapData Encoded calldata for the DEX swap function.\n   */\n  function burnAndBridge(bytes calldata _swapData) external onlyRole(BURNER_ROLE) {\n    require(invoiceArrears == 0, InvoiceInArrears());\n\n    uint256 minimumFee = messageService.minimumFeeInWei();\n\n    require(address(this).balance > minimumFee, InsufficientBalance());\n\n    uint256 balanceAvailable = address(this).balance - minimumFee;\n\n    uint256 ethToBurn = (balanceAvailable * ETH_BURNT_PERCENTAGE) / 100;\n    (bool success, ) = address(0).call{ value: ethToBurn }(\"\");\n    require(success, EthBurnFailed());\n\n    (bool swapSuccess, bytes memory returnData) = dex.call{ value: balanceAvailable - ethToBurn }(_swapData);\n    require(swapSuccess, DexSwapFailed());\n\n    uint256 numLineaTokens = abi.decode(returnData, (uint256));\n    require(numLineaTokens > 0, ZeroLineaTokensReceived());\n\n    IERC20(lineaToken).approve(address(tokenBridge), numLineaTokens);\n\n    tokenBridge.bridgeToken{ value: minimumFee }(lineaToken, numLineaTokens, l1LineaTokenBurner);\n\n    emit EthBurntSwappedAndBridged(ethToBurn, numLineaTokens);\n  }\n\n  /**\n   * @notice Update the invoice payment receiver.\n   * @param _newInvoicePaymentReceiver New invoice payment receiver address.\n   */\n  function updateInvoicePaymentReceiver(address _newInvoicePaymentReceiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_newInvoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n\n    address currentInvoicePaymentReceiver = invoicePaymentReceiver;\n    require(_newInvoicePaymentReceiver != currentInvoicePaymentReceiver, ExistingAddressTheSame());\n\n    invoicePaymentReceiver = _newInvoicePaymentReceiver;\n    emit InvoicePaymentReceiverUpdated(currentInvoicePaymentReceiver, _newInvoicePaymentReceiver);\n  }\n\n  /**\n   * @notice Update the invoice arrears.\n   * @param _newInvoiceArrears New invoice arrears value.\n   * @param _lastInvoiceDate Timestamp of the last invoice.\n   */\n  function updateInvoiceArrears(\n    uint256 _newInvoiceArrears,\n    uint256 _lastInvoiceDate\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_lastInvoiceDate >= lastInvoiceDate, InvoiceDateTooOld());\n\n    invoiceArrears = _newInvoiceArrears;\n    lastInvoiceDate = _lastInvoiceDate;\n    emit InvoiceArrearsUpdated(_newInvoiceArrears, _lastInvoiceDate);\n  }\n\n  /**\n   * @notice Updates the address of the L1 LINEA token burner contract.\n   * @param _newL1LineaTokenBurner Address of the new L1 LINEA token burner contract.\n   */\n  function updateL1LineaTokenBurner(address _newL1LineaTokenBurner) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_newL1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n\n    address currentL1LineaTokenBurner = l1LineaTokenBurner;\n    require(_newL1LineaTokenBurner != currentL1LineaTokenBurner, ExistingAddressTheSame());\n\n    l1LineaTokenBurner = _newL1LineaTokenBurner;\n    emit L1LineaTokenBurnerUpdated(currentL1LineaTokenBurner, _newL1LineaTokenBurner);\n  }\n\n  /**\n   * @notice Updates the address of the DEX contract.\n   * @param _newDex Address of the new DEX contract.\n   */\n  function updateDex(address _newDex) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_newDex != address(0), ZeroAddressNotAllowed());\n\n    address currentDex = dex;\n    require(_newDex != currentDex, ExistingAddressTheSame());\n\n    dex = _newDex;\n    emit DexUpdated(currentDex, _newDex);\n  }\n\n  /**\n   * @notice Fallback function - Receives Funds.\n   */\n  fallback() external payable {\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Receive function - Receives Funds.\n   */\n  receive() external payable {\n    emit EthReceived(msg.value);\n  }\n}\n"
    }
}