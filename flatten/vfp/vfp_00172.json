{
    "vfp_id": "vfp_00172",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Inconsistent No-Witness Registration Handling - Phase 2",
            "description": "The `deriveClaimHashAndRegisterCompact` function always includes the witness in the claim hash calculation, even when the `typehash` is `COMPACT_TYPEHASH`, which indicates no witness should be included. In contrast, `toClaimHashFromDeposit` correctly omits the witness in such cases.\nThe root cause is inconsistent logic across registration functions, leading to hash mismatches when no witness is intended.\nThis inconsistency can cause valid claims to fail verification or allow malformed claims to pass, depending on the registration path used.\nThe impact includes potential claim rejection or validation bypass, undermining the integrity of the registration system and creating edge cases that could be exploited.\n",
            "severity": "Low",
            "location": [
                "RegistrationLogic.sol::deriveClaimHashAndRegisterCompact#104",
                "HashLib.sol::toClaimHashFromDeposit#625"
            ],
            "files": [
                "the-compact/src/lib/RegistrationLogic.sol"
            ]
        }
    ],
    "affected_files": {
        "RegistrationLogic.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatorLib } from \"./AllocatorLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { DomainLib } from \"./DomainLib.sol\";\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\n\n/**\n * @title RegistrationLogic\n * @notice Inherited contract implementing logic for registering compact claim hashes\n * and typehashes and querying for whether given claim hashes and typehashes have\n * been registered.\n */\ncontract RegistrationLogic is ConstructorLogic {\n    using AllocatorLib for uint256[2][];\n    using RegistrationLib for address;\n    using RegistrationLib for bytes32;\n    using RegistrationLib for bytes32[2][];\n    using ValidityLib for address;\n    using ValidityLib for bytes32;\n    using IdLib for address;\n    using EfficiencyLib for uint256;\n    using DomainLib for uint256;\n\n    /**\n     * @notice Internal function for registering a claim hash. The claim hash and its\n     * associated typehash will remain valid until the shortest reset period of the\n     * compact that the claim hash is derived from has elapsed.\n     * @param sponsor   The account registering the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     */\n    function _register(address sponsor, bytes32 claimHash, bytes32 typehash) internal {\n        sponsor.registerCompact(claimHash, typehash);\n    }\n\n    /**\n     * @notice Internal function for registering multiple claim hashes in a single call. Each\n     * claim hash and its associated typehash will remain valid until the shortest reset period\n     * of the respective compact that the claim hash is derived from has elapsed.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                         Whether all claim hashes were successfully registered.\n     */\n    function _registerBatch(bytes32[2][] calldata claimHashesAndTypehashes) internal returns (bool) {\n        return claimHashesAndTypehashes.registerBatchAsCaller();\n    }\n\n    /**\n     * @notice Internal function for registering a compact on behalf of a sponsor with their signature.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered compact.\n     */\n    function _registerFor(address sponsor, bytes32 typehash, bytes calldata sponsorSignature)\n        internal\n        returns (bytes32 claimHash)\n    {\n        return _deriveClaimHashAndRegisterCompact(sponsor, typehash, 0x100, _domainSeparator(), sponsorSignature);\n    }\n\n    /**\n     * @notice Internal function for registering a batch compact on behalf of a sponsor with their signature.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered batch compact.\n     */\n    function _registerBatchFor(address sponsor, bytes32 typehash, bytes calldata sponsorSignature)\n        internal\n        returns (bytes32 claimHash)\n    {\n        return _deriveClaimHashAndRegisterCompact(sponsor, typehash, 0xe0, _domainSeparator(), sponsorSignature);\n    }\n\n    /**\n     * @notice Internal function for registering a multichain compact on behalf of a sponsor with their signature.\n     * Note that the multichain compact in question will need to be independently registered on each chain where\n     * onchain registration is desired.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param notarizedChainId Chain ID of the domain used to sign the multichain compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered multichain compact.\n     */\n    function _registerMultichainFor(\n        address sponsor,\n        bytes32 typehash,\n        uint256 notarizedChainId,\n        bytes calldata sponsorSignature\n    ) internal returns (bytes32 claimHash) {\n        return _deriveClaimHashAndRegisterCompact(\n            sponsor, typehash, 0xa0, notarizedChainId.toNotarizedDomainSeparator(), sponsorSignature\n        );\n    }\n\n    /**\n     * @notice Internal function for deriving a claim hash and registering it as a compact.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param preimageLength   The length of the preimage data used to derive the claim hash.\n     * @param domainSeparator  The domain separator to use for signature verification.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The derived and registered claim hash.\n     */\n    function _deriveClaimHashAndRegisterCompact(\n        address sponsor,\n        bytes32 typehash,\n        uint256 preimageLength,\n        bytes32 domainSeparator,\n        bytes calldata sponsorSignature\n    ) internal returns (bytes32 claimHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Copy relevant arguments from calldata to prepare hash preimage.\n            // Note that provided arguments may have dirty upper bits, which will\n            // give a claim hash that cannot be derived during claim processing.\n            calldatacopy(m, 0x04, preimageLength)\n\n            // Derive the claim hash from the prepared preimage data.\n            claimHash := keccak256(m, preimageLength)\n        }\n\n        // Ensure that the sponsor has verified the supplied claim hash.\n        claimHash.hasValidSponsor(sponsor, sponsorSignature, domainSeparator);\n\n        // Register the compact for the indicated sponsor.\n        sponsor.registerCompact(claimHash, typehash);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the expiration timestamp of a\n     * registration.\n     * @param sponsor   The account that registered the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     * @return registrationTimestamp The timestamp at which the registration was made.\n     */\n    function _getRegistrationStatus(address sponsor, bytes32 claimHash, bytes32 typehash)\n        internal\n        view\n        returns (uint256 registrationTimestamp)\n    {\n        registrationTimestamp = sponsor.toRegistrationTimestamp(claimHash, typehash);\n    }\n\n    //// Registration of specific claims ////\n\n    /**\n     * @notice Internal function to register a claim with witness by its components.\n     * @dev Constructs and registers the compact that consists exactly of the provided\n     * arguments.\n     * @param sponsor     Account that the claim should be registered for.\n     * @param tokenId     Identifier for the associated token & lock.\n     * @param amount      Claim's associated number of tokens.\n     * @param arbiter     Account verifying and initiating the settlement of the claim.\n     * @param nonce       Allocator replay protection nonce.\n     * @param expires     Timestamp when the claim expires. Not to be confused with the reset\n     * time of the compact.\n     * @param typehash    Typehash of the entire compact. Including the subtypes of the\n     * witness\n     * @param witness     EIP712 structured hash of witness.\n     */\n    function _registerUsingClaimWithWitness(\n        address sponsor,\n        uint256 tokenId,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) internal returns (bytes32 claimhash) {\n        claimhash =\n            HashLib.toFlatMessageHashWithWitness(sponsor, tokenId, amount, arbiter, nonce, expires, typehash, witness);\n        sponsor.registerCompact(claimhash, typehash);\n    }\n\n    /**\n     * @notice Internal function to register a batch claim with witness by its components.\n     * @dev Constructs and registers the compact that consists exactly of the provided\n     * arguments.\n     * @param sponsor       Account that the claim should be registered for.\n     * @param idsAndAmounts Ids and amounts associated with the to be registered claim.\n     * @param arbiter       Account verifying and initiating the settlement of the claim.\n     * @param nonce         Nonce to register the claim at. The nonce is not checked to be\n     * unspent\n     * @param expires       Timestamp when the claim expires. Not to be confused with the\n     * reset time of the compact.\n     * @param typehash      Typehash of the entire compact. Including the subtypes of the\n     * witness\n     * @param witness       EIP712 structured hash of witness.\n     * @param replacementAmounts An optional array of replacement amounts.\n     */\n    function _registerUsingBatchClaimWithWitness(\n        address sponsor,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness,\n        uint256[] memory replacementAmounts\n    ) internal returns (bytes32 claimhash) {\n        claimhash = HashLib.toFlatBatchClaimWithWitnessMessageHash(\n            sponsor, idsAndAmounts, arbiter, nonce, expires, typehash, witness, replacementAmounts\n        );\n        sponsor.registerCompact(claimhash, typehash);\n    }\n}\n"
    }
}