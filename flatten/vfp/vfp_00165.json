{
    "vfp_id": "vfp_00165",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "register*For Functions Allow Replay of Past Registrations",
            "description": "The `register*For` functions record the timestamp of a sponsor's claim authorization, which determines its validity period. However, these functions do not prevent replaying of old registrations, allowing arbitrary users to refresh the timestamp and extend expired authorizations.\nThe cause is the lack of replay protection or nonce validation in the registration logic. This allows a malicious allocator, possibly colluding with an arbiter, to reuse an old sponsor signature to re-register an expired claim.\nBy replaying a past registration, the attacker bypasses the sponsor's authorization step, effectively reducing the two-step verification (sponsor + allocator) to a single step. This enables execution of expired claims without current sponsor consent.\nThe impact includes unauthorized claim execution, loss of expected expiration guarantees, and potential fund loss if outdated compacts are reactivated without the sponsor's knowledge.\n",
            "severity": "Medium",
            "location": [
                "ValidityLib.sol#146-152"
            ],
            "files": [
                "the-compact/src/lib/ValidityLib.sol"
            ]
        }
    ],
    "affected_files": {
        "ValidityLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Scope } from \"../types/Scope.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\nimport { IdLib } from \"./IdLib.sol\";\nimport { ConsumerLib } from \"./ConsumerLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { DomainLib } from \"./DomainLib.sol\";\nimport { EmissaryLib } from \"./EmissaryLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\n\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\n\n/**\n * @title ValidityLib\n * @notice Library contract implementing logic for validating expirations,\n * signatures, nonces (including consuming unused nonces), and token addresses.\n */\nlibrary ValidityLib {\n    using RegistrationLib for address;\n    using ValidityLib for address;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using ConsumerLib for uint256;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for ResetPeriod;\n    using DomainLib for bytes32;\n    using ValidityLib for uint256;\n    using EmissaryLib for bytes32;\n    using EmissaryLib for uint256[2][];\n    using FixedPointMathLib for uint256;\n    using SignatureCheckerLib for address;\n\n    error NoIdsAndAmountsProvided();\n\n    /**\n     * @notice Internal function that retrieves an allocator's address from their ID and\n     * consumes a nonce in their scope. Reverts if the allocator is not registered.\n     * @param allocatorId The unique identifier for a registered allocator.\n     * @param nonce       The nonce to consume in the allocator's scope.\n     * @return allocator  The address of the registered allocator.\n     */\n    function fromRegisteredAllocatorIdWithConsumed(uint96 allocatorId, uint256 nonce)\n        internal\n        returns (address allocator)\n    {\n        allocator = allocatorId.toRegisteredAllocator();\n        nonce.consumeNonceAsAllocator(allocator);\n    }\n\n    /**\n     * @notice Internal function that retrieves an allocator's address from a resource lock ID\n     * and consumes a nonce in their scope. Reverts if the allocator is not registered.\n     * @param id         The ERC6909 token identifier containing the allocator ID.\n     * @param nonce      The nonce to consume in the allocator's scope.\n     * @return allocator The address of the registered allocator.\n     */\n    function toRegisteredAllocatorWithConsumed(uint256 id, uint256 nonce) internal returns (address allocator) {\n        allocator = id.toAllocator();\n        nonce.consumeNonceAsAllocator(allocator);\n    }\n\n    /**\n     * @notice Internal view function that ensures that a timestamp has not yet passed.\n     * Reverts if the provided timestamp is not in the future.\n     * @param expires The timestamp to check.\n     */\n    function later(uint256 expires) internal view {\n        assembly (\"memory-safe\") {\n            if iszero(gt(expires, timestamp())) {\n                // revert Expired(expiration);\n                mstore(0, 0xf80dbaea)\n                mstore(0x20, expires)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function that validates a signature against an expected signer.\n     * Returns if the signature is valid or if the caller is the expected signer, otherwise\n     * reverts. The message hash is combined with the domain separator before verification.\n     * If ECDSA recovery fails, an EIP-1271 isValidSignature check is performed. Note that\n     * an emissary check will not be performed.\n     * @param messageHash     The EIP-712 hash of the message to verify.\n     * @param expectedSigner  The address that should have signed the message.\n     * @param signature       The signature to verify.\n     * @param domainSeparator The domain separator to combine with the message hash.\n     */\n    function hasValidSponsor(\n        bytes32 messageHash,\n        address expectedSigner,\n        bytes calldata signature,\n        bytes32 domainSeparator\n    ) internal view {\n        // Apply domain separator to message hash to derive the digest.\n        bytes32 digest = messageHash.withDomain(domainSeparator);\n\n        // First, check signature against digest with ECDSA (or ensure sponsor is caller).\n        if (expectedSigner.isValidECDSASignatureCalldata(digest, signature)) {\n            return;\n        }\n\n        // Finally, check EIP1271 using the digest and signature.\n        if (!expectedSigner.isValidERC1271SignatureNowCalldata(digest, signature)) {\n            assembly (\"memory-safe\") {\n                // revert InvalidSignature();\n                mstore(0, 0x8baa579f)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function that validates a signature or registration against an expected\n     * signer. If the initial verification fails, the emissary is used to valdiate the claim.\n     * Returns if the signature is valid or if the caller is the expected signer, otherwise\n     * reverts. The claim hash is combined with the domain separator before verification.\n     * If ECDSA recovery fails, an EIP-1271 isValidSignature check is performed with half of\n     * available gas. If EIP-1271 fails, and an IEmissary is set for the sponsor, an\n     * IEmissary.verifyClaim check is performed.\n     * @param claimHash           The EIP-712 hash of the claim to verify.\n     * @param expectedSigner      The address that should have signed the message.\n     * @param signature           The signature to verify.\n     * @param domainSeparator     The domain separator to combine with the message hash.\n     * @param typehash            The EIP-712 typehash used for the claim message.\n     * @param shortestResetPeriod The shortest reset period across all resource locks on the compact.\n     */\n    function hasValidSponsorOrRegistration(\n        bytes32 claimHash,\n        address expectedSigner,\n        bytes calldata signature,\n        bytes32 domainSeparator,\n        uint256[2][] memory idsAndAmounts,\n        bytes32 typehash,\n        uint256 shortestResetPeriod\n    ) internal view {\n        // Get registration status early if no signature is supplied.\n        bool checkedRegistrationPeriod;\n        if (signature.length == 0) {\n            uint256 registrationTimestamp = expectedSigner.toRegistrationTimestamp(claimHash, typehash);\n\n            if ((registrationTimestamp != 0).and(registrationTimestamp + shortestResetPeriod > block.timestamp)) {\n                return;\n            }\n\n            checkedRegistrationPeriod = true;\n        }\n\n        // Apply domain separator to message hash to derive the digest.\n        bytes32 digest = claimHash.withDomain(domainSeparator);\n\n        // First, check signature against digest with ECDSA (or ensure sponsor is caller).\n        if (expectedSigner.isValidECDSASignatureCalldata(digest, signature)) {\n            return;\n        }\n\n        // Next, check for an active registration if not yet checked.\n        if (!checkedRegistrationPeriod) {\n            uint256 registrationTimestamp = expectedSigner.toRegistrationTimestamp(claimHash, typehash);\n\n            if ((registrationTimestamp != 0).and(registrationTimestamp + shortestResetPeriod > block.timestamp)) {\n                return;\n            }\n        }\n\n        // Then, check EIP1271 using the digest, supplying half of available gas.\n        if (expectedSigner.isValidERC1271SignatureNowCalldataHalfGas(digest, signature)) {\n            return;\n        }\n\n        // Finally, fallback to emissary using the claim hash.\n        claimHash.verifyWithEmissary(expectedSigner, idsAndAmounts.extractSameLockTag(), signature);\n    }\n\n    /**\n     * @notice Internal view function to check if a nonce has been consumed in an\n     * allocator's scope.\n     * @param allocator The allocator whose scope to check.\n     * @param nonce     The nonce to check.\n     * @return          Whether the nonce has been consumed.\n     */\n    function hasConsumedAllocatorNonce(address allocator, uint256 nonce) internal view returns (bool) {\n        return nonce.isConsumedByAllocator(allocator);\n    }\n\n    /**\n     * @notice Internal pure function that validates a token address is not the zero\n     * address (which represents native tokens). Reverts if the address is zero.\n     * @param token The token address to validate.\n     * @return      The validated token address.\n     */\n    function excludingNative(address token) internal pure returns (address) {\n        assembly (\"memory-safe\") {\n            if iszero(shl(96, token)) {\n                // revert InvalidToken(0);\n                mstore(0x40, 0x961c9a4f)\n                revert(0x5c, 0x24)\n            }\n        }\n\n        return token;\n    }\n\n    /**\n     * @notice Internal pure function for validating that a resource lock's scope is compatible\n     * with the provided sponsor domain separator. Reverts if an exogenous claim (indicated by\n     * a non-zero sponsor domain separator) attempts to claim against a chain-specific resource\n     * lock (indicated by the most significant bit of the id).\n     * @param sponsorDomainSeparator The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param id                     The ERC6909 token identifier of the resource lock.\n     */\n    function ensureValidScope(bytes32 sponsorDomainSeparator, uint256 id) internal pure {\n        assembly (\"memory-safe\") {\n            if iszero(or(iszero(sponsorDomainSeparator), iszero(shr(255, id)))) {\n                // revert InvalidScope(id)\n                mstore(0, 0xa06356f5)\n                mstore(0x20, id)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function for determining if a resource lock has chain-specific\n     * scope in the context of an exogenous claim. Returns true if the claim is exogenous\n     * (indicated by a non-zero sponsor domain separator) and the resource lock is\n     * chain-specific.\n     * @param id                     The ERC6909 token identifier of the resource lock.\n     * @param sponsorDomainSeparator The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @return                       Whether the resource lock's scope is incompatible with the claim context.\n     */\n    function scopeNotMultichain(uint256 id, bytes32 sponsorDomainSeparator) internal pure returns (bool) {\n        return (sponsorDomainSeparator != bytes32(0)).and(id.toScope() == Scope.ChainSpecific);\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// using `ecrecover`.\n    function isValidECDSASignatureCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        // Determine whether the signer is the caller.\n        bool signerIsCaller = signer == msg.sender;\n\n        // Exit early if signer is either the caller or the null address.\n        if ((signer == address(0)).or(signerIsCaller)) {\n            // Valid if signer is caller, otherwise invalid (null address).\n            return signerIsCaller;\n        }\n\n        assembly (\"memory-safe\") {\n            // Cache free memory pointer.\n            let m := mload(0x40)\n\n            // Use a faux loop to support breaking early.\n            for { } 1 { } {\n                // examine the length of the supplied signature.\n                switch signature.length\n                case 64 {\n                    // Parse length 64 as EIP2098 compact signatures.\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    // Parse length 65 as standard rsv signatures.\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                }\n                default { break }\n\n                // Prepare hash in scratch space.\n                mstore(0x00, hash)\n\n                // Call the ecrecover precompile and examine returndata for validity.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n\n                // Restore the zero slot and free memory pointer.\n                mstore(0x60, 0)\n                mstore(0x40, m)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    /// Sourced from Solady with a modification to only supply half of available gas.\n    function isValidERC1271SignatureNowCalldataHalfGas(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        assembly (\"memory-safe\") {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(div(gas(), 2), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n}\n"
    }
}