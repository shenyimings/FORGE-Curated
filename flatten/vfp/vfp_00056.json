{
    "vfp_id": "vfp_00056",
    "project_name": "cantina_centrifuge_may2025.pdf",
    "findings": [
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Holding amounts may be updated erroneously when queueing asset amounts",
            "description": "The BalanceSheet contract may update holding amounts incorrectly when processing queued assets if PoolManager.updatePricePoolPerShare is called while assets are queued. The issue arises because submitQueuedAssets uses the current pricePoolPerAsset, which may have changed since the deposit was approved. This leads to inaccurate valuation of queued deposits. The root cause is the lack of snapshotting or locking the price at the time of queueing. While the system allows manual adjustments via Hub.updateHoldingValue, this introduces reliance on operator intervention. An attacker could potentially exploit price volatility windows to manipulate holding valuations, though the risk is mitigated by the need for precise timing. The impact is potential mispricing of assets and incorrect share calculations, affecting fairness and accuracy.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "protocol-v3/src/vaults/BalanceSheet.sol"
            ]
        }
    ],
    "affected_files": {
        "BalanceSheet.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {IERC6909} from \"src/misc/interfaces/IERC6909.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {MessageLib, UpdateContractType} from \"src/common/libraries/MessageLib.sol\";\nimport {IVaultMessageSender} from \"../common/interfaces/IGatewaySenders.sol\";\nimport {IBalanceSheetGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IPoolManager} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBalanceSheet, QueueAmount} from \"src/vaults/interfaces/IBalanceSheet.sol\";\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {IUpdateContract} from \"src/vaults/interfaces/IUpdateContract.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\n\n/// @title  Balance Sheet\n/// @notice Management contract that integrates all balance sheet functions of a pool:\n///         - Issuing and revoking shares\n///         - Depositing and withdrawing assets\n///         - Force transferring shares\n///\n///         Share and asset updates to the Hub are optionally queued, to reduce the cost\n///         per transaction. Dequeuing can be triggered locally by the manager or from the Hub.\ncontract BalanceSheet is Auth, Recoverable, IBalanceSheet, IBalanceSheetGatewayHandler, IUpdateContract {\n    using MathLib for *;\n    using CastLib for bytes32;\n\n    IRoot public immutable root;\n\n    IGateway public gateway;\n    IPoolManager public poolManager;\n    IVaultMessageSender public sender;\n    IPoolEscrowProvider public poolEscrowProvider;\n\n    mapping(PoolId => mapping(address => bool)) public manager;\n    mapping(PoolId poolId => mapping(ShareClassId scId => bool)) public queueEnabled;\n    mapping(PoolId poolId => mapping(ShareClassId scId => QueueAmount)) public queuedShares;\n    mapping(PoolId poolId => mapping(ShareClassId scId => mapping(AssetId assetId => QueueAmount))) public queuedAssets;\n\n    constructor(IRoot root_, address deployer) Auth(deployer) {\n        root = root_;\n    }\n\n    /// @dev Check if the msg.sender is ward or a manager\n    modifier authOrManager(PoolId poolId) {\n        require(wards[msg.sender] == 1 || manager[poolId][msg.sender], IAuth.NotAuthorized());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    function file(bytes32 what, address data) external auth {\n        if (what == \"gateway\") gateway = IGateway(data);\n        else if (what == \"poolManager\") poolManager = IPoolManager(data);\n        else if (what == \"sender\") sender = IVaultMessageSender(data);\n        else if (what == \"poolEscrowProvider\") poolEscrowProvider = IPoolEscrowProvider(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    function update(PoolId poolId, ShareClassId, /* scId */ bytes calldata payload) external auth {\n        uint8 kind = uint8(MessageLib.updateContractType(payload));\n\n        if (kind == uint8(UpdateContractType.UpdateManager)) {\n            MessageLib.UpdateContractUpdateManager memory m = MessageLib.deserializeUpdateContractUpdateManager(payload);\n            address who = m.who.toAddress();\n\n            manager[poolId][who] = m.canManage;\n            emit UpdateManager(poolId, who, m.canManage);\n        } else {\n            revert UnknownUpdateContractType();\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Management functions\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheet\n    function deposit(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, address owner, uint128 amount)\n        external\n        authOrManager(poolId)\n    {\n        AssetId assetId = poolManager.assetToId(asset, tokenId);\n        _noteDeposit(poolId, scId, assetId, asset, tokenId, owner, amount);\n        _executeDeposit(poolId, asset, tokenId, owner, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    /// @dev This function is mostly useful to keep higher level integrations CEI adherent.\n    function noteDeposit(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address owner,\n        uint128 amount\n    ) external authOrManager(poolId) {\n        AssetId assetId = poolManager.assetToId(asset, tokenId);\n        _noteDeposit(poolId, scId, assetId, asset, tokenId, owner, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function withdraw(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount\n    ) external authOrManager(poolId) {\n        AssetId assetId = poolManager.assetToId(asset, tokenId);\n        _withdraw(poolId, scId, assetId, asset, tokenId, receiver, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function issue(PoolId poolId, ShareClassId scId, address to, uint128 shares) external authOrManager(poolId) {\n        _issue(poolId, scId, to, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function revoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) external authOrManager(poolId) {\n        _noteRevoke(poolId, scId, from, shares);\n        _executeRevoke(poolId, scId, from, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    /// @dev This function is mostly useful to keep higher level integrations CEI adherent.\n    function noteRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares)\n        external\n        authOrManager(poolId)\n    {\n        _noteRevoke(poolId, scId, from, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function transferSharesFrom(PoolId poolId, ShareClassId scId, address from, address to, uint256 amount)\n        external\n        authOrManager(poolId)\n    {\n        require(!root.endorsed(from), CannotTransferFromEndorsedContract());\n        IShareToken token = IShareToken(poolManager.shareToken(poolId, scId));\n        token.authTransferFrom(from, from, to, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function overridePricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 value)\n        external\n        authOrManager(poolId)\n    {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAsset\", poolId, scId, assetId)), value.raw());\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)), true);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function overridePricePoolPerShare(PoolId poolId, ShareClassId scId, D18 value) external authOrManager(poolId) {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerShare\", poolId, scId)), value.raw());\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId)), true);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function triggerDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, address owner, uint128 amount)\n        external\n        auth\n    {\n        (address asset, uint256 tokenId) = poolManager.idToAsset(assetId);\n        _noteDeposit(poolId, scId, assetId, asset, tokenId, owner, amount);\n        _executeDeposit(poolId, asset, tokenId, owner, amount);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function triggerWithdraw(PoolId poolId, ShareClassId scId, AssetId assetId, address receiver, uint128 amount)\n        external\n        auth\n    {\n        (address asset, uint256 tokenId) = poolManager.idToAsset(assetId);\n        _withdraw(poolId, scId, assetId, asset, tokenId, receiver, amount);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function triggerIssueShares(PoolId poolId, ShareClassId scId, address receiver, uint128 shares) external auth {\n        _issue(poolId, scId, receiver, shares);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function setQueue(PoolId poolId, ShareClassId scId, bool enabled) external auth {\n        queueEnabled[poolId][scId] = enabled;\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function submitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) external authOrManager(poolId) {\n        _submitQueuedAssets(poolId, scId, assetId);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function submitQueuedShares(PoolId poolId, ShareClassId scId) external authOrManager(poolId) {\n        _submitQueuedShares(poolId, scId);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal\n    //----------------------------------------------------------------------------------------------\n\n    function _noteDeposit(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address asset,\n        uint256 tokenId,\n        address owner,\n        uint128 amount\n    ) internal {\n        IPoolEscrow escrow = poolEscrowProvider.escrow(poolId);\n        escrow.deposit(scId, asset, tokenId, amount);\n\n        D18 pricePoolPerAsset_ = _pricePoolPerAsset(poolId, scId, assetId);\n        emit Deposit(poolId, scId, asset, tokenId, owner, amount, pricePoolPerAsset_);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedAssets[poolId][scId][assetId].increase += amount;\n        } else {\n            sender.sendUpdateHoldingAmount(poolId, scId, assetId, owner, amount, pricePoolPerAsset_, true);\n        }\n    }\n\n    function _executeDeposit(PoolId poolId, address asset, uint256 tokenId, address owner, uint128 amount) internal {\n        IPoolEscrow escrow = poolEscrowProvider.escrow(poolId);\n        if (tokenId == 0) {\n            SafeTransferLib.safeTransferFrom(asset, owner, address(escrow), amount);\n        } else {\n            IERC6909(asset).transferFrom(owner, address(escrow), tokenId, amount);\n        }\n    }\n\n    function _withdraw(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount\n    ) internal {\n        IPoolEscrow escrow = poolEscrowProvider.escrow(poolId);\n        escrow.withdraw(scId, asset, tokenId, amount);\n\n        D18 pricePoolPerAsset_ = _pricePoolPerAsset(poolId, scId, assetId);\n        emit Withdraw(poolId, scId, asset, tokenId, receiver, amount, pricePoolPerAsset_);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedAssets[poolId][scId][assetId].decrease += amount;\n        } else {\n            sender.sendUpdateHoldingAmount(poolId, scId, assetId, receiver, amount, pricePoolPerAsset_, false);\n        }\n\n        escrow.authTransferTo(asset, tokenId, receiver, amount);\n    }\n\n    function _issue(PoolId poolId, ShareClassId scId, address to, uint128 shares) internal {\n        emit Issue(poolId, scId, to, _pricePoolPerShare(poolId, scId), shares);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedShares[poolId][scId].increase += shares;\n        } else {\n            sender.sendUpdateShares(poolId, scId, shares, true);\n        }\n\n        IShareToken token = poolManager.shareToken(poolId, scId);\n        token.mint(to, shares);\n    }\n\n    function _noteRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) internal {\n        emit Revoke(poolId, scId, from, _pricePoolPerShare(poolId, scId), shares);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedShares[poolId][scId].decrease += shares;\n        } else {\n            sender.sendUpdateShares(poolId, scId, shares, false);\n        }\n    }\n\n    function _executeRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) internal {\n        IShareToken token = poolManager.shareToken(poolId, scId);\n        token.authTransferFrom(from, from, address(this), shares);\n        token.burn(address(this), shares);\n    }\n\n    function _submitQueuedShares(PoolId poolId, ShareClassId scId) internal {\n        QueueAmount storage queue = queuedShares[poolId][scId];\n\n        if (queue.increase > queue.decrease) {\n            sender.sendUpdateShares(poolId, scId, queue.increase - queue.decrease, true);\n        } else if (queue.decrease > queue.increase) {\n            sender.sendUpdateShares(poolId, scId, queue.decrease - queue.increase, false);\n        }\n\n        queue.increase = 0;\n        queue.decrease = 0;\n    }\n\n    function _submitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) internal {\n        QueueAmount storage queue = queuedAssets[poolId][scId][assetId];\n\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, assetId);\n        if (queue.increase > queue.decrease) {\n            sender.sendUpdateHoldingAmount(\n                poolId, scId, assetId, address(0), queue.increase - queue.decrease, pricePoolPerAsset, true\n            );\n        } else if (queue.decrease > queue.increase) {\n            sender.sendUpdateHoldingAmount(\n                poolId, scId, assetId, address(0), queue.decrease - queue.increase, pricePoolPerAsset, false\n            );\n        }\n\n        queue.increase = 0;\n        queue.decrease = 0;\n    }\n\n    function _pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId) internal view returns (D18) {\n        if (TransientStorageLib.tloadBool(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)))) {\n            return\n                d18(TransientStorageLib.tloadUint128(keccak256(abi.encode(\"pricePoolPerAsset\", poolId, scId, assetId))));\n        }\n\n        (D18 pricePoolPerAsset,) = poolManager.pricePoolPerAsset(poolId, scId, assetId, true);\n        return pricePoolPerAsset;\n    }\n\n    function _pricePoolPerShare(PoolId poolId, ShareClassId scId) internal view returns (D18) {\n        if (TransientStorageLib.tloadBool(keccak256(abi.encode(\"pricePoolPerShareIsSet\", poolId, scId)))) {\n            return d18(TransientStorageLib.tloadUint128(keccak256(abi.encode(\"pricePoolPerShare\", poolId, scId))));\n        }\n\n        (D18 pricePoolPerShare,) = poolManager.pricePoolPerShare(poolId, scId, true);\n        return pricePoolPerShare;\n    }\n}\n"
    }
}