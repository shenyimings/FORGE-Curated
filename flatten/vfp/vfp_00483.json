{
    "vfp_id": "vfp_00483",
    "project_name": "2025.08.14 - Final - Malda Audit Report.pdf",
    "findings": [
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "No endpoint to trigger liquidateExternal from extension chain",
            "description": "The mErc20Host contract has a liquidateExternal endpoint, but there is no corresponding endpoint in mTokenGateway to trigger this function from an extension chain via a proof forwarder. The root cause is the missing functionality in mTokenGateway to handle liquidation requests from other chains. This issue is exacerbated by the inability to perform permissionless calls when the source is Ethereum mainnet. The exploitation is passive; any attempt to liquidate from an extension chain fails due to the missing endpoint. The impact is that liquidateExternal cannot be called from extension chains, especially Ethereum mainnet, preventing cross-chain liquidations and increasing risk of undercollateralized positions.\n",
            "severity": "Medium",
            "location": [
                "mTokenGateway.sol#224-252"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/extension/mTokenGateway.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-179"
                ]
            },
            "title": "Blacklist can be completely bypassed on outHere endpoint in mTokenGateway",
            "description": "The mTokenGateway's outHere function is protected by ifNotBlacklisted modifiers for msg.sender and receiver. However, the receiver parameter is overwritten inside the _outHere function with _sender extracted from the journalData. Since _sender is not checked against the blacklist, a blacklisted user can craft a journal with a non-blacklisted allowedCaller as msg.sender and their own address as _sender, thereby bypassing the blacklist. The root cause is the lack of a blacklist check on the decoded _sender value. An attacker can exploit this to withdraw funds even if their address is blacklisted. The impact is a complete bypass of the blacklist mechanism, undermining the protocol's ability to restrict malicious actors.\n",
            "severity": "Medium",
            "location": [
                "mTokenGateway.sol#254-262",
                "mTokenGateway.sol#281-286"
            ],
            "files": [
                "798d00b879b8412ca4049ba09dba5ae42464cfe7/2025-07-malda/malda-lending/src/mToken/extension/mTokenGateway.sol"
            ]
        }
    ],
    "affected_files": {
        "mTokenGateway.sol": "// Copyright (c) 2025 Merge Layers Inc.\n//\n// This source code is licensed under the Business Source License 1.1\n// (the \"License\"); you may not use this file except in compliance with the\n// License. You may obtain a copy of the License at\n//\n//     https://github.com/malda-protocol/malda-lending/blob/main/LICENSE-BSL\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file contains code derived from or inspired by Compound V2,\n// originally licensed under the BSD 3-Clause License. See LICENSE-COMPOUND-V2\n// for original license terms and attributions.\n\n// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.28;\n\n/*\n _____ _____ __    ____  _____ \n|     |  _  |  |  |    \\|  _  |\n| | | |     |  |__|  |  |     |\n|_|_|_|__|__|_____|____/|__|__|   \n*/\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n// contracts\nimport {IRoles} from \"src/interfaces/IRoles.sol\";\nimport {IBlacklister} from \"src/interfaces/IBlacklister.sol\";\nimport {ImTokenGateway} from \"src/interfaces/ImTokenGateway.sol\";\nimport {ImTokenOperationTypes} from \"src/interfaces/ImToken.sol\";\n\nimport {mTokenProofDecoderLib} from \"src/libraries/mTokenProofDecoderLib.sol\";\n\nimport {IZkVerifier} from \"src/verifier/ZkVerifier.sol\";\n\ncontract mTokenGateway is OwnableUpgradeable, ImTokenGateway, ImTokenOperationTypes {\n    using SafeERC20 for IERC20;\n\n    // ----------- STORAGE -----------\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    IRoles public rolesOperator;\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    IBlacklister public blacklistOperator;\n\n    IZkVerifier public verifier;\n\n    mapping(OperationType => bool) public paused;\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    address public underlying;\n\n    mapping(address => uint256) public accAmountIn;\n    mapping(address => uint256) public accAmountOut;\n    mapping(address => mapping(address => bool)) public allowedCallers;\n    mapping(address => bool) public userWhitelisted;\n    bool public whitelistEnabled;\n\n    uint32 private constant LINEA_CHAIN_ID = 59144;\n\n    ///@dev gas fee for `supplyOnHost`\n    uint256 public gasFee;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address payable _owner, address _underlying, address _roles, address _blacklister, address zkVerifier_)\n        external\n        initializer\n    {\n        __Ownable_init(_owner);\n        require(_roles != address(0), mTokenGateway_AddressNotValid());\n        require(zkVerifier_ != address(0), mTokenGateway_AddressNotValid());\n        require(_blacklister != address(0), mTokenGateway_AddressNotValid());\n        require(_underlying != address(0), mTokenGateway_AddressNotValid());\n        require(_roles != address(0), mTokenGateway_AddressNotValid());\n\n        underlying = _underlying;\n        rolesOperator = IRoles(_roles);\n        blacklistOperator = IBlacklister(_blacklister);\n\n        verifier = IZkVerifier(zkVerifier_);\n    }\n\n    modifier notPaused(OperationType _type) {\n        require(!paused[_type], mTokenGateway_Paused(_type));\n        _;\n    }\n\n    modifier onlyAllowedUser(address user) {\n        if (whitelistEnabled) {\n            require(userWhitelisted[user], mTokenGateway_UserNotWhitelisted());\n        }\n        _;\n    }\n\n    modifier ifNotBlacklisted(address user) {\n        require (!blacklistOperator.isBlacklisted(user), mTokenGateway_UserBlacklisted());\n        _;\n    }\n\n    // ----------- VIEW ------------\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function isPaused(OperationType _type) external view returns (bool) {\n        return paused[_type];\n    }\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function getProofData(address user, uint32) external view returns (uint256, uint256) {\n        return (accAmountIn[user], accAmountOut[user]);\n    }\n\n    // ----------- OWNER ------------\n    /**\n     * @notice Sets user whitelist status\n     * @param user The user address\n     * @param state The new staate\n     */\n    function setWhitelistedUser(address user, bool state) external onlyOwner {\n        userWhitelisted[user] = state;\n        emit mTokenGateway_UserWhitelisted(user, state);\n    }\n\n    /**\n     * @notice Enable user whitelist\n     */\n    function enableWhitelist() external onlyOwner {\n        whitelistEnabled = true;\n        emit mTokenGateway_WhitelistEnabled();\n    }\n\n    /**\n     * @notice Disable user whitelist\n     */\n    function disableWhitelist() external onlyOwner {\n        whitelistEnabled = false;\n        emit mTokenGateway_WhitelistDisabled();\n    }\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function setPaused(OperationType _type, bool state) external override {\n        if (state) {\n            require(\n                msg.sender == owner() || rolesOperator.isAllowedFor(msg.sender, rolesOperator.GUARDIAN_PAUSE()),\n                mTokenGateway_CallerNotAllowed()\n            );\n        } else {\n            require(msg.sender == owner(), mTokenGateway_CallerNotAllowed());\n        }\n\n        emit mTokenGateway_PausedState(_type, state);\n        paused[_type] = state;\n    }\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function extractForRebalancing(uint256 amount) external notPaused(OperationType.Rebalancing) {\n        if (!rolesOperator.isAllowedFor(msg.sender, rolesOperator.REBALANCER())) revert mTokenGateway_NotRebalancer();\n        IERC20(underlying).safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Sets the gas fee\n     * @param amount the new gas fee\n     */\n    function setGasFee(uint256 amount) external onlyOwner {\n        gasFee = amount;\n        emit mTokenGateway_GasFeeUpdated(amount);\n    }\n\n    /**\n     * @notice Withdraw gas received so far\n     * @param receiver the receiver address\n     */\n    function withdrawGasFees(address payable receiver) external {\n        if (msg.sender != owner() && !_isAllowedFor(msg.sender, _getSequencerRole())) {\n            revert mTokenGateway_CallerNotAllowed();\n        }\n        uint256 balance = address(this).balance;\n        receiver.transfer(balance);\n    }\n\n    /**\n     * @notice Updates IZkVerifier address\n     * @param _zkVerifier the verifier address\n     */\n    function updateZkVerifier(address _zkVerifier) external onlyOwner {\n        require(_zkVerifier != address(0), mTokenGateway_AddressNotValid());\n        emit ZkVerifierUpdated(address(verifier), _zkVerifier);\n        verifier = IZkVerifier(_zkVerifier);\n    }\n\n    // ----------- PUBLIC ------------\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function updateAllowedCallerStatus(address caller, bool status) external override {\n        allowedCallers[msg.sender][caller] = status;\n        emit AllowedCallerUpdated(msg.sender, caller, status);\n    }\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function supplyOnHost(uint256 amount, address receiver, bytes4 lineaSelector)\n        external\n        payable\n        override\n        notPaused(OperationType.AmountIn)\n        onlyAllowedUser(msg.sender)\n        ifNotBlacklisted(msg.sender)\n        ifNotBlacklisted(receiver)\n    {\n        // checks\n        require(amount > 0, mTokenGateway_AmountNotValid());\n        require(msg.value >= gasFee, mTokenGateway_NotEnoughGasFee());\n\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n\n        // effects\n        accAmountIn[receiver] += amount;\n\n        emit mTokenGateway_Supplied(\n            msg.sender,\n            receiver,\n            accAmountIn[receiver],\n            accAmountOut[receiver],\n            amount,\n            uint32(block.chainid),\n            LINEA_CHAIN_ID,\n            lineaSelector\n        );\n    }\n\n    /**\n     * @inheritdoc ImTokenGateway\n     */\n    function outHere(bytes calldata journalData, bytes calldata seal, uint256[] calldata amounts, address receiver)\n        external\n        notPaused(OperationType.AmountOutHere)\n        ifNotBlacklisted(msg.sender)\n        ifNotBlacklisted(receiver)\n    {\n        // verify received data\n        if (!rolesOperator.isAllowedFor(msg.sender, rolesOperator.PROOF_BATCH_FORWARDER())) {\n            _verifyProof(journalData, seal);\n        }\n\n        bytes[] memory journals = abi.decode(journalData, (bytes[]));\n        uint256 length = journals.length;\n        require(length == amounts.length, mTokenGateway_LengthNotValid());\n\n        for (uint256 i; i < journals.length;) {\n            _outHere(journals[i], amounts[i], receiver);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _outHere(bytes memory journalData, uint256 amount, address receiver) internal {\n        (address _sender, address _market,, uint256 _accAmountOut, uint32 _chainId, uint32 _dstChainId,) =\n            mTokenProofDecoderLib.decodeJournal(journalData);\n\n        // temporary overwrite; will be removed in future implementations\n        receiver = _sender;\n\n        // checks\n        _checkSender(msg.sender, _sender);\n        require(_market == address(this), mTokenGateway_AddressNotValid());\n        require(_chainId == LINEA_CHAIN_ID, mTokenGateway_ChainNotValid()); // allow only Host\n        require(_dstChainId == uint32(block.chainid), mTokenGateway_ChainNotValid());\n        require(amount > 0, mTokenGateway_AmountNotValid());\n        require(_accAmountOut - accAmountOut[_sender] >= amount, mTokenGateway_AmountTooBig());\n        require(IERC20(underlying).balanceOf(address(this)) >= amount, mTokenGateway_ReleaseCashNotAvailable());\n\n        // effects\n        accAmountOut[_sender] += amount;\n\n        // interactions\n        IERC20(underlying).safeTransfer(_sender, amount);\n\n        emit mTokenGateway_Extracted(\n            msg.sender,\n            _sender,\n            receiver,\n            accAmountIn[_sender],\n            accAmountOut[_sender],\n            amount,\n            uint32(_chainId),\n            uint32(block.chainid)\n        );\n    }\n\n    // ----------- PRIVATE ------------\n    function _verifyProof(bytes calldata journalData, bytes calldata seal) private view {\n        require(journalData.length > 0, mTokenGateway_JournalNotValid());\n\n        // Decode the dynamic array of journals.\n        bytes[] memory journals = abi.decode(journalData, (bytes[]));\n\n        // Check the L1Inclusion flag for each journal.\n        bool isSequencer = _isAllowedFor(msg.sender, _getProofForwarderRole())\n            || _isAllowedFor(msg.sender, _getBatchProofForwarderRole());\n\n        if (!isSequencer) {\n            for (uint256 i = 0; i < journals.length; i++) {\n                (,,,,,, bool L1Inclusion) = mTokenProofDecoderLib.decodeJournal(journals[i]);\n                if (!L1Inclusion) {\n                    revert mTokenGateway_L1InclusionRequired();\n                }\n            }\n        }\n\n        // verify it using the ZkVerifier contract\n        verifier.verifyInput(journalData, seal);\n    }\n\n    function _checkSender(address msgSender, address srcSender) private view {\n        if (msgSender != srcSender) {\n            require(\n                allowedCallers[srcSender][msgSender] || msgSender == owner()\n                    || _isAllowedFor(msgSender, _getProofForwarderRole())\n                    || _isAllowedFor(msgSender, _getBatchProofForwarderRole()),\n                mTokenGateway_CallerNotAllowed()\n            );\n        }\n    }\n\n    function _getSequencerRole() private view returns (bytes32) {\n        return rolesOperator.SEQUENCER();\n    }\n\n    function _getBatchProofForwarderRole() private view returns (bytes32) {\n        return rolesOperator.PROOF_BATCH_FORWARDER();\n    }\n\n    function _getProofForwarderRole() private view returns (bytes32) {\n        return rolesOperator.PROOF_FORWARDER();\n    }\n\n    function _isAllowedFor(address _sender, bytes32 role) private view returns (bool) {\n        return rolesOperator.isAllowedFor(_sender, role);\n    }\n}\n"
    }
}