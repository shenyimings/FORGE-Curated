{
    "vfp_id": "vfp_00177",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Potential Bit Overlap in `toLockTag`",
            "description": "The `toLockTag` function combines a 96-bit allocator ID with scope and reset period bits into a `bytes12` value. However, it does not clear the upper 4 bits of the allocator ID before combining, which could lead to unintended bit overlap if the allocator ID uses more than the expected lower 92 bits. This issue arises because the function assumes the allocator ID is properly masked but does not enforce it. An attacker could potentially manipulate the allocator ID to set bits in the reserved region, leading to incorrect locktag generation. While currently not exploitable due to internal usage constraints, this creates a latent risk if the function is reused in other contexts without proper input sanitization.\n",
            "severity": null,
            "location": [
                "IdLib.sol::toLockTag#220"
            ],
            "files": [
                "the-compact/src/lib/IdLib.sol"
            ]
        }
    ],
    "affected_files": {
        "IdLib.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { Lock } from \"../types/Lock.sol\";\nimport { MetadataLib } from \"./MetadataLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\n\n/**\n * @title IdLib\n * @notice Library contract implementing logic for deriving IDs for allocators and\n * for resource locks, converting between various IDs, and for extracting details\n * related to those IDs. This includes logic for registering allocators and for\n * assigning them an allocator ID.\n */\nlibrary IdLib {\n    using IdLib for bytes12;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using IdLib for ResetPeriod;\n    using MetadataLib for Lock;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint8;\n    using EfficiencyLib for uint96;\n    using EfficiencyLib for bytes12;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for address;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for Scope;\n    using EfficientHashLib for bytes;\n\n    error NoAllocatorRegistered(uint96 allocatorId);\n    error AllocatorAlreadyRegistered(uint96 allocatorId, address allocator);\n\n    // Storage slot seed for mapping allocator IDs to allocator addresses.\n    uint256 private constant _ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED = 0x000044036fc77deaed2300000000000000000000000;\n\n    // keccak256(bytes(\"AllocatorRegistered(uint96,address)\")).\n    uint256 private constant _ALLOCATOR_REGISTERED_EVENT_SIGNATURE =\n        0xc54dcaa67a8fd7b4a9aa6fd57351934c792613d5ec1acbd65274270e6de8f7e4;\n\n    // Error selectors for NoAllocatorRegistered and AllocatorAlreadyRegistered.\n    uint256 private constant _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE = 0xcf90c3a8;\n    uint256 private constant _ALLOCATOR_ALREADY_REGISTERED_ERROR_SIGNATURE = 0xc18b0e97;\n\n    /**\n     * @notice Internal function for registering an allocator. Derives an ID for the\n     * allocator and stores the allocator's address for that ID, reverting if an\n     * allocator has already been registered for the ID in question.\n     * @param allocator The address to register as an allocator.\n     * @return allocatorId The derived ID for the registered allocator.\n     */\n    function register(address allocator) internal returns (uint96 allocatorId) {\n        // Derive the allocator ID for the provided allocator address.\n        allocatorId = allocator.usingAllocatorId();\n\n        assembly (\"memory-safe\") {\n            // Derive storage slot for allocator registration by ID.\n            let allocatorSlot := or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId)\n\n            // Retrieve the allocator value at the derived storage slot.\n            let registeredAllocator := sload(allocatorSlot)\n\n            // Revert if an allocator has already been registered for the ID.\n            if registeredAllocator {\n                mstore(0, _ALLOCATOR_ALREADY_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                mstore(0x40, registeredAllocator)\n                revert(0x1c, 0x44)\n            }\n\n            // Store allocator address (sanitize first as an added precaution).\n            allocator := shr(0x60, shl(0x60, allocator))\n            sstore(allocatorSlot, allocator)\n\n            // Emit AllocatorRegistered(allocatorId, allocator) event.\n            mstore(0x00, allocatorId)\n            mstore(0x20, allocator)\n            log1(0x00, 0x40, _ALLOCATOR_REGISTERED_EVENT_SIGNATURE)\n        }\n    }\n\n    /**\n     * @notice Internal view function for constructing a resource lock ID assuming that the\n     * provided allocator has been registered. Derives the allocator ID from the registered\n     * allocator, and combines it with the provided scope, reset period, and token address\n     * to form a single ID value. Reverts if the allocator is not registered.\n     * @param token   The address of the underlying token.\n     * @param lockTag The lock tag containing allocator ID, reset period, and scope.\n     * @return id     The derived resource lock ID.\n     */\n    function toIdIfRegistered(address token, bytes12 lockTag) internal view returns (uint256 id) {\n        // Derive the allocator ID for the provided allocator address.\n        lockTag.toAllocatorId().mustHaveARegisteredAllocator();\n\n        // Derive resource lock ID (pack scope, reset period, allocator ID, & token).\n        id = lockTag.asUint256() | token.asUint256();\n    }\n\n    /**\n     * @notice Internal view function for retrieving an allocator's address from their ID.\n     * Reverts if no allocator is registered with the provided ID.\n     * @param allocatorId The ID to look up.\n     * @return allocator  The registered allocator's address.\n     */\n    function toRegisteredAllocator(uint96 allocatorId) internal view returns (address allocator) {\n        assembly (\"memory-safe\") {\n            // Retrieve allocator from storage based on allocator ID.\n            allocator := sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))\n\n            // Revert if no registered allocator is located.\n            if iszero(allocator) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that verifies an allocator is registered and\n     * returns their ID. Derives the allocator ID from the address and reverts if the\n     * stored address doesn't exactly match the provided one.\n     * @param allocator    The address to check registration for.\n     * @return allocatorId The derived allocator ID.\n     */\n    function toAllocatorIdIfRegistered(address allocator) internal view returns (uint96 allocatorId) {\n        // Derive the allocator ID for the provided allocator address.\n        allocatorId = allocator.usingAllocatorId();\n\n        assembly (\"memory-safe\") {\n            // Revert on any difference between original address and stored address.\n            if xor(allocator, sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function for extracting and validating an allocator ID from\n     * a resource lock ID. Reverts if the allocator is not registered.\n     * @param id           The resource lock ID to extract from.\n     * @return allocatorId The validated allocator ID.\n     */\n    function toRegisteredAllocatorId(uint256 id) internal view returns (uint96 allocatorId) {\n        allocatorId = id.toAllocatorId();\n        allocatorId.mustHaveARegisteredAllocator();\n    }\n\n    /**\n     * @notice Internal view function that checks if an allocator ID has a registered\n     * allocator. Reverts if no allocator is registered.\n     * @param allocatorId The allocator ID to check.\n     */\n    function mustHaveARegisteredAllocator(uint96 allocatorId) internal view {\n        assembly (\"memory-safe\") {\n            // NOTE: consider an SLOAD bypass for a fully compact allocator\n            if iszero(sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that checks if an allocator can be registered.\n     * Returns true if any of the following are true:\n     *  - The caller is the allocator\n     *  - The allocator address contains code\n     *  - The proof is a valid create2 deployment that derives the allocator address\n     *    (e.g. proof must take the form of 0xff ++ factory ++ salt ++ initcode hash)\n     * @param allocator The address to check.\n     * @param proof     An 85-byte value containing create2 address derivation parameters.\n     * @return          Whether the allocator can be registered.\n     */\n    function canBeRegistered(address allocator, bytes calldata proof) internal view returns (bool) {\n        return (msg.sender == allocator).or(allocator.code.length > 0).or(\n            proof.length == 85 && (proof[0] == 0xff).and(allocator == address(uint160(uint256(proof.hashCalldata()))))\n        );\n    }\n\n    /**\n     * @notice Internal view function for retrieving an allocator's address from a\n     * resource lock ID. Reverts if no allocator has been registered for the ID.\n     * @param id         The resource lock ID to extract the allocator from.\n     * @return allocator The address of the allocator.\n     */\n    function toAllocator(uint256 id) internal view returns (address allocator) {\n        allocator = id.toAllocatorId().toRegisteredAllocator();\n    }\n\n    /**\n     * @notice Internal view function for extracting the full Lock struct from a\n     * resource lock ID.\n     * @param id    The resource lock ID to extract from.\n     * @return lock A Lock struct containing token, allocator, reset period, and scope.\n     */\n    function toLock(uint256 id) internal view returns (Lock memory lock) {\n        lock.token = id.toAddress();\n        lock.allocator = id.toAllocator();\n        lock.resetPeriod = id.toResetPeriod();\n        lock.scope = id.toScope();\n    }\n\n    /**\n     * @notice Internal pure function for building the \"lock tag\" from an\n     * allocatorId, scope, and reset period.\n     * @param allocatorId The allocator ID.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param resetPeriod The duration after which the resource lock can be reset.\n     * @return            The lock tag.\n     */\n    function toLockTag(uint96 allocatorId, Scope scope, ResetPeriod resetPeriod) internal pure returns (bytes12) {\n        // Derive lock tag (pack scope, reset period, & allocator ID).\n        return ((scope.asUint256() << 255) | (resetPeriod.asUint256() << 252) | (allocatorId.asUint256() << 160))\n            .asBytes12();\n    }\n\n    /**\n     * @notice Internal pure function for extracting the \"lock tag\" from an ID.\n     * @param id The resource lock ID.\n     * @return lockTag The lock tag.\n     */\n    function toLockTag(uint256 id) internal pure returns (bytes12 lockTag) {\n        // Extract the lock tag.\n        assembly (\"memory-safe\") {\n            lockTag := shl(160, shr(160, id))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the last 20 bytes of an\n     * underlying uint256 as an address. This represents either the token\n     * address (for a resource lock ID) or the claimant address (for a claimant\n     * value).\n     * @param id The uint256 to extract from.\n     * @return   The address.\n     */\n    function toAddress(uint256 id) internal pure returns (address) {\n        return id.asSanitizedAddress();\n    }\n\n    /**\n     * @notice Internal pure function for creating a new resource lock ID with a\n     * different token address.\n     * @param id         The resource lock ID to modify.\n     * @param token      The new token address.\n     * @return updatedId The modified resource lock ID.\n     */\n    function withReplacedToken(uint256 id, address token) internal pure returns (uint256 updatedId) {\n        assembly (\"memory-safe\") {\n            updatedId := or(shl(160, shr(160, id)), shr(96, shl(96, token)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for creating a new resource lock ID from an\n     * existing id and a lock tag.\n     * @param id         The resource lock ID to modify.\n     * @param lockTag    The new lock tag.\n     * @return updatedId The modified resource lock ID.\n     */\n    function withReplacedLockTag(uint256 id, bytes12 lockTag) internal pure returns (uint256 updatedId) {\n        assembly (\"memory-safe\") {\n            updatedId := or(shl(160, shr(160, lockTag)), shr(96, shl(96, id)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the scope from a resource lock ID.\n     * @param id     The resource lock ID to extract from.\n     * @return scope The scope (uppermost bit).\n     */\n    function toScope(uint256 id) internal pure returns (Scope scope) {\n        assembly (\"memory-safe\") {\n            // extract uppermost bit\n            scope := shr(255, id)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the reset period from a resource\n     * lock ID.\n     * @param id           The resource lock ID to extract from.\n     * @return resetPeriod The reset period (bits 252-254).\n     */\n    function toResetPeriod(uint256 id) internal pure returns (ResetPeriod resetPeriod) {\n        assembly (\"memory-safe\") {\n            // extract 2nd, 3rd & 4th uppermost bits\n            resetPeriod := and(shr(252, id), 7)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the reset period from a resource\n     * lock tag.\n     * @param lockTag      The resource lock tag to extract from.\n     * @return resetPeriod The reset period (bits 252-254).\n     */\n    function toResetPeriod(bytes12 lockTag) internal pure returns (ResetPeriod resetPeriod) {\n        assembly (\"memory-safe\") {\n            // extract 2nd, 3rd & 4th uppermost bits\n            resetPeriod := and(shr(252, lockTag), 7)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the compact flag from a resource\n     * lock ID. The compact flag is a 4-bit component of the allocator ID.\n     * @param id           The resource lock ID to extract from.\n     * @return compactFlag The compact flag (bits 248-251).\n     */\n    function toCompactFlag(uint256 id) internal pure returns (uint8 compactFlag) {\n        assembly (\"memory-safe\") {\n            // extract 5th, 6th, 7th & 8th uppermost bits\n            compactFlag := and(shr(248, id), 15)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the allocator ID from a resource\n     * lock ID. The allocator ID is a 92-bit value, with the first 4 bits representing\n     * the compact flag and the last 88 bits matching the last 88 bits of the underlying\n     * allocator, but is represented by a uint96 as solidity only supports uint values\n     * for multiples of 8 bits.\n     * @param id           The resource lock ID to extract from.\n     * @return allocatorId The allocator ID (bits 160-251).\n     */\n    function toAllocatorId(uint256 id) internal pure returns (uint96 allocatorId) {\n        assembly (\"memory-safe\") {\n            // Extract bits 5-96.\n            allocatorId := shr(164, shl(4, id))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for converting a reset period to its duration in\n     * seconds. There are eight distinct reset periods ranging from one second to\n     * thirty days. Specific periods include some additional padding:\n     *  - One hour is padded by five minutes\n     *  - Seven days is padded by one hour\n     * @dev No bounds check performed; ensure that the enum value is in range.\n     * @param resetPeriod The reset period to convert.\n     * @return duration   The duration in seconds.\n     */\n    function toSeconds(ResetPeriod resetPeriod) internal pure returns (uint256 duration) {\n        assembly (\"memory-safe\") {\n            // Bitpacked durations in 24-bit segments:\n            // 278d00  094890  015180  000f3c  000258  00003c  00000f  000001\n            // 30 days 7 days  1 day   1 hour  10 min  1 min   15 sec  1 sec\n            let bitpacked := 0x278d00094890015180000f3c00025800003c00000f000001\n\n            // Shift right by period * 24 bits & mask the least significant 24 bits.\n            duration := and(shr(mul(resetPeriod, 24), bitpacked), 0xffffff)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for computing an address's compact flag. The flag\n     * is a 4-bit value that represents how \"compact\" the address of an allocator is. A\n     * fully \"compact\" allocator address will have nine leading zero bytes, or eighteen\n     * leading zero nibbles. To be considered even partially compact, the account must\n     * have at least two leading zero bytes, or four leading zero nibbles. The full\n     * scoring formula is therefore:\n     *  - 0-3 leading zero nibbles: 0\n     *  - 4-17 leading zero nibbles: number of leading zeros minus 3\n     *  - 18+ leading zero nibbles: 15\n     * @param allocator    The address to compute the flag for.\n     * @return compactFlag The computed compact flag.\n     */\n    function toCompactFlag(address allocator) internal pure returns (uint8 compactFlag) {\n        assembly (\"memory-safe\") {\n            // Extract the uppermost 72 bits of the address.\n            let x := shr(184, shl(96, allocator))\n\n            // Propagate the highest set bit.\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n            x := or(x, shr(32, x))\n            x := or(x, shr(64, x))\n\n            // Count set bits to derive most significant bit in the last byte.\n            let y := sub(x, and(shr(1, x), 0x5555555555555555))\n            y := add(and(y, 0x3333333333333333), and(shr(2, y), 0x3333333333333333))\n            y := and(add(y, shr(4, y)), 0x0f0f0f0f0f0f0f0f)\n            y := add(y, shr(8, y))\n            y := add(y, shr(16, y))\n            y := add(y, shr(32, y))\n\n            // Look up final value in the sequence.\n            compactFlag := and(shr(and(sub(72, and(y, 127)), not(3)), 0xfedcba9876543210000), 15)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for computing an allocator's ID from their address.\n     * Combines the compact flag (4 bits) with the last 88 bits of the address.\n     * @param allocator    The address to compute the ID for.\n     * @return allocatorId The computed allocator ID.\n     */\n    function usingAllocatorId(address allocator) internal pure returns (uint96 allocatorId) {\n        uint8 compactFlag = allocator.toCompactFlag();\n\n        assembly (\"memory-safe\") {\n            allocatorId := or(shl(88, compactFlag), shr(168, shl(168, allocator)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the allocator ID from a resource\n     * lock tag. The allocator ID is a 92-bit value, with the first 4 bits representing\n     * the compact flag and the last 88 bits matching the last 88 bits of the underlying\n     * allocator, but is represented by a uint96 as solidity only supports uint values\n     * for multiples of 8 bits.\n     * @param lockTag      The resource lock tag to extract from.\n     * @return allocatorId The allocator ID (bits 160-251).\n     */\n    function toAllocatorId(bytes12 lockTag) internal pure returns (uint96 allocatorId) {\n        assembly (\"memory-safe\") {\n            // Extract bits 5-96.\n            allocatorId := shr(164, shl(4, lockTag))\n        }\n    }\n\n    /**\n     * @notice Internal view function for ensuring that the allocator ID from a resource\n     * lock tag is registered to an allocator.\n     * @param lockTag The resource lock tag to check allocator registration for.\n     */\n    function hasRegisteredAllocatorId(bytes12 lockTag) internal view {\n        lockTag.toAllocatorId().mustHaveARegisteredAllocator();\n    }\n\n    /**\n     * @notice Internal pure function for deriving a resource lock ID from a Lock struct.\n     * The ID consists of:\n     *  - Bit 255: scope\n     *  - Bits 252-254: reset period\n     *  - Bits 160-251: allocator ID (first 4 bits are compact flag, next 88 from allocator address)\n     *  - Bits 0-159: token address\n     * @dev Note that this will return an ID even if the allocator is unregistered.\n     * @param lock The Lock struct containing the resource lock's components.\n     * @return id  The derived resource lock ID.\n     */\n    function toId(Lock memory lock) internal pure returns (uint256 id) {\n        id = (\n            (lock.scope.asUint256() << 255) | (lock.resetPeriod.asUint256() << 252)\n                | (lock.allocator.usingAllocatorId().asUint256() << 160) | lock.token.asUint256()\n        );\n    }\n}\n"
    }
}