{
    "vfp_id": "vfp_00037",
    "project_name": "2025.03.14 - Final - Crestal Network Audit Report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ]
            },
            "title": "createCommonProjectIDAndDeploymentRequest() hardcodes request id index to 0, leading to lost requests for users",
            "description": "The `createCommonProjectIDAndDeploymentRequest` function in BlueprintCore.sol hardcodes the index value to 0, which prevents proper handling of multiple deployment requests for the same project ID. This function is called during agent creation to register a deployment request, and the index is meant to prevent overwriting existing requests. However, by fixing the index to 0, any new request with the same project ID will overwrite the previous one. The root cause is the static assignment of index = 0 instead of using a user-specific or incrementing counter. An attacker (or even a legitimate user in a race condition) can create a second agent with the same project ID and base64 proposal but a different server URL, causing the first request to be overwritten. The impact is that the first user loses their request and the associated fees, as only one request can be finalized via `submitProofOfDeployment`, even though both required payment.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol#373"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Signatures missing some parameters being vulnerable to attackers using them coupled with malicious parameters",
            "description": "The `createAgentWithSigWithNFT` and similar signature-based functions do not include critical parameters such as `tokenId`, `privateWorkerAddress`, or `tokenAddress` in the signed message digest. This allows attackers to intercept valid signatures from the ERC-4337 mempool (via Biconomy) and replay them with altered parameters. The root cause is incomplete message hashing in the EIP-712 signature scheme, omitting key fields that affect execution outcome. An attacker can observe a user's signed operation in the public mempool, extract the signature, and submit it with a different `tokenId` (potentially one they don't own), a malicious `privateWorkerAddress`, or a higher-cost `tokenAddress`. This leads to users unintentionally deploying agents with wrong tokens, being censored by malicious workers, or paying excessive fees. The impact includes denial of service, fund loss, and manipulation of deployment routing.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::createAgentWithSigWithNFT",
                "BlueprintCore.sol::createAgentWithTokenWithSig"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Signature Replay attack possible on updateWorkerDeploymentConfigWithSig() in Blueprint core.sol which leads to users lose the funds",
            "description": "The `updateWorkerDeploymentConfigWithSig` function lacks replay protection mechanisms such as nonces or timestamps, allowing valid signatures to be reused indefinitely. This function processes payments via `payWithERC20` based on signed messages, making it dangerous if replayable. The root cause is the absence of a nonce or unique identifier in the signed digest, combined with no on-chain state tracking to prevent reuse. An attacker can capture a successful transaction's signature and repeatedly call `updateWorkerDeploymentConfigWithSig` with the same parameters, triggering multiple fund transfers from the user to the fee collection wallet. Each replay executes the payment logic again, draining the user's approved token balance over time. The impact is complete loss of approved funds, as the system does not support refunds and users cannot recover the repeatedly withdrawn fees.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::updateWorkerDeploymentConfigWithSig#672"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of access control in setWorkerPublicKey() in BlueprintCore.sol which results users to lose funds",
            "description": "The `setWorkerPublicKey` function is public and allows any address to register or update a public key in the workers system without authorization. This enables malicious actors to register fake worker identities and be selected by users for private deployments. The root cause is the missing access control modifier, allowing unrestricted writes to critical mappings like `workersPublicKey` and `workerAddressesMp`. An attacker can call `setWorkerPublicKey` with a fake key, get added to the worker list, and be chosen by a user for a private deployment. The user then encrypts sensitive data with the attacker's public key and pays fees, but the attacker can refuse to deploy, keeping the encrypted data and causing the deployment to fail. The impact includes loss of user funds (paid as fees), exposure of sensitive data, and disruption of the deployment ecosystem.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::setWorkerPublicKey#689"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Worker-Induced Denial-of-Service in Deployment Requests Due to Lack of a Cancellation Mechanism",
            "description": "The contract enforces a single active deployment request per project but provides no way to cancel or reset a request if the assigned worker fails to complete it. Once a worker picks up a request (status becomes Pickup), the project is locked indefinitely if the worker does not submit proof of deployment. The root cause is the absence of a timeout or cancellation function, combined with a design that only allows one request per project. An attacker (or negligent worker) can pick up a request and simply never complete it, blocking all future deployment attempts for that project. The impact is permanent stalling of the project lifecycle, rendering it unusable and causing loss of agent creation fees, as no further progress can be made and no refund mechanism exists.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::deploymentRequest",
                "BlueprintCore.sol::submitDeploymentRequest"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Non whitelisted user can also create agent by calling createAgentWithNFT instead of createAgentWithWhitelistUsers affecting the motive of protocol to only allow whitelisted user to create agent",
            "description": "The protocol intends to restrict agent creation to whitelisted users via the `createAgentWithWhitelistUsers` function, but this control is bypassed by the unrestricted `createAgentWithNFT` function. Any user holding the required NFT can create an agent regardless of whitelist status, undermining the access control model. The root cause is the lack of alignment between the two creation pathsâ€”while one enforces whitelisting, the other does not, creating a privilege escalation vector. An attacker (non-whitelisted user) can simply call `createAgentWithNFT` instead of the whitelisted version, bypassing the access check entirely. The impact is that the protocol's security and governance model is compromised, allowing unauthorized users to create agents and potentially abuse system resources or privileges intended only for approved participants.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::createAgentWithNFT#510",
                "BlueprintCore.sol::createAgentWithWhitelistUsers#521"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        }
    ],
    "affected_files": {
        "BlueprintCore.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {EIP712} from \"./EIP712.sol\";\nimport {Payment} from \"./Payment.sol\";\n\ncontract BlueprintCore is EIP712, Payment {\n    enum Status {\n        Init,\n        Issued,\n        Pickup,\n        Deploying,\n        Deployed,\n        GeneratedProof\n    }\n\n    struct DeploymentStatus {\n        Status status;\n        address deployWorkerAddr;\n    }\n\n    // slither-disable-next-line naming-convention\n    string public VERSION;\n    // This is considered initialized due to BlueprintV1 deployment, however\n    // for future upgrades, it can be seen as \"uninitialized\" but we should\n    // not override it again in upgrades unless absolutely necessary\n    // slither-disable-next-line uninitialized-state,constable-states\n    uint256 public factor;\n    uint256 public totalProposalRequest;\n    uint256 public totalDeploymentRequest;\n\n    mapping(address => bytes32) public latestProposalRequestID;\n    mapping(address => bytes32) public latestDeploymentRequestID;\n    mapping(address => bytes32) public latestProjectID;\n\n    mapping(address => uint256) public solverReputation;\n    mapping(address => uint256) public workerReputation;\n    mapping(bytes32 => DeploymentStatus) public requestDeploymentStatus;\n\n    mapping(bytes32 => string) private deploymentProof;\n    mapping(bytes32 => address) private requestSolver;\n    mapping(bytes32 => address) private requestWorker;\n    // projectIDs is not used anymore after 2.0\n    mapping(bytes32 => address) private projectIDs;\n\n    // keep old variable in order so that it can be compatible with old contract\n\n    // new variable and struct\n    struct Project {\n        bytes32 id;\n        bytes32 requestProposalID;\n        bytes32 requestDeploymentID;\n        address proposedSolverAddr;\n    }\n\n    address public constant dummyAddress = address(0);\n\n    // project map\n    mapping(bytes32 => Project) private projects;\n\n    mapping(bytes32 => bytes32[]) public deploymentIdList;\n\n    // List of worker addresses\n    address[] private workerAddresses;\n    // worker public key\n    mapping(address => bytes) private workersPublicKey;\n\n    // worker address mapping\n    mapping(string => address[]) private workerAddressesMp;\n\n    string private constant WORKER_ADDRESS_KEY = \"worker_address_key\";\n\n    // NFT token id mapping, one NFT token id can only be used once\n    mapping(uint256 => Status) public nftTokenIdMap;\n\n    address public nftContractAddress;\n\n    // whitelist user can create an agent\n    mapping(address => Status) public whitelistUsers;\n\n    // deployment owner\n    mapping(bytes32 => address) private deploymentOwners;\n\n    // payment related variables\n    string public constant PAYMENT_KEY = \"payment_key\";\n\n    string public constant CREATE_AGENT_OP = \"create_agent\";\n    string public constant UPDATE_AGENT_OP = \"update_agent\";\n\n    address public feeCollectionWalletAddress;\n\n    mapping(string => address[]) public paymentAddressesMp;\n\n    mapping(address => bool) public paymentAddressEnableMp;\n\n    mapping(address => mapping(string => uint256)) public paymentOpCostMp;\n\n    mapping(address => mapping(address => uint256)) public userTopUpMp;\n\n    mapping(address => uint256) private userNonceMp;\n\n    // worker management related variables\n    address public workerAdmin;\n    mapping(address => bool) public trustWorkerMp;\n    // deployment request id to project id mapping\n    mapping(bytes32 => bytes32) public requestIDToProjectID;\n\n    event CreateProjectID(bytes32 indexed projectID, address walletAddress);\n    event RequestProposal(\n        bytes32 indexed projectID,\n        address walletAddress,\n        bytes32 indexed requestID,\n        string base64RecParam,\n        string serverURL\n    );\n    event RequestPrivateProposal(\n        bytes32 indexed projectID,\n        address walletAddress,\n        address privateSolverAddress,\n        bytes32 indexed requestID,\n        string base64RecParam,\n        string serverURL\n    );\n    event RequestDeployment(\n        bytes32 indexed projectID,\n        address walletAddress,\n        address solverAddress,\n        bytes32 indexed requestID,\n        string base64Proposal,\n        string serverURL\n    );\n    event RequestPrivateDeployment(\n        bytes32 indexed projectID,\n        address walletAddress,\n        address privateWorkerAddress,\n        address solverAddress,\n        bytes32 indexed requestID,\n        string base64Proposal,\n        string serverURL\n    );\n    event AcceptDeployment(bytes32 indexed projectID, bytes32 indexed requestID, address indexed workerAddress);\n    event GeneratedProofOfDeployment(\n        bytes32 indexed projectID, bytes32 indexed requestID, string base64DeploymentProof\n    );\n\n    event UpdateDeploymentConfig(\n        bytes32 indexed projectID, bytes32 indexed requestID, address workerAddress, string base64Config\n    );\n\n    event CreateAgent(\n        bytes32 indexed projectID, bytes32 indexed requestID, address walletAddress, uint256 nftTokenId, uint256 amount\n    );\n\n    event UserTopUp(\n        address indexed walletAddress, address feeCollectionWalletAddress, address tokenAddress, uint256 amount\n    );\n\n    modifier newProject(bytes32 projectId) {\n        // check project id\n        // slither-disable-next-line incorrect-equality,timestamp\n        require(projects[projectId].id == 0, \"projectId already exists\");\n        _;\n    }\n\n    modifier hasProjectNew(bytes32 projectId) {\n        // only new upgraded (v2) blueprint uses this function\n        // slither-disable-next-line timestamp\n        require(projects[projectId].id != 0, \"projectId does not exist\");\n        _;\n    }\n\n    modifier hasProject(bytes32 projectId) {\n        // projectId backwards compatibility\n        //    projects[projectId].id != 0 --> false --> new project id created by new blueprint not exist\n        //    projectIDs[projectId] != address(0) -- > false -- >. old project id created by old blueprint not exist.\n        //    both 1 and 2 are false, then project id does not exist in old and new blueprint\n        // slither-disable-next-line timestamp\n        require(projects[projectId].id != 0 || projectIDs[projectId] != dummyAddress, \"projectId does not exist\");\n        _;\n    }\n\n    modifier isTrustedWorker() {\n        require(trustWorkerMp[msg.sender], \"Worker is not trusted\");\n        _;\n    }\n\n    function setProjectId(bytes32 projectId, address userAddr) internal newProject(projectId) {\n        require(userAddr != dummyAddress, \"Invalid userAddr\");\n\n        Project memory project =\n            Project({id: projectId, requestProposalID: 0, requestDeploymentID: 0, proposedSolverAddr: dummyAddress});\n        // set project info into mapping\n        projects[projectId] = project;\n\n        // set latest project\n        latestProjectID[userAddr] = projectId;\n\n        emit CreateProjectID(projectId, userAddr);\n    }\n\n    function createProjectID() public returns (bytes32 projectId) {\n        // generate unique project id\n        // FIXME: typically we shouldn't just use block.timestamp, as this prevents multi-project\n        // creation during a single block - which shouldn't be impossible...\n        projectId = keccak256(abi.encodePacked(block.timestamp, msg.sender, block.chainid));\n\n        setProjectId(projectId, msg.sender);\n    }\n\n    function deploymentRequest(\n        address userAddress,\n        bytes32 projectId,\n        address solverAddress,\n        address workerAddress,\n        string memory base64Proposal,\n        string memory serverURL,\n        uint256 index\n    ) internal hasProject(projectId) returns (bytes32 requestID, bytes32 projectDeploymentId) {\n        require(bytes(serverURL).length > 0, \"serverURL is empty\");\n        require(bytes(base64Proposal).length > 0, \"base64Proposal is empty\");\n\n        // generate project used deployment id that linked to many deploymentsID associated with different service id\n        projectDeploymentId =\n            keccak256(abi.encodePacked(block.timestamp, userAddress, base64Proposal, block.chainid, projectId));\n\n        // check projectDeploymentId id is created or not\n        // if it is created, which means project has started deployment process, should lock\n        // slither-disable-next-line incorrect-equality,timestamp\n        require(projects[projectId].requestDeploymentID == 0, \"deployment requestID already exists\");\n\n        // generate unique deployment requestID message hash\n        requestID = keccak256(\n            abi.encodePacked(block.timestamp, userAddress, base64Proposal, block.chainid, projectId, index, serverURL)\n        );\n\n        latestDeploymentRequestID[userAddress] = requestID;\n\n        // workerAddress == address(0): init deployment status, not picked by any worker\n        // workerAddress != address(0):\n        // private deployment request\n        // set pick up deployment status since this is private deployment request,\n        // which can be picked only by designated worker\n        DeploymentStatus memory deploymentStatus = DeploymentStatus({\n            status: (workerAddress == dummyAddress ? Status.Issued : Status.Pickup),\n            deployWorkerAddr: workerAddress\n        });\n\n        requestDeploymentStatus[requestID] = deploymentStatus;\n\n        // update project solver info\n        projects[projectId].proposedSolverAddr = solverAddress;\n    }\n\n    function createCommonDeploymentRequest(\n        address userAddress,\n        bytes32 projectId,\n        address solverAddress,\n        address workerAddress,\n        string memory base64Proposal,\n        string memory serverURL\n    ) internal returns (bytes32 requestID) {\n        require(solverAddress != dummyAddress, \"solverAddress is not valid\");\n\n        bytes32 projectDeploymentId;\n        (requestID, projectDeploymentId) =\n            deploymentRequest(userAddress, projectId, solverAddress, workerAddress, base64Proposal, serverURL, 0);\n        totalDeploymentRequest++;\n\n        // once we got request deploymentID, then we set project requestDeploymentID, which points to a list of deploymentID\n        projects[projectId].requestDeploymentID = projectDeploymentId;\n\n        // push request deploymentID into map, link to a project\n        deploymentIdList[projectDeploymentId].push(requestID);\n\n        if (workerAddress == dummyAddress) {\n            emit RequestDeployment(projectId, userAddress, solverAddress, requestID, base64Proposal, serverURL);\n        } else {\n            emit RequestPrivateDeployment(\n                projectId, userAddress, workerAddress, solverAddress, requestID, base64Proposal, serverURL\n            );\n\n            // emit accept deployment event since this deployment request is accepted by blueprint\n            emit AcceptDeployment(projectId, requestID, workerAddress);\n        }\n    }\n\n    function createCommonProjectIDAndDeploymentRequest(\n        address userAddress,\n        bytes32 projectId,\n        string memory base64Proposal,\n        address workerAddress,\n        string memory serverURL\n    ) internal returns (bytes32 requestID) {\n        // set project id\n        setProjectId(projectId, userAddress);\n\n        // create deployment request without solver recommendation, so leave solver address as dummyAddress\n        // since this is public deployment request leave worker address as dummyAddress\n        bytes32 projectDeploymentId;\n        (requestID, projectDeploymentId) =\n            deploymentRequest(userAddress, projectId, dummyAddress, workerAddress, base64Proposal, serverURL, 0);\n        totalDeploymentRequest++;\n\n        projects[projectId].requestDeploymentID = projectDeploymentId;\n\n        deploymentIdList[projectDeploymentId].push(requestID);\n\n        // add requestID to projectID mapping\n        requestIDToProjectID[requestID] = projectId;\n\n        if (workerAddress == dummyAddress) {\n            emit RequestDeployment(projectId, userAddress, dummyAddress, requestID, base64Proposal, serverURL);\n        } else {\n            emit RequestPrivateDeployment(\n                projectId, userAddress, workerAddress, dummyAddress, requestID, base64Proposal, serverURL\n            );\n            // emit accept deployment event since this deployment request is accepted by blueprint\n            emit AcceptDeployment(projectId, requestID, workerAddress);\n        }\n    }\n\n    function createProjectIDAndDeploymentRequest(\n        bytes32 projectId,\n        string memory base64Proposal,\n        string memory serverURL\n    ) public returns (bytes32 requestID) {\n        requestID =\n            createCommonProjectIDAndDeploymentRequest(msg.sender, projectId, base64Proposal, dummyAddress, serverURL);\n    }\n\n    function createProjectIDAndDeploymentRequestWithSig(\n        bytes32 projectId,\n        string memory base64Proposal,\n        string memory serverURL,\n        bytes memory signature\n    ) public returns (bytes32 requestID) {\n        // get EIP712 hash digest\n        bytes32 digest = getRequestDeploymentDigest(projectId, base64Proposal, serverURL);\n\n        // get signer address\n        address signerAddr = getSignerAddress(digest, signature);\n\n        requestID =\n            createCommonProjectIDAndDeploymentRequest(signerAddr, projectId, base64Proposal, dummyAddress, serverURL);\n    }\n\n    function createProjectIDAndPrivateDeploymentRequest(\n        bytes32 projectId,\n        string memory base64Proposal,\n        address privateWorkerAddress,\n        string memory serverURL\n    ) public returns (bytes32 requestID) {\n        requestID = createCommonProjectIDAndDeploymentRequest(\n            msg.sender, projectId, base64Proposal, privateWorkerAddress, serverURL\n        );\n    }\n\n    function createAgent(\n        address userAddress,\n        bytes32 projectId,\n        string memory base64Proposal,\n        address privateWorkerAddress,\n        string memory serverURL,\n        uint256 tokenId,\n        address tokenAddress\n    ) internal returns (bytes32 requestID) {\n        if (tokenAddress == address(0) && tokenId > 0) {\n            // create agent with nft\n            // check NFT token id is already used or not\n            require(nftTokenIdMap[tokenId] != Status.Pickup, \"NFT token id already used\");\n\n            // check NFT ownership\n            require(checkNFTOwnership(nftContractAddress, tokenId, userAddress), \"NFT token not owned by user\");\n\n            requestID = createCommonProjectIDAndDeploymentRequest(\n                userAddress, projectId, base64Proposal, privateWorkerAddress, serverURL\n            );\n\n            // update NFT token id status\n            nftTokenIdMap[tokenId] = Status.Pickup;\n\n            // set deployment owner\n            deploymentOwners[requestID] = userAddress;\n\n            // emit create agent event\n            emit CreateAgent(projectId, requestID, userAddress, tokenId, 0);\n        } else {\n            // create agent with token\n            // check token address is valid and in paymentOpCostMp\n            require(paymentAddressEnableMp[tokenAddress], \"Token address is invalid\");\n            // get cost of create agent operation\n            uint256 cost = paymentOpCostMp[tokenAddress][CREATE_AGENT_OP];\n\n            requestID = createCommonProjectIDAndDeploymentRequest(\n                userAddress, projectId, base64Proposal, privateWorkerAddress, serverURL\n            );\n\n            // set deployment owner\n            deploymentOwners[requestID] = userAddress;\n\n            // CEI pattern : Handle token transfers after updating the all of the above functions state.\n            if (cost > 0) {\n                if (tokenAddress == address(0)) {\n                    require(msg.value == cost, \"Native token amount mismatch\");\n                    // payment to fee collection wallet address with ether\n                    payWithNativeToken(payable(feeCollectionWalletAddress), cost);\n                } else {\n                    // payment to feeCollectionWalletAddress with token\n                    payWithERC20(tokenAddress, cost, userAddress, feeCollectionWalletAddress);\n                }\n            }\n\n            // emit create agent event\n            emit CreateAgent(projectId, requestID, userAddress, tokenId, cost);\n        }\n    }\n\n    function createAgentWithToken(\n        bytes32 projectId,\n        string memory base64Proposal,\n        address privateWorkerAddress,\n        string memory serverURL,\n        address tokenAddress\n    ) public payable returns (bytes32 requestID) {\n        requestID = createAgent(msg.sender, projectId, base64Proposal, privateWorkerAddress, serverURL, 0, tokenAddress);\n    }\n\n    function createAgentWithTokenWithSig(\n        bytes32 projectId,\n        string memory base64Proposal,\n        address privateWorkerAddress,\n        string memory serverURL,\n        address tokenAddress,\n        bytes memory signature\n    ) public payable returns (bytes32 requestID) {\n        // get EIP712 hash digest\n        bytes32 digest =\n            getCreateAgentWithTokenDigest(projectId, base64Proposal, serverURL, privateWorkerAddress, tokenAddress);\n\n        // get signer address\n        address signerAddr = getSignerAddress(digest, signature);\n\n        requestID = createAgent(signerAddr, projectId, base64Proposal, privateWorkerAddress, serverURL, 0, tokenAddress);\n    }\n\n    function createAgentWithNFT(\n        bytes32 projectId,\n        string memory base64Proposal,\n        address privateWorkerAddress,\n        string memory serverURL,\n        uint256 tokenId\n    ) public returns (bytes32 requestID) {\n        requestID =\n            createAgent(msg.sender, projectId, base64Proposal, privateWorkerAddress, serverURL, tokenId, address(0));\n    }\n\n    function createAgentWithSigWithNFT(\n        bytes32 projectId,\n        string memory base64Proposal,\n        address privateWorkerAddress,\n        string memory serverURL,\n        bytes memory signature,\n        uint256 tokenId\n    ) public returns (bytes32 requestID) {\n        // get EIP712 hash digest\n        bytes32 digest =\n            getCreateAgentWithNFTDigest(projectId, base64Proposal, serverURL, privateWorkerAddress, tokenId);\n\n        // get signer address\n        address signerAddr = getSignerAddress(digest, signature);\n\n        requestID =\n            createAgent(signerAddr, projectId, base64Proposal, privateWorkerAddress, serverURL, tokenId, address(0));\n    }\n\n    function resetDeployment(\n        address userAddress,\n        bytes32 projectId,\n        bytes32 requestID,\n        address workerAddress,\n        string memory base64Proposal,\n        string memory serverURL\n    ) internal hasProject(projectId) {\n        require(requestDeploymentStatus[requestID].status != Status.Init, \"requestID does not exist\");\n\n        // generate_proof status is not allowed to reset\n        require(\n            requestDeploymentStatus[requestID].status != Status.GeneratedProof, \"requestID has already submitted proof\"\n        );\n\n        // check if it owner of requestID\n        require(deploymentOwners[requestID] == userAddress, \"Only deployment owner can update config\");\n\n        DeploymentStatus memory deploymentStatus = DeploymentStatus({\n            status: (workerAddress == dummyAddress ? Status.Issued : Status.Pickup),\n            deployWorkerAddr: workerAddress\n        });\n\n        requestDeploymentStatus[requestID] = deploymentStatus;\n\n        // public deployment request\n        if (workerAddress == dummyAddress) {\n            // reset deployment status\n            requestDeploymentStatus[requestID].status = Status.Issued;\n            emit RequestDeployment(projectId, userAddress, dummyAddress, requestID, base64Proposal, serverURL);\n        } else {\n            // reset deployment status\n            requestDeploymentStatus[requestID].status = Status.Pickup;\n            // private deployment request\n            emit RequestPrivateDeployment(\n                projectId, userAddress, workerAddress, dummyAddress, requestID, base64Proposal, serverURL\n            );\n            // emit accept deployment event since this deployment request is accepted by blueprint\n            emit AcceptDeployment(projectId, requestID, workerAddress);\n        }\n    }\n\n    function resetDeploymentRequest(\n        bytes32 projectId,\n        bytes32 requestID,\n        address workerAddress,\n        string memory base64Proposal,\n        string memory serverURL\n    ) public {\n        resetDeployment(msg.sender, projectId, requestID, workerAddress, base64Proposal, serverURL);\n    }\n\n    function resetDeploymentRequestWithSig(\n        bytes32 projectId,\n        bytes32 requestID,\n        address workerAddress,\n        string memory base64Proposal,\n        string memory serverURL,\n        bytes memory signature\n    ) public {\n        address owner = deploymentOwners[requestID];\n        require(owner != address(0), \"Invalid requestID\");\n\n        // get EIP712 hash digest\n        bytes32 digest =\n            getRequestResetDeploymentDigest(projectId, requestID, workerAddress, base64Proposal, userNonceMp[owner]);\n\n        // get signer address\n        address signerAddr = getSignerAddress(digest, signature);\n\n        // check if signer address is owner of requestID\n        require(signerAddr == owner, \"Invalid signature\");\n\n        resetDeployment(signerAddr, projectId, requestID, workerAddress, base64Proposal, serverURL);\n\n        // increase nonce\n        userNonceMp[owner]++;\n    }\n\n    function checkProjectIDAndRequestID(bytes32 projectId, bytes32 requestID) internal returns (bool) {\n        // requestIDToProjectID is newly added mapping so we need to rebuild this mapping for old project id\n        // check new project id and request id binding\n        if (requestIDToProjectID[requestID] != projectId) {\n            // check old project id and request id binding\n            (,, bytes32[] memory deploymentIds) = getProjectInfo(projectId);\n            for (uint256 i = 0; i < deploymentIds.length; i++) {\n                if (deploymentIds[i] == requestID) {\n                    // build project id to request id mapping for old project id\n                    requestIDToProjectID[requestID] = projectId;\n                    return true;\n                }\n            }\n        } else {\n            return true;\n        }\n\n        return false;\n    }\n\n    function submitProofOfDeployment(bytes32 projectId, bytes32 requestID, string memory proofBase64)\n        public\n        hasProject(projectId)\n        isTrustedWorker\n    {\n        require(requestDeploymentStatus[requestID].status != Status.Init, \"requestID does not exist\");\n        require(requestDeploymentStatus[requestID].deployWorkerAddr == msg.sender, \"Wrong worker address\");\n        require(requestDeploymentStatus[requestID].status != Status.GeneratedProof, \"Already submitted proof\");\n\n        require(checkProjectIDAndRequestID(projectId, requestID), \"ProjectID and requestID mismatch\");\n\n        // set deployment status into generatedProof\n        requestDeploymentStatus[requestID].status = Status.GeneratedProof;\n\n        // save deployment proof to mapping\n        deploymentProof[requestID] = proofBase64;\n\n        emit GeneratedProofOfDeployment(projectId, requestID, proofBase64);\n    }\n\n    function submitDeploymentRequest(bytes32 projectId, bytes32 requestID)\n        public\n        hasProject(projectId)\n        isTrustedWorker\n        returns (bool isAccepted)\n    {\n        require(requestDeploymentStatus[requestID].status != Status.Init, \"requestID does not exist\");\n        require(\n            requestDeploymentStatus[requestID].status != Status.Pickup,\n            \"requestID already picked by another worker, try a different requestID\"\n        );\n\n        require(\n            requestDeploymentStatus[requestID].status != Status.GeneratedProof, \"requestID has already submitted proof\"\n        );\n\n        require(checkProjectIDAndRequestID(projectId, requestID), \"ProjectID and requestID mismatch\");\n\n        // currently, do first come, first server, will do a better way in the future\n        requestDeploymentStatus[requestID].status = Status.Pickup;\n        requestDeploymentStatus[requestID].deployWorkerAddr = msg.sender;\n\n        // set project deployed worker address\n        isAccepted = true;\n\n        emit AcceptDeployment(projectId, requestID, requestDeploymentStatus[requestID].deployWorkerAddr);\n    }\n\n    function updateWorkerDeploymentConfigCommon(\n        address tokenAddress,\n        address userAddress,\n        bytes32 projectId,\n        bytes32 requestID,\n        string memory updatedBase64Config\n    ) internal hasProject(projectId) {\n        require(requestDeploymentStatus[requestID].status != Status.Init, \"requestID does not exist\");\n        require(bytes(updatedBase64Config).length > 0, \"updatedBase64Config is empty\");\n        require(requestDeploymentStatus[requestID].status != Status.Issued, \"requestID is not picked up by any worker\");\n\n        // check if it owner of requestID\n        require(deploymentOwners[requestID] == userAddress, \"Only deployment owner can update config\");\n\n        // check tokenAddress is valid and must be in paymentOpCostMp\n        require(paymentAddressEnableMp[tokenAddress], \"Invalid token address\");\n\n        // reset status if it is generated proof\n        if (requestDeploymentStatus[requestID].status == Status.GeneratedProof) {\n            requestDeploymentStatus[requestID].status = Status.Pickup;\n        }\n\n        // CEI pattern : Handle token transfers after updating the all of the above functions state.\n        // get update agent cost\n        uint256 cost = paymentOpCostMp[tokenAddress][UPDATE_AGENT_OP];\n\n        if (cost > 0) {\n            if (tokenAddress == address(0)) {\n                require(msg.value == cost, \"Native token amount mismatch\");\n                // payment to fee collection wallet address with ether\n                payWithNativeToken(payable(feeCollectionWalletAddress), cost);\n            } else {\n                // payment to feeCollectionWalletAddress with token\n                payWithERC20(tokenAddress, cost, userAddress, feeCollectionWalletAddress);\n            }\n        }\n\n        emit UpdateDeploymentConfig(\n            projectId, requestID, requestDeploymentStatus[requestID].deployWorkerAddr, updatedBase64Config\n        );\n    }\n\n    function updateWorkerDeploymentConfig(\n        address tokenAddress,\n        bytes32 projectId,\n        bytes32 requestID,\n        string memory updatedBase64Config\n    ) public payable {\n        updateWorkerDeploymentConfigCommon(tokenAddress, msg.sender, projectId, requestID, updatedBase64Config);\n    }\n\n    function updateWorkerDeploymentConfigWithSig(\n        address tokenAddress,\n        bytes32 projectId,\n        bytes32 requestID,\n        string memory updatedBase64Config,\n        bytes memory signature\n    ) public payable {\n        address owner = deploymentOwners[requestID];\n        require(owner != address(0), \"Invalid requestID\");\n\n        // get EIP712 hash digest\n        bytes32 digest =\n            getUpdateWorkerConfigDigest(tokenAddress, projectId, requestID, updatedBase64Config, userNonceMp[owner]);\n\n        // get signer address\n        address signerAddr = getSignerAddress(digest, signature);\n\n        // check if signer address is owner of requestID\n        require(signerAddr == owner, \"Invalid signature\");\n\n        updateWorkerDeploymentConfigCommon(tokenAddress, signerAddr, projectId, requestID, updatedBase64Config);\n\n        userNonceMp[owner]++;\n    }\n\n    // set worker public key\n    function setWorkerPublicKey(bytes calldata publicKey) public isTrustedWorker {\n        require(publicKey.length > 0, \"Public key cannot be empty\");\n\n        // not set length check like 64 or 33 or others\n        // will introduce some admin function to control workers\n        if (workersPublicKey[msg.sender].length == 0) {\n            workerAddressesMp[WORKER_ADDRESS_KEY].push(msg.sender);\n        }\n\n        workersPublicKey[msg.sender] = publicKey;\n    }\n\n    // get worker public key\n    function getWorkerPublicKey(address workerAddress) external view returns (bytes memory publicKey) {\n        publicKey = workersPublicKey[workerAddress];\n    }\n\n    // get list of worker addresses\n    function getWorkerAddresses() public view returns (address[] memory) {\n        return workerAddressesMp[WORKER_ADDRESS_KEY];\n    }\n\n    // reset previous unclean workers\n    function resetWorkerAddresses() internal {\n        address[] memory addrs = getWorkerAddresses();\n        for (uint256 i = 0; i < addrs.length; i++) {\n            delete workersPublicKey[addrs[i]];\n        }\n        delete workerAddressesMp[WORKER_ADDRESS_KEY];\n    }\n\n    // get list of payment addresses\n    function getPaymentAddresses() public view returns (address[] memory) {\n        return paymentAddressesMp[PAYMENT_KEY];\n    }\n\n    // get latest proposal request id\n    function getLatestProposalRequestID(address addr) public view returns (bytes32) {\n        return latestProposalRequestID[addr];\n    }\n\n    // get latest deployment request id\n    function getLatestDeploymentRequestID(address addr) public view returns (bytes32) {\n        return latestDeploymentRequestID[addr];\n    }\n\n    // get latest project id of user\n    function getLatestUserProjectID(address addr) public view returns (bytes32) {\n        return latestProjectID[addr];\n    }\n\n    // get project info\n    function getProjectInfo(bytes32 projectId)\n        public\n        view\n        hasProjectNew(projectId)\n        returns (address, bytes32, bytes32[] memory)\n    {\n        bytes32[] memory requestDeploymentIDs = deploymentIdList[projects[projectId].requestDeploymentID];\n\n        return (projects[projectId].proposedSolverAddr, projects[projectId].requestProposalID, requestDeploymentIDs);\n    }\n\n    function getDeploymentProof(bytes32 requestID) public view returns (string memory) {\n        return deploymentProof[requestID];\n    }\n\n    function getEIP712ContractAddress() public view returns (address) {\n        return getAddress();\n    }\n\n    function isWhitelistUser(address userAddress) public view returns (bool) {\n        return whitelistUsers[userAddress] == Status.Issued || whitelistUsers[userAddress] == Status.Pickup;\n    }\n\n    function userTopUp(address tokenAddress, uint256 amount) public payable {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        require(paymentAddressEnableMp[tokenAddress], \"Payment address is not valid\");\n\n        // update user top up\n        userTopUpMp[msg.sender][tokenAddress] += amount;\n\n        if (tokenAddress == address(0)) {\n            require(msg.value == amount, \"Native token amount mismatch\");\n\n            // payment to fee collection wallet address with ether\n            payWithNativeToken(payable(feeCollectionWalletAddress), amount);\n        } else {\n            // payment to feeCollectionWalletAddress with token\n            payWithERC20(tokenAddress, amount, msg.sender, feeCollectionWalletAddress);\n        }\n\n        emit UserTopUp(msg.sender, feeCollectionWalletAddress, tokenAddress, amount);\n    }\n\n    // it is ok to expose public function to get user nonce\n    // since the signature with nonce is only used for one time\n    // reason make userAddress as param is that gasless flow, user can get nonce with other wallet address, not need msg.sender\n\n    function getUserNonce(address userAddress) public view returns (uint256) {\n        return userNonceMp[userAddress];\n    }\n\n    // get latest deployment status\n    function getDeploymentStatus(bytes32 requestID) public view returns (Status, address) {\n        return (requestDeploymentStatus[requestID].status, requestDeploymentStatus[requestID].deployWorkerAddr);\n    }\n}\n"
    }
}