{
    "vfp_id": "vfp_00159",
    "project_name": "ChainSecurity_Gearbox_MigrationBot_Audit.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Usage of ptOverride",
            "description": "1. **Description:** The ptOverride mapping was required to be populated for all phantom tokens, but this led to a potential failure in validation when comparing uniqueTransferred tokens and migratedCollateral.underlying, especially when ptOverride was not set but the underlying value was zero. This could disrupt the migration process for certain token configurations.\n2. **Cause:** The _validateParameters function incorrectly assumed ptOverride must be set for all phantom tokens and enforced a comparison without checking whether an override existed, leading to unnecessary reverts.\n3. **Exploitation:** An attacker or user attempting to migrate a credit account with a phantom token lacking a ptOverride entry could trigger a revert during validation, preventing a legitimate migration.\n4. **Impact:** The impact was limited to disruption of the migration functionality for specific token configurations, potentially blocking legitimate user operations. However, no fund loss or critical system failure was possible.\n",
            "severity": "Low",
            "location": [
                "AccountMigratorBot.sol::_validateParameters"
            ],
            "files": [
                "periphery-v3/contracts/migration/AccountMigratorBot.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Missing Lock Check",
            "description": "1. **Description:** The AccountMigratorBot uses a lock mechanism to prevent reentrancy or unexpected state changes during migration. However, the lock was being set to true without first verifying that it was currently unlocked, which could lead to incorrect state transitions in edge cases.\n2. **Cause:** The implementation lacked a precondition check before modifying the lock state, violating secure coding practices for mutex-like mechanisms.\n3. **Exploitation:** In an unexpected execution trace (e.g., due to external reentrancy or low-level call manipulation), an attacker might force the lock to be set while already locked, potentially disrupting the expected control flow and leading to inconsistent state.\n4. **Impact:** The impact was low, as the core functionality remained intact and no direct fund loss was possible. However, it could lead to denial of service for migration operations under rare conditions.\n",
            "severity": "Informational",
            "location": [
                "AccountMigratorBot.sol"
            ],
            "files": [
                "periphery-v3/contracts/migration/AccountMigratorBot.sol"
            ]
        }
    ],
    "affected_files": {
        "AccountMigratorBot.sol": "// SPDX-License-Identifier: UNLICENSED\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2025.\npragma solidity ^0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {IAccountMigratorBot, IAccountMigratorAdapter} from \"../interfaces/IAccountMigratorBot.sol\";\nimport {\n    MigrationParams,\n    PreviewMigrationResult,\n    MigratedCollateral,\n    PhantomTokenParams,\n    PhantomTokenOverride\n} from \"../types/AccountMigrationTypes.sol\";\nimport {\n    INACTIVE_CREDIT_ACCOUNT_ADDRESS,\n    UNDERLYING_TOKEN_MASK,\n    WAD,\n    PERCENTAGE_FACTOR\n} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\nimport {ICreditAccountV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditAccountV3.sol\";\nimport {ICreditFacadeV3, MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {\n    ICreditManagerV3,\n    CollateralDebtData,\n    CollateralCalcTask\n} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {\n    ICreditFacadeV3Multicall,\n    EXTERNAL_CALLS_PERMISSION,\n    UPDATE_QUOTA_PERMISSION,\n    DECREASE_DEBT_PERMISSION,\n    INCREASE_DEBT_PERMISSION,\n    WITHDRAW_COLLATERAL_PERMISSION\n} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3Multicall.sol\";\nimport {OptionalCall} from \"@gearbox-protocol/core-v3/contracts/libraries/OptionalCall.sol\";\nimport {\n    IPhantomToken, IPhantomTokenAdapter\n} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IPhantomToken.sol\";\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\nimport {IPoolQuotaKeeperV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolQuotaKeeperV3.sol\";\nimport {IInterestRateModel} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IInterestRateModel.sol\";\nimport {IPoolV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol\";\nimport {IPriceFeedStore} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IPriceFeedStore.sol\";\nimport {IPriceOracleV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPriceOracleV3.sol\";\nimport {ACLTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ACLTrait.sol\";\nimport {IMarketConfigurator} from \"@gearbox-protocol/permissionless/contracts/interfaces/IMarketConfigurator.sol\";\nimport {IMarketConfiguratorFactory} from\n    \"@gearbox-protocol/permissionless/contracts/interfaces/IMarketConfiguratorFactory.sol\";\nimport {IContractsRegister} from \"@gearbox-protocol/permissionless/contracts/interfaces/IContractsRegister.sol\";\nimport {BitMask} from \"@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol\";\nimport {CreditLogic} from \"@gearbox-protocol/core-v3/contracts/libraries/CreditLogic.sol\";\nimport {PriceUpdate} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IPriceFeedStore.sol\";\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\n\ncontract AccountMigratorBot is Ownable, ReentrancyGuardTrait, IAccountMigratorBot {\n    using SafeERC20 for IERC20;\n    using BitMask for uint256;\n    using CreditLogic for CollateralDebtData;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant override version = 3_10;\n    bytes32 public constant override contractType = \"BOT::ACCOUNT_MIGRATOR\";\n\n    uint192 public constant override requiredPermissions =\n        EXTERNAL_CALLS_PERMISSION | UPDATE_QUOTA_PERMISSION | DECREASE_DEBT_PERMISSION;\n\n    address internal activeCreditAccount = INACTIVE_CREDIT_ACCOUNT_ADDRESS;\n\n    mapping(address => PhantomTokenOverride) internal _phantomTokenOverrides;\n\n    EnumerableSet.AddressSet internal _overridenPhantomTokens;\n\n    address public immutable mcFactory;\n\n    address public immutable contractsRegisterOld;\n\n    constructor(address _mcFactory, address _ioProxy, address _contractsRegisterOld) {\n        _transferOwnership(_ioProxy);\n        mcFactory = _mcFactory;\n        contractsRegisterOld = _contractsRegisterOld;\n    }\n\n    /// EXECUTION LOGIC\n\n    /// @notice Migrates a credit account from one credit manager to another.\n    /// @param params The migration parameters.\n    /// @param priceUpdates The price updates to apply.\n    function migrateCreditAccount(MigrationParams memory params, PriceUpdate[] memory priceUpdates)\n        external\n        nonReentrant\n    {\n        address sourceCreditManager = ICreditAccountV3(params.sourceCreditAccount).creditManager();\n\n        _validateParameters(sourceCreditManager, params);\n\n        _applyPriceUpdates(params.targetCreditManager, priceUpdates);\n        _checkAccountOwner(sourceCreditManager, params);\n\n        address creditFacade = ICreditManagerV3(sourceCreditManager).creditFacade();\n        address adapter = ICreditManagerV3(sourceCreditManager).contractToAdapter(address(this));\n\n        MultiCall[] memory calls = _getClosingMultiCalls(creditFacade, adapter, params);\n\n        _unlockAdapter(params.sourceCreditAccount, adapter);\n        ICreditFacadeV3(creditFacade).botMulticall(params.sourceCreditAccount, calls);\n        _lockAdapter(adapter);\n    }\n\n    /// @notice Transfer the collaterals from the previous credit account and opens a new credit account with required calls.\n    ///         Can only be used when the adapter is unlocked and by the active credit account.\n    function migrate(MigrationParams memory params) external {\n        if (msg.sender != activeCreditAccount) {\n            revert(\"MigratorBot: caller is not the active credit account\");\n        }\n\n        uint256[] memory balances = _transferCollaterals(params);\n\n        address targetCreditFacade = ICreditManagerV3(params.targetCreditManager).creditFacade();\n\n        MultiCall[] memory calls = _getOpeningMultiCalls(targetCreditFacade, params, balances);\n\n        ICreditFacadeV3(targetCreditFacade).openCreditAccount(params.accountOwner, calls, 0);\n    }\n\n    /// @dev Transfers the collaterals from the previous credit account and returns the unique tokens and the transferred balances.\n    function _transferCollaterals(MigrationParams memory params) internal returns (uint256[] memory) {\n        uint256[] memory minimalAmounts = _getMinimalAssetAmounts(params);\n\n        uint256 len = params.uniqueTransferredTokens.length;\n\n        uint256[] memory balances = new uint256[](len);\n\n        for (uint256 i = 0; i < len; i++) {\n            address token = params.uniqueTransferredTokens[i];\n\n            balances[i] = IERC20(token).balanceOf(msg.sender);\n\n            if (balances[i] < minimalAmounts[i]) {\n                revert(\"MigratorBot: insufficient token balance to cover expected amount\");\n            }\n\n            IERC20(token).safeTransferFrom(msg.sender, address(this), balances[i]);\n            IERC20(token).forceApprove(params.targetCreditManager, balances[i]);\n        }\n\n        return balances;\n    }\n\n    /// @dev Gets the aggregated amounts for each transferred collateral or PT underlying.\n    function _getMinimalAssetAmounts(MigrationParams memory params) internal pure returns (uint256[] memory) {\n        uint256[] memory totalAmounts = new uint256[](params.uniqueTransferredTokens.length);\n\n        uint256 len = params.migratedCollaterals.length;\n\n        for (uint256 i = 0; i < len; i++) {\n            address token = params.migratedCollaterals[i].phantomTokenParams.isPhantomToken\n                ? params.migratedCollaterals[i].phantomTokenParams.underlying\n                : params.migratedCollaterals[i].collateral;\n\n            uint256 amount = params.migratedCollaterals[i].phantomTokenParams.isPhantomToken\n                ? params.migratedCollaterals[i].phantomTokenParams.underlyingAmount\n                : params.migratedCollaterals[i].amount;\n\n            uint256 index = _indexOf(params.uniqueTransferredTokens, token);\n            totalAmounts[index] += amount;\n        }\n\n        return totalAmounts;\n    }\n\n    /// @dev Gets the index of an item in an array.\n    function _indexOf(address[] memory array, address item) internal pure returns (uint256) {\n        uint256 len = array.length;\n\n        for (uint256 i = 0; i < len; i++) {\n            if (array[i] == item) return i;\n        }\n\n        revert(\"MigratorBot: item not found in array\");\n    }\n\n    /// @dev Checks whether the caller is the owner of the source credit account.\n    function _checkAccountOwner(address sourceCreditManager, MigrationParams memory params) internal view {\n        address sourceAccountOwner =\n            ICreditManagerV3(sourceCreditManager).getBorrowerOrRevert(params.sourceCreditAccount);\n\n        if (msg.sender != sourceAccountOwner || msg.sender != params.accountOwner) {\n            revert(\"MigratorBot: caller is not the account owner\");\n        }\n    }\n\n    /// @dev Builds a MultiCall array to close the source credit account.\n    function _getClosingMultiCalls(address creditFacade, address adapter, MigrationParams memory params)\n        internal\n        view\n        returns (MultiCall[] memory calls)\n    {\n        uint256 collateralsLength = params.migratedCollaterals.length;\n\n        calls = new MultiCall[](\n            params.numRemoveQuotasCalls + params.numPhantomTokenCalls + (params.targetBorrowAmount > 0 ? 1 : 0) + 1\n        );\n\n        uint256 k = 0;\n\n        address sourceCreditManager = ICreditAccountV3(params.sourceCreditAccount).creditManager();\n\n        for (uint256 i = 0; i < collateralsLength; i++) {\n            if (\n                params.migratedCollaterals[i].phantomTokenParams.isPhantomToken\n                    && params.migratedCollaterals[i].amount > 1\n            ) {\n                calls[k++] = _getPhantomTokenWithdrawalCall(\n                    sourceCreditManager, params.migratedCollaterals[i].collateral, params.migratedCollaterals[i].amount\n                );\n            }\n        }\n\n        calls[k++] = MultiCall({target: adapter, callData: abi.encodeCall(IAccountMigratorAdapter.migrate, (params))});\n\n        for (uint256 i = 0; i < collateralsLength; i++) {\n            if (!params.migratedCollaterals[i].underlyingInSource) {\n                calls[k++] = MultiCall({\n                    target: creditFacade,\n                    callData: abi.encodeCall(\n                        ICreditFacadeV3Multicall.updateQuota, (params.migratedCollaterals[i].collateral, type(int96).min, 0)\n                    )\n                });\n            }\n        }\n\n        if (params.targetBorrowAmount > 0) {\n            calls[k] = MultiCall({\n                target: creditFacade,\n                callData: abi.encodeCall(ICreditFacadeV3Multicall.decreaseDebt, (type(uint256).max))\n            });\n        }\n\n        return calls;\n    }\n\n    /// @dev Builds a MultiCall array to open the target credit account.\n    function _getOpeningMultiCalls(address creditFacade, MigrationParams memory params, uint256[] memory balances)\n        internal\n        view\n        returns (MultiCall[] memory calls)\n    {\n        calls = new MultiCall[](\n            params.numAddCollateralCalls + params.numIncreaseQuotaCalls + params.numPhantomTokenCalls\n                + params.underlyingSwapCalls.length + params.extraOpeningCalls.length\n                + (params.targetBorrowAmount > 0 ? 2 : 0)\n        );\n\n        uint256 uniqueTokensLength = params.uniqueTransferredTokens.length;\n\n        uint256 k = 0;\n\n        for (uint256 i = 0; i < uniqueTokensLength; i++) {\n            address token = params.uniqueTransferredTokens[i];\n\n            if (balances[i] > 1) {\n                calls[k++] = MultiCall({\n                    target: creditFacade,\n                    callData: abi.encodeCall(ICreditFacadeV3Multicall.addCollateral, (token, balances[i]))\n                });\n            }\n        }\n\n        uint256 collateralsLength = params.migratedCollaterals.length;\n\n        for (uint256 i = 0; i < collateralsLength; i++) {\n            if (\n                params.migratedCollaterals[i].phantomTokenParams.isPhantomToken\n                    && params.migratedCollaterals[i].amount > 1\n            ) {\n                calls[k++] = _getPhantomTokenDepositCall(\n                    params.targetCreditManager,\n                    params.migratedCollaterals[i].collateral,\n                    params.migratedCollaterals[i].amount\n                );\n            }\n        }\n\n        if (params.targetBorrowAmount > 0) {\n            calls[k++] = MultiCall({\n                target: creditFacade,\n                callData: abi.encodeCall(ICreditFacadeV3Multicall.increaseDebt, (params.targetBorrowAmount))\n            });\n        }\n\n        for (uint256 i = 0; i < collateralsLength; i++) {\n            if (params.migratedCollaterals[i].targetQuotaIncrease > 0) {\n                calls[k++] = MultiCall({\n                    target: creditFacade,\n                    callData: abi.encodeCall(\n                        ICreditFacadeV3Multicall.updateQuota,\n                        (\n                            _getCollateralOrOverride(params.migratedCollaterals[i].collateral),\n                            int96(params.migratedCollaterals[i].targetQuotaIncrease),\n                            params.migratedCollaterals[i].targetQuotaIncrease\n                        )\n                    )\n                });\n            }\n        }\n\n        uint256 underlyingSwapCallsLength = params.underlyingSwapCalls.length;\n\n        for (uint256 i = 0; i < underlyingSwapCallsLength; i++) {\n            calls[k++] = params.underlyingSwapCalls[i];\n        }\n\n        if (params.targetBorrowAmount > 0) {\n            calls[k++] = _getUnderlyingWithdrawCall(creditFacade, params);\n        }\n\n        uint256 extraOpeningCallsLength = params.extraOpeningCalls.length;\n\n        for (uint256 i = 0; i < extraOpeningCallsLength; i++) {\n            calls[k++] = params.extraOpeningCalls[i];\n        }\n    }\n\n    /// @dev Builds a call to withdraw an amount of underlying equal to the source account's debt.\n    function _getUnderlyingWithdrawCall(address creditFacade, MigrationParams memory params)\n        internal\n        view\n        returns (MultiCall memory call)\n    {\n        address underlying = ICreditManagerV3(ICreditAccountV3(params.sourceCreditAccount).creditManager()).underlying();\n        uint256 totalDebt = _getAccountTotalDebt(params.sourceCreditAccount);\n\n        return MultiCall({\n            target: creditFacade,\n            callData: abi.encodeCall(\n                ICreditFacadeV3Multicall.withdrawCollateral, (underlying, totalDebt, params.sourceCreditAccount)\n            )\n        });\n    }\n\n    /// @dev Builds a call to deposit a phantom token.\n    function _getPhantomTokenDepositCall(address creditManager, address collateral, uint256 amount)\n        internal\n        view\n        returns (MultiCall memory call)\n    {\n        PhantomTokenOverride memory ptOverride = _phantomTokenOverrides[collateral];\n\n        if (ptOverride.newToken != address(0)) {\n            (address target,) = _getPhantomTokenInfo(ptOverride.newToken);\n\n            address adapter = ICreditManagerV3(creditManager).contractToAdapter(target);\n\n            return MultiCall({\n                target: adapter,\n                callData: abi.encodeCall(IPhantomTokenAdapter.depositPhantomToken, (ptOverride.newToken, amount))\n            });\n        }\n\n        (address target,) = _getPhantomTokenInfo(collateral);\n\n        if (target == address(0)) revert(\"MigratorBot: phantom token is not valid\");\n\n        address adapter = ICreditManagerV3(creditManager).contractToAdapter(target);\n\n        return MultiCall({\n            target: adapter,\n            callData: abi.encodeCall(IPhantomTokenAdapter.depositPhantomToken, (collateral, amount))\n        });\n    }\n\n    /// @dev Builds a call to withdraw a phantom token.\n    function _getPhantomTokenWithdrawalCall(address creditManager, address collateral, uint256 amount)\n        internal\n        view\n        returns (MultiCall memory call)\n    {\n        PhantomTokenOverride memory ptOverride = _phantomTokenOverrides[collateral];\n\n        if (ptOverride.newToken != address(0)) {\n            (address target,) = _getPhantomTokenInfo(collateral);\n\n            address adapter = ICreditManagerV3(creditManager).contractToAdapter(target);\n\n            return MultiCall({target: adapter, callData: ptOverride.withdrawalCallData});\n        }\n\n        (address target,) = _getPhantomTokenInfo(collateral);\n\n        if (target == address(0)) revert(\"MigratorBot: phantom token is not valid\");\n\n        address adapter = ICreditManagerV3(creditManager).contractToAdapter(target);\n\n        return MultiCall({\n            target: adapter,\n            callData: abi.encodeCall(IPhantomTokenAdapter.withdrawPhantomToken, (collateral, amount))\n        });\n    }\n\n    /// @dev Gets the target and deposited token of a phantom token safely, to account for tokens that may behave\n    ///      weirdly on unknown function selector.\n    function _getPhantomTokenInfo(address collateral) internal view returns (address target, address depositedToken) {\n        (bool success, bytes memory returnData) = OptionalCall.staticCallOptionalSafe({\n            target: collateral,\n            data: abi.encodeWithSelector(IPhantomToken.getPhantomTokenInfo.selector),\n            gasAllowance: 30_000\n        });\n        if (!success) return (address(0), address(0));\n\n        (target, depositedToken) = abi.decode(returnData, (address, address));\n    }\n\n    /// @dev Computes the total debt of a credit account.\n    function _getAccountTotalDebt(address creditAccount) internal view returns (uint256) {\n        address creditManager = ICreditAccountV3(creditAccount).creditManager();\n\n        CollateralDebtData memory cdd =\n            ICreditManagerV3(creditManager).calcDebtAndCollateral(creditAccount, CollateralCalcTask.DEBT_ONLY);\n\n        return cdd.calcTotalDebt();\n    }\n\n    /// @dev Applies the price updates for push price feeds.\n    function _applyPriceUpdates(address creditManager, PriceUpdate[] memory priceUpdates) internal {\n        address creditFacade = ICreditManagerV3(creditManager).creditFacade();\n        address priceFeedStore = ICreditFacadeV3(creditFacade).priceFeedStore();\n\n        IPriceFeedStore(priceFeedStore).updatePrices(priceUpdates);\n    }\n\n    /// @dev Unlocks the account migration adapter.\n    function _unlockAdapter(address creditAccount, address adapter) internal {\n        activeCreditAccount = creditAccount;\n        IAccountMigratorAdapter(adapter).unlock();\n    }\n\n    /// @dev Locks the account migration adapter.\n    function _lockAdapter(address adapter) internal {\n        activeCreditAccount = INACTIVE_CREDIT_ACCOUNT_ADDRESS;\n        IAccountMigratorAdapter(adapter).lock();\n    }\n\n    /// @dev Validates the migration parameters. Checks that:\n    ///      - the source credit manager is valid\n    ///      - the target credit manager is valid\n    ///      - the migrated tokens are collaterals in the source CM\n    ///      - the phantom token underlyings are correct\n    ///      - the migration adapter is not called in the underlying swap calls or extra opening calls\n    function _validateParameters(address sourceCreditManager, MigrationParams memory params) internal view {\n        _validateCreditManager(sourceCreditManager);\n        _validateCreditManager(params.targetCreditManager);\n\n        for (uint256 i = 0; i < params.migratedCollaterals.length; i++) {\n            try ICreditManagerV3(sourceCreditManager).getTokenMaskOrRevert(params.migratedCollaterals[i].collateral)\n            returns (uint256) {} catch {\n                revert(\"MigratorBot: migrated token is not a valid collateral\");\n            }\n\n            if (params.migratedCollaterals[i].phantomTokenParams.isPhantomToken) {\n                PhantomTokenOverride memory ptOverride =\n                    _phantomTokenOverrides[params.migratedCollaterals[i].collateral];\n\n                if (\n                    ptOverride.underlying != address(0)\n                        && ptOverride.underlying != params.migratedCollaterals[i].phantomTokenParams.underlying\n                ) {\n                    revert(\"MigratorBot: incorrect phantom token underlying\");\n                }\n\n                (, address underlying) = _getPhantomTokenInfo(ptOverride.newToken);\n                if (params.migratedCollaterals[i].phantomTokenParams.underlying != underlying) {\n                    revert(\"MigratorBot: incorrect phantom token underlying\");\n                }\n            }\n        }\n\n        address targetAdapter = ICreditManagerV3(params.targetCreditManager).contractToAdapter(address(this));\n\n        if (targetAdapter != address(0)) {\n            uint256 len = params.underlyingSwapCalls.length;\n\n            for (uint256 i = 0; i < len; i++) {\n                if (params.underlyingSwapCalls[i].target == targetAdapter) {\n                    revert(\"MigratorBot: arbitrary call to migration adapter\");\n                }\n            }\n\n            len = params.extraOpeningCalls.length;\n\n            for (uint256 i = 0; i < len; i++) {\n                if (params.extraOpeningCalls[i].target == targetAdapter) {\n                    revert(\"MigratorBot: arbitrary call to migration adapter\");\n                }\n            }\n        }\n\n        uint256 uniqueTokensLength = params.uniqueTransferredTokens.length;\n        uint256 migratedCollateralsLength = params.migratedCollaterals.length;\n\n        for (uint256 i = 0; i < uniqueTokensLength; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < migratedCollateralsLength; j++) {\n                address token = params.migratedCollaterals[j].phantomTokenParams.isPhantomToken\n                    ? params.migratedCollaterals[j].phantomTokenParams.underlying\n                    : params.migratedCollaterals[j].collateral;\n\n                if (params.uniqueTransferredTokens[i] == token) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                revert(\"MigratorBot: transferred token not found among collaterals\");\n            }\n        }\n\n        for (uint256 i = 0; i < migratedCollateralsLength; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < uniqueTokensLength; j++) {\n                address token = params.migratedCollaterals[i].phantomTokenParams.isPhantomToken\n                    ? params.migratedCollaterals[i].phantomTokenParams.underlying\n                    : params.migratedCollaterals[i].collateral;\n\n                if (token == params.uniqueTransferredTokens[j]) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                revert(\"MigratorBot: migrated collateral not found among transferred tokens\");\n            }\n        }\n    }\n\n    /// @dev Validates that the credit manager is known by Gearbox protocol.\n    function _validateCreditManager(address creditManager) internal view {\n        uint256 cmVersion = IVersion(creditManager).version();\n\n        if (cmVersion < 3_10) {\n            if (!IContractsRegister(contractsRegisterOld).isCreditManager(creditManager)) {\n                revert(\"MigratorBot: credit manager is not valid\");\n            }\n        } else {\n            address creditConfigurator = ICreditManagerV3(creditManager).creditConfigurator();\n            address acl = ACLTrait(creditConfigurator).acl();\n            address mc = Ownable(acl).owner();\n\n            address contractsRegister = IMarketConfigurator(mc).contractsRegister();\n\n            if (\n                !IMarketConfiguratorFactory(mcFactory).isMarketConfigurator(mc)\n                    || !IContractsRegister(contractsRegister).isCreditManager(creditManager)\n            ) {\n                revert(\"MigratorBot: credit manager is not valid\");\n            }\n        }\n    }\n\n    /// @dev Returns either the collateral token or its PT override token.\n    function _getCollateralOrOverride(address collateral) internal view returns (address) {\n        PhantomTokenOverride memory ptOverride = _phantomTokenOverrides[collateral];\n\n        if (ptOverride.newToken != address(0)) {\n            return ptOverride.newToken;\n        }\n\n        return collateral;\n    }\n\n    function serialize() external view override returns (bytes memory) {\n        address[] memory overridenPhantomTokens = _overridenPhantomTokens.values();\n\n        PhantomTokenOverride[] memory ptOverrides = new PhantomTokenOverride[](overridenPhantomTokens.length);\n\n        for (uint256 i = 0; i < overridenPhantomTokens.length; i++) {\n            ptOverrides[i] = _phantomTokenOverrides[overridenPhantomTokens[i]];\n        }\n\n        return abi.encode(mcFactory, ptOverrides);\n    }\n\n    function setPhantomTokenOverride(\n        address phantomToken,\n        address newToken,\n        address underlying,\n        bytes calldata withdrawalCallData\n    ) external onlyOwner {\n        _phantomTokenOverrides[phantomToken] =\n            PhantomTokenOverride({newToken: newToken, underlying: underlying, withdrawalCallData: withdrawalCallData});\n\n        _overridenPhantomTokens.add(phantomToken);\n    }\n\n    function phantomTokenOverrides(address phantomToken) external view override returns (PhantomTokenOverride memory) {\n        return _phantomTokenOverrides[phantomToken];\n    }\n}\n"
    }
}