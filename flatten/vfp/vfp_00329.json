{
    "vfp_id": "vfp_00329",
    "project_name": "cantina_rocketpool_jun2025.pdf",
    "findings": [
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing check allows challenged members to refute beyond the challenge window",
            "description": "The actionChallengeDecide() function does not verify that a challenged member responded within the challenge window. This allows members to refute challenges even after the deadline, violating the intended protocol behavior. The root cause is a missing timestamp check for the refuting party. A malicious or negligent member could exploit this to avoid removal despite being unresponsive. The impact is reduced reliability of the challenge mechanism as a fail-safe.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L207-L224"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Missing check allows a challenge proposer to also later remove the challenged member",
            "description": "The actionChallengeDecide() function does not prevent the original challenge proposer from being the one to remove the challenged member. This violates the requirement that a different node must perform the removal to provide oversight. The root cause is a missing address comparison check. A malicious actor could exploit this to self-police without external validation. The impact is reduced accountability in the challenge process, though mitigated by the ability of users to run multiple nodes.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L180-L183",
                "RocketDAONodeTrustedActions.sol#L224-L231"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for members.rplbond allows current members to manipulate oDAO",
            "description": "The members.rplbond parameter, which sets the RPL bond required for oDAO membership (1750 RPL), has no guardrails. Current members can change it to an arbitrarily high value to deter new members or set it near zero to eliminate meaningful penalties. The root cause is lack of update validation. Malicious oDAO members could exploit this to entrench power or avoid accountability. The impact includes governance centralization and reduced deterrence against misbehavior.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L94-L103",
                "RocketDAONodeTrustedActions.sol#L139-L147",
                "RocketDAONodeTrustedActions.sol#L169-L172",
                "RocketDAONodeTrustedSettingsMembers.sol#L20"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails on members.challenge.cost allow members to prevent non-member challenges or allow spamming",
            "description": "The members.challenge.cost (set to 1 ether) has no upper or lower guardrails. It can be set so high that non-members cannot afford to challenge, or so low (even zero) that spam attacks become feasible. The root cause is absence of bounds checking. Malicious oDAO members could exploit this to either block external oversight or enable denial-of-service via spam. The impact includes compromised governance integrity and potential abuse of the challenge system.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L187-L188",
                "RocketDAONodeTrustedSettingsMembers.sol#L25",
                "RocketDAONodeTrustedSettingsMembers.sol#L35-L40"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        }
    ],
    "affected_files": {
        "RocketDAONodeTrustedActions.sol": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../RocketBase.sol\";\nimport \"../../../interface/RocketVaultInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../../interface/dao/node/RocketDAONodeTrustedActionsInterface.sol\";\nimport \"../../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMembersInterface.sol\";\nimport \"../../../interface/dao/node/settings/RocketDAONodeTrustedSettingsProposalsInterface.sol\";\nimport \"../../../interface/rewards/claims/RocketClaimTrustedNodeInterface.sol\";\nimport \"../../../interface/util/AddressSetStorageInterface.sol\";\nimport \"../../../interface/util/IERC20Burnable.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n// The Trusted Node DAO Actions\ncontract RocketDAONodeTrustedActions is RocketBase, RocketDAONodeTrustedActionsInterface {\n\n    using SafeMath for uint;\n\n    // Events\n    event ActionJoined(address indexed nodeAddress, uint256 rplBondAmount, uint256 time);\n    event ActionLeave(address indexed nodeAddress, uint256 rplBondAmount, uint256 time);\n    event ActionKick(address indexed nodeAddress, uint256 rplBondAmount, uint256 time);\n    event ActionChallengeMade(address indexed nodeChallengedAddress, address indexed nodeChallengerAddress, uint256 time);\n    event ActionChallengeDecided(address indexed nodeChallengedAddress, address indexed nodeChallengeDeciderAddress, bool success, uint256 time);\n\n\n    // The namespace for any data stored in the trusted node DAO (do not change)\n    string constant private daoNameSpace = \"dao.trustednodes.\";\n\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Version\n        version = 2;\n    }\n\n    /*** Internal Methods **********************/\n\n    // Add a new member to the DAO\n    function _memberAdd(address _nodeAddress, uint256 _rplBondAmountPaid) private onlyRegisteredNode(_nodeAddress) {\n        // Load contracts\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Check current node status\n        require(rocketDAONode.getMemberIsValid(_nodeAddress) != true, \"This node is already part of the trusted node DAO\");\n        // Flag them as a member now that they have accepted the invitation and record the size of the bond they paid\n        setBool(keccak256(abi.encodePacked(daoNameSpace, \"member\", _nodeAddress)), true);\n        // Add the bond amount they have paid\n        if(_rplBondAmountPaid > 0) setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.bond.rpl\", _nodeAddress)), _rplBondAmountPaid);\n        // Record the block number they joined at\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.joined.time\", _nodeAddress)), block.timestamp);\n         // Add to member index now\n        addressSetStorage.addItem(keccak256(abi.encodePacked(daoNameSpace, \"member.index\")), _nodeAddress); \n    }\n\n    // Remove a member from the DAO\n    function _memberRemove(address _nodeAddress) private onlyTrustedNode(_nodeAddress) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Remove their membership now\n        deleteBool(keccak256(abi.encodePacked(daoNameSpace, \"member\", _nodeAddress)));\n        deleteAddress(keccak256(abi.encodePacked(daoNameSpace, \"member.address\", _nodeAddress)));\n        deleteString(keccak256(abi.encodePacked(daoNameSpace, \"member.id\", _nodeAddress)));\n        deleteString(keccak256(abi.encodePacked(daoNameSpace, \"member.url\", _nodeAddress)));\n        deleteUint(keccak256(abi.encodePacked(daoNameSpace, \"member.bond.rpl\", _nodeAddress)));\n        deleteUint(keccak256(abi.encodePacked(daoNameSpace, \"member.joined.time\", _nodeAddress)));\n        deleteUint(keccak256(abi.encodePacked(daoNameSpace, \"member.challenged.time\", _nodeAddress)));\n        // Clean up the invited/leave proposals\n        deleteUint(keccak256(abi.encodePacked(daoNameSpace, \"member.executed.time\", \"invited\", _nodeAddress)));\n        deleteUint(keccak256(abi.encodePacked(daoNameSpace, \"member.executed.time\", \"leave\", _nodeAddress)));\n         // Remove from member index now\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(daoNameSpace, \"member.index\")), _nodeAddress); \n    }\n\n    // A member official joins the DAO with their bond ready, if successful they are added as a member\n    function _memberJoin(address _nodeAddress) private {\n        // Set some intiial contract address\n        address rocketVaultAddress = getContractAddress(\"rocketVault\");\n        address rocketTokenRPLAddress = getContractAddress(\"rocketTokenRPL\");\n        // Load contracts\n        IERC20 rplInflationContract = IERC20(rocketTokenRPLAddress);\n        RocketVaultInterface rocketVault = RocketVaultInterface(rocketVaultAddress);\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAONodeTrustedSettingsMembersInterface rocketDAONodeTrustedSettingsMembers = RocketDAONodeTrustedSettingsMembersInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMembers\"));\n        RocketDAONodeTrustedSettingsProposalsInterface rocketDAONodeTrustedSettingsProposals = RocketDAONodeTrustedSettingsProposalsInterface(getContractAddress(\"rocketDAONodeTrustedSettingsProposals\"));\n        // The time that the member was successfully invited to join the DAO\n        uint256 memberInvitedTime = rocketDAONode.getMemberProposalExecutedTime(\"invited\", _nodeAddress);\n        // Have they been invited?\n        require(memberInvitedTime > 0, \"This node has not been invited to join\");\n        // The current member bond amount in RPL that's required\n        uint256 rplBondAmount = rocketDAONodeTrustedSettingsMembers.getRPLBond();\n        // Has their invite expired?\n        require(memberInvitedTime.add(rocketDAONodeTrustedSettingsProposals.getActionTime()) > block.timestamp, \"This node's invitation to join has expired, please apply again\");\n        // Verify they have allowed this contract to spend their RPL for the bond\n        require(rplInflationContract.allowance(_nodeAddress, address(this)) >= rplBondAmount, \"Not enough allowance given to RocketDAONodeTrusted contract for transfer of RPL bond tokens\");\n        // Transfer the tokens to this contract now\n        require(rplInflationContract.transferFrom(_nodeAddress, address(this), rplBondAmount), \"Token transfer to RocketDAONodeTrusted contract was not successful\");\n        // Allow RocketVault to transfer these tokens to itself now\n        require(rplInflationContract.approve(rocketVaultAddress, rplBondAmount), \"Approval for RocketVault to spend RocketDAONodeTrusted RPL bond tokens was not successful\");\n        // Let vault know it can move these tokens to itself now and credit the balance to this contract\n        rocketVault.depositToken(getContractName(address(this)), IERC20(rocketTokenRPLAddress), rplBondAmount);\n        // Add them as a member now that they have accepted the invitation and record the size of the bond they paid\n        _memberAdd(_nodeAddress, rplBondAmount);\n        // Log it\n        emit ActionJoined(_nodeAddress, rplBondAmount, block.timestamp);\n    }\n  \n    /*** Action Methods ************************/\n\n    // When a new member has been successfully invited to join, they must call this method to join officially\n    // They will be required to have the RPL bond amount in their account\n    // This method allows us to only allow them to join if they have a working node account and have been officially invited\n    function actionJoin() override external onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedActions\", address(this)) {\n        _memberJoin(msg.sender);\n    }\n\n    // When the DAO has suffered a loss of members due to unforseen blackswan issue and has < the min required amount (3), a regular bonded node can directly join as a member and recover the DAO\n    // They will be required to have the RPL bond amount in their account. This is called directly from RocketDAONodeTrusted.\n    function actionJoinRequired(address _nodeAddress) override external onlyRegisteredNode(_nodeAddress) onlyLatestContract(\"rocketDAONodeTrusted\", msg.sender) {\n        _memberJoin(_nodeAddress);\n    }\n    \n    // When a new member has successfully requested to leave with a proposal, they must call this method to leave officially and receive their RPL bond\n    function actionLeave(address _rplBondRefundAddress) override external onlyTrustedNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedActions\", address(this)) {\n        // Load contracts\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAONodeTrustedSettingsProposalsInterface rocketDAONodeTrustedSettingsProposals = RocketDAONodeTrustedSettingsProposalsInterface(getContractAddress(\"rocketDAONodeTrustedSettingsProposals\"));\n        // Check this wouldn't dip below the min required trusted nodes\n        require(rocketDAONode.getMemberCount() > rocketDAONode.getMemberMinRequired(), \"Member count will fall below min required\");\n        // Get the time that they were approved to leave at\n        uint256 leaveAcceptedTime = rocketDAONode.getMemberProposalExecutedTime(\"leave\", msg.sender);\n        // Has their leave request expired?\n        require(leaveAcceptedTime.add(rocketDAONodeTrustedSettingsProposals.getActionTime()) > block.timestamp, \"This member has not been approved to leave or request has expired, please apply to leave again\");\n        // They were successful, lets refund their RPL Bond\n        uint256 rplBondRefundAmount = rocketDAONode.getMemberRPLBondAmount(msg.sender);\n        // Refund\n        if(rplBondRefundAmount > 0) {\n            // Valid withdrawal address\n            require(_rplBondRefundAddress != address(0x0), \"Member has not supplied a valid address for their RPL bond refund\");\n            // Send tokens now\n            rocketVault.withdrawToken(_rplBondRefundAddress, IERC20(getContractAddress(\"rocketTokenRPL\")), rplBondRefundAmount);\n        }\n        // Remove them now\n        _memberRemove(msg.sender);\n        // Log it\n        emit ActionLeave(msg.sender, rplBondRefundAmount, block.timestamp);\n    }\n\n\n    // A member can be evicted from the DAO by proposal, send their remaining RPL balance to them and remove from the DAO\n    // Is run via the main DAO contract when the proposal passes and is executed\n    function actionKick(address _nodeAddress, uint256 _rplFine) override external onlyTrustedNode(_nodeAddress) onlyLatestContract(\"rocketDAONodeTrustedProposals\", msg.sender) {\n        // Load contracts\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        IERC20 rplToken = IERC20(getContractAddress(\"rocketTokenRPL\"));\n        // Get the\n        uint256 rplBondRefundAmount = rocketDAONode.getMemberRPLBondAmount(_nodeAddress);\n        // Refund\n        if (rplBondRefundAmount > 0) {\n            // Send tokens now if the vault can cover it\n            if(rplToken.balanceOf(address(rocketVault)) >= rplBondRefundAmount) rocketVault.withdrawToken(_nodeAddress, IERC20(getContractAddress(\"rocketTokenRPL\")), rplBondRefundAmount);\n        }\n        // Burn the fine\n        if (_rplFine > 0) {\n            rocketVault.burnToken(IERC20Burnable(getContractAddress(\"rocketTokenRPL\")), _rplFine);\n        }\n        // Remove the member now\n        _memberRemove(_nodeAddress);\n        // Log it\n        emit ActionKick(_nodeAddress, rplBondRefundAmount, block.timestamp);   \n    }\n\n\n    // In the event that the majority/all of members go offline permanently and no more proposals could be passed, a current member or a regular node can 'challenge' a DAO members node to respond\n    // If it does not respond in the given window, it can be removed as a member. The one who removes the member after the challenge isn't met, must be another node other than the proposer to provide some oversight\n    // This should only be used in an emergency situation to recover the DAO. Members that need removing when consensus is still viable, should be done via the 'kick' method.\n    function actionChallengeMake(address _nodeAddress) override external onlyTrustedNode(_nodeAddress) onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedActions\", address(this)) payable {\n        // Load contracts\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAONodeTrustedSettingsMembersInterface rocketDAONodeTrustedSettingsMembers = RocketDAONodeTrustedSettingsMembersInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMembers\"));\n        // Members can challenge other members for free, but for a regular bonded node to challenge a DAO member, requires non-refundable payment to prevent spamming\n        if(rocketDAONode.getMemberIsValid(msg.sender) != true) require(msg.value == rocketDAONodeTrustedSettingsMembers.getChallengeCost(), \"Non DAO members must pay ETH to challenge a members node\");\n        // Can't challenge yourself duh\n        require(msg.sender != _nodeAddress, \"You cannot challenge yourself\");\n        // Is this member already being challenged?\n        require(!rocketDAONode.getMemberIsChallenged(_nodeAddress), \"Member is already being challenged\");\n        // Has this node recently made another challenge and not waited for the cooldown to pass?\n        require(getUint(keccak256(abi.encodePacked(daoNameSpace, \"node.challenge.created.time\", msg.sender))).add(rocketDAONodeTrustedSettingsMembers.getChallengeCooldown()) < block.timestamp, \"You must wait for the challenge cooldown to pass before issuing another challenge\");\n        // Ok challenge accepted\n        // Record the last time this member challenged\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"node.challenge.created.time\", msg.sender)), block.timestamp);\n        // Record the challenge block now\n        setUint(keccak256(abi.encodePacked(daoNameSpace, \"member.challenged.time\", _nodeAddress)), block.timestamp);\n        // Record who made the challenge\n        setAddress(keccak256(abi.encodePacked(daoNameSpace, \"member.challenged.by\", _nodeAddress)), msg.sender);\n        // Log it\n        emit ActionChallengeMade(_nodeAddress, msg.sender, block.timestamp);\n    }\n\n    \n    // Decides the success of a challenge. If called by the challenged node within the challenge window, the challenge is defeated and the member stays as they have indicated their node is still alive.\n    // If called after the challenge window has passed by anyone except the original challenge initiator, then the challenge has succeeded and the member is removed\n    function actionChallengeDecide(address _nodeAddress) override external onlyTrustedNode(_nodeAddress) onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAONodeTrustedActions\", address(this)) {\n        // Load contracts\n        RocketDAONodeTrustedSettingsMembersInterface rocketDAONodeTrustedSettingsMembers = RocketDAONodeTrustedSettingsMembersInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMembers\"));\n        // Was the challenge successful?\n        bool challengeSuccess = false;\n        // Get the block the challenge was initiated at\n        bytes32 challengeTimeKey = keccak256(abi.encodePacked(daoNameSpace, \"member.challenged.time\", _nodeAddress));\n        uint256 challengeTime = getUint(challengeTimeKey);\n        // If challenge time is 0, the member hasn't been challenged or they have successfully responded to the challenge previously\n        require(challengeTime > 0, \"Member hasn't been challenged or they have successfully responded to the challenge already\");\n        // Allow the challenged member to refute the challenge at anytime. If the window has passed and the challenge node does not run this method, any member can decide the challenge and eject the absent member\n        // Is it the node being challenged?\n        if(_nodeAddress == msg.sender) {\n            // Challenge is defeated, node has responded\n            deleteUint(challengeTimeKey);\n        }else{\n            // The challenge refute window has passed, the member can be ejected now\n            require(challengeTime.add(rocketDAONodeTrustedSettingsMembers.getChallengeWindow()) < block.timestamp, \"Refute window has not yet passed\");\n            // Node has been challenged and failed to respond in the given window, remove them as a member and their bond is burned\n            _memberRemove(_nodeAddress);\n            // Challenge was successful\n            challengeSuccess = true;\n        }\n        // Log it\n        emit ActionChallengeDecided(_nodeAddress, msg.sender, challengeSuccess, block.timestamp);\n    }\n\n\n}\n"
    }
}