{
    "vfp_id": "vfp_00178",
    "project_name": "The Compact Audit.md",
    "findings": [
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Gas-Optimization Opportunities",
            "description": "The codebase contains multiple opportunities for gas optimization, including redundant masking operations, inefficient bitwise expressions, duplicated computations, and suboptimal control flow. For example, `shl(160, shr(160, ...))` can be simplified, and `keccak256` computations duplicate work already done. Additionally, indexed event parameters like `assignableAt` add unnecessary gas costs. These inefficiencies increase transaction fees and deployment costs. While not security vulnerabilities per se, they impact the economic viability and scalability of the system. Addressing these issues would reduce gas consumption and improve overall efficiency.\n",
            "severity": "Informational",
            "location": [
                "DepositViaPermit2Logic.sol::_setReentrancyLockAndStartPreparingPermit2Call#445",
                "DepositViaPermit2Logic.sol::_preprocessAndPerformInitialNativeDeposit#374",
                "DepositViaPermit2Logic.sol::_depositBatchAndRegisterViaPermit2#279",
                "TransferBenchmarkLib.sol::setNativeTokenBenchmark#51",
                "TransferBenchmarkLib.sol::setNativeTokenBenchmark#76",
                "TransferBenchmarkLib.sol::setERC20TokenBenchmark#114-146",
                "TransferLib.sol::withdraw#108",
                "DepositViaPermit2Lib.sol::beginPreparingBatchDepositPermit2Calldata#63",
                "ComponentLib.sol::verifyAndProcessComponents#269",
                "EmissaryLib.sol::assignEmissary#94",
                "EmissaryLib.sol::EmissaryAssignmentScheduled#47",
                "AllocatorLib.sol::callAuthorizeClaim#99"
            ],
            "files": [
                "the-compact/src/lib/DepositViaPermit2Logic.sol"
            ]
        }
    ],
    "affected_files": {
        "DepositViaPermit2Logic.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\nimport { DepositLogic } from \"./DepositLogic.sol\";\nimport { DepositViaPermit2Lib } from \"./DepositViaPermit2Lib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { TransferLib } from \"./TransferLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\n/**\n * @title DepositViaPermit2Logic\n * @notice Inherited contract implementing internal functions with logic for processing\n * token deposits via permit2. These deposits leverage Permit2 witness data to either\n * indicate the parameters of the lock to deposit into and the recipient of the deposit,\n * or the parameters of the compact to register alongside the deposit. Deposits can also\n * involve a single ERC20 token or a batch of tokens in a single Permit2 authorization.\n * @dev IMPORTANT NOTE: this logic operates directly on unallocated memory, and reads\n * directly from fixed calldata offsets; proceed with EXTREME caution when making any\n * modifications to either this logic contract (including the insertion of new logic) or\n * to the associated permit2 deposit function interfaces!\n */\ncontract DepositViaPermit2Logic is DepositLogic {\n    using TransferLib for address;\n    using DepositViaPermit2Lib for bytes32;\n    using DepositViaPermit2Lib for uint256;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using IdLib for ResetPeriod;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using RegistrationLib for address;\n    using ValidityLib for address;\n    using SafeTransferLib for address;\n\n    // Selector for the single token `permit2.permitWitnessTransferFrom` function.\n    uint32 private constant _PERMIT_WITNESS_TRANSFER_FROM_SELECTOR = 0x137c29fe;\n\n    // Address of the Permit2 contract.\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens using Permit2 authorization. The\n     * depositor must approve Permit2 to transfer the tokens on its behalf unless the token in\n     * question automatically grants approval to Permit2. The ERC6909 token amount received by the\n     * by the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token. The Permit2 authorization signed by the\n     * depositor must contain a CompactDeposit witness containing the allocator, the reset period,\n     * the scope, and the intended recipient of the deposit.\n     * @param token       The address of the ERC20 token to deposit.\n     * @param recipient   The address that will receive the corresponding the ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposit.\n     * @return            The ERC6909 token identifier of the associated resource lock.\n     */\n    function _depositViaPermit2(address token, address recipient, bytes calldata signature)\n        internal\n        returns (uint256)\n    {\n        // Derive the CompactDeposit witness hash.\n        bytes32 witness = uint256(0xa4).asStubborn().deriveCompactDepositWitnessHash();\n\n        // Set reentrancy lock, get initial balance, and begin preparing Permit2 call data.\n        (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation) =\n            _setReentrancyLockAndStartPreparingPermit2Call(token);\n\n        // Insert the CompactDeposit typestring fragment.\n        typestringMemoryLocation.insertCompactDepositTypestring();\n\n        // Store the CompactDeposit witness hash.\n        assembly (\"memory-safe\") {\n            mstore(add(m, 0x100), witness)\n        }\n\n        // Write the signature and perform the Permit2 call.\n        //\n        _writeSignatureAndPerformPermit2Call(m, uint256(0x140).asStubborn(), uint256(0x1e0).asStubborn(), signature);\n\n        // Deposit tokens based on the balance change from the Permit2 call.\n        _checkBalanceAndDeposit(token, recipient, id, initialBalance);\n\n        // Clear reentrancy lock.\n        _clearReentrancyGuard();\n\n        // Return the ERC6909 token identifier of the associated resource lock.\n        return id;\n    }\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens using Permit2 authorization and\n     * registering a compact. The depositor must approve Permit2 to transfer the tokens on its\n     * behalf unless the token in question automatically grants approval to Permit2. The ERC6909\n     * token amount received by the depositor is derived from the difference between the starting\n     * and ending balance held in the resource lock, which may differ from the amount transferred\n     * depending on the implementation details of the respective token. The Permit2 authorization\n     * signed by the depositor must contain an Activation witness containing the id of the resource\n     * lock and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param token           The address of the ERC20 token to deposit.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposit.\n     * @return                The ERC6909 token identifier of the associated resource lock.\n     */\n    function _depositAndRegisterViaPermit2(\n        address token,\n        address depositor, // also recipient\n        bytes32 claimHash,\n        string calldata witness,\n        bytes calldata signature\n    ) internal returns (uint256) {\n        uint256 id;\n        uint256 initialBalance;\n        bytes32 compactTypehash;\n        {\n            uint256 m;\n            {\n                uint256 typestringMemoryLocation;\n\n                // Set reentrancy lock, get initial balance, and begin preparing Permit2 call data.\n                (id, initialBalance, m, typestringMemoryLocation) =\n                    _setReentrancyLockAndStartPreparingPermit2Call(token);\n\n                CompactCategory compactCategory;\n                bytes32 activationTypehash;\n                assembly (\"memory-safe\") {\n                    compactCategory := calldataload(0xe4)\n                }\n\n                // Continue preparing Permit2 call data and get activation and compact typehashes.\n                (activationTypehash, compactTypehash) = typestringMemoryLocation.writeWitnessAndGetTypehashes(\n                    compactCategory, witness, bool(false).asStubborn()\n                );\n\n                // Derive the activation witness hash and store it.\n                activationTypehash.deriveAndWriteWitnessHash(id, claimHash, m, 0x100);\n            }\n\n            // Derive signature offset value.\n            uint256 signatureOffsetValue;\n            assembly (\"memory-safe\") {\n                signatureOffsetValue := and(add(mload(add(m, 0x160)), 0x17f), not(0x1f))\n            }\n\n            // Write the signature and perform the Permit2 call.\n            _writeSignatureAndPerformPermit2Call(m, uint256(0x140).asStubborn(), signatureOffsetValue, signature);\n        }\n\n        // Deposit tokens based on the balance change from the Permit2 call.\n        _checkBalanceAndDeposit(token, depositor, id, initialBalance);\n\n        // Register the compact.\n        depositor.registerCompact(claimHash, compactTypehash);\n\n        // Clear reentrancy lock.\n        _clearReentrancyGuard();\n\n        // Return the ERC6909 token identifier of the associated resource lock.\n        return id;\n    }\n\n    /**\n     * @notice Internal function for depositing multiple tokens using Permit2 authorization in a\n     * single transaction. The first token id can optionally represent native tokens by providing\n     * the null address and an amount matching msg.value. The depositor must approve Permit2 to\n     * transfer the tokens on its behalf unless the tokens automatically grant approval to\n     * Permit2. The ERC6909 token amounts received by the recipient are derived from the\n     * differences between starting and ending balances held in the resource locks, which may\n     * differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * CompactDeposit witness containing the allocator, the reset period, the scope, and the\n     * intended recipient of the deposits.\n     * @param permitted   Array of token permissions specifying the deposited tokens and amounts.\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposits.\n     * @return            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function _depositBatchViaPermit2(\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        address recipient,\n        bytes calldata signature\n    ) internal returns (uint256[] memory) {\n        // Set reentrancy guard, perform initial native deposit if present, and get initial token balances.\n        (\n            uint256 totalTokensLessInitialNative,\n            bool firstUnderlyingTokenIsNative,\n            uint256[] memory ids,\n            uint256[] memory initialTokenBalances\n        ) = _preprocessAndPerformInitialNativeDeposit(permitted, recipient);\n\n        {\n            // Derive the CompactDeposit witness hash.\n            bytes32 witness = uint256(0x84).asStubborn().deriveCompactDepositWitnessHash();\n\n            // Begin preparing Permit2 call data.\n            (uint256 m, uint256 typestringMemoryLocation) =\n                totalTokensLessInitialNative.beginPreparingBatchDepositPermit2Calldata(firstUnderlyingTokenIsNative);\n\n            // Insert the CompactDeposit typestring fragment.\n            typestringMemoryLocation.insertCompactDepositTypestring();\n\n            // Declare variable for signature offset value.\n            uint256 signatureOffsetValue;\n            assembly (\"memory-safe\") {\n                // Store the CompactDeposit witness hash.\n                mstore(add(m, 0x80), witness)\n\n                // Derive signature offset value.\n                signatureOffsetValue := add(0x200, shl(7, totalTokensLessInitialNative))\n            }\n\n            // Write the signature and perform the Permit2 call.\n            _writeSignatureAndPerformPermit2Call(m, uint256(0xc0).asStubborn(), signatureOffsetValue, signature);\n        }\n\n        // Deposit tokens based on balance changes from Permit2 call and clear reentrancy lock.\n        _verifyBalancesAndPerformDeposits(ids, permitted, initialTokenBalances, recipient, firstUnderlyingTokenIsNative);\n\n        // Return the ERC6909 token identifiers of the associated resource locks.\n        return ids;\n    }\n\n    /**\n     * @notice Internal function for depositing multiple tokens using Permit2 authorization and\n     * registering a compact in a single transaction. The first token id can optionally represent\n     * native tokens by providing the null address and an amount matching msg.value. The depositor\n     * must approve Permit2 to transfer the tokens on its behalf unless the tokens automatically\n     * grant approval to Permit2. The ERC6909 token amounts received by the depositor are derived\n     * from the differences between starting and ending balances held in the resource locks, which\n     * may differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * BatchActivation witness containing the ids of the resource locks and an associated\n     * Compact, BatchCompact, or MultichainCompact payload matching the specified compact category.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted       Array of token permissions specifying the deposited tokens and amounts.\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function _depositBatchAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        string calldata witness,\n        bytes calldata signature\n    ) internal returns (uint256[] memory ids) {\n        bool firstUnderlyingTokenIsNative;\n        uint256[] memory initialTokenBalances;\n        bytes32 compactTypehash;\n\n        {\n            uint256 totalTokensLessInitialNative;\n\n            // Set reentrancy guard, perform initial native deposit if present, and get initial token balances.\n            (totalTokensLessInitialNative, firstUnderlyingTokenIsNative, ids, initialTokenBalances) =\n                _preprocessAndPerformInitialNativeDeposit(permitted, depositor);\n\n            {\n                uint256 m;\n                CompactCategory compactCategory;\n                {\n                    // Derive the hash of the resource lock ids.\n                    uint256 idsHash;\n                    bytes32 activationTypehash;\n                    uint256 typestringMemoryLocation;\n\n                    assembly (\"memory-safe\") {\n                        idsHash :=\n                            keccak256(\n                                add(ids, 0x20), shl(5, add(totalTokensLessInitialNative, firstUnderlyingTokenIsNative))\n                            )\n\n                        compactCategory := calldataload(0xc4)\n                    }\n\n                    // Begin preparing Permit2 call data.\n                    (m, typestringMemoryLocation) = totalTokensLessInitialNative\n                        .beginPreparingBatchDepositPermit2Calldata(firstUnderlyingTokenIsNative);\n\n                    // Prepare the typestring fragment and get batch activation and compact typehashes.\n                    (activationTypehash, compactTypehash) = typestringMemoryLocation.writeWitnessAndGetTypehashes(\n                        compactCategory, witness, bool(true).asStubborn()\n                    );\n\n                    bytes32 claimHash;\n                    assembly (\"memory-safe\") {\n                        claimHash := calldataload(0xa4)\n                    }\n\n                    // Derive the batch activation witness hash and store it.\n                    activationTypehash.deriveAndWriteWitnessHash(idsHash, claimHash, m, 0x80);\n                }\n\n                // Declare variable for signature offset value.\n                uint256 signatureOffsetValue;\n                assembly (\"memory-safe\") {\n                    // Derive the total memory offset for the witness.\n                    let totalWitnessMemoryOffset :=\n                        and(\n                            add(\n                                add(0x11d, add(witness.length, iszero(iszero(witness.length)))),\n                                mul(eq(compactCategory, 1), 0x0b)\n                            ),\n                            not(0x1f)\n                        )\n\n                    // Derive the signature offset value.\n                    signatureOffsetValue :=\n                        add(add(0x180, shl(7, totalTokensLessInitialNative)), totalWitnessMemoryOffset)\n                }\n\n                // Write the signature and perform the Permit2 call.\n                _writeSignatureAndPerformPermit2Call(m, uint256(0xc0).asStubborn(), signatureOffsetValue, signature);\n            }\n        }\n\n        // Deposit tokens based on balance changes from Permit2 call and clear reentrancy lock.\n        _verifyBalancesAndPerformDeposits(ids, permitted, initialTokenBalances, depositor, firstUnderlyingTokenIsNative);\n\n        bytes32 registeredClaimHash;\n        assembly (\"memory-safe\") {\n            registeredClaimHash := calldataload(0xa4)\n        }\n\n        // Register the compact.\n        depositor.registerCompact(registeredClaimHash, compactTypehash);\n\n        // Return the ERC6909 token identifiers of the associated resource locks.\n        return ids;\n    }\n\n    /**\n     * @notice Private function for pre-processing and performing an initial native deposit.\n     * @param permitted                     Array of token permissions specifying the deposited tokens and amounts.\n     * @param recipient                     The address that will receive the corresponding ERC6909 tokens.\n     * @return totalTokensLessInitialNative The total number of tokens less the initial native deposit.\n     * @return firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     * @return ids                          Array of ERC6909 token identifiers.\n     * @return initialTokenBalances         Array of initial token balances.\n     */\n    function _preprocessAndPerformInitialNativeDeposit(\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        address recipient\n    )\n        private\n        returns (\n            uint256 totalTokensLessInitialNative,\n            bool firstUnderlyingTokenIsNative,\n            uint256[] memory ids,\n            uint256[] memory initialTokenBalances\n        )\n    {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Get total number of tokens and declare lockTag.\n        uint256 totalTokens = permitted.length;\n        bytes12 lockTag;\n\n        assembly (\"memory-safe\") {\n            // Get the offset of the permitted calldata struct.\n            let permittedOffset := permitted.offset\n\n            // Determine if the first underlying token is native.\n            firstUnderlyingTokenIsNative := iszero(shr(96, shl(96, calldataload(permittedOffset))))\n\n            // Revert if:\n            //  * the array is empty\n            //  * the callvalue is zero but the first token is native\n            //  * the callvalue is nonzero but the first token is non-native\n            //  * the first token is non-native and the callvalue doesn't equal the first amount\n            if or(\n                iszero(totalTokens),\n                or(\n                    eq(firstUnderlyingTokenIsNative, iszero(callvalue())),\n                    and(firstUnderlyingTokenIsNative, iszero(eq(callvalue(), calldataload(add(permittedOffset, 0x20)))))\n                )\n            ) {\n                // revert InvalidBatchDepositStructure()\n                mstore(0, 0xca0fc08e)\n                revert(0x1c, 0x04)\n            }\n\n            // Retrieve lockTag\n            // toIdIfRegistered does not sanitize the lockTag. Clear the rightmost 20 bytes.\n            lockTag := shl(160, shr(160, calldataload(0x84)))\n        }\n\n        // Get the initial resource lock id.\n        uint256 initialId = address(0).toIdIfRegistered(lockTag);\n\n        // Allocate ids array.\n        ids = new uint256[](totalTokens);\n\n        // Perform initial native deposit if present.\n        if (firstUnderlyingTokenIsNative) {\n            recipient.deposit(initialId, msg.value);\n\n            // Set the initial id using the native resource lock.\n            ids[0] = initialId;\n        }\n\n        // Calculate total number of tokens less the initial native deposit.\n        unchecked {\n            totalTokensLessInitialNative = totalTokens - firstUnderlyingTokenIsNative.asUint256();\n        }\n\n        // Prepare ids and get initial token balances.\n        initialTokenBalances = _prepareIdsAndGetBalances(\n            ids, totalTokensLessInitialNative, firstUnderlyingTokenIsNative, permitted, initialId\n        );\n    }\n\n    /**\n     * @notice Private function for setting the reentrancy guard and starting the process\n     *  of preparing a Permit2 call.\n     * @param token                      The address of the token to be deposited.\n     * @return id                        The ERC6909 token identifier of the associated resource lock.\n     * @return initialBalance            The initial balance of the token in the contract.\n     * @return m                         The memory pointer for the Permit2 call data.\n     * @return typestringMemoryLocation  The memory location for the typestring.\n     */\n    function _setReentrancyLockAndStartPreparingPermit2Call(address token)\n        private\n        returns (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation)\n    {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Declare lockTag\n        bytes12 lockTag;\n\n        // Retrieve lockTag from calldata.\n        assembly (\"memory-safe\") {\n            // toIdIfRegistered does not sanitize the lockTag. Clear the rightmost 20 bytes.\n            lockTag := shl(160, shr(160, calldataload(0xa4)))\n        }\n\n        // Get the ERC6909 token identifier of the associated resource lock.\n        id = token.excludingNative().toIdIfRegistered(lockTag);\n\n        // Get the initial balance of the token in the contract.\n        initialBalance = token.balanceOf(address(this));\n\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            m := mload(0x40)\n\n            // Begin preparing Permit2 call data.\n            mstore(m, _PERMIT_WITNESS_TRANSFER_FROM_SELECTOR)\n            calldatacopy(add(m, 0x20), 0x04, 0x80) // token, amount, nonce, deadline\n            mstore(add(m, 0xa0), address())\n            mstore(add(m, 0xc0), calldataload(0x24)) // amount\n            mstore(add(m, 0xe0), calldataload(0x84)) // depositor\n            mstore(add(m, 0x120), 0x140)\n\n            // Derive the memory location for the typestring.\n            typestringMemoryLocation := add(m, 0x160)\n\n            // NOTE: strongly consider allocating memory here as the inline assembly scope\n            // is being left (it *should* be fine for now as the function between assembly\n            // blocks does not allocate any new memory).\n        }\n    }\n\n    /**\n     * @notice Private function for writing the signature and performing the Permit2 call.\n     * @param m                       The memory pointer for the Permit2 call data.\n     * @param signatureOffsetLocation The memory location for the signature offset.\n     * @param signatureOffsetValue    The signature offset value.\n     * @param signature               The Permit2 signature.\n     */\n    function _writeSignatureAndPerformPermit2Call(\n        uint256 m,\n        uint256 signatureOffsetLocation,\n        uint256 signatureOffsetValue,\n        bytes calldata signature\n    ) private {\n        // Determine if Permit2 is deployed.\n        bool isPermit2Deployed = _isPermit2Deployed();\n\n        assembly (\"memory-safe\") {\n            // Write the signature offset.\n            mstore(add(m, signatureOffsetLocation), signatureOffsetValue) // signature offset\n\n            // Retrieve signature length and derive signature memory offset.\n            let signatureLength := signature.length\n            let signatureMemoryOffset := add(m, add(0x20, signatureOffsetValue))\n\n            // Write the signature length.\n            mstore(signatureMemoryOffset, signatureLength)\n\n            // Copy the signature from calldata to memory.\n            calldatacopy(add(signatureMemoryOffset, 0x20), signature.offset, signatureLength)\n\n            // Perform the Permit2 call.\n            if iszero(\n                and(\n                    isPermit2Deployed,\n                    call(gas(), _PERMIT2, 0, add(m, 0x1c), add(0x24, add(signatureOffsetValue, signatureLength)), 0, 0)\n                )\n            ) {\n                // Bubble up if the call failed and there's data.\n                // NOTE: consider evaluating remaining gas to protect against revert bombing\n                if returndatasize() {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert Permit2CallFailed();\n                mstore(0, 0x7f28c61e)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Private function for verifying balance changes and performing deposits.\n     * @param ids                          The ERC6909 token identifiers of the associated resource locks.\n     * @param permittedTokens              The token permissions specifying the deposited tokens and amounts.\n     * @param initialTokenBalances         The initial token balances in the contract.\n     * @param recipient                    The address that will receive the corresponding ERC6909 tokens.\n     * @param firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     */\n    function _verifyBalancesAndPerformDeposits(\n        uint256[] memory ids,\n        ISignatureTransfer.TokenPermissions[] calldata permittedTokens,\n        uint256[] memory initialTokenBalances,\n        address recipient,\n        bool firstUnderlyingTokenIsNative\n    ) private {\n        // Declare token balance, initial balance, and error buffer variables.\n        uint256 tokenBalance;\n        uint256 initialBalance;\n        uint256 errorBuffer;\n\n        // Retrieve total initial token balances (equal to total tokens less initial native deposit).\n        uint256 totalTokensLessInitialNative = initialTokenBalances.length;\n\n        unchecked {\n            // Iterate through each token.\n            for (uint256 i = 0; i < totalTokensLessInitialNative; ++i) {\n                // Get the token balance and initial balance.\n                tokenBalance =\n                    permittedTokens[i + firstUnderlyingTokenIsNative.asUint256()].token.balanceOf(address(this));\n                initialBalance = initialTokenBalances[i];\n\n                // Set the error buffer if the initial balance is greater than or equal to the token balance.\n                errorBuffer |= (initialBalance >= tokenBalance).asUint256();\n\n                // Perform the deposit.\n                recipient.deposit(ids[i + firstUnderlyingTokenIsNative.asUint256()], tokenBalance - initialBalance);\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Revert if the error buffer is set.\n            if errorBuffer {\n                // revert InvalidDepositBalanceChange()\n                mstore(0, 0x426d8dcf)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Clear reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Private function for preparing ids and getting token balances.\n     * Note that all tokens must be supplied in ascending order and cannot be duplicated.\n     * @param ids                          The ERC6909 token identifiers of the associated resource locks.\n     * @param totalTokensLessInitialNative The total number of tokens less the initial native deposit.\n     * @param firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     * @param permitted                    The token permissions specifying the deposited tokens and amounts.\n     * @param id                           The ERC6909 token identifier of the associated resource lock.\n     * @return tokenBalances               The token balances in the contract.\n     */\n    function _prepareIdsAndGetBalances(\n        uint256[] memory ids,\n        uint256 totalTokensLessInitialNative,\n        bool firstUnderlyingTokenIsNative,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        uint256 id\n    ) private view returns (uint256[] memory tokenBalances) {\n        unchecked {\n            // Allocate token balances array.\n            tokenBalances = new uint256[](totalTokensLessInitialNative);\n\n            // Declare token, candidate id, and error buffer variables.\n            address token;\n            uint256 candidateId;\n            uint256 errorBuffer;\n\n            // Iterate over each token.\n            for (uint256 i = 0; i < totalTokensLessInitialNative; ++i) {\n                // Retrieve the token and derive the candidate id.\n                token = permitted[i + firstUnderlyingTokenIsNative.asUint256()].token;\n                candidateId = id.withReplacedToken(token);\n\n                // Set the error buffer if the candidate id is less than or equal to the current id.\n                errorBuffer |= (candidateId <= id).asUint256();\n\n                // Update the id.\n                id = candidateId;\n\n                // Set the id in the ids array.\n                ids[i + firstUnderlyingTokenIsNative.asUint256()] = id;\n\n                // Get the token balance and set it in the token balances array.\n                tokenBalances[i] = token.balanceOf(address(this));\n            }\n\n            assembly (\"memory-safe\") {\n                // Revert if the error buffer is set.\n                if errorBuffer {\n                    // revert InvalidDepositTokenOrdering()\n                    mstore(0, 0x0f2f1e51)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n}\n"
    }
}