{
    "vfp_id": "vfp_00375",
    "project_name": "1inch Protocol Fee Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing Docstrings",
            "description": "The codebase lacks proper documentation in several public and external functions and interfaces. This includes functions such as `getMakingAmount`, `getTakingAmount`, and entire interfaces like `IAmountGetter` and `IOrderMixin`. The absence of docstrings reduces code readability and maintainability, making it harder for developers and auditors to understand the intended behavior. This issue stems from insufficient inline documentation during development. While it does not directly lead to exploitable vulnerabilities, it increases the risk of misinterpretation during future development or audits. The impact is limited to reduced clarity and potential integration errors.\n",
            "severity": "Low",
            "location": [
                "AmountGetterBase.sol::getMakingAmount#12-22",
                "AmountGetterBase.sol::getTakingAmount#24-34",
                "IAmountGetter.sol::IAmountGetter#7-47",
                "IOrderMixin.sol::IOrderMixin#9-210"
            ],
            "files": [
                "cf8e50eb24c01c7b276a30a5877840df35e66e67/limit-order-protocol/contracts/extensions/AmountGetterBase.sol",
                "cf8e50eb24c01c7b276a30a5877840df35e66e67/limit-order-protocol/contracts/interfaces/IAmountGetter.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Incomplete Docstrings",
            "description": "Several functions in the codebase have incomplete NatSpec documentation, where not all parameters or return values are documented. For example, the `getMakingAmount` and `getTakingAmount` functions in `IAmountGetter.sol` omit return value descriptions, and the `remainingInvalidatorForOrder` functions do not document the `maker` parameter. In `SimpleSettlement.sol`, internal functions like `_getAuctionBump` and `_getFeeAmounts` fail to document return variables such as `tail`. This stems from partial or inconsistent documentation practices. The lack of complete documentation can lead to misunderstandings about function behavior, especially for external developers or auditors. The impact is reduced code clarity and increased risk of integration errors, though no direct security exploits are possible.\n",
            "severity": "Low",
            "location": [
                "IAmountGetter.sol::getMakingAmount#18-26",
                "IAmountGetter.sol::getTakingAmount#38-46",
                "IOrderMixin.sol::remainingInvalidatorForOrder#84",
                "IOrderMixin.sol::rawRemainingInvalidatorForOrder#91",
                "SimpleSettlement.sol::_getAuctionBump#118-120",
                "SimpleSettlement.sol::_getRateBump#93",
                "SimpleSettlement.sol::_getFeeAmounts#201"
            ],
            "files": [
                "cf8e50eb24c01c7b276a30a5877840df35e66e67/limit-order-protocol/contracts/interfaces/IOrderMixin.sol",
                "cf8e50eb24c01c7b276a30a5877840df35e66e67/limit-order-protocol/contracts/interfaces/IAmountGetter.sol",
                "c0197a5b4110e89a7a832fff8e95927e41564e17/fusion-protocol/contracts/SimpleSettlement.sol"
            ]
        }
    ],
    "affected_files": {
        "IOrderMixin.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport \"../libraries/MakerTraitsLib.sol\";\nimport \"../libraries/TakerTraitsLib.sol\";\n\ninterface IOrderMixin {\n    struct Order {\n        uint256 salt;\n        Address maker;\n        Address receiver;\n        Address makerAsset;\n        Address takerAsset;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        MakerTraits makerTraits;\n    }\n\n    error InvalidatedOrder();\n    error TakingAmountExceeded();\n    error PrivateOrder();\n    error BadSignature();\n    error OrderExpired();\n    error WrongSeriesNonce();\n    error SwapWithZeroAmount();\n    error PartialFillNotAllowed();\n    error OrderIsNotSuitableForMassInvalidation();\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\n    error ReentrancyDetected();\n    error PredicateIsNotTrue();\n    error TakingAmountTooHigh();\n    error MakingAmountTooLow();\n    error TransferFromMakerToTakerFailed();\n    error TransferFromTakerToMakerFailed();\n    error MismatchArraysLengths();\n    error InvalidPermit2Transfer();\n    error SimulationResults(bool success, bytes res);\n\n    /**\n     * @notice Emitted when order gets filled\n     * @param orderHash Hash of the order\n     * @param remainingAmount Amount of the maker asset that remains to be filled\n     */\n    event OrderFilled(\n        bytes32 orderHash,\n        uint256 remainingAmount\n    );\n\n    /**\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\n     * @param orderHash Hash of the order\n     */\n    event OrderCancelled(\n        bytes32 orderHash\n    );\n\n    /**\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\n     * @param maker Maker address\n     * @param slotIndex Slot index that was updated\n     * @param slotValue New slot value\n     */\n    event BitInvalidatorUpdated(\n        address indexed maker,\n        uint256 slotIndex,\n        uint256 slotValue\n    );\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param maker Maker address\n     * @param slot Slot number to return bitmask for\n     * @return result Each bit represents whether corresponding was already invalidated\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remaining Remaining amount of the order\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\n\n    /**\n     * @notice Cancels order's quote\n     * @param makerTraits Order makerTraits\n     * @param orderHash Hash of the order to cancel\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\n\n    /**\n     * @notice Cancels orders' quotes\n     * @param makerTraits Orders makerTraits\n     * @param orderHashes Hashes of the orders to cancel\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\n\n    /**\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\n     * @param makerTraits Order makerTraits\n     * @param additionalMask Additional bitmask to invalidate orders\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\n\n    /**\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\n     * @param order Order\n     * @return orderHash Hash of the order\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\n\n    /**\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\n     * @dev The function always reverts and returns the simulation results in revert data.\n     * @param target Addresses that will be delegated\n     * @param data Data that will be passed to delegatee\n     */\n    function simulate(address target, bytes calldata data) external;\n\n    /**\n     * @notice Fills order's quote, fully or partially (whichever is possible).\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrder(\n        Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but uses contract-based signatures.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrder(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n}\n",
        "AmountGetterBase.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IAmountGetter } from \"../interfaces/IAmountGetter.sol\";\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\n\n/// @title Base price getter contract that either calls external getter or applies linear formula\ncontract AmountGetterBase is IAmountGetter {\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        return _getMakingAmount(order, extension, orderHash, taker, takingAmount, remainingMakingAmount, extraData);\n    }\n\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        return _getTakingAmount(order, extension, orderHash, taker, makingAmount, remainingMakingAmount, extraData);\n    }\n\n    function _getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view virtual returns (uint256) {\n        if (extraData.length >= 20) {\n            return IAmountGetter(address(bytes20(extraData))).getMakingAmount(\n                order, extension, orderHash, taker, takingAmount, remainingMakingAmount, extraData[20:]\n            );\n        } else {\n            return Math.mulDiv(order.makingAmount, takingAmount, order.takingAmount);\n        }\n    }\n\n    function _getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view virtual returns (uint256) {\n        if (extraData.length >= 20) {\n            return IAmountGetter(address(bytes20(extraData))).getTakingAmount(\n                order, extension, orderHash, taker, makingAmount, remainingMakingAmount, extraData[20:]\n            );\n        } else {\n            return Math.mulDiv(order.takingAmount, makingAmount, order.makingAmount, Math.Rounding.Ceil);\n        }\n    }\n}\n",
        "IAmountGetter.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\ninterface IAmountGetter {\n    /**\n     * @notice View method that gets called to determine the actual making amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n\n    /**\n     * @notice View method that gets called to determine the actual making amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n}\n",
        "SimpleSettlement.sol": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IOrderMixin } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\";\nimport { FeeTaker } from \"@1inch/limit-order-protocol-contract/contracts/extensions/FeeTaker.sol\";\n\n/**\n * @title Simple Settlement contract\n * @notice Contract to execute limit orders settlement, created by Fusion mode.\n */\ncontract SimpleSettlement is FeeTaker {\n    using Math for uint256;\n\n    uint256 private constant _BASE_POINTS = 10_000_000; // 100%\n    uint256 private constant _GAS_PRICE_BASE = 1_000_000; // 1000 means 1 Gwei\n\n    error AllowedTimeViolation();\n    error InvalidProtocolSurplusFee();\n    error InvalidEstimatedTakingAmount();\n\n    /**\n     * @notice Initializes the contract.\n     * @param limitOrderProtocol The limit order protocol contract.\n     * @param accessToken Contract address whose tokens allow filling limit orders with a fee for resolvers that are outside the whitelist.\n     * @param weth The WETH address.\n     * @param owner The owner of the contract.\n     */\n    constructor(address limitOrderProtocol, IERC20 accessToken, address weth, address owner)\n        FeeTaker(limitOrderProtocol, accessToken, weth, owner)\n    {}\n\n    /**\n     * @dev Adds dutch auction capabilities to the getter\n     */\n    function _getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view override returns (uint256) {\n        (uint256 rateBump, bytes calldata tail) = _getRateBump(extraData);\n        return Math.mulDiv(\n            super._getMakingAmount(order, extension, orderHash, taker, takingAmount, remainingMakingAmount, tail),\n            _BASE_POINTS,\n            _BASE_POINTS + rateBump\n        );\n    }\n\n    /**\n     * @dev Adds dutch auction capabilities to the getter\n     */\n    function _getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view override returns (uint256) {\n        (uint256 rateBump, bytes calldata tail) = _getRateBump(extraData);\n        return Math.mulDiv(\n            super._getTakingAmount(order, extension, orderHash, taker, makingAmount, remainingMakingAmount, tail),\n            _BASE_POINTS + rateBump,\n            _BASE_POINTS,\n            Math.Rounding.Ceil\n        );\n    }\n\n    /**\n     * @dev Parses auction rate bump data from the `auctionDetails` field.\n     * `gasBumpEstimate` and `gasPriceEstimate` are used to estimate the transaction costs\n     * which are then offset from the auction rate bump.\n     * @param auctionDetails AuctionDetails is a tightly packed struct of the following format:\n     * ```\n     * struct AuctionDetails {\n     *     bytes3 gasBumpEstimate;\n     *     bytes4 gasPriceEstimate;\n     *     bytes4 auctionStartTime;\n     *     bytes3 auctionDuration;\n     *     bytes3 initialRateBump;\n     *     (bytes3,bytes2)[N] pointsAndTimeDeltas;\n     * }\n     * ```\n     * @return rateBump The rate bump.\n     */\n    function _getRateBump(bytes calldata auctionDetails) private view returns (uint256, bytes calldata) {\n        unchecked {\n            uint256 gasBumpEstimate = uint24(bytes3(auctionDetails[0:3]));\n            uint256 gasPriceEstimate = uint32(bytes4(auctionDetails[3:7]));\n            uint256 gasBump = gasBumpEstimate == 0 || gasPriceEstimate == 0 ? 0 : gasBumpEstimate * block.basefee / gasPriceEstimate / _GAS_PRICE_BASE;\n            uint256 auctionStartTime = uint32(bytes4(auctionDetails[7:11]));\n            uint256 auctionFinishTime = auctionStartTime + uint24(bytes3(auctionDetails[11:14]));\n            uint256 initialRateBump = uint24(bytes3(auctionDetails[14:17]));\n            (uint256 auctionBump, bytes calldata tail) = _getAuctionBump(auctionStartTime, auctionFinishTime, initialRateBump, auctionDetails[17:]);\n            return (auctionBump > gasBump ? auctionBump - gasBump : 0, tail);\n        }\n    }\n\n    /**\n     * @dev Calculates auction price bump. Auction is represented as a piecewise linear function with `N` points.\n     * Each point is represented as a pair of `(rateBump, timeDelta)`, where `rateBump` is the\n     * rate bump in basis points and `timeDelta` is the time delta in seconds.\n     * The rate bump is interpolated linearly between the points.\n     * The last point is assumed to be `(0, auctionDuration)`.\n     * @param auctionStartTime The time when the auction starts.\n     * @param auctionFinishTime The time when the auction finishes.\n     * @param initialRateBump The initial rate bump.\n     * @param pointsAndTimeDeltas The points and time deltas structure.\n     * @return The rate bump at the current time.\n     */\n    function _getAuctionBump(\n        uint256 auctionStartTime, uint256 auctionFinishTime, uint256 initialRateBump, bytes calldata pointsAndTimeDeltas\n    ) private view returns (uint256, bytes calldata) {\n        unchecked {\n            uint256 currentPointTime = auctionStartTime;\n            uint256 currentRateBump = initialRateBump;\n            uint256 pointsCount = uint8(pointsAndTimeDeltas[0]);\n            pointsAndTimeDeltas = pointsAndTimeDeltas[1:];\n            bytes calldata tail = pointsAndTimeDeltas[5 * pointsCount:];\n\n            if (block.timestamp <= auctionStartTime) {\n                return (initialRateBump, tail);\n            } else if (block.timestamp >= auctionFinishTime) {\n                return (0, tail);\n            }\n\n            for (uint256 i = 0; i < pointsCount; i++) {\n                uint256 nextRateBump = uint24(bytes3(pointsAndTimeDeltas[:3]));\n                uint256 nextPointTime = currentPointTime + uint16(bytes2(pointsAndTimeDeltas[3:5]));\n                if (block.timestamp <= nextPointTime) {\n                    return (((block.timestamp - currentPointTime) * nextRateBump + (nextPointTime - block.timestamp) * currentRateBump) / (nextPointTime - currentPointTime), tail);\n                }\n                currentRateBump = nextRateBump;\n                currentPointTime = nextPointTime;\n                pointsAndTimeDeltas = pointsAndTimeDeltas[5:];\n            }\n            return ((auctionFinishTime - block.timestamp) * currentRateBump / (auctionFinishTime - currentPointTime), tail);\n        }\n    }\n\n    /**\n     * @dev Validates whether the taker is whitelisted.\n     * @param whitelistData Whitelist data is a tightly packed struct of the following format:\n     * ```\n     * 4 bytes - allowed time\n     * 1 byte - size of the whitelist\n     * (bytes12)[N] — taker whitelist\n     * ```\n     * Only 10 lowest bytes of the address are used for comparison.\n     * @param taker The taker address to check.\n     * @return isWhitelisted Whether the taker is whitelisted.\n     * @return tail Remaining calldata.\n     */\n    function _isWhitelistedPostInteractionImpl(bytes calldata whitelistData, address taker) internal view override returns (bool isWhitelisted, bytes calldata tail) {\n        unchecked {\n            uint80 maskedTakerAddress = uint80(uint160(taker));\n            uint256 allowedTime = uint32(bytes4(whitelistData));\n            uint256 size = uint8(whitelistData[4]);\n            bytes calldata whitelist = whitelistData[5:5 + 12 * size];\n            tail = whitelistData[5 + 12 * size:];\n\n            for (uint256 i = 0; i < size; i++) {\n                uint80 whitelistedAddress = uint80(bytes10(whitelist));\n                if (block.timestamp < allowedTime) {\n                    revert AllowedTimeViolation();\n                } else if (maskedTakerAddress == whitelistedAddress) {\n                    return (true, tail);\n                }\n                allowedTime += uint16(bytes2(whitelist[10:])); // add next time delta\n                whitelist = whitelist[12:];\n            }\n            if (block.timestamp < allowedTime) {\n                revert AllowedTimeViolation();\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates fee amounts depending on whether the taker is in the whitelist and whether they have an _ACCESS_TOKEN.\n     * @param order The user's order.\n     * @param taker The taker address.\n     * @param takingAmount The amount of the asset being taken.\n     * @param extraData The extra data has the following format:\n     * FeeTaker structure determined by `super._getFeeAmounts`:\n     *      2 bytes — integrator fee percentage (in 1e5)\n     *      1 bytes - integrator rev share percentage (in 1e2)\n     *      2 bytes — resolver fee percentage (in 1e5)\n     *      bytes — whitelist structure determined by `_isWhitelistedPostInteractionImpl` implementation\n     * Surpluses fee structure:\n     *      32 bytes - estimated taking amount\n     *      1 byte - protocol surplus fee (in 1e2)\n     * ```\n     */\n    function _getFeeAmounts(IOrderMixin.Order calldata order, address taker, uint256 takingAmount, uint256 makingAmount, bytes calldata extraData) internal override virtual returns (uint256 integratorFeeAmount, uint256 protocolFeeAmount, bytes calldata tail) {\n        (integratorFeeAmount, protocolFeeAmount, tail) = super._getFeeAmounts(order, taker, takingAmount, makingAmount, extraData);\n\n        uint256 estimatedTakingAmount = uint256(bytes32(tail));\n        if (estimatedTakingAmount < order.takingAmount) {\n            revert InvalidEstimatedTakingAmount();\n        }\n\n        uint256 actualTakingAmount = takingAmount - integratorFeeAmount - protocolFeeAmount;\n        uint256 scaledEstimatedTakingAmount = estimatedTakingAmount.mulDiv(makingAmount, order.makingAmount);\n        if (actualTakingAmount > scaledEstimatedTakingAmount) {\n            uint256 protocolSurplusFee = uint256(uint8(bytes1(tail[32:])));\n            if (protocolSurplusFee > _BASE_1E2) revert InvalidProtocolSurplusFee();\n            protocolFeeAmount += (actualTakingAmount - scaledEstimatedTakingAmount).mulDiv(protocolSurplusFee, _BASE_1E2);\n        }\n        tail = tail[33:];\n    }\n}\n"
    }
}