{
    "vfp_id": "vfp_00085",
    "project_name": "OpenZeppelin Uniswap Hooks v1.1.0 RC 2 Audit.md",
    "findings": [
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing Docstrings",
            "description": "Multiple functions and state variables across the codebase lack NatSpec documentation. Specifically, the poolManager state variable in BaseHook.sol and all state variables in LiquidityPenaltyHook.sol are undocumented. Additionally, other public or sensitive functions lack proper docstrings. The absence of documentation reduces code readability and increases the risk of misinterpretation by developers, auditors, or integrators. While this does not directly lead to exploits, it can result in incorrect usage of the contracts, especially for complex logic such as fee handling or tick management. The lack of clear parameter and return value descriptions makes it harder to verify correctness and increases the likelihood of integration errors.\n",
            "severity": "Low",
            "location": [
                "BaseHook.sol::poolManager#30",
                "LiquidityPenaltyHook.sol"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseHook.sol",
                "uniswap-hooks/src/general/LiquidityPenaltyHook.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Liquidity Penalty Can Be Circumvented Using Secondary Accounts",
            "description": "The LiquidityPenaltyHook is designed to penalize JIT liquidity attacks by redirecting fees to in-range LPs when liquidity is removed within a short window. However, an attacker can use a secondary account to position liquidity in a low-traffic tick range. After generating fees with a primary account, the attacker can move the price into the secondary account's range and remove liquidity, causing the penalty fees to be donated to the secondary account. This allows the attacker to bypass the intended penalty mechanism and extract fees. While this attack is theoretically possible, it is impractical in high-liquidity pools due to the high cost of price manipulation. The impact is limited to low-liquidity environments, where the attacker could profitably redirect fees, undermining the fairness of fee distribution.\n",
            "severity": "Low",
            "location": [
                "LiquidityPenaltyHook.sol#L63",
                "LiquidityPenaltyHook.sol"
            ],
            "files": [
                "uniswap-hooks/src/general/LiquidityPenaltyHook.sol"
            ]
        }
    ],
    "affected_files": {
        "BaseHook.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseHook.sol)\n\npragma solidity ^0.8.24;\n\nimport {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {SwapParams, ModifyLiquidityParams} from \"v4-core/src/types/PoolOperation.sol\";\n\n/**\n * @dev Base hook implementation.\n *\n * This contract defines all hook entry points, as well as security and permission helpers.\n * Based on the https://github.com/Uniswap/v4-periphery/blob/main/src/base/hooks/BaseHook.sol[Uniswap v4 periphery implementation].\n *\n * NOTE: Hook entry points must be overiden and implemented by the inheriting hook to be used. Their respective\n * flags must be set to true in the `getHookPermissions` function as well.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseHook is IHooks {\n    IPoolManager public immutable poolManager;\n\n    /**\n     * @dev The hook is not the caller.\n     */\n    error NotSelf();\n\n    /**\n     * @dev The pool is not authorized to use this hook.\n     */\n    error InvalidPool();\n\n    /**\n     * @dev The hook function is not implemented.\n     */\n    error HookNotImplemented();\n\n    /**\n     * @notice Thrown when calling unlockCallback where the caller is not `PoolManager`.\n     */\n    error NotPoolManager();\n\n    /**\n     * @dev Set the pool manager and check that the hook address matches the expected permissions and flags.\n     */\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        validateHookAddress(this);\n    }\n\n    /**\n     * @notice Only allow calls from the `PoolManager` contract\n     */\n    modifier onlyPoolManager() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    /**\n     * @dev Restrict the function to only be callable by the hook itself.\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    /**\n     * @dev Restrict the function to only be called for a valid pool.\n     */\n    modifier onlyValidPools(IHooks hooks) {\n        if (hooks != this) revert InvalidPool();\n        _;\n    }\n\n    /**\n     * @dev Get the hook permissions to signal which hook functions are to be implemented.\n     *\n     * Used at deployment to validate the address correctly represents the expected permissions.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual returns (Hooks.Permissions memory permissions);\n\n    /**\n     * @dev Validate the hook address against the expected permissions.\n     */\n    function validateHookAddress(BaseHook hook) internal pure {\n        Hooks.validateHookPermissions(hook, getHookPermissions());\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external\n        virtual\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _beforeInitialize(sender, key, sqrtPriceX96);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeInitialize`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeInitialize(address, PoolKey calldata, uint160) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        virtual\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _afterInitialize(sender, key, sqrtPriceX96, tick);\n    }\n\n    /**\n     * @dev Hook implementation for `afterInitialize`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterInitialize(address, PoolKey calldata, uint160, int24) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _beforeAddLiquidity(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeAddLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeAddLiquidity(address, PoolKey calldata, ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _beforeRemoveLiquidity(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeRemoveLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeRemoveLiquidity(address, PoolKey calldata, ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta delta0,\n        BalanceDelta delta1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterAddLiquidity(sender, key, params, delta0, delta1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterAddLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterAddLiquidity(\n        address,\n        PoolKey calldata,\n        ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta delta0,\n        BalanceDelta delta1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterRemoveLiquidity(sender, key, params, delta0, delta1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterRemoveLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeSwap(address sender, PoolKey calldata key, SwapParams calldata params, bytes calldata hookData)\n        external\n        virtual\n        onlyPoolManager\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        return _beforeSwap(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeSwap`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeSwap(address, PoolKey calldata, SwapParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, int128) {\n        return _afterSwap(sender, key, params, delta, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterSwap`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterSwap(address, PoolKey calldata, SwapParams calldata, BalanceDelta, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, int128)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _beforeDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeDonate`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _afterDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterDonate`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n}\n",
        "LiquidityPenaltyHook.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.1) (src/general/LiquidityPenaltyHook.sol)\n\npragma solidity ^0.8.24;\n\n// Internal imports\nimport {BaseHook} from \"../base/BaseHook.sol\";\nimport {CurrencySettler} from \"../utils/CurrencySettler.sol\";\n\n// External imports\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {Position} from \"v4-core/src/libraries/Position.sol\";\nimport {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";\nimport {StateLibrary} from \"v4-core/src/libraries/StateLibrary.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {FullMath} from \"v4-core/src/libraries/FullMath.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {ModifyLiquidityParams} from \"v4-core/src/types/PoolOperation.sol\";\nimport {BalanceDelta, BalanceDeltaLibrary, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\n\n/**\n * @dev Just-in-Time (JIT) liquidity provisioning resistant hook.\n *\n * This hook disincentivizes JIT attacks by penalizing LP fee collection during {_afterRemoveLiquidity},\n * and disabling it during {_afterAddLiquidity} if liquidity was recently added to the position.\n * The penalty is donated to the pool's liquidity providers in range at the time of removal.\n *\n * See {_calculateLiquidityPenalty} for penalty calculation.\n *\n * NOTE: If a long term liquidity provider adds liquidity continuously, a pause of `blockNumberOffset`\n * before removing will be needed if `feesAccrued` collection is intended, in order to avoid getting\n * penalized by the JIT protection mechanism.\n *\n * WARNING: Altrough this hook achieves it's objective of protecting long term LP's in most scenarios,\n * low liquidity pools and long-tail assets may still be vulnerable depending on the configured `blockNumberOffset`.\n * Larger values of such are recommended in those cases in order to decrease the profitability of the attack.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.1_\n */\ncontract LiquidityPenaltyHook is BaseHook {\n    using CurrencySettler for Currency;\n    using StateLibrary for IPoolManager;\n    using SafeCast for uint256;\n\n    /**\n     * @dev The hook was attempted to be constructed with a `blockNumberOffset` lower than `MIN_BLOCK_NUMBER_OFFSET`.\n     */\n    error BlockNumberOffsetTooLow();\n\n    /**\n     * @dev A penalty was attempted to be applied and donated to LP's in range, but there aren't any.\n     */\n    error NoLiquidityToReceiveDonation();\n\n    uint48 public constant MIN_BLOCK_NUMBER_OFFSET = 1;\n\n    uint48 private immutable _blockNumberOffset;\n\n    mapping(PoolId poolId => mapping(bytes32 positionKey => uint48 blockNumber)) private _lastAddedLiquidityBlock;\n\n    mapping(PoolId poolId => mapping(bytes32 positionKey => BalanceDelta delta)) private _withheldFees;\n\n    /**\n     * @dev Sets the `PoolManager` address and the {getBlockNumberOffset}.\n     */\n    constructor(IPoolManager poolManager_, uint48 blockNumberOffset_) BaseHook(poolManager_) {\n        if (blockNumberOffset_ < MIN_BLOCK_NUMBER_OFFSET) revert BlockNumberOffsetTooLow();\n        _blockNumberOffset = blockNumberOffset_;\n    }\n\n    /**\n     * @dev Tracks `lastAddedLiquidityBlock` and withholds `feeDelta` if liquidity was added within the `blockNumberOffset` period.\n     * See {_afterRemoveLiquidity} for claiming the withheld fees back.\n     */\n    function _afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta, /* delta */\n        BalanceDelta feeDelta,\n        bytes calldata\n    ) internal virtual override returns (bytes4, BalanceDelta) {\n        PoolId poolId = key.toId();\n        bytes32 positionKey = Position.calculatePositionKey(sender, params.tickLower, params.tickUpper, params.salt);\n\n        // If liquidity was added recently within the `blockNumberOffset`, retain the feeDelta in this hook.\n        if (_getBlockNumber() - getLastAddedLiquidityBlock(poolId, positionKey) < getBlockNumberOffset()) {\n            _updateLastAddedLiquidityBlock(poolId, positionKey);\n            _takeFeesToHook(key, positionKey, feeDelta);\n\n            return (this.afterAddLiquidity.selector, feeDelta);\n        }\n\n        _updateLastAddedLiquidityBlock(poolId, positionKey);\n\n        return (this.afterAddLiquidity.selector, BalanceDeltaLibrary.ZERO_DELTA);\n    }\n\n    /**\n     * @dev Penalizes the collection of LP `feesDelta` and `withheldFees` after liquidity removal if liquidity was\n     * recently added to the position.\n     *\n     * NOTE: The penalty is applied on both `withheldFees` and `feeDelta` equally.\n     * Therefore, regardless of how many times liquidity was added to the position within the `blockNumberOffset` period,\n     * all accrued fees are penalized as if the liquidity was added only once during that period. This ensures that splitting\n     * liquidity additions within the `blockNumberOffset` period does not reduce or increase the penalty.\n     *\n     * IMPORTANT: The penalty is donated to the pool's liquidity providers in range at the time of liquidity removal,\n     * which may be different from the liquidity providers in range at the time of liquidity addition.\n     */\n    function _afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta, /* delta */\n        BalanceDelta feeDelta,\n        bytes calldata\n    ) internal virtual override returns (bytes4, BalanceDelta) {\n        PoolId poolId = key.toId();\n        bytes32 positionKey = Position.calculatePositionKey(sender, params.tickLower, params.tickUpper, params.salt);\n\n        // Receive back the `withheldFees` retained during previous liquidity additions within the `blockNumberOffset`.\n        BalanceDelta withheldFees = _settleFeesFromHook(key, positionKey);\n\n        // The total fees accrued by the LP are the sum of the `feeDelta` plus the `withheldFees`.\n        BalanceDelta totalFees = feeDelta + withheldFees;\n\n        // cache lastAddedLiquidity SLOAD\n        uint48 lastAddedLiquidityBlock = getLastAddedLiquidityBlock(poolId, positionKey);\n\n        if (\n            _getBlockNumber() - lastAddedLiquidityBlock < getBlockNumberOffset()\n                && totalFees != BalanceDeltaLibrary.ZERO_DELTA\n        ) {\n            BalanceDelta liquidityPenalty = _calculateLiquidityPenalty(totalFees, lastAddedLiquidityBlock);\n\n            // If there is a penalty to be applied but there are no active liquidity positions in range to\n            // receive the donation, then the liquidity removal is not possible and the offset must be awaited.\n            if (poolManager.getLiquidity(poolId) == 0) revert NoLiquidityToReceiveDonation();\n\n            poolManager.donate(\n                key, uint256(int256(liquidityPenalty.amount0())), uint256(int256(liquidityPenalty.amount1())), \"\"\n            );\n\n            return (this.afterRemoveLiquidity.selector, liquidityPenalty - withheldFees);\n        }\n\n        // If the liquidity removal was not penalized, return the withheld fees if any.\n        if (withheldFees != BalanceDeltaLibrary.ZERO_DELTA) {\n            BalanceDelta returnDelta = toBalanceDelta(-withheldFees.amount0(), -withheldFees.amount1());\n            return (this.afterRemoveLiquidity.selector, returnDelta);\n        }\n\n        return (this.afterRemoveLiquidity.selector, BalanceDeltaLibrary.ZERO_DELTA);\n    }\n\n    /**\n     * @dev Returns the current block number.\n     */\n    function _getBlockNumber() internal view virtual returns (uint48) {\n        return uint48(block.number);\n    }\n\n    /**\n     * @dev Updates the `lastAddedLiquidityBlock` for a liquidity position.\n     */\n    function _updateLastAddedLiquidityBlock(PoolId poolId, bytes32 positionKey) internal virtual {\n        _lastAddedLiquidityBlock[poolId][positionKey] = _getBlockNumber();\n    }\n\n    /**\n     * @dev Takes `feeDelta` from a liquidity position as `withheldFees` into this hook.\n     */\n    function _takeFeesToHook(PoolKey calldata key, bytes32 positionKey, BalanceDelta feeDelta) internal virtual {\n        PoolId poolId = key.toId();\n\n        _withheldFees[poolId][positionKey] = _withheldFees[poolId][positionKey] + feeDelta;\n\n        key.currency0.take(poolManager, address(this), uint256(uint128(feeDelta.amount0())), true);\n        key.currency1.take(poolManager, address(this), uint256(uint128(feeDelta.amount1())), true);\n    }\n\n    /**\n     * @dev Returns `withheldFees` from this hook to the liquidity provider.\n     */\n    function _settleFeesFromHook(PoolKey calldata key, bytes32 positionKey)\n        internal\n        virtual\n        returns (BalanceDelta withheldFees)\n    {\n        PoolId poolId = key.toId();\n\n        withheldFees = getWithheldFees(poolId, positionKey);\n\n        // Reset the `withheldFees`.\n        _withheldFees[poolId][positionKey] = BalanceDeltaLibrary.ZERO_DELTA;\n\n        // Settle the `withheldFees` for the liquidity position.\n        if (withheldFees.amount0() > 0) {\n            key.currency0.settle(poolManager, address(this), uint256(uint128(withheldFees.amount0())), true);\n        }\n        if (withheldFees.amount1() > 0) {\n            key.currency1.settle(poolManager, address(this), uint256(uint128(withheldFees.amount1())), true);\n        }\n    }\n\n    /**\n     * @dev Calculates the penalty to be applied to JIT liquidity provisioning.\n     *\n     * The penalty is calculated as a linear function of the block number difference between the `lastAddedLiquidityBlock` and the `currentBlockNumber`.\n     *\n     * The formula is:\n     * liquidityPenalty = feeDelta * ( 1 - (currentBlockNumber - lastAddedLiquidityBlock) / blockNumberOffset)\n     *\n     * The penalty is 100% at the block where liquidity was last added and 0% after the `blockNumberOffset` block.\n     *\n     * NOTE: Won't overflow if `currentBlockNumber - lastAddedLiquidityBlock < blockNumberOffset` is verified prior to calling this function.\n     */\n    function _calculateLiquidityPenalty(BalanceDelta feeDelta, uint48 lastAddedLiquidityBlock)\n        internal\n        virtual\n        returns (BalanceDelta liquidityPenalty)\n    {\n        uint48 currentBlockNumber = _getBlockNumber();\n        uint48 blockNumberOffset = getBlockNumberOffset();\n\n        unchecked {\n            uint256 amount0LiquidityPenalty = FullMath.mulDiv(\n                SafeCast.toUint128(feeDelta.amount0()),\n                blockNumberOffset - (currentBlockNumber - lastAddedLiquidityBlock), // won't overflow.\n                blockNumberOffset\n            );\n            uint256 amount1LiquidityPenalty = FullMath.mulDiv(\n                SafeCast.toUint128(feeDelta.amount1()),\n                blockNumberOffset - (currentBlockNumber - lastAddedLiquidityBlock), // won't overflow.\n                blockNumberOffset\n            );\n\n            // Although the amounts are returned as uint256, they must fit in int128, since they are fee rewards.\n            liquidityPenalty = toBalanceDelta(amount0LiquidityPenalty.toInt128(), amount1LiquidityPenalty.toInt128());\n        }\n    }\n\n    /**\n     * @dev The minimum time window (in blocks) that must pass after adding liquidity before it can be\n     * removed without penalty. During this period, JIT attacks are deterred through fee withholding\n     * and penalties. Higher values provide stronger JIT protection but may discourage legitimate LPs.\n     */\n    function getBlockNumberOffset() public view virtual returns (uint48) {\n        return _blockNumberOffset;\n    }\n\n    /**\n     * @dev Tracks the `withheldFees` for a liquidity position.\n     *\n     * `withheldFees` are UniswapV4's `feesAccrued` retained by this hook during liquidity addition if liquidity\n     * has been added within the `blockNumberOffset` time window. This is intended to disable fee collection during\n     * JIT liquidity provisioning attacks. See {_afterRemoveLiquidity} for claiming the fees back.\n     */\n    function getLastAddedLiquidityBlock(PoolId poolId, bytes32 positionKey) public view virtual returns (uint48) {\n        return _lastAddedLiquidityBlock[poolId][positionKey];\n    }\n\n    /**\n     * @dev Returns the `withheldFees` for a liquidity position.\n     */\n    function getWithheldFees(PoolId poolId, bytes32 positionKey) public view virtual returns (BalanceDelta) {\n        return _withheldFees[poolId][positionKey];\n    }\n\n    /**\n     * @dev Set the hooks permissions, specifically `afterAddLiquidity`, `afterAddLiquidityReturnDelta`, `afterRemoveLiquidity` and `afterRemoveLiquidityReturnDelta`.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: true,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: true,\n            beforeSwap: false,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: true,\n            afterRemoveLiquidityReturnDelta: true\n        });\n    }\n}\n"
    }
}