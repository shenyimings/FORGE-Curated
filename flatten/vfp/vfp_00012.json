{
    "vfp_id": "vfp_00012",
    "project_name": "cantina_coinbase_dec2025.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Non-Deterministic Bridged and Fee Amounts",
            "description": "The fee and payout amounts prepared in _onSend are derived from the campaign's on-chain balance at execution time, rather than from values that can be deterministically known or enforced by the sender on the source side of the bridge. This creates a situation where the bridgedAmount is calculated based on the current balance of the campaign minus previously allocated fees, and the feeAmount is derived as a percentage of that value. Because the bridgedAmount depends on the live balance of the campaign contract, it can be influenced externally between the time the sender initiates the bridge and when _onSend executes. The root cause is the reliance on dynamic, mutable state rather than sender-provided or locked-in values. An attacker or third party could manipulate the outcome by sending unsolicited funds to the campaign contract before the _onSend function executes. This could result in a larger payout than expected on the destination chain, potentially causing reverts in recipient contracts that enforce strict amount checks, leading to unexpected failures and reduced composability. While not a direct exploit leading to fund loss, it breaks assumptions about payout predictability and may affect integration reliability.\n",
            "severity": "Low",
            "location": [
                "BridgeReferralFees.sol::#L72-L112"
            ],
            "files": [
                "flywheel/src/hooks/BridgeReferralFees.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Prioritize using abi.decode for decoding bytes data for consistency and readability",
            "description": "The _onDistributeFees and _onUpdateMetadata functions perform explicit typecasting of bytes hookData to string, while other hook functions in the same contract use abi.decode for parsing input data. This inconsistency in decoding methods reduces code readability and maintainability for developers and auditors. The root cause is a lack of standardized data parsing practices across functions. Although both methods are functionally valid, using mixed approaches increases the cognitive load and risk of errors during future modifications. There is no direct security impact, but inconsistent patterns can obscure logic and make audits more difficult. The recommendation is to standardize on abi.decode for all such operations to improve clarity and consistency across the codebase. This is a best practice suggestion rather than a vulnerability.\n",
            "severity": "Informational",
            "location": [
                "BridgeReferralFees.sol::#L124",
                "BridgeReferralFees.sol::#L166"
            ],
            "files": [
                "flywheel/src/hooks/BridgeReferralFees.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Unused and redundant code",
            "description": "The BridgeReferralFees contract contains minor code quality issues that affect maintainability. Specifically, the ZeroBridgedAmount custom error is declared but never used in the contract, and the NATIVE_TOKEN address is redundantly defined instead of reusing the existing Constants.NATIVE_TOKEN constant. The root cause is incomplete cleanup during development or refactoring. Unused code elements like errors and duplicated constants increase code bloat and reduce clarity, making the contract harder to audit and maintain. While there is no direct security risk, such issues can mislead reviewers into thinking certain conditions are handled when they are not, or create confusion about the source of truth for shared values. Removing unused errors and consolidating constants improves code hygiene and reduces the chance of inconsistencies in future updates. This issue was acknowledged and fixed in commit a5056e3c.\n",
            "severity": "Informational",
            "location": [
                "BridgeReferralFees.sol::#L19",
                "BridgeReferralFees.sol::#L36-L37"
            ],
            "files": [
                "flywheel/src/hooks/BridgeReferralFees.sol"
            ]
        }
    ],
    "affected_files": {
        "BridgeReferralFees.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.29;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {BuilderCodes} from \"builder-codes/BuilderCodes.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\n\nimport {CampaignHooks} from \"../CampaignHooks.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {Flywheel} from \"../Flywheel.sol\";\n\n/// @title BridgeReferralFees\n///\n/// @notice This contract is used to configure bridge referral fees with Base builder codes. It is expected to be used in\n///         conjunction with the BuilderCodes contract that manages codes registration. Once registered, this contract\n///         allows the builder to start receiving referral fees for each usage of the code during a bridge operation that\n///         involves a transfer of tokens.\ncontract BridgeReferralFees is CampaignHooks {\n    /// @notice Address of the BuilderCodes contract\n    BuilderCodes public immutable BUILDER_CODES;\n\n    /// @notice Maximum fee basis points, capped at ~2.5% by uint8 size\n    uint8 public immutable MAX_FEE_BASIS_POINTS;\n\n    /// @notice Address of the metadata manager\n    address public immutable METADATA_MANAGER;\n\n    /// @notice URI prefix for the campaign\n    string public uriPrefix;\n\n    /// @notice Error thrown to enforce only one campaign can be initialized\n    error InvalidCampaignInitialization();\n\n    /// @notice Error thrown when the caller is not authorized\n    error Unauthorized();\n\n    /// @notice BridgeReferralFees constructor\n    ///\n    /// @param flywheel Address of the flywheel contract\n    /// @param builderCodes Address of the BuilderCodes contract\n    /// @param maxFeeBasisPoints Maximum fee basis points\n    /// @param metadataManager Address of the metadata manager\n    /// @param uriPrefix_ URI prefix for the campaign\n    constructor(\n        address flywheel,\n        address builderCodes,\n        uint8 maxFeeBasisPoints,\n        address metadataManager,\n        string memory uriPrefix_\n    ) CampaignHooks(flywheel) {\n        BUILDER_CODES = BuilderCodes(builderCodes);\n        MAX_FEE_BASIS_POINTS = maxFeeBasisPoints;\n        METADATA_MANAGER = metadataManager;\n        uriPrefix = uriPrefix_;\n    }\n\n    /// @inheritdoc CampaignHooks\n    function campaignURI(address campaign) external view override returns (string memory uri) {\n        return bytes(uriPrefix).length > 0 ? string.concat(uriPrefix, LibString.toHexStringChecksummed(campaign)) : \"\";\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onCreateCampaign(address campaign, uint256 nonce, bytes calldata hookData) internal pure override {\n        if (nonce != 0 || hookData.length > 0) revert InvalidCampaignInitialization();\n    }\n\n    /// @inheritdoc CampaignHooks\n    /// @dev User can receive new funds sent into the campaign minus an optional fee for the referring builder code\n    function _onSend(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        view\n        override\n        returns (Flywheel.Payout[] memory payouts, Flywheel.Distribution[] memory fees, bool sendFeesNow)\n    {\n        (address user, string memory code, uint8 feeBps) = abi.decode(hookData, (address, string, uint8));\n\n        // Calculate bridged amount as current balance minus total fees allocated and not yet sent\n        uint256 bridgedAmount = token == Constants.NATIVE_TOKEN ? campaign.balance : IERC20(token).balanceOf(campaign);\n        bridgedAmount -= FLYWHEEL.totalAllocatedFees(campaign, token);\n\n        // Set feeBps to MAX_FEE_BASIS_POINTS if feeBps exceeds MAX_FEE_BASIS_POINTS\n        feeBps = feeBps > MAX_FEE_BASIS_POINTS ? MAX_FEE_BASIS_POINTS : feeBps;\n\n        // Determine fallback key and payout address for builder code, zero-ing fees if failed to process\n        (bool success, bytes32 fallbackKey, address payoutAddress) = _processBuilderCode(code);\n        if (!success) feeBps = 0;\n\n        // Prepare payout\n        uint256 feeAmount = _safePercent(bridgedAmount, feeBps);\n        payouts = new Flywheel.Payout[](1);\n        payouts[0] = Flywheel.Payout({\n            recipient: user,\n            amount: bridgedAmount - feeAmount,\n            extraData: abi.encode(code, feeAmount)\n        });\n\n        // Prepare fee if applicable\n        if (feeAmount > 0) {\n            sendFeesNow = true;\n            fees = new Flywheel.Distribution[](1);\n            fees[0] = Flywheel.Distribution({\n                key: fallbackKey, // allow fee send to fallback to builder code\n                recipient: payoutAddress, // if payoutAddress misconfigured, builder loses their fee\n                amount: feeAmount,\n                extraData: \"\"\n            });\n        }\n    }\n\n    /// @inheritdoc CampaignHooks\n    ///\n    /// @dev Will only need to use this function if the initial fee send fails\n    function _onDistributeFees(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        view\n        override\n        returns (Flywheel.Distribution[] memory distributions)\n    {\n        // Determine key and payout address for builder code, zero-ing fees if failed to process\n        (bool success, bytes32 fallbackKey, address payoutAddress) = _processBuilderCode(string(hookData));\n        if (!success) return distributions;\n\n        distributions = new Flywheel.Distribution[](1);\n        distributions[0] = Flywheel.Distribution({\n            key: fallbackKey,\n            recipient: payoutAddress,\n            amount: FLYWHEEL.allocatedFee(campaign, token, fallbackKey),\n            extraData: \"\"\n        });\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onWithdrawFunds(address sender, address campaign, address token, bytes calldata hookData)\n        internal\n        pure\n        override\n        returns (Flywheel.Payout memory payout)\n    {\n        // Intended use is for funds to be sent into the campaign and atomically sent out to recipients\n        // If tokens are sent into the campaign outside of this scope on accident, anyone can take them (no access control for `onSend` hook)\n        // To keep the event feed clean for payouts/fees, we leave open the ability to withdraw funds directly\n        // Those wishing to take accidental tokens left in the campaign should find this function easier\n        payout = abi.decode(hookData, (Flywheel.Payout));\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onUpdateStatus(\n        address sender,\n        address campaign,\n        Flywheel.CampaignStatus oldStatus,\n        Flywheel.CampaignStatus newStatus,\n        bytes calldata hookData\n    ) internal pure override {\n        // This is a perpetual campaign, so it should always be active\n        // Campaigns are created as INACTIVE, so still need to let someone turn it on\n        if (newStatus != Flywheel.CampaignStatus.ACTIVE) revert Flywheel.InvalidCampaignStatus();\n    }\n\n    /// @inheritdoc CampaignHooks\n    function _onUpdateMetadata(address sender, address, bytes calldata hookData) internal override {\n        if (sender != METADATA_MANAGER) revert Unauthorized();\n        if (hookData.length > 0) uriPrefix = string(hookData);\n    }\n\n    /// @notice Processes a builder code and returns the key and payout address\n    ///\n    /// @param code Builder code\n    ///\n    /// @dev Wraps all calls to BuilderCodes in a try/catch to handle errors gracefully.\n    /// @dev Expected errors are if the code is not valid or registered.\n    ///\n    /// @return success True if the code is valid and registered\n    /// @return fallbackKey The fallback key to allocate fees to if fee distribution fails\n    /// @return payoutAddress The payout address for the builder code\n    function _processBuilderCode(string memory code)\n        internal\n        view\n        returns (bool success, bytes32 fallbackKey, address payoutAddress)\n    {\n        // Convert code to token ID for constant-size fallback key\n        try BUILDER_CODES.toTokenId(code) returns (uint256 tokenId) {\n            // Fetch payout address for token ID\n            try BUILDER_CODES.payoutAddress(tokenId) returns (address addr) {\n                return (true, bytes32(tokenId), addr);\n            } catch {\n                return (false, bytes32(0), address(0));\n            }\n        } catch {\n            return (false, bytes32(0), address(0));\n        }\n    }\n\n    /// @notice Calculates a percentage of an amount safely, avoiding overflow\n    ///\n    /// @param amount The amount to calculate the percentage of\n    /// @param basisPoints The basis points to calculate the percentage of\n    ///\n    /// @return value The percentage of the amount\n    function _safePercent(uint256 amount, uint8 basisPoints) internal pure returns (uint256 value) {\n        return (amount / 1e4) * basisPoints + ((amount % 1e4) * basisPoints) / 1e4;\n    }\n}\n"
    }
}