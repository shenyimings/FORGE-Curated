{
    "vfp_id": "vfp_00008",
    "project_name": "ackee-blockchain-cow-flash-loan-router-report.pdf",
    "findings": [
        {
            "id": 1,
            "category": {},
            "title": "I1: Documentation errors",
            "description": "1. **Description:** The Borrower.sol and LoansWithSettlement.sol contracts contain typographical and grammatical errors in their NatSpec comments, such as using \"An\" instead of \"A\" and \"fist\" instead of \"first\".\n\n2. **Cause:** Oversight during code documentation writing, likely due to lack of proofreading or automated linting for comments.\n\n3. **Exploitation:** These errors cannot be exploited in any way, as they do not affect runtime behavior or security logic.\n\n4. **Impact:** The impact is minimal, limited to reduced code readability and professionalism. However, clear documentation is important for maintainability and external developer understanding.\n",
            "severity": "Informational",
            "location": [
                "Borrower.sol",
                "LoansWithSettlement.sol"
            ],
            "files": [
                "flash-loan-router/src/mixin/Borrower.sol",
                "flash-loan-router/src/library/LoansWithSettlement.sol"
            ]
        }
    ],
    "affected_files": {
        "Borrower.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IBorrower} from \"../interface/IBorrower.sol\";\nimport {ICowSettlement} from \"../interface/ICowSettlement.sol\";\nimport {IFlashLoanRouter} from \"../interface/IFlashLoanRouter.sol\";\nimport {IERC20} from \"../vendored/IERC20.sol\";\nimport {SafeERC20} from \"../vendored/SafeERC20.sol\";\n\n/// @title Generic Borrower\n/// @author CoW DAO developers\n/// @notice An generic implementation of a borrower that is designed to make it\n/// easy to support different flash-loan providers with a simpler, dedicated\n/// contract that imports this.\n/// It handles fund management through ERC-20 approvals, call authentication,\n/// and router interactions.\nabstract contract Borrower is IBorrower {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IBorrower\n    IFlashLoanRouter public immutable router;\n    /// @inheritdoc IBorrower\n    ICowSettlement public immutable settlementContract;\n\n    /// @notice A function with this modifier can only be called in the context\n    /// of a CoW Protocol settlement.\n    modifier onlySettlementContract() {\n        require(msg.sender == address(settlementContract), \"Only callable in a settlement\");\n        _;\n    }\n\n    /// @notice Only the registered flash-loan router can call.\n    modifier onlyRouter() {\n        require(msg.sender == address(router), \"Not the router\");\n        _;\n    }\n\n    /// @param _router The router address that will be using this contract to\n    /// trigger flash loans and that will be called back by this contract.\n    constructor(IFlashLoanRouter _router) {\n        router = _router;\n        settlementContract = _router.settlementContract();\n    }\n\n    /// @inheritdoc IBorrower\n    function flashLoanAndCallBack(address lender, IERC20 token, uint256 amount, bytes calldata callBackData)\n        external\n        onlyRouter\n    {\n        triggerFlashLoan(lender, token, amount, callBackData);\n    }\n\n    /// @inheritdoc IBorrower\n    function approve(IERC20 token, address target, uint256 amount) external onlySettlementContract {\n        token.forceApprove(target, amount);\n    }\n\n    /// @notice Every flash-loan provider has different syntax for requesting a\n    /// flash loan. This function is intended to be realized in a concrete\n    /// implementation to support the specific logic of the provider.\n    /// @param lender The contract where the loan can be triggered.\n    /// @param token The token to borrow.\n    /// @param amount The amount of tokens to borrow.\n    /// @param callBackData Data to be sent back to this contract in the\n    /// flash-loan callback without any change.\n    function triggerFlashLoan(address lender, IERC20 token, uint256 amount, bytes calldata callBackData)\n        internal\n        virtual;\n\n    /// @notice This function is expected to be called in the concrete call-back\n    /// implementation that is requested by the supported flash-loan provider.\n    /// @param callBackData Data that was sent by the lender in the call back.\n    function flashLoanCallBack(bytes calldata callBackData) internal {\n        router.borrowerCallBack(callBackData);\n    }\n}\n",
        "LoansWithSettlement.sol": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IBorrower} from \"../interface/IBorrower.sol\";\nimport {IERC20} from \"../vendored/IERC20.sol\";\nimport {Bytes} from \"./Bytes.sol\";\nimport {Loan} from \"./Loan.sol\";\n\n/// @title Loans-with-settlement Library\n/// @author CoW DAO developers\n/// @notice A library describing a settlement execution through the flash-loan\n/// router and providing related utility functions.\n/// @dev This library is used to manage an encoded representation of a list of\n/// loans with a settlement as a bytes array. An abstract representation of it\n/// as a Solidity struct would be:\n///\n/// struct Data {\n///     Loan.Data[] loans;\n///     bytes settlement;\n/// }\n///\n/// The encoding of the bytes array for n loans is as follows:\n///\n/// Content: |-- number of loans, n --||-- ABI-encoded settlement --||-- n-th Loan  --||-- (n-1)-th Loan --|...|-- 1-st Loan  --|\n/// Length:  |<--     32 bytes     -->||<--    arbitrary size    -->||<--size(Loan)-->||<-- size(Loan)  -->|...|<--size(Loan)-->|\n///\n/// Loans are stored right to left so that it's easy to pop them in order\n/// without having to shift all remaining loans in memory.\nlibrary LoansWithSettlement {\n    using Bytes for bytes;\n    using Loan for Loan.EncodedData;\n\n    /// @notice The number of bytes reserved for the encoding of the loan count.\n    uint256 private constant LOAN_COUNT_SIZE = 32;\n\n    /// @notice The number of loans in the input.\n    /// @param loansWithSettlement The list of loans with settlement.\n    /// @return count Number of loans in the input.\n    function loanCount(bytes memory loansWithSettlement) internal pure returns (uint256 count) {\n        uint256 pointer = loansWithSettlement.memoryPointerToContent();\n        assembly (\"memory-safe\") {\n            count := mload(pointer)\n        }\n    }\n\n    /// @notice A collision-resistent identifier for the input list of loans\n    /// with settlement.\n    /// @param loansWithSettlement The list of loans with settlement to hash.\n    /// @return A collision-resistent identifier for the input.\n    function hash(bytes memory loansWithSettlement) internal pure returns (bytes32) {\n        return keccak256(loansWithSettlement);\n    }\n\n    /// @notice Store the list of loans and the settlement in a format\n    /// expected by this library.\n    /// @param loans List of requested loans.\n    /// @param settlement ABI-encoded settlement call data.\n    /// @return encodedLoansWithSettlement encoded representation of the input\n    /// parameters.\n    function encode(Loan.Data[] calldata loans, bytes calldata settlement)\n        internal\n        pure\n        returns (bytes memory encodedLoansWithSettlement)\n    {\n        uint256 encodedLength;\n        unchecked {\n            // Unchecked: the input values are bounded by the gas cost of\n            // including the data in a transaction.\n            encodedLength = LOAN_COUNT_SIZE + settlement.length + loans.length * Loan.ENCODED_LOAN_BYTE_SIZE;\n        }\n        encodedLoansWithSettlement = Bytes.allocate(encodedLength);\n\n        // Keep track of the fist yet-unwritten-to byte\n        uint256 head = encodedLoansWithSettlement.memoryPointerToContent();\n        assembly (\"memory-safe\") {\n            mstore(head, loans.length)\n        }\n\n        unchecked {\n            // Unchecked: `head` is bounded by `encodedLength`.\n            head += LOAN_COUNT_SIZE;\n        }\n        assembly (\"memory-safe\") {\n            calldatacopy(head, settlement.offset, settlement.length)\n        }\n\n        unchecked {\n            // Unchecked: `head` is bounded by `encodedLength`.\n            head += settlement.length;\n        }\n        for (uint256 i = loans.length; i > 0;) {\n            unchecked {\n                // Unchecked: loop condition prevents underflows.\n                i--;\n            }\n            Loan.EncodedData encodedLoan = Loan.EncodedData.wrap(head);\n            encodedLoan.store(loans[i]);\n            unchecked {\n                // Unchecked: `head` is bounded by `encodedLength`.\n                head += Loan.ENCODED_LOAN_BYTE_SIZE;\n            }\n        }\n    }\n\n    /// @notice Remove the next loan that is to be processed from the encoded\n    /// input data and return its parameter.\n    /// @dev The element are popped from the first to the last in the order they\n    /// were presented *before encoding*.\n    /// @param loansWithSettlement The encoded data from which to remove the\n    /// next loan. It must be a valid encoding of loans with settlement of\n    /// length at least one.\n    /// @return amount The amount to be borrowed (see `Loan.Data`).\n    /// @return borrower The address of the borrower contract (see `Loan.Data`).\n    /// @return lender The lender address (see `Loan.Data`).\n    /// @return token The token to borrow (see `Loan.Data`).\n    function popLoan(bytes memory loansWithSettlement)\n        internal\n        pure\n        returns (uint256 amount, IBorrower borrower, address lender, IERC20 token)\n    {\n        uint256 count = loanCount(loansWithSettlement);\n        require(count > 0, \"No loans available\");\n\n        uint256 updatedLoansWithSettlementLength;\n        unchecked {\n            // Unchecked: there is at least a loan.\n            count = count - 1;\n            // Unchecked: loansWithSettlement is properly encoded and has a\n            // loan, meaning that it has at least length\n            // `Loan.ENCODED_LOAN_BYTE_SIZE`\n            updatedLoansWithSettlementLength = loansWithSettlement.length - Loan.ENCODED_LOAN_BYTE_SIZE;\n        }\n\n        uint256 loansWithSettlementPointer = loansWithSettlement.memoryPointerToContent();\n        uint256 loanPointer;\n        unchecked {\n            // Unchecked: the pointer refers to a memory location inside\n            // loansWithSettlement, which is assumed to be a valid array.\n            loanPointer = loansWithSettlementPointer + updatedLoansWithSettlementLength;\n        }\n        Loan.EncodedData encodedLoan = Loan.EncodedData.wrap(loanPointer);\n\n        assembly (\"memory-safe\") {\n            // Efficiently reduce the size of the bytes array.\n            // The length of a dynamic array is stored at the first slot of the\n            // array and followed by the array elements.\n            // Memory is never freed, so the remaining unused memory won't\n            // affect the compiler.\n            // <https://docs.soliditylang.org/en/v0.8.28/internals/layout_in_memory.html>\n            mstore(loansWithSettlement, updatedLoansWithSettlementLength)\n            // Update first encoded element: the loan count.\n            mstore(loansWithSettlementPointer, count)\n        }\n\n        return encodedLoan.decode();\n    }\n\n    /// @notice Takes an input value with no encoded loans, destroys its content\n    /// in memory, and extracts the settlement stored as part of its encoding.\n    /// @dev This function overwrites the low-level memory representation of\n    /// the input value, meaning that trying to use the input after calling\n    /// this function leads to broken code. This functon takes full ownership\n    /// of the memory representing the input.\n    /// @param loansWithSettlement The encoded data representing loans with a\n    /// settlement. It must have valid encoding. This value will be destroyed\n    /// by calling this function and must not be used anywhere else.\n    /// @return settlement The settlement encoded in the input.\n    function destroyToSettlement(bytes memory loansWithSettlement) internal pure returns (bytes memory settlement) {\n        require(loanCount(loansWithSettlement) == 0, \"Pending loans\");\n        // We assume that the input is loans with a settlement, encoded as\n        // expected by this library. The settlement data is a subarray of the\n        // input: if we accept to override the input data with arbitrary data,\n        // we can carve out a valid ABI-encoded bytes array representing the\n        // settlement.\n        uint256 settlementLength;\n        unchecked {\n            // Unchecked: we assume `loansWithSettlement` to be valid encoded\n            // loans with settlement. Since there are no loans, this means that\n            // it comprises the loan count plus the settlement data, which is at\n            // least zero.\n            settlementLength = loansWithSettlement.length - LOAN_COUNT_SIZE;\n        }\n\n        // We rely on the fact that LOAN_COUNT_SIZE is 32, exactly the size\n        // needed to store the length of a memory array.\n        uint256 settlementPointer = loansWithSettlement.memoryPointerToContent();\n\n        assembly (\"memory-safe\") {\n            mstore(settlementPointer, settlementLength)\n            settlement := settlementPointer\n        }\n    }\n}\n"
    }
}