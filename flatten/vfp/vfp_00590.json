{
    "vfp_id": "vfp_00590",
    "project_name": "cantina_maker_endgame_jan2026.pdf",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Incorrect Constant Naming and Missing Test Validation",
            "description": "The vulnerability involves two minor issues in the test and integration code: (1) incorrect naming of constants REWARDS_LSSKY_SKY and REWARDS_DIST_LSSKY_SKY, which should be REWARDS_USDS_SKY and REWARDS_DIST_USDS_SKY respectively, leading to potential confusion in code maintenance and readability; and (2) the test at line 358â€“364 does not verify that VestedRewardsDistributionJobLike and chainlog were set correctly, which could result in undetected misconfigurations during deployment. The root cause is insufficient attention to detail in naming conventions and incomplete test coverage. While this does not pose a direct security risk, it could lead to operational errors or misinterpretations during audits or upgrades. An attacker could potentially exploit the ambiguity in configurations if not corrected, though the impact is minimal. The impact is limited to code clarity and reliability of test assertions, with no direct financial or functional consequences.\n",
            "severity": "Informational",
            "location": [
                "TreasuryFundedFarmingInit.t.integration.sol::#L87-L89",
                "TreasuryFundedFarmingInit.t.sol::#L358-L364"
            ],
            "files": [
                "endgame-toolkit/script/dependencies/treasury-funded-farms/TreasuryFundedFarmingInit.t.sol",
                "endgame-toolkit/script/dependencies/treasury-funded-farms/TreasuryFundedFarmingInit.t.integration.sol"
            ]
        }
    ],
    "affected_files": {
        "TreasuryFundedFarmingInit.t.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.16;\n\nimport {DssTest} from \"dss-test/DssTest.sol\";\nimport {StakingRewardsDeploy, StakingRewardsDeployParams} from \"../StakingRewardsDeploy.sol\";\nimport {\n    VestedRewardsDistributionDeploy,\n    VestedRewardsDistributionDeployParams\n} from \"../VestedRewardsDistributionDeploy.sol\";\nimport {\n    TreasuryFundedFarmingInit,\n    FarmingInitParams,\n    FarmingUpdateVestParams,\n    FarmingUpdateVestResult\n} from \"./TreasuryFundedFarmingInit.sol\";\n\ncontract TreasuryFundedFarmingInitTest is DssTest {\n    ChainlogLike chainlog;\n    MockSpell spell;\n    address pause;\n    address pauseProxy;\n    address lssky;\n    address sky;\n    address usds;\n    address vest;\n    address lockstakeEngine;\n    address distJob;\n    FarmingInitParams lfp;\n    FarmingInitParams fp;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\");\n        chainlog = ChainlogLike(0xdA0Ab1e0017DEbCd72Be8599041a2aa3bA7e740F);\n\n        pause = chainlog.getAddress(\"MCD_PAUSE\");\n        pauseProxy = chainlog.getAddress(\"MCD_PAUSE_PROXY\");\n        lockstakeEngine = chainlog.getAddress(\"LOCKSTAKE_ENGINE\");\n        lssky = chainlog.getAddress(\"LOCKSTAKE_SKY\");\n        sky = chainlog.getAddress(\"SKY\");\n        usds = chainlog.getAddress(\"USDS\");\n        vest = chainlog.getAddress(\"MCD_VEST_SKY_TREASURY\");\n        distJob = chainlog.getAddress(\"CRON_REWARDS_DIST_JOB\");\n\n        lfp = FarmingInitParams({\n            stakingToken: lssky,\n            rewardsToken: sky,\n            rewards: address(0),\n            rewardsKey: \"REWARDS_LSSKY_SKY\",\n            dist: address(0),\n            distKey: \"REWARDS_DIST_LSSKY_SKY\",\n            distJob: distJob,\n            distJobInterval: 7 days - 1 hours,\n            vest: vest,\n            vestTot: 2_400_000 * 10 ** 18,\n            vestBgn: block.timestamp - 7 days,\n            vestTau: 365 days\n        });\n        lfp.rewards = StakingRewardsDeploy.deploy(\n            StakingRewardsDeployParams({\n                owner: pauseProxy, stakingToken: lfp.stakingToken, rewardsToken: lfp.rewardsToken\n            })\n        );\n        lfp.dist = VestedRewardsDistributionDeploy.deploy(\n            VestedRewardsDistributionDeployParams({\n                deployer: address(this), owner: pauseProxy, vest: lfp.vest, rewards: lfp.rewards\n            })\n        );\n\n        fp = FarmingInitParams({\n            stakingToken: usds,\n            rewardsToken: sky,\n            rewards: address(0),\n            rewardsKey: \"REWARDS_LSSKY_SKY\",\n            dist: address(0),\n            distKey: \"REWARDS_DIST_LSSKY_SKY\",\n            distJob: distJob,\n            distJobInterval: 7 days - 1 hours,\n            vest: vest,\n            vestTot: 2_400_000 * 10 ** 18,\n            vestBgn: block.timestamp - 7 days,\n            vestTau: 365 days\n        });\n        fp.rewards = StakingRewardsDeploy.deploy(\n            StakingRewardsDeployParams({\n                owner: pauseProxy, stakingToken: fp.stakingToken, rewardsToken: fp.rewardsToken\n            })\n        );\n        fp.dist = VestedRewardsDistributionDeploy.deploy(\n            VestedRewardsDistributionDeployParams({\n                deployer: address(this), owner: pauseProxy, vest: fp.vest, rewards: fp.rewards\n            })\n        );\n\n        spell = new MockSpell();\n    }\n\n    struct CheckInitFarmValuesBefore {\n        uint256 allowance;\n        uint256 cap;\n        uint256 vestCount;\n    }\n\n    function testFarm_init() public {\n        CheckInitFarmValuesBefore memory b = _checkFarm_init_beforeSpell(fp);\n\n        // Simulate spell casting\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        _checkFarm_init_afterSpell(fp, b);\n    }\n\n    function testFarm_init_whenVestingRateIsGreaterThanCurrentVestCap() public {\n        CheckInitFarmValuesBefore memory b;\n\n        // Force `vest.cap()` to return a lower value\n        {\n            vm.mockCall(address(fp.vest), abi.encodeWithSignature(\"cap()\"), abi.encode(uint256(0)));\n\n            b = _checkFarm_init_beforeSpell(fp);\n\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        _checkFarm_init_afterSpell(fp, b);\n    }\n\n    function testRevert_farm_init_whenMismatchingParams() public {\n        // vest.czar != pauseProxy\n        {\n            vm.mockCall(address(fp.vest), abi.encodeWithSignature(\"czar()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // vest.gem != fp.rewardsToken\n        {\n            vm.mockCall(address(fp.vest), abi.encodeWithSignature(\"gem()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // rewards.stakingToken() != fp.stakingToken\n        {\n            vm.mockCall(address(fp.rewards), abi.encodeWithSignature(\"stakingToken()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // rewards.rewardsToken() != fp.rewardsToken\n        {\n            vm.mockCall(address(fp.rewards), abi.encodeWithSignature(\"rewardsToken()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // rewards.rewardRate != 0\n        {\n            vm.mockCall(address(fp.rewards), abi.encodeWithSignature(\"rewardRate()\"), abi.encode(uint256(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // rewards.rewardsDistribution != address(0)\n        {\n            vm.mockCall(\n                address(fp.rewards), abi.encodeWithSignature(\"rewardsDistribution()\"), abi.encode(address(0x1337))\n            );\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // rewards.owner() != MCD_PAUSE_PROXY\n        {\n            vm.mockCall(address(fp.rewards), abi.encodeWithSignature(\"owner()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // dist.gem != fp.rewardsToken\n        {\n            vm.mockCall(address(fp.dist), abi.encodeWithSignature(\"gem()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // dist.dssVest != fp.vest\n        {\n            vm.mockCall(address(fp.dist), abi.encodeWithSignature(\"dssVest()\"), abi.encode(address(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n\n        // dist.vestId != 0\n        {\n            vm.mockCall(address(fp.dist), abi.encodeWithSignature(\"vestId()\"), abi.encode(uint256(0x1337)));\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n            vm.clearMockedCalls();\n        }\n    }\n\n    function testLockstakeFarm_init() public {\n        CheckInitFarmValuesBefore memory b = _checkFarm_init_beforeSpell(lfp);\n\n        assertEq(\n            uint8(LockstakeEngineLike(lockstakeEngine).farms(lfp.rewards)),\n            uint8(LockstakeEngineLike.FarmStatus.UNSUPPORTED),\n            \"before: lockstake engine should not have rewards\"\n        );\n\n        // Simulate spell casting\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initLockstakeFarm, (lfp, lockstakeEngine)));\n\n        _checkFarm_init_afterSpell(lfp, b);\n\n        assertEq(\n            uint8(LockstakeEngineLike(lockstakeEngine).farms(lfp.rewards)),\n            uint8(LockstakeEngineLike.FarmStatus.ACTIVE),\n            \"after: lockstake engine should have rewards\"\n        );\n    }\n\n    function testRevert_lockstakeFarm_init_whenStakingTokenIsNotLssky() public {\n        lfp.stakingToken = usds;\n\n        // Simulate spell casting\n        vm.prank(pause);\n        vm.expectRevert(\"ds-pause-delegatecall-error\");\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initLockstakeFarm, (lfp, lockstakeEngine)));\n    }\n\n    function _checkFarm_init_beforeSpell(FarmingInitParams memory p)\n        internal\n        view\n        returns (CheckInitFarmValuesBefore memory b)\n    {\n        // Sanity checks\n        assertEq(DssVestTransferrableLike(p.vest).gem(), sky, \"before: gem mismatch\");\n\n        assertEq(StakingRewardsLike(p.rewards).stakingToken(), p.stakingToken, \"before: staking token mismatch\");\n        assertEq(StakingRewardsLike(p.rewards).rewardsToken(), p.rewardsToken, \"before: rewards token mismatch\");\n        assertEq(StakingRewardsLike(p.rewards).rewardRate(), 0, \"before: reward rate mismatch\");\n        assertEq(StakingRewardsLike(p.rewards).owner(), pauseProxy, \"before: rewards owner mismatch\");\n        assertEq(\n            StakingRewardsLike(p.rewards).rewardsDistribution(), address(0), \"before: rewards distribution mismatch\"\n        );\n\n        assertEq(VestedRewardsDistributionLike(p.dist).gem(), p.rewardsToken, \"before: gem mismatch\");\n        assertEq(VestedRewardsDistributionLike(p.dist).dssVest(), p.vest, \"before: vest mismatch\");\n        assertEq(VestedRewardsDistributionLike(p.dist).vestId(), 0, \"before: vest id already set\");\n        assertEq(VestedRewardsDistributionLike(p.dist).stakingRewards(), p.rewards, \"before: staking rewards mismatch\");\n\n        assertFalse(VestedRewardsDistributionJobLike(p.distJob).has(p.dist), \"before: job should not have dist\");\n\n        // Initial state\n        b.allowance = ERC20Like(p.rewardsToken).allowance(pauseProxy, p.vest);\n        b.cap = DssVestTransferrableLike(p.vest).cap();\n        b.vestCount = DssVestTransferrableLike(p.vest).ids();\n    }\n\n    function _checkFarm_init_afterSpell(FarmingInitParams memory p, CheckInitFarmValuesBefore memory b) internal view {\n        assertEq(StakingRewardsLike(p.rewards).rewardRate(), p.vestTot / p.vestTau, \"after: should set reward rate\");\n        assertEq(\n            StakingRewardsLike(p.rewards).rewardsDistribution(),\n            address(p.dist),\n            \"after: should set rewards distribution\"\n        );\n\n        assertEq(\n            VestedRewardsDistributionLike(p.dist).vestId(), b.vestCount + 1, \"after: should set the correct vestId\"\n        );\n        // Should distribute only if vesting period has already started\n        if (p.vestBgn < block.timestamp) {\n            assertEq(\n                VestedRewardsDistributionLike(p.dist).lastDistributedAt(),\n                block.timestamp,\n                \"after: should set the correct vestId\"\n            );\n        }\n\n        assertTrue(VestedRewardsDistributionJobLike(p.distJob).has(p.dist), \"after: job should have dist\");\n\n        assertEq(\n            DssVestTransferrableLike(p.vest).ids(),\n            b.vestCount + 1,\n            \"after: should have created exactly 1 new vesting stream\"\n        );\n        assertEq(\n            DssVestTransferrableLike(p.vest).unpaid(b.vestCount + 1),\n            0,\n            \"after: should have distributed any unpaid amount\"\n        );\n        // Note: if there was a distribution, the allowance would've been decreased by the paid amount\n        uint256 expectedAllowance = b.allowance + p.vestTot - DssVestTransferrableLike(p.vest).rxd(b.vestCount + 1);\n        assertEq(\n            ERC20Like(sky).allowance(pauseProxy, p.vest), expectedAllowance, \"after: should set the correct allowance\"\n        );\n\n        // Adds 10% buffer\n        uint256 expectedRateWithBuffer = (11 * p.vestTot) / (10 * p.vestTau);\n        if (expectedRateWithBuffer > b.cap) {\n            assertEq(\n                DssVestTransferrableLike(p.vest).cap(), expectedRateWithBuffer, \"after: should set the correct cap\"\n            );\n        }\n    }\n\n    struct CheckUpdateFarmVestValuesBefore {\n        uint256 allowance;\n        uint256 vestCount;\n        uint256 prevVestId;\n        uint256 prevVestTot;\n        uint256 prevVestRxd;\n        uint256 prevUnpaid;\n        uint256 rewardRate;\n    }\n\n    function testFarm_updateVest() public {\n        // First initialize the farm\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Create update params with new vesting schedule\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist,\n            vestTot: 3_600_000 * 10 ** 18, // Increased amount\n            vestBgn: block.timestamp + 1 days, // Start tomorrow\n            vestTau: 180 days // Shorter vesting period\n        });\n\n        CheckUpdateFarmVestValuesBefore memory b = _checkFarm_updateVest_beforeSpell(updateParams);\n\n        // Simulate spell casting for update\n        vm.prank(pause);\n        bytes memory returnData =\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n        FarmingUpdateVestResult memory result = abi.decode(returnData, (FarmingUpdateVestResult));\n\n        _checkFarm_updateVest_afterSpell(updateParams, b, result);\n    }\n\n    function testFarm_updateVest_withPreviousUnpaidAmount() public {\n        // First initialize the farm with past start time to generate unpaid amount\n        fp.vestBgn = block.timestamp - 7 days; // Started a week ago\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Fast forward to accumulate some unpaid amount\n        vm.warp(block.timestamp + 3 days);\n\n        // Create update params\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist,\n            vestTot: 4_800_000 * 10 ** 18, // Even larger amount\n            vestBgn: block.timestamp - 1 days, // Start yesterday to create immediate unpaid amount\n            vestTau: 90 days // Much shorter vesting period\n        });\n\n        CheckUpdateFarmVestValuesBefore memory b = _checkFarm_updateVest_beforeSpell(updateParams);\n\n        // Ensure there's unpaid amount in previous vest\n        assertGt(b.prevUnpaid, 0, \"Previous vest should have unpaid amount for test\");\n\n        // Simulate spell casting for update\n        vm.prank(pause);\n        bytes memory returnData =\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n        FarmingUpdateVestResult memory result = abi.decode(returnData, (FarmingUpdateVestResult));\n\n        _checkFarm_updateVest_afterSpell(updateParams, b, result);\n\n        // Verify both previous and new distributions happened\n        assertGt(result.prevDistributedAmount, 0, \"Should have distributed previous unpaid amount\");\n        assertGt(result.distributedAmount, 0, \"Should have distributed new unpaid amount\");\n    }\n\n    function testFarm_updateVest_whenCapNeedsAdjustment() public {\n        // Initialize farm\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Record original cap and mock low cap to force adjustment\n        address vestAddr = VestedRewardsDistributionLike(fp.dist).dssVest();\n        uint256 originalCap = DssVestTransferrableLike(vestAddr).cap();\n        vm.mockCall(address(vestAddr), abi.encodeWithSignature(\"cap()\"), abi.encode(uint256(1)));\n\n        // Create update params with high rate requiring cap adjustment\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist,\n            vestTot: 100_000_000 * 10 ** 18, // Very high amount to force cap adjustment\n            vestBgn: block.timestamp + 1 days,\n            vestTau: 1 days // Very short period = very high rate\n        });\n\n        uint256 expectedRateWithBuffer = (110 * updateParams.vestTot) / (100 * updateParams.vestTau);\n\n        // Simulate spell casting for update\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n\n        vm.clearMockedCalls();\n\n        // Verify the vest was created successfully\n        uint256 newVestId = VestedRewardsDistributionLike(fp.dist).vestId();\n        assertGt(newVestId, 0, \"New vest should be created\");\n\n        // Verify the cap was adjusted to the expected rate with buffer\n        uint256 newCap = DssVestTransferrableLike(vestAddr).cap();\n        assertEq(newCap, expectedRateWithBuffer, \"Cap should be adjusted to expected rate with buffer\");\n        assertGt(newCap, originalCap, \"New cap should be greater than original cap\");\n    }\n\n    function testRevert_updateVest_whenVestCzarMismatch() public {\n        // Initialize farm first\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Mock vest.czar() to return wrong address\n        address vestAddr = VestedRewardsDistributionLike(fp.dist).dssVest();\n        vm.mockCall(address(vestAddr), abi.encodeWithSignature(\"czar()\"), abi.encode(address(0x1337)));\n\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist, vestTot: 1_200_000 * 10 ** 18, vestBgn: block.timestamp + 1 days, vestTau: 90 days\n        });\n\n        vm.expectRevert(\"ds-pause-delegatecall-error\");\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n\n        vm.clearMockedCalls();\n    }\n\n    function testFarm_updateVest_allowanceCalculation() public {\n        // Initialize farm\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Fast forward to create some received amount\n        vm.warp(block.timestamp + 30 days);\n\n        address vestAddr = VestedRewardsDistributionLike(fp.dist).dssVest();\n        address rewardsToken = VestedRewardsDistributionLike(fp.dist).gem();\n        uint256 prevVestId = VestedRewardsDistributionLike(fp.dist).vestId();\n\n        // Record state before update\n        uint256 prevVestTot = DssVestTransferrableLike(vestAddr).tot(prevVestId);\n\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist,\n            vestTot: 3_000_000 * 10 ** 18, // Different amount to test allowance calculation\n            vestBgn: block.timestamp + 1 days,\n            vestTau: 200 days\n        });\n\n        // Force some distribution to happen before update\n        VestedRewardsDistributionLike(fp.dist).distribute();\n        uint256 prevVestRxdAfterDist = DssVestTransferrableLike(vestAddr).rxd(prevVestId);\n\n        // Record allowance after the distribution to get accurate baseline\n        uint256 prevAllowanceAfterDist = ERC20Like(rewardsToken).allowance(pauseProxy, vestAddr);\n\n        // Update vest\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n\n        // Check that allowance was correctly calculated\n        uint256 currAllowanceAfter = ERC20Like(rewardsToken).allowance(pauseProxy, vestAddr);\n        uint256 expectedChange = updateParams.vestTot - (prevVestTot - prevVestRxdAfterDist);\n        uint256 expectedAllowance = prevAllowanceAfterDist + expectedChange;\n\n        // Use 1% tolerance for allowance calculation verification\n        assertApproxEqRel(\n            currAllowanceAfter,\n            expectedAllowance,\n            1e16, // 1% tolerance (1e18 = 100%)\n            \"Allowance calculation should be approximately correct\"\n        );\n    }\n\n    function testFarm_updateVest_vestCreationParameters() public {\n        // Initialize farm\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        uint256 customVestTot = 5_000_000 * 10 ** 18;\n        uint256 customVestBgn = block.timestamp + 7 days;\n        uint256 customVestTau = 45 days;\n\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist, vestTot: customVestTot, vestBgn: customVestBgn, vestTau: customVestTau\n        });\n\n        address vestAddr = VestedRewardsDistributionLike(fp.dist).dssVest();\n        uint256 vestCountBefore = DssVestTransferrableLike(vestAddr).ids();\n\n        // Update vest\n        vm.prank(pause);\n        bytes memory returnData =\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n        FarmingUpdateVestResult memory result = abi.decode(returnData, (FarmingUpdateVestResult));\n\n        // Verify new vest has correct parameters\n        uint256 newVestId = result.vestId;\n        assertEq(newVestId, vestCountBefore + 1, \"Should create exactly one new vest\");\n        assertEq(DssVestTransferrableLike(vestAddr).tot(newVestId), customVestTot, \"New vest should have correct total\");\n        assertEq(\n            DssVestTransferrableLike(vestAddr).bgn(newVestId), customVestBgn, \"New vest should have correct begin time\"\n        );\n        assertEq(\n            DssVestTransferrableLike(vestAddr).fin(newVestId),\n            customVestBgn + customVestTau,\n            \"New vest should have correct finish time\"\n        );\n\n        // Verify the vest is properly linked to distribution\n        assertEq(VestedRewardsDistributionLike(fp.dist).vestId(), newVestId, \"Distribution should point to new vest\");\n    }\n\n    function testRevert_updateVest_whenInvalidParams() public {\n        // Initialize farm first\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Test vestTot = 0\n        {\n            FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n                dist: fp.dist,\n                vestTot: 0, // Invalid\n                vestBgn: block.timestamp + 1 days,\n                vestTau: 90 days\n            });\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n        }\n\n        // Test vestTau = 0 (division by zero risk)\n        {\n            FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n                dist: fp.dist,\n                vestTot: 1_200_000 * 10 ** 18,\n                vestBgn: block.timestamp + 1 days,\n                vestTau: 0 // Invalid - would cause division by zero\n            });\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n        }\n\n        // Test dist with vestId = 0 (not initialized)\n        {\n            // Deploy a new distribution that hasn't been initialized\n            address uninitDist = VestedRewardsDistributionDeploy.deploy(\n                VestedRewardsDistributionDeployParams({\n                    deployer: address(this), owner: pauseProxy, vest: fp.vest, rewards: fp.rewards\n                })\n            );\n\n            FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n                dist: uninitDist, // This dist has vestId = 0\n                vestTot: 1_200_000 * 10 ** 18,\n                vestBgn: block.timestamp + 1 days,\n                vestTau: 90 days\n            });\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n        }\n\n        // Test vest gem mismatch\n        {\n            address vestAddr = VestedRewardsDistributionLike(fp.dist).dssVest();\n            vm.mockCall(address(vestAddr), abi.encodeWithSignature(\"gem()\"), abi.encode(address(0x1337)));\n\n            FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n                dist: fp.dist, vestTot: 1_200_000 * 10 ** 18, vestBgn: block.timestamp + 1 days, vestTau: 90 days\n            });\n\n            vm.expectRevert(\"ds-pause-delegatecall-error\");\n            vm.prank(pause);\n            ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n\n            vm.clearMockedCalls();\n        }\n    }\n\n    function _checkFarm_updateVest_beforeSpell(FarmingUpdateVestParams memory p)\n        internal\n        view\n        returns (CheckUpdateFarmVestValuesBefore memory b)\n    {\n        address vestAddr = VestedRewardsDistributionLike(p.dist).dssVest();\n        address rewardsToken = VestedRewardsDistributionLike(p.dist).gem();\n\n        b.allowance = ERC20Like(rewardsToken).allowance(pauseProxy, vestAddr);\n        b.vestCount = DssVestTransferrableLike(vestAddr).ids();\n        b.prevVestId = VestedRewardsDistributionLike(p.dist).vestId();\n        b.prevVestTot = DssVestTransferrableLike(vestAddr).tot(b.prevVestId);\n        b.prevVestRxd = DssVestTransferrableLike(vestAddr).rxd(b.prevVestId);\n        b.prevUnpaid = DssVestTransferrableLike(vestAddr).unpaid(b.prevVestId);\n        b.rewardRate = StakingRewardsLike(VestedRewardsDistributionLike(p.dist).stakingRewards()).rewardRate();\n\n        // Verify previous vest exists\n        assertGt(b.prevVestId, 0, \"before: should have existing vest to update\");\n    }\n\n    function _checkFarm_updateVest_afterSpell(\n        FarmingUpdateVestParams memory p,\n        CheckUpdateFarmVestValuesBefore memory b,\n        FarmingUpdateVestResult memory result\n    ) internal view {\n        address vestAddr = VestedRewardsDistributionLike(p.dist).dssVest();\n        address rewardsToken = VestedRewardsDistributionLike(p.dist).gem();\n        address stakingRewards = VestedRewardsDistributionLike(p.dist).stakingRewards();\n\n        // Verify result values\n        assertEq(result.prevVestId, b.prevVestId, \"after: should return correct previous vestId\");\n        assertEq(result.prevDistributedAmount, b.prevUnpaid, \"after: should return correct previous distributed amount\");\n\n        // Verify new vest was created\n        assertEq(DssVestTransferrableLike(vestAddr).ids(), b.vestCount + 1, \"after: should create exactly one new vest\");\n        assertEq(result.vestId, b.vestCount + 1, \"after: should return correct new vestId\");\n\n        // Verify new vest is set in distribution\n        assertEq(\n            VestedRewardsDistributionLike(p.dist).vestId(), result.vestId, \"after: should update vestId in distribution\"\n        );\n\n        // Verify previous vest was yanked (unpaid should be 0)\n        assertEq(DssVestTransferrableLike(vestAddr).unpaid(b.prevVestId), 0, \"after: yanked vest should have 0 unpaid\");\n\n        // Verify allowance was adjusted correctly\n        uint256 expectedAllowance = b.allowance + p.vestTot - (b.prevVestTot - b.prevVestRxd) - result.distributedAmount;\n        assertEq(\n            ERC20Like(rewardsToken).allowance(pauseProxy, vestAddr),\n            expectedAllowance,\n            \"after: should adjust allowance correctly\"\n        );\n\n        // Note: The reward rate in StakingRewards is updated during distribution, not immediately\n        // We verify that the new vesting parameters are in place, which will affect future distributions\n        uint256 currentRewardRate = StakingRewardsLike(stakingRewards).rewardRate();\n        // The reward rate should be positive only if there was a distribution\n        if (result.distributedAmount > 0) {\n            assertGt(currentRewardRate, 0, \"after: reward rate should be positive when distribution occurred\");\n        }\n\n        // Verify distributions occurred if there was unpaid amount\n        if (p.vestBgn < block.timestamp) {\n            assertEq(\n                VestedRewardsDistributionLike(p.dist).lastDistributedAt(),\n                block.timestamp,\n                \"after: should have distributed if vesting already started\"\n            );\n        }\n    }\n}\n\ncontract MockSpell {\n    function initFarm(FarmingInitParams memory p) public {\n        TreasuryFundedFarmingInit.initFarm(p);\n    }\n\n    function initLockstakeFarm(FarmingInitParams memory p, address lockstakeEngine) public {\n        TreasuryFundedFarmingInit.initLockstakeFarm(p, address(lockstakeEngine));\n    }\n\n    function updateFarmVest(FarmingUpdateVestParams memory p) public returns (FarmingUpdateVestResult memory r) {\n        return TreasuryFundedFarmingInit.updateFarmVest(p);\n    }\n}\n\ninterface ChainlogLike {\n    function getAddress(bytes32 key) external view returns (address addr);\n}\n\ninterface ProxyLike {\n    function exec(address usr, bytes memory fax) external returns (bytes memory);\n}\n\ninterface DssVestTransferrableLike {\n    function cap() external view returns (uint256);\n    function gem() external view returns (address);\n    function ids() external view returns (uint256);\n    function bgn(uint256 vestId) external view returns (uint256);\n    function fin(uint256 vestId) external view returns (uint256);\n    function rxd(uint256 vestId) external view returns (uint256);\n    function tot(uint256 vestId) external view returns (uint256);\n    function unpaid(uint256 vestId) external view returns (uint256);\n}\n\ninterface StakingRewardsLike {\n    function balanceOf(address who) external view returns (uint256);\n    function earned(address who) external view returns (uint256);\n    function getReward() external;\n    function owner() external view returns (address);\n    function rewardRate() external view returns (uint256);\n    function rewardsDistribution() external view returns (address);\n    function rewardsToken() external view returns (address);\n    function stake(uint256 amount) external;\n    function stakingToken() external view returns (address);\n    function withdraw(uint256 amount) external;\n}\n\ninterface VestedRewardsDistributionLike {\n    function dssVest() external view returns (address);\n    function distribute() external;\n    function gem() external view returns (address);\n    function lastDistributedAt() external view returns (uint256);\n    function stakingRewards() external view returns (address);\n    function vestId() external view returns (uint256);\n}\n\ninterface VestedRewardsDistributionJobLike {\n    function has(address dist) external view returns (bool);\n}\n\ninterface ERC20Like {\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external;\n    function balanceOf(address who) external view returns (uint256);\n}\n\ninterface LockstakeEngineLike {\n    enum FarmStatus {\n        UNSUPPORTED,\n        ACTIVE,\n        DELETED\n    }\n\n    function farms(address farm) external view returns (FarmStatus);\n    function free(address owner, uint256 urnIndex, address to, uint256 wad) external;\n    function getReward(address owner, uint256 index, address farm, address to) external returns (uint256 amt);\n    function lock(address owner, uint256 urnIndex, uint256 wad, uint16 ref) external;\n    function open(uint256 urnIndex) external returns (address urn);\n    function ownerUrnsCount(address owner) external view returns (uint256);\n    function selectFarm(address owner, uint256 urnIndex, address farm, uint16 ref) external;\n    function sky() external view returns (address);\n    function urnFarms(address urn) external view returns (address);\n}\n",
        "TreasuryFundedFarmingInit.t.integration.sol": "// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.16;\n\nimport {DssTest} from \"dss-test/DssTest.sol\";\nimport {StakingRewardsDeploy, StakingRewardsDeployParams} from \"../StakingRewardsDeploy.sol\";\nimport {\n    VestedRewardsDistributionDeploy,\n    VestedRewardsDistributionDeployParams\n} from \"../VestedRewardsDistributionDeploy.sol\";\nimport {\n    TreasuryFundedFarmingInit,\n    FarmingInitParams,\n    FarmingUpdateVestParams,\n    FarmingUpdateVestResult\n} from \"./TreasuryFundedFarmingInit.sol\";\n\ncontract TreasuryFundedFarmingInitIntegrationTest is DssTest {\n    ChainlogLike chainlog;\n    MockSpell spell;\n    address pause;\n    address pauseProxy;\n    address lssky;\n    address sky;\n    address usds;\n    address vest;\n    address lockstakeEngine;\n    address distJob;\n    FarmingInitParams lfp;\n    FarmingInitParams fp;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\");\n        chainlog = ChainlogLike(0xdA0Ab1e0017DEbCd72Be8599041a2aa3bA7e740F);\n\n        pause = chainlog.getAddress(\"MCD_PAUSE\");\n        pauseProxy = chainlog.getAddress(\"MCD_PAUSE_PROXY\");\n        lockstakeEngine = chainlog.getAddress(\"LOCKSTAKE_ENGINE\");\n        lssky = chainlog.getAddress(\"LOCKSTAKE_SKY\");\n        sky = chainlog.getAddress(\"SKY\");\n        usds = chainlog.getAddress(\"USDS\");\n        vest = chainlog.getAddress(\"MCD_VEST_SKY_TREASURY\");\n        distJob = chainlog.getAddress(\"CRON_REWARDS_DIST_JOB\");\n\n        lfp = FarmingInitParams({\n            stakingToken: lssky,\n            rewardsToken: sky,\n            rewards: address(0),\n            rewardsKey: \"REWARDS_LSSKY_SKY\",\n            dist: address(0),\n            distKey: \"REWARDS_DIST_LSSKY_SKY\",\n            distJob: distJob,\n            distJobInterval: 7 days - 1 hours,\n            vest: vest,\n            vestTot: 2_400_000 * 10 ** 18,\n            vestBgn: block.timestamp - 7 days,\n            vestTau: 365 days\n        });\n        lfp.rewards = StakingRewardsDeploy.deploy(\n            StakingRewardsDeployParams({\n                owner: pauseProxy, stakingToken: lfp.stakingToken, rewardsToken: lfp.rewardsToken\n            })\n        );\n        lfp.dist = VestedRewardsDistributionDeploy.deploy(\n            VestedRewardsDistributionDeployParams({\n                deployer: address(this), owner: pauseProxy, vest: lfp.vest, rewards: lfp.rewards\n            })\n        );\n\n        fp = FarmingInitParams({\n            stakingToken: usds,\n            rewardsToken: sky,\n            rewards: address(0),\n            rewardsKey: \"REWARDS_LSSKY_SKY\",\n            dist: address(0),\n            distKey: \"REWARDS_DIST_LSSKY_SKY\",\n            distJob: distJob,\n            distJobInterval: 7 days - 1 hours,\n            vest: vest,\n            vestTot: 2_400_000 * 10 ** 18,\n            vestBgn: block.timestamp - 7 days,\n            vestTau: 365 days\n        });\n        fp.rewards = StakingRewardsDeploy.deploy(\n            StakingRewardsDeployParams({\n                owner: pauseProxy, stakingToken: fp.stakingToken, rewardsToken: fp.rewardsToken\n            })\n        );\n        fp.dist = VestedRewardsDistributionDeploy.deploy(\n            VestedRewardsDistributionDeployParams({\n                deployer: address(this), owner: pauseProxy, vest: fp.vest, rewards: fp.rewards\n            })\n        );\n\n        spell = new MockSpell();\n    }\n\n    function testInitFarm_stakeGetRewardAndWithdraw_Fuzz(uint256 stakeAmt) public {\n        // Bound `stakeAmt` to [1, 1_000_000_000_000]\n        stakeAmt = bound(stakeAmt, 1 * 10 ** 18, 1_000_000_000_000 * 10 ** 18);\n\n        // Simulate spell casting\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Set `stakingToken` balance of the testing contract.\n        address usr = address(this);\n        deal(address(fp.stakingToken), usr, stakeAmt);\n\n        // Approve `stakingToken` to the farming contract.\n        ERC20Like(fp.stakingToken).approve(fp.rewards, stakeAmt);\n\n        // Stake `stakingToken`\n        uint256 pstakedBalance = StakingRewardsLike(fp.rewards).balanceOf(usr);\n        StakingRewardsLike(fp.rewards).stake(stakeAmt);\n        uint256 stakedBalance = StakingRewardsLike(fp.rewards).balanceOf(usr);\n        assertEq(stakedBalance, pstakedBalance + stakeAmt, \"Staking failed: balance should increase by staked amount\");\n\n        // Accumulate rewards.\n        vm.warp(block.timestamp + 1 days);\n\n        // Check earned rewards.\n        uint256 earnedAmt = StakingRewardsLike(fp.rewards).earned(usr);\n        assertGt(earnedAmt, 0, \"No rewards earned after 1 day of staking\");\n\n        // Claim earned rewards.\n        uint256 prewardsTokenBalance = ERC20Like(fp.rewardsToken).balanceOf(usr);\n        StakingRewardsLike(fp.rewards).getReward();\n        uint256 rewardsTokenBalance = ERC20Like(fp.rewardsToken).balanceOf(usr);\n        assertEq(\n            rewardsTokenBalance,\n            prewardsTokenBalance + earnedAmt,\n            \"Reward claiming failed: balance should increase by earned amount\"\n        );\n\n        // Withdraw staked tokens.\n        uint256 pstakingTokenBalance = ERC20Like(fp.stakingToken).balanceOf(usr);\n        StakingRewardsLike(fp.rewards).withdraw(stakeAmt);\n        uint256 stakingTokenBalance = ERC20Like(fp.stakingToken).balanceOf(usr);\n        assertEq(\n            stakingTokenBalance,\n            pstakingTokenBalance + stakeAmt,\n            \"Withdrawal failed: balance should increase by withdrawn amount\"\n        );\n    }\n\n    function testInitLockstakeFarm_openSelectFarmLockGetRewardAndFree_Fuzz(uint256 lockAmt) public {\n        // Bound lockAmt to [1, 1_000_000_000_000]\n        lockAmt = bound(lockAmt, 1 * 10 ** 18, 1_000_000_000_000 * 10 ** 18);\n\n        // Simulate spell casting\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initLockstakeFarm, (lfp, lockstakeEngine)));\n\n        // Open a new urn\n        address owner = address(this);\n\n        uint256 ownerUrnsCount = LockstakeEngineLike(lockstakeEngine).ownerUrnsCount(owner);\n        assertEq(ownerUrnsCount, 0, \"Owner should start with zero urns\");\n\n        uint256 urnIndex = ownerUrnsCount;\n        address urn = LockstakeEngineLike(lockstakeEngine).open(urnIndex);\n\n        // Select a farm\n        LockstakeEngineLike(lockstakeEngine).selectFarm(owner, urnIndex, lfp.rewards, 0);\n        assertEq(\n            LockstakeEngineLike(lockstakeEngine).urnFarms(urn),\n            lfp.rewards,\n            \"Farm selection failed: urn should be associated with rewards contract\"\n        );\n\n        // Lock tokens\n        address lockToken = LockstakeEngineLike(lockstakeEngine).sky();\n        deal(address(lockToken), owner, lockAmt);\n\n        ERC20Like(lockToken).approve(lockstakeEngine, type(uint256).max);\n        LockstakeEngineLike(lockstakeEngine).lock(owner, urnIndex, lockAmt, 0);\n\n        // Check staking token balance for the urn\n        uint256 stakedAmt = StakingRewardsLike(lfp.rewards).balanceOf(urn);\n        assertEq(stakedAmt, lockAmt, \"Lockstake failed: urn staked balance should equal locked amount\");\n\n        // Accumulate rewards\n        vm.warp(block.timestamp + 1 days);\n\n        // Check earned rewards\n        uint256 earnedAmt = StakingRewardsLike(lfp.rewards).earned(urn);\n        assertGt(earnedAmt, 0, \"No rewards earned after 1 day of lockstaking\");\n\n        // Get rewards\n        uint256 prewardsTokenBalance = ERC20Like(lfp.rewardsToken).balanceOf(owner);\n        LockstakeEngineLike(lockstakeEngine).getReward(owner, urnIndex, lfp.rewards, owner);\n        uint256 rewardsTokenBalance = ERC20Like(lfp.rewardsToken).balanceOf(owner);\n        assertEq(\n            rewardsTokenBalance,\n            prewardsTokenBalance + earnedAmt,\n            \"Lockstake reward claiming failed: balance should increase by earned amount\"\n        );\n\n        // Free urn\n        uint256 plockTokenBalance = ERC20Like(lockToken).balanceOf(owner);\n        LockstakeEngineLike(lockstakeEngine).free(owner, urnIndex, owner, lockAmt);\n        uint256 lockTokenBalance = ERC20Like(lockToken).balanceOf(owner);\n        assertEq(\n            lockTokenBalance,\n            plockTokenBalance + lockAmt,\n            \"Free operation failed: balance should increase by freed amount\"\n        );\n    }\n\n    function testUpdateFarmVest_integration_stakingStillWorksAfterUpdate() public {\n        uint256 stakeAmt = 1000 * 10 ** 18;\n\n        // Initialize farm\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.initFarm, (fp)));\n\n        // Set up staking\n        address usr = address(this);\n        deal(address(fp.stakingToken), usr, stakeAmt);\n        ERC20Like(fp.stakingToken).approve(fp.rewards, stakeAmt);\n        StakingRewardsLike(fp.rewards).stake(stakeAmt);\n\n        // Accumulate some rewards\n        vm.warp(block.timestamp + 2 days);\n        uint256 earnedBefore = StakingRewardsLike(fp.rewards).earned(usr);\n        assertGt(earnedBefore, 0, \"No rewards earned after 2 days before vest update\");\n\n        // Update the vest\n        FarmingUpdateVestParams memory updateParams = FarmingUpdateVestParams({\n            dist: fp.dist,\n            vestTot: 1_200_000 * 10 ** 18, // Different amount\n            vestBgn: block.timestamp + 1 hours,\n            vestTau: 60 days\n        });\n\n        vm.prank(pause);\n        ProxyLike(pauseProxy).exec(address(spell), abi.encodeCall(spell.updateFarmVest, (updateParams)));\n\n        // Verify staking still works after update\n        vm.warp(block.timestamp + 1 days);\n        uint256 earnedAfter = StakingRewardsLike(fp.rewards).earned(usr);\n        assertGt(earnedAfter, earnedBefore, \"Rewards should continue accumulating after vest update\");\n\n        // Verify we can still claim rewards\n        uint256 preBalance = ERC20Like(fp.rewardsToken).balanceOf(usr);\n        StakingRewardsLike(fp.rewards).getReward();\n        uint256 postBalance = ERC20Like(fp.rewardsToken).balanceOf(usr);\n        assertGt(postBalance, preBalance, \"Reward claiming should work after vest update\");\n    }\n}\n\ncontract MockSpell {\n    function initFarm(FarmingInitParams memory p) public {\n        TreasuryFundedFarmingInit.initFarm(p);\n    }\n\n    function initLockstakeFarm(FarmingInitParams memory p, address lockstakeEngine) public {\n        TreasuryFundedFarmingInit.initLockstakeFarm(p, address(lockstakeEngine));\n    }\n\n    function updateFarmVest(FarmingUpdateVestParams memory p) public returns (FarmingUpdateVestResult memory r) {\n        return TreasuryFundedFarmingInit.updateFarmVest(p);\n    }\n}\n\ninterface ChainlogLike {\n    function getAddress(bytes32 key) external view returns (address addr);\n}\n\ninterface ProxyLike {\n    function exec(address usr, bytes memory fax) external returns (bytes memory);\n}\n\ninterface StakingRewardsLike {\n    function balanceOf(address who) external view returns (uint256);\n    function earned(address who) external view returns (uint256);\n    function getReward() external;\n    function stake(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n}\n\ninterface ERC20Like {\n    function approve(address spender, uint256 amount) external;\n    function balanceOf(address who) external view returns (uint256);\n}\n\ninterface LockstakeEngineLike {\n    function free(address owner, uint256 urnIndex, address to, uint256 wad) external;\n    function getReward(address owner, uint256 index, address farm, address to) external returns (uint256 amt);\n    function lock(address owner, uint256 urnIndex, uint256 wad, uint16 ref) external;\n    function open(uint256 urnIndex) external returns (address urn);\n    function ownerUrnsCount(address owner) external view returns (uint256);\n    function selectFarm(address owner, uint256 urnIndex, address farm, uint16 ref) external;\n    function sky() external view returns (address);\n    function urnFarms(address urn) external view returns (address);\n}\n"
    }
}