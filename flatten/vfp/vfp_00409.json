{
    "vfp_id": "vfp_00409",
    "project_name": "Uniswap Hooks Library Milestone 1 Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Non-Explicit Multiple-Pool Support Allows Overwriting Hook State",
            "description": "The BaseCustomAccounting hook is designed to support only a single Uniswap V4 pool, identified by the `poolKey` state variable, which is set during the `_beforeInitialize` callback. However, the hook does not prevent re-initialization with a different pool, allowing the `poolKey` to be overwritten by registering the same hook with another pool. This occurs because Uniswap V4 allows any pool to use any hook without the hook's explicit consent unless actively rejected.\n\nThe root cause is the lack of a guard in the `_beforeInitialize` function to ensure `poolKey` is set only once. As a result, an attacker or any user can register the hook with a new pool, overwriting the original `poolKey`. This causes all subsequent operations (like liquidity additions or removals) to target the new pool, while the original pool's liquidity remains locked and inaccessible through the hook.\n\nAn attacker could exploit this by registering the hook with a new pool after users have deposited liquidity, effectively freezing their funds in the original pool. The impact is loss of access to user funds and potential permanent loss if no external mechanism exists to recover the liquidity.\n",
            "severity": "Critical",
            "location": [
                "BaseCustomAccounting.sol::poolKey#35",
                "BaseCustomAccounting.sol::_beforeInitialize#220",
                "BaseCustomAccounting.sol#196"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Insufficient Slippage Check",
            "description": "The BaseCustomAccounting hook lacks sufficient slippage protection during liquidity operations. When removing liquidity, there is no slippage check at all, leaving users exposed to front-running via swaps that alter the pool's tick and token balances. When adding liquidity, the slippage check uses the total delta (principal + fees), which can be manipulated.\n\nThe root cause is the incorrect use of the full delta returned by `PoolManager.modifyLiquidity`, which includes accrued fees. If fees exceed the principal delta, the net delta can be positive, leading to an unsafe cast of `-amount` to `uint256`, which results in a very large number and bypasses the slippage check entirely.\n\nAn attacker can exploit this by front-running add/remove liquidity calls with swaps that shift the tick or accrue large fees. The impact includes users receiving far fewer tokens than expected when removing liquidity, or being forced to deposit significantly more than intended when adding liquidity, leading to economic loss.\n",
            "severity": "High",
            "location": [
                "BaseCustomAccounting.sol::addLiquidity#132",
                "BaseCustomAccounting.sol::removeLiquidity#151-162",
                "BaseCustomAccounting.sol#199"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Unsafe Casting Due to Accrued Fees",
            "description": "In the BaseCustomAccounting hook, the delta returned from `PoolManager.modifyLiquidity` includes both principal and accrued fees. When processing this delta, the code assumes negative amounts for deposits, but accrued fees can make one or both token amounts positive. The code then performs an unsafe cast of `-amount` to `uint256`, which can result in extremely large values.\n\nThe root cause is the incorrect assumption that delta amounts are always negative when adding liquidity. If fees are large, the net delta can be positive, leading to a large unsigned value when negated, which may either cause a revert or result in the user paying far more than intended.\n\nAn attacker can exploit this by increasing fees (e.g., via concentrated liquidity or time-based accrual) before a user's liquidity operation. The impact is either a failed transaction or a significant overpayment by the user, leading to loss of funds.\n",
            "severity": "Medium",
            "location": [
                "BaseCustomAccounting.sol#199",
                "BaseCustomAccounting.sol#208",
                "BaseCustomAccounting.sol#184"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Dynamic After Swap Fees May Not Work as Intended",
            "description": "The DynamicAfterFee contract only applies its fee logic to exact-input swaps, allowing users to avoid the fee entirely by using exact-output swaps. Additionally, the `targetDelta` is reset after each swap and lacks a built-in mechanism for updating, making it vulnerable to front-running.\n\nThe root cause is the lack of fee enforcement on exact-output swaps and the absence of a secure, documented method to update `targetDelta`. An attacker can front-run a legitimate swap with a tiny exact-input swap, setting the `targetDelta` to a high value, causing the next user's entire output to be taken as a fee.\n\nThis can be exploited by front-running transactions to either avoid fees or steal value from subsequent swaps. The impact includes loss of user funds due to unexpected fee deductions and reduced trust in the fee mechanism, undermining the intended economic model.\n",
            "severity": "Medium",
            "location": [
                "DynamicAfterFee.sol::afterSwap#48-49",
                "DynamicAfterFee.sol#56",
                "DynamicAfterFee.sol#59-74"
            ],
            "files": [
                "uniswap-hooks/src/fee/BaseDynamicAfterFee.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "BaseAsyncSwap Operation Is Unclear",
            "description": "The BaseAsyncSwap hook skips normal swap logic for exact-input swaps by minting ERC-6909 claim tokens to itself, but it does not specify how these tokens should be handled. There is no mechanism to track which user or pool the tokens belong to, nor any logic for distributing or refunding them.\n\nThe root cause is incomplete design and lack of required override guidance. The hook receives tokens from multiple pools but does not separate accounting by user or pool. Additionally, it does not handle exact-output swaps, allowing users to bypass the hook entirely.\n\nThis can be exploited by users who perform exact-output swaps to avoid the hook's logic. The impact includes undefined behavior, potential loss of user funds, and integration difficulties due to unclear responsibilities for inheriting contracts. The lack of user tracking prevents proper accounting and redemption.\n",
            "severity": "Medium",
            "location": [
                "BaseNoOp.sol::BaseAsyncSwap#27",
                "BaseNoOp.sol#54"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseAsyncSwap.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Unintuitive Return Delta",
            "description": "The `_unlockCallback` function in the `BaseCustomCurve` hook always returns two negative amounts in its delta, regardless of whether liquidity is being added or removed. This behavior is inconsistent with the expectations of the `_mint` and `_burn` functions in the parent `BaseCustomAccounting` contract, which expect deltas with signs matching the operation (positive for minting, negative for burning). The root cause is the hardcoded negative return values in `_unlockCallback`, which fails to reflect the actual economic action. An attacker or developer misunderstanding this behavior could implement incorrect logic in inheriting contracts, potentially leading to incorrect accounting or miscalculations in token minting or burning. The impact is limited to potential logic errors in derived contracts rather than direct fund loss, but it increases the risk of integration bugs.\n",
            "severity": "Low",
            "location": [
                "BaseCustomCurve.sol::_unlockCallback#147",
                "BaseCustomAccounting.sol::_mint#129",
                "BaseCustomAccounting.sol::_burn#162"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomCurve.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Redundant `virtual` Function Modifier",
            "description": "The `validateHookAddress` function in the `BaseHook` contract is marked as `virtual`, allowing it to be overridden by inheriting contracts. However, this modifier was inherited from Uniswap's v4-periphery codebase where it was introduced solely for testing purposes. In the current context, there is no need for this function to be overridden in production, making the `virtual` modifier unnecessary. The root cause is a direct copy of code without adjusting modifiers for the new context. If a derived contract incorrectly overrides this function, it could weaken access control checks, potentially allowing unauthorized hooks to be registered. While the immediate impact is low, it introduces unnecessary complexity and risk of misuse, reducing code safety and clarity.\n",
            "severity": "Low",
            "location": [
                "BaseHook.sol::validateHookAddress#100"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseHook.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "BaseHook's `unlockCallback` Not Needed",
            "description": "The `BaseHook` contract includes an `unlockCallback` function and an internal `_unlockCallback` implementation that are not necessary for minimal hooks. Only hooks that initiate calls to the `PoolManager` need such a callback. The current implementation uses low-level calls that are difficult to use safely and are always overridden. Retaining it creates a potential reentrancy vector if a derived contract does not properly secure it. The root cause is inclusion of unnecessary boilerplate code. This increases attack surface and maintenance burden without providing benefit, potentially leading to security vulnerabilities in inheriting contracts if the function is exposed unintentionally.\n",
            "severity": "Low",
            "location": [
                "BaseHook.sol::unlockCallback#109",
                "BaseHook.sol::_unlockCallback#118"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseHook.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Non-Existent Named Return Variable",
            "description": "The documentation for the `unlockCallback` function in `BaseCustomCurve.sol` refers to a return parameter named `delta`, but the function does not actually declare such a return variable. The root cause is outdated or incorrect NatSpec comments. This discrepancy can mislead developers into believing a value is returned when it is not, potentially leading to incorrect assumptions in integrating contracts or manual audits.\n",
            "severity": "Low",
            "location": [
                "BaseCustomCurve.sol::unlockCallback#147"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomCurve.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Insufficient Documentation",
            "description": "Multiple critical functions and contracts lack adequate NatSpec documentation, increasing the risk of incorrect implementation by developers. For example, the `_getAddLiquidity` and `_getRemoveLiquidity` functions do not document the need for a unique salt per liquidity provider, which is essential to prevent unauthorized withdrawal of others' liquidity. The `DynamicAfterFee` contract does not warn about potential donation exploitation by just-in-time liquidity providers. Additionally, internal functions like `_getAmountOutFromExactInput` lack parameter and return value documentation. The root cause is incomplete developer documentation practices. This can lead to insecure integrations where developers misunderstand the expected behavior, potentially resulting in loss of fees or incorrect state changes due to misuse of the hooks.\n",
            "severity": "Informational",
            "location": [
                "BaseCustomAccounting.sol::_getAddLiquidity#248",
                "BaseCustomAccounting.sol::_getRemoveLiquidity#248",
                "DynamicAfterFee.sol#28",
                "BaseCustomCurve.sol::_beforeSwap#82",
                "BaseCustomCurve.sol::_unlockCallback#147",
                "BaseHook.sol::unlockCallback#109",
                "BaseCustomCurve.sol::_getAmountOutFromExactInput#208"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Typographical Errors",
            "description": "The codebase contains several typographical errors in comments, such as \"implementator\" instead of \"implementer\", \"Aditionally\" instead of \"Additionally\", and \"An\" instead of \"A\". These errors occur in documentation for `BaseCustomAccounting.sol` and `CurrencySettler.sol`. The root cause is lack of proofreading. While these do not affect code execution, they reduce professionalism and clarity, potentially causing confusion for developers reading the documentation, especially non-native English speakers.\n",
            "severity": "Informational",
            "location": [
                "BaseCustomAccounting.sol#22",
                "BaseCustomAccounting.sol#40",
                "CurrencySettler.sol#13"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Optimizable State Reads",
            "description": "In the `BaseCustomCurve` contract, the `poolKey` storage variable is read multiple times within the `_unlockCallback` function without being cached. Each read performs an SLOAD operation, which is expensive in gas. The root cause is inefficient coding practice. By caching `poolKey` in memory at the start of the function, redundant state reads can be avoided, reducing gas consumption during execution. This is a performance optimization with no security impact but improves efficiency.\n",
            "severity": "Informational",
            "location": [
                "BaseCustomCurve.sol::_unlockCallback#147"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomCurve.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Modifier",
            "description": "The `onlySelf` modifier in the `BaseHook` contract is defined but never used anywhere in the codebase. The root cause is inclusion of unused helper code. While it does not introduce a direct vulnerability, it adds unnecessary complexity and reduces code clarity. Developers mayè¯¯assume it is used for access control, leading to incorrect security assumptions. Unused code should be removed to maintain a clean and auditable codebase.\n",
            "severity": "Informational",
            "location": [
                "BaseHook.sol::onlySelf#75"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseHook.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Lack of Security Contact",
            "description": "None of the contracts include a `@custom:security-contact` NatSpec tag, making it difficult for security researchers to report vulnerabilities. The root cause is omission of a best practice for responsible disclosure. Without a clear contact, vulnerabilities may go unreported or be disclosed publicly without coordination, increasing risk to users. While the team states implementers should add their own, the base contracts should encourage this practice by including a placeholder.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "uniswap-hooks/src/base/BaseCustomCurve.sol",
                "uniswap-hooks/src/base/BaseHook.sol",
                "uniswap-hooks/src/base/BaseCustomAccounting.sol",
                "uniswap-hooks/src/base/BaseAsyncSwap.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Different Pragma Version From `PoolManager`",
            "description": "The base contracts use a floating pragma `^0.8.24`, while the Uniswap `PoolManager` contract uses `0.8.26`. The root cause is version mismatch in dependency management. This can lead to unexpected compiler behavior or compatibility issues when integrating with the `PoolManager`, especially if new compiler features or bugs are introduced between versions. Using a fixed version aligned with the `PoolManager` would improve consistency and safety.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "uniswap-hooks/src/base/BaseCustomCurve.sol",
                "uniswap-hooks/src/base/BaseHook.sol",
                "uniswap-hooks/src/base/BaseCustomAccounting.sol",
                "uniswap-hooks/src/base/BaseAsyncSwap.sol",
                "uniswap-hooks/src/fee/BaseDynamicAfterFee.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Functions Are Updating the State Without Event Emissions",
            "description": "Functions like `_beforeInitialize` in `BaseCustomAccounting` and the constructor in `BaseHook` modify state but do not emit events. The root cause is lack of observability design. Without events, off-chain systems cannot easily track state changes, making monitoring, debugging, and indexing more difficult. While the team states implementers should add their own events, base contracts should emit core events by default to ensure critical changes are always logged.\n",
            "severity": "Informational",
            "location": [
                "BaseCustomAccounting.sol::_beforeInitialize#218",
                "BaseHook.sol::constructor#59"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomAccounting.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1120"
                ],
                "3": [
                    "CWE-1064"
                ]
            },
            "title": "Unnecessary Restriction On the `_getAmount` `virtual` Function",
            "description": "The `_getAmount` function in `BaseCustomCurve` imposes unnecessary restrictions by requiring `input`, `output`, and `zeroForOne` parameters, even though the direction can be inferred from the currencies. It also splits logic based on `exactInput`, forcing inheriting contracts to follow a rigid structure. The root cause is over-constrained API design. This reduces flexibility and complicates implementations. Passing `IPoolManager.SwapParams` directly would simplify the interface and allow more natural implementations, reducing the risk of errors in complex fee logic.\n",
            "severity": "Informational",
            "location": [
                "BaseCustomCurve.sol::_getAmount#195"
            ],
            "files": [
                "uniswap-hooks/src/base/BaseCustomCurve.sol"
            ]
        }
    ],
    "affected_files": {
        "BaseHook.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseHook.sol)\n\npragma solidity ^0.8.24;\n\nimport {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\n\n/**\n * @dev Base hook implementation.\n *\n * This contract defines all hook entry points, as well as security and permission helpers.\n * Based on the https://github.com/Uniswap/v4-periphery/blob/main/src/base/hooks/BaseHook.sol[Uniswap v4 periphery implementation].\n *\n * NOTE: Hook entry points must be overiden and implemented by the inheriting hook to be used. Their respective\n * flags must be set to true in the `getHookPermissions` function as well.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseHook is IHooks {\n    IPoolManager public immutable poolManager;\n\n    /**\n     * @dev The hook is not the caller.\n     */\n    error NotSelf();\n\n    /**\n     * @dev The pool is not authorized to use this hook.\n     */\n    error InvalidPool();\n\n    /**\n     * @dev The hook function is not implemented.\n     */\n    error HookNotImplemented();\n\n    /**\n     * @notice Thrown when calling unlockCallback where the caller is not `PoolManager`.\n     */\n    error NotPoolManager();\n\n    /**\n     * @dev Set the pool manager and check that the hook address matches the expected permissions and flags.\n     */\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        validateHookAddress(this);\n    }\n\n    /**\n     * @notice Only allow calls from the `PoolManager` contract\n     */\n    modifier onlyPoolManager() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    /**\n     * @dev Restrict the function to only be callable by the hook itself.\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    /**\n     * @dev Restrict the function to only be called for a valid pool.\n     */\n    modifier onlyValidPools(IHooks hooks) {\n        if (hooks != this) revert InvalidPool();\n        _;\n    }\n\n    /**\n     * @dev Get the hook permissions to signal which hook functions are to be implemented.\n     *\n     * Used at deployment to validate the address correctly represents the expected permissions.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual returns (Hooks.Permissions memory permissions);\n\n    /**\n     * @dev Validate the hook address against the expected permissions.\n     */\n    function validateHookAddress(BaseHook hook) internal pure {\n        Hooks.validateHookPermissions(hook, getHookPermissions());\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external\n        virtual\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _beforeInitialize(sender, key, sqrtPriceX96);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeInitialize`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeInitialize(address, PoolKey calldata, uint160) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        virtual\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _afterInitialize(sender, key, sqrtPriceX96, tick);\n    }\n\n    /**\n     * @dev Hook implementation for `afterInitialize`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterInitialize(address, PoolKey calldata, uint160, int24) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _beforeAddLiquidity(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeAddLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _beforeRemoveLiquidity(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeRemoveLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta0,\n        BalanceDelta delta1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterAddLiquidity(sender, key, params, delta0, delta1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterAddLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterAddLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta0,\n        BalanceDelta delta1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterRemoveLiquidity(sender, key, params, delta0, delta1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterRemoveLiquidity`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n        return _beforeSwap(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeSwap`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4, int128) {\n        return _afterSwap(sender, key, params, delta, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterSwap`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, int128)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _beforeDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeDonate`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external virtual onlyPoolManager returns (bytes4) {\n        return _afterDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterDonate`, to be overriden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n}\n",
        "BaseDynamicAfterFee.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/fee/BaseDynamicAfterFee.sol)\n\npragma solidity ^0.8.24;\n\nimport {BaseHook} from \"src/base/BaseHook.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {CurrencySettler} from \"src/utils/CurrencySettler.sol\";\n\n/**\n * @dev Base implementation for dynamic fees applied after swaps.\n *\n * In order to use this hook, the inheriting contract must define the {_getTargetOutput} and\n * {_afterSwapHandler} functions. The {_getTargetOutput} function returns the target output to\n * apply to the swap depending on the given apply flag. The {_afterSwapHandler} function is called\n * after the target output is applied to the swap and currency amount is received.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseDynamicAfterFee is BaseHook {\n    using SafeCast for uint256;\n    using CurrencySettler for Currency;\n\n    uint256 internal _targetOutput;\n\n    bool internal _applyTargetOutput;\n\n    /**\n     * @dev Target output exceeds swap amount.\n     */\n    error TargetOutputExceeds();\n\n    /**\n     * @dev Set the `PoolManager` address.\n     */\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    /**\n     * @dev Sets the target output and apply flag to be used in the `afterSwap` hook.\n     *\n     * NOTE: The target output is reset to 0 in the `afterSwap` hook regardless of the apply flag.\n     */\n    function _beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) internal virtual override returns (bytes4, BeforeSwapDelta, uint24) {\n        // Get the target output and apply flag\n        (uint256 targetOutput, bool applyTargetOutput) = _getTargetOutput(sender, key, params, hookData);\n\n        // Set the target output and apply flag, overriding any previous values.\n        _applyTargetOutput = applyTargetOutput;\n        _targetOutput = targetOutput;\n\n        return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    /**\n     * @dev Apply the target output to the unspecified currency of the swap using fees.\n     * The fees are minted as ERC-6909 tokens, which can then be redeemed in the\n     * {_afterSwapHandler} function. Note that if the underlying unspecified currency\n     * is native, the implementing contract must ensure that it can receive native tokens\n     * when redeeming.\n     *\n     * NOTE: The target output is reset to 0, both when the apply flag is set to `false`\n     * and when set to `true`.\n     */\n    function _afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata\n    ) internal virtual override returns (bytes4, int128) {\n        uint256 targetOutput = _targetOutput;\n\n        // Reset storage target output to 0 and use one stored in memory\n        _targetOutput = 0;\n\n        // Skip if target output is not active\n        if (!_applyTargetOutput) {\n            return (this.afterSwap.selector, 0);\n        }\n\n        // Fee defined in the unspecified currency of the swap\n        (Currency unspecified, int128 unspecifiedAmount) = (params.amountSpecified < 0 == params.zeroForOne)\n            ? (key.currency1, delta.amount1())\n            : (key.currency0, delta.amount0());\n\n        // If fee is on output, get the absolute output amount\n        if (unspecifiedAmount < 0) unspecifiedAmount = -unspecifiedAmount;\n\n        // Revert if the target output exceeds the swap amount\n        if (targetOutput > uint128(unspecifiedAmount)) revert TargetOutputExceeds();\n\n        // Calculate the fee amount, which is the difference between the swap amount and the target output\n        uint256 feeAmount = uint128(unspecifiedAmount) - targetOutput;\n\n        // Mint ERC-6909 tokens for unspecified currency fee and call handler\n        if (feeAmount > 0) {\n            unspecified.take(poolManager, address(this), feeAmount, true);\n            _afterSwapHandler(key, params, delta, targetOutput, feeAmount);\n        }\n\n        return (this.afterSwap.selector, feeAmount.toInt128());\n    }\n\n    /**\n     * @dev Return the target output to be enforced by the `afterSwap` hook using fees.\n     *\n     * IMPORTANT: The swap will revert if the target output exceeds the output unspecified amount from the swap.\n     * In order to consume all of the output from the swap, set the target output to equal the output unspecified\n     * amount and set the apply flag to `true`.\n     *\n     * @return targetOutput The target output, defined in the unspecified currency of the swap.\n     * @return applyTargetOutput The apply flag, which can be set to `false` to skip applying the target output.\n     */\n    function _getTargetOutput(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) internal virtual returns (uint256 targetOutput, bool applyTargetOutput);\n\n    /**\n     * @dev Handler called after applying the target output to a swap and receiving the currency amount.\n     *\n     * @param key The pool key.\n     * @param params The swap parameters.\n     * @param delta The balance delta from the swap.\n     * @param targetOutput The target output, defined in the unspecified currency of the swap.\n     * @param feeAmount The amount of the unspecified currency taken from the swap.\n     */\n    function _afterSwapHandler(\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        uint256 targetOutput,\n        uint256 feeAmount\n    ) internal virtual;\n\n    /**\n     * @dev Set the hook permissions, specifically {beforeSwap}, {afterSwap} and {afterSwapReturnDelta}.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: true,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n",
        "BaseCustomAccounting.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseCustomAccounting.sol)\n\npragma solidity ^0.8.24;\n\nimport {BaseHook} from \"src/base/BaseHook.sol\";\nimport {CurrencySettler} from \"src/utils/CurrencySettler.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"v4-core/src/interfaces/callback/IUnlockCallback.sol\";\nimport {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {StateLibrary} from \"v4-core/src/libraries/StateLibrary.sol\";\n\n/**\n * @dev Base implementation for custom accounting and hook-owned liquidity.\n *\n * To enable hook-owned liquidity, tokens must be deposited via the hook to allow control and flexibility\n * over the liquidity. The implementation inheriting this hook must implement the respective functions\n * to calculate the liquidity modification parameters and the amount of liquidity shares to mint or burn.\n *\n * Additionally, the implementer must consider that the hook is the sole owner of the liquidity and\n * manage fees over liquidity shares accordingly.\n *\n * NOTE: This base hook is designed to work with a single pool key. If you want to use the same custom\n * accounting hook for multiple pools, you must have multiple storage instances of this contract and\n * initialize them via the `PoolManager` with their respective pool keys.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseCustomAccounting is BaseHook, IUnlockCallback {\n    using CurrencySettler for Currency;\n    using CurrencyLibrary for Currency;\n    using StateLibrary for IPoolManager;\n\n    /**\n     * @dev A liquidity modification order was attempted to be executed after the deadline.\n     */\n    error ExpiredPastDeadline();\n\n    /**\n     * @dev Pool was not initialized.\n     */\n    error PoolNotInitialized();\n\n    /**\n     * @dev Principal delta of liquidity modification resulted in too much slippage.\n     */\n    error TooMuchSlippage();\n\n    /**\n     * @dev Liquidity was attempted to be added or removed via the `PoolManager` instead of the hook.\n     */\n    error LiquidityOnlyViaHook();\n\n    /**\n     * @dev Native currency was not sent with the correct amount.\n     */\n    error InvalidNativeValue();\n\n    /**\n     * @dev Hook was already initialized.\n     */\n    error AlreadyInitialized();\n\n    struct AddLiquidityParams {\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n        int24 tickLower;\n        int24 tickUpper;\n        bytes32 userInputSalt;\n    }\n\n    struct RemoveLiquidityParams {\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n        int24 tickLower;\n        int24 tickUpper;\n        bytes32 userInputSalt;\n    }\n\n    struct CallbackData {\n        address sender;\n        IPoolManager.ModifyLiquidityParams params;\n    }\n\n    /**\n     * @notice The hook's pool key.\n     */\n    PoolKey public poolKey;\n\n    /**\n     * @dev Ensure the deadline of a liquidity modification request is not expired.\n     *\n     * @param deadline Deadline of the request, passed in by the caller.\n     */\n    modifier ensure(uint256 deadline) {\n        if (deadline < block.timestamp) revert ExpiredPastDeadline();\n        _;\n    }\n\n    /**\n     * @dev Set the pool `PoolManager` address.\n     */\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    /**\n     * @notice Adds liquidity to the hook's pool.\n     *\n     * @dev To cover all possible scenarios, `msg.sender` should have already given the hook an allowance\n     * of at least amount0Desired/amount1Desired on token0/token1. Always adds assets at the ideal ratio,\n     * according to the price when the transaction is executed.\n     *\n     * NOTE: The `amount0Min` and `amount1Min` parameters are relative to the principal delta, which excludes\n     * fees accrued from the liquidity modification delta.\n     *\n     * @param params The parameters for the liquidity addition.\n     * @return delta The principal delta of the liquidity addition.\n     */\n    function addLiquidity(AddLiquidityParams calldata params)\n        external\n        payable\n        virtual\n        ensure(params.deadline)\n        returns (BalanceDelta delta)\n    {\n        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());\n\n        if (sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        // Revert if msg.value is non-zero but currency0 is not native\n        bool isNative = poolKey.currency0.isAddressZero();\n        if (!isNative && msg.value > 0) revert InvalidNativeValue();\n\n        // Get the liquidity modification parameters and the amount of liquidity shares to mint\n        (bytes memory modifyParams, uint256 shares) = _getAddLiquidity(sqrtPriceX96, params);\n\n        // Apply the liquidity modification\n        (BalanceDelta callerDelta, BalanceDelta feesAccrued) = _modifyLiquidity(modifyParams);\n\n        // Mint the liquidity shares to sender\n        _mint(params, callerDelta, feesAccrued, shares);\n\n        // Get the principal delta by subtracting the fee delta from the caller delta (-= is not supported)\n        delta = callerDelta - feesAccrued;\n\n        // Check for slippage on principal delta\n        uint128 amount0 = uint128(-delta.amount0());\n        if (amount0 < params.amount0Min || uint128(-delta.amount1()) < params.amount1Min) {\n            revert TooMuchSlippage();\n        }\n\n        // If the currency0 is native, refund any remaining msg.value that wasn't used based on the principal delta\n        if (isNative) {\n            // Check that delta amount was covered by msg.value given that settle would be valid if hook can pay for difference\n            // It also allows users to provide more native value than the desired amount\n            if (msg.value < amount0) revert InvalidNativeValue();\n\n            // Previous check prevents underflow revert\n            poolKey.currency0.transfer(msg.sender, msg.value - amount0);\n        }\n    }\n\n    /**\n     * @notice Removes liquidity from the hook's pool.\n     *\n     * NOTE: The `amount0Min` and `amount1Min` parameters are relative to the principal delta, which\n     * excludes fees accrued from the liquidity modification delta.\n     *\n     * @param params The parameters for the liquidity removal.\n     * @return delta The principal delta of the liquidity removal.\n     */\n    function removeLiquidity(RemoveLiquidityParams calldata params)\n        external\n        virtual\n        ensure(params.deadline)\n        returns (BalanceDelta delta)\n    {\n        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());\n\n        if (sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        // Get the liquidity modification parameters and the amount of liquidity shares to burn\n        (bytes memory modifyParams, uint256 shares) = _getRemoveLiquidity(params);\n\n        // Apply the liquidity modification\n        (BalanceDelta callerDelta, BalanceDelta feesAccrued) = _modifyLiquidity(modifyParams);\n\n        // Burn the liquidity shares from the sender\n        _burn(params, callerDelta, feesAccrued, shares);\n\n        // Get the principal delta by subtracting the fee delta from the caller delta (-= is not supported)\n        delta = callerDelta - feesAccrued;\n\n        // Check for slippage\n        if (uint128(delta.amount0()) < params.amount0Min || uint128(delta.amount1()) < params.amount1Min) {\n            revert TooMuchSlippage();\n        }\n    }\n\n    /**\n     * @dev Calls the `PoolManager` to unlock and call back the hook's `unlockCallback` function.\n     *\n     * @param params The encoded parameters for the liquidity modification based on the `ModifyLiquidityParams` struct.\n     * @return callerDelta The balance delta from the liquidity modification. This is the total of both principal and fee deltas.\n     * @return feesAccrued The balance delta of the fees generated in the liquidity range.\n     */\n    // slither-disable-next-line dead-code\n    function _modifyLiquidity(bytes memory params)\n        internal\n        virtual\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued)\n    {\n        (callerDelta, feesAccrued) = abi.decode(\n            poolManager.unlock(\n                abi.encode(CallbackData(msg.sender, abi.decode(params, (IPoolManager.ModifyLiquidityParams))))\n            ),\n            (BalanceDelta, BalanceDelta)\n        );\n    }\n\n    /**\n     * @dev Callback from the `PoolManager` when liquidity is modified, either adding or removing.\n     *\n     * @param rawData The encoded `CallbackData` struct.\n     * @return returnData The encoded caller and fees accrued deltas.\n     */\n    function unlockCallback(bytes calldata rawData)\n        external\n        virtual\n        override\n        onlyPoolManager\n        returns (bytes memory returnData)\n    {\n        CallbackData memory data = abi.decode(rawData, (CallbackData));\n        PoolKey memory key = poolKey;\n\n        // Set the salt value of the liquidity position, which is the keccak256 hash of the sender and salt from the callback data\n        // This ensures that each liquidity position is unique and cannot be accessed by other users\n        data.params.salt = keccak256(abi.encode(data.sender, data.params.salt));\n\n        // Get liquidity modification deltas\n        (BalanceDelta callerDelta, BalanceDelta feesAccrued) = poolManager.modifyLiquidity(key, data.params, \"\");\n\n        // Calculate the principal delta\n        BalanceDelta principalDelta = callerDelta - feesAccrued;\n\n        // Handle each currency amount based on its sign after applying the liquidity modification\n        if (principalDelta.amount0() < 0) {\n            // If amount0 is negative, send tokens from the sender to the pool\n            key.currency0.settle(poolManager, data.sender, uint256(int256(-principalDelta.amount0())), false);\n        } else {\n            // If amount0 is positive, send tokens from the pool to the sender\n            key.currency0.take(poolManager, data.sender, uint256(int256(principalDelta.amount0())), false);\n        }\n\n        if (principalDelta.amount1() < 0) {\n            // If amount1 is negative, send tokens from the sender to the pool\n            key.currency1.settle(poolManager, data.sender, uint256(int256(-principalDelta.amount1())), false);\n        } else {\n            // If amount1 is positive, send tokens from the pool to the sender\n            key.currency1.take(poolManager, data.sender, uint256(int256(principalDelta.amount1())), false);\n        }\n\n        // Handle any accrued fees (by default, transfer all fees to the sender)\n        _handleAccruedFees(data, callerDelta, feesAccrued);\n\n        // Return both deltas so that slippage checks can be done on the principal delta\n        return abi.encode(callerDelta, feesAccrued);\n    }\n\n    /**\n     * @dev Handle any fees accrued in a liquidity position. By default, this function transfers the tokens to the\n     * owner of the liquidity position. However, this function can be overriden to take fees accrued in the position,\n     * or any other desired logic.\n     *\n     * @param data The encoded `CallbackData` struct, including the sender and the parameters for the liquidity modification.\n     * @param callerDelta The balance delta from the liquidity modification.\n     * @param feesAccrued The balance delta of the fees generated in the liquidity range.\n     */\n    function _handleAccruedFees(CallbackData memory data, BalanceDelta callerDelta, BalanceDelta feesAccrued)\n        internal\n        virtual\n    {\n        // Send any accrued fees to the sender\n        poolKey.currency0.take(poolManager, data.sender, uint256(int256(feesAccrued.amount0())), false);\n        poolKey.currency1.take(poolManager, data.sender, uint256(int256(feesAccrued.amount1())), false);\n    }\n\n    /**\n     * @dev Initialize the hook's pool key. The stored key should act immutably so that\n     * it can safely be used across the hook's functions.\n     */\n    function _beforeInitialize(address, PoolKey calldata key, uint160) internal override returns (bytes4) {\n        // Check if the pool key is already initialized\n        if (address(poolKey.hooks) != address(0)) revert AlreadyInitialized();\n\n        // Store the pool key to be used in other functions\n        poolKey = key;\n        return this.beforeInitialize.selector;\n    }\n\n    /**\n     * @dev Revert when liquidity is attempted to be added via the `PoolManager`.\n     */\n    function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        override\n        returns (bytes4)\n    {\n        revert LiquidityOnlyViaHook();\n    }\n\n    /**\n     * @dev Revert when liquidity is attempted to be removed via the `PoolManager`.\n     */\n    function _beforeRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) internal virtual override returns (bytes4) {\n        revert LiquidityOnlyViaHook();\n    }\n\n    /**\n     * @dev Get the liquidity modification to apply for a given liquidity addition,\n     * and the amount of liquidity shares would be minted to the sender.\n     *\n     * @param sqrtPriceX96 The current square root price of the pool.\n     * @param params The parameters for the liquidity addition.\n     * @return modify The encoded parameters for the liquidity addition, which must follow the\n     * same encoding structure as in `_getRemoveLiquidity` and `_modifyLiquidity`.\n     * @return shares The liquidity shares to mint.\n     *\n     * IMPORTANT: The salt returned in `modify` indicates which position of the sender the liquidity\n     * modification is applied given that the `unlockCallback` function uses the keccak256 hash of\n     * the sender and the salt returned here to determine the liquidity position. By default, we\n     * recommend using the `userInputSalt` parameter from the `AddLiquidityParams` struct as the salt\n     * here.\n     */\n    function _getAddLiquidity(uint160 sqrtPriceX96, AddLiquidityParams memory params)\n        internal\n        virtual\n        returns (bytes memory modify, uint256 shares);\n\n    /**\n     * @dev Get the liquidity modification to apply for a given liquidity removal,\n     * and the amount of liquidity shares would be burned from the sender.\n     *\n     * @param params The parameters for the liquidity removal.\n     * @return modify The encoded parameters for the liquidity removal, which must follow the\n     * same encoding structure as in `_getAddLiquidity` and `_modifyLiquidity`.\n     * @return shares The liquidity shares to burn.\n     *\n     * IMPORTANT: The salt returned in `modify` indicates which position of the sender the liquidity\n     * modification is applied given that the `unlockCallback` function uses the keccak256 hash of\n     * the sender and the salt returned here to determine the liquidity position. By default, we\n     * recommend using the `userInputSalt` parameter from the `AddLiquidityParams` struct as the salt\n     * here.\n     */\n    function _getRemoveLiquidity(RemoveLiquidityParams memory params)\n        internal\n        virtual\n        returns (bytes memory modify, uint256 shares);\n\n    /**\n     * @dev Mint liquidity shares to the sender.\n     *\n     * @param params The parameters for the liquidity addition.\n     * @param callerDelta The balance delta from the liquidity addition. This is the total of both principal and fee delta.\n     * @param feesAccrued The balance delta of the fees generated in the liquidity range.\n     * @param shares The liquidity shares to mint.\n     */\n    function _mint(AddLiquidityParams memory params, BalanceDelta callerDelta, BalanceDelta feesAccrued, uint256 shares)\n        internal\n        virtual;\n\n    /**\n     * @dev Burn liquidity shares from the sender.\n     *\n     * @param params The parameters for the liquidity removal.\n     * @param callerDelta The balance delta from the liquidity removal. This is the total of both principal and fee delta.\n     * @param feesAccrued The balance delta of the fees generated in the liquidity range.\n     * @param shares The liquidity shares to burn.\n     */\n    function _burn(\n        RemoveLiquidityParams memory params,\n        BalanceDelta callerDelta,\n        BalanceDelta feesAccrued,\n        uint256 shares\n    ) internal virtual;\n\n    /**\n     * @dev Set the hook permissions, specifically `beforeInitialize`, `beforeAddLiquidity` and `beforeRemoveLiquidity`.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            beforeRemoveLiquidity: true,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n",
        "BaseCustomCurve.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseCustomCurve.sol)\n\npragma solidity ^0.8.24;\n\nimport {BaseCustomAccounting} from \"src/base/BaseCustomAccounting.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";\nimport {CurrencySettler} from \"src/utils/CurrencySettler.sol\";\nimport {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"v4-core/src/types/BalanceDelta.sol\";\n\n/**\n * @dev Base implementation for custom curves, inheriting from {BaseCustomAccounting}.\n *\n * This hook allows to implement a custom curve (or any logic) for swaps, which overrides the default v3-like\n * concentrated liquidity implementation of the `PoolManager`. During a swap, the hook calls the\n * {_getUnspecifiedAmount} function to get the amount of tokens to be sent to the receiver. The return delta\n * created from this calculation is then consumed and applied by the `PoolManager`.\n *\n * NOTE: This hook by default does not include fee or salt mechanisms, which can be implemented by inheriting\n * contracts if needed.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseCustomCurve is BaseCustomAccounting {\n    using CurrencySettler for Currency;\n    using SafeCast for uint256;\n\n    struct CallbackDataCustom {\n        address sender;\n        int128 amount0;\n        int128 amount1;\n    }\n\n    /**\n     * @dev Set the pool `PoolManager` address.\n     */\n    constructor(IPoolManager _poolManager) BaseCustomAccounting(_poolManager) {}\n\n    /**\n     * @dev Defines how the liquidity modification data is encoded and returned\n     * for an add liquidity request.\n     */\n    function _getAddLiquidity(uint160, AddLiquidityParams memory params)\n        internal\n        virtual\n        override\n        returns (bytes memory, uint256)\n    {\n        (uint256 amount0, uint256 amount1, uint256 shares) = _getAmountIn(params);\n        return (abi.encode(amount0.toInt128(), amount1.toInt128()), shares);\n    }\n\n    /**\n     * @dev Defines how the liquidity modification data is encoded and returned\n     * for a remove liquidity request.\n     */\n    function _getRemoveLiquidity(RemoveLiquidityParams memory params)\n        internal\n        virtual\n        override\n        returns (bytes memory, uint256)\n    {\n        (uint256 amount0, uint256 amount1, uint256 shares) = _getAmountOut(params);\n        return (abi.encode(-amount0.toInt128(), -amount1.toInt128()), shares);\n    }\n\n    /**\n     * @dev Overides the default swap logic of the `PoolManager` and calls the {_getUnspecifiedAmount}\n     * to get the amount of tokens to be sent to the receiver.\n     *\n     * NOTE: In order to take and settle tokens from the pool, the hook must hold the liquidity added\n     * via the {addLiquidity} function.\n     */\n    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)\n        internal\n        virtual\n        override\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        // Determine if the swap is exact input or exact output\n        bool exactInput = params.amountSpecified < 0;\n\n        // Determine which currency is specified and which is unspecified\n        (Currency specified, Currency unspecified) =\n            (params.zeroForOne == exactInput) ? (key.currency0, key.currency1) : (key.currency1, key.currency0);\n\n        // Get the positive specified amount\n        uint256 specifiedAmount = exactInput ? uint256(-params.amountSpecified) : uint256(params.amountSpecified);\n\n        // Get the amount of the unspecified currency to be taken or settled\n        uint256 unspecifiedAmount = _getUnspecifiedAmount(params);\n\n        // New delta must be returned, so store in memory\n        BeforeSwapDelta returnDelta;\n\n        if (exactInput) {\n            // For exact input swaps:\n            // 1. Take the specified input (user-given) amount from this contract's balance in the pool\n            specified.take(poolManager, address(this), specifiedAmount, true);\n            // 2. Send the calculated output amount to this contract's balance in the pool\n            unspecified.settle(poolManager, address(this), unspecifiedAmount, true);\n\n            returnDelta = toBeforeSwapDelta(specifiedAmount.toInt128(), -unspecifiedAmount.toInt128());\n        } else {\n            // For exact output swaps:\n            // 1. Take the calculated input amount from this contract's balance in the pool\n            unspecified.take(poolManager, address(this), unspecifiedAmount, true);\n            // 2. Send the specified (user-given) output amount to this contract's balance in the pool\n            specified.settle(poolManager, address(this), specifiedAmount, true);\n\n            returnDelta = toBeforeSwapDelta(-specifiedAmount.toInt128(), unspecifiedAmount.toInt128());\n        }\n\n        return (this.beforeSwap.selector, returnDelta, 0);\n    }\n\n    /**\n     * @dev Overides the custom accounting logic to support the custom curve integer amounts.\n     *\n     * @param params The parameters for the liquidity modification, encoded in the\n     * {_getAddLiquidity} or {_getRemoveLiquidity} function.\n     * @return callerDelta The balance delta from the liquidity modification. This is the total of both principal and fee deltas.\n     * @return feesAccrued The balance delta of the fees generated in the liquidity range.\n     */\n    function _modifyLiquidity(bytes memory params)\n        internal\n        virtual\n        override\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued)\n    {\n        (int128 amount0, int128 amount1) = abi.decode(params, (int128, int128));\n        (callerDelta, feesAccrued) = abi.decode(\n            poolManager.unlock(abi.encode(CallbackDataCustom(msg.sender, amount0, amount1))),\n            (BalanceDelta, BalanceDelta)\n        );\n    }\n\n    /**\n     * @dev Decodes the callback data and applies the liquidity modifications, overriding the custom\n     * accounting logic to mint and burn ERC-6909 claim tokens which are used in swaps.\n     *\n     * @param rawData The callback data encoded in the {_modifyLiquidity} function.\n     * @return returnData The encoded caller and fees accrued deltas.\n     */\n    function unlockCallback(bytes calldata rawData)\n        external\n        virtual\n        override\n        onlyPoolManager\n        returns (bytes memory returnData)\n    {\n        CallbackDataCustom memory data = abi.decode(rawData, (CallbackDataCustom));\n\n        int128 amount0 = 0;\n        int128 amount1 = 0;\n\n        // This section handles liquidity modifications (adding/removing) for both tokens in the pool\n        // The sign of data.amount0/1 determines if we're removing (-) or adding (+) liquidity\n\n        PoolKey memory _poolKey = poolKey;\n\n        // Remove liquidity if amount0 is negative\n        if (data.amount0 < 0) {\n            // Burns ERC-6909 tokens to receive tokens\n            _poolKey.currency0.settle(poolManager, address(this), uint256(int256(-data.amount0)), true);\n            // Sends tokens from the pool to the user\n            _poolKey.currency0.take(poolManager, data.sender, uint256(int256(-data.amount0)), false);\n            // Record the amount so that it can be then encoded into the delta\n            amount0 = -data.amount0;\n        }\n\n        // Remove liquidity if amount1 is negative\n        if (data.amount1 < 0) {\n            // Burns ERC-6909 tokens to receive tokens\n            _poolKey.currency1.settle(poolManager, address(this), uint256(int256(-data.amount1)), true);\n            // Sends tokens from the pool to the user\n            _poolKey.currency1.take(poolManager, data.sender, uint256(int256(-data.amount1)), false);\n            // Record the amount so that it can be then encoded into the delta\n            amount1 = -data.amount1;\n        }\n\n        // Add liquidity if amount0 is positive\n        if (data.amount0 > 0) {\n            // First settle (send) tokens from user to pool\n            _poolKey.currency0.settle(poolManager, data.sender, uint256(int256(data.amount0)), false);\n            // Take (mint) ERC-6909 tokens to be received by this hook\n            _poolKey.currency0.take(poolManager, address(this), uint256(int256(data.amount0)), true);\n            // Record the amount so that it can be then encoded into the delta\n            amount0 = -data.amount0;\n        }\n\n        // Add liquidity if amount1 is positive\n        if (data.amount1 > 0) {\n            // First settle (send) tokens from user to pool\n            _poolKey.currency1.settle(poolManager, data.sender, uint256(int256(data.amount1)), false);\n            // Take (mint) ERC-6909 tokens to be received by this hook\n            _poolKey.currency1.take(poolManager, address(this), uint256(int256(data.amount1)), true);\n            // Record the amount so that it can be then encoded into the delta\n            amount1 = -data.amount1;\n        }\n\n        // Return the encoded caller and fees accrued (zero by default) deltas\n        return abi.encode(toBalanceDelta(amount0, amount1), BalanceDeltaLibrary.ZERO_DELTA);\n    }\n\n    /**\n     * @dev Calculate the amount of the unspecified currency to be taken or settled from the swapper, depending on the swap\n     * direction.\n     *\n     * @param params The swap parameters.\n     * @return unspecifiedAmount The amount of the unspecified currency to be taken or settled.\n     */\n    function _getUnspecifiedAmount(IPoolManager.SwapParams calldata params)\n        internal\n        virtual\n        returns (uint256 unspecifiedAmount);\n\n    /**\n     * @dev Calculate the amount of tokens to use and liquidity shares to burn for a remove liquidity request.\n     * @return amount0 The amount of token0 to be received by the liquidity provider.\n     * @return amount1 The amount of token1 to be received by the liquidity provider.\n     * @return shares The amount of liquidity shares to be burned by the liquidity provider.\n     */\n    function _getAmountOut(RemoveLiquidityParams memory params)\n        internal\n        virtual\n        returns (uint256 amount0, uint256 amount1, uint256 shares);\n\n    /**\n     * @dev Calculate the amount of tokens to use and liquidity shares to mint for an add liquidity request.\n     * @return amount0 The amount of token0 to be sent by the liquidity provider.\n     * @return amount1 The amount of token1 to be sent by the liquidity provider.\n     * @return shares The amount of liquidity shares to be minted by the liquidity provider.\n     */\n    function _getAmountIn(AddLiquidityParams memory params)\n        internal\n        virtual\n        returns (uint256 amount0, uint256 amount1, uint256 shares);\n\n    /**\n     * @dev Set the hook permissions, specifically `beforeInitialize`, `beforeAddLiquidity`, `beforeRemoveLiquidity`,\n     * `beforeSwap`, and `beforeSwapReturnDelta`\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            beforeRemoveLiquidity: true,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: true,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n",
        "BaseAsyncSwap.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseAsyncSwap.sol)\n\npragma solidity ^0.8.24;\n\nimport {BaseHook} from \"src/base/BaseHook.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";\nimport {CurrencySettler} from \"src/utils/CurrencySettler.sol\";\n\n/**\n * @dev Base implementation for async swaps, which skip the v3-like swap implementation of the `PoolManager`\n * by taking the full swap input amount and returning a delta that nets out the specified amount to 0.\n *\n * This base hook allows developers to implement arbitrary logic to handle swaps, including use-cases like\n * asynchronous swaps and custom swap-ordering. However, given this flexibility, developers should ensure\n * that any logic implemented interacts safely with the `PoolManager` and works correctly.\n *\n * In order to handle async swaps, the hook mints ERC-6909 claim tokens for the specified currency and amount.\n * Inheriting contracts are free to handle these claim tokens as necessary, which can be redeemed for the\n * underlying currency by using the `settle` function from the `CurrencySettler` library.\n *\n * IMPORTANT: If the hook is used for multiple pools, the ERC-6909 tokens must be separated and managed\n * independently for each pool in order to prevent draining of ERC-6909 tokens from one pool to another.\n *\n * NOTE: The hook only supports async exact-input swaps. Exact-output swaps will be processed normally\n * by the `PoolManager`.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseAsyncSwap is BaseHook {\n    using SafeCast for uint256;\n    using CurrencySettler for Currency;\n\n    /**\n     * @dev Set the `PoolManager` address.\n     */\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    /**\n     * @dev Skip the v3-like swap implementation of the `PoolManager` by returning a delta that nets out the\n     * specified amount to 0 to enable asynchronous swaps.\n     */\n    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)\n        internal\n        virtual\n        override\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        // Async swaps are only possible on exact-input swaps, so exact-output swaps are executed by the `PoolManager` as normal\n        if (params.amountSpecified < 0) {\n            // Determine which currency is specified\n            Currency specified = params.zeroForOne ? key.currency0 : key.currency1;\n\n            // Get the positive specified amount\n            uint256 specifiedAmount = uint256(-params.amountSpecified);\n\n            // Mint ERC-6909 claim token for the specified currency and amount\n            specified.take(poolManager, address(this), specifiedAmount, true);\n\n            // Return delta that nets out specified amount to 0.\n            return (this.beforeSwap.selector, toBeforeSwapDelta(specifiedAmount.toInt128(), 0), 0);\n        } else {\n            return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n        }\n    }\n\n    /**\n     * @dev Set the hook permissions, specifically `beforeSwap` and `beforeSwapReturnDelta`.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory permissions) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: true,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n"
    }
}