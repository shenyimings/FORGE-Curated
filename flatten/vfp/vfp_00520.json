{
    "vfp_id": "vfp_00520",
    "project_name": "Uniswap Calibur Audit.md",
    "findings": [
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Missing Signature Deadlines",
            "description": "The signature validation logic only checks whether the associated key has expired, based on the key's settings, but does not enforce per-signature deadlines. This means a valid signature can be replayed at any time before the key expires, deviating from best practices that include time-limited signatures. The root cause is the lack of a deadline parameter in the signature verification flow. An attacker could capture a valid signature (e.g., via a compromised frontend or phishing) and replay it at a later time to execute unauthorized transactions. The impact includes replay attacks, loss of fine-grained control over permissions, and increased window of exposure for stolen signatures.\n",
            "severity": "Medium",
            "location": [
                "KeyManagement.sol::settings expiry check#77"
            ],
            "files": [
                "732a20a8d82f034573c6c7e44160f1860233a946/minimal-delegation/src/KeyManagement.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ],
                "4": [
                    "CWE-456"
                ]
            },
            "title": "A Newly Registered Key Has No Expiration Date",
            "description": "Keys registered via the `register` function are created without an expiration date because no entry is made in the `keySettings` mapping, which defaults to no expiry. This violates the principle of least privilege. The cause is incomplete initialization logic in `KeyManagement.sol`. An attacker who gains access to a forgotten admin key could exploit this to maintain long-term access. The impact is prolonged exposure from orphaned or forgotten keys, increasing the attack surface over time.\n",
            "severity": "Low",
            "location": [
                "KeyManagement.sol::register#21",
                "SettingsLib.sol#52"
            ],
            "files": [
                "732a20a8d82f034573c6c7e44160f1860233a946/minimal-delegation/src/KeyManagement.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Unrestricted Admin Keys",
            "description": "Admin keys can register new keys and update any key's settings, including their own, allowing them to remove expiration dates or grant admin privileges to others. This creates a trust escalation issue where any admin can become permanent and grant further privileges, effectively making the wallet a 1-of-n multisig with no limits. The cause is overly permissive access control in `KeyManagement.sol`. An attacker who compromises an admin key could exploit this to grant themselves permanent access and bypass time-based restrictions. The impact is a weakened security model where the compromise of a single admin key can lead to full and permanent control of the wallet.\n",
            "severity": "Low",
            "location": [
                "KeyManagement.sol::update#32"
            ],
            "files": [
                "732a20a8d82f034573c6c7e44160f1860233a946/minimal-delegation/src/KeyManagement.sol"
            ]
        }
    ],
    "affected_files": {
        "KeyManagement.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.29;\n\nimport {EnumerableSetLib} from \"solady/utils/EnumerableSetLib.sol\";\nimport {IKeyManagement} from \"./interfaces/IKeyManagement.sol\";\nimport {BaseAuthorization} from \"./BaseAuthorization.sol\";\nimport {Key, KeyLib, KeyType} from \"./libraries/KeyLib.sol\";\nimport {Settings, SettingsLib} from \"./libraries/SettingsLib.sol\";\n\n/// @dev A base contract for managing keys\nabstract contract KeyManagement is IKeyManagement, BaseAuthorization {\n    using EnumerableSetLib for EnumerableSetLib.Bytes32Set;\n    using KeyLib for *;\n    using SettingsLib for Settings;\n\n    EnumerableSetLib.Bytes32Set keyHashes;\n    mapping(bytes32 keyHash => bytes encodedKey) keyStorage;\n    mapping(bytes32 keyHash => Settings settings) keySettings;\n\n    /// @inheritdoc IKeyManagement\n    function register(Key memory key) external onlyThis {\n        if (key.isRootKey()) revert CannotRegisterRootKey();\n\n        bytes32 keyHash = key.hash();\n        keyStorage[keyHash] = abi.encode(key);\n        keyHashes.add(keyHash);\n\n        emit Registered(keyHash, key);\n    }\n\n    /// @inheritdoc IKeyManagement\n    function update(bytes32 keyHash, Settings settings) external onlyThis {\n        if (keyHash.isRootKey()) revert CannotUpdateRootKey();\n        if (!isRegistered(keyHash)) revert KeyDoesNotExist();\n        keySettings[keyHash] = settings;\n    }\n\n    /// @inheritdoc IKeyManagement\n    function revoke(bytes32 keyHash) external onlyThis {\n        if (!keyHashes.remove(keyHash)) revert KeyDoesNotExist();\n        delete keyStorage[keyHash];\n        keySettings[keyHash] = SettingsLib.DEFAULT;\n\n        emit Revoked(keyHash);\n    }\n\n    /// @inheritdoc IKeyManagement\n    function keyCount() external view returns (uint256) {\n        return keyHashes.length();\n    }\n\n    /// @inheritdoc IKeyManagement\n    function keyAt(uint256 i) external view returns (Key memory) {\n        return getKey(keyHashes.at(i));\n    }\n\n    /// @inheritdoc IKeyManagement\n    function getKey(bytes32 keyHash) public view returns (Key memory) {\n        if (keyHash.isRootKey()) return KeyLib.toRootKey();\n        if (isRegistered(keyHash)) return abi.decode(keyStorage[keyHash], (Key));\n        revert KeyDoesNotExist();\n    }\n\n    /// @inheritdoc IKeyManagement\n    function getKeySettings(bytes32 keyHash) public view returns (Settings) {\n        if (keyHash.isRootKey()) return SettingsLib.ROOT_KEY_SETTINGS;\n        if (isRegistered(keyHash)) return keySettings[keyHash];\n        revert KeyDoesNotExist();\n    }\n\n    /// @inheritdoc IKeyManagement\n    function isRegistered(bytes32 keyHash) public view returns (bool) {\n        return keyHashes.contains(keyHash);\n    }\n\n    /// @notice Reverts if the key settings are expired\n    function _checkExpiry(Settings settings) internal view {\n        (bool isExpired, uint40 expiry) = settings.isExpired();\n        if (isExpired) revert IKeyManagement.KeyExpired(expiry);\n    }\n\n    /// @notice Check if the keyHash is the root key or an admin key\n    function _isOwnerOrAdmin(bytes32 keyHash) internal view returns (bool) {\n        if (keyHash.isRootKey()) return true;\n        if (!isRegistered(keyHash)) return false;\n        Settings settings = keySettings[keyHash];\n        if (settings.isAdmin()) return true;\n        return false;\n    }\n}\n"
    }
}