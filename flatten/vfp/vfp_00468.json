{
    "vfp_id": "vfp_00468",
    "project_name": "Forta Firewall Incremental Audit.md",
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Overflow in quantize Function Can Cause a DoS",
            "description": "The vulnerability exists in the `quantize` function where an intermediate overflow occurs during the calculation due to the operation `2 ** offset` when `offset = 256`. This causes the entire expression to revert because Solidity performs arithmetic operations sequentially, and the overflow happens before the final subtraction.\nThe root cause is the order of operations in the return statement, which leads to an intermediate result exceeding the `uint256` limit, triggering a revert.\nAn attacker could exploit this by providing a sufficiently large input value `n` that results in `offset = 256`, causing any call to `quantize` to fail and revert execution.\nThe impact is a denial of service (DoS) condition in any function relying on `quantize`, potentially disrupting critical functionality that depends on this calculation.\n",
            "severity": "High",
            "location": [
                "Quantization.sol::quantize#20-24"
            ],
            "files": [
                "forta-firewall-contracts/src/Quantization.sol"
            ]
        }
    ],
    "affected_files": {
        "Quantization.sol": "// SPDX-License-Identifier: GNU General Public License Version 3\n// See license at: https://github.com/forta-network/forta-firewall-contracts/blob/master/LICENSE-GPLv3.md\n\npragma solidity ^0.8.25;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @notice Until the attestation can arrive on chain and the user transaction can be executed,\n * the asset amounts that will be processed can fluctuate slightly and cause different hashes\n * to be produced during the real execution and a mismatch with the values in the attestation.\n * This library solves this problem by quantizing the reference value used in checkpoint hash\n * computation.\n */\nlibrary Quantization {\n    /**\n     * @notice Quantizes the given value by zeroing the smaller digits.\n     * @param n Input value.\n     */\n    function quantize(uint256 n) public pure returns (uint256) {\n        uint256 offset = 8 * Math.log256(n);\n        return ((n >> offset) << offset) + (2 ** offset) - 1;\n    }\n}\n"
    }
}