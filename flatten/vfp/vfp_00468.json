{
    "vfp_id": "vfp_00468",
    "project_name": "SSO Account OIDC Recovery Solidity Audit.md",
    "findings": [
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Key Ordering in _compactKeys Function Leads to Potential Overwriting of New Keys",
            "description": "The `_compactKeys` function in the `OidcKeyRegistry` contract reorders keys starting from the current index pointer instead of from zero after a key is removed. This causes incorrect realignment of the key buffer, leading to a misaligned insertion pointer. As a result, newer keys may be overwritten before older ones, violating the intended FIFO (First In, First Out) replacement policy. An attacker or even normal operations could trigger a state where critical newer keys are prematurely lost, compromising the integrity of the OIDC key registry. The root cause is flawed array compaction logic that fails to reset indexing after compaction. This could lead to denial of service for account recovery if valid keys are overwritten.\n",
            "severity": "Medium",
            "location": [
                "OidcKeyRegistry.sol::_compactKeys#158"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Insufficient Validation of RSA Moduli and Exponent in _validateKeyBatch",
            "description": "The `_validateKeyBatch` function in the `OidcKeyRegistry` contract performs incomplete validation of RSA cryptographic parameters. While it checks for non-zero exponents and basic modulus structure, it does not enforce a minimum bit length (e.g., 2048 bits) for the modulus, nor does it verify that the modulus is oddâ€”both essential for RSA security. Small or even moduli are vulnerable to factorization attacks, and small exponents can be exploited in known cryptographic attacks. The lack of these checks allows potentially weak cryptographic keys to be registered, undermining the security of the entire OIDC-based recovery mechanism. The root cause is missing validation logic for critical RSA parameter constraints.\n",
            "severity": "Medium",
            "location": [
                "OidcKeyRegistry.sol::_validateKeyBatch#207",
                "OidcKeyRegistry.sol::_validateModulus#251",
                "OidcKeyRegistry.sol::_hasNonZeroExponent#236"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Duplicate kid Values in OidcKeyRegistry Allow for Partial Key Deletion and Retrieval",
            "description": "The `addKeys` function in the `OidcKeyRegistry` contract does not enforce uniqueness of the `kid` (key ID) field, allowing multiple keys with the same `kid` to be registered. When `deleteKey` is called with a `kid`, only the first matching key is removed, leaving duplicates in storage. Similarly, `getKey` returns only the first match, potentially returning an unintended key. This can lead to a situation where a compromised key cannot be fully revoked, leaving the system vulnerable to misuse. The root cause is the absence of a uniqueness check during key addition. This undermines the reliability and security of key management.\n",
            "severity": "Low",
            "location": [
                "OidcKeyRegistry.sol::addKeys#100",
                "OidcKeyRegistry.sol::deleteKey#191",
                "OidcKeyRegistry.sol::getKey#118"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Builtin Getter for OIDCKeys Does Not Return n",
            "description": "The `OIDCKeys` state variable in the `OidcKeyRegistry` contract is declared as `public`, which automatically generates a getter function. However, Solidity's default getter does not return array or complex struct members, so the `n` (modulus) field is omitted from the returned data. This can mislead external callers into thinking the getter returns complete key data, when in fact it only returns `issHash`, `kid`, and `e`. The root cause is the misuse of `public` visibility for a struct containing non-primitive types. This can lead to incorrect assumptions in off-chain applications or integrations.\n",
            "severity": "Low",
            "location": [
                "OidcKeyRegistry.sol::OIDCKeys#77"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-282"
                ],
                "3": [
                    "CWE-283"
                ]
            },
            "title": "Potential Loss of Ownership During Transfer",
            "description": "The `OidcKeyRegistry` contract uses a single-step ownership transfer mechanism, where the new owner is immediately assigned without requiring confirmation. If the address is incorrect or inaccessible, ownership is permanently lost with no recovery mechanism. This increases operational risk and could lead to irreversible loss of administrative control over the contract. The root cause is the lack of a two-step ownership transfer pattern. Implementing a confirmatory step would mitigate this risk.\n",
            "severity": "Low",
            "location": [
                "OidcKeyRegistry.sol#11"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        }
    ],
    "affected_files": {
        "OidcKeyRegistry.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title OidcKeyRegistry\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract is used to store OIDC keys for the OIDC recovery validator.\ncontract OidcKeyRegistry is Initializable, OwnableUpgradeable {\n  /// @dev The maximum number of keys that can be added to the registry.\n  uint8 public constant MAX_KEYS = 8;\n\n  /// @dev The number of 128-bit chunks needed to represent RSA public key modulus in the ZK circuit.\n  /// @dev This matches the Circom circuit's bigint configuration for RSA verification.\n  uint8 public constant CIRCOM_BIGINT_CHUNKS = 17;\n\n  /// @notice The structure representing an OIDC key.\n  /// @param issHash The issuer hash.\n  /// @param kid The key ID.\n  /// @param n The RSA modulus.\n  /// @param e The RSA exponent.\n  struct Key {\n    bytes32 issHash;\n    bytes32 kid;\n    uint256[CIRCOM_BIGINT_CHUNKS] n;\n    bytes e;\n  }\n\n  /// @notice Emitted when a key is added to the registry.\n  /// @param issHash The issuer hash.\n  /// @param kid The key ID.\n  /// @param n The RSA modulus.\n  event KeyAdded(bytes32 indexed issHash, bytes32 indexed kid, uint256[CIRCOM_BIGINT_CHUNKS] n);\n\n  /// @notice Emitted when a key is deleted from the registry.\n  /// @param issHash The issuer hash.\n  /// @param kid The key ID.\n  event KeyDeleted(bytes32 indexed issHash, bytes32 indexed kid);\n\n  /// @notice Thrown when a key is not found for the given issuer hash and key ID.\n  /// @param issHash The issuer hash associated with the key.\n  /// @param kid The key ID that was not found.\n  error KeyNotFound(bytes32 issHash, bytes32 kid);\n\n  /// @notice Thrown when the number of keys exceeds the maximum allowed limit (MAX_KEYS).\n  /// @param count The number of keys that exceeded the limit.\n  error KeyCountLimitExceeded(uint256 count);\n\n  /// @notice Thrown when the issuer hash of the keys being added does not match the expected issuer hash.\n  /// @dev This is to ensure that all added keys are for the same issuer.\n  /// @param expectedIssHash The expected issuer hash.\n  /// @param actualIssHash The actual issuer hash provided.\n  error IssuerHashMismatch(bytes32 expectedIssHash, bytes32 actualIssHash);\n\n  /// @notice Thrown when the key ID is zero, which is not allowed.\n  /// @param index The index of the key in the batch being validated.\n  error KeyIdCannotBeZero(uint8 index);\n\n  /// @notice Thrown when the exponent is zero, which is not allowed.\n  /// @param index The index of the key in the batch being validated.\n  error ExponentCannotBeZero(uint8 index);\n\n  /// @notice Thrown when the modulus is zero, which is not allowed.\n  /// @param index The index of the key in the batch being validated.\n  error ModulusCannotBeZero(uint8 index);\n\n  /// @notice Thrown when a modulus chunk exceeds the maximum allowed size of 121 bits.\n  /// @param index The index of the key in the batch being validated.\n  /// @param chunkIndex The index of the chunk that exceeded the limit.\n  /// @param chunkValue The value of the chunk that exceeded the limit.\n  error ModulusChunkTooLarge(uint8 index, uint256 chunkIndex, uint256 chunkValue);\n\n  /// @notice The mapping of issuer hash to keys.\n  /// @dev Each issuer has an array of length MAX_KEYS, which is a circular buffer.\n  mapping(bytes32 issHash => Key[MAX_KEYS] keys) public OIDCKeys;\n\n  /// @notice The index of the last key added per issuer.\n  /// @dev This is used to determine the next index to add a key to in the circular buffer.\n  mapping(bytes32 issHash => uint8 keyIndex) public keyIndexes;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize() external initializer {\n    __Ownable_init();\n  }\n\n  /// @notice Hashes the issuer string to a bytes32 value.\n  /// @param iss The issuer string to hash.\n  /// @return issHash The hashed issuer.\n  function hashIssuer(string memory iss) external pure returns (bytes32) {\n    return keccak256(abi.encode(iss));\n  }\n\n  /// @notice Adds a batch of keys to the registry.\n  /// @param newKeys The keys to add.\n  function addKeys(Key[] memory newKeys) external onlyOwner {\n    _addKeys(newKeys);\n  }\n\n  /// @notice Adds a single key to the registry.\n  /// @param newKey The key to add.\n  function addKey(Key memory newKey) external onlyOwner {\n    Key[] memory newKeys = new Key[](1);\n    newKeys[0] = newKey;\n    _addKeys(newKeys);\n  }\n\n  /// @notice Retrieves a key from the registry.\n  /// @param issHash The issuer hash.\n  /// @param kid The key ID.\n  /// @return key The key.\n  function getKey(bytes32 issHash, bytes32 kid) external view returns (Key memory) {\n    for (uint8 i = 0; i < MAX_KEYS; ++i) {\n      if (OIDCKeys[issHash][i].kid == kid) {\n        return OIDCKeys[issHash][i];\n      }\n    }\n    revert KeyNotFound(issHash, kid);\n  }\n\n  /// @notice Retrieves all keys for a given issuer hash.\n  /// @param issHash The issuer hash.\n  /// @return keys The keys.\n  function getKeys(bytes32 issHash) external view returns (Key[MAX_KEYS] memory) {\n    return OIDCKeys[issHash];\n  }\n\n  /// @notice Deletes a key from the registry.\n  /// @param issHash The issuer hash.\n  /// @param kid The key ID.\n  function deleteKey(bytes32 issHash, bytes32 kid) external onlyOwner {\n    _deleteKey(issHash, kid);\n    _compactKeys(issHash);\n    emit KeyDeleted(issHash, kid);\n  }\n\n  /// @notice Adds a batch of keys to the registry.\n  /// @param newKeys The keys to add.\n  function _addKeys(Key[] memory newKeys) private {\n    _validateKeyBatch(newKeys);\n    for (uint8 i = 0; i < newKeys.length; ++i) {\n      bytes32 issHash = newKeys[i].issHash;\n      uint8 keyIndex = keyIndexes[issHash];\n      uint8 nextIndex = (keyIndex + 1) % MAX_KEYS; // Circular buffer\n      OIDCKeys[issHash][nextIndex] = newKeys[i];\n      keyIndexes[issHash] = nextIndex;\n      emit KeyAdded(issHash, newKeys[i].kid, newKeys[i].n);\n    }\n  }\n\n  /// @notice Compacts the keys for a given issuer hash.\n  /// @dev This function is called when a key is deleted from the registry.\n  /// @param issHash The issuer hash.\n  function _compactKeys(bytes32 issHash) private {\n    Key[MAX_KEYS] memory keys;\n    uint8 keyCount = 0;\n    uint8 currentIndex = keyIndexes[issHash];\n\n    // Collect non-empty keys in order\n    for (uint8 i = 0; i < MAX_KEYS; ++i) {\n      uint8 circularIndex = (currentIndex + i) % MAX_KEYS;\n      if (OIDCKeys[issHash][circularIndex].kid != 0) {\n        keys[keyCount] = OIDCKeys[issHash][circularIndex];\n        keyCount++;\n      }\n    }\n\n    // Reassign the collected keys in order back to storage\n    for (uint8 i = 0; i < keyCount; ++i) {\n      OIDCKeys[issHash][i] = keys[i];\n    }\n\n    // Delete remaining keys that are no longer needed\n    for (uint8 i = keyCount; i < MAX_KEYS; ++i) {\n      delete OIDCKeys[issHash][i];\n    }\n\n    // Adding MAX_KEYS to avoid underflow\n    keyIndexes[issHash] = (keyCount + MAX_KEYS - 1) % MAX_KEYS;\n  }\n\n  /// @notice Deletes a key from the registry.\n  /// @param issHash The issuer hash.\n  /// @param kid The key ID.\n  function _deleteKey(bytes32 issHash, bytes32 kid) private {\n    for (uint8 i = 0; i < MAX_KEYS; ++i) {\n      if (OIDCKeys[issHash][i].kid == kid) {\n        delete OIDCKeys[issHash][i];\n        return;\n      }\n    }\n    revert KeyNotFound(issHash, kid);\n  }\n\n  /// @notice Validates a batch of keys.\n  /// @dev This function is called when a batch of keys is added to the registry.\n  /// @dev It validates that only one issuer is added per batch.\n  /// @dev It validates that the key ID is not zero.\n  /// @dev It validates that the exponent is not zero.\n  /// @dev It validates that the modulus is not zero.\n  /// @dev It validates that the modulus chunks are not bigger than 121 bits.\n  /// @param newKeys The keys to validate.\n  function _validateKeyBatch(Key[] memory newKeys) private pure {\n    if (newKeys.length > MAX_KEYS) {\n      revert KeyCountLimitExceeded(newKeys.length);\n    }\n    if (newKeys.length == 0) {\n      return;\n    }\n    bytes32 issHash = newKeys[0].issHash;\n    for (uint8 i = 0; i < newKeys.length; ++i) {\n      if (newKeys[i].issHash != issHash) {\n        revert IssuerHashMismatch(issHash, newKeys[i].issHash);\n      }\n\n      if (newKeys[i].kid == 0) {\n        revert KeyIdCannotBeZero(i);\n      }\n\n      if (!_hasNonZeroExponent(newKeys[i].e)) {\n        revert ExponentCannotBeZero(i);\n      }\n\n      _validateModulus(newKeys[i].n, i);\n    }\n  }\n\n  /// @notice Checks if the exponent is not zero.\n  /// @dev This function is called when a batch of keys is added to the registry.\n  /// @param exponent The exponent to check.\n  /// @return hasNonZeroExponent True if the exponent is not zero, false otherwise.\n  function _hasNonZeroExponent(bytes memory exponent) private pure returns (bool) {\n    for (uint256 i = 0; i < exponent.length; ++i) {\n      if (exponent[i] != 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @notice Validates the modulus.\n  /// @dev This function is called when a key is added to the registry.\n  /// @dev It validates that the modulus is not zero.\n  /// @dev It validates that the modulus chunks are not bigger than 121 bits.\n  /// @param modulus The modulus to validate.\n  /// @param index The index of the key in the batch being validated.\n  function _validateModulus(uint256[CIRCOM_BIGINT_CHUNKS] memory modulus, uint8 index) private pure {\n    uint256 limit = (1 << 121) - 1;\n    bool hasNonZero = false;\n\n    for (uint8 i = 0; i < CIRCOM_BIGINT_CHUNKS; ++i) {\n      if (modulus[i] > limit) {\n        revert ModulusChunkTooLarge(index, i, modulus[i]);\n      }\n      if (modulus[i] != 0) {\n        hasNonZero = true;\n      }\n    }\n\n    if (!hasNonZero) {\n      revert ModulusCannotBeZero(index);\n    }\n  }\n}\n"
    }
}