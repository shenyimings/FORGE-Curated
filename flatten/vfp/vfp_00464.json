{
    "vfp_id": "vfp_00464",
    "project_name": "cantina_stryke_aug2025.pdf",
    "findings": [
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Incorrect use of shadow variable",
            "description": "In LiquidityManager.sol, the function accepts a _factory parameter but ignores it, using the state variable factory instead. The root cause is a coding inconsistency. While it works currently because the correct value is passed, it creates confusion and risks breakage if reused. The impact is reduced code clarity and potential bugs in future modifications or reuse.\n",
            "severity": "Informational",
            "location": [
                "LiquidityManager.sol#L121"
            ],
            "files": [
                "contracts/src/handlers/sushi-v3/LiquidityManager.sol",
                "contracts/src/handlers/uniswap-v3/LiquidityManager.sol",
                "contracts/src/handlers/wagmi-v3/LiquidityManager.sol",
                "contracts/src/handlers/shadow-v3/LiquidityManager.sol"
            ]
        }
    ],
    "affected_files": {
        "LiquidityManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Interfaces\nimport {IUniswapV3MintCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LiquidityAmounts} from \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport {TickMath} from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n\n/// @title Liquidity management functions\n/// @notice Internal functions for safely managing liquidity in Uniswap V3\nabstract contract LiquidityManager is IUniswapV3MintCallback {\n    address public immutable factory;\n    bytes32 public immutable POOL_INIT_CODE_HASH;\n\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    constructor(address _factory, bytes32 _pool_init_code_hash) {\n        factory = _factory;\n        POOL_INIT_CODE_HASH = _pool_init_code_hash;\n    }\n\n    struct MintCallbackData {\n        PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IUniswapV3MintCallback\n    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        verifyCallback(factory, decoded.poolKey);\n\n        if (amount0Owed > 0) {\n            pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        }\n        if (amount1Owed > 0) {\n            pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n        }\n    }\n\n    struct AddLiquidityParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        address recipient;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function addLiquidity(AddLiquidityParams memory params)\n        public\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1, IUniswapV3Pool pool)\n    {\n        PoolKey memory poolKey = PoolKey({token0: params.token0, token1: params.token1, fee: params.fee});\n\n        pool = IUniswapV3Pool(computeAddress(factory, poolKey));\n\n        // compute the liquidity amount\n        {\n            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\n\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, params.amount0Desired, params.amount1Desired\n            );\n        }\n\n        (amount0, amount1) = pool.mint(\n            params.recipient,\n            params.tickLower,\n            params.tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    function pay(address token, address payer, address recipient, uint256 value) internal {\n        // pull payment\n        if (payer == address(this)) {\n            SafeERC20.safeTransfer(IERC20(token), recipient, value);\n        } else {\n            SafeERC20.safeTransferFrom(IERC20(token), payer, recipient, value);\n        }\n    }\n\n    function getPoolKey(address tokenA, address tokenB, uint24 fee) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    function computeAddress(address _factory, PoolKey memory key) internal view returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function verifyCallback(address _factory, address tokenA, address tokenB, uint24 fee)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        return verifyCallback(_factory, getPoolKey(tokenA, tokenB, fee));\n    }\n\n    function verifyCallback(address _factory, PoolKey memory poolKey) internal view returns (IUniswapV3Pool pool) {\n        pool = IUniswapV3Pool(computeAddress(_factory, poolKey));\n        require(msg.sender == address(pool));\n    }\n}\n",
        "dataset-curated/contracts/cantina_stryke_aug2025.pdf-source/contracts/src/handlers/wagmi-v3/LiquidityManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Interfaces\nimport {IUniswapV3MintCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LiquidityAmounts} from \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport {TickMath} from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n\n/// @title Liquidity management functions\n/// @notice Internal functions for safely managing liquidity in Uniswap V3\nabstract contract LiquidityManager is IUniswapV3MintCallback {\n    address public immutable factory;\n    bytes32 public immutable POOL_INIT_CODE_HASH;\n\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    constructor(address _factory, bytes32 _pool_init_code_hash) {\n        factory = _factory;\n        POOL_INIT_CODE_HASH = _pool_init_code_hash;\n    }\n\n    struct MintCallbackData {\n        PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IUniswapV3MintCallback\n    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        verifyCallback(factory, decoded.poolKey);\n\n        if (amount0Owed > 0) {\n            pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        }\n        if (amount1Owed > 0) {\n            pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n        }\n    }\n\n    struct AddLiquidityParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        address recipient;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function addLiquidity(AddLiquidityParams memory params)\n        public\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1, IUniswapV3Pool pool)\n    {\n        PoolKey memory poolKey = PoolKey({token0: params.token0, token1: params.token1, fee: params.fee});\n\n        pool = IUniswapV3Pool(computeAddress(factory, poolKey));\n\n        // compute the liquidity amount\n        {\n            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\n\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, params.amount0Desired, params.amount1Desired\n            );\n        }\n\n        (amount0, amount1) = pool.mint(\n            params.recipient,\n            params.tickLower,\n            params.tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    function pay(address token, address payer, address recipient, uint256 value) internal {\n        // pull payment\n        if (payer == address(this)) {\n            SafeERC20.safeTransfer(IERC20(token), recipient, value);\n        } else {\n            SafeERC20.safeTransferFrom(IERC20(token), payer, recipient, value);\n        }\n    }\n\n    function getPoolKey(address tokenA, address tokenB, uint24 fee) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    function computeAddress(address _factory, PoolKey memory key) internal view returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function verifyCallback(address _factory, address tokenA, address tokenB, uint24 fee)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        return verifyCallback(_factory, getPoolKey(tokenA, tokenB, fee));\n    }\n\n    function verifyCallback(address _factory, PoolKey memory poolKey) internal view returns (IUniswapV3Pool pool) {\n        pool = IUniswapV3Pool(computeAddress(_factory, poolKey));\n        require(msg.sender == address(pool));\n    }\n}\n",
        "dataset-curated/contracts/cantina_stryke_aug2025.pdf-source/contracts/src/handlers/shadow-v3/LiquidityManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Interfaces\nimport {IUniswapV3MintCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LiquidityAmounts} from \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport {TickMath} from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n\nimport {IRamsesV3Pool} from \"./IRamsesV3Pool.sol\";\n\n/// @title Liquidity management functions\n/// @notice Internal functions for safely managing liquidity in Uniswap V3\nabstract contract LiquidityManager is IUniswapV3MintCallback {\n    address public immutable factory;\n    bytes32 public immutable POOL_INIT_CODE_HASH;\n\n    struct PoolKey {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n    }\n\n    constructor(address _factory, bytes32 _pool_init_code_hash) {\n        factory = _factory;\n        POOL_INIT_CODE_HASH = _pool_init_code_hash;\n    }\n\n    struct MintCallbackData {\n        PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IUniswapV3MintCallback\n    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        verifyCallback(factory, decoded.poolKey);\n\n        if (amount0Owed > 0) {\n            pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        }\n        if (amount1Owed > 0) {\n            pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n        }\n    }\n\n    struct AddLiquidityParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        address recipient;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function addLiquidity(AddLiquidityParams memory params)\n        public\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1, IUniswapV3Pool pool)\n    {\n        PoolKey memory poolKey =\n            PoolKey({token0: params.token0, token1: params.token1, tickSpacing: params.tickSpacing});\n\n        pool = IUniswapV3Pool(computeAddress(factory, poolKey));\n\n        // compute the liquidity amount\n        {\n            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\n\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, params.amount0Desired, params.amount1Desired\n            );\n        }\n\n        (amount0, amount1) = IRamsesV3Pool(address(pool)).mint(\n            params.recipient,\n            uint256(0),\n            params.tickLower,\n            params.tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    function pay(address token, address payer, address recipient, uint256 value) internal {\n        // pull payment\n        if (payer == address(this)) {\n            SafeERC20.safeTransfer(IERC20(token), recipient, value);\n        } else {\n            SafeERC20.safeTransferFrom(IERC20(token), payer, recipient, value);\n        }\n    }\n\n    function getPoolKey(address tokenA, address tokenB, int24 tickSpacing) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, tickSpacing: tickSpacing});\n    }\n\n    function computeAddress(address _factory, PoolKey memory key) internal view returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.tickSpacing)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function verifyCallback(address _factory, address tokenA, address tokenB, int24 tickSpacing)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        return verifyCallback(_factory, getPoolKey(tokenA, tokenB, tickSpacing));\n    }\n\n    function verifyCallback(address _factory, PoolKey memory poolKey) internal view returns (IUniswapV3Pool pool) {\n        pool = IUniswapV3Pool(computeAddress(_factory, poolKey));\n        require(msg.sender == address(pool));\n    }\n}\n",
        "dataset-curated/contracts/cantina_stryke_aug2025.pdf-source/contracts/src/handlers/uniswap-v3/LiquidityManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Interfaces\nimport {IUniswapV3MintCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport {SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LiquidityAmounts} from \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport {TickMath} from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n\n/// @title Liquidity management functions\n/// @notice Internal functions for safely managing liquidity in Uniswap V3\nabstract contract LiquidityManager is IUniswapV3MintCallback {\n    address public immutable factory;\n    bytes32 public immutable POOL_INIT_CODE_HASH;\n\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    constructor(address _factory, bytes32 _pool_init_code_hash) {\n        factory = _factory;\n        POOL_INIT_CODE_HASH = _pool_init_code_hash;\n    }\n\n    struct MintCallbackData {\n        PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IUniswapV3MintCallback\n    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        verifyCallback(factory, decoded.poolKey);\n\n        if (amount0Owed > 0) {\n            pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        }\n        if (amount1Owed > 0) {\n            pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n        }\n    }\n\n    struct AddLiquidityParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        address recipient;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function addLiquidity(AddLiquidityParams memory params)\n        public\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1, IUniswapV3Pool pool)\n    {\n        PoolKey memory poolKey = PoolKey({token0: params.token0, token1: params.token1, fee: params.fee});\n\n        pool = IUniswapV3Pool(computeAddress(factory, poolKey));\n\n        // compute the liquidity amount\n        {\n            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\n\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, params.amount0Desired, params.amount1Desired\n            );\n        }\n\n        (amount0, amount1) = pool.mint(\n            params.recipient,\n            params.tickLower,\n            params.tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    function pay(address token, address payer, address recipient, uint256 value) internal {\n        // pull payment\n        if (payer == address(this)) {\n            SafeERC20.safeTransfer(IERC20(token), recipient, value);\n        } else {\n            SafeERC20.safeTransferFrom(IERC20(token), payer, recipient, value);\n        }\n    }\n\n    function getPoolKey(address tokenA, address tokenB, uint24 fee) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    function computeAddress(address _factory, PoolKey memory key) internal view returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function verifyCallback(address _factory, address tokenA, address tokenB, uint24 fee)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        return verifyCallback(_factory, getPoolKey(tokenA, tokenB, fee));\n    }\n\n    function verifyCallback(address _factory, PoolKey memory poolKey) internal view returns (IUniswapV3Pool pool) {\n        pool = IUniswapV3Pool(computeAddress(_factory, poolKey));\n        require(msg.sender == address(pool));\n    }\n}\n"
    }
}