{
    "path": "dataset-curated/reports/Zellic/Mina Token Bridge EVM - Zellic Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/sotatek-dev/multichain-bridge-smart-contract-evm",
            "https://github.com/sotatek-dev/multichain-bridge-smart-contract-mina"
        ],
        "commit_id": [
            "6071594f4e12717b8a6636d7b06186124a9bd744",
            "a572ed7a6802d68d69ced8de9720dc5626b9b68c"
        ],
        "address": null,
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2024-12-09",
        "project_path": {
            "Mina Token Bridge EVM - Zellic Audit Report.pdf-source": "dataset-curated/contracts/Mina Token Bridge EVM - Zellic Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Return value of transferFrom is not checked",
            "description": "The lock function in Bridge.sol calls transferFrom on an ERC-20 token but does not check its return value. Some ERC-20 tokens return false on failure instead of reverting, which can lead to the bridge assuming a successful transfer when no tokens were actually transferred. This is caused by relying on the transferFrom return value without proper validation. An attacker could exploit this by using a non-reverting failing token to trigger a Lock event without actually depositing funds. This could allow the attacker to mint tokens on the Mina side without backing, leading to a complete loss of funds from the bridge.\n",
            "severity": "Critical",
            "location": [
                "Bridge.sol::lock"
            ],
            "files": [
                "6071594f4e12717b8a6636d7b06186124a9bd744/multichain-bridge-smart-contract-evm/contracts/Bridge.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Signatures can be replayed",
            "description": "The unlock function on the Mina side (Bridge.ts) accepts validator signatures but does not track whether they have been used before. This is due to the absence of a nonce or signature registry mechanism. An attacker who obtains valid signatures (e.g., through compromise or observation) can replay them multiple times to repeatedly mint tokens. This could allow an attacker to drain all funds from the bridge contract by reusing the same set of signatures. The impact is high because it directly enables theft of all bridge-held assets.\n",
            "severity": "Critical",
            "location": [
                "Bridge.ts::unlock",
                "Bridge.ts::validateSig"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Bridge.ts"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Validator public key is not checked",
            "description": "The validateValidator function in Bridge.ts is intended to verify that the public keys used in signatures belong to registered validators. However, although a helper function validateIndex is defined, it is never invoked. This means that any public key can be passed as a validator, and the function will accept it as long as the threshold number of signatures is provided. This flaw is caused by incomplete implementation logic. An attacker can generate three arbitrary key pairs and sign the unlock message with them, effectively bypassing validator authorization. This allows full control over the minting process and could lead to complete loss of funds.\n",
            "severity": "Critical",
            "location": [
                "Bridge.ts::validateValidator"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Bridge.ts"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1024"
                ]
            },
            "title": "Function getValidatorIndex returns index of first validator for every public key",
            "description": "The getValidatorIndex function in ValidatorManager.ts uses TypeScript if statements to compare public keys, but these comparisons involve circuit Booleans (not native TypeScript booleans). Since circuit Booleans are always truthy in JavaScript execution context, the function always returns 1 regardless of the input. This is caused by incorrect use of circuit logic within a conditional statement. As a result, any public key will be accepted as the first validator, completely breaking validator validation. This flaw compounds with the previous one, allowing arbitrary keys to pass as valid validators. The impact is a total compromise of the validator-based security model.\n",
            "severity": "Critical",
            "location": [
                "ValidatorManager.ts::getValidatorIndex"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/ValidatorManager.ts"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "The protocol owner can withdraw all funds from the bridge",
            "description": "The withdrawETH function in Bridge.sol allows the owner to withdraw any amount of ETH from the contract without restriction. While fees from Mina-to-Ethereum transfers are intended to be collected, the accumulated amounts are tracked off-chain in the backend, not on-chain. This design allows the owner to withdraw more than just fees, including user deposits. The cause is the lack of on-chain accounting and withdrawal limits. An attacker who compromises the owner key, or a malicious owner, could drain all ETH from the bridge. This introduces significant centralization risk and undermines user trust in the protocol's security.\n",
            "severity": "High",
            "location": [
                "Bridge.sol::withdrawETH"
            ],
            "files": [
                "6071594f4e12717b8a6636d7b06186124a9bd744/multichain-bridge-smart-contract-evm/contracts/Bridge.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "No domain separation for validator signatures",
            "description": "The message signed by validators on the Mina side consists of raw field elements (receiver, amount, token address) without any domain separator. This means the same signature could be valid for a different contract that accepts messages of the same structure. The cause is the lack of a unique context prefix in the signed message. If a validator uses the same key for another application, a signature intended for that app could be replayed in the bridge. While the risk is mitigated by centralized operation, it still represents a potential cross-contract replay vulnerability with low direct impact but high theoretical severity.\n",
            "severity": "High",
            "location": [
                "Bridge.ts::unlock",
                "Bridge.ts::validateSig"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Bridge.ts"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ]
            },
            "title": "Validators cannot be removed",
            "description": "The Bridge.sol contract allows adding validators via _addListValidator but provides no mechanism to remove them. This is caused by the absence of a corresponding remove function. If a validator becomes compromised or untrustworthy, the owner cannot revoke its privileges. This creates a permanent security liability, as any added validator remains authorized indefinitely. The impact is a reduced ability to respond to security incidents and long-term operational inflexibility, posing a medium-level protocol risk.\n",
            "severity": "Medium",
            "location": [
                "Bridge.sol::_addListValidator"
            ],
            "files": [
                "6071594f4e12717b8a6636d7b06186124a9bd744/multichain-bridge-smart-contract-evm/contracts/Bridge.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "No token whitelist",
            "description": "The Mina-side Bridge contract lacks a token whitelist, allowing the lock and unlock functions to operate on any token address. This is caused by the absence of a validation check against a list of approved tokens. An attacker could exploit this to lock and mint arbitrary tokens, potentially leading to the creation of fake assets on the Mina side. While the backend currently filters tokens, this is not enforced on-chain, creating a single point of failure. The impact is mitigated by backend controls, but the on-chain design remains insecure, warranting an informational rating.\n",
            "severity": "Informational",
            "location": [
                "Bridge.ts::lock",
                "Bridge.ts::unlock"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Bridge.ts"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Lack of parameter validation in initialization",
            "description": "The initialize function in Bridge.sol sets minAmount and maxAmount without verifying that maxAmount >= minAmount. This is caused by missing input validation logic. If the contract is initialized with maxAmount < minAmount, the lock function will revert for all inputs, effectively disabling the bridge. While these values can be corrected later, the invalid state may go unnoticed, leading to a denial of service. The impact is low because it's a configuration issue that can be fixed, but it still represents a robustness flaw in contract initialization.\n",
            "severity": "Informational",
            "location": [
                "Bridge.sol::initialize"
            ],
            "files": [
                "6071594f4e12717b8a6636d7b06186124a9bd744/multichain-bridge-smart-contract-evm/contracts/Bridge.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Fixed number of validators",
            "description": "The unlock and validateValidator functions in Bridge.ts are hardcoded to accept exactly three validators. This is caused by fixed function parameters and logic. If the number of active validators changes, the contract cannot adapt. For example, if only two validators are active but the threshold is three, the bridge becomes unusable. This lack of flexibility could lead to a denial of service if validator sets need to be adjusted. While storage limitations on Mina prevent dynamic arrays, this design choice limits future scalability and operational resilience, making it an informational finding.\n",
            "severity": "Informational",
            "location": [
                "Bridge.ts::unlock",
                "Bridge.ts::validateValidator"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Bridge.ts"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Invalid threshold can halt the protocol",
            "description": "The changeThreshold function in Bridge.sol allows the owner to set the threshold to any value without checking if it exceeds the number of validators. This is caused by missing validation logic. If the threshold is set higher than the number of validators, the quorum cannot be reached, and the unlock function will always revert. This results in a complete denial of service for the bridge. The impact is protocol-wide disruption due to a simple configuration error, which could be accidental or malicious. While the owner is trusted, this lack of safeguard increases operational risk, justifying an informational severity.\n",
            "severity": "Informational",
            "location": [
                "Bridge.sol::changeThreshold"
            ],
            "files": [
                "6071594f4e12717b8a6636d7b06186124a9bd744/multichain-bridge-smart-contract-evm/contracts/Bridge.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1120"
                ],
                "3": [
                    "CWE-1121"
                ]
            },
            "title": "Simplifications in validateValidator",
            "description": "The validateValidator function in the Mina Bridge contract contains unnecessarily complex boolean logic that reduces code readability and maintainability.\nThe use of nested Provable.if statements for boolean negation and condition checks instead of direct logical operations (e.g., .not()) leads to convoluted code.\nThis does not present a direct attack vector but increases the risk of logic errors during future modifications due to poor readability.\nReduced code clarity may lead to mistakes during development or audits, potentially introducing security flaws in later updates.\n",
            "severity": "Informational",
            "location": [
                "Mina Bridge::validateValidator"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/ValidatorManager.ts",
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Manager.ts"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Misleading function name",
            "description": "The function verifyMsg in the Mina Bridge contract logs whether a signature is valid but does not enforce validation, which can mislead developers into believing it performs a security check.\nThe function name suggests an assertion or requirement is made, but it only logs the result of sig.verify without reverting on failure.\nIf a developer mistakenly uses this function expecting it to validate a signature as part of a security-critical path, it could lead to bypassing signature verification.\nPotential for future vulnerabilities due to incorrect usage, especially if the function is later included in a security-sensitive context.\n",
            "severity": "Informational",
            "location": [
                "Mina Bridge::verifyMsg"
            ],
            "files": [
                "a572ed7a6802d68d69ced8de9720dc5626b9b68c/multichain-bridge-smart-contract-mina/src/Bridge.ts"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Threat Model: unlock function input validation",
            "description": "The unlock function accepts several user-controlled inputs, including token, amount, user, hash, fee, and signatures, each with specific constraints and security checks.\nThe function relies on ECDSA signatures and validator checks to authorize the unlock operation, and reverts if the hash is already used, the signer is not a validator, or the balance is insufficient.\nIf any of the validation steps are bypassed or incorrectly implemented, an attacker could replay a hash, forge a signature, or drain the contract via unauthorized withdrawals.\nThis could lead to loss of funds or double-spending if the signature verification or hash uniqueness check fails. However, the description is cut off, so full impact and details are not available in this chunk.\n",
            "severity": "Informational",
            "location": [
                "Bridge.sol::unlock"
            ],
            "files": [
                "6071594f4e12717b8a6636d7b06186124a9bd744/multichain-bridge-smart-contract-evm/contracts/Bridge.sol"
            ]
        }
    ]
}