{
    "path": "dataset-curated/reports/OpenZeppelin/Very Liquid Vaults Audit.md",
    "project_info": {
        "url": [
            "https://github.com/SizeCredit/very-liquid-vaults"
        ],
        "commit_id": [
            "d5d781ceed378b8865f01b72bfe782be715888c1"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-08-18",
        "project_path": {
            "very-liquid-vaults": "dataset-curated/contracts/Very Liquid Vaults Audit.md-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Incorrect Order of Operations Causes Permanent Reduction in Protocol Fees",
            "description": "The vulnerability arises in the `_mintPerformanceFee` function of the `PerformanceVault` contract, where the high-water-mark (HWM) is updated before minting fee shares. This order of operations causes a dilution of the price per share (PPS) after the fee shares are minted, which reduces the PPS below the newly set HWM. Since the HWM is only updated when the current PPS exceeds it, the protocol will not charge performance fees again until the PPS surpasses this inflated HWM. The root cause is the incorrect sequence of updating the HWM prior to minting, which breaks the economic model. An attacker is not required to exploit this; normal operation after a fee minting event will result in permanent loss of fee revenue. The impact is a long-term reduction in protocol income, undermining the sustainability of the fee mechanism.\n",
            "severity": "Medium",
            "location": [
                "PerformanceVault.sol::L105-L112"
            ],
            "files": [
                "very-liquid-vaults/src/utils/PerformanceVault.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Overly Restrictive Pause Mechanism Blocks User Transfers",
            "description": "The `_update` function in `BaseVault.sol` uses a `notPaused` modifier that blocks all ERC-20 operations, including `transfer` and `transferFrom`, during a pause. While intended to prevent deposit and withdrawal during emergencies, this design unnecessarily restricts user-to-user transfers of existing shares, effectively freezing secondary market liquidity. The root cause is the broad application of the pause flag to all state-changing ERC-20 functions instead of limiting it to vault-specific I/O (deposit, mint, withdraw, redeem). An attacker could not directly exploit this for financial gain, but a malicious or compromised guardian could trigger a pause to cause denial of service to secondary markets, integration failures, or collateral lockups in lending protocols. The impact is reduced user autonomy and potential systemic issues in DeFi integrations relying on share transferability.\n",
            "severity": "Low",
            "location": [
                "BaseVault.sol::_update#L180"
            ],
            "files": [
                "very-liquid-vaults/src/utils/BaseVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Malicious or Faulty Strategies Cannot Be Removed",
            "description": "The `removeStrategy` function in `SizeMetaVault` calls `convertToAssets` on the strategy being removed, even when the rebalance amount is zero (e.g., during a guardian-initiated asset forfeiture). A malicious or malfunctioning strategy can revert on `convertToAssets`, preventing its own removal. The root cause is the unconditional external call to the strategy contract without checking if rebalancing is necessary. This creates a denial-of-service vector where a compromised strategy can permanently block its removal, potentially bricking the entire meta vault if it also disrupts core operations. The impact is severe operational disruption, as the protocol cannot recover from a faulty strategy, leading to a complete freeze of user funds and functionality.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::removeStrategy#L215"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Missing, Incomplete, and Misleading Documentation",
            "description": "Multiple instances of incorrect, missing, or misleading NatSpec and inline comments were found throughout the codebase. For example, `removeStrategy`'s NatSpec incorrectly states `VAULT_MANAGER_ROLE` can call it, while the code uses `GUARDIAN_ROLE`. Similarly, `setTotalAssetsCap`'s comment claims only the `Auth` contract can call it, but the code allows any `VAULT_MANAGER_ROLE` holder. Additionally, numerous functions lack any documentation, including critical ones like `initialize`, `maxDeposit`, and events. The root cause is inconsistent and incomplete documentation practices. While this does not directly lead to fund loss, it increases the risk of operator error, misconfiguration, and integration bugs by third parties. The impact is reduced code maintainability, auditability, and increased likelihood of human error in governance or integration.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::removeStrategy#L210",
                "BaseVault.sol::setTotalAssetsCap#L127",
                "Auth.sol::initialize",
                "IVault.sol::auth",
                "IVault.sol::totalAssetsCap",
                "SizeMetaVault.sol::initialize",
                "SizeMetaVault.sol::maxDeposit",
                "SizeMetaVault.sol::maxMint",
                "SizeMetaVault.sol::maxWithdraw",
                "SizeMetaVault.sol::maxRedeem",
                "SizeMetaVault.sol::totalAssets",
                "SizeMetaVault.sol::setPerformanceFeePercent",
                "SizeMetaVault.sol::setFeeRecipient",
                "SizeMetaVault.sol::setRebalanceMaxSlippagePercent",
                "SizeMetaVault.sol::addStrategy",
                "SizeMetaVault.sol::removeStrategy",
                "SizeMetaVault.sol::reorderStrategies",
                "SizeMetaVault.sol::rebalance",
                "SizeMetaVault.sol::strategies",
                "SizeMetaVault.sol::strategies (index)",
                "SizeMetaVault.sol::strategiesCount",
                "SizeMetaVault.sol::rebalanceMaxSlippagePercent",
                "SizeMetaVault.sol::isStrategy",
                "SizeMetaVault.sol::MAX_STRATEGIES",
                "AaveStrategyVault.sol::initialize",
                "AaveStrategyVault.sol::maxDeposit",
                "AaveStrategyVault.sol::maxMint",
                "AaveStrategyVault.sol::maxWithdraw",
                "AaveStrategyVault.sol::maxRedeem",
                "AaveStrategyVault.sol::totalAssets",
                "AaveStrategyVault.sol::pool",
                "AaveStrategyVault.sol::aToken",
                "ERC4626StrategyVault.sol::initialize",
                "ERC4626StrategyVault.sol::maxDeposit",
                "ERC4626StrategyVault.sol::maxMint",
                "ERC4626StrategyVault.sol::maxWithdraw",
                "ERC4626StrategyVault.sol::maxRedeem",
                "ERC4626StrategyVault.sol::vault",
                "ERC4626StrategyVault.sol::VaultSet",
                "BaseVault.sol::initialize",
                "BaseVault.sol::setTotalAssetsCap",
                "BaseVault.sol::decimals",
                "BaseVault.sol::maxDeposit",
                "BaseVault.sol::maxMint",
                "BaseVault.sol::maxWithdraw",
                "BaseVault.sol::maxRedeem",
                "BaseVault.sol::auth",
                "BaseVault.sol::totalAssetsCap",
                "NonReentrantVault.sol::deposit",
                "NonReentrantVault.sol::mint",
                "NonReentrantVault.sol::withdraw",
                "NonReentrantVault.sol::redeem",
                "PerformanceVault.sol::deposit",
                "PerformanceVault.sol::mint",
                "PerformanceVault.sol::withdraw",
                "PerformanceVault.sol::redeem",
                "PerformanceVault.sol::highWaterMark",
                "PerformanceVault.sol::performanceFeePercent",
                "PerformanceVault.sol::feeRecipient",
                "PerformanceVault.sol::State Variables",
                "PerformanceVault.sol::Events"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Return Values for Nested Meta Vaults Sharing the Same Strategy",
            "description": "The `_maxWithdrawFromStrategies` and `_maxDepositToStrategies` functions in `SizeMetaVault` can return inflated values when nested meta vaults share the same underlying strategy. For example, if a top-level meta vault has both a direct ERC-4626 strategy and a nested meta vault that uses the same strategy, the available capacity is double-counted. The root cause is the lack of deduplication or tracking of shared strategies in the calculation logic. An attacker could exploit this by structuring nested vaults to misrepresent available liquidity, leading to failed deposit attempts despite reported headroom. The impact is degraded user experience and potential integration failures in systems relying on accurate `maxDeposit`/`maxWithdraw` values, though no direct fund loss occurs.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::_maxWithdrawFromStrategies",
                "SizeMetaVault.sol::_maxDepositToStrategies"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Incomplete Reentrancy Protection",
            "description": "The `SizeMetaVault` contract lacks the `nonReentrant` modifier on the `setRebalanceMaxSlippagePercent` function, which is callable without a timelock. Additionally, the `NonReentrantVault` and `PerformanceVault` contracts do not apply the `nonReentrant` modifier to inherited ERC-20 functions like `transfer` and `transferFrom`. The root cause is incomplete application of reentrancy guards across all state-changing entry points. While many functions are protected by timelocks, the absence of guards on `setRebalanceMaxSlippagePercent` exposes it to reentrancy. Furthermore, read-only reentrancy remains possible via `view` functions during state changes, which could affect third-party integrations. The impact includes potential manipulation of slippage settings and vulnerability in external contracts that rely on consistent state during calls.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::setRebalanceMaxSlippagePercent#L192",
                "NonReentrantVault.sol::transfer",
                "NonReentrantVault.sol::transferFrom",
                "PerformanceVault.sol::transfer",
                "PerformanceVault.sol::transferFrom"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect Return Value in `maxRedeem` and `maxMint` Functions",
            "description": "The `maxRedeem` and `maxMint` functions in `SizeMetaVault` and `ERC4626StrategyVault` derive their values from `maxWithdraw` and `maxDeposit`, respectively, which involves converting shares to assets and back. Due to the use of floor division in both conversions, a precision loss of up to 1 Wei occurs, causing the returned share amount to be slightly less than the actual balance. The root cause is the double conversion without rounding up or compensating for precision loss. While not exploitable for direct fund theft, this can lead to user frustration and integration issues where dependent contracts assume the full balance is withdrawable or mintable. The impact is a denial-of-service-like experience for users attempting to move their entire balance, potentially breaking automated strategies or yield aggregators.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::maxRedeem#L102-L104",
                "SizeMetaVault.sol::maxMint",
                "ERC4626StrategyVault.sol::maxRedeem",
                "ERC4626StrategyVault.sol::maxMint"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol",
                "very-liquid-vaults/src/strategies/ERC4626StrategyVault.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-407"
                ]
            },
            "title": "reorderStrategies Function is Unnecessarily Expensive",
            "description": "The `reorderStrategies` function in the `SizeMetaVault` contract inefficiently removes and re-adds all strategies when reordering, leading to excessive gas consumption. The root cause is the unnecessary use of `_removeStrategy` and `_addStrategy` internal functions, which perform redundant validation and array shifting despite the input already being validated. An attacker cannot directly exploit this for profit, but users and the system are impacted through higher transaction costs. The impact includes increased gas fees, redundant event emissions, and a larger reversion surface without security benefit.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::reorderStrategies#239-244",
                "SizeMetaVault.sol::reorderStrategies#229-236",
                "SizeMetaVault.sol#238-244"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1060"
                ]
            },
            "title": "Avoidable External Call",
            "description": "The `initialize` function in the `AaveStrategyVault` contract performs two external calls to the AAVE pool to retrieve the same `aToken` address, which is a gas-inefficient practice. The cause is the lack of local variable caching for the result of the first external call. This allows for avoidable gas expenditure during contract initialization. While external calls are necessary in some contexts, repeating the same call without change in state is unnecessary. The impact is limited to increased gas costs during deployment, with no risk of fund loss or access control breach.\n",
            "severity": "Low",
            "location": [
                "AaveStrategyVault.sol::initialize#70-81"
            ],
            "files": [
                "very-liquid-vaults/src/strategies/AaveStrategyVault.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Opportunity to Break Loops Early",
            "description": "The `_deposit` and `_withdraw` functions in the `SizeMetaVault` contract continue looping through all strategies even after the required `assetsToDeposit` or `assetsToWithdraw` have been fully allocated or withdrawn. The cause is the absence of an early break condition when the target amount is fully processed. This leads to unnecessary iterations, increasing gas costs. An attacker could potentially exploit this by forcing the system to process many strategies, increasing transaction costs for users. The impact is limited to gas inefficiency and higher operational costs, with no direct security compromise.\n",
            "severity": "Low",
            "location": [
                "SizeMetaVault.sol::_deposit#141",
                "SizeMetaVault.sol::_withdraw#167"
            ],
            "files": [
                "very-liquid-vaults/src/SizeMetaVault.sol"
            ]
        }
    ]
}