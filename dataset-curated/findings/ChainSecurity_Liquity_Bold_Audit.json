{
    "path": "dataset-curated/reports/ChainSecurity/ChainSecurity_Liquity_Bold_Audit.pdf",
    "project_info": {
        "url": [
            "https://github.com/liquity/bold"
        ],
        "commit_id": [
            "7d9c8e68104cd4493f8b7da7e28e6951a2f84304"
        ],
        "address": [
            null
        ],
        "chain": "ethereum",
        "compiler_version": "n/a",
        "audit_date": "2025-05-14",
        "project_path": {
            "bold": "dataset-curated/contracts/ChainSecurity_Liquity_Bold_Audit.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding in Debt Shares Calculation Can Mint Unbacked Tokens",
            "description": "This vulnerability arises from the rounding down of debt shares in the TroveManager._updateBatchShares() function, which allows an attacker to manipulate the debt-to-shares ratio in a batch. By repeatedly donating small amounts of debt and opening/closing troves, an attacker can inflate the ratio to a point where new troves receive zero debt shares for non-zero debt, enabling them to mint unbacked BOLD tokens. The root cause is improper handling of integer division and lack of safeguards against ratio manipulation. An attacker could exploit this by looping through donation and trove operations to inflate the ratio, then mint large amounts of unbacked tokens, leading to protocol insolvency. The impact includes loss of trust, financial loss, and potential collapse of the system's monetary model.\n",
            "severity": "Critical",
            "location": [
                "TroveManager.sol::_updateBatchShares",
                "TroveManager.sol::_requireBelowMaxSharesRatio"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "BalancerFlashLoan Missing Access Control",
            "description": "The BalancerFlashLoan contract lacks proper access control on its makeFlashLoan function, allowing any external caller to trigger flash loans and bypass the intended authorization checks in the leverage zapper contracts. The cause is the absence of a modifier or check to ensure only authorized zappers can initiate flash loans. An attacker could exploit this by directly calling makeFlashLoan with arbitrary parameters, including targeting troves they do not control, thereby adjusting troves without proper rights. This could lead to unauthorized trove modifications, potential liquidation risks, and financial gain via sandwich attacks on associated swaps. The impact includes loss of user funds and unauthorized manipulation of trove positions.\n",
            "severity": "High",
            "location": [
                "BalancerFlashLoan.sol::makeFlashLoan",
                "BalancerFlashLoan.sol::receiveFlashLoan"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Leverage Zappers Do Not Return Swap Excess",
            "description": "The leverage zapper contracts fail to return excess tokens received from swap operations (e.g., UniV3Exchange and CurveExchange), leaving user funds stranded in the contract. The root cause is the lack of balance tracking before and after swaps and failure to refund leftover tokens. An attacker could exploit market volatility and slippage to generate excess tokens during swaps, which would remain in the zapper and could be drained by others. This leads to user fund loss, as excess BOLD or collateral tokens are not returned. The impact is direct financial loss for users and reduced trust in the system's fund handling.\n",
            "severity": "High",
            "location": [
                "UniV3Exchange.sol::swapFromBold",
                "CurveExchange.sol::swapFromBold",
                "Zapper contracts::openLeveragedTroveWithRawETH",
                "Zapper contracts::leverUpTrove",
                "Zapper contracts::leverDownTrove"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Zappers Can Lose User Funds",
            "description": "When users repay debt via zapper functions, if the repayment would bring the trove below MIN_DEBT, only a partial amount is repaid, and the remainder stays locked in the zapper contract. The cause is the logic in _adjustTrove that silently reduces the repayment amount without refunding excess. An attacker can front-run a large repayment by redeeming the target trove down to just above MIN_DEBT, causing nearly the entire repayment amount to be trapped. The impact is significant loss of user funds, especially in large repayments, and creates an attack vector where malicious actors can profit by backrunning and extracting stuck funds. This undermines user trust and fund safety.\n",
            "severity": "High",
            "location": [
                "BorrowerOperations.sol::_adjustTrove",
                "Zapper contracts::adjust",
                "Zapper contracts::repay"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Incorrect Scaling of P",
            "description": "In the StabilityPool.offset function, the variable P can be scaled beyond the assumed upper bound of 1e36 due to incorrect loop conditions, leading to incorrect calculations in dependent functions like getDepositorCollGain. The cause is a flawed while loop condition that allows P to grow excessively during scaling. An attacker could manipulate deposit and offset values to trigger this overflow, resulting in incorrect reward distributions and collateral gain calculations. The impact includes incorrect state updates, unfair reward allocation, and potential exploitation of miscalculated gains, though the risk is mitigated by the rarity of such edge cases.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::offset"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Pool Deposit Are Compared to Precision",
            "description": "The _updateYieldRewardsSum function compares total deposits to DECIMAL_PRECISION instead of the standard MIN_BOLD_IN_SP constant used elsewhere, despite both having the same value (1e18). While this does not result in functional bugs due to identical values, it introduces inconsistency and potential risk if constants are later changed independently. The cause is code duplication and lack of centralized constant usage. This could lead to future bugs if one constant is updated without the other. The impact is low, as no immediate exploit exists, but it represents a correctness issue in code consistency and maintainability.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1107"
                ]
            },
            "title": "Total Deposit Are Compared to Wrong Constant",
            "description": "Similar to the previous issue, _updateYieldRewardsSum uses DECIMAL_PRECISION instead of MIN_BOLD_IN_SP when checking total deposits for yield distribution thresholds. Although both constants are equal (1e18), this creates a discrepancy in codebase consistency. The root cause is redundant use of different constants for the same logical threshold. There is no immediate security impact, but it increases technical debt and risk of future divergence. The impact is limited to code clarity and maintainability, classified as a low-severity correctness issue.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Batches Can Be Used to Make Two Free Adjustments in a Row",
            "description": "Users can exploit the batch interest rate adjustment mechanism to perform two interest rate changes in a row without paying the required upfront fee. The cause is that setBatchManagerAnnualInterestRate only checks the batch's last adjustment time, not individual trove adjustments. A user can join a batch that was adjusted long ago, change its interest rate, and leave\u2014effectively adjusting their own rate twice within the cooldown period. This allows strategic avoidance of redemption risk while minimizing cost. The impact includes unfair advantage, manipulation of interest rates, and potential abuse of the system's economic model, though the financial impact is limited.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::setInterestBatchManager",
                "BorrowerOperations.sol::setBatchManagerAnnualInterestRate"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Delegation Specification",
            "description": "The code initially allowed the receiver address (set by a Remove Manager) to receive collateral during any withdrawal, including those initiated by the owner, contrary to the documentation which states the receiver only gets funds during Remove Manager actions. The cause is a mismatch between specification and implementation. This could lead to user funds being sent to an unintended address if the receiver is set and the owner withdraws. The impact is potential loss of user funds and confusion due to undocumented behavior. The issue was corrected to align code with documentation.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::withdrawCollateral"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unredeemable Troves Can Pay Minimum Interest Rate",
            "description": "Troves with debt below MIN_DEBT are marked as unredeemable (zombie troves) and excluded from redemption lists, removing the risk of redemption and thus the incentive to pay higher interest rates. An attacker can create many such troves to pay only the minimum interest, gaining an unfair economic advantage. The cause is the design decision to exclude small troves from redemption lists. While mitigated by gas and capital costs, the strategy could still be profitable under certain conditions. The partial fix ensures zombie troves are redeemed first during redemptions, but an edge case remains where liquidated troves with zero debt can still become unredeemable and pay minimal interest. The impact is economic inefficiency and potential abuse of the interest model.\n",
            "severity": "Medium",
            "location": [
                "TroveManager.sol",
                "RedemptionLogic.sol"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy in swapFromBold Behavior",
            "description": "The UniV3Exchange and CurveExchange implementations of swapFromBold behave differently: UniV3 uses ExactOutput (fixing output, variable input), while Curve uses ExactInput (fixing input, variable output), leading to inconsistent handling of excess tokens. The cause is the use of different swap semantics across exchange adapters. This can result in unexpected leftover tokens in different contracts, complicating user expectations and integration logic. Liquity acknowledged the inconsistency but noted future exchanges may not support a uniform model. The impact is low, limited to usability and predictability, with no direct fund loss.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.sol::swapFromBold",
                "CurveExchange.sol::swapFromBold"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect Code Comments",
            "description": "The code contains outdated, inaccurate, or misleading comments and natspec documentation across several functions and contracts. For example, references to the deprecated \"composite debt\" concept from Liquity V1 persist in V2, where gas compensation is now handled in WETH. Additionally, some comments describe logic that no longer applies, such as redemption order based on collateral ratio when it is now based on interest rate.\n\nThe cause is that the comments were not updated during the transition from Liquity V1 to V2 or during subsequent logic changes. Some are the result of copy-paste from older versions or incomplete refactoring.\n\nWhile the code itself is correct, misleading comments could lead developers or auditors to misunderstand the system's behavior, potentially introducing bugs during future maintenance or upgrades.\n\nThe primary impact is reduced code maintainability and increased risk of human error during development or auditing. Although the runtime behavior is unaffected, incorrect documentation may lead to incorrect assumptions and future vulnerabilities.\n",
            "severity": "Low",
            "location": [
                "ActivePool._mintBatchManagementFeeAndAccountForChange",
                "BorrowerOperations._openTrove",
                "BorrowerOperations._applyUpfrontFee",
                "TroveManager.redeemCollateral",
                "LiquityMath._decPow",
                "StabilityPool.sortedTroves",
                "TroveManager.Batch",
                "MainnetPriceFeedBase.priceFeedDisabled",
                "TroveManager._urgentRedeemCollateralFromTrove",
                "BorrowerOperations.adjustUnredeemableTrove"
            ],
            "files": [
                "bold/contracts/src/ActivePool.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Interest Delegates Are More Trusted Than Needed",
            "description": "Interest rate delegates can update the interest rate without any time-based restriction, allowing them to repeatedly trigger the upfront fee mechanism and potentially grief users by forcing frequent fee payments.\n\nThe cause is that while there are limits on the magnitude of interest rate changes, there is no cooldown period enforced between updates, unlike the mechanism available to users for batch managers.\n\nA malicious or compromised delegate could adjust the interest rate multiple times in quick succession, each time triggering an upfront fee for users who interact with the system, thereby increasing their costs.\n\nUsers may incur unnecessary fees, leading to a degraded user experience and potential financial loss. This represents a form of griefing rather than direct fund theft.\n",
            "severity": "Low",
            "location": [
                "InterestRateDelegate"
            ],
            "files": []
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Payable Modifier",
            "description": "The function `WETHZapper.adjustZombieTroveWithRawETH` lacks the `payable` modifier despite being designed to receive Ether for conversion to WETH, causing transactions that send Ether to revert.\n\nThe cause is the `payable` modifier was omitted during implementation, making the function unable to accept Ether even though its internal logic expects it.\n\nAny attempt to call this function with Ether will fail, preventing the adjustment of zombie troves via the zapper. This disrupts a legitimate use case for trove recovery.\n\nUsers cannot use the zapper to fix zombie troves unless the function is redeployed with the `payable` modifier, limiting functionality and potentially leading to full redemption of affected troves.\n",
            "severity": "Low",
            "location": [
                "WETHZapper.adjustZombieTroveWithRawETH"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation of Troves in Urgent Redemptions",
            "description": "The `TroveManager.urgentRedemption` function does not validate whether a trove exists, is active, or has debt before processing, leading to unnecessary gas consumption and storage writes.\n\nThe cause is input validation for trove status and debt amount is missing in the function logic.\n\nAn attacker could submit redemption requests for non-existent or closed troves, causing the system to perform redundant storage operations and waste gas.\n\nIncreased gas costs for transactions and unnecessary state bloat. While no critical state corruption occurs, external applications reading from storage may observe incorrect or stale data.\n",
            "severity": "Low",
            "location": [
                "TroveManager.urgentRedemption",
                "TroveManager._applySingleRedemption"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Opening Troves Can Be Blocked",
            "description": "The trove ID in `BorrowerOperations._openTrove` is derived only from the owner and owner index, making it predictable and susceptible to frontrunning. An attacker can open a trove with the same ID, set themselves as manager, and steal the collateral.\n\nThe cause is that the trove ID does not include the caller (`msg.sender`), allowing anyone to replicate the ID and preempt the intended user.\n\nAn attacker monitors pending transactions and frontruns a trove creation by submitting their own with the same owner and index, becoming the manager and later withdrawing the collateral.\n\nUsers, especially multisigs or governance systems with delayed execution, can be permanently prevented from opening troves, leading to denial of service and potential loss of funds if the attacker withdraws collateral.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations._openTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-396"
                ]
            },
            "title": "Out-of-gas May Lead to Shutdown",
            "description": "The `MainnetPriceFeedBase.fetchPrice` function can trigger a system shutdown if the Chainlink oracle call runs out of gas, due to a catch block that treats all reverts as oracle failure.\n\nThe cause is that the try-catch block does not distinguish between out-of-gas reverts and actual oracle failures, leading to a false positive shutdown signal.\n\nAn attacker could call `fetchPrice` with a gas limit calibrated to cause the oracle call to exhaust gas, triggering an unintended shutdown if the remaining gas is sufficient to execute the shutdown logic.\n\nA temporary or permanent shutdown of the system could occur without an actual oracle failure, disrupting all operations. Although currently infeasible due to gas costs, future changes could make this attack viable.\n",
            "severity": "Low",
            "location": [
                "MainnetPriceFeedBase._getCurrentChainlinkResponse",
                "WSTETHPriceFeed._getCanonicalRate"
            ],
            "files": [
                "bold/contracts/src/PriceFeeds/MainnetPriceFeedBase.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Price Limit in UniV3Exchange Is Too Strict",
            "description": "The `UniV3Exchange.getBoldAmountToSwap` function uses a price limit that is too strict, based on the maximum output price rather than the average trade price, leading to suboptimal swaps.\n\nThe cause is that the price limit is derived directly from `_maxBoldAmount / _minCollAmount`, which does not reflect the actual average execution price of the swap.\n\nUsers may be forced to use looser price bounds than necessary, increasing slippage and allowing MEV bots to extract more value during large swaps.\n\nReduced swap efficiency and increased vulnerability to MEV, resulting in worse execution prices for users.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.getBoldAmountToSwap"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Shutdown Can Be Triggered Twice",
            "description": "The `shutdown` function in `BorrowerOperations` can be called when the TCR is below SCR, but it also calls `priceFeed.fetchPrice()`, which may independently trigger a shutdown due to oracle failure, resulting in two shutdown events.\n\nThe cause is that the function does not check whether the oracle call already caused a shutdown before proceeding with the TCR-based shutdown logic.\n\nIf both conditions occur simultaneously, two shutdown events are emitted, which may confuse off-chain monitoring systems that expect mutually exclusive shutdown causes.\n\nIncorrect event logging and potential misinterpretation by external systems, though no functional harm occurs due to idempotent shutdown logic.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.shutdown"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "User-provided transferFrom Source Address",
            "description": "The `UniV3Exchange` and `CurveExchange` contracts use a user-provided `_zapper` address in `transferFrom` calls, allowing arbitrary token pulls from approved addresses.\n\nThe cause is using a user-controlled address as the `from` parameter in `transferFrom` violates secure coding practices and introduces unintended token access.\n\nAn attacker could drain tokens from any address that has approved the exchange contract, including zappers or users who mistakenly approved it.\n\nRisk of unauthorized token transfers, though the actual impact is limited since zappers are not intended to hold balances.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.swapFromBold",
                "UniV3Exchange.SwapToBold",
                "CurveExchange.swapFromBold",
                "CurveExchange.SwapToBold"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ],
                "4": [
                    "CWE-226"
                ]
            },
            "title": "Zapper Delegation Is Not Reset When a Trove Is Closed",
            "description": "When a trove is closed, delegation settings in the zapper are not reset, allowing reuse of old delegations if a new trove with the same ID is created.\n\nThe cause is that the system allows trove ID reuse and does not clear zapper delegation upon trove closure.\n\nAn attacker could create and close a trove to set malicious delegations, which persist and affect future troves with the same ID, potentially leading to loss of control.\n\nUsers may unknowingly grant control to unauthorized addresses if they reuse trove IDs, leading to potential fund loss or unauthorized actions.\n",
            "severity": "Low",
            "location": [
                "Zapper"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Gas Optimizations in StabilityPool",
            "description": "Several gas inefficiencies were identified in the `StabilityPool` contract, including unnecessary checks, redundant arithmetic, and ineffective function calls.\n\nThe cause is suboptimal code structure and lack of early returns or simplifications in yield calculation and withdrawal logic.\n\nThese inefficiencies increase transaction costs for users but do not enable malicious exploitation.\n\nHigher gas consumption for depositors and withdrawers, reducing user experience and increasing operational costs.\n",
            "severity": "Informational",
            "location": [
                "StabilityPool.getDepositorYieldGainWithPending",
                "StabilityPool.withdrawFromSP"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Receiver Address in Balancer Flashloan Is Reset Late",
            "description": "The `BalancerFlashLoan` contract sets the receiver address at the start of `makeFlashLoan` but resets it only after the callback, rather than in the `receiveFlashLoan` function.\n\nThe cause is that the reset logic is placed in the wrong function, increasing the window during which the receiver state is set.\n\nWhile not currently exploitable, this pattern increases the risk of reentrancy or state inconsistency in future modifications or forks.\n\nIncreased risk of future vulnerabilities due to poor state management hygiene.\n",
            "severity": "Informational",
            "location": [
                "BalancerFlashLoan.makeFlashLoan",
                "BalancerFlashLoan.receiveFlashLoan"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Backed Tokens Can Be Redeemed Unproportionally",
            "description": "The `redeemCollateral` function in `CollateralRegistry` can redeem disproportionately from a single branch when not all branches are fully backed, violating fairness assumptions.\n\nThe cause is that the redemption logic does not cap the amount by total unbacked debt when some branches are partially backed.\n\nAn attacker could redeem large amounts from a single branch before it becomes fully backed, gaining an unfair advantage over proportional redemption.\n\nUnfair distribution of collateral during redemptions, potentially leading to economic imbalance between branches.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "CEI Pattern Violated in Adjust Trove",
            "description": "The `WETHZapper._adjustTrovePost` function sends ETH before BOLD tokens, violating the Checks-Effects-Interactions (CEI) pattern and exposing the contract to reentrancy risks.\n\nThe cause is that the order of external calls is incorrect; ETH is sent first, allowing a malicious receiver to reenter the contract.\n\nA malicious contract receiving ETH could reenter the system before state changes are finalized, potentially manipulating logic.\n\nRisk of reentrancy attacks, though mitigated by the non-reentrant nature of the BOLD token.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePost"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Comments From Development",
            "description": "The codebase contains leftover development artifacts such as TODOs, commented-out code, and test imports, which should not be present in production.\n\nThe cause is incomplete cleanup before deployment.\n\nThese do not pose direct security risks but may confuse auditors or developers.\n\nReduced code clarity and professionalism, increasing the risk of oversight during maintenance.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._getLatestTroveDataFromBatch",
                "TroveManager",
                "Various functions with TODOs"
            ],
            "files": []
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Core Debt Invariant Incorrectly Documented",
            "description": "The documented core debt invariant omits `defaultPool.BoldDebt`, making it incorrect.\n\nThe cause is that the documentation was not updated to reflect the full debt accounting model.\n\nMisleading documentation could lead developers to make incorrect assumptions about system invariants.\n\nRisk of logic errors during development or auditing due to reliance on incorrect invariants.\n",
            "severity": "Informational",
            "location": [
                "Documentation"
            ],
            "files": []
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Floating Pragma",
            "description": "Some contracts use a floating Solidity pragma, which can lead to compilation with untested compiler versions.\n\nThe cause is lack of version pinning in pragma statements.\n\nCompiling with an untested version may introduce compiler-specific bugs or optimizations.\n\nIncreased risk of deployment issues or undefined behavior due to compiler version mismatches.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry.sol"
            ],
            "files": []
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Inconsistent Input Validation by Zappers",
            "description": "Zapper contracts have inconsistent input validation; for example, `WETHZapper` enforces non-zero debt increases while `GasCompZapper` does not.\n\nThe cause is lack of shared validation logic across zapper implementations.\n\nWhile harmless in practice, inconsistent checks reduce code reliability and maintainability.\n\nPotential for future bugs if validation logic diverges further.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePre",
                "GasCompZapper._adjustTrovePre"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol",
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Indexed Parameters of Events",
            "description": "The `CollSent` event in `CollSurplusPool` does not index the `_to` parameter, making it harder for off-chain services to query withdrawals.\n\nThe cause is that the event parameter was not marked as `indexed`.\n\nNo direct exploit, but reduces usability for external applications.\n\nInefficient event querying for wallets and analytics tools.\n",
            "severity": "Informational",
            "location": [
                "CollSurplusPool.CollSent"
            ],
            "files": [
                "bold/contracts/src/CollSurplusPool.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Minting Unbacked Tokens via Redistributions",
            "description": "A rounding issue in debt share calculations allowed attackers to mint unbacked tokens by manipulating exchange rates and triggering redistributions.\n\nThe cause is that debt redistribution logic did not account for rounding down when calculating debt shares, allowing debt to be allocated without corresponding shares.\n\nAn attacker could open troves, manipulate exchange rates, and trigger redistributions to increase debt without minting shares, effectively creating unbacked tokens.\n\nRisk of protocol insolvency if exploited at scale, particularly in low-liquidity branches.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._getLatestTroveDataFromBatch",
                "TroveManager.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Misleading Function Names in Zapper",
            "description": "Functions in `GasCompZapper` use names like `adjustTroveWithRawETH` that imply ETH handling, but the contract does not operate with raw ETH.\n\nThe cause is inconsistent naming across zapper implementations.\n\nMisleading names could cause developers to misuse the functions or misunderstand their behavior.\n\nIncreased risk of integration errors and developer confusion.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.adjustTroveWithRawETH"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing Events",
            "description": "The `AddRemoveManager._setAddManager` and `_setRemoveManager` functions do not emit events when manager roles are updated.\n\nThe cause is event emission was omitted during implementation.\n\nUsers cannot track changes to manager roles, especially after transferring Trove NFTs.\n\nReduced transparency and auditability, making it harder for users to monitor access control changes.\n",
            "severity": "Informational",
            "location": [
                "AddRemoveManager._setAddManager",
                "AddRemoveManager._setRemoveManager"
            ],
            "files": [
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Unimplemented Function Can Be Called",
            "description": "The contracts GasCompZapper and WETHZapper define functions `receiveFlashLoanOnOpenLeveragedTrove`, `receiveFlashLoanOnLeverUpTrove`, and `receiveFlashLoanOnLeverDownTrove` with empty function bodies. These functions are not marked as virtual or intended to be overridden in derived contracts, yet they can still be called externally. Since the functions perform no operations, calling them results in silent success without any side effects. This could mislead callers into believing the functions perform meaningful actions. If these functions are not meant to be called, they should revert to prevent misuse and clarify intent.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.sol",
                "WETHZapper.sol"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol",
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Bypassing Collateral Adjustment Check",
            "description": "The function BorrowerOperations._requireValidAdjustmentInCurrentMode prevents reducing collateral in undercollateralized troves (ICR < MCR). However, this check can be bypassed via self-redemptions: a user can first adjust the interest rate of their trove to be the lowest in the branch, then redeem from it. This sequence allows indirect reduction of collateral in an undercollateralized state. While Liquity acknowledges this behavior, they argue it does not allow converting a healthy trove into an undercollateralized one, thus posing minimal risk. Nevertheless, this represents a deviation from expected system invariants.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._requireValidAdjustmentInCurrentMode"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified across several contracts:\n1. ActivePool.mintBatchManagementFeeAndAccountForChange() is protected by a modifier that allows BorrowOperations or TroveManager, but is only ever called by TroveManager.\n2. ActivePool.calcPendingAggInterest() and calcPendingAggBatchManagementFee() could short-circuit early when the timestamp hasn't changed.\n3. TroveManager._getLatestTroveDataFromBatch() reads the entire batch struct but uses only one value.\n4. CollateralRegistry._requireBoldBalanceCoversRedemption() reasserts an invariant already enforced by OpenZeppelin's token implementation.\n5. TroveManager._redistributeDebtAndColl can skip sending zero collateral to DefaultPool.\n6. UniV3Exchange._requireCallerIsUniV3Router() and uniswapV3SwapCallback() are defined but never used.\n7. BorrowerOperations.adjustTroveInterestRate charges an upfront fee only if the rate changes, but _requireAnnualInterestRateIsNew makes this redundant.\n8. StabilityPool.sortedTroves is declared immutable but never used.\n9. Several state variables in TroveManager, BorrowerOperations, and ActivePool could be marked immutable for gas savings.\n10. WSTETHPriceFeed._fetchPrice() can be optimized by calling stETH directly instead of through wstETH.\n11. priceToSqrtPrice and _zeroForOne in UniV3Exchange are unused.\n12. TroveManager._requireBelowMaxSharesRatio could short-circuit before multiplication.\nSome of these (6, 7, 14) were partially corrected in Version 2.\n",
            "severity": "Informational",
            "location": [
                "ActivePool.mintBatchManagementFeeAndAccountForChange",
                "ActivePool.calcPendingAggInterest",
                "ActivePool.calcPendingAggBatchManagementFee",
                "TroveManager._getLatestTroveDataFromBatch",
                "CollateralRegistry._requireBoldBalanceCoversRedemption",
                "TroveManager._redistributeDebtAndColl",
                "UniV3Exchange._requireCallerIsUniV3Router",
                "UniV3Exchange.uniswapV3SwapCallback",
                "BorrowerOperations.adjustTroveInterestRate",
                "StabilityPool.sortedTroves",
                "BorrowerOperations._requireIsShutDown",
                "WSTETHPriceFeed._fetchPrice",
                "TroveManager contract state variables",
                "BorrowerOperations contract state variables",
                "ActivePool contract state variables",
                "UniV3Exchange.priceToSqrtPrice",
                "UniV3Exchange._zeroForOne",
                "TroveManager._requireBelowMaxSharesRatio"
            ],
            "files": []
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Insufficient Gas Compensation Could Mint Bad Debt",
            "description": "The system relies on gas compensation to incentivize liquidations. If the gas cost exceeds the compensation, liquidators may not act, leading to accumulation of bad debt. This can occur during prolonged periods of high gas prices or falling collateral values. An attacker could exploit this by creating a batch with maximum interest rate and joining the Stability Pool, allowing unbacked tokens to be minted via interest accrual if the trove remains unliquidated. Although such attacks carry risk (anyone can liquidate at a loss to punish the attacker), they illustrate a theoretical pathway for minting unbacked debt. The risk is considered low due to economic disincentives and prioritization of large troves for liquidation.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Price Deviation in Composite Price Feed",
            "description": "The RETHPriceFeed computes RETH/USD as the product of RETH/ETH and ETH/USD prices. With Chainlink deviation thresholds of 2% and 0.5% respectively, the combined price can deviate up to ~2.5% before updating. During branch shutdowns triggered by TCR < SCR, the protocol offers a 1% bonus on oracle price, which may be insufficient to cover this deviation. Additionally, the canonical rate from Rocket Pool updates every 24 hours, potentially delaying urgent redemptions. This creates a window where users may receive less value than expected during critical events. Liquity acknowledges this as a known and accepted risk.\n",
            "severity": "Informational",
            "location": [
                "RETHPriceFeed",
                "CompositePriceFeed._fetchPrice",
                "TroveManager.urgentRedemption"
            ],
            "files": [
                "bold/contracts/src/PriceFeeds/RETHPriceFeed.sol",
                "bold/contracts/src/PriceFeeds/CompositePriceFeed.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small Redemptions Do Not Increase Base Rate",
            "description": "The function CollateralRegistry._getUpdatedBaseRateFromRedemption calculates the base rate based on the fraction of BOLD redeemed. Due to integer division rounding down, very small redemptions (e.g., less than totalSupply / 1e18) result in zero base rate increase. This allows strategic splitting of redemptions to avoid fees, though at higher gas cost. For example, with a 10B total supply, redemptions below 1e-8 BOLD have no effect. Liquity acknowledges this but considers the amounts negligible and not economically viable to exploit.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry._getUpdatedBaseRateFromRedemption"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Upfront Fee Is Zero for Small Borrows",
            "description": "The upfront fee in BorrowerOperations._calcUpfrontFee is calculated as a fraction of debt and interest rate over time. Due to precision limitations, the fee rounds to zero for small borrows. For instance, with a 0.5% average interest rate, any borrow below 10,400 wei pays no fee. Similarly, interest accrual on small troves may also round to zero. This primarily affects zombie troves with negligible debt. Liquity acknowledges the issue but deems the impact negligible at both user and system levels.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._calcUpfrontFee",
                "_calcInterest"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Upfrontfee Can Bring Troves Below MCR",
            "description": "While BorrowerOperations._applyUpfrontFee includes a check to ensure ICR remains above MCR, the function setBatchManagerAnnualInterestRate lacks this protection. As a result, charging an upfront fee during a batch interest rate adjustment could push a trove below MCR. However, interest can only be adjusted once per second, limiting the potential for repeated manipulation within a block. In Version 5, a 10% collateral buffer was introduced to prevent single-transaction liquidation exploits. This mitigates the most critical variant where a user could open a trove at 110%, pay an upfront fee, and immediately liquidate it in one transaction. The attack is now only possible over time.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations._applyUpfrontFee",
                "setBatchManagerAnnualInterestRate"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "rETH Address Might Change",
            "description": "The rETH token address is set once in the AddressesRegistry and cannot be updated. However, Rocket Pool recommends retrieving addresses dynamically from their registry contract rather than hardcoding them. Although Liquity contacted Rocket Pool and was assured the rETH address is unlikely to change, the current design does not support migration if it ever does. This creates a potential long-term integration risk, especially if Rocket Pool upgrades its token contract.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry"
            ],
            "files": [
                "bold/contracts/src/AddressesRegistry.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Add Manager Can Increase Stake",
            "description": "The addManager role allows anyone to add collateral to a trove. While this improves collateralization, it also increases the trove\u2019s stake in the system. In extreme cases involving negative redistributions (where debt increases more than collateral), an attacker could manipulate another user\u2019s trove to increase their share of losses. Users can mitigate this by setting the addManager to their own address, effectively disabling third-party deposits.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "CCR and SCR Considerations",
            "description": "The Close Crowdfunding Ratio (CCR) and Shutdown Collateralization Ratio (SCR) must be sufficiently far apart to prevent attackers from frontrunning oracle updates to trigger branch shutdowns. If CCR is too close to SCR, a price drop could be exploited to force a shutdown. This mirrors known attacks in Liquity V1. The proposed values (CCR=1.5, SCR=1.1) are considered safe, but future deployments with tighter margins should evaluate this risk.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/AddressesRegistry.sol"
            ]
        },
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Delegations Are Deleted on Liquidation",
            "description": "Upon liquidation, all delegations for a trove are deleted via the _BorrowerOperations.onLiquidateTrove hook. Only the trove owner can reclaim surplus collateral; delegated accounts cannot. If the owner is a smart contract, it must implement claimCollateral() directly and cannot rely on delegation. Failure to do so risks permanent loss of surplus collateral.\n",
            "severity": "Informational",
            "location": [
                "_BorrowerOperations.onLiquidateTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Frontrunning Considerations for Off-Chain Infrastructure",
            "description": "Off-chain systems must account for frontrunning risks:\n1. redeemCollateral uses user-provided max amount for fee calculation, which may exceed actual redemption, leading to overpayment.\n2. Setting _maxFeePercentage may cause reverts if base rate increases due to prior redemptions.\n3. Liquidation order affects redistributions, which can alter the health of other troves.\nIntegrators should consider using wrapper contracts to dynamically compute safe redemption amounts.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Fully Backed Branches Can Have Low Interest Rates",
            "description": "Branches with more BOLD in Stability Pool than outstanding debt are \"fully backed\" and immune to redemptions. This removes the incentive to maintain high interest rates, leading to rate drops to the minimum. If the branch later becomes unbacked (via withdrawals, liquidations, or new debt), troves may face sudden redemption pressure. The system may self-correct if Stability Pool deposits decrease due to lower yields, but the dynamics are uncertain.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 47,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Inconsistent Use of Receivers in Zappers",
            "description": "Zapper contracts use a receiver pattern inconsistently:\n- adjustTroveWithRawETH sends WETH and BOLD to the zapper's receiver, extra BOLD to msg.sender.\n- closeTroveFromCollateral sends all funds to the zapper's receiver.\n- openTroveWithRawETH sends BOLD to msg.sender.\nThis inconsistency may lead to unexpected fund flows for integrators and users.\n",
            "severity": "Informational",
            "location": [
                "Zappers"
            ],
            "files": [
                "bold/contracts/src/Zappers"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Integration Notes for Smart Contract Devs",
            "description": "Several behaviors may surprise integrators:\n- repayBold and adjustTrove repay only up to MIN_DEBT, leaving excess with caller.\n- withdrawFromSP withdraws full balance if _amount exceeds user\u2019s deposit.\n- Trove state can change between calls due to batch-wide effects (e.g., rounding).\nContracts must handle partial executions and dynamic state changes.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations.repayBold",
                "BorrowerOperations.adjustTrove",
                "StabilityPool.withdrawFromSP",
                "TroveManager.getLatestTroveData"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Interest Rate Adjustments Below CCR",
            "description": "When TCR falls below CCR, debt-increasing operations (including upfront fee payments for interest rate adjustments) are blocked. This prevents users from increasing their interest rate to avoid redemptions once below CCR. Users must act before crossing this threshold, as adjustments are subject to a cooldown period.\n",
            "severity": "Informational",
            "location": [
                "INTEREST_RATE_ADJ_COOLDOWN"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Manipulating Bold Supply With Flashloans",
            "description": "Users can use flashloans to inflate BOLD supply temporarily, reducing redemption fees (which are proportional to supply). For example, doubling supply halves the fee on large redemptions. If the average interest rate post-borrow is low (e.g., 1%), this can be profitable. Users can avoid self-redemption by depositing minted BOLD into the Stability Pool. This behavior is economically rational but may distort fee mechanisms.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/StabilityPool.sol",
                "bold/contracts/src/BoldToken.sol"
            ]
        },
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "No Interest Paid on Pending Redistributions",
            "description": "Debt from liquidations is held in DefaultPool until a trove is touched. No interest accrues on this pending debt. Additionally, the upfront fee calculation ignores pending debt (which has 0% rate), potentially overestimating the effective system interest rate. This leads to minor inaccuracies in fee modeling.\n",
            "severity": "Informational",
            "location": [
                "DefaultPool"
            ],
            "files": [
                "bold/contracts/src/DefaultPool.sol"
            ]
        },
        {
            "id": 52,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Possible Attacks Against Zapper Users",
            "description": "Zapper users are vulnerable to two types of attacks if trove state changes between transaction submission and execution:\n1. **Extracting Redistribution Profits**: After a redistribution makes a trove redeemable, an attacker can redeem just enough to pass minExpectedCollateral and capture the profit via slippage.\n2. **Extracting Redemption Fees**: After a high-fee redemption, an attacker can donate collateral to pass minExpectedCollateral and extract the fee via slippage.\nThese attacks exploit the fact that zapper functions use slippage buffers that absorb newly accrued value.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper.closeTroveFromCollateral",
                "_flashLoanAmount"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 53,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Sending NFTs Does Not Reset Delegation",
            "description": "Troves are NFTs and can be transferred. However, delegation settings (e.g., removeManager, receiver) are not reset on transfer. A seller could set themselves as removeManager at the last moment and later remove collateral. Buyers should ensure delegation is reset during purchase. Additionally, zappers have their own delegation settings, which must also be reviewed.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "bold/contracts/src/TroveNFT.sol",
                "bold/contracts/src/Zappers/BaseZapper.sol",
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 54,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Trove Shares Exchange Rate Invariant",
            "description": "The function TroveManager._updateBatchShares() rounds down when reducing debt, which can slightly reduce debt per share. While the protocol assumes a 1:1 debt-to-share ratio, rounding could theoretically cause discrepancies. In extreme cases, this could lead to overflow in debt calculations (e.g., when totalDebtShares is extremely large). Full redemptions may leave residual shares due to division truncation. In Version 2, full closures now set shares to zero to avoid this. The core invariant \u2014 that debt per share never falls below 1 \u2014 must be preserved.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._updateBatchShares",
                "TroveManager._getLatestTroveDataFromBatch"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 55,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Zapper Remove Manager Requires Increased Trust",
            "description": "In core contracts, the removeManager cannot directly profit from malicious actions because funds go to the receiver. In zappers, however, the removeManager controls swap parameters in leverage functions. A malicious removeManager can execute trades at unfavorable rates or sandwich attacks to extract value from the trove owner. Thus, the removeManager in zappers requires higher trust than in core contracts.\n",
            "severity": "Informational",
            "location": [
                "Zapper removeManager"
            ],
            "files": []
        }
    ]
}