{
    "path": "dataset-curated/reports/OpenZeppelin/SSO Account OIDC Recovery Solidity Audit.md",
    "project_info": {
        "url": [
            "https://github.com/matter-labs/zksync-sso-clave-contracts"
        ],
        "commit_id": [
            "ed21d09add8da99d9c82d0f7c30659625c6636e6"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-04-03",
        "project_path": {
            "zksync-sso-clave-contracts": "dataset-curated/contracts/SSO Account OIDC Recovery Solidity Audit.md-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Potential Signature Replay Attack in ERC1271Handler",
            "description": "The `isValidSignature` function in the `ERC1271Handler` contract lacks sufficient validation to prevent signature replay attacks. For EOA signatures, the function only verifies the signature's validity and its association with a `k1owner`, without imposing restrictions on how the hash is constructed. This allows an attacker to reuse a historical transaction hash and signature to execute unauthorized actions on behalf of the account. Additionally, the removal of EIP712 logic in the updated version eliminates safeguards such as inclusion of chain ID and contract address in the hash, enabling cross-chain and cross-account signature reuse. The impact includes unauthorized execution of transactions and potential loss of account control. The vulnerability stems from insufficient input validation and the absence of replay protection mechanisms.\n",
            "severity": "High",
            "location": [
                "ERC1271Handler.sol::isValidSignature#25"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/handlers/ERC1271Handler.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Key Ordering in _compactKeys Function Leads to Potential Overwriting of New Keys",
            "description": "The `_compactKeys` function in the `OidcKeyRegistry` contract reorders keys starting from the current index pointer instead of from zero after a key is removed. This causes incorrect realignment of the key buffer, leading to a misaligned insertion pointer. As a result, newer keys may be overwritten before older ones, violating the intended FIFO (First In, First Out) replacement policy. An attacker or even normal operations could trigger a state where critical newer keys are prematurely lost, compromising the integrity of the OIDC key registry. The root cause is flawed array compaction logic that fails to reset indexing after compaction. This could lead to denial of service for account recovery if valid keys are overwritten.\n",
            "severity": "Medium",
            "location": [
                "OidcKeyRegistry.sol::_compactKeys#158"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Insufficient Validation of RSA Moduli and Exponent in _validateKeyBatch",
            "description": "The `_validateKeyBatch` function in the `OidcKeyRegistry` contract performs incomplete validation of RSA cryptographic parameters. While it checks for non-zero exponents and basic modulus structure, it does not enforce a minimum bit length (e.g., 2048 bits) for the modulus, nor does it verify that the modulus is odd\u2014both essential for RSA security. Small or even moduli are vulnerable to factorization attacks, and small exponents can be exploited in known cryptographic attacks. The lack of these checks allows potentially weak cryptographic keys to be registered, undermining the security of the entire OIDC-based recovery mechanism. The root cause is missing validation logic for critical RSA parameter constraints.\n",
            "severity": "Medium",
            "location": [
                "OidcKeyRegistry.sol::_validateKeyBatch#207",
                "OidcKeyRegistry.sol::_validateModulus#251",
                "OidcKeyRegistry.sol::_hasNonZeroExponent#236"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "Unauthorized Control via Manipulated pendingPasskeyHash in startRecovery Process",
            "description": "The `startRecovery` function in the `OidcRecoveryValidator` contract does not validate the `pendingPasskeyHash` parameter before storing it, even though it is critical for determining who can complete the recovery. While the ZK proof verifies ownership of the OIDC identity, the `pendingPasskeyHash` is not bound to the proof. This allows an attacker who possesses a valid ZK proof (e.g., a malicious third party or compromised prover) to set a `pendingPasskeyHash` for which they control the private key, thereby hijacking the recovery process and taking control of the target account. The impact is full unauthorized account takeover. The root cause is the lack of cryptographic binding between the `pendingPasskeyHash` and the ZK proof.\n",
            "severity": "Medium",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#201",
                "OidcRecoveryValidator.sol#L239C58-L239C76"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Duplicate kid Values in OidcKeyRegistry Allow for Partial Key Deletion and Retrieval",
            "description": "The `addKeys` function in the `OidcKeyRegistry` contract does not enforce uniqueness of the `kid` (key ID) field, allowing multiple keys with the same `kid` to be registered. When `deleteKey` is called with a `kid`, only the first matching key is removed, leaving duplicates in storage. Similarly, `getKey` returns only the first match, potentially returning an unintended key. This can lead to a situation where a compromised key cannot be fully revoked, leaving the system vulnerable to misuse. The root cause is the absence of a uniqueness check during key addition. This undermines the reliability and security of key management.\n",
            "severity": "Low",
            "location": [
                "OidcKeyRegistry.sol::addKeys#100",
                "OidcKeyRegistry.sol::deleteKey#191",
                "OidcKeyRegistry.sol::getKey#118"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Front-Running in addOidcAccount Account Registration",
            "description": "The `addOidcAccount` function in the `OidcRecoveryValidator` contract uses a `digestIndex` mapping to prevent reuse of OIDC digests. However, since the registration transaction is visible in the mempool, a malicious actor can monitor pending transactions and front-run a legitimate user by submitting a transaction with the same `oidcDigest`. This causes the legitimate user's transaction to revert, blocking their ability to register their OIDC identity. Although the risk is currently mitigated by the lack of public mempools on elastic chain operators, this remains a potential future threat. The root cause is the absence of a commitment-reveal scheme or account binding in the registration process.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::addOidcAccount#163"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Builtin Getter for OIDCKeys Does Not Return n",
            "description": "The `OIDCKeys` state variable in the `OidcKeyRegistry` contract is declared as `public`, which automatically generates a getter function. However, Solidity's default getter does not return array or complex struct members, so the `n` (modulus) field is omitted from the returned data. This can mislead external callers into thinking the getter returns complete key data, when in fact it only returns `issHash`, `kid`, and `e`. The root cause is the misuse of `public` visibility for a struct containing non-primitive types. This can lead to incorrect assumptions in off-chain applications or integrations.\n",
            "severity": "Low",
            "location": [
                "OidcKeyRegistry.sol::OIDCKeys#77"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-282"
                ],
                "3": [
                    "CWE-283"
                ]
            },
            "title": "Potential Loss of Ownership During Transfer",
            "description": "The `OidcKeyRegistry` contract uses a single-step ownership transfer mechanism, where the new owner is immediately assigned without requiring confirmation. If the address is incorrect or inaccessible, ownership is permanently lost with no recovery mechanism. This increases operational risk and could lead to irreversible loss of administrative control over the contract. The root cause is the lack of a two-step ownership transfer pattern. Implementing a confirmatory step would mitigate this risk.\n",
            "severity": "Low",
            "location": [
                "OidcKeyRegistry.sol#11"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/OidcKeyRegistry.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Inflexible Recovery Process Termination in OidcRecoveryValidator",
            "description": "The `OidcRecoveryValidator` contract does not provide a way to cancel an ongoing recovery process without completely removing the account's OIDC linkage via `deleteOidcAccount`. This forces users to choose between leaving a recovery pending or losing the ability to recover in the future. The root cause is the absence of a dedicated cancellation mechanism. This reduces user control and security flexibility, especially if the user regains access through alternative means.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#239",
                "OidcRecoveryValidator.sol::deleteOidcAccount#182"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Delayed Recovery Validation May Compromise Account Security",
            "description": "The `OidcRecoveryValidator` contract checks the proof's time limit only during `startRecovery`, but not during `validateTransaction`. This allows a significant delay between the two steps, during which the proof could expire. If the user regains access through another method (e.g., guardians), the pending recovery could still be completed later, leading to unauthorized account takeover. The root cause is the lack of time validation during the second step. This creates a dangerous time window where recovery can be finalized long after it should be valid.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#202",
                "OidcRecoveryValidator.sol::validateTransaction"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Old digestIndex Not Released on OIDC Account Update",
            "description": "When a user updates their OIDC account via `addOidcAccount`, the old `digestIndex` mapping is not cleared. This permanently reserves the old digest, preventing the user from reusing it even for their own account. If the user wishes to revert to a previous OIDC identity, they are blocked by the uniqueness check. The root cause is the failure to delete the old digest from the mapping before assigning the new one. This leads to inefficient state usage and reduced user flexibility.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::digestIndex#108",
                "OidcRecoveryValidator.sol::addOidcAccount#163"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "The `addOidcAccount` Function Always returns `false`",
            "description": "The `addOidcAccount` function incorrectly determines whether a new account is being added or an existing one is being updated by checking the length of a `bytes32` field (`oidcDigest.length`). Since `bytes32` always has a length of 32 bytes regardless of content, the condition `accountData[msg.sender].oidcDigest.length == 0` will never be true, causing the function to always return `false`, indicating an update even for new accounts.\n\nThe root cause is a misunderstanding of how fixed-size byte arrays work in Solidity\u2014length checks are not meaningful for `bytes32`. This leads to incorrect state signaling via return value and event emission, potentially misleading off-chain systems that rely on this boolean to detect new account linkages.\n\nAn attacker or user cannot directly exploit this for financial gain, but the incorrect return value and event data could be leveraged in a social engineering context or to disrupt account monitoring systems that expect accurate new-account detection.\n\nThe impact is primarily on system correctness and observability, leading to potential misinterpretation of user onboarding events and incorrect analytics or alerting based on account creation.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::addOidcAccount#163",
                "OidcRecoveryValidator.sol::oidcDataForAddress#319"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Inconsistencies in Account Recovery Data During Recovery Process",
            "description": "The `addOidcAccount` function updates only a subset of the account's recovery-related fields (`oidcDigest`, `iss`, `sub`, and `digestIndex`), leaving critical state variables such as `readyToRecover`, `pendingPasskeyHash`, and `recoverNonce` unchanged. This can result in stale recovery state persisting after a new OIDC account is linked.\n\nThe cause is incomplete state management during account update\u2014fields related to ongoing recovery are not reset or synchronized, creating a risk that a previous recovery session remains active even after the user has re-linked their OIDC identity.\n\nAn attacker who knows a previously used `publicKey` could exploit this by initiating a recovery after the user has called `addOidcAccount`, potentially allowing restoration of access using outdated credentials, provided the user had previously started a recovery and then re-linked their account.\n\nThe impact is a potential compromise of the recovery mechanism's integrity, allowing unintended recovery paths and mixing of state from different recovery sessions, which undermines the security model of the account recovery system.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::addOidcAccount#163",
                "OidcRecoveryValidator.sol::validateTransaction#201"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Insufficient Validation in Recovery Process May Lead to Wasted Recovery Attempts",
            "description": "The recovery process in `OidcRecoveryValidator` allows a recovery attempt to be consumed even if the `WebAuthValidator` fails to add the new `publicKey` due to invalid `credentialId` or `originDomain`. This occurs because the call to `WebAuthValidator` returns `false` instead of reverting, but the recovery nonce is still incremented.\n\nThe root cause is the lack of validation that the `publicKey` was actually added before consuming a recovery attempt. The system assumes success based on transaction completion rather than the actual outcome of the key registration.\n\nAn attacker who knows a user's `publicKey` can deliberately submit recovery transactions with invalid parameters, causing the `WebAuthValidator` to reject the key while still consuming the user's recovery attempt, effectively performing a denial-of-service on the recovery mechanism.\n\nThe impact is the depletion of a user's recovery attempts without actual progress, potentially locking them out of recovery if all attempts are exhausted through malicious or accidental misuse.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::validateTransaction#201",
                "WebAuthValidator.sol::addPubkey#94"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Insufficient Validation of `iss` Argument Length in `addOidcAccount`",
            "description": "The `addOidcAccount` function validates that the `iss` (issuer) string is non-empty but does not enforce an upper length limit. However, the associated zero-knowledge circuit expects `iss` to be less than 32 characters, as defined in the circuit template.\n\nThe cause is a missing on-chain validation that mirrors off-chain constraints. While the circuit enforces the length during proof generation, the contract allows longer values to be stored, creating a mismatch between on-chain data and what can be proven.\n\nAn attacker or user could store an `iss` value longer than 31 characters, which would be accepted on-chain but unusable in recovery because it cannot generate a valid ZK proof. This breaks the recovery flow for that account.\n\nThe impact is a denial-of-service condition for account recovery, where a user may be unable to recover their account if they have stored an `iss` value that exceeds the circuit's expected length, even if it was accepted by the contract.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::addOidcAccount#165",
                "jwt-tx-validation.circom#L43",
                "jwt-tx-validation.circom#L138"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "`OidcRecoveryValidator` Does Not Follow the ERC-1271 Flow",
            "description": "The `validateSignature` function in `OidcRecoveryValidator` reverts when called, instead of returning `false` as specified by ERC-1271. This deviation prevents the `ERC1271Handler` from properly handling signature validation and returning the required magic value.\n\nThe cause is incorrect implementation of the ERC-1271 standard, which mandates that invalid signatures should be indicated by returning `0x00000000` (via `false`) rather than reverting, to allow the handler contract to respond appropriately.\n\nAn attacker cannot directly exploit this, but any external system or wallet that relies on ERC-1271 signature validation will fail to interact correctly with accounts using this validator, leading to rejected transactions or failed authentication.\n\nThe impact is reduced interoperability and potential failure of signature verification in compliant systems, undermining the contract's integration with standard wallet infrastructure.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::validateSignature#289",
                "ERC1271Handler.sol::isValidSignature#37"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ],
                "3": [
                    "CWE-198"
                ]
            },
            "title": "Endianness Mismatch in senderHash Representation Between Contract and Circuit",
            "description": "The `startRecovery` function in the `OidcRecoveryValidator` contract splits the 32-byte `senderHash` into two parts for circuit input, but uses inconsistent endianness: the first part is processed in little-endian format after a right shift, while the second part (the least significant byte) is used without reversal. This results in a mixed byte order representation of the same logical value. The root cause is the inconsistent handling of byte order during serialization, particularly the use of `_reverse` on part of the hash but not the whole. An attacker could potentially exploit this by crafting inputs that cause the circuit to reconstruct an incorrect `senderHash`, leading to failed proof verification or unexpected behavior in the recovery process. The impact includes potential denial of service for legitimate recovery attempts or, in worst-case scenarios, successful recovery by an unauthorized party if the mismatch leads to an exploitable logic flaw in the circuit validation.\n",
            "severity": "Medium",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#231-233",
                "OidcRecoveryValidator.sol::_reverse"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Unnecessary override Keyword in onInstall and onUninstall",
            "description": "The `onInstall` and `onUninstall` functions in the `OidcRecoveryValidator` contract are marked with the `override` keyword, implying they override a function from a base contract. However, they are actually implementing abstract functions from an interface, not overriding a concrete implementation. The root cause is a misuse of Solidity inheritance syntax, which can mislead developers about the contract's inheritance hierarchy. While this does not lead to direct exploitation, it can cause confusion during code review or future development, potentially resulting in incorrect assumptions about function behavior or inheritance structure. The impact is primarily on code maintainability and auditability, increasing the risk of introducing bugs during future modifications due to misunderstanding the contract's design.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::onInstall",
                "OidcRecoveryValidator.sol::onUninstall"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant Inheritance from VerifierCaller in OidcRecoveryValidator",
            "description": "The `OidcRecoveryValidator` contract inherits from `VerifierCaller`, but does not use any of its functions or features. This unnecessary inheritance increases the contract's bytecode size and adds complexity without functional benefit. The root cause is leftover or premature inheritance that was not cleaned up during development. While this does not introduce a direct security exploit, it increases deployment and execution gas costs and complicates the codebase, making it harder to audit and maintain. The impact includes higher operational costs and an increased attack surface due to unnecessary code being present in the contract.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Inconsistent Handling of addOidcAccount Return Value in OidcRecoveryValidator",
            "description": "The `onInstall` function in `OidcRecoveryValidator` calls `addOidcAccount` but ignores its return value, which could indicate success or failure. This creates ambiguity about whether the operation succeeded, potentially hiding errors during installation. The root cause is a lack of proper error handling or documentation for the ignored return value. If the function reverts on failure, this may not be an issue, but without explicit handling or documentation, it's unclear whether this behavior is intentional. The impact is reduced code clarity and potential for silent failures, which could lead to inconsistent contract state if the operation fails but the installation proceeds anyway.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::onInstall#149"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1061"
                ]
            },
            "title": "Redundant External Call to hashIssuer in OidcRecoveryValidator",
            "description": "The `startRecovery` function makes an external call to `hashIssuer` in the `OidcKeyRegistry` contract, which performs a simple hashing operation without accessing any state. This external call introduces unnecessary gas overhead and complexity. The root cause is architectural over-engineering, where a stateless utility function is placed in another contract unnecessarily. While the team acknowledged this and chose not to fix it due to low gas costs, the vulnerability lies in the inefficiency and potential for increased attack surface through external calls. The impact is higher transaction costs and a slight increase in risk due to inter-contract dependencies, though the actual exploitability is low.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#210",
                "OidcKeyRegistry.sol::hashIssuer"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect Comment on Public Key in startRecovery Function",
            "description": "The comment in the `startRecovery` function states that the first `CIRCOM_BIGINT_CHUNKS` elements represent the \"OIDC provider public key\", but in reality, only the modulus is included, not the full public key (which would include the exponent). This misleading comment can cause confusion for developers and auditors, leading to incorrect assumptions about the data being passed to the circuit. The root cause is outdated or inaccurate documentation. The impact is primarily on code maintainability and auditability, increasing the risk of integration errors or misinterpretation of the protocol's security model, especially by external developers or auditors relying on comments.\n",
            "severity": "Low",
            "location": [
                "OidcRecoveryValidator.sol::startRecovery#219"
            ],
            "files": [
                "zksync-sso-clave-contracts/src/validators/OidcRecoveryValidator.sol"
            ]
        }
    ]
}