{
    "path": "dataset-curated/reports/Zellic/Pyth Lazer EVM - Zellic Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/pyth-network/pyth-crosschain"
        ],
        "commit_id": [
            "c6a2eb91c7ed50de8553f6a64c766ff1d2e58b5a"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-02-10",
        "project_path": {
            "pyth-crosschain": "dataset-curated/contracts/Pyth Lazer EVM - Zellic Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Signature malleability",
            "description": "1. **Description:** The contract uses the raw ecrecover function to recover the signer from a signature, which does not enforce strict signature standards. This allows for signature malleability, where multiple valid signatures can represent the same message and signer.\n2. **Cause:** The implementation does not use OpenZeppelin's ECDSA library, which includes protections against signature malleability by enforcing the s-value to be in the lower range and v to be either 27 or 28. The current code accepts both high and low s-values and both 27 and 28 for v, enabling malleable signatures.\n3. **Exploitation:** An attacker could generate multiple valid signatures for the same message and present them to a consumer contract. If the consumer contract tracks signatures (e.g., in a batch or uniqueness check), this could lead to replay-like behavior or unexpected state changes.\n4. **Impact:** While the core contract is not directly compromised, downstream consumer contracts may experience logic errors or inefficiencies due to accepting multiple valid signatures for the same data.\n",
            "severity": "Low",
            "location": [
                "PythLazer.sol::ecrecover"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Improper initialization within the UUPS pattern",
            "description": "1. **Description:** The implementation contract for the UUPS proxy pattern includes an initialize function that is callable on the implementation contract itself. Although self-destruct attacks are mitigated post-Shanghai, the initialize function could still be frontrun if not properly protected.\n2. **Cause:** The constructor of the implementation contract does not call _disableInitializers, leaving the initialization logic potentially callable by an attacker before the proxy delegates to it. This is a known design risk in upgradeable contracts.\n3. **Exploitation:** An attacker could frontrun the legitimate initialization of the proxy by calling initialize on the implementation contract directly, potentially taking ownership if the function assigns ownership and is not properly guarded.\n4. **Impact:** The impact is limited to the implementation contract and does not directly compromise the proxy, but it represents a critical design flaw that could allow an attacker to seize control of the implementation, affecting future upgrades.\n",
            "severity": "Low",
            "location": [
                "PythLazer.sol::initialize"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Performing duplicate checks within the same range of update length",
            "description": "1. **Description:** The verifyUpdate function performs redundant length checks on the input data, specifically checking if the update length is less than 71 twice in different parts of the function.\n2. **Cause:** The first check is at the beginning of the function, and a second, logically equivalent check is performed after extracting the payload length. This duplication is unnecessary as the second check already covers the first.\n3. **Exploitation:** There is no direct exploitation path as this is not a security vulnerability, but it results in higher gas consumption for every call to verifyUpdate.\n4. **Impact:** Users pay more in gas fees than necessary, reducing the efficiency of the contract. This is a code quality and optimization issue rather than a security risk.\n",
            "severity": "Informational",
            "location": [
                "PythLazer.sol::verifyUpdate#"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Inclusion of unnecessary migrate function",
            "description": "1. **Description:** The contract contains a migrate function that sets the verification_fee to 1 wei, a value that is already the default and never changes. This function serves no practical purpose.\n2. **Cause:** The function was likely included for initialization purposes but is redundant because the state variable is already initialized to the same value. It adds no upgrade or migration functionality.\n3. **Exploitation:** No exploitation is possible, but the function increases the attack surface slightly and consumes gas during deployment due to increased bytecode size.\n4. **Impact:** The main impact is on code clarity and gas efficiency. Unnecessary functions make the code harder to audit and slightly more expensive to deploy.\n",
            "severity": "Informational",
            "location": [
                "PythLazer.sol::migrate"
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazer.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Remove unused code",
            "description": "1. **Description:** The PythLazerLib.sol file imports the forge-std console library, which is not used anywhere in the codebase. This import is dead code.\n2. **Cause:** The import was likely added for debugging during development but was not removed before the audit.\n3. **Exploitation:** There is no security risk, but unused imports increase the compiled bytecode size and can mislead auditors into thinking the library is in use.\n4. **Impact:** Slight increase in deployment cost and reduced code readability. It violates best practices for clean, maintainable code.\n",
            "severity": "Informational",
            "location": [
                "PythLazerLib.sol::import {console} from \"forge-std/console.sol\""
            ],
            "files": [
                "pyth-crosschain/lazer/contracts/evm/src/PythLazerLib.sol"
            ]
        }
    ]
}