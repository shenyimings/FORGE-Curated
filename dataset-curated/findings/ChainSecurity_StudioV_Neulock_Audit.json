{
    "path": "dataset-curated/reports/ChainSecurity/ChainSecurity_StudioV_Neulock_Audit.pdf",
    "project_info": {
        "url": [
            "https://github.com/Studio-V-Tech/neulock-onchain"
        ],
        "commit_id": [
            "c386f625fc60667aa48dfe54aeba43f63c4ac5d5"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-06-20",
        "project_path": {
            "neulock-onchain": "dataset-curated/contracts/ChainSecurity_StudioV_Neulock_Audit.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "Royalty Payments With Native Tokens Break Marketplace Integrations",
            "description": "The NEU token implements EIP-2981 for royalty payments, which can be made in ETH or ERC20 tokens. However, the NeuV2 contract lacks a receive() function, causing any royalty payments in ETH to revert. This prevents the NEU token from being traded on marketplaces that enforce royalty payments in native tokens, limiting its marketability and usability.\n\nThe root cause is the absence of a receive() or fallback function in the NeuV2 contract to accept ETH payments. As a result, any marketplace attempting to send ETH royalties to the contract will have the transaction reverted.\n\nAn attacker is not directly exploiting this, but malicious actors or competitive projects could leverage this limitation to discourage trading on compliant marketplaces, pushing users toward non-compliant platforms where royalties are ignored.\n\nThe impact is a reduced trading capability of the NEU token on major marketplaces, leading to potential loss of revenue for the project and diminished user trust due to restricted functionality.\n",
            "severity": "High",
            "location": [
                "NeuV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Subscription Can Be Passed Around",
            "description": "The NEU NFT grants entitlement to use the Neulock service, but since the NFT is freely transferable, a single owner could lend or transfer it to multiple users, allowing them to access the service without purchasing their own NFT. This undermines the business model by enabling unauthorized sharing or flash-loaning of access rights.\n\nThe cause is the lack of a cooldown or lock mechanism on the NFT after minting, allowing immediate transfer and reuse of entitlement. This design flaw enables secondary markets or lending platforms to exploit the system.\n\nAn attacker could mint a NEU NFT, allow multiple users to access the service, and then transfer it back, effectively providing unlimited access without additional cost. Flash loan platforms could automate this process.\n\nThe impact includes loss of revenue due to bypassed purchases, dilution of NFT value, and potential abuse of system resources by unauthorized users.\n",
            "severity": "High",
            "location": [
                "NeuV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-913"
                ],
                "3": [
                    "CWE-915"
                ]
            },
            "title": "Metadata Contract Can Be Updated",
            "description": "The NeuV2 contract allows the OPERATOR_ROLE to update the metadata contract address via setMetadataContract() even after initialization. This introduces risk because the metadata contract manages critical data such as refund values and series information. A malicious or compromised operator could change the metadata contract to one that manipulates accounting or disables functionality.\n\nThe root cause is the lack of a mechanism to lock the metadata contract address after the initial setup, leaving it mutable indefinitely.\n\nA compromised OPERATOR_ROLE could deploy a malicious metadata contract that alters refund logic, inflates or erases sponsor points, or breaks compatibility with the NEU token.\n\nThe impact includes potential loss of funds, incorrect state tracking, and disruption of core functionality, especially around refunds and series management.\n",
            "severity": "Medium",
            "location": [
                "NeuV2.sol::setMetadataContract"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Refund Mechanism Can Be Abused to DOS a Series",
            "description": "The refund mechanism allows users to refund their NEU NFT within 7 days of minting. An attacker can exploit this by purchasing all available tokens in a series and immediately refunding them, effectively preventing others from minting and forcing the project to create a new series. This costs the attacker only gas, making it a low-cost denial-of-service attack.\n\nThe cause is the combination of a finite token supply per series and a refund feature that does not penalize or limit bulk refunds.\n\nAn attacker can automate the purchase and refund of all tokens in a high-demand series, blocking legitimate users and disrupting the release schedule.\n\nThe impact is a denial of service for specific token series, reputational damage, and operational overhead from having to deploy new series.\n",
            "severity": "Medium",
            "location": [
                "NeuMetadataV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Royalties in Non-Native Tokens Are Locked",
            "description": "The NEU token contract can receive royalties in non-native tokens (e.g., ERC20), but it lacks a mechanism to withdraw these tokens. Once received, they are permanently locked in the contract, making recovery impossible without an upgrade.\n\nThe cause is the absence of a withdrawal function for ERC20 tokens, which is a common oversight when handling multiple token types.\n\nWhile not directly exploitable by attackers, this represents a significant risk if marketplaces start paying royalties in non-native tokens, leading to irreversible loss of funds.\n\nThe impact is the permanent loss of royalty revenue paid in non-native tokens, reducing the project's income and financial flexibility.\n",
            "severity": "Medium",
            "location": [
                "NeuV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Burning Can Increase Withdraw Gas Cost",
            "description": "In NeuMetadataV2, the sumAllRefundableTokensValue() function loops backward through tokens to calculate refundable value. If tokens at the end of a series are burned, the loop continues until it finds an unburned token, increasing gas consumption. In extreme cases, this could exceed the block gas limit, preventing withdrawal.\n\nThe cause is inefficient loop logic that does not account for burned tokens when determining the end of the refundable window.\n\nAn attacker could burn tokens at the end of a series to increase the gas cost of withdrawals, effectively blocking the operator from withdrawing funds.\n\nThe impact is a potential denial of service on the withdraw function, preventing access to funds and disrupting operations.\n",
            "severity": "Low",
            "location": [
                "NeuMetadataV2.sol::sumAllRefundableTokensValue"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ]
            },
            "title": "Inconsistency in Initialization Steps",
            "description": "The initialization process is inconsistent across contracts. NeuStorageV2 allows full initialization via initialize() without requiring initializeV2(), while NeuV2 requires both initialize() and initializeV2() to be called. This inconsistency increases the risk of improper deployment.\n\nThe cause is a lack of standardized initialization patterns across the codebase.\n\nA developer might mistakenly assume that calling initialize() is sufficient for all contracts, leading to partially initialized contracts and potential security issues due to missing setup steps.\n\nThe impact is potential deployment errors, leading to malfunctioning contracts or security vulnerabilities due to missing setup steps.\n",
            "severity": "Low",
            "location": [
                "NeuStorageV2.sol::initialize",
                "NeuV2.sol::initialize"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol",
                "neulock-onchain/contracts/old/StorageV2.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Inconsistent Refund Period",
            "description": "There is a discrepancy between getRefundAmount() and sumAllRefundableTokensValue() regarding the refund window boundary. The former reverts when block.timestamp - mintedAt equals REFUND_WINDOW, while the latter includes the token if the condition is equal, leading to inconsistent behavior.\n\nThe cause is a mismatch in comparison operators: one uses < and the other uses >, creating a one-second ambiguity at the boundary.\n\nThis could lead to user confusion and disputes over whether a token is refundable at the exact cutoff time.\n\nThe impact is minor financial discrepancies and potential user dissatisfaction due to inconsistent refund eligibility.\n",
            "severity": "Low",
            "location": [
                "NeuMetadataV2.sol::getRefundAmount",
                "NeuMetadataV2.sol::sumAllRefundableTokensValue"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Events",
            "description": "The initialize() functions in NeuEntitlementV1 and NeuMetadataV2 do not emit events when critical state changes occur, such as adding the NEU contract as an entitlement or setting the logo contract address. This makes it difficult for off-chain systems to track contract state.\n\nThe cause is the omission of event emissions during initialization, which is a best practice for transparency and observability.\n\nWithout events, frontends and monitoring tools cannot reliably detect when key configurations are set, leading to potential synchronization issues.\n\nThe impact is reduced observability and increased complexity for external systems relying on event data.\n",
            "severity": "Low",
            "location": [
                "NeuEntitlementV1.sol::initialize",
                "NeuMetadataV2.sol::initialize"
            ],
            "files": [
                "neulock-onchain/contracts/old/EntitlementV1.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing Input Sanitization",
            "description": "The addSeries() and updatePrice() functions do not validate that the price is non-zero, and addSeries() does not enforce that maxTokens is at least 1. This allows the creation of series with zero price or zero length, which can break logic such as isUserMinted().\n\nThe cause is missing input validation checks for critical parameters.\n\nA malicious or mistaken operator could create invalid series, leading to unexpected behavior or denial of service.\n\nThe impact includes broken minting logic, unusable token IDs, and potential disruption of series management.\n",
            "severity": "Low",
            "location": [
                "NeuMetadataV2.sol::addSeries",
                "NeuMetadataV2.sol::updatePrice"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Getter for Number of Entitlement Contracts",
            "description": "The NeuEntitlementV2 contract provides entitlementContractsV2() to access contracts by index but lacks a function to query the total number of entitlement contracts. This forces callers to iterate until the function reverts, which is inefficient and error-prone.\n\nThe cause is the absence of a length getter, a common pattern in array-based data structures.\n\nOff-chain applications must use inefficient trial-and-error methods to determine the size of the list.\n\nThe impact is increased gas costs and complexity for external systems interacting with the contract.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV2.sol"
            ],
            "files": [
                "neulock-onchain/contracts/current/EntitlementV2.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "NEU Contract Is Not Necessarily the First Entitlement Contract",
            "description": "The initializeV2() function in NeuEntitlementV2 assumes the first entitlement contract is the NEU token, but this is not enforced. If the NEU contract was removed before initialization, a different contract could be assigned to _neuContract, leading to incorrect behavior.\n\nThe cause is a reliance on implicit ordering without validation.\n\nA compromised or mistaken operator could manipulate the order, causing the system to treat a non-NEU contract as the primary entitlement.\n\nThe impact is potential misconfiguration and incorrect access control decisions.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV2.sol::initializeV2"
            ],
            "files": [
                "neulock-onchain/contracts/current/EntitlementV2.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ]
            },
            "title": "EIP7496 Compliance",
            "description": "The EIP-7496 standard recommends using keccak256 hashes for trait keys, but NeuMetadataV2 uses the human-readable string \"points\" directly as the traitKey. This deviates from the standard and may cause interoperability issues with compliant systems.\n\nThe cause is non-compliance with the EIP-7496 specification regarding trait key formatting.\n\nSystems expecting hashed keys may fail to recognize the trait, leading to incorrect interpretation of NFT traits.\n\nThe impact is reduced interoperability with third-party platforms that strictly follow the EIP-7496 standard.\n",
            "severity": "Informational",
            "location": [
                "NeuMetadataV2.sol::_getTraitValue"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Gas Griefing by Adding Many Unlock Keys",
            "description": "The function `NeuDaoLockV1.setNeuDaoAddress()` deletes elements from the `keyTokenIds` array by iterating through the entire array, which becomes increasingly expensive as more token IDs are added. There is no upper bound on the array length aside from the total supply of NEU tokens.\nThe use of an unbounded array without efficient removal mechanisms leads to increasing gas costs for array cleanup during function execution.\nAn attacker could add a large number of key token IDs, causing future calls to `setNeuDaoAddress()` to consume excessive gas, potentially making the function unusable due to block gas limits.\nThis could result in the inability to update the Neu DAO address, leading to a denial of service for critical contract functionality.\n",
            "severity": "Informational",
            "location": [
                "NeuDaoLockV1.setNeuDaoAddress"
            ],
            "files": [
                "neulock-onchain/contracts/old/LockV1.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1176"
                ]
            },
            "title": "Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified across several functions in the contract suite, including unnecessary loops, redundant checks, inefficient memory usage, and suboptimal event emissions.\nInefficient coding patterns such as looping to truncate arrays, redundant address(0) checks, repeated SLOADs, redundant event emissions, and missing unchecked blocks contribute to higher gas consumption.\nWhile not directly exploitable for financial gain, these inefficiencies increase transaction costs for users and can be leveraged in gas griefing attacks if exploited at scale.\nIncreased operational costs for users and the system, reduced scalability, and potential for denial-of-service under extreme conditions due to high gas usage.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV1.userEntitlementContracts",
                "NeuDaoLockV1.withdraw",
                "NeuMetadataV2.setSeriesAvailability",
                "NeuMetadataV2.createTokenMetadata",
                "NeuMetadataV2._givesGovernanceAccess",
                "NeuV2._privateMint",
                "NeuV2._increaseSponsorPoints",
                "NeuMetadataV2.increaseSponsorPoints",
                "Bytes8Utils.toString",
                "NeuEntitlementV2.initializeV2"
            ],
            "files": [
                "neulock-onchain/contracts/old/EntitlementV1.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Loop Iterator Increment Optimization Is Unnecessary",
            "description": "In `NeuMetadataV2.getTraitValues()`, the loop iterator increment was placed inside an `unchecked` block, which is unnecessary because the Solidity compiler (since version 0.8.22) automatically optimizes `i++` in for-loops.\nDevelopers manually applied an optimization that is already handled by the compiler, adding redundant code.\nThis does not present a direct attack vector but reflects a misunderstanding of compiler behavior.\nMinimal impact; however, it adds unnecessary complexity and reduces code clarity.\n",
            "severity": "Informational",
            "location": [
                "NeuMetadataV2.getTraitValues"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing Natspec",
            "description": "The contracts lack NatSpec comments, which are used to document functions, parameters, return values, and events in Solidity.\nAbsence of documentation comments in the source code.\nNot exploitable, but hampers readability and integration efforts by external developers.\nReduced code maintainability and increased risk of misinterpretation during audits or upgrades.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol",
                "neulock-onchain/contracts/old/EntitlementV1.sol",
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "NEU Can Be Removed From the Entitlement Contracts List",
            "description": "The NEU contract could be removed from the entitlement contracts list via `NeuEntitlementV1.removeEntitlementContract()`, which poses a risk if the OPERATOR_ROLE is compromised.\nLack of a safeguard to prevent removal of a critical contract from the entitlement system.\nA malicious or compromised operator could remove the NEU contract, breaking expected functionality for users.\nUsers may lose access to expected features tied to holding NEU tokens, undermining trust in the system.\n",
            "severity": "Informational",
            "location": [
                "NeuEntitlementV1.removeEntitlementContract"
            ],
            "files": [
                "neulock-onchain/contracts/old/EntitlementV1.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1078"
                ]
            },
            "title": "Storage Variable Without Explicit Visibility",
            "description": "The storage variable `_traitMetadataURI` in `NeuMetadataV2` does not explicitly declare its visibility, relying on the default `internal`.\nOmission of explicit visibility specifier in variable declaration.\nWhile safe by default, this violates best practices and may lead to confusion or future errors if visibility assumptions change.\nReduced code clarity and maintainability; potential for accidental exposure if refactored without awareness.\n",
            "severity": "Informational",
            "location": [
                "_traitMetadataURI in NeuMetadataV2"
            ],
            "files": [
                "neulock-onchain/contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ]
            },
            "title": "Uninitialized Dependency",
            "description": "In `NeuV2`, the initializer function `__ERC721Royalty_init()` is not called during contract initialization, even though it is currently a no-op.\nFailure to follow proper inheritance initialization patterns in Solidity.\nIf the parent contract's initializer later becomes non-trivial, the uninitialized state could lead to incorrect behavior.\nRisk of future malfunction if dependencies evolve, leading to potential loss of functionality or incorrect royalty settings.\n",
            "severity": "Informational",
            "location": [
                "NeuV2 initializer functions"
            ],
            "files": [
                "neulock-onchain/contracts/old/NeuV2.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Role in NeuMetadataV2",
            "description": "The `STORAGE_ROLE` in `NeuMetadataV2` is declared but not used anywhere in the codebase.\nLeftover role from prior development stages that was not cleaned up.\nUnused roles increase code bloat and may confuse auditors or developers about access control design.\nReduced code clarity and potential confusion in security analysis.\n",
            "severity": "Informational",
            "location": [
                "NeuMetadataV2"
            ],
            "files": [
                "contracts/old/MetadataV2.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ]
            },
            "title": "setStorageContract Does Not Remove Previous Contract",
            "description": "The `setStorageContract` function in `NeuV2` adds a new contract to `POINTS_INCREASER_ROLE` but does not remove the previous one, leaving outdated permissions in place.\nIncomplete role management during contract updates.\nA previously authorized contract could retain permission to call `increaseSponsorPoints()`, potentially leading to unauthorized point increases if the old contract is compromised.\nLingering permissions could allow unintended behavior or exploitation by outdated components.\n",
            "severity": "Informational",
            "location": [
                "NeuV2.setStorageContract"
            ],
            "files": [
                "contracts/old/NeuV2.sol"
            ]
        }
    ]
}