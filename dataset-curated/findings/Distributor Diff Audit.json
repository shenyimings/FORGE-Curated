{
    "path": "dataset-curated/reports/OpenZeppelin/Distributor Diff Audit.md",
    "project_info": {
        "url": [
            "https://github.com/zksync-association/zk-governance"
        ],
        "commit_id": [
            "27763f16b7b8b4c98241c9c7ae73c045e3b52e23"
        ],
        "address": null,
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2024-05-23",
        "project_path": {
            "zk-governance": "dataset-curated/contracts/Distributor Diff Audit.md-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Inconsistency in Signature Verification",
            "description": "The vulnerability arises from inconsistent handling of signature expiration between claiming and delegation operations in the ZkMerkleDistributor and ZkTokenV1 contracts. Specifically, when claiming tokens on behalf of another user via `claimOnBehalf` or `claimAndDelegateOnBehalf`, the system checks if the current `block.timestamp` is equal to or greater than the `expiry` value, causing the transaction to revert. However, when delegating votes using `delegateBySig` or `claimAndDelegate`, the system only reverts if the `block.timestamp` is strictly greater than the `expiry`, allowing transactions to succeed if the timestamp is exactly equal to the expiry.\n\nThis inconsistency stems from differing comparison logic in the validation conditions\u2014one uses >= while the other uses >\u2014leading to a potential discrepancy in behavior under edge-case timing conditions. An attacker could potentially exploit this by crafting signatures that expire at a precise block timestamp and triggering delegation functions in a block where `block.timestamp` equals the expiry, which would be accepted, while the same signature would be rejected in a claiming context.\n\nThe impact of this issue is limited to a minor inconsistency in access control timing, potentially allowing unintended delegation actions at the exact moment of expiration. While not critical, it introduces ambiguity in expected behavior and weakens the reliability of signature expiration as a security mechanism. The issue was resolved in a later commit by standardizing the check to use strict inequality (>) for both paths.\n",
            "severity": "Low",
            "location": [
                "ZkMerkleDistributor.sol::claimOnBehalf#148",
                "ZkMerkleDistributor.sol::claimAndDelegateOnBehalf#209",
                "ZkTokenV1.sol::delegateBySig#112"
            ],
            "files": [
                "src/ZkMerkleDistributor.sol",
                "src/ZkTokenV1.sol"
            ]
        }
    ]
}