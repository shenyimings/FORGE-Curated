{
    "path": "dataset-curated/reports/Cantina/cantina_clearpool_aug2025.pdf",
    "project_info": {
        "url": [
            "https://github.com/clearpool-finance/clearpool-payfi-vaults",
            "https://github.com/Ozean-L2/nucleus-boring-vault"
        ],
        "commit_id": [
            "3f87019c",
            "cb325156"
        ],
        "address": null,
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": null,
        "project_path": {
            "cantina_clearpool_aug2025.pdf-source": "dataset-curated/contracts/cantina_clearpool_aug2025.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Decimal truncation on asset vaults different to 18 decimals loss precission",
            "description": "The calculation of asset amounts in vaults with non-18 decimal precision leads to loss of precision due to inconsistent decimal scaling across contracts such as TellerWithMultiAssetSupport.sol, AccountantWithRateProviders.sol, and AtomicQueue.sol. This occurs because the code does not properly normalize decimal representations when converting between assets and shares. An attacker could exploit this by depositing and withdrawing with low-decimal assets to induce rounding errors, potentially leading to unfair accrual of value or loss of user funds. The impact is significant for users interacting with vaults using assets that do not have 18 decimals, as they may receive fewer shares or assets than expected.\n",
            "severity": "High",
            "location": [
                "TellerWithMultiAssetSupport.sol",
                "AccountantWithRateProviders.sol",
                "AtomicQueue.sol"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/TellerWithMultiAssetSupport.sol",
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol",
                "3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Rate provider return amount inconsistency",
            "description": "The functions calculateSharesForAmount and calculateAmountForShares expect the rateProvider to return rates scaled to 18 decimals, while the claimFees function expects the rate in quote asset decimals. This inconsistency can lead to incorrect calculations when converting between shares and amounts. The root cause is the lack of a standardized scaling convention across the codebase for rateProvider outputs. An attacker could exploit this by manipulating fee claims on low-decimal assets, causing miscalculations that result in either zero-value transfers or inflated fee payouts. The impact includes potential loss of fees or incorrect distribution of assets.\n",
            "severity": "High",
            "location": [],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Incorrect scaling in _calculateWantAmount",
            "description": "The _calculateWantAmount function in AtomicQueue.sol uses inconsistent scaling logic across its three calculation paths. In some cases, it divides by 1e18 while using raw values not normalized to 18 decimals, leading to incorrect scaling of the resulting amount. The cause is the absence of consistent use of standardized constants like ONE_SHARE for scaling operations. An attacker could exploit this by triggering specific calculation paths with carefully chosen input values to manipulate the output amount, potentially leading to unfair allocation of assets or shares. The impact includes economic imbalance and loss of user funds due to incorrect conversions.\n",
            "severity": "High",
            "location": [
                "AtomicQueue.sol::_calculateWantAmount"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Inconsistent scaling in claimFees may zero out transfers",
            "description": "In the claimFees function, the non-pegged branch mixes units by using fees scaled to the fee asset's decimals while dividing by a rate expected in 18 decimals. For example, with base asset at 18 decimals and fee asset at 6 decimals, small accrued fees can round down to zero during conversion, even though _feesOwedInBase is still cleared. This is caused by improper unit alignment in arithmetic operations. An attacker could exploit this by accumulating small fees and claiming them, resulting in loss of those fees due to rounding down. The impact is loss of accrued fees for users or the protocol, especially affecting low-decimal fee assets.\n",
            "severity": "High",
            "location": [
                "claimFees"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Public checkpoint() mutates state while paused",
            "description": "The checkpoint() function in AccountantWithRateProviders.sol is public and can be called by any address even when the contract is paused. It mutates critical state variables such as _exchangeRate, _feesOwedInBase, and _lastAccrualTime through _checkpointInterestAndFees(), bypassing the intended pause protection. The root cause is the lack of a pause check within the checkpoint() function. An attacker could exploit this by calling checkpoint() after a pause is triggered (e.g., due to an invalid exchange rate), thereby updating the exchange rate and accrual data despite the paused state. The impact includes potential manipulation of state during emergency conditions, undermining the safety mechanism of the pause.\n",
            "severity": "Medium",
            "location": [
                "AccountantWithRateProviders.sol#L509-L511"
            ],
            "files": [
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Invalid Exchange Rate Causes Permanent State Corruption in Fee Calculations",
            "description": "The updateExchangeRate() function stores invalid exchange rates that are later used as the base for future interest and fee calculations. Even if the rate is out of bounds and causes a pause, the invalid rate is still stored and used in subsequent _checkpointInterestAndFees() calls. The cause is the lack of validation before storage and the absence of a mechanism to reject invalid rates during pauses. An attacker could exploit this by submitting an out-of-bounds rate, triggering a pause but still corrupting the stored _exchangeRate, which then skews all future interest accruals. The impact is long-term state corruption affecting fee calculations and potentially leading to incorrect distributions or insolvency.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Insufficient event coverage for state changes",
            "description": "Several state-changing functions do not emit events, reducing transparency and observability. Specifically, checkpoint() modifies _exchangeRate, _feesOwedInBase, and _lastAccrualTime without emitting events; setShareLockPeriod() changes a critical parameter without notification; and updateExchangeRate() sets state._isPaused without emitting Paused(), duplicating logic from the dedicated pause() function. The cause is missing event emissions and inconsistent use of pause logic. This can be exploited indirectly by attackers who rely on event-based monitoring to detect anomalies, as they may fail to detect critical state changes. The impact includes reduced auditability, delayed incident response, and potential for undetected malicious activity.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "Inconsistent enforcement when lowering maxLendingRate",
            "description": "The setMaxLendingRate function only updates the cap without adjusting the current lending rate if it exceeds the new maximum. This means the contract continues to accrue interest at a rate that is now above the governance-defined limit until a separate transaction is sent to correct it. The root cause is the lack of automatic clamping of the current rate to the new cap. An attacker (or malicious governor) could exploit this by temporarily setting a high lending rate and then lowering the cap without adjusting the active rate, allowing continued accrual at the higher rate. The impact is policy violation and potential overcharging of borrowers.\n",
            "severity": "Low",
            "location": [
                "AccountantWithRateProviders.sol#L320-L323"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Solve can be DoSed when a single request is invalid",
            "description": "In AtomicQueue.sol, the solve function reverts entirely if a single request is invalid, instead of skipping the invalid request and processing the rest. Additionally, transferFrom can fail, which also causes a full revert. The cause is the lack of error handling or try-catch logic for individual requests. An attacker could exploit this by submitting a batch with one invalid request, causing the entire solve operation to fail, effectively DoSing the system. The impact is denial of service for legitimate users trying to execute valid requests, especially in high-traffic scenarios.\n",
            "severity": "Low",
            "location": [
                "AtomicQueue.sol#L221-L232"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "Use of raw 1e4 instead of a named constant",
            "description": "The code uses the raw literal 1e4 as a denominator for basis point calculations in AccountantWithRateProviders.sol, instead of a named constant like BASIS_POINTS. While functionally correct, this reduces code clarity and maintainability. The cause is hardcoding of magic numbers. This is not directly exploitable but increases the risk of future bugs if the value is inconsistently used or mistyped elsewhere. The impact is reduced code readability and higher maintenance cost, potentially leading to errors in future modifications.\n",
            "severity": "Informational",
            "location": [
                "AccountantWithRateProviders.sol#L270-L272"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-563"
                ]
            },
            "title": "Unused return value and unnecessary computation in calculateExchangeRateWithInterest",
            "description": "The function calculateExchangeRateWithInterest() computes and returns both newRate and interestAccrued, but all call sites only use newRate. This results in unnecessary computation of interestAccrued, increasing gas costs. The cause is a design decision to return extra data for off-chain use, despite no on-chain benefit. While not exploitable, it represents inefficient code. The impact is higher gas consumption for no functional benefit, which could be optimized by splitting the function or making interestAccrued optional.\n",
            "severity": "Informational",
            "location": [
                "AccountantWithRateProviders.sol#L383"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol",
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Increasing Interest Rate creates price drift risk in AtomicQueue (mitigated by current withdraw-only usage)",
            "description": "AtomicQueue uses the current NAV at execution time to price requests, which introduces price drift risk if interest rates change between request submission and execution. For example, a user expecting 100 shares for 10 USDC might receive fewer if the rate increases. Currently, this is mitigated because the queue is used only for withdrawals and managed by Clearpool. The cause is the use of real-time pricing without slippage protection. If the queue were opened for deposits, this could be exploited by frontrunning or sandwich attacks. The impact includes unfair outcomes for users and potential loss of funds if usage expands without safeguards.\n",
            "severity": "Informational",
            "location": [
                "AtomicQueue.sol#L157-L164"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/atomic-queue/AtomicQueue.sol",
                "3f87019c/clearpool-payfi-vaults/src/atomic-queue/AtomicQueue.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Bound check incomplete",
            "description": "The bound check in AccountantWithRateProviders.sol only verifies that the exchange rate change is within upper and lower bounds but does not ensure that _allowedExchangeRateChangeUpper > _allowedExchangeRateChangeLower. This allows the bounds to be set in reverse order, effectively inverting the allowed range. The cause is missing validation of the relationship between the two parameters. An attacker (or misconfigured governor) could set the bounds in reverse, allowing out-of-bounds rates to pass validation. The impact is potential acceptance of invalid exchange rates, leading to incorrect accruals or pauses.\n",
            "severity": "Informational",
            "location": [
                "AccountantWithRateProviders.sol#L205"
            ],
            "files": [
                "cb325156/nucleus-boring-vault/src/base/Roles/AccountantWithRateProviders.sol",
                "3f87019c/clearpool-payfi-vaults/src/base/Roles/AccountantWithRateProviders.sol"
            ]
        }
    ]
}