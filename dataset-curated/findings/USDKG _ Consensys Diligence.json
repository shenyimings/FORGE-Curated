{
    "path": "dataset-curated/reports/Consensys_Diligence/USDKG _ Consensys Diligence.md",
    "project_info": {
        "url": [
            "https://github.com/USDkg/USDkg"
        ],
        "commit_id": [
            "5e2b92515976fa331291c35e78ab6cb13542b30d"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-01-20",
        "project_path": {
            "USDkg": "dataset-curated/contracts/USDKG _ Consensys Diligence.md-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-184"
                ]
            },
            "title": "transferFrom() Lacks notBlackListed Modifier on the Spender msg.sender",
            "description": "The USDKG token implements a blacklist mechanism to restrict certain users from interacting with the token, enforced via the `notBlackListed` modifier on functions like `transfer()` and `transferFrom()`. However, in the `transferFrom()` function, the modifier only checks the `_from` address (the token owner) but not the `msg.sender` (the spender). This omission allows a malicious or compromised contract, once approved by a user, to execute `transferFrom()` even if it has been blacklisted. For example, an exploited lending protocol with USDKG approval could be used to drain user funds. By not checking the spender, the system cannot proactively block such contracts from acting as intermediaries in token transfers. This reduces the effectiveness of the blacklist mechanism and allows attackers to bypass restrictions by using vulnerable or malicious smart contracts as conduits.\n",
            "severity": "Medium",
            "location": [
                "contracts/USDKG.sol::transferFrom#122",
                "contracts/USDKG.sol::notBlackListed#86-92"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation for Parameters in the Constructor",
            "description": "The constructor of the `USDKG` contract accepts `_owner` and `_compliance` address parameters but does not validate that these addresses are non-zero. If either parameter is set to the zero address during deployment, critical administrative functions tied to these roles (such as pausing, issuing, redeeming, or blacklisting) will become permanently inoperable, as no account can assume those roles. This creates a single point of failure during deployment. A mistaken or malicious deployment with zero addresses would render the contract partially or fully unusable, leading to a permanent loss of control and governance functionality. This issue stems from the lack of input validation, a common best practice in smart contract development.\n",
            "severity": "Medium",
            "location": [
                "contracts/USDKG.sol::constructor#45-52"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small Amount Can Ignore Fee on Transfer",
            "description": "The USDKG token implements a fee-on-transfer mechanism using a `basisPointsRate` divided by a `FEE_PRECISION` constant of 10,000. However, because the fee is calculated as `(_value * basisPointsRate) / FEE_PRECISION`, small transfer amounts can result in a fee that rounds down to zero due to integer division truncation. For instance, if the product `_value * basisPointsRate` is less than 10,000, the fee becomes zero. This allows users to bypass the fee mechanism entirely by splitting large transfers into multiple small ones. While the client has acknowledged and accepted this risk, it remains a design flaw that undermines the intended economic model if fees are ever enabled. The impact is limited to revenue loss from fee evasion rather than direct fund loss.\n",
            "severity": "Low",
            "location": [
                "contracts/USDKG.sol::transfer#103-104",
                "contracts/USDKG.sol::transferFrom#122-128",
                "contracts/USDKG.sol::FEE_PRECISION#22"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Fee Basis Points Can\u2019t Reach the Maximum Unlike What Is Described in the Documentation",
            "description": "The project documentation states that the transfer fee can reach a maximum of 0.2%, but the on-chain implementation prevents this. The `MAX_BASIS_POINTS` constant is set to 20, and the `setParams` function enforces `newBasisPoints < MAX_BASIS_POINTS`, meaning the maximum allowed fee is strictly less than 20 basis points (i.e., less than 0.2%). This discrepancy between documentation and code can mislead users and administrators into believing a higher fee cap is possible. The inconsistency may stem from a misunderstanding during implementation or a failure to update documentation. While not a direct security vulnerability, it affects transparency and trust in the system's specifications.\n",
            "severity": "Low",
            "location": [
                "contracts/USDKG.sol::MAX_BASIS_POINTS#21",
                "contracts/USDKG.sol::setParams#216-223",
                "docs/USDKG.md?plain=1#L11"
            ],
            "files": [
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Inaccurate Comments and Messages",
            "description": "The codebase contains several instances of incorrect or misleading comments and error messages. Examples include misspelling `keccak256` as `keccack`, using \"Now owner\" instead of \"Not owner\" in a require statement, and using a generic `onlyOwner` comment on a modifier named `onlyCompliance`. Additionally, references to \"Tether\" in comments are irrelevant since USDKG is not affiliated with Tether. These inaccuracies do not introduce direct security risks but reduce code readability, increase the risk of developer errors during maintenance, and may mislead auditors or contributors. They indicate a lack of code hygiene and attention to detail, which can indirectly affect long-term security and maintainability.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::transferToken#276-277",
                "contracts/Multisig.sol::owners#457",
                "contracts/USDKG.sol::onlyCompliance#62-65",
                "contracts/USDKG.sol::getBlackListStatus#248-249"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Use .call to Transfer Native Token Refund",
            "description": "The `handlePayment` function in the `Multisig.sol` contract uses `receiver.send(payment)` to refund ETH, which forwards only 2300 gas and may fail for contracts that require more gas to receive funds. The recommendation is to use `.call` instead, which forwards all available gas and is more compatible with modern smart contract wallets. This issue was previously addressed in the Gnosis Safe codebase (PRs 601 and 602), which this contract is based on. While `.send` is safe from reentrancy due to limited gas, it limits interoperability with contract receivers. Using `.call` improves compatibility without introducing reentrancy risks in this context, as the payment is made after the main logic and state changes.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::handlePayment#257-260"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-758"
                ]
            },
            "title": "Settle Solidity Version",
            "description": "The contracts `Multisig.sol` and `USDKG.sol` specify their Solidity version as `^0.8.0`, which allows compilation with any minor version in the 0.8.x series. This introduces unpredictability, as different compilers may produce different bytecode due to bug fixes or optimizations in newer versions. It also increases the risk of deploying with an untested compiler version. Best practice is to lock the version (e.g., `0.8.20`) to ensure deterministic builds and avoid potential issues from compiler regressions. This is especially important for audited contracts where the audit is based on a specific compilation output.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol#2",
                "contracts/USDKG.sol#2"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol",
                "USDkg/contracts/USDKG.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Inconsistent Transaction Execution Logic in Multisig Contract Deviates From Gnosis Safe and Documentation",
            "description": "The `execTransaction` function in `Multisig.sol` allows any external party to execute a transaction once it has sufficient approvals, unlike the original Gnosis Safe implementation, which restricts execution to the last approver. This deviation increases the attack surface by enabling front-running or censorship by third parties. It also contradicts the project's own documentation, which states \"The last signer initiates the transaction.\" This inconsistency could lead to unexpected behavior, reduced accountability, and potential denial-of-service if malicious actors block executions. The current design reduces trustworthiness and deviates from a well-audited standard, introducing unnecessary risk.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::execTransaction#382-437",
                "contracts/Multisig.sol::checkApprovals#146-171"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused Variable and Functions",
            "description": "The `Multisig` contract contains several unused elements: the `data` parameter in `checkApprovals` and `checkNApprovals`, the `signedMessages` mapping, and the `signatureSplit` function. These elements contribute to code bloat, increase deployment cost, and add unnecessary complexity, making audits and maintenance harder. While they do not pose direct security risks, they violate code hygiene principles and may confuse developers. Removing dead code reduces the attack surface and improves clarity. The `signatureSplit` function, for example, is defined but not used anywhere in the contract.\n",
            "severity": "Low",
            "location": [
                "contracts/Multisig.sol::checkApprovals#146-171",
                "contracts/Multisig.sol::signedMessages#47",
                "contracts/Multisig.sol::signatureSplit#309-323"
            ],
            "files": [
                "USDkg/contracts/Multisig.sol"
            ]
        }
    ]
}