{
    "path": "dataset-curated/reports/ChainSecurity/ChainSecurity_Gearbox_Permissionless_Audit.pdf",
    "project_info": {
        "url": [
            "https://github.com/Gearbox-protocol/permissionless"
        ],
        "commit_id": [
            "6c1b6ac842b751198e82db67ce5beb4a1c079d68"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-01-19",
        "project_path": {
            "permissionless": "dataset-curated/contracts/ChainSecurity_Gearbox_Permissionless_Audit.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Cannot Forbid an Adapter With Normal Configuration",
            "description": "This vulnerability arises from incorrect logic in the CreditFactory.configure() function when attempting to forbid an adapter. Instead of calling unauthorizeFactory(), the code re-authorizes the factory, which reverts because the adapter is already authorized. This prevents the intended configuration change from being applied. An attacker or misconfigured governance proposal could exploit this to maintain unauthorized adapter access. The impact includes loss of configurability and potential security risks from unwanted adapters remaining active.\n",
            "severity": "High",
            "location": [
                "CreditFactory.sol::configure"
            ],
            "files": [
                "permissionless/contracts/factories/CreditFactory.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Factory Migration Will Fail",
            "description": "In MarketConfigurator._migrateFactoryTargets(), the loop that processes target contracts incorrectly modifies the array during iteration, leading to an out-of-bounds access when more than one target exists. This causes the migration transaction to revert, preventing upgrades to new factory versions. Attackers could exploit this by forcing a migration attempt that fails, blocking system upgrades. The impact is a denial of service to the upgrade mechanism, reducing system liveness and maintainability.\n",
            "severity": "High",
            "location": [
                "MarketConfigurator.sol::_migrateFactoryTargets"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Legacy CreditManager Cannot Be Fully Configured",
            "description": "After migrating legacy credit suites to the new governance system via MarketConfiguratorLegacy, certain functions like setMaxEnabledTokens() and makeTokenQuoted() cannot be called because they are not supported by the CreditFactory's encoding logic. This limits post-migration configuration capabilities. An attacker could exploit this by forcing a migration before configurations are finalized, leading to permanently misconfigured markets. The impact is reduced flexibility and potential for increased risk in legacy markets.\n",
            "severity": "High",
            "location": [
                "MarketConfiguratorLegacy.sol",
                "CreditFactory.sol"
            ],
            "files": [
                "permissionless/contracts/market/legacy/MarketConfiguratorLegacy.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Overwritten Version in AddressProvider",
            "description": "The AddressProvider._setAddress() function incorrectly computes subversions using the wrong variable (version instead of _version), causing all versions to be recorded with the same subversion values (e.g., 300, 310), even when targeting newer versions like 320. This breaks the versioning system's integrity. Attackers could exploit this to overwrite critical addresses under false version assumptions. The impact is corruption of the versioning mechanism, leading to potential misrouting of system calls.\n",
            "severity": "High",
            "location": [
                "AddressProvider.sol::_setAddress"
            ],
            "files": [
                "permissionless/contracts/instance/AddressProvider.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Reverting Proposals Lock Cross-Chain Governance",
            "description": "The CrossChainMultisig uses Address.functionCall() to execute proposals, which bubbles up reverts. If a proposal succeeds on Ethereum Mainnet but reverts on another chain, that chain's governance becomes permanently stuck because it cannot skip the failed proposal. This allows a single failing call to lock cross-chain governance. The impact is a complete denial of service to governance on non-mainnet chains, preventing any future updates and endangering system liveness.\n",
            "severity": "High",
            "location": [
                "CrossChainMultisig.sol"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Timelock Transactions Can Be Executed Before the ETA",
            "description": "The Timelock.executeTransaction() function incorrectly checks that the current block timestamp is <= ETA, allowing execution only before the scheduled time. This is the opposite of intended behavior, where execution should only occur after ETA. An attacker with access to the timelock (e.g., via governance) could execute transactions prematurely. The impact includes bypassing the timelock delay, undermining governance security and enabling rushed malicious changes.\n",
            "severity": "High",
            "location": [
                "Timelock.sol::executeTransaction"
            ],
            "files": [
                "permissionless/contracts/market/TimeLock.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Updating a Rate Keeper Will Freeze the Epoch",
            "description": "In RateKeeperFactory.onUpdateRateKeeper(), when upgrading to a new GAUGE-type RateKeeper, the epoch is unfrozen on the old RateKeeper instead of the new one. This leaves the new RateKeeper's epoch frozen, preventing it from updating rates. Attackers could exploit this during an upgrade to freeze rate adjustments, disrupting incentive mechanisms. The impact is functional disruption of the ratekeeping system, affecting staking and reward distribution.\n",
            "severity": "High",
            "location": [
                "RateKeeperFactory.sol::onUpdateRateKeeper"
            ],
            "files": [
                "permissionless/contracts/factories/RateKeeperFactory.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Batching disableRecoveryMode Can Be Problematic",
            "description": "The disableRecoveryMode() function can be included in a batch with other transactions. If any transaction in the batch fails, the entire batch reverts, leaving the system in recovery mode indefinitely. This removes the ability to exit recovery safely. Attackers could craft a failing batch containing disableRecoveryMode to permanently trap the system in recovery. The impact is a denial of service to normal governance operations across chains.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig.sol::disableRecoveryMode"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Recovery Mode Message Replay",
            "description": "Recovery mode messages do not include the target chain ID in their signature scope, allowing a recovery message signed for one chain (e.g., Chain A) to be replayed on another chain (e.g., Chain B). This could force Chain B into recovery mode without authorization. Attackers could exploit this to block governance on newly deployed chains. The impact is cross-chain governance manipulation and potential freezing of operations on new deployments.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig.sol::enableRecoveryMode"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ],
                "3": [
                    "CWE-325"
                ]
            },
            "title": "Dynamic Types Must Be Hashed for EIP712",
            "description": "In CrossChainMultisig.hashProposal(), the call data (of type bytes) is not hashed before being included in the EIP-712 digest, violating the EIP-712 specification which requires dynamic types to be hashed. This could lead to signature malleability or incorrect hash computation. Attackers could exploit this to craft proposals with manipulated calldata hashes, potentially leading to unauthorized execution. The impact is compromised integrity of signed proposals.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig.sol::hashProposal"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ],
                "4": [
                    "CWE-606"
                ]
            },
            "title": "Free Choice of maxEnabledTokens Can Be Dangerous",
            "description": "The system allows risk curators to set maxEnabledTokens to arbitrarily high values. If too many tokens are enabled, the gas cost of liquidating a credit account could exceed the block gas limit, making liquidations impossible. This could lead to bad debt accumulation in the protocol. Attackers could exploit this by proposing or setting excessively high values. The impact is financial risk due to unprocessable liquidations and potential insolvency.\n",
            "severity": "Medium",
            "location": [
                "CreditFactory.sol",
                "CreditManagerV3.sol"
            ],
            "files": [
                "permissionless/contracts/factories/CreditFactory.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Legacy PriceOracle Cannot Be Updated",
            "description": "When updating the PriceOracle via PriceOracleFactory, the system attempts to call reservePriceFeeds() on the old oracle. However, legacy versions (pre-3.10) do not implement this function, causing the update to revert. This prevents oracle upgrades for legacy markets. Attackers could exploit this to block critical oracle updates, leaving outdated or insecure oracles in place. The impact is reduced upgradability and potential price manipulation in legacy markets.\n",
            "severity": "Medium",
            "location": [
                "PriceOracleFactory.sol::_getPriceFeed",
                "PriceOracleV3.sol"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing Sanity Checks on minorVersion",
            "description": "When creating a new market or credit suite, the admin can specify an arbitrary minor version for the factories, potentially leading to mismatched interfaces between components such as pools and credit managers.\nCause: The system lacks validation to ensure version compatibility across interdependent components during deployment.\nExploitation: An admin could intentionally or accidentally deploy components with incompatible versions, leading to unexpected behavior or failures in the system.\nImpact: The mismatch in component interfaces could result in operational failures, broken functionality, or incorrect state transitions within the protocol.\n",
            "severity": "Medium",
            "location": [
                "MarketConfigurator::enforces version to be 3_XY"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Rate Keeper Cannot Be Updated",
            "description": "Updating the rate keeper through the market configurator fails because the quota keeper checks for tokens to be added to the new rate keeper before they are actually added.\nCause: The order of operations is incorrect\u2014the tokens are added in a later hook after the check has already occurred.\nExploitation: Any attempt to update the rate keeper will revert due to the premature validation, preventing necessary upgrades.\nImpact: The inability to update the rate keeper blocks protocol upgrades and maintenance, potentially leading to outdated or insecure configurations persisting.\n",
            "severity": "Medium",
            "location": [
                "MarketConfigurator::onUpdateRateKeeper",
                "PoolFactory::setGauge",
                "QuotaKeeper",
                "RateKeeperFactory::install hook"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Shutting Down a Market Configurator",
            "description": "The shutdown function for a market configurator reverts when it should succeed, due to incorrect logic in the use of EnumerableSet.add.\nCause: The code reverts when the market configurator is successfully added to the shutdown set, but EnumerableSet.add returns true on successful addition, making the revert condition trigger incorrectly.\nExploitation: An admin attempting to shut down a market configurator will find the operation impossible due to the revert.\nImpact: Market shutdown functionality is broken, preventing proper deprecation or retirement of outdated or compromised markets.\n",
            "severity": "Medium",
            "location": [
                "_shutdownMarketConfiguratorsSet.add(marketConfigurator)"
            ],
            "files": [
                "permissionless/contracts/market/MarketConfigurator.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Threshold Not Enforced When Removing Signer",
            "description": "The CrossChainMultisig allows removal of a signer without ensuring that the remaining signers meet the threshold required to execute proposals.\nCause: No validation is performed during signer removal to confirm that the threshold can still be met.\nExploitation: A malicious or mistaken removal of a signer could drop the number of signers below the threshold.\nImpact: If the threshold cannot be met, governance proposals become unexecutable, effectively freezing the multisig and halting governance operations.\n",
            "severity": "Medium",
            "location": [
                "CrossChainMultisig::removeSigner"
            ],
            "files": [
                "permissionless/contracts/global/CrossChainMultisig.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "A Transaction Can Be Canceled After Execution",
            "description": "The Timelock contract allows calling cancelTransaction on an already executed transaction, which emits a misleading CancelTransaction event.\nCause: The function does not check the state of the transaction before allowing cancellation.\nExploitation: An attacker or user could cancel an already executed transaction, resulting in a confusing event log that suggests a transaction was canceled when it was already completed.\nImpact: While the underlying state is not altered, the emitted event can mislead off-chain monitoring tools and create confusion in governance tracking.\n",
            "severity": "Low",
            "location": [
                "Timelock::cancelTransaction"
            ],
            "files": [
                "permissionless/contracts/market/TimeLock.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Allowance Timestamp Can Be Reset",
            "description": "The PriceFeedStore.allowPriceFeed function does not revert if the price feed is already allowed, allowing repeated calls to reset the allowanceTimestamp.\nCause: Missing validation to prevent re-allowing an already allowed price feed.\nExploitation: An admin could repeatedly call the function to reset the timestamp, potentially extending the validity period of a price feed unintentionally.\nImpact: This could lead to prolonged use of a price feed beyond its intended validity window, increasing risk if the feed becomes unreliable or compromised.\n",
            "severity": "Low",
            "location": [
                "PriceFeedStore::allowPriceFeed"
            ],
            "files": [
                "permissionless/contracts/instance/PriceFeedStore.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-274"
                ]
            },
            "title": "Enough Admins Check",
            "description": "The Governor contract does not enforce that at least one admin remains when ownership is renounced or when permissionless execution is disabled.\nCause: Missing safeguards during admin removal or ownership renouncement.\nExploitation: All admins could be removed or ownership renounced without ensuring at least one execution admin remains.\nImpact: The governor could become permanently locked, rendering the protocol unupgradable and governance inoperable.\n",
            "severity": "Low",
            "location": [
                "Governor"
            ],
            "files": [
                "permissionless/contracts/market/Governor.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-179"
                ],
                "4": [
                    "CWE-181"
                ]
            },
            "title": "Forbidden initCode",
            "description": "The BytecodeRepository checks if initCode is forbidden both at submission and deployment, but the check at submission can be bypassed by adding garbage bytes.\nCause: Redundant and circumventable validation logic during submission.\nExploitation: An attacker could submit a forbidden initCode with added garbage bytes to bypass the initial check, then deploy the clean version later.\nImpact: Malicious bytecode could be registered and deployed, compromising the integrity of the deployed contracts.\n",
            "severity": "Low",
            "location": [
                "BytecodeRepository::_validateInitCode"
            ],
            "files": []
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Pending Owners",
            "description": "The PriceFeedStore._validatePriceFeedDeployment function requires accepting ownership from a pending owner, but the price feed cannot be validated unless it is already known, creating a circular dependency.\nCause: The validation and ownership acceptance processes are mutually dependent.\nExploitation: A legitimate price feed cannot be onboarded because it cannot pass validation until it is known, but it cannot be known until it passes validation.\nImpact: New price feeds cannot be added, blocking protocol expansion or updates to oracle systems.\n",
            "severity": "Low",
            "location": [
                "PriceFeedStore::_validatePriceFeedDeployment"
            ],
            "files": [
                "permissionless/contracts/instance/PriceFeedStore.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Wrong Specifications",
            "description": "Several code comments and specifications are incorrect or misleading, including domain separator recomputation logic, mapping semantics, and function behavior descriptions.\nCause: Outdated or inaccurate documentation within the codebase.\nExploitation: Developers or auditors relying on the specs may misunderstand the actual behavior, leading to incorrect assumptions or integration errors.\nImpact: Misleading documentation increases the risk of integration bugs, audit oversights, and long-term maintenance issues.\n",
            "severity": "Low",
            "location": [
                "EIP712Mainnet::_cachedDomainSeparator",
                "BytecodeRepository::contractTypeOwner",
                "CrossChainMultiSig::signProposal"
            ],
            "files": []
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Dead Code",
            "description": "Unused code, such as the ProxyCallExecuted event in ProxyCall, exists in the codebase.\nCause: Code that was once used but is no longer referenced remains in the repository.\nExploitation: No direct exploit, but increases code complexity and maintenance burden.\nImpact: Reduces code clarity, increases audit surface, and may confuse developers.\n",
            "severity": "Informational",
            "location": [
                "ProxyCall::ProxyCallExecuted event"
            ],
            "files": [
                "permissionless/contracts/helpers/ProxyCall.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ]
            },
            "title": "Inconsistent Sanity Check for Versioning",
            "description": "Different components perform inconsistent version validation\u2014BytecodeRepository checks versions between 100 and 999, while AddressProvider only checks if above 100.\nCause: Lack of standardized version validation logic across contracts.\nExploitation: Could allow deployment of contracts with unexpectedly high version numbers if only AddressProvider validation is used.\nImpact: Inconsistent behavior and potential for version confusion across the system.\n",
            "severity": "Informational",
            "location": [
                "BytecodeRepository::_validateVersion",
                "AddressProvider::_validateVersion"
            ],
            "files": [
                "permissionless/contracts/global/BytecodeRepository.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-193"
                ]
            },
            "title": "Redundant Chunk",
            "description": "The _writeInitCode function in BytecodeRepository may create an empty final chunk when the initCode length is a multiple of chunkSize.\nCause: The chunk count is calculated using division with ceiling, which can result in one extra empty chunk.\nExploitation: No direct security impact, but wastes storage and gas.\nImpact: Inefficient use of storage and increased deployment cost.\n",
            "severity": "Informational",
            "location": [
                "BytecodeRepository::_writeInitCode"
            ],
            "files": [
                "permissionless/contracts/global/BytecodeRepository.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary Imports",
            "description": "Several imported interfaces and constants are not used in the respective files.\nCause: Imports were left behind after refactoring or were added prematurely.\nExploitation: No security risk, but increases compilation time and code bloat.\nImpact: Reduces code clarity and maintainability.\n",
            "severity": "Informational",
            "location": [
                "Domain.sol",
                "InstanceManager.sol",
                "CreditFactory.sol"
            ],
            "files": [
                "permissionless/contracts/libraries/Domain.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1078"
                ]
            },
            "title": "Wrong Variable Name",
            "description": "In AddressProvider._setAddress, the variable minorVersion actually represents the major version, and patchVersion represents the minor version.\nCause: Incorrect naming during development or refactoring.\nExploitation: Developers may misinterpret the versioning logic, leading to bugs in version handling.\nImpact: Increases risk of logic errors due to confusion over version fields.\n",
            "severity": "Informational",
            "location": [
                "AddressProvider::_setAddress"
            ],
            "files": [
                "permissionless/contracts/instance/AddressProvider.sol"
            ]
        }
    ]
}