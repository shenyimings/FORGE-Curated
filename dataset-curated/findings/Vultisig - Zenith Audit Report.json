{
    "path": "dataset-curated/reports/Zenith/Vultisig - Zenith Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/vultisig/vultisig-contract"
        ],
        "commit_id": [
            "6c299dd44235505c4081fa6780271cf55f873108"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-03-21",
        "project_path": {
            "vultisig-contract": "dataset-curated/contracts/Vultisig - Zenith Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Users lose pending rewards when depositing additional tokens",
            "description": "The Stake.sol contract uses a reward debt accounting system to track user rewards based on their staked amount and a global accRewardPerShare variable. When a user makes an additional deposit, the _deposit() function recalculates the user's rewardDebt using the updated staking amount without first accounting for already accumulated pending rewards. This causes the previous rewardDebt to be overwritten with a value that includes the new deposit, effectively zeroing out any pending rewards the user had earned before the deposit. The root cause is the incorrect recalculation of rewardDebt instead of incrementing it based on the new deposit. An attacker could exploit this by repeatedly depositing and withdrawing to reset their reward debt and forfeit rewards, though the primary impact is on honest users who lose accrued rewards. The impact is loss of user rewards, undermining trust and fairness in the staking mechanism.\n",
            "severity": "High",
            "location": [
                "Stake.sol::189"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Sweep and reinvest functions are vulnerable to sandwich attacks",
            "description": "The _swapTokens() function in StakeSweeper.sol calculates the expected output of a token swap using Uniswap's getAmountsOut() function, which reads from current pool reserves that can be manipulated by frontrunning. The calculated amountOutMin applies slippage protection but is derived from a potentially manipulated state, rendering the protection ineffective. This allows an attacker to sandwich sweep() or reinvest() transactions by manipulating the price before the swap and profiting afterward. The root cause is the reliance on on-chain price data at execution time rather than off-chain, user-provided minimums. The lack of access control on sweep() exacerbates the issue by allowing anyone to trigger these vulnerable swaps. Exploitation would involve monitoring the mempool, frontrunning with a large trade, allowing the victim's swap to execute at a worse rate, and back-running to capture profit. The impact is financial loss for users due to unfavorable swap rates, especially during large sweeps or reinvestments.\n",
            "severity": "High",
            "location": [
                "Stake.sol",
                "StakeSweeper.sol::104-111"
            ],
            "files": [
                "vultisig-contract/contracts/StakeSweeper.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "Absence of minimum staking duration enables risk-free reward theft",
            "description": "The Stake.sol contract allows users to deposit and withdraw tokens without any minimum staking duration, enabling flash loan attacks to extract rewards. When minRewardUpdateDelay is 0 or can be triggered, an attacker can flash loan a large amount of VULT tokens, deposit them to become the dominant staker, trigger a reward update (e.g., via sweep() or by front-running a reward transfer), and immediately withdraw, capturing a disproportionate share of the rewards. The root cause is the lack of a time-based lock on staked funds, combined with the reward distribution logic that updates based on current stake without considering deposit timing. This allows for risk-free exploitation using flash loans, with the cost limited to gas and flash loan fees. The impact is theft of rewards from legitimate long-term stakers, undermining the fairness and economic model of the staking system.\n",
            "severity": "Medium",
            "location": [
                "Stake.sol"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Ineffective deadline protection in _swapTokens()",
            "description": "The _swapTokens() function in StakeSweeper.sol sets the deadline for Uniswap swaps using block.timestamp + 1 hours, which is calculated at execution time. Since the Uniswap router compares this deadline against the same block.timestamp, the check is always satisfied, making the deadline protection meaningless. The root cause is the dynamic calculation of the deadline instead of using a fixed timestamp provided by the caller. As a result, transactions can remain valid in the mempool indefinitely, exposing users to execution under unfavorable market conditions long after submission. This undermines the purpose of the deadline parameter, which is to limit the time window for execution. The impact is increased exposure to price volatility and potential loss due to stale transactions being mined at inopportune times.\n",
            "severity": "Medium",
            "location": [
                "StakeSweeper.sol::115"
            ],
            "files": [
                "vultisig-contract/contracts/StakeSweeper.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Unnecessary reward balance check in _claimRewards() can silently reduce user rewards",
            "description": "The _claimRewards() function in Stake.sol includes a check that caps the reward amount to the contract's current reward token balance if pending rewards exceed it. This check is unnecessary because the contract's reward accounting should ensure that total pending rewards never exceed available balance. If this condition is triggered, it silently reduces the user's reward without reverting, leading to unexpected loss of entitled rewards. The root cause is defensive programming that fails silently instead of failing loudly when an invariant is violated. This could mask deeper accounting issues in the contract. The impact is user funds being silently withheld, reducing transparency and potentially hiding critical bugs in reward distribution logic.\n",
            "severity": "Low",
            "location": [
                "Stake.sol::533"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Reward is not distributed before updating distribution parameters",
            "description": "The contract allows the owner to update rewardDecayFactor and minRewardUpdateDelay without first distributing accrued rewards via updateRewards(). This means that changing these parameters can retroactively affect the amount of rewards distributed in the current period. For example, increasing the decay factor after rewards have accrued but before distribution reduces the amount released. The root cause is the lack of a pre-update reward distribution step. An attacker (or privileged user) could exploit this by timing parameter changes to minimize payouts. The impact is reduced rewards for stakers due to parameter manipulation, undermining predictability and fairness in the reward system.\n",
            "severity": "Low",
            "location": [
                "Stake.sol::405-419"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Lack of reentrancy protection in onApprovalReceived() function",
            "description": "The onApprovalReceived() function in Stake.sol, which handles token approvals and deposits in a single transaction via IERC1363Spender, lacks the nonReentrant modifier used by other state-changing functions like deposit(). Although the current implementation may not be directly exploitable due to internal logic, the absence of reentrancy protection creates a security inconsistency. The root cause is a missing safeguard on a function that modifies state in response to external calls. If future changes alter the control flow or introduce new state updates, this could open a reentrancy vulnerability. The impact is potential loss of funds in the event of a future modification that makes the function susceptible to reentrant calls.\n",
            "severity": "Low",
            "location": [
                "Stake.sol::309-321"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Redundant variable assignment in catch block",
            "description": "In the migrate() function of Stake.sol, the catch block contains an assignment migrationSuccess = false, which is redundant because the variable is already initialized to false before the try-catch block and only set to true if the try block succeeds. The root cause is unnecessary code that does not alter program behavior. While this has no security impact, it wastes gas and reduces code clarity. The impact is minimal gas inefficiency and reduced maintainability due to superfluous logic.\n",
            "severity": "Informational",
            "location": [
                "Stake.sol::371"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Unnecessary conditional checks in reward calculation logic",
            "description": "The reward calculation logic contains redundant conditions, such as checking minRewardUpdateDelay != 0 when timeDelayMet already accounts for it, and using a ternary operator that can be simplified (e.g., rewardDecayFactor != 1 ? totalNewRewards : totalNewRewards / rewardDecayFactor). The root cause is inefficient and overly complex code. These redundancies do not introduce security risks but reduce code readability and increase maintenance burden. The impact is higher cognitive load for auditors and developers, increasing the risk of future bugs due to misunderstanding the logic.\n",
            "severity": "Informational",
            "location": [
                "Stake.sol"
            ],
            "files": [
                "vultisig-contract/contracts/Stake.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Sweeper allowance is not reset after the swap",
            "description": "After a swap in StakeSweeper.sol, the contract attempts to reset the token allowance using safeIncreaseAllowance(tokenIn, defaultRouter, 0), which does not reliably reset allowances, especially if the current allowance is non-zero. The root cause is incorrect use of the safeIncreaseAllowance function, which only increases allowances and has no effect when setting to zero. This could leave residual allowances, posing a potential risk if the router address is compromised or upgraded. The impact is a minor security hygiene issue where leftover approvals could be exploited in combination with other vulnerabilities or contract upgrades.\n",
            "severity": "Informational",
            "location": [
                "StakeSweeper.sol::118"
            ],
            "files": [
                "vultisig-contract/contracts/StakeSweeper.sol"
            ]
        }
    ]
}