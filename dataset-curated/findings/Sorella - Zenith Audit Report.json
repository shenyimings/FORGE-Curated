{
    "path": "dataset-curated/reports/Zenith/Sorella - Zenith Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/SorellaLabs/l2-angstrom"
        ],
        "commit_id": [
            "e880ec452106629ca48f9330a7add34bcd9c38b1"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-09-12",
        "project_path": {
            "l2-angstrom": "dataset-curated/contracts/Sorella - Zenith Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "zeroForOne current tick transition is incorrect",
            "description": "The vulnerability occurs in the TickIteratorDown initialization during a swap where the current tick matches the upper tick of a liquidity position. Because the upper tick is exclusive, the liquidity should be added when the price moves down, but the reset() function in TickIteratorDown calls _advanceToNextDown(), which skips the current tick, failing to account for the pending liquidity. This causes an incorrect liquidity subtraction during a zeroForOne swap, potentially leading to an overflow when subtracting liquidity that was never added. An attacker could exploit this by creating a position at the current tick and triggering a downward swap, resulting in an invalid state and potential DoS or incorrect fee distribution. The impact includes miscalculated liquidity and potential reverts during swaps, disrupting pool operations.\n",
            "severity": "High",
            "location": [
                "CompensationPriceFinder.sol#L67"
            ],
            "files": [
                "l2-angstrom/src/libraries/CompensationPriceFinder.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "AFTER_SWAP_RETURNS_DELTA_FLAG isn't turned on",
            "description": "The afterSwap() function is designed to return the protocol swap fee, but the afterSwapReturnDelta flag is not enabled in the hook configuration. As a result, the PoolManager does not parse the return value from afterSwap, treating it as zero and failing to apply the intended fee. This misconfiguration stems from the permissions structure in the hook setup, where the flag is omitted despite the function's return value being critical for fee enforcement. An attacker could exploit this by performing swaps that should incur protocol fees, but due to the unprocessed return value, no fee is charged. The impact is a loss of expected protocol revenue and potential economic imbalance in fee distribution.\n",
            "severity": "High",
            "location": [
                "hook-config.sol#L17-L19",
                "AngstromL2.sol#L284"
            ],
            "files": [
                "l2-angstrom/src/hook-config.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "beforeInitialization() checks are bypassed due to noSelfCall modifier",
            "description": "The beforeInitialize() hook is intended to enforce pool configuration constraints, such as requiring native currency and dynamic fees. However, the noSelfCall modifier prevents the hook from being executed when the contract itself initiates the call, which occurs during pool initialization. As a result, the validation checks in beforeInitialize() are bypassed, allowing incompatible pool configurations to be created. This is caused by the modifier's logic that only allows external callers, excluding self-calls. An attacker could exploit this by creating a pool with invalid parameters, such as non-native currency or static fees, undermining the protocol's security assumptions. The impact includes potential misconfiguration of pools and violation of intended constraints.\n",
            "severity": "Medium",
            "location": [
                "AngstromL2.sol#L179",
                "AngstromL2.sol#L186-L196"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Liquidity ranges deltas are not rounded in the right direction",
            "description": "The liquidity delta calculations in _zeroForOneCreditRewards(), _oneForZeroCreditRewards(), getZeroForOne(), and getOneForZero() always round down, which deviates from the intended economic model. The protocol expects delta1 to be rounded up in zero-for-one swaps and delta0 in one-for-zero swaps to fairly reward liquidity providers near the price. Due to incorrect rounding, LPs may receive less reward than expected, and in edge cases, it can lead to underflow when lpCompensationAmount is reduced. This can be exploited by crafting swaps across many small liquidity ranges, causing miscalculations in reward distribution. The impact includes unfair reward allocation and potential arithmetic underflows, leading to transaction failures.\n",
            "severity": "Medium",
            "location": [
                "AngstromL2",
                "CompensationPriceFinder"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol",
                "l2-angstrom/src/libraries/CompensationPriceFinder.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Fee mutators may cause total swap / tax fees to exceed 100%",
            "description": "While initialization enforces that total swap and tax fees do not exceed 100%, the fee mutator functions lack these checks. Although MAX_PROTOCOL_SWAP_FEE_E6 exists, it is only applied during initialization, and MAX_PROTOCOL_TAX_FEE_E6 is unused. This allows governance or privileged roles to set fees that sum to over 100%, particularly dangerous for tax fees, as a 100% or higher tax results in zero lpCompensationAmount. When lpCompensationAmount is zero, _blockOfLastTopOfBlock is not updated, causing JIT and swap taxes to be repeatedly charged within the same block. This could be exploited to drain user funds through repeated taxation. The impact includes potential fund loss and broken incentive mechanisms.\n",
            "severity": "Low",
            "location": [
                "AngstromL2.sol#L125-L137"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Rewards are lost on single-tick swaps with no active liquidity",
            "description": "When a swap of zero ETH is executed on a tick with no active liquidity, the protocol fails to distribute rewards correctly. This occurs because the swap starts and ends in the same tick, and with no liquidity, the liquidityBeforeSwap state variable reads zero, leading to no reward accrual. Although the tax is still collected, the associated rewards are effectively lost. This edge case can be triggered intentionally by users who perform zero-amount swaps on empty ticks. The impact is a loss of reward distribution efficiency and potential economic leakage, though it does not lead to fund loss or critical failure.\n",
            "severity": "Low",
            "location": [
                "AngstromL2"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-369"
                ]
            },
            "title": "pstarX96 rounds down to zero on low ticks ranges leading to reverts for division by zero",
            "description": "The pstarX96 value, derived from pstarSqrtX96 squared, can round down to zero on very low ticks (below -665455), causing division by zero in _zeroForOneCreditRewards() and _oneForZeroCreditRewards(). This happens because the precision of the fixed-point arithmetic is insufficient at extreme values. When pstarX96 is zero, any division by it will revert, halting reward calculations. This can be triggered by swaps in pools with extremely low tick prices. The impact is a denial of service for reward distribution in edge-case scenarios, though it is unlikely under normal market conditions.\n",
            "severity": "Low",
            "location": [
                "AngstromL2.sol"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "JIT tax can be avoided by first doing a small swap",
            "description": "The JIT tax and swap tax are only charged on the first action in a block. By performing a negligible swap first, a user can pay only the swap tax and avoid the JIT tax on subsequent liquidity additions or swaps. Since the JIT tax is 4x the swap tax, this creates an economic incentive to game the system. The vulnerability arises from the _blockOfLastTopOfBlock update logic, which suppresses further taxes once set. An attacker can exploit this by structuring transactions to front-run their own actions, minimizing tax costs. The impact includes reduced protocol revenue and unfair advantage for sophisticated users.\n",
            "severity": "Low",
            "location": [
                "AngstromL2.sol#L198-L242"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Native ID conversion to currency can be replaced with NATIVE_CURRENCY constant",
            "description": "The code uses CurrencyLibrary.fromId(NATIVE_CURRENCY_ID) to obtain the native currency object, but this is redundant because the NATIVE_CURRENCY constant is already available. This is a code quality issue that increases gas usage slightly due to an unnecessary function call. While it does not pose a security risk, it reduces code clarity and efficiency. Replacing the call with the constant improves readability and reduces gas costs. The impact is purely optimization-related with no security consequences.\n",
            "severity": "Informational",
            "location": [
                "AngstromL2.sol#L213",
                "AngstromL2.sol#L233"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant checks on params.liquidityDelta",
            "description": "The checks on params.liquidityDelta in PoolRewards.sol are redundant because the PoolManager already determines whether to call afterAddLiquidity or afterRemoveLiquidity based on the sign of liquidityDelta. These checks do not add security value and are duplicated logic. While they serve as a sanity check, they are not necessary for correctness. The impact is minimal, limited to slight gas inefficiency and code bloat.\n",
            "severity": "Informational",
            "location": [
                "PoolRewards.sol#L81",
                "PoolRewards.sol#L117"
            ],
            "files": [
                "l2-angstrom/src/types/PoolRewards.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-405"
                ],
                "4": [
                    "CWE-1176"
                ]
            },
            "title": "_oneForZeroCreditRewards() calculates rewards of ranges with 0 liquidity",
            "description": "The _oneForZeroCreditRewards() function calculates rewards even for liquidity ranges with zero liquidity, which is inefficient and unnecessary. This occurs because the condition checks tickNext <= lastTick but does not verify that liquidity is non-zero. Although it does not lead to incorrect state, it wastes gas by performing calculations that have no effect. The fix involves adding a liquidity != 0 check. The impact is gas inefficiency during reward distribution.\n",
            "severity": "Informational",
            "location": [
                "AngstromL2.sol"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The updateAfterLiquidityAdd() function doesn't initialize the reward accumulator of uninitialized ticks",
            "description": "The updateAfterLiquidityAdd() function attempts to initialize rewardGrowthOutsideX128 for uninitialized ticks, but the condition !pm.isInitialized is never true because ticks are already initialized during the afterAddLiquidity hook flow. This results in dead code that has no effect. The initialization is redundant because the values are not meaningful until used. The impact is negligible, limited to code clarity and minor gas savings if simplified.\n",
            "severity": "Informational",
            "location": [
                "PoolRewards.sol"
            ],
            "files": [
                "l2-angstrom/src/types/PoolRewards.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-655"
                ]
            },
            "title": "Indirectly claiming rewards is subject to MEV tax",
            "description": "Users can claim rewards indirectly by performing a zero-liquidity modification (poking a position), but this action is subject to the MEV tax if it is the first in a block. This creates a disincentive for users to claim rewards efficiently, as they may be taxed unnecessarily. The issue arises because the tax exemption does not apply to liquidity modifications, even when no actual liquidity change occurs. An attacker can front-run such claims to extract value. The impact includes user friction and potential loss of rewards due to tax overhead.\n",
            "severity": "Informational",
            "location": [
                "AngstromL2.sol#L229-L234"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Redundancies",
            "description": "Several constants and functions (NegationOverflow, AttemptingToWithdrawLPRewards, MAX_DEFAULT_PROTOCOL_FEE_MULTIPLE_E6, MAX_PROTOCOL_TAX_FEE_E6) are defined but never used in the codebase. This increases code complexity and maintenance burden without providing value. These definitions should be removed to improve code clarity and reduce audit surface. The impact is purely code quality and maintainability.\n",
            "severity": "Informational",
            "location": [
                "AngstromL2.sol#L57",
                "AngstromL2.sol#L59",
                "AngstromL2Factory.sol#L50",
                "AngstromL2Factory.sol#L52"
            ],
            "files": [
                "l2-angstrom/src/AngstromL2.sol"
            ]
        }
    ]
}