{
    "path": "dataset-curated/reports/Ackee-Blockchain/ackee-blockchain-lido-csm-v2-report.pdf",
    "project_info": {
        "url": [
            "https://github.com/lidofinance/community-staking-module/tree/59dc7845660bef7299bf8cc97f9c831f5588a8ba",
            "https://github.com/Ackee-Blockchain/tests-lido-csm-v2",
            "https://github.com/lidofinance/core"
        ],
        "commit_id": [
            "59dc7845660bef7299bf8cc97f9c831f5588a8ba",
            "n/a",
            "628c8736d12478fc9e9a7dcba7dc2e7e6ebb8715"
        ],
        "address": [
            "0x6eFF460627b6798C2907409EA2Fdfb287Eaa2e55",
            "0xE4d5a7be8d7c3db15755061053F5a49b6a67fFfc",
            "0x25fdc3be9977cd4da679df72a64c8b6bd5216a78",
            "0x9d28ad303c90df524ba960d7a2dac56dcc31e428",
            "0x6f09d2426c7405c5546413e6059f884d2d03f449",
            "0xcf33a38111d0b1246a3f38a838fb41d626b454f0",
            "0x65d4d92cd0eabaa05cd5a46269c24b71c21cfdc4",
            "0xb314d4a76c457c93150d308787939063f4cc67e0",
            "0xfdab48c4d627e500207e9af29c98579d90ea0ad4",
            "0x5dcf7cf7c6645e9e822a379df046a8b0390251a1",
            "0x1eb6d4da13ca9566c17f526ae0715325d7a07665",
            "0x3e5021424c9e13fc853e523cd68ebbec848956a0",
            "0xaa328816027f2d32b9f56d190bc9fa4a5c07637f",
            "0xe0b234f99e413e27d9bc31abba9a49a3e570da97",
            "0xda22fa1cea40d05fe4cd536967afdd839586d546",
            "0x06cd61045f958a209a0f8d746e103ecc625f4193",
            "0xc72b58aa02e0e98cf8a4a0e9dce75e763800802c",
            "0xdc5fe1782b6943f318e05230d688713a560063dc"
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-05-27",
        "project_path": {
            "ackee-blockchain-lido-csm-v2-report.pdf-source": "dataset-curated/contracts/ackee-blockchain-lido-csm-v2-report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "H1: Deposits denial of service",
            "description": "The migrateToPriorityQueue function in the CSModule contract allows permissionless migration of validator keys into a higher priority queue. The function increments the Community Staking Module (CSM) nonce even if the node operator has no keys to migrate or does not exist. This behavior is a vulnerability because the nonce is used by the Deposit Security Module (DSM) to validate deposit data signatures. An attacker can repeatedly call this function with invalid or non-existent node operator IDs, causing the nonce to increment and invalidate existing DSM signatures. This would prevent new validators from being deposited, resulting in a denial of service for the staking process. The root cause is the lack of validation on the existence and eligibility of the node operator before incrementing the nonce.\n",
            "severity": "High",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#589-614"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "H2: Incorrect enqueued keys accounting",
            "description": "The migrateToPriorityQueue function in CSModule.sol computes the number of keys to migrate and then subtracts that number from the enqueued count as a \"hack\" to ensure correct behavior in the subsequent _enqueueNodeOperatorKeys call. However, this subtraction is not reverted or compensated, and the legacy queue slots remain in place. As a result, the enqueued count becomes inconsistent with the actual number of queue slots, leading to a logic error. This discrepancy can cause an underflow in the QueueLib.clean function or prevent node operators from depositing new keys because the enqueued count appears higher than the depositable count. The root cause is the incorrect accounting due to an unbalanced decrement operation. An attacker can exploit this by calling the function for any node operator with queue slots, breaking the accounting system.\n",
            "severity": "High",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#603-609"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "M1: processExitDelayReport griefing",
            "description": "The processExitDelayReport function in CSExitPenalties.sol reverts when a validator has already been reported for exit delay, which prevents batch reporting transactions from succeeding if any single validator in the batch has already been reported. This behavior enables a griefing attack where an attacker can front-run a batch report transaction by submitting a report for one validator in the batch, causing the entire batch to revert and waste gas. The root cause is the use of a revert instead of a silent skip when a validator is already reported. This increases the cost and risk of reporting for honest actors and can be abused to disrupt the penalty enforcement mechanism.\n",
            "severity": "Medium",
            "location": [
                "CSExitPenalties.sol::processExitDelayReport",
                "ValidatorExitDelayVerifier.sol::verifyValidatorExitDelay#178-196"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSExitPenalties.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/core/contracts/0.8.25/ValidatorExitDelayVerifier.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "L1: Bond burning denial of service",
            "description": "The CSBondCore._burn function converts the amount of stETH to burn into shares, and if the resulting shares are zero, it returns early. However, after computing the stETH amount from the shares, it calls Burner.requestBurnMyStETH, which reverts if the converted shares amount is zero due to rounding errors. This creates a denial of service risk where small bond amounts that should be burned may cause the function to revert unexpectedly. The root cause is the double conversion between stETH and shares and the lack of a check for negligible stETH amounts before initiating the burn. This can prevent legitimate penalty enforcement and leave dust shares stranded in the contract.\n",
            "severity": "Low",
            "location": [
                "CSBondCore.sol::_burn#203-211",
                "Burner.sol::_requestBurn"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/abstract/CSBondCore.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/core/contracts/0.8.9/Burner.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "L2: Depositable count not updated in migrateToPriorityQueue",
            "description": "The migrateToPriorityQueue function uses the depositable count to determine how many keys can be migrated. However, this count may be outdated if the node operator's bond lock has expired or bond curve parameters have changed. Since the function is permissionless, an attacker can call it with an outdated depositable count, resulting in fewer keys being migrated than should be allowed. Because migration can only occur once per node operator, this permanently limits their ability to migrate. The root cause is the reliance on a potentially stale depositable count without first updating it. This is a logic error that can be exploited to harm node operators' operational efficiency.\n",
            "severity": "Low",
            "location": [
                "CSModule.sol::migrateToPriorityQueue",
                "CSModule.sol::_enqueueNodeOperatorKeys#1512-1513"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "L3: Incorrect number of migrated keys",
            "description": "The migrateToPriorityQueue function calculates the number of keys to migrate as min(maxDeposits - deposited, enqueuedCount), subtracts this from enqueuedCount, and passes it to _enqueueNodeOperatorKeys. However, _enqueueNodeOperatorKeys then computes the final number of keys as min(depositable - enqueued, maxKeys), where enqueued is the updated (lower) value. This leads to an incorrect final count because the function uses a stale enqueued value in its logic. The expected behavior is to migrate min(depositable, toMigrate) keys, but the actual behavior results in min(depositable - enqueued + toMigrate, toMigrate), which can be less. The root cause is inconsistent state handling between the two functions, leading to a logic error in key migration.\n",
            "severity": "Low",
            "location": [
                "CSModule.sol::migrateToPriorityQueue#603-610",
                "CSModule.sol::_enqueueNodeOperatorKeys#1512-1513"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "W1: Duplicate getSigningKeys call in processBadPerformanceProof",
            "description": "The processBadPerformanceProof function in CSStrikes.sol calls getSigningKeys to obtain a validator's public key, and then passes control to _ejectByStrikes, which calls ejectBadPerformer in CSEjector.sol. The ejectBadPerformer function then calls getSigningKeys again to recompute the same public key, despite the value already being available. This results in unnecessary gas consumption. The root cause is redundant computation across contract boundaries. Although the team acknowledged this and accepted the gas cost for trust boundary reasons, it remains a gas optimization issue. The function is called in a context where the pubkey could be passed as a parameter, eliminating the duplicate call.\n",
            "severity": "Informational",
            "location": [
                "CSStrikes.sol::_ejectByStrikes#221-245",
                "CSEjector.sol::ejectBadPerformer#207-212"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSStrikes.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSEjector.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "W2: Depositable validators count can be updated on non-existing node operators",
            "description": "The updateDepositableValidatorsCount function in CSModule.sol can be called for non-existing node operators. While the function safely does nothing in such cases, this behavior may not be intended and could lead to unnecessary transactions. The root cause is the lack of a validation check to ensure the node operator exists before attempting to update their depositable count. Although the team acknowledged this as intentional due to backward compatibility and existing safeguards in calling contexts, it represents a logic inconsistency that could confuse external callers or lead to wasted gas.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::updateDepositableValidatorsCount#579-583"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "W3: ValidatorWithdrawalInfo struct contains unused isSlashed field",
            "description": "The ValidatorWithdrawalInfo struct in CSModule.sol contains an isSlashed field that is no longer used in CSM v2. This field was carried over from CSM v1 but is obsolete because slashing reporting during withdrawal proofs has been removed. The presence of unused code increases contract complexity and storage footprint without benefit. The root cause is failure to clean up legacy fields during the upgrade. This is a code quality issue that should be addressed to improve maintainability and reduce potential confusion.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::ValidatorWithdrawalInfo"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1285"
                ],
                "4": [
                    "CWE-129"
                ]
            },
            "title": "W4: _validateKeyNumberValueIntervals in CSParametersRegistry does not check for empty arrays",
            "description": "The _validateKeyNumberValueIntervals function in CSParametersRegistry.sol accesses intervals[0] without first checking if the array is empty. This can lead to an out-of-bounds revert when an empty array is passed. The function is called by setRewardShareData and setPerformanceLeewayData, which also lack empty array checks. The root cause is insufficient input validation. This is a defensive programming issue that could cause unintended reverts during configuration updates, potentially disrupting protocol operations if exploited.\n",
            "severity": "Informational",
            "location": [
                "CSParametersRegistry.sol::_validateKeyNumberValueIntervals#766-786"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSParametersRegistry.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "W5: Node operators can self-refer",
            "description": "The CSVettedGate and CSModule contracts allow a node operator to set their own address as the referrer, enabling self-referral. While this is intended in CSModule.sol, it was not intended in CSVettedGate.sol, where it could distort referral incentives. The root cause is the absence of a self-reference check in CSVettedGate. This is a logic error that could be exploited to game referral rewards. The issue was partially fixed by adding a check in CSVettedGate, but self-referral remains allowed in CSModule as intended.\n",
            "severity": "Informational",
            "location": [
                "CSVettedGate.sol",
                "CSModule.sol"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/VettedGate.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ]
            },
            "title": "W6: Invalid tagging of memory-safe assembly",
            "description": "The SSZ library uses inline assembly blocks that are tagged with a single-line comment `// @solidity memory-safe-assembly`. However, the Solidity compiler only recognizes memory-safe assembly tags when they are written as NatSpec comments using triple slashes (`///`). The incorrect comment syntax fails to properly signal memory safety to the compiler, which may result in unnecessary memory clobbering or missed optimizations. This issue arises due to a misunderstanding of Solidity's syntax requirements for memory-safe assembly annotations. Although the impact is limited to compiler-level optimizations and does not introduce direct security risks, it may affect runtime behavior in unexpected ways under certain conditions. The consequence is a warning-level issue related to code correctness and compiler interaction.\n",
            "severity": "Informational",
            "location": [
                "SSZ.sol#30",
                "SSZ.sol#121",
                "SSZ.sol#187"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/lib/SSZ.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "W7: Node operator creation transient flag not cleared",
            "description": "The CSModule contract uses a boolean flag stored in transient storage to track whether a node operator was created within the current transaction. This flag is set during node operator creation but is never cleared afterward. The root cause is the lack of cleanup logic after the flag has served its purpose. An attacker could exploit this by structuring a transaction sequence where a victim creates a node operator, and then an untrusted contract (controlled by the attacker) is called within the same transaction, allowing the attacker to add validator keys to the newly created operator. Alternatively, if the victim\u2019s transaction is bundled with the attacker\u2019s via ERC-4337 and executed first, the attacker can exploit the still-set flag. This leads to unauthorized addition of validator keys, violating intended access control logic and enabling potential abuse of permissioned functionality.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::_isOperatorCreatedInTX#1531"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-369"
                ]
            },
            "title": "W8: Division by zero in processBadPerformanceProof",
            "description": "The `processBadPerformanceProof` function in the CSStrikes contract performs a modulus operation using `keyStrikesList.length` as the divisor without validating that the length is non-zero. The cause is the absence of input validation before arithmetic operations. If `keyStrikesList.length` is zero, this results in a division by zero, triggering a Solidity panic (0x12), which causes the transaction to revert with a low-level panic error instead of a meaningful revert message. This impacts user experience and error handling clarity, as callers cannot distinguish between different failure modes. While it does not lead to fund loss or privilege escalation, it results in poor error reporting and potential confusion during interaction.\n",
            "severity": "Informational",
            "location": [
                "CSStrikes.sol::processBadPerformanceProof#136"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSStrikes.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ]
            },
            "title": "W9: submitWithdrawals griefing",
            "description": "The `submitWithdrawals` function in CSModule does not handle edge cases in input array size securely. If an empty array is passed, the module nonce is unnecessarily incremented, potentially leading to a denial of service for future deposit operations that depend on the nonce. Additionally, if multiple withdrawal items are passed, an attacker can front-run the transaction by submitting a withdrawal for one validator, causing the entire transaction to revert and wasting the caller's gas. The root cause is the lack of input validation and improper control flow: the function reverts upon encountering an already-reported validator instead of skipping it. This enables griefing attacks where an attacker can disrupt legitimate operations at low cost, impacting reliability and user experience.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol::submitWithdrawals#719"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ],
                "3": [
                    "CWE-483"
                ]
            },
            "title": "W10: Unconditional emission of ReferralRecorded event",
            "description": "The `VettedGate.recordReferral` function unconditionally emits the `ReferralRecorded` event, even when the referral season is inactive or the referrer is invalid. This occurs because the event emission is placed outside the conditional block that checks `isReferralProgramSeasonActive`. The cause is incorrect placement of event emission logic. Off-chain systems that listen for this event may incorrectly interpret it as a valid referral, leading to inaccurate tracking and potential misuse of referral data. While this does not directly affect on-chain state or fund security, it compromises the integrity of referral analytics and may mislead integrators relying on event logs for business logic.\n",
            "severity": "Informational",
            "location": [
                "VettedGate.sol::_bumpReferralCount#388"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/VettedGate.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "I1: Lido and StETH ambiguous naming",
            "description": "The codebase uses inconsistent variable names for the same contract address: `STETH` in CSModule and CSFeeDistributor, while using `LIDO` in CSBondCurve and CSAccounting. This inconsistency stems from differing naming conventions across contracts despite referring to the same underlying contract. The ambiguity can mislead auditors or developers into believing these are different contracts, increasing the risk of errors during code review or integration. Although the functionality remains correct, the lack of naming uniformity reduces code clarity and maintainability. This is a code quality issue that could indirectly contribute to future bugs if assumptions are made based on variable names.\n",
            "severity": "Informational",
            "location": [
                "CSModule.sol",
                "CSFeeDistributor.sol",
                "CSBondCurve.sol",
                "CSAccounting.sol"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSFeeDistributor.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/abstract/CSBondCurve.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSAccounting.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "I2: Typos",
            "description": "Multiple typographical errors were found in the codebase: \"internals\" instead of \"intervals\", \"Invariat\" instead of \"Invariant\", and \"kes\" instead of \"keys\". These typos appear in comments and parameter documentation, such as in ICSBondCurve's interface documentation, CSModule's invariant comment, and SigningKeys' function parameters. While these do not affect runtime behavior, they reduce code readability and professionalism. Misleading or incorrect comments can confuse developers and auditors, especially when relying on documentation to understand complex logic. The root cause is insufficient code review or lack of automated linting for comments.\n",
            "severity": "Informational",
            "location": [
                "ICSBondCurve.sol#10",
                "CSModule.sol#1402",
                "SigningKeys.sol#165"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/interfaces/ICSBondCurve.sol",
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/CSModule.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "I3: Inconsistent unchecked use in CSBondCurve",
            "description": "The CSBondCurve contract inconsistently applies the `unchecked` block around out-of-bounds checks for `curveId`. Functions `_getCurveInfo` and `_updateBondCurve` perform bounds checks outside of `unchecked`, while `_setBondCurve` wraps the same type of check inside an `unchecked` block. This inconsistency suggests a lack of clear coding standards. Although all checks correctly revert on invalid input, the mixed usage may confuse reviewers about the intent\u2014whether overflow is expected or not. The issue does not introduce runtime risks but affects code maintainability and clarity. Uniform application of `unchecked` is recommended to reflect intentional design choices.\n",
            "severity": "Informational",
            "location": [
                "CSBondCurve.sol::_getCurveInfo#248",
                "CSBondCurve.sol::_updateBondCurve#114",
                "CSBondCurve.sol::_setBondCurve#134"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/abstract/CSBondCurve.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "I4: Unused code",
            "description": "The codebase contains unused elements: the error `InvalidBondCurveMaxLength` in ICSBondCurve.sol and the modifier `whenPaused` and function `_pauseUntil` in PausableUntil.sol. These artifacts are not referenced anywhere in the code, making them dead code. While some were removed (e.g., the unused error), others were retained for future use. Unused code increases complexity, reduces readability, and may mislead developers into thinking functionality is active. Although the team decided to keep some for forward compatibility, their presence still constitutes a code quality concern and should be well-documented to avoid confusion.\n",
            "severity": "Informational",
            "location": [
                "ICSBondCurve.sol",
                "PausableUntil.sol"
            ],
            "files": [
                "59dc7845660bef7299bf8cc97f9c831f5588a8ba/community-staking-module/src/interfaces/ICSBondCurve.sol"
            ]
        }
    ]
}