{
    "path": "dataset-curated/reports/OpenZeppelin/Taiko Shasta Protocol Audit.md",
    "project_info": {
        "url": [
            "https://github.com/taikoxyz/taiko-mono"
        ],
        "commit_id": [
            "503445678a4bd875d761e56ba80a29a5b8e68d6e"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2023-03-22",
        "project_path": {
            "taiko-mono": "dataset-curated/contracts/Taiko Shasta Protocol Audit.md-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Span Handling in _finalize() Causes Permanent Finalization Halt",
            "description": "The _finalize() function in the Inbox contract assumes that each processed proposal both starts and ends at lastFinalizedProposalId + 1, which only holds true when transitionRecord.span == 1. When span > 1 (as used in optimized inboxes), the function finalizes multiple proposals but only advances lastFinalizedProposalId by one, creating a state inconsistency. This causes subsequent finalization attempts to fail because the next expected proposal ID does not have a corresponding transition record, as aggregated records are stored under the first proposal ID in the span. As a result, finalization halts permanently, unfinalized proposals accumulate, and the ring buffer eventually fills, preventing new proposals. This leads to a complete denial of service on the rollup, with prover bonds remaining locked indefinitely.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol::_finalize#955-1046",
                "InboxOptimized1.sol::_buildAndSaveAggregatedTransitionRecords"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Finalization Denial of Service due to Forced Record Hash Mismatch",
            "description": "The Inbox and InboxOptimized1 contracts implement a conflict detection mechanism that sets the finalization deadline to the maximum value when a transition record hash mismatch occurs. However, this mechanism is too rigid and can be triggered by valid, non-contradictory proofs that differ only in structure or bond instructions. Three vectors exist: aggregation vs. single-step proofs, time-dependent bond variance near proving window boundaries, and prover-dependent bond differences. In each case, honest provers can generate different hashes for valid transitions, causing the system to treat them as conflicting and freeze finalization. This design flaw exposes a denial-of-service vector where the rollup's finalization is permanently blocked due to benign variations in proof data, undermining liveness and decentralization.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol",
                "InboxOptimized1.sol",
                "LibBondInstruction.sol"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "Chain Continuity Violation in InboxOptimized1 Transition Aggregation",
            "description": "The InboxOptimized1 contract aggregates multiple transitions into a single TransitionRecord without verifying that each transition's parentTransitionHash matches the previous transition's transitionHash. This allows an attacker to submit a batch of transitions that are individually valid but not cryptographically linked in sequence. For example, a transition can point to a non-canonical parent state while still being accepted in an aggregated record. During finalization, the system jumps directly to the final transition's hash, effectively teleporting the chain state to an arbitrary fork. This breaks the fundamental assumption of chain continuity, enabling an attacker to finalize invalid state transitions, potentially leading to consensus failure, asset theft, or inflation.\n",
            "severity": "Critical",
            "location": [
                "InboxOptimized1.sol::_buildAndSaveAggregatedTransitionRecords#175"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/InboxOptimized1.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-228"
                ],
                "3": [
                    "CWE-237"
                ]
            },
            "title": "Denial of Service via Unsafe ABI Decoding in Anchor Contract",
            "description": "The Anchor contract's anchorV4 function processes a ProverAuth struct passed as ABI-encoded calldata, which is decoded using abi.decode in validateProverAuth without prior validation of the encoding's correctness. Malformed input that meets length requirements but fails decoding will cause the abi.decode call to revert, making the entire transaction invalid. Since anchorV4 is required for L2 block validity, this causes the execution engine to reject the block, leading the off-chain driver to enter an infinite retry loop. This results in a permanent halt of the L2 chain, preventing further state progression and blocking the finalization of dependent proposals. The system loses liveness due to an unhandled low-level revert in a critical path.\n",
            "severity": "Critical",
            "location": [
                "Anchor.sol::anchorV4#221",
                "Anchor.sol::validateProverAuth#346",
                "LibManifest.sol#50"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/Anchor.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Lack of Cryptographic Binding Between Proof and Guest Program ID",
            "description": "The Risc0Verifier and SP1Verifier contracts verify proofs using external verifiers but fail to cryptographically bind the verified proof to the claimed guest program ID (blockImageId or blockProvingProgram). While the contracts check that the ID is in a trusted list, the external verification does not confirm that the aggregation proof actually executed the specified guest program. An attacker can generate a proof from a malicious guest program, aggregate it using the legitimate aggregation program, and submit it with a trusted ID. The contract accepts it because the aggregation proof is valid, even though it attests to an unauthorized program. This allows bypassing protocol validity rules and finalizing arbitrary, potentially malicious state transitions.\n",
            "severity": "Critical",
            "location": [
                "Risc0Verifier.sol::verifyProof",
                "SP1Verifier.sol::verifyProof"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/verifiers/Risc0Verifier.sol",
                "taiko-mono/packages/protocol/contracts/layer1/verifiers/SP1Verifier.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Problematic Conflict Resolution Design",
            "description": "The current conflict resolution design, triggered by TransitionConflictDetected, fails to act as a circuit breaker and leads to multiple systemic issues. It does not halt propose(), prove(), or saveForcedInclusion(), allowing the ring buffer to fill with unprocessable proposals, leading to complete unavailability. Recovery via _compositeKeyVersion bumping invalidates proofs but leaves proposals intact, creating permanent deadlocks if the canonical chain must be re-rooted. Honest provers lose rewards due to \"zombie proofs,\" and malicious actors can withdraw bonds before slashing. Forced inclusions continue, enabling cheap griefing attacks. The design lacks granular governance tools to resolve conflicts safely and forces a coarse \"nuclear\" reset, causing unnecessary waste and fragility. This undermines both security and liveness during critical failure scenarios.\n",
            "severity": "Critical",
            "location": [
                "IInbox.sol::TransitionConflictDetected",
                "Inbox.sol::_finalize#955",
                "Inbox.sol::_proposalHashes",
                "Inbox.sol::_compositeKeyVersion#125"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/iface/IInbox.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Unfinalizable Proposals via Aggregation Overflow",
            "description": "The InboxOptimized1 contract uses a uint8 span field in TransitionRecord to track the number of aggregated proposals, but _buildAndSaveAggregatedTransitionRecords allows aggregation of more than 255 proposals in an unchecked block. When 256 proposals are aggregated, span overflows from 255 to 0, creating an invalid record. During finalization, this record cannot be processed: supplying a correct span=256 proof fails the hash check, while using the stored span=0 record fails the require(transitionRecord.span > 0) check. This creates an unresolvable deadlock, halting finalization. As new proposals accumulate, the ring buffer fills, and propose() permanently reverts with NotEnoughCapacity(), resulting in a complete system halt. A malicious prover can exploit this by submitting a single proof covering 256 consecutive proposals.\n",
            "severity": "High",
            "location": [
                "InboxOptimized1.sol::_buildAndSaveAggregatedTransitionRecords#175",
                "Inbox.sol::_finalize#955-1046"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/InboxOptimized1.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Ineffective Conflict Handling Allows Finalization of Conflicted Transitions",
            "description": "The conflict handling mechanism between `InboxOptimized1` and `Inbox` fails to prevent finalization of transitions that have been flagged as conflicted. When a hash collision occurs for the same proposal and parent, `InboxOptimized1` overwrites the ring buffer slot and sets the `finalizationDeadline` to the maximum value to mark it as non-finalizable. However, the `_finalize` function in `Inbox` only enforces this deadline when no transition data is provided (implicit finalization). When a caller supplies a `TransitionRecord` in calldata, the function skips the deadline check and finalizes the transition if the hash matches, ignoring the conflict flag.\n\nThe root cause is a logic inconsistency between the two contracts: `InboxOptimized1` marks conflicted transitions as non-finalizable, but `Inbox` does not enforce this rule in the explicit finalization path. An attacker can exploit this by submitting a conflicting transition that overwrites the valid one and then having a colluding proposer include it in a proposal with explicit transition data. The system will accept it because the hash matches, even though it was marked as conflicted.\n\nThis allows malicious or incorrect transitions to become canonical, undermining the protocol's conflict resolution mechanism and enabling replacement of valid transitions. The impact includes weakened security guarantees, potential manipulation of chain state, and reduced trust in honest prover outcomes.\n",
            "severity": "Medium",
            "location": [
                "InboxOptimized1.sol::#89-128",
                "Inbox.sol::#533-557",
                "Inbox.sol::_finalize"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/InboxOptimized1.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-691"
                ]
            },
            "title": "Inconsistent Inheritance Patterns and Defective Initialization Logic",
            "description": "The protocol's upgradeability architecture suffers from inconsistent inheritance patterns and defective initialization logic, particularly in `AnchorForkRouter` and `Anchor` contracts. The design uses complex and brittle inheritance chains to maintain storage compatibility, with some contracts using `EssentialContract` while others directly inherit `UUPSUpgradeable` and `Ownable2StepUpgradeable`, leading to confusion and audit difficulty.\n\nA critical flaw is the lack of a functional mechanism to initialize the `owner` address in the proxy's storage, rendering access control ineffective. The `_transferOwnership` call in the `Anchor` constructor only affects the implementation contract, not the proxy. Additionally, constructors do not consistently call `_disableInitializers()`, leaving implementation contracts vulnerable to reinitialization.\n\nThis creates risks of ownership loss, broken upgradeability, and potential reinitialization attacks. The impact includes compromised access control, inability to upgrade contracts securely, and increased attack surface due to unclear initialization responsibilities. The structural complexity also reduces code maintainability and increases the likelihood of future bugs.\n",
            "severity": "Medium",
            "location": [
                "AnchorForkRouter.sol::#56",
                "Anchor.sol::#26",
                "Anchor.sol::_transferOwnership#206",
                "EssentialContract.sol::#10",
                "ForkRouter.sol::#22"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/AnchorForkRouter.sol",
                "taiko-mono/packages/protocol/contracts/layer2/core/Anchor.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Missing Synchronization Between BondManager and PreconfWhitelist Allows Low-Bond 'Zombie' Proposers",
            "description": "The `BondManager` and `PreconfWhitelist` contracts are not synchronized, allowing operators who are no longer properly bonded to remain whitelisted and eligible for selection as proposers. When a proposer is slashed below `minBond` or requests withdrawal, `BondManager` marks them as low-bond, but this state change is not propagated to `PreconfWhitelist`. The operator remains whitelisted until manually removed, even though they are economically invalid.\n\nThe root cause is the absence of event-driven synchronization between the two components. The current ejector monitor does not subscribe to `BondManager` events, so it fails to detect when a proposer becomes low-bond. If such a \"zombie\" proposer is selected, their proposal is replaced with an empty manifest, leading to wasted L1 gas, reduced liveness, and poor user experience due to delayed transaction inclusion.\n\nThe impact includes degraded network liveness, increased operational costs, and silent erosion of system reliability. Since all components behave as designed, this issue may go undetected by standard monitoring, making it a stealthy liveness risk.\n",
            "severity": "High",
            "location": [
                "BondManager.sol::",
                "PreconfWhitelist.sol::",
                "ejector monitor"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/BondManager.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Inconsistent `Proved` Event Payload Creates Data Availability Gap for Aggregated Transitions",
            "description": "The `InboxOptimized1` contract emits a `Proved` event when aggregating multiple transitions, but the event payload lacks the full `Checkpoint` preimage for the end of the span. While it includes the full `Checkpoint` for the first proposal and the `checkpointHash` for the last, the actual preimage (block hash and state root) for the final transition is not exposed on-chain.\n\nThe root cause is a mismatch between the event design and the requirements of off-chain components like the `shasta_indexer`, which rely solely on L1 events to reconstruct `ProposeInput`. Without the full end-of-span `Checkpoint`, these components cannot construct a valid `ProposeInput.checkpoint` that matches `record.checkpointHash`, even though the proof exists on-chain.\n\nThis creates a data availability gap: finalization of aggregated transitions depends on external L2 data sources. If the L2 RPC is unavailable or out of sync, finalization stalls despite valid proofs being present on L1. The impact includes reduced liveness, increased centralization risk (reliance on specific RPC endpoints), and weakened robustness of the permissionless finality mechanism.\n",
            "severity": "Medium",
            "location": [
                "InboxOptimized1.sol::",
                "Inbox.sol::_setTransitionRecordHashAndDeadline#501",
                "shasta_indexer::indexer.go"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/InboxOptimized1.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Forced Inclusion and Permissionless Fallback Can Be Throttled via `LastProcessedAt` Coupling",
            "description": "The forced inclusion mechanism uses `lastProcessedAt` to determine when a transaction is due, but this value is updated every time any forced inclusion is processed. A malicious proposer can exploit this by processing only one transaction at a time (e.g., `minForcedInclusionCount = 1`), which resets `lastProcessedAt` to the current timestamp, thereby pushing the due time of subsequent transactions forward by another `forcedInclusionDelay`.\n\nThe root cause is the coupling of liveness guarantees to `lastProcessedAt` instead of strictly to submission timestamps. This allows a censoring proposer to throttle the queue clearance rate, making the delay for the k-th transaction approximately `k \u00d7 forcedInclusionDelay`. The permissionless fallback is similarly weakened because its activation threshold also depends on `lastProcessedAt`, which a malicious proposer can keep recent to prevent the fallback from ever activating.\n\nThe impact is a degraded forced inclusion mechanism that fails to provide strong liveness guarantees under adversarial conditions. Even though the queue is FIFO and censorship is not permanent, users may experience unbounded delays, undermining the safety valve intended for worst-case scenarios like proposer collusion or systemic bugs.\n",
            "severity": "Low",
            "location": [
                "LibForcedInclusion.sol::#172",
                "Inbox.sol::_dequeueAndProcessForcedInclusions#883"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/libs/LibForcedInclusion.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Misleading Documentation",
            "description": "Multiple documentation comments are inconsistent with the actual contract behavior, leading to potential misinterpretation by developers, auditors, and integrators. Examples include misdocumenting L2 withdrawal restrictions as \"unrestricted\" when they are actually time-gated, incorrectly labeling `BondManager` as an L1 contract when it is used on L2, and overstating the persistence of proposal hashes in a ring buffer that overwrites old entries.\n\nThe root cause is outdated or inaccurate comments that were not updated alongside code changes. This includes incorrect storage size documentation (304 bits vs actual 512 bits), misleading parameter descriptions (e.g., `_newInstance` in `hashPublicInputs`), and false claims about enforced limits (e.g., forced inclusions limited to one L2 block when no such limit exists).\n\nThe impact is increased risk of incorrect assumptions during integration, auditing, or protocol analysis. Misleading documentation can lead to flawed security models, incorrect gas estimations, and integration errors, especially for third-party developers relying on interface comments for understanding system behavior.\n",
            "severity": "Low",
            "location": [
                "IBondManager.sol::#90-95",
                "BondManager.sol::#10",
                "InboxOptimized1.sol::ReusableTransitionRecord#29",
                "Inbox.sol::getProposalHash#372",
                "LibPublicInput.sol::hashPublicInputs#18",
                "SgxVerifier.sol::verifyProof#126",
                "BondManager.sol::authorized#20",
                "LibForcedInclusion.sol::#15,18"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/IBondManager.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Proving Window Misconfiguration Leads to Altered Bond Mechanics",
            "description": "The `Inbox` contract does not enforce that `extendedProvingWindow >= provingWindow` during initialization. This allows a misconfigured deployment where the extended window is shorter than the base proving window, which collapses the \"late\" proof interval and causes all proofs submitted after `provingWindow` to be classified as \"very-late\".\n\nThe root cause is the lack of input validation in the constructor. The bond classification logic in `_buildTransitionRecord` relies on these windows to determine whether a proof is on-time, late, or very-late. When `extendedProvingWindow < provingWindow`, the condition for \"late\" proofs becomes impossible to satisfy, so all delayed proofs are treated as very-late, shifting bond responsibilities from the designated prover to the proposer and altering incentive structures.\n\nThe impact is a distortion of the intended economic incentives for provers. For example, a proof submitted within what should be the \"late\" window may be penalized as \"very-late\", discouraging external provers and reducing liveness. This could be exploited by proposers to manipulate bond payouts or avoid accountability for delayed proofs.\n",
            "severity": "Medium",
            "location": [
                "Inbox.sol::#166-188",
                "Inbox.sol::_buildTransitionRecord",
                "LibBondInstruction.sol::calculateBondInstructions#67-109",
                "Anchor.sol::_processBondInstructions#428-463"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Default Fail-Open Configuration for SGX Enclave Attestation",
            "description": "The `SgxVerifier` contract relies on `AutomataDcapV3Attestation` for verifying SGX enclaves, but the `checkLocalEnclaveReport` flag is set to `false` by default. This disables critical validation of the enclave's `MRENCLAVE` and `MRSIGNER` measurements, allowing any enclave with a valid Intel quote to be registered, regardless of the software it runs.\n\nThe root cause is a fail-open default configuration, which contradicts the principle of secure-by-default design. While the system assumes an honest owner will enable the check, an oversight or misconfiguration could leave the system vulnerable to malicious enclaves running unauthorized code.\n\nThe impact is a potential compromise of the proof-of-validity mechanism, as an attacker could register a rogue verifier enclave and submit invalid proofs. This undermines the security foundation of the entire protocol, especially if the owner fails to manually enable the check during deployment.\n",
            "severity": "High",
            "location": [
                "SgxVerifier.sol::",
                "AutomataDcapV3Attestation.sol::checkLocalEnclaveReport#37"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/verifiers/SgxVerifier.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Re-activation Causes Permanent DoS Due to Stale Ring Buffer State",
            "description": "The `activate` function in the `Inbox` contract resets `nextProposalId` but does not clear the `_proposalHashes` ring buffer. If proposals were submitted between the first and second activation, their hashes remain in the buffer. After reset, when a new proposal is submitted with `id = 1`, the contract detects a non-zero hash at index 1 and triggers wrap-around logic, requiring the proposal ID in that slot (which is 1) to be less than the genesis proposal ID (0). Since 1 < 0 is impossible, all future proposals revert.\n\nThe root cause is incomplete state reset logic in the `_activateInbox` function. The ring buffer is not cleared, leading to a contradiction in the chain head verification logic after reactivation. This creates a permanent denial-of-service condition that renders the contract unusable.\n\nThe impact is a complete halt of proposal submission and chain progression if `activate` is called twice within the 2-hour window. Although the function is time-locked, this vulnerability poses a critical risk during recovery scenarios or L1 reorgs, potentially leading to irreversible chain downtime.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol::activate#208",
                "Inbox.sol::_verifyChainHead",
                "_proposalHashes ring buffer"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Beacon Block Root Retrieval Lacks Fallback for Missed Slots",
            "description": "The `PreconfWhitelist` contract retrieves beacon block roots using `getBeaconBlockRootAt`, which requires a block to exist at the exact epoch boundary timestamp. If that slot is missed, the function returns `bytes32(0)`, resulting in zero randomness and causing the operator selection to default to index 0.\n\nThe root cause is the use of a strict lookup function without a fallback mechanism. The `_getRandomNumber` function does not handle the case of missed slots, leading to deterministic and biased operator selection during network anomalies.\n\nThe impact is a loss of randomness and fairness in proposer selection, introducing a predictable bias toward the first operator. This weakens the security of the preconfirmation system and could be exploited during periods of network instability to manipulate which operator is selected.\n",
            "severity": "Low",
            "location": [
                "PreconfWhitelist.sol::_getRandomNumber#280",
                "LibPreconfUtils.sol::getBeaconBlockRootAt#60"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/preconf/impl/PreconfWhitelist.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Gas Asymmetry and Low-Bond Path Enable Griefing of Previous Prover",
            "description": "There is a structural gas asymmetry between proposing and proving blocks, where proving is significantly more expensive than proposing. When a proposer is in a low-bond state (e.g., after slashing or withdrawal request), the protocol automatically assigns the previous prover as the designated prover without requiring authentication or paying a prover fee. This allows a low-bond proposer to force the previous prover to incur high proving costs without compensation, creating a griefing vector.\n\nThe root cause is the protocol design decision to waive prover authentication and fees in low-bond cases while still imposing high proving costs. An attacker (or misbehaving proposer) can exploit this by repeatedly submitting proposals while in a low-bond state, forcing the previous prover to prove them at a net loss.\n\nThe impact is a denial-of-service-like condition against the previous prover, who may be forced to bear unsustainable gas costs. While the team acknowledges the issue and plans to eject low-bond operators from the whitelist, the current design allows this griefing scenario to persist until enforcement is implemented off-chain.\n",
            "severity": "High",
            "location": [
                "Inbox.sol::propose#232",
                "Inbox.sol::prove#300",
                "Anchor.sol::setDesignatedProver#302-304"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Deposits After Withdrawal Keep Proposer in Permanent Low-Bond \u201cZombie\u201d State",
            "description": "After calling `requestWithdrawal()`, a proposer who later deposits sufficient funds to meet the minimum bond requirement remains permanently classified as low-bond because the `withdrawalRequestedAt` flag is not reset by the `deposit()` function. The `hasSufficientBond` check requires both sufficient balance and `withdrawalRequestedAt == 0`, so even fully funded proposers are treated as low-bond until they explicitly call `cancelWithdrawal()`.\n\nThe root cause is the lack of state synchronization in the `deposit()` function, which updates the balance but fails to clear the withdrawal request flag when the bond is restored. This leads to a \"zombie\" state where the proposer can still be elected and submit blocks, but all proposals are downgraded to default manifests due to low-bond classification.\n\nAn attacker could exploit this by entering and maintaining this state to disrupt block finalization or cause confusion. Honest proposers may unknowingly operate in this degraded mode, leading to dropped transactions and poor user experience. The impact includes loss of user transactions, reduced protocol reliability, and potential confusion in operator status.\n\nA fix would require `deposit()` to reset `withdrawalRequestedAt` when the bond is sufficient, or at minimum, clear documentation and client-side warnings.\n",
            "severity": "High",
            "location": [
                "BondManager.sol::requestWithdrawal#130",
                "BondManager.sol::deposit",
                "Anchor.sol::hasSufficientBond"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer2/core/BondManager.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Ring Buffer Size of 1 Makes Inbox Permanently Unable to Accept Proposals",
            "description": "The `Inbox` contract uses a ring buffer to manage proposals, with available capacity calculated as `ringBufferSize - 1 - unfinalizedProposalCount`. When `ringBufferSize == 1`, this formula always yields zero capacity, even when no proposals are unfinalized. After the genesis block is seeded via `activate`, any call to `propose` will revert with `NotEnoughCapacity()`.\n\nThe root cause is the lack of input validation in the constructor, which only checks for `ringBufferSize == 0` but allows `ringBufferSize == 1`. This is a configuration-level vulnerability that leads to a permanent liveness failure: the contract becomes unable to accept any new proposals after initialization.\n\nAn attacker or misconfigured deployment could set `ringBufferSize = 1`, rendering the system non-operational. The impact is a complete halt in block proposal processing, resulting in a denial of service for the entire rollup.\n\nThe fix requires the constructor to enforce `ringBufferSize >= 2` to ensure at least one usable slot is available.\n",
            "severity": "Critical",
            "location": [
                "Inbox.sol::_getAvailableCapacity#1081-1087",
                "Inbox.sol::constructor#166-179",
                "Inbox.sol::propose#250-252"
            ],
            "files": [
                "taiko-mono/packages/protocol/contracts/layer1/core/impl/Inbox.sol"
            ]
        }
    ]
}