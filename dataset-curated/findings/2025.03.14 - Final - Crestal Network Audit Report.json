{
    "path": "dataset-curated/reports/Sherlock/2025.03.14 - Final - Crestal Network Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/crestalnetwork/crestal-omni-contracts"
        ],
        "commit_id": [
            "dc45e98af5e247dce5bbe53b0bd5b1f256884f84"
        ],
        "address": [],
        "chain": "base",
        "compiler_version": "n/a",
        "audit_date": "2025-03-11",
        "project_path": {
            "crestal-omni-contracts": "dataset-curated/contracts/2025.03.14 - Final - Crestal Network Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Anyone who is approving BlueprintV5 contract to spend ERC20 can get drained because payWithERC20",
            "description": "The `payWithERC20` function in the Payment contract is public, allowing any external caller to initiate token transfers from any address that has approved the contract. This function is intended to be used internally by the BlueprintV5 contract during agent creation, but its public visibility enables abuse. The root cause is the lack of access control on the `payWithERC20` function, which fails to restrict callers to only trusted contracts or internal logic. An attacker can exploit this by calling `payWithERC20` directly with a victim's address as the `fromAddress`, any approved ERC20 token, and the attacker's address as the `toAddress`. This allows the attacker to drain all approved tokens from the victim's wallet. The impact is significant financial loss for users who have approved the contract to spend their tokens, especially during agent creation where such approvals are required.\n",
            "severity": "High",
            "location": [
                "Payment.sol::payWithERC20#25-32"
            ],
            "files": [
                "crestal-omni-contracts/src/Payment.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-1419"
                ]
            },
            "title": "createCommonProjectIDAndDeploymentRequest() hardcodes request id index to 0, leading to lost requests for users",
            "description": "The `createCommonProjectIDAndDeploymentRequest` function in BlueprintCore.sol hardcodes the index value to 0, which prevents proper handling of multiple deployment requests for the same project ID. This function is called during agent creation to register a deployment request, and the index is meant to prevent overwriting existing requests. However, by fixing the index to 0, any new request with the same project ID will overwrite the previous one. The root cause is the static assignment of index = 0 instead of using a user-specific or incrementing counter. An attacker (or even a legitimate user in a race condition) can create a second agent with the same project ID and base64 proposal but a different server URL, causing the first request to be overwritten. The impact is that the first user loses their request and the associated fees, as only one request can be finalized via `submitProofOfDeployment`, even though both required payment.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol#373"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Signatures missing some parameters being vulnerable to attackers using them coupled with malicious parameters",
            "description": "The `createAgentWithSigWithNFT` and similar signature-based functions do not include critical parameters such as `tokenId`, `privateWorkerAddress`, or `tokenAddress` in the signed message digest. This allows attackers to intercept valid signatures from the ERC-4337 mempool (via Biconomy) and replay them with altered parameters. The root cause is incomplete message hashing in the EIP-712 signature scheme, omitting key fields that affect execution outcome. An attacker can observe a user's signed operation in the public mempool, extract the signature, and submit it with a different `tokenId` (potentially one they don't own), a malicious `privateWorkerAddress`, or a higher-cost `tokenAddress`. This leads to users unintentionally deploying agents with wrong tokens, being censored by malicious workers, or paying excessive fees. The impact includes denial of service, fund loss, and manipulation of deployment routing.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::createAgentWithSigWithNFT",
                "BlueprintCore.sol::createAgentWithTokenWithSig"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Signature Replay attack possible on updateWorkerDeploymentConfigWithSig() in Blueprint core.sol which leads to users lose the funds",
            "description": "The `updateWorkerDeploymentConfigWithSig` function lacks replay protection mechanisms such as nonces or timestamps, allowing valid signatures to be reused indefinitely. This function processes payments via `payWithERC20` based on signed messages, making it dangerous if replayable. The root cause is the absence of a nonce or unique identifier in the signed digest, combined with no on-chain state tracking to prevent reuse. An attacker can capture a successful transaction's signature and repeatedly call `updateWorkerDeploymentConfigWithSig` with the same parameters, triggering multiple fund transfers from the user to the fee collection wallet. Each replay executes the payment logic again, draining the user's approved token balance over time. The impact is complete loss of approved funds, as the system does not support refunds and users cannot recover the repeatedly withdrawn fees.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::updateWorkerDeploymentConfigWithSig#672"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of access control in setWorkerPublicKey() in BlueprintCore.sol which results users to lose funds",
            "description": "The `setWorkerPublicKey` function is public and allows any address to register or update a public key in the workers system without authorization. This enables malicious actors to register fake worker identities and be selected by users for private deployments. The root cause is the missing access control modifier, allowing unrestricted writes to critical mappings like `workersPublicKey` and `workerAddressesMp`. An attacker can call `setWorkerPublicKey` with a fake key, get added to the worker list, and be chosen by a user for a private deployment. The user then encrypts sensitive data with the attacker's public key and pays fees, but the attacker can refuse to deploy, keeping the encrypted data and causing the deployment to fail. The impact includes loss of user funds (paid as fees), exposure of sensitive data, and disruption of the deployment ecosystem.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::setWorkerPublicKey#689"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Worker-Induced Denial-of-Service in Deployment Requests Due to Lack of a Cancellation Mechanism",
            "description": "The contract enforces a single active deployment request per project but provides no way to cancel or reset a request if the assigned worker fails to complete it. Once a worker picks up a request (status becomes Pickup), the project is locked indefinitely if the worker does not submit proof of deployment. The root cause is the absence of a timeout or cancellation function, combined with a design that only allows one request per project. An attacker (or negligent worker) can pick up a request and simply never complete it, blocking all future deployment attempts for that project. The impact is permanent stalling of the project lifecycle, rendering it unusable and causing loss of agent creation fees, as no further progress can be made and no refund mechanism exists.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::deploymentRequest",
                "BlueprintCore.sol::submitDeploymentRequest"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Non whitelisted user can also create agent by calling createAgentWithNFT instead of createAgentWithWhitelistUsers affecting the motive of protocol to only allow whitelisted user to create agent",
            "description": "The protocol intends to restrict agent creation to whitelisted users via the `createAgentWithWhitelistUsers` function, but this control is bypassed by the unrestricted `createAgentWithNFT` function. Any user holding the required NFT can create an agent regardless of whitelist status, undermining the access control model. The root cause is the lack of alignment between the two creation paths\u2014while one enforces whitelisting, the other does not, creating a privilege escalation vector. An attacker (non-whitelisted user) can simply call `createAgentWithNFT` instead of the whitelisted version, bypassing the access check entirely. The impact is that the protocol's security and governance model is compromised, allowing unauthorized users to create agents and potentially abuse system resources or privileges intended only for approved participants.\n",
            "severity": "Medium",
            "location": [
                "BlueprintCore.sol::createAgentWithNFT#510",
                "BlueprintCore.sol::createAgentWithWhitelistUsers#521"
            ],
            "files": [
                "crestal-omni-contracts/src/BlueprintCore.sol"
            ]
        }
    ]
}