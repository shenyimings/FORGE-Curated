{
    "path": "dataset-curated/reports/Cantina/cantina_horizen_april2025.pdf",
    "project_info": {
        "url": [
            "https://github.com/HorizenOfficial/horizen-migration"
        ],
        "commit_id": [
            "65ca289dfbc5654809ace57485d781ddb1bbd43d"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": null,
        "project_path": {
            "horizen-migration": "dataset-curated/contracts/cantina_horizen_april2025.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "Excessive admin controls in LinearTokenVesting could break vesting invariants",
            "description": "The LinearTokenVesting.sol contract grants excessive administrative privileges that can compromise the integrity of the vesting schedule. The changeVestingParams() function allows the admin to modify critical parameters such as timeBetweenClaims and intervalsToClaim with arbitrary values. This creates two potential vulnerabilities: first, the admin can instantly release 100% of the remaining tokens by setting both parameters to 1, effectively bypassing the vesting schedule. Second, a malicious admin can prevent users from claiming tokens by repeatedly resetting the vesting period just before claims are due, resulting in a denial-of-service condition. The root cause is the lack of immutability or restrictions on admin privileges after deployment. This could lead to loss of user trust and potential financial harm if admin keys are compromised.\n",
            "severity": "Medium",
            "location": [
                "LinearTokenVesting.sol::changeVestingParams"
            ],
            "files": [
                "horizen-migration/erc20-migration/contracts/LinearTokenVesting.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Faulty batchInsert calls in EONBackupVault and ZendBackupVault could lead to irrecoverable state",
            "description": "The batchInsert() function in both EONBackupVault.sol and ZendBackupVault.sol lacks safeguards against invalid data insertion. Although only callable by the owner, the function does not check for duplicate address entries, which could overwrite existing balances or cause inconsistent state. Additionally, there is no validation to ensure that the total amount of tokens to be minted stays within the ZenToken's hard cap of 21,000,000 tokens, risking supply cap violations. The root cause is the absence of input validation and preconditions in the batchInsert function. If exploited through operator error or malicious intent, this could lead to an irrecoverable contract state, incorrect token distribution, or inflation beyond the intended supply.\n",
            "severity": "Low",
            "location": [
                "EONBackupVault.sol#L63",
                "ZendBackupVault.sol#L94"
            ],
            "files": [
                "horizen-migration/erc20-migration/contracts/EONBackupVault.sol",
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Possible replay attack risk in ZendBackupVault",
            "description": "The createMessageHash() function in ZendBackupVault does not include chain-specific context such as chain ID or contract address in the signed message, making signatures susceptible to replay attacks across different chains. Specifically, a signature valid on the original chain could be replayed on a forked chain, and testnet transactions could be replayed on mainnet if not properly isolated. The root cause is the lack of domain separation in the message hash construction. This could allow an attacker to claim tokens on the wrong network using a valid signature from another, potentially leading to loss of funds if the destAddress differs between chains.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Storing unordered eon vault data in zend_to_horizen script",
            "description": "The zend_to_horizen.py script generates a sorted list of EON vault accounts (sorted_eon_vault_accounts) but incorrectly writes the original unsorted dictionary (eon_vault_results) to the output file. This could result in inconsistent or unpredictable processing order during migration, potentially affecting downstream systems that expect deterministic ordering. The root cause is a logic error in file output handling. The impact is primarily operational, risking data integrity and complicating verification processes during the migration.\n",
            "severity": "Low",
            "location": [
                "zend_to_horizen.py#L137"
            ],
            "files": [
                "horizen-migration/dump-scripts/python/horizen_dump_scripts/zend_to_horizen.py"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing balance assertion in zend_to_horizen script",
            "description": "The zend_to_horizen.py script does not include assertions to verify that the total balance of all accounts matches the expected total before and after processing. This lack of validation increases the risk of undetected errors during the migration, such as incorrect balance calculations or data loss. The root cause is the absence of defensive programming practices in a critical migration script. If an error occurs and goes unnoticed, it could result in incorrect token allocations and financial discrepancies post-migration.\n",
            "severity": "Low",
            "location": [
                "zend_to_horizen.py#L127"
            ],
            "files": [
                "horizen-migration/dump-scripts/python/horizen_dump_scripts/zend_to_horizen.py"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing duplicates check could result in incorrect data being processed and generated",
            "description": "The scripts get_all_forger_stakes.py, setup_eon2_json.py, and zend_to_horizen.py do not validate input files for duplicate account entries. Since these scripts assume each account appears only once, duplicate entries could lead to incorrect balance summations or overwrites. The root cause is the lack of duplicate detection logic in data processing pipelines. This could result in inaccurate final account balances in the migration output, leading to incorrect token distribution. While Horizen added checks in zend_to_horizen.py, the other scripts rely on JSON.load behavior, which silently overwrites duplicates.\n",
            "severity": "Low",
            "location": [
                "zend_to_horizen.py#L77",
                "get_all_forger_stakes.py",
                "setup_eon2_json.py#L43"
            ],
            "files": [
                "horizen-migration/dump-scripts/python/horizen_dump_scripts/get_all_forger_stakes.py",
                "horizen-migration/dump-scripts/python/horizen_dump_scripts/setup_eon2_json.py",
                "horizen-migration/dump-scripts/python/horizen_dump_scripts/zend_to_horizen.py"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Precision loss while converting satoshi to wei in zend_to_horizen scripts",
            "description": "The satoshi_2_wei() function in zend_to_horizen.py uses floating-point arithmetic for conversion, which can lead to precision loss when handling large values. Python's float type cannot accurately represent all large integers, such as those near the maximum satoshi value (21,000,000 * 10^8). This could result in incorrect wei values during the migration. The root cause is the use of imprecise data types for financial calculations. Although Horizen removed rounding and noted that inputs are integers, passing float values (e.g., 21_000_000e8) could still introduce errors, risking miscalculations in token amounts.\n",
            "severity": "Low",
            "location": [
                "zend_to_horizen.py#L46"
            ],
            "files": [
                "horizen-migration/dump-scripts/python/horizen_dump_scripts/zend_to_horizen.py"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ]
            },
            "title": "Optimization in ZendBackupVault claims functions",
            "description": "The _verifyPubKeysFromScript function in ZendBackupVault performs inefficient memory operations during public key verification. It loads a 32-byte word starting 31 bytes before the actual signature, relying on the current script layout where the compressed key prefix (0x02/0x03) happens to align with the end of that word. This is fragile and suboptimal. The root cause is poor low-level memory access design. While not a direct security vulnerability, it increases gas costs and introduces fragility\u2014if the script layout changes, the function could break. The impact is higher transaction costs and potential future bugs.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-657"
                ],
                "3": [
                    "CWE-637"
                ]
            },
            "title": "The AccessControl in ZenToken is obsolete",
            "description": "The ZenToken contract imports and uses OpenZeppelin's AccessControl, but only for managing minters. Since minting is a one-time process and no other role-based access is needed, AccessControl introduces unnecessary complexity and bloat. The root cause is over-engineering access control for a simple use case. This leads to unused functions and increased contract size, which could confuse auditors and users. A simpler mapping of minters with a one-time disable mechanism would suffice.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZenToken.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1106"
                ]
            },
            "title": "The distribute of ZEN in the EON vault should not be capped to 500",
            "description": "The distribute function in EONBackupVault enforces a hardcoded limit of 500 addresses per call, which may be insufficient for large-scale distributions. The root cause is the use of a magic number instead of a configurable parameter. This could force multiple transactions to complete a distribution, increasing gas costs and operational complexity. Allowing the owner to specify a maxCount parameter would provide flexibility and efficiency.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/EONBackupVault.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "The admin and owner usage is confusing in LinearTokenVesting",
            "description": "The LinearTokenVesting contract uses both Ownable and a separate immutable admin field. The owner can only call setERC20, which is used once during initialization, while all other privileged functions are restricted to the admin. This dual control model is confusing and redundant. The root cause is inconsistent access control design. It increases cognitive load and risks misconfiguration. Simplifying to use only the owner role with restricted transferability would improve clarity and maintainability.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/LinearTokenVesting.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Add zenToken check to moreToDistribute() function",
            "description": "The moreToDistribute() function in EONBackupVault does not check whether the zenToken address has been set (i.e., != address(0)), unlike the distribute() function, which reverts if it is not. This inconsistency means moreToDistribute() could return true indicating funds are available to distribute, but a subsequent call to distribute() would revert. The root cause is a missing validation check. This could lead to incorrect state assumptions in off-chain systems or user interfaces, causing confusion and failed transactions.\n",
            "severity": "Informational",
            "location": [
                "EONBackupVault.sol#L115"
            ],
            "files": [
                "horizen-migration/erc20-migration/contracts/EONBackupVault.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Merkle Trees could be used instead of batch insert in the ZendBackupVault",
            "description": "The ZendBackupVault currently uses on-chain batchInsert to register all user balances, which is gas-intensive. A more efficient approach would be to use a Merkle tree, where only the root is stored on-chain, and users provide Merkle proofs to claim their tokens. The root cause is the use of a naive data commitment strategy. While not a vulnerability, this represents a scalability limitation. Adopting Merkle trees would reduce deployment costs and improve efficiency, especially for large user bases.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "S-malleability in the claiming process",
            "description": "The claimP2PKH and claimP2SH functions in ZendBackupVault accept ECDSA signatures without enforcing low-S normalization. While this does not currently enable fund theft\u2014because balances are set to zero after the first claim and the message commits to destAddress\u2014it violates best practices. The root cause is incomplete signature validation. In other contexts, high-S signatures could lead to replay or malleability issues. For future-proofing and consistency with security standards, signatures should be validated to ensure S \u2264 N/2.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "horizen-migration/erc20-migration/contracts/ZendBackupVault.sol"
            ]
        }
    ]
}