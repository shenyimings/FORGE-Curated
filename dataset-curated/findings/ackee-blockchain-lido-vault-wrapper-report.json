{
    "path": "dataset-curated/reports/Ackee-Blockchain/ackee-blockchain-lido-vault-wrapper-report.pdf",
    "project_info": {
        "url": [
            "https://github.com/lidofinance/vaults-wrapper"
        ],
        "commit_id": [
            "f35fe13ddca2084d7b848172b2698feb4fa88025"
        ],
        "address": [
            "0x5Def7fBC0211351139B928f307EDC794af845Bde",
            "0x671978CEEa7DAf405fA08E930E1047d1b7b21a69",
            "0xB011531857B6006479627e776feB6c0cEA5fc74a",
            "0x9FD67B2D5b88BeBaC741EE50510cf808B4854a5F",
            "0x15f2C9ea98e5564d25A46eE39D19704476998786",
            "0x3f221b8E5bC098cC6C23611BEeacaeCfD77e1587",
            "0x468029A88b6f75Eb1D13BB291fC3B82fc2C0232F"
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2026-02-06",
        "project_path": {
            "vaults-wrapper": "dataset-curated/contracts/ackee-blockchain-lido-vault-wrapper-report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "SocializedLoss event emits incorrect asset amount",
            "description": "The SocializedLoss event in the StvStETHPool contract emits an incorrect value for the assets parameter due to a timing issue in the calculation. The root cause is that the asset amount is calculated after the rebalance operation, which mutates the totalAssets value. Specifically, _convertToAssets(_maxStvToBurn) uses the post-rebalance totalAssets, whereas the event should reflect the pre-rebalance state. This leads to a discrepancy in the emitted asset amount. An attacker or affected party, such as a protocol operator relying on event data for off-chain accounting, could be misled by the incorrect value. The impact is low, as it does not lead to direct fund loss or system compromise, but it can cause inaccuracies in monitoring and reporting systems that consume the event data.\n",
            "severity": "Low",
            "location": [
                "StvStETHPool.sol::StvStETHPool._rebalanceMintedStethShares#678-682"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rebalance preview calculation inconsistency",
            "description": "The previewForceRebalance function in the StvStETHPool contract returns a different STV burn amount than what is actually executed during rebalancing, leading to a calculation inconsistency. The cause is a rounding discrepancy in the execution path: the actual burn uses a round-trip conversion through stETH shares (which involves a down-rounding step in getSharesByPooledEth), while the preview function does not replicate this exact path. As a result, the preview overestimates the required STV amount. An attacker cannot directly exploit this for financial gain, but integrators or automated systems relying on accurate previews may experience confusion or operational issues. The impact is low, as it affects usability and predictability rather than security-critical functions.\n",
            "severity": "Low",
            "location": [
                "StvStETHPool.sol::previewForceRebalance",
                "StvStETHPool.sol::StvStETHPool._rebalanceMintedStethShares#670-671"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Shares cannot be burnt when exceeding liability exists on pool and liability on vault is low",
            "description": "The vulnerability arises in the StvStETHPool contract during direct staking vault rebalancing, where the liabilityShares field in the VaultRecord structure is decreased, but this change does not reflect in the mintedStethShares mapping used by the burnStethShares and burnWsteth functions. This discrepancy causes a logic error that prevents users from burning their stETH or wstETH shares to repay debt, even when the liability has been reduced via rebalancing. The root cause is the lack of synchronization between the liabilityShares in the vault record and the mintedStethShares tracking in the pool contract. An attacker or affected user could find themselves unable to repay debt despite having sufficient shares, especially after a rebalance reduces their liability. In rare cases, this could lead to a user position becoming unhealthy and subject to forced rebalancing, although users may still use the WithdrawalQueue contract as an alternative path to withdraw and repay. The impact is limited to user functionality and debt repayment, not leading to fund loss, hence classified as a Warning.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::burnWsteth#338",
                "StvStETHPool.sol::burnStethShares#353"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Possible type mismatch during calling BORING_QUEUE.requestOnChainWithdraw",
            "description": "The GGVStrategy contract calls BORING_QUEUE.requestOnChainWithdraw with a parameter of type int256 by using ggvShares.toInt256(), while the target function expects a uint128 amountOfShares. This type mismatch constitutes a data validation issue that could lead to transaction failures or undefined behavior during ABI encoding, especially if the receiving contract strictly enforces type correctness. The root cause is improper type conversion in the calling code, which assumes that a uint256 can be safely cast to int256 and then interpreted as uint128, which is not guaranteed. An attacker could potentially exploit this by triggering the function with edge-case values that cause silent truncation or misinterpretation of the amount, leading to incorrect withdrawal requests. The impact is limited to transaction failure or incorrect processing, not direct fund loss, hence classified as a Warning.\n",
            "severity": "Informational",
            "location": [
                "GGVStrategy.sol::requestExitByWsteth#199"
            ],
            "files": [
                "vaults-wrapper/src/strategy/GGVStrategy.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Unsafe transfer in recoverERC20 function",
            "description": "The recoverERC20 function in the GGVStrategy contract uses low-level calls to IERC20.transfer without checking the return value, which is a critical data validation flaw. Many ERC20 tokens, such as USDT, do not return a boolean on transfer, and others may return false instead of reverting on failure. By using callForwarder.doCall without verifying the success of the transfer, the function may appear to succeed while the tokens remain stuck in the call forwarder contract. The root cause is the absence of safe transfer practices, relying on raw calls instead of using the SafeERC20 library. An attacker could exploit this by sending a non-compliant token to the contract and then attempting recovery, leading to a silent failure where the user believes tokens were recovered but they were not. This could result in loss of recovered funds and misreporting of asset movement, hence classified as a Warning.\n",
            "severity": "Informational",
            "location": [
                "GGVStrategy.sol::recoverERC20#366"
            ],
            "files": [
                "vaults-wrapper/src/strategy/GGVStrategy.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Misleading error name in GGVStrategy",
            "description": "The error named NothingToExit in the GGVStrategy contract is misleading because it is triggered when a user attempts to withdraw more tokens than they have requested, not when there is literally nothing to exit. This is a code quality issue that can confuse developers and auditors, leading to incorrect assumptions about the control flow. The root cause is poor naming that does not reflect the actual condition being checked. While this does not introduce a direct security vulnerability, it can lead to maintenance errors or incorrect handling in integrations that rely on error messages for logic. There is no direct exploitation path, but the impact is on code clarity and long-term maintainability, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "GGVStrategy.sol::requestExitByWsteth#190"
            ],
            "files": [
                "vaults-wrapper/src/strategy/GGVStrategy.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1109"
                ]
            },
            "title": "Potentially misleading reserveRatioBp variable name",
            "description": "The variable reserveRatioBp is used in multiple contexts within StvStETHPool, but its effective value for users includes an added gap (ReservationGap + VaultConnection.reserveRatioBp). However, the same name is used without distinguishing between the base value and the effective value, leading to confusion. This is a code quality issue where ambiguous naming can mislead developers about the actual logic. The root cause is the reuse of a variable name across different semantic meanings. While this does not lead to incorrect behavior, it increases the risk of misinterpretation during audits or upgrades, potentially leading to logic errors in future development. The impact is limited to developer experience and code clarity, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::forcedRebalanceThresholdBP#483"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incomplete documentation for checkpoint hint function",
            "description": "The documentation for the checkpoint hint function in WithdrawalQueue.sol incorrectly states that it is used with claimWithdrawalBatch and getClaimableEther, omitting that the batch functions require manual calling while single functions call it automatically. This is a documentation inconsistency that can mislead integrators and developers about the correct usage pattern. The root cause is outdated or incomplete NatSpec comments. This does not introduce a security flaw but can lead to incorrect implementation in off-chain systems, resulting in failed claims or inefficient gas usage. The impact is on integration correctness and developer experience, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "WithdrawalQueue.sol#758"
            ],
            "files": [
                "vaults-wrapper/src/WithdrawalQueue.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unused interfaces and libraries",
            "description": "Several interfaces (ILido, IOperatorGrid, IOssifiableProxy, IBoringSolver) and one library (DoubleRefSlotCache) are defined but not used in the main codebase. This is a code quality issue that increases code bloat and maintenance overhead. The root cause is leftover code from development or testing that was not cleaned up. While unused code does not directly affect security, it can confuse auditors and increase the attack surface if resurrected unintentionally. The team acknowledged that some are used in tests or deploy scripts, but others were removed. The impact is minimal, limited to code clarity and maintainability, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "ILido.sol",
                "IOperatorGrid.sol",
                "IOssifiableProxy.sol",
                "IBoringSolver.sol",
                "IVaultHub.sol::DoubleRefSlotCache"
            ],
            "files": [
                "vaults-wrapper/src/interfaces/core/ILido.sol",
                "vaults-wrapper/src/interfaces/core/IOperatorGrid.sol",
                "vaults-wrapper/src/interfaces/core/IOssifiableProxy.sol",
                "vaults-wrapper/src/interfaces/ggv/IBoringSolver.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused errors",
            "description": "The errors ArraysLengthMismatch in StvStETHPool.sol and StringTooLong in Factory.sol are declared but never used in the codebase. This is a code quality issue that adds unnecessary complexity and can mislead developers into thinking these conditions are handled. The root cause is incomplete cleanup after refactoring. While these errors do not introduce vulnerabilities, they clutter the code and increase compilation size. The impact is limited to code maintainability and clarity, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::ArraysLengthMismatch",
                "Factory.sol::StringTooLong"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol",
                "vaults-wrapper/src/Factory.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Public functions can be declared as external",
            "description": "The functions forceRebalance and forceRebalanceAndSocializeLoss in StvStETHPool.sol are declared as public but are not called internally, meaning they can be declared as external to save gas on deployment and execution. This is a code optimization and quality issue. The root cause is suboptimal function visibility selection. While this does not pose a security risk, it results in higher gas costs for users. The impact is economic inefficiency, not security, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "StvStETHPool.sol::forceRebalance#564",
                "StvStETHPool.sol::forceRebalanceAndSocializeLoss#580"
            ],
            "files": [
                "vaults-wrapper/src/StvStETHPool.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-348"
                ]
            },
            "title": "Role constants read from Dashboard implementation instead of proxy",
            "description": "The Factory.createPoolFinish function reads role constants (e.g., FUND_ROLE, REBALANCE_ROLE) from the global DASHBOARD_IMPL instead of the deployed Dashboard instance. If the implementation changes between pool creation phases, the roles granted may not match the actual implementation, leading to privilege misassignment. The root cause is incorrect source of role identifiers. An attacker could potentially exploit timing between implementation upgrades to gain unintended privileges or cause denial of service by breaking expected role assignments. The impact is on access control integrity, hence classified as Informational due to low likelihood and fixability.\n",
            "severity": "Informational",
            "location": [
                "Factory.sol::createPoolFinish#647"
            ],
            "files": [
                "vaults-wrapper/src/Factory.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "createPoolFinish forwards full msg.value instead of exact connect deposit potentially causing loss of overpaid ETH",
            "description": "The Factory.createPoolFinish function forwards the entire msg.value to Dashboard.connectToVaultHub instead of only the required CONNECT_DEPOSIT amount. This means any overpayment is sent to the dashboard and not refunded, potentially leading to loss of excess ETH if users are unaware. The root cause is lack of explicit value capping in the call. While the function checks for minimum deposit, it does not limit the forwarded value. An attacker cannot directly exploit this, but users may lose funds due to overpayment, especially if documentation does not warn them. The impact is potential user fund loss due to poor UX, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "Factory.sol::createPoolFinish#564"
            ],
            "files": [
                "vaults-wrapper/src/Factory.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "calculateCurrentStethShareRate documentation contradicts implementation precision",
            "description": "The NatSpec for calculateCurrentStethShareRate in WithdrawalQueue.sol claims a 1e27 precision return value, but the implementation returns a value with 1e18 precision (ETH amount per 1e27 stETH shares). This inconsistency can mislead off-chain integrators who rely on documentation for correct scaling. The root cause is outdated or incorrect documentation. While the internal logic is correct, external systems may apply wrong scaling, leading to incorrect calculations in UIs or analytics. The impact is on integration correctness and data interpretation, not on-chain security, hence classified as Informational.\n",
            "severity": "Informational",
            "location": [
                "WithdrawalQueue.sol::calculateCurrentStethShareRate#658"
            ],
            "files": [
                "vaults-wrapper/src/WithdrawalQueue.sol"
            ]
        }
    ]
}