{
    "path": "dataset-curated/reports/Ackee-Blockchain/ackee-blockchain-fluidkey-earn-module-report.pdf",
    "project_info": {
        "url": [
            "https://github.com/fluidkey/fluidkey-earn-module"
        ],
        "commit_id": [
            "6aca8f7e203cadad6287f643cb3ef050ffe1ef01"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-02-17",
        "project_path": {
            "fluidkey-earn-module": "dataset-curated/contracts/ackee-blockchain-fluidkey-earn-module-report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-347"
                ]
            },
            "title": "Cross-chain replay attack vulnerability",
            "description": "The autoEarn function generates a signature verification hash without including the chain ID in its calculation. This omission allows the same signature to be valid across multiple blockchain networks where the module is deployed.\nThe root cause is the failure to bind the signature to a specific chain, making it possible for an attacker to replay a valid signature from one chain on another.\nAn attacker can observe a valid transaction and signature on one chain (e.g., Chain A), then replay that signature on a different chain (e.g., Chain B) where the same module is deployed. Since the chain ID is not part of the hash, the signature verification will succeed on the target chain.\nThis leads to unauthorized execution of operations, such as unauthorized asset movements, effectively allowing an attacker to perform actions on behalf of the original signer on a different chain.\n",
            "severity": "High",
            "location": [
                "FluidkeyEarnModule.sol::autoEarn#291"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "MAX_TOKENS limit bypass via setConfig leading to unintended module persistence",
            "description": "The module enforces a MAX_TOKENS limit during installation via the onInstall function, but this validation is missing in the setConfig function. As a result, users can add more configurations after installation, bypassing the intended cap.\nThe cause is inconsistent validation logic\u2014while onInstall checks the number of configurations against MAX_TOKENS, setConfig does not, creating an attack vector to exceed the limit.\nAn attacker (or authorized user) can install the module with up to 100 configurations, then use setConfig to add more. Upon uninstallation, only the first 100 configurations are cleaned up, leaving excess configurations active.\nThese leftover configurations remain functional even after the module is uninstalled, allowing continued calls to autoEarn and unauthorized token movements, undermining the module's lifecycle integrity.\n",
            "severity": "Medium",
            "location": [
                "FluidkeyEarnModule.sol::setConfig",
                "FluidkeyEarnModule.sol::onUninstall"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Unchecked return value",
            "description": "The execTransactionFromModule function returns a boolean indicating success or failure, but its return value is not checked in the calling code, particularly when depositing wrapped native tokens.\nThe root cause is the lack of proper error handling after an external call, which violates secure coding practices for handling critical operations.\nIf the external call to deposit fails (e.g., due to a reentrancy guard or contract-specific restrictions), the transaction will continue as if it succeeded, leading to incorrect state updates and potential loss of funds.\nThe impact includes silent failures in token wrapping operations, which could result in incorrect accounting and user funds being stuck or lost without clear indication.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::execTransactionFromModule#351-357"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Module installation allows empty configuration",
            "description": "The onInstall function does not validate whether the _configs array is empty before proceeding with initialization. This allows a user to install the module with no actual configurations.\nThe cause is missing input validation, which allows edge-case inputs to trigger unintended behavior.\nAn attacker or user could call onInstall with an empty array, causing the module to emit ModuleInitialized without setting up any valid configurations, potentially misleading other systems that rely on the event.\nWhile not directly exploitable for fund loss, it leads to inconsistent system state and could interfere with dependent logic or monitoring tools expecting valid configurations after initialization.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::onInstall"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Misleading event in deleteConfig",
            "description": "The deleteConfig function emits the ConfigSet event, which is also used by the setConfig function, leading to ambiguous and misleading event logs.\nThe root cause is the reuse of an event for two different operations, which violates the principle of clear and unambiguous logging.\nAn external observer or indexing service cannot distinguish between a configuration being set versus deleted based on events alone, leading to incorrect state reconstruction.\nThis can result in frontends, bots, or analytics tools misinterpreting the actual state changes, potentially leading to incorrect user actions or system decisions.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::deleteConfig"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Variable can be immutable",
            "description": "The wrappedNative address is set once in the constructor and never modified, yet it is declared as a regular public state variable instead of immutable.\nThe cause is suboptimal code design that misses an opportunity for gas savings.\nWhile this does not introduce a direct security risk, it increases the cost of reading the variable during runtime, as regular state variables are more expensive to access than immutable ones.\nThe impact is increased gas consumption for all calls that read wrappedNative, leading to higher transaction costs for users over time.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::wrappedNative#57",
                "FluidkeyEarnModule.sol::constructor#59-63"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Incorrect usage of immutable instead of constant",
            "description": "The ETH address is declared as immutable but holds a fixed, compile-time known value (the zero address for native ETH). It should be declared as constant instead.\nThe cause is misuse of language features\u2014immutable is intended for values set at construction time, while constant is for compile-time constants.\nThis leads to unnecessary storage allocation and higher deployment gas costs, as immutable variables are stored in code rather than being inlined.\nThe impact is inefficient bytecode and slightly higher deployment cost, though runtime gas is unaffected.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::ETH#56"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1110"
                ]
            },
            "title": "Misleading documentation",
            "description": "The documentation for the prevToken parameter in deleteConfig does not clarify that it is part of a linked list structure, only stating it is the \"token stored before\" without explaining its role in pointer-based deletion.\nThe cause is incomplete or ambiguous inline documentation.\nDevelopers or auditors may misunderstand the internal data structure, leading to incorrect assumptions about how deletions work, especially in edge cases like head or tail removal.\nThis increases the risk of introducing bugs during future maintenance or integration, as the actual implementation logic (linked list) is not clearly reflected in the comments.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::deleteConfig"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-664"
                ]
            },
            "title": "Unnecessary external call",
            "description": "The getAllConfigs function calls this.getTokens() externally instead of accessing the internal tokens mapping directly, forcing an internal transaction.\nThe cause is inefficient design\u2014using an external call to the same contract when direct state access is possible and cheaper.\nThis pattern results in higher gas consumption due to the overhead of external function calls, including ABI encoding and EVM call frame setup.\nThe impact is increased transaction costs for users calling getAllConfigs, with no functional benefit over direct internal access.\n",
            "severity": "Informational",
            "location": [
                "FluidkeyEarnModule.sol::getAllConfigs",
                "FluidkeyEarnModule.sol::getTokens"
            ],
            "files": [
                "fluidkey-earn-module/src/FluidkeyEarnModule.sol"
            ]
        }
    ]
}