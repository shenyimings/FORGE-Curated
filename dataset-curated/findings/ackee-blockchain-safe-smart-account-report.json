{
    "path": "dataset-curated/reports/Ackee-Blockchain/ackee-blockchain-safe-smart-account-report.pdf",
    "project_info": {
        "url": [
            "https://github.com/safe-global/safe-smart-account"
        ],
        "commit_id": [
            "b115c4c5fe23dca6aefeeccc73d312ddd23322c2"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-04-14",
        "project_path": {
            "safe-smart-account": "dataset-curated/contracts/ackee-blockchain-safe-smart-account-report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Front-running attack can bypass callback execution during Safe deployment",
            "description": "The createProxyWithCallback function in SafeProxyFactory.sol is vulnerable to a front-running attack because it uses a predictable salt derivation that can be replicated by the createProxyWithNonce function. The root cause is the shared use of a nonce value derived from user inputs, which allows an attacker to calculate the deployment address in advance. An attacker can observe a victim's transaction in the mempool, compute the same salt nonce, and call createProxyWithNonce before the victim's transaction is confirmed. This results in the attacker deploying the proxy at the intended address, causing the victim's transaction to fail while the critical callback\u2014intended to initialize security parameters or other setup logic\u2014is never executed. The impact is medium, as it can lead to a partially initialized or insecure Safe instance, potentially compromising the intended security model.\n",
            "severity": "Medium",
            "location": [
                "SafeProxyFactory.sol::createProxyWithCallback#109-110"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxyFactory.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "CompatibilityFallbackHandler does not provide full compatibility",
            "description": "The CompatibilityFallbackHandler contract fails to implement the encodeTransactionData function, which is expected by older integrations with previous versions of the Safe contract. This omission breaks backward compatibility for read-only operations that depend on this function. The root cause is an incomplete implementation of legacy interface support in the fallback handler. An attacker or malicious actor is not required for exploitation; instead, any legitimate integration relying on encodeTransactionData will fail when interacting with a Safe using this handler. This leads to a loss of interoperability and potential disruption in dApps or tooling expecting full backward compatibility. The impact is low because it does not lead to fund loss or direct security compromise, but it affects system usability and integration reliability.\n",
            "severity": "Low",
            "location": [
                "CompatibilityFallbackHandler.sol"
            ],
            "files": [
                "safe-smart-account/contracts/handler/CompatibilityFallbackHandler.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Strict calldata check on masterCopy call",
            "description": "The fallback function in SafeProxy.sol performs an overly strict comparison of the full 32-byte calldata when checking for the masterCopy() function selector. Instead of masking the first 4 bytes (the function selector), it compares the entire 32-byte word, which includes potential appended data. The root cause is incorrect handling of function selector matching, deviating from Solidity's standard delegation behavior where extra calldata is ignored. An attacker or user can craft a call to masterCopy() with additional trailing bytes (e.g., 0xa619486e0a), which the proxy will not recognize and will delegate to the singleton, potentially leading to incorrect return values or unexpected behavior if a fallback handler processes the call. The impact is low, as it does not enable arbitrary code execution but may result in incorrect state reads or confusion in client applications.\n",
            "severity": "Low",
            "location": [
                "SafeProxy.sol::fallback#41"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxy.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Misleading event emissions",
            "description": "The _setSafeMethod function in ExtensibleBase.sol and the setDomainVerifier function in SignatureVerifierMuxer.sol emit events even when no actual state change occurs. Specifically, AddedSafeMethod and AddedDomainVerifier events are emitted when both old and new values are zero, and ChangedSafeMethod/ChangedDomainVerifier events are emitted when old and new values are identical. The root cause is the lack of value comparison before event emission. This can mislead off-chain indexers and monitoring tools into believing that a change has occurred when none has, potentially causing incorrect state reconstruction or false alerts. The impact is classified as Warning because it does not directly affect on-chain security but undermines the reliability of event-based tracking systems, which are critical for wallet and service integrations.\n",
            "severity": "Informational",
            "location": [
                "ExtensibleBase.sol::_setSafeMethod",
                "SignatureVerifierMuxer.sol::setDomainVerifier"
            ],
            "files": [
                "safe-smart-account/contracts/handler/extensible/ExtensibleBase.sol",
                "safe-smart-account/contracts/handler/extensible/SignatureVerifierMuxer.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Use of precomputed msg.data",
            "description": "The SafeToL2Migration contract precomputes function call data using hardcoded selectors instead of using the actual msg.data. This is done to emit a consistent SafeMultiSigTransaction event during migration. The root cause is the assumption that migration functions are always called directly with no additional calldata. If a user calls the migration function with extra data (e.g., via a relayer or batch executor), the emitted event will reflect the precomputed data rather than the actual transaction data, leading to a mismatch between signed data and recorded data. This can confuse transaction indexing services and lead to incorrect transaction reconstruction. The impact is Warning because it affects data integrity for indexing but does not compromise fund safety or access control.\n",
            "severity": "Informational",
            "location": [
                "SafeToL2Migration.sol::migrateToL2",
                "SafeToL2Migration.sol::migrateFromV111"
            ],
            "files": []
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-188"
                ]
            },
            "title": "Scratch space assumed zeroed out",
            "description": "The SafeProxy contract's fallback function uses inline assembly to store the singleton address shifted by 96 bits into memory at offset 0x0c, assuming the first 12 bytes of memory (scratch space) are zeroed out. However, the Solidity compiler does not guarantee that scratch space is initialized to zero, even in the absence of preceding code, which could lead to incorrect ABI encoding of the address if prior operations have left garbage data in memory. This behavior relies on an unsafe assumption about the EVM memory state. Although the impact is limited to a specific internal operation and does not directly enable fund loss or access control breaches, it introduces a potential inconsistency in return data encoding under certain compiler behaviors or future changes. The impact is a warning-level issue due to the reliance on an undocumented and potentially unsafe memory assumption.\n",
            "severity": "Informational",
            "location": [
                "SafeProxy.sol::fallback#43-50"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxy.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Safe setup may emit outdated information",
            "description": "The Safe.setup function emits the SafeSetup event after calling setupModules, which performs an arbitrary delegatecall that may modify the contract's state. However, the event uses local variables (_owners, _threshold, etc.) that were captured before the delegatecall, meaning the emitted event data may not reflect the actual final state of the contract after module initialization. This discrepancy can mislead off-chain indexing services or monitoring tools that rely on event data for state reconstruction. The root cause is the incorrect ordering of event emission relative to state-modifying external calls. An attacker or malicious module could exploit this by manipulating state post-event to create a divergence between observed and actual state. The impact is a warning due to potential data inconsistency in event logs, though it does not directly compromise fund safety or access control.\n",
            "severity": "Informational",
            "location": [
                "Safe.sol::setup#98-105"
            ],
            "files": [
                "safe-smart-account/contracts/Safe.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "onlyNonceZero check can be bypassed",
            "description": "The onlyNonceZero modifier in SafeToL2Migration.sol checks that the nonce equals 1, assuming this indicates no transactions have been executed (since nonce starts at 0 and increments before execution). However, this check can be bypassed if a transaction is executed via a module, as module calls do not increment the nonce. This allows a Safe with prior transaction history to appear as if it has a zero transaction count, potentially violating backend assumptions for L2 migration. The root cause is a flawed logic assumption that nonce == 1 always implies no prior execution, without accounting for module-based transactions. An attacker could exploit this by executing a transaction through a module and then migrating the Safe to L2, circumventing the intended restriction. The impact is a warning due to potential state inconsistency in migration logic, though the backend may have mitigations.\n",
            "severity": "Informational",
            "location": [
                "SafeToL2Migration.sol::onlyNonceZero#64-68"
            ],
            "files": [
                "safe-smart-account/contracts/libraries/SafeToL2Migration.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-346"
                ],
                "3": [
                    "CWE-940"
                ]
            },
            "title": "Locked tokens possibility",
            "description": "The TokenCallbackHandler contract does not validate that its functions are only called as fallbacks from a Safe contract. As a result, if users directly send ERC-721 or ERC-1155 tokens to the contract address, those tokens become permanently locked because the contract lacks withdrawal functionality. The root cause is the absence of a sender validation check (e.g., ensuring msg.sender is a contract with specific storage layout). This creates a risk of irreversible fund loss for users who mistakenly send tokens directly. An attacker could not directly exploit this for gain, but users may lose assets due to this configuration oversight. The impact is a warning due to the potential for user fund loss through accidental interactions.\n",
            "severity": "Informational",
            "location": [
                "TokenCallbackHandler.sol"
            ],
            "files": [
                "safe-smart-account/contracts/handler/TokenCallbackHandler.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "ProxyCreationL2 nonce value is not user given argument",
            "description": "The SafeProxyFactory.createProxyWithCallbackL2 function emits the ProxyCreationL2 event, but the saltNonce value included in the event reflects an internal salt computation rather than the user-provided nonce. This misleads users and indexing services about the actual input parameters used for proxy creation. The root cause is the reuse of an internal function (createProxyWithNonceL2) that transforms the user input, without correctly reflecting the original value in the event. This creates a discrepancy between on-chain logs and user intent, potentially affecting replayability or auditability of deployments. The impact is a warning due to incorrect event data, which could affect tooling that relies on accurate event parameters for reconstruction or verification.\n",
            "severity": "Informational",
            "location": [
                "SafeProxyFactory.sol::createProxyWithCallbackL2"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxyFactory.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Documentation issues",
            "description": "Multiple contracts contain inaccurate or misleading documentation. In FallbackManager.sol, the comment claims the function returns 0 when no handler is set, but it actually returns empty bytes. In SignatureVerifierMuxer.sol, byte offset comments use hexadecimal prefixes for decimal values, leading to incorrect position descriptions. In MultiSendCallOnly.sol, a comment contains a typo (\"it right\" instead of \"right\"). Additionally, the changelog incorrectly attributes a function implementation to CompatibilityFallbackHandler when it is in the Safe contract. The root cause is inconsistent documentation practices and lack of review. These inaccuracies can mislead developers and auditors, increasing the risk of incorrect assumptions during integration or maintenance. The impact is informational, as these do not introduce direct security risks but affect code clarity and maintainability.\n",
            "severity": "Informational",
            "location": [
                "FallbackManager.sol",
                "SignatureVerifierMuxer.sol::isValidSignature",
                "MultiSendCallOnly.sol::multiSend",
                "MultiSend.sol::multiSend"
            ],
            "files": [
                "safe-smart-account/contracts/base/FallbackManager.sol",
                "safe-smart-account/contracts/handler/extensible/SignatureVerifierMuxer.sol",
                "safe-smart-account/contracts/libraries/MultiSendCallOnly.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary typecasts to payable",
            "description": "The codebase performs unnecessary typecasts to payable when casting addresses to the ISafe interface, such as ISafe(payable(msg.sender)). These casts are redundant because the ISafe interface does not require payable addressing, and the conversion adds no functional benefit. The root cause is a misunderstanding of Solidity's type system and interface casting rules. While this does not introduce a security vulnerability, it reduces code clarity and may confuse developers about the intended usage. The impact is informational, as it pertains to code quality rather than security. The issue was later resolved by introducing an inheritance relationship that made the casts semantically meaningful.\n",
            "severity": "Informational",
            "location": [
                "**/*.sol"
            ],
            "files": [
                "safe-smart-account/contracts/interfaces/ISafe.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Code optimizations",
            "description": "Several functions contain suboptimal code patterns that could be improved for readability or gas efficiency. In ModuleManager.sol, a require statement could be replaced with a revert pattern for better error handling. In ERC165Handler.sol, loops use conditional checks (i > 0) before XOR operations, which are unnecessary because XOR with zero is idempotent. Removing these conditions would simplify the code without increasing gas costs. The root cause is a lack of optimization during implementation. The impact is informational, as these are code quality improvements rather than security fixes. The recommendations were implemented post-audit.\n",
            "severity": "Informational",
            "location": [
                "ModuleManager.sol::preModuleExecution#104",
                "ERC165Handler.sol::addSupportedInterfaceBatch#57-67",
                "ERC165Handler.sol::removeSupportedInterfaceBatch#80-89"
            ],
            "files": [
                "safe-smart-account/contracts/base/ModuleManager.sol",
                "safe-smart-account/contracts/handler/extensible/ERC165Handler.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-392"
                ]
            },
            "title": "Factory initializer error not propagated",
            "description": "In SafeProxyFactory.sol, when deploying a proxy with an initializer call, the inline assembly reverts with (0, 0) if the call fails, discarding the original revert reason from the initializer. This prevents users from diagnosing why a deployment failed, reducing debuggability and user experience. The root cause is the use of low-level call without error data forwarding. An attacker cannot exploit this directly, but legitimate users may struggle to understand deployment failures. The impact is informational, as it affects usability rather than security. The issue was resolved by propagating the revert data.\n",
            "severity": "Informational",
            "location": [
                "SafeProxyFactory.sol::deployProxy#42-45"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxyFactory.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "No view function for FallbackManager handler address",
            "description": "Unlike other manager contracts (GuardManager, ModuleManager, OwnerManager), FallbackManager.sol does not provide a public view function to read the stored fallback handler address. This breaks consistency in the codebase and forces external callers to use alternative methods (e.g., StorageAccessible interface) to access this data. The root cause is an omission in interface design. While the value can still be accessed, the lack of a dedicated getter reduces usability and developer experience. The impact is informational. The client acknowledged the finding but chose not to implement a fix, citing implementation complexity and alternative access methods.\n",
            "severity": "Informational",
            "location": [
                "FallbackManager.sol"
            ],
            "files": [
                "safe-smart-account/contracts/base/FallbackManager.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "SafeStorage can be defined as abstract",
            "description": "The SafeStorage contract is intended to be used as a base contract for storage layout sharing but is not marked as abstract. Marking it as abstract would better reflect its design intent and prevent accidental instantiation. The root cause is a missing language feature usage for design clarity. This has no security impact but affects code semantics and developer understanding. The impact is informational. The issue was fixed post-audit by marking SafeStorage (and SignatureValidatorConstants) as abstract.\n",
            "severity": "Informational",
            "location": [
                "SafeStorage.sol"
            ],
            "files": [
                "safe-smart-account/contracts/libraries/SafeStorage.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing L2-specific variant of createChainSpecificProxyWithNonce",
            "description": "The SafeProxyFactory contract provides L2-specific variants of most deployment functions to emit additional events for L2 indexing, but lacks an L2 variant for createChainSpecificProxyWithNonce. This inconsistency means deployments using this function on L2 networks do not emit the expected ChainSpecificProxyCreationL2 event, potentially breaking indexing tools. The root cause is an incomplete implementation of the L2 deployment pattern. The impact is informational, related to event completeness. The issue was resolved by adding the missing createChainSpecificProxyWithNonceL2 function.\n",
            "severity": "Informational",
            "location": [
                "SafeProxyFactory.sol"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxyFactory.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Interface type used for parameter that accepts zero address",
            "description": "In SafeProxyFactory.sol, the createProxyWithCallback function accepts a callback parameter of interface type, but explicitly checks for address(callback) != address(0), indicating that the zero address is a valid input. Using an interface type in this context is semantically incorrect, as interfaces imply a contract implementation. The address type should be used instead to accurately reflect that zero is a valid sentinel value. The root cause is a type system misuse for special-case handling. The impact is informational, affecting code clarity. The function was later removed as part of another fix (M1).\n",
            "severity": "Informational",
            "location": [
                "SafeProxyFactory.sol::createProxyWithCallback"
            ],
            "files": [
                "safe-smart-account/contracts/proxies/SafeProxyFactory.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "ChangedThreshold event is emitted unconditionally",
            "description": "The OwnerManager.changeThreshold function emits the ChangedThreshold event even when the new threshold value is the same as the current one. This can mislead off-chain services into thinking a state change occurred when it did not. The root cause is the lack of a value comparison before event emission. While consistent with other events in the codebase, it reduces event reliability. The impact is informational. The client acknowledged the finding but chose not to fix it, citing low value and consistency with existing patterns.\n",
            "severity": "Informational",
            "location": [
                "OwnerManager.sol::changeThreshold#110-114"
            ],
            "files": [
                "safe-smart-account/contracts/base/OwnerManager.sol"
            ]
        }
    ]
}