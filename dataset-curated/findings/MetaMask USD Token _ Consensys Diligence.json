{
    "path": "dataset-curated/reports/Consensys_Diligence/MetaMask USD Token _ Consensys Diligence.md",
    "project_info": {
        "url": [
            "https://github.com/m0-foundation/mUSD"
        ],
        "commit_id": [
            "b62fab7c3e867b700bd81dad2ab140e074d98f32"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-08-11",
        "project_path": {
            "mUSD": "dataset-curated/contracts/MetaMask USD Token _ Consensys Diligence.md-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Consider Allowing `approve` Even When Contract Is Paused",
            "description": "The `MUSD` contract inherits from OpenZeppelin\u2019s `PausableUpgradeable` and blocks `approve` calls during a paused state via the `_beforeApprove` hook. This behavior differs from standard OpenZeppelin pausable ERC-20 contracts, where `approve` is allowed even when paused. The root cause is the explicit inclusion of `_requireNotPaused()` in the `_beforeApprove` hook. This restriction prevents users from revoking approvals during emergency pauses, which could be security-critical\u2014for example, during an ongoing exploit. An attacker could potentially exploit standing approvals if users are unable to revoke them during a pause. The impact is limited because the contract is pausable by design and administrative controls exist, but it reduces user autonomy in securing their own funds.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::_beforeApprove#101-111"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 1,
            "category": {},
            "title": "Consider Making Forced Transfers Revert for Zero Amount",
            "description": "The `_forceTransfer` function in the `MUSD` contract allows zero-amount forced transfers to succeed, emitting a `ForcedTransfer` event. While this mimics standard ERC-20 behavior for zero-value transfers (which must emit `Transfer`), forced transfers are exceptional administrative actions that move funds from frozen accounts without owner consent. The root cause is the early return when `amount == 0` without reverting. This could lead to misuse or confusion, as a zero-amount forced transfer may indicate a user error or an attempt to test permissions without effect. Although no funds are moved, the event emission could be misleading or abused for log spam. The impact is low, as no economic loss occurs, but it may affect monitoring and incident response systems.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::_forceTransfer#166-178"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 2,
            "category": {},
            "title": "Version Mismatch for `evm-m-extensions` in `mUSD`",
            "description": "The `MUSD` contract depends on the `evm-m-extensions` repository, but the version used in the project (submodule at `90f144de...`) is behind the revision (`011f84f0...`) that was intended for audit. This discrepancy means that the audited logic may not fully reflect the actual deployed or intended behavior, especially since `MUSD` inherits functionality from `evm-m-extensions`. The root cause is a misalignment in submodule versioning, possibly due to deployment or configuration drift. While the audit scope did not include `evm-m-extensions`, this mismatch introduces uncertainty about the correctness and security of inherited behaviors. The impact is informational, but it could mask vulnerabilities in the actual deployed codebase if the older version contains unpatched issues.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 3,
            "category": {},
            "title": "ERC-20 Token Name Not Correct",
            "description": "The ERC-20 token name in the `MUSD` contract is hardcoded as \"MUSD\", but according to the MetaMask team, it should be \"MetaMask USD\". This discrepancy occurs in the initialization of the `MYieldToOne` base contract. The root cause is a mismatch between product branding and on-chain implementation. While this does not introduce a security vulnerability, it affects user experience and trust, as wallet interfaces and exchanges will display the incorrect name. There is no exploitation vector, but it could lead to confusion or reduced confidence in the token's legitimacy. The impact is purely reputational and branding-related.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::initialize#56"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 4,
            "category": {},
            "title": "Cumulative Hooks Should Always Call Their `super`, Even if Currently Empty",
            "description": "The `_beforeClaimYield` hook in `MUSD` overrides a base function but does not call `super._beforeClaimYield()`. Although the base implementation is currently empty and has no functional impact, this pattern violates best practices for cumulative hooks in inheritance hierarchies. The root cause is an omission in the override implementation. If future updates add logic to the base hook, the `MUSD` contract will fail to execute it, potentially bypassing critical checks. This could lead to security gaps if, for example, access control or validation logic is later added to the parent hook. The impact is low in the current state but introduces technical debt and future risk.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::_beforeClaimYield#148-152"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 5,
            "category": {},
            "title": "Several Public Functions Could Be External",
            "description": "The `initialize`, `pause`, and `unpause` functions in `MUSD` are declared as `public` but are never called internally. The root cause is suboptimal function visibility selection. Declaring them as `external` would reduce gas costs for external callers and clarify intent, as these functions are only meant to be called externally. There is no security risk, but it represents a code quality issue. The impact is minimal, limited to inefficiency and slightly higher gas usage, but it does not affect correctness or security.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::initialize#45-52",
                "src/MUSD.sol::MUSD::pause#66",
                "src/MUSD.sol::MUSD::unpause#71"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 6,
            "category": {},
            "title": "initialize Function Should Probably Not Be Virtual",
            "description": "The `initialize` function in `MUSD` is marked as `virtual`, suggesting it can be overridden in derived contracts. However, no other functions in the contract are virtual, and the design does not appear to support inheritance. The root cause is inconsistent design signaling. If the contract is not intended to be inherited, marking `initialize` as `virtual` may mislead developers into thinking extension is supported. This could lead to unsafe inheritance patterns or confusion during code review. The impact is low, as no actual vulnerability exists, but it affects code maintainability and clarity.\n",
            "severity": "Low",
            "location": [
                "src/MUSD.sol::MUSD::initialize#45-52"
            ],
            "files": [
                "mUSD/src/MUSD.sol"
            ]
        },
        {
            "id": 7,
            "category": {},
            "title": "Inconsistent Order of Functions in Interface and Contract",
            "description": "The `IMUSD` interface defines `forceTransfers` before `forceTransfer`, while the `MUSD` contract implements `forceTransfer` first. This inconsistency does not affect functionality but reduces code readability and maintainability. The root cause is a lack of alignment in source code organization. While Solidity does not require interface and contract function order to match, consistent ordering improves developer experience and reduces the risk of integration errors. The impact is purely code quality and does not pose any security risk.\n",
            "severity": "Low",
            "location": [
                "src/IMUSD.sol::IMUSD::forceTransfers#51-71",
                "src/MUSD.sol::MUSD::forceTransfer#75-97"
            ],
            "files": [
                "mUSD/src/MUSD.sol",
                "mUSD/src/IMUSD.sol"
            ]
        }
    ]
}