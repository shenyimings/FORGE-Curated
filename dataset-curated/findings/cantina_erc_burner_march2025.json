{
    "path": "dataset-curated/reports/Cantina/cantina_erc_burner_march2025.pdf",
    "project_info": {
        "url": [
            "https://github.com/ercburnerdev/ercburner-audit"
        ],
        "commit_id": [
            "67614a439eda2135e3a81a6c766a580660768b93"
        ],
        "address": [
            null
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2023-03-22",
        "project_path": {
            "ercburner-audit": "dataset-curated/contracts/cantina_erc_burner_march2025.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "Swap execution can completely fail in some cases when tokens like BNB are involved",
            "description": "The swapExactInputMultiple() function in URBurner.sol uses OpenZeppelin's safeDecreaseAllowance() to handle failed swaps, which internally calls approve(0) before setting a new allowance. This behavior causes a revert when interacting with certain tokens like BNB, which explicitly revert on approve(0) calls. The root cause is the reliance on a library function that assumes all ERC20 tokens allow resetting approval to zero, which is not universally true. An attacker could potentially trigger this failure by initiating a swap with a BNB-like token, causing the entire transaction to revert even if the user intended a simple fallback. This leads to a denial of service for users attempting to use such tokens, resulting in failed transactions and potential loss of gas fees.\n",
            "severity": "Medium",
            "location": [
                "URBurner.sol::swapExactInputMultiple#291-301"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Bridge refunds could be lost if URBurner is not deployed at the same address on all supported chains",
            "description": "The ERCBurner protocol uses a relay bridge to transfer ETH across chains, but does not validate bridgeData in swapExactInputMultiple() or relayBridge(). In cases where both refundTo and recipient are unspecified, the refund is sent to the originating contract address on the destination chain. If URBurner is not deployed at the same address on all chains, the refund will be sent to an uncontrolled address, resulting in permanent loss of funds. The cause is the lack of address consistency validation across chains and reliance on the contract address as a refund destination. An attacker cannot directly exploit this, but users are at risk whenever bridging fails and refunds are issued to a non-existent or unowned address. The impact is loss of user funds in the event of a bridge failure when deployment addresses differ.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol",
                "ercburner-audit/contracts/burner/AVAXBurner.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ],
                "4": [
                    "CWE-638"
                ],
                "5": [
                    "CWE-424"
                ]
            },
            "title": "relayBridge() does not check if bridging functionality has been paused",
            "description": "The relayBridge() function allows users to bridge ETH directly without performing a swap, but it lacks a check for the pauseBridge boolean, unlike swapExactInputMultiple(). This omission means that even when bridging is paused by the admin, users can still call relayBridge() to initiate a bridge, bypassing the intended pause mechanism. The root cause is inconsistent access control logic between two similar functions. An attacker or user could exploit this to continue using bridging functionality during a maintenance or emergency pause, potentially leading to unintended fund movements or exposure during a vulnerable state. The impact includes circumvention of admin controls and potential loss of funds if bridging is paused due to a security issue.\n",
            "severity": "Low",
            "location": [
                "AVAXBurner.sol::relayBridge#345-354",
                "URBurner.sol::relayBridge#362-370"
            ],
            "files": [
                "ercburner-audit/contracts/burner/AVAXBurner.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Users can lose funds if they swap to tokens other than WNATIVE via ERCBurner",
            "description": "The swapExactInputMultiple() function assumes that all swaps will result in WNATIVE, which is then unwrapped to native currency. However, if a user encodes a swap path that outputs a token other than WNATIVE, the contract will receive the output tokens but has no mechanism to return them to the user. The cause is the lack of validation that the final output token is WNATIVE. An attacker could craft a malicious swap path to trick users into sending tokens to the contract, or a user could accidentally do so, resulting in permanent loss of those funds. The impact is direct financial loss for users who specify incorrect swap paths.\n",
            "severity": "Low",
            "location": [
                "URBurner.sol::swapExactInputMultiple#279-290"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-266"
                ]
            },
            "title": "DEFAULT_ADMIN_ROLE needs to be re-assigned properly when transferring ownership",
            "description": "The URBurner contract assigns DEFAULT_ADMIN_ROLE to the initial owner, but does not update this role when ownership is transferred. If the previous owner's address is burned or becomes inaccessible, the role may be lost, and the new owner may not automatically receive it. The cause is the failure to override transferOwnership() to manage role assignment. This could lead to a situation where no address has administrative privileges, resulting in governance paralysis. The impact is potential loss of upgradability and administrative control, especially critical in an upgradeable contract system.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Users could lose referral registration fees if they register after referrals are paused",
            "description": "The paidReferrer() and upgradeReferrer() functions do not check the pauseReferral boolean, allowing users to register or upgrade as referrers even when the referral system is paused. While no fees are distributed when paused, users still pay registration fees, which are effectively lost. The cause is missing the whenNotPaused modifier on these functions. An attacker could exploit this by encouraging users to register during a paused state, leading to financial loss. The impact is loss of user funds paid as fees with no return of value.\n",
            "severity": "Low",
            "location": [
                "URBurner.sol::paidReferrer#393-396",
                "URBurner.sol::upgradeReferrer#424-427"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Bridging fee is incorrectly charged in swapExactInputMultiple() when bridge boolean is set to false",
            "description": "In swapExactInputMultiple(), a bridging fee is charged even when the bridge parameter is set to false, as long as a recipient address is provided. This is incorrect because bridging is not occurring; instead, the native currency is being sent directly. The cause is flawed fee logic that does not properly distinguish between bridging and simple transfers. An attacker could exploit this by setting bridge=false and specifying a recipient to extract fees without using the bridge. The impact is overcharging users for functionality they are not using, leading to unnecessary loss of funds.\n",
            "severity": "Low",
            "location": [
                "URBurner.sol::swapExactInputMultiple#322-327"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Remove nonReentrant from functions that have no external calls",
            "description": "Some functions in the contract are marked with the nonReentrant modifier despite not making any external calls that could trigger reentrancy. The use of this modifier adds unnecessary gas overhead. The cause is over-application of reentrancy guards without analyzing the function's call graph. While not directly exploitable, this represents inefficient code. An attacker could potentially exploit the increased gas cost to make transactions fail due to out-of-gas errors, though this is unlikely. The impact is higher transaction costs for users, reducing efficiency and increasing fees.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Prefer explicit calls over arbitrary calldata",
            "description": "The contract uses low-level calls with arbitrary calldata to forward bridge data, increasing the attack surface. Instead, it should validate the function selector before forwarding. The cause is the use of unsafe patterns that allow execution of unintended functions on the target contract. An attacker could craft malicious calldata to invoke unintended functions on the bridge contract, potentially leading to fund loss or unintended state changes. The impact is increased risk of remote code execution on the receiving contract due to insufficient input validation.\n",
            "severity": "Informational",
            "location": [
                "URBurner.sol#344"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "paidReferrer() and upgradeReferrer() should have whenNotPaused modifier",
            "description": "The paidReferrer() and upgradeReferrer() functions lack the whenNotPaused modifier, which is present on similar administrative functions. This inconsistency could lead to confusion and unintended behavior during system pauses. The cause is incomplete application of pause controls across all relevant functions. While already mentioned in finding 3.2.4, this is a separate informational note emphasizing consistency. The impact is reduced code clarity and potential for future vulnerabilities if pause logic is expanded without updating these functions.\n",
            "severity": "Informational",
            "location": [
                "URBurner.sol::paidReferrer#393-396",
                "URBurner.sol::upgradeReferrer#424-427"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Swap deadlines in current logic are not useful",
            "description": "The swapExactInputMultiple() function uses block.timestamp + 900 as the deadline for all swaps, which is evaluated at the destination chain for cross-chain swaps. This makes the deadline ineffective because the block timestamp differs across chains. The cause is using a relative timestamp that does not account for cross-chain execution delays. An attacker could exploit this by delaying transaction inclusion on the destination chain, rendering the deadline meaningless and enabling stale price execution. The impact is potential loss of funds due to outdated swap rates being used.\n",
            "severity": "Informational",
            "location": [
                "URBurner.sol#237"
            ],
            "files": [
                "ercburner-audit/contracts/burner/URBurner.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Suggestions to improve code readability",
            "description": "Several code readability issues were identified: setUniversalRouter() should be renamed to setLBRouter() for accuracy, error messages like ReferrerCannotBeSelf() are misleading, and the contract description should clarify support for native currency instead of ETH. The cause is imprecise naming and documentation. While not a security risk, this reduces code maintainability and increases the chance of developer error. The impact is higher cognitive load for auditors and developers, potentially leading to misinterpretation and bugs in future updates.\n",
            "severity": "Informational",
            "location": [
                "AVAXBurner.sol#558",
                "URBurner.sol#31",
                "URBurner.sol#192"
            ],
            "files": [
                "ercburner-audit/contracts/burner/AVAXBurner.sol"
            ]
        }
    ]
}