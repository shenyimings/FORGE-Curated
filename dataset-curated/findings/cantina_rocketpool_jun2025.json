{
    "path": "dataset-curated/reports/Cantina/cantina_rocketpool_jun2025.pdf",
    "project_info": {
        "url": "https://github.com/rocket-pool/rocketpool",
        "commit_id": "56ea8976a5ccafb553b0eb613bd62fd19a8d5aa8",
        "address": "n/a",
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2023-07-27",
        "project_path": {
            "rocketpool": "dataset-curated/contracts/cantina_rocketpool_jun2025.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Malicious node operators can add validators with reused pubkeys to drain user capital",
            "description": "The vulnerability allows malicious node operators to add new validators using public keys (pubkeys) that are already associated with staking validators. This occurs because the protocol does not enforce global uniqueness of validator pubkeys when adding new validators via RocketNodeDeposit.sol.\n\nThe root cause is the absence of a check to ensure that a validator's pubkey is unique across all protocol megapools before registration. As a result, a malicious node operator can reuse a pubkey from an already staking validator when depositing additional funds.\n\nAn attacker can exploit this by depositing additional ETH toward a validator they already control using a reused pubkey. When the validator's actual balance exceeds the MAX_EFFECTIVE_BALANCE of 32 ETH on the beacon chain, the excess is treated as rewards and periodically skimmed via partial withdrawals to the validator\u2019s withdrawal credentials, which are controlled by the node operator.\n\nThe impact is a direct loss of user deposit pool capital, as the skimmed amounts are effectively stolen from the protocol. This can be repeated across multiple validators, leading to a significant drain of funds and potentially causing a depeg of rETH.\n",
            "severity": "Critical",
            "location": [
                "RocketNodeDeposit.sol::deposit#184-185",
                "RocketNodeDeposit.sol::depositMulti#223-224"
            ],
            "files": [
                "rocketpool/contracts/contract/node/RocketNodeDeposit.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Linked list data structure in LinkedListStorage can be corrupted",
            "description": "The vulnerability exists in the LinkedListStorage._dequeueItem() function, where certain storage variables are not properly cleared when removing the first item from the queue. Specifically, namespace.next and namespace.item are not reset, even though they should be to prevent stale data from being misinterpreted.\n\nThe root cause is incomplete cleanup of storage slots during dequeue operations. While namespace.prev is correctly left as zero for the first item, namespace.next is not cleared, and namespace.item remains set. This is problematic because _enqueueItem() does not always set .next for new items, especially when the queue is empty.\n\nAn attacker can manipulate the dangling next pointer to corrupt the internal state of the linked list. For example, by crafting a scenario where a dequeued item's next pointer still points to a previous location, subsequent calls to peekItem() may return incorrect values. Additionally, since namespace.item is not cleared, functions like getItem() and scan() can return items that have already been removed.\n\nThe impact is corruption of critical data structures, leading to incorrect behavior in any contract relying on this linked list for state management, potentially resulting in loss of funds or denial of service.\n",
            "severity": "Critical",
            "location": [
                "LinkedListStorage.sol::_dequeueItem#134-164",
                "LinkedListStorage.sol::_removeItem#95-102"
            ],
            "files": [
                "rocketpool/contracts/contract/util/LinkedListStorage.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Implementation of EIP-7782 changing assumed block time of 12 seconds will cause protocol-wide issues",
            "description": "The protocol assumes a fixed block time of 12 seconds across multiple contracts, which will cause widespread malfunctions if Ethereum reduces block times to 6 seconds as proposed in EIP-7782.\n\nThe root cause is the hardcoding of secondsPerSlot = 12 in various time-calculation functions throughout the codebase, instead of using a dynamic or configurable value. This assumption is embedded in critical logic such as withdrawal timing, epoch calculations, penalty periods, and proposal age limits.\n\nAn attacker or systemic change (such as a network hard fork) that reduces block times would cause miscalculations in functions like notifyExit(), notifyFinalBalance(), and getCurrentEpoch(). For example, withdrawableTime and distributableTime would be miscalculated, leading to delayed or incorrect distributions. Additionally, getCurrentSlot() would return incorrect values, allowing malicious node operators to bypass exit challenges and steal funds.\n\nThe impact is protocol-wide functional degradation, including incorrect reward distribution, extended upgrade delays, improper penalty enforcement, and potential loss of user funds due to flawed exit challenge mechanisms.\n",
            "severity": "High",
            "location": [
                "RocketDAOProtocolSettingsAuction.sol#19",
                "RocketDAOProtocolSettingsAuction.sol#38-40",
                "RocketDAOProtocolSettingsAuction.sol#73-76",
                "RocketDAOProtocolSettingsProposals.sol#24",
                "RocketDAOProtocolSettingsProposals.sol#61-64",
                "RocketDAOProtocolSettingsProposals.sol#114-117",
                "RocketMegapoolDelegateBase.sol#13",
                "RocketMegapoolDelegate.sol#24",
                "RocketMegapoolDelegate.sol#401-406",
                "RocketMegapoolDelegate.sol#510",
                "RocketMegapoolDelegate.sol#523",
                "RocketMegapoolDelegate.sol#561-564",
                "RocketMegapoolDelegate.sol#587-588",
                "RocketMegapoolDelegate.sol#690-696",
                "RocketMegapoolDelegate.sol#699-704",
                "RocketMegapoolPenalties.sol#15",
                "RocketMegapoolPenalties.sol#89-94",
                "RocketNetworkPenalties.sol#16",
                "RocketNetworkPenalties.sol#128-133",
                "BlockRoots.sol#19",
                "BlockRoots.sol#29-38"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsAuction.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect/repeated withdrawal from rocketSmoothingPool in executeRewardSnapshot() will lead to loss of ETH rewards",
            "description": "The vulnerability involves a redundant and incorrect withdrawal call in the _executeRewardSnapshot() function of RocketRewardsPool.sol, where ETH is withdrawn twice from the rocketSmoothingPool for the same reward distribution.\n\nThe root cause is a logic error where, after already withdrawing smoothingPoolETH into the contract, the function attempts to withdraw the same amount again directly to the relay. This second withdrawal is unnecessary and dangerous because it assumes the smoothing pool still has sufficient balance.\n\nAn attacker cannot directly exploit this, but the protocol itself will fail during reward distribution if the smoothing pool lacks sufficient balance, causing the entire transaction to revert. More likely, if the first withdrawal succeeds but the second is skipped due to logic flaws, ETH may become stuck in RocketRewardsPool.\n\nThe impact is a loss of ETH rewards for node operators who participate in the smoothing pool, as funds either get stuck or cause transaction reverts, disrupting the reward distribution process in every cycle.\n",
            "severity": "High",
            "location": [
                "RocketRewardsPool.sol::_executeRewardSnapshot#254-256",
                "RocketRewardsPool.sol::_executeRewardSnapshot#302-305"
            ],
            "files": [
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-665"
                ],
                "3": [
                    "CWE-909"
                ]
            },
            "title": "Missing contracts from the RocketUpgradeOneDotFour upgrade contract",
            "description": "The RocketUpgradeOneDotFour upgrade contract omits two critical contracts: RocketMinipoolManager (an existing contract needing upgrade) and RocketMegapoolPenalties (a new contract).\n\nThe root cause is an incomplete upgrade script that fails to register these contracts during the deployment process. This oversight means that state changes or new functionality intended for these contracts will not be properly initialized or linked.\n\nAn attacker could potentially exploit the missing upgrade of RocketMinipoolManager to operate under outdated logic, or the absence of RocketMegapoolPenalties could allow malicious node operators to avoid penalties. While not directly exploitable, the missing contracts introduce functional gaps.\n\nThe impact is incomplete protocol upgrades, leading to missing features, inconsistent state, and potential security risks due to unapplied logic or unenforced penalties.\n",
            "severity": "High",
            "location": [
                "RocketUpgradeOneDotFour.sol",
                "RocketMinipoolManager.sol",
                "RocketMegapoolPenalties.sol"
            ],
            "files": [
                "rocketpool/contracts/contract/upgrade/RocketUpgradeOneDotFour.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Allowing extra upper bits for indexes allows invalid proofs to pass in BeaconStateVerifier",
            "description": "The vulnerability stems from using uint256 for index parameters in BeaconStateVerifier functions when smaller types (uint40 and uint16) should be used, given the fixed sizes of the underlying data structures.\n\nThe root cause is improper type enforcement in pathBeaconStateToValidator() and pathBlockToWithdrawal(), where _validatorIndex and _withdrawalNum are declared as uint256 instead of being restricted to 40 and 4 bits respectively. This allows attackers to craft indices with extra upper bits that overflow into the gIndex calculation.\n\nAn attacker can manipulate the gIndex to point to unintended fields in the BeaconState, effectively forging invalid Merkle proofs. For example, by setting _validatorIndex > 2^40, the attacker can shift the path from the validators list to another field, bypassing validation checks.\n\nThe impact is the acceptance of invalid beacon chain state proofs, which could lead to incorrect reward distributions, false validator exits, or theft of user funds through fraudulent state transitions.\n",
            "severity": "High",
            "location": [
                "BeaconStateVerifier.sol::pathBeaconStateToValidator#125-129",
                "BeaconStateVerifier.sol::pathBlockToWithdrawal#147-153"
            ],
            "files": [
                "rocketpool/contracts/contract/util/BeaconStateVerifier.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing lower guardrail for reduced.bond may allow validators to stake with lower bond than expected",
            "description": "The protocol lacks a minimum guardrail for the reduced.bond setting, which determines the required ETH bond per validator for node operators staking more than two validators.\n\nThe root cause is the absence of input validation when updating the reduced.bond parameter via DAO governance. While RPIP-42 specifies a reduction from 4 ETH to 1.5 ETH, the system allows the pDAO to set this value to zero or any arbitrarily low amount.\n\nA malicious or compromised pDAO could set reduced.bond to zero, enabling node operators to stake with no bonded ETH. This allows them to earn commission rewards without financial skin in the game.\n\nThe impact includes increased risk of validator slashing and abandonment, 100% loan-to-value (LTV) staking, and erosion of protocol security, as node operators have no economic incentive to act honestly.\n",
            "severity": "Medium",
            "location": [
                "RocketDAOProtocolSettingsNode.sol#24",
                "RocketDAOProtocolSettingsNode.sol#31-44",
                "RocketMegapoolDelegate.sol#177",
                "RocketMegapoolDelegate.sol#251",
                "RocketMegapoolDelegate.sol#720",
                "RocketNodeDeposit.sol#38-53"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNode.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for upgradeveto.quorum and upgrade.delay can affect protocol upgrades",
            "description": "The protocol does not enforce guardrails on the upgradeveto.quorum and upgrade.delay parameters, allowing them to be set to arbitrary values by governance.\n\nThe root cause is the lack of validation in the DAO settings contracts, which permit pDAO to modify these values without bounds. According to RPIP-60, the intended values are 33% quorum and 1 week delay, but no technical constraints enforce this.\n\nA malicious pDAO could increase upgrade.delay to an extremely high value, effectively stalling any unwanted protocol upgrades indefinitely. Alternatively, reducing upgrade.delay to zero would allow immediate execution of upgrades without giving the Security Council time to review and veto malicious changes.\n\nThe impact is a compromise of the protocol's upgrade safety mechanisms, potentially leading to governance attacks, stalled improvements, or forced deployment of harmful changes.\n",
            "severity": "Medium",
            "location": [
                "RocketDAONodeTrustedUpgrade.sol#55-57",
                "RocketDAONodeTrustedUpgrade.sol#206-218",
                "RocketDAOProtocolSettingsSecurity.sol#21-22",
                "RocketDAOProtocolSettingsSecurity.sol#43-66"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedUpgrade.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Node Operator can perpetually lock a third-party depositor funds",
            "description": "A node operator can prevent third-party depositors from withdrawing their credit, effectively locking their funds indefinitely.\n\nThe root cause is access control in the withdrawCredit() function, which is restricted to onlyRegisteredNode(msg.sender), meaning only the node operator can initiate withdrawal. While third-party depositors can deposit ETH via depositEthFor(), they cannot reclaim their credit if the node operator refuses to call withdrawCredit().\n\nAn attacker (malicious or compromised node operator) can accept large deposits from a third party (e.g., a treasury), allow the ETH to be converted into credit via bonding, and then refuse to withdraw it. This breaks the expectation that depositors retain control over their funds.\n\nThe impact is permanent loss of funds for third-party depositors, particularly concerning for large institutional deposits, undermining trust in the protocol's custodial model.\n",
            "severity": "Medium",
            "location": [
                "RocketDepositPool.sol::depositEthFor#565",
                "RocketNodeDeposit.sol::withdrawCredit#107-118"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Mix-up between list and vector types in the SSZ library",
            "description": "The SSZ library incorrectly implements length handling for Merkleization, mixing up the behavior between lists and vectors.\n\nThe root cause is that intoVector() incorrectly increments length by one, while intoList() does not, contrary to the Ethereum consensus specification. According to the SSZ spec, lists must include their length in the Merkle root (mix_in_length), whereas vectors do not.\n\nThis leads to inconsistent and incorrect Merkle proofs in BeaconStateVerifier, where list types like validators and historical_summaries use intoVector(), and vector types like block_roots use intoList(). This mismatch causes verification failures or acceptance of invalid proofs.\n\nThe impact is potential consensus bugs in beacon chain state verification, leading to incorrect reward calculations, failed withdrawals, or security vulnerabilities in proof-of-stake operations.\n",
            "severity": "Low",
            "location": [
                "SSZ.sol::intoVector#27-35",
                "BeaconStateVerifier.sol::pathBeaconStateToValidator#127",
                "BeaconStateVerifier.sol::pathHistoricalSummaries#137",
                "BeaconStateVerifier.sol::pathBlockRoots#142",
                "BeaconStateVerifier.sol::pathBlockToWithdrawal#151"
            ],
            "files": [
                "rocketpool/contracts/contract/util/SSZ.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Use of incorrect/repeated ABIs will lead to integration errors",
            "description": "The RocketUpgradeOneDotFour contract reuses the same ABI (abis[23] and abis[24]) for multiple different contracts, including blockRoots, rocketNetworkPenalties, beaconStateVerifier, and rocketRewardsPool.\n\nThe root cause is improper assignment in the execute() function, where _addContract() and _upgradeContract() calls use duplicate ABI indices. This means integrators or external systems relying on these ABIs may receive incorrect interface definitions.\n\nAn attacker cannot directly exploit this, but third-party developers or frontends using the deployed contract ABIs may integrate with incorrect function signatures, leading to failed transactions or misinterpreted data.\n\nThe impact is integration errors, potential front-running, or incorrect state interpretation by external tools, reducing the reliability and security of the ecosystem.\n",
            "severity": "Low",
            "location": [
                "RocketUpgradeOneDotFour.sol::execute#118-141"
            ],
            "files": [
                "rocketpool/contracts/contract/upgrade/RocketUpgradeOneDotFour.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Missed exit challenges by oDAO will lead to loss of user capital",
            "description": "The protocol relies on the oDAO to challenge validator exits, but there is no mechanism to ensure these challenges are timely or enforced.\n\nThe root cause is the lack of automated or incentivized challenge mechanisms for validator exits. If the oDAO fails to act on an invalid exit notification, the protocol may incorrectly treat borrowed user capital as rewards.\n\nAn attacker could submit a fraudulent exit with an inflated balance, and if the oDAO does not challenge it within the window, the excess amount would be distributed as rewards instead of being returned to the deposit pool.\n\nThe impact is a loss of user capital due to unchallenged fraudulent exits, undermining the integrity of the staking pool and reward distribution system.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolManager.sol::challengeExit#132-147"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolManager.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Two compromised oDAO members could collude to temporarily prevent reward distributions",
            "description": "A malicious pair of oDAO members could collude to alternately call challengeExit() to lock up to 49 validators each time, preventing them from receiving rewards. This is possible because the function only prevents the same oDAO member from challenging repeatedly but does not prevent two members from taking turns.\n\nThe root cause is the lack of on-chain logic to detect and ban repeated invalid challenges from a pair of members. The current system relies on optimistic trust and governance-based resolution, which is slow (up to seven weeks).\n\nAn attacker (two compromised oDAO members) could exploit this by repeatedly challenging validators to force node operators to exit without claiming rewards, potentially gaining an unfair share of future rewards (e.g., from MEV blocks).\n\nThe impact is temporary disruption of reward distribution and potential unfair advantage for malicious actors, though the bonded RPL forfeiture (1750 RPL per member) provides economic disincentive.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolManager.sol#L135"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolManager.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "challengeExit() allows less than intended challenges",
            "description": "The challengeExit() function is intended to allow 50 challenges per call, but due to a logic error using the < operator instead of <=, it only allows 49 challenges.\n\nThe root cause is an incorrect comparison in the require statement that limits the number of challenges. This off-by-one error reduces the intended functionality.\n\nAn attacker (malicious or compromised oDAO member) could exploit this to slightly reduce the efficiency of the challenge process, though the impact is minimal since 49 out of 50 challenges still succeed.\n\nThe impact is a minor reduction in the protocol's ability to challenge exiting validators in a single transaction, potentially increasing gas costs or requiring additional transactions.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolManager.sol#L145-L146"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolManager.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "Megapool MEV theft penalties can be applied multiple times per block with different amounts",
            "description": "The penalty submission mechanism for Megapools includes the penalty amount in the submission key (nodeSubmissionKey), which allows the same oDAO member to submit multiple penalties for the same block with different amounts.\n\nThe root cause is the inclusion of _amount in the keccak256 hash used to prevent duplicate submissions. Since changing the amount produces a different key, the system does not recognize it as a duplicate.\n\nA malicious or buggy oDAO client could exploit this to apply multiple penalties in the same block, even though MEV theft can only occur once per block. This could lead to over-penalization.\n\nThe impact is potential over-penalization of Megapools, leading to unjust loss of funds for node operators, though the overall cap on weekly penalties limits the total exposure.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolPenalties.sol#L44-L47"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolPenalties.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Minipool MEV theft penalties will not be applied at 51% consensus threshold",
            "description": "The consensus check for applying Minipool MEV theft penalties uses a > operator instead of >=, meaning that a 51% vote threshold is not sufficient to apply the penalty when exactly 51% of oDAO members vote in favor.\n\nThe root cause is the incorrect use of a strict greater-than operator where a greater-than-or-equal operator is required by the specification.\n\nIn an edge case where exactly 51% of oDAO members approve a penalty, the penalty will not be applied, even though it meets the defined threshold.\n\nThe impact is a failure to penalize MEV theft in a narrow but possible scenario, undermining the reliability of the penalty system and potentially allowing malicious validators to avoid penalties.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L34",
                "RocketDAOProtocolSettingsNetwork.sol#L138-L141",
                "RocketNetworkPenalties.sol#L113"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Missing forced distribution before changed capital ratio scenarios causes incorrect accrued staking rewards distribution",
            "description": "The reduceBond() function correctly forces a reward distribution before adjusting the capital ratio, but other functions that affect the capital ratio\u2014dequeue(), dissolveValidator(), and notifyFinalBalance()\u2014do not perform this step.\n\nThe root cause is inconsistent implementation of reward distribution logic across functions that modify the capital ratio.\n\nA node operator could exploit this by calling these functions without triggering distribution, thereby deferring rewards to a later time when the capital ratio is less favorable, resulting in incorrect reward allocation.\n\nThe impact is incorrect distribution of staking rewards, potentially leading to financial loss for node operators or unfair advantage depending on timing.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolDelegate.sol#L255-L259"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Allowing distribute() to be called before the first staked validator may cause inaccuracy in rewards distribution",
            "description": "The distribute() function updates lastDistributionBlock to block.number even if no validator has been staked yet. This allows anyone who donates ETH and calls distribute() to set this value prematurely.\n\nThe root cause is the lack of a guard clause preventing distribute() from being called before the first validator is staked.\n\nAn attacker could manipulate the time-weighted average commission calculation by forcing an early distribution, skewing future reward calculations if the commission rate changes before the first validator is staked.\n\nThe impact is inaccuracy in staking reward calculations, potentially leading to unfair distribution of rewards.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolDelegate.sol#L306-L308",
                "RocketMegapoolDelegate.sol#L411"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail on notify_threshold allows all exiting validators to be penalized",
            "description": "The notify.threshold parameter lacks an upper bound, allowing the pDAO to set it to an arbitrarily high value, which could result in all exiting validators being penalized for late notification.\n\nThe root cause is the absence of an upper limit in the parameter validation logic, despite RPIP-72 specifying only a lower guardrail.\n\nA malicious or misconfigured pDAO could exploit this to set a very high threshold (e.g., weeks), ensuring that nearly all node operators fail to notify in time, leading to widespread penalties.\n\nThe impact is unjust financial penalties on node operators and potential operational disruption.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L25-L26",
                "RocketDAOProtocolSettingsMegapool.sol#L44-L45",
                "RocketMegapoolDelegate.sol#L560-L564"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Incorrect operator prevents the application of the maximum allowed late notification fine",
            "description": "The setSettingUint() function uses '<' instead of '<=' when enforcing the upper limit on late.notify.fine, preventing the value from being set to exactly 0.5 ETH, which is allowed by RPIP-72.\n\nThe root cause is a logical error in the require statement, making the validation stricter than intended.\n\nThis bug prevents the protocol from applying the maximum penalty allowed by the specification, limiting governance flexibility.\n\nThe impact is reduced effectiveness of the penalty mechanism, as the maximum fine cannot be enforced even when justified.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L46-L47"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Missing conditional check for exit challenge creation deviates from RPIP-72 specification",
            "description": "RPIP-72 specifies that oDAO members should only be able to create an exit challenge if a node operator fails to notify exit more than notify_threshold before withdrawable_epoch. However, challengeExit() lacks this check.\n\nThe root cause is the omission of time-based validation in the challengeExit() function, unlike notifyExit(), which enforces the rule.\n\nThis allows oDAO members to create challenges at any time, deviating from the specification and potentially enabling premature or unjust challenges.\n\nThe impact is a deviation from protocol specification and potential for abuse in the challenge system, though RocketPool acknowledges this as an intentional optimistic safeguard.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolDelegate.sol#L496-L514",
                "RocketMegapoolDelegate.sol#L560-L564"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing lower guardrail on late.notify.fine allows exiting validators to never incur any late notification fine",
            "description": "The late.notify.fine parameter has an upper guardrail (\u22640.5 ETH) but no lower guardrail, allowing the pDAO to set it to zero.\n\nThe root cause is the lack of a minimum value enforcement in the parameter setting logic.\n\nA malicious or self-interested pDAO could set the fine to zero, eliminating the penalty for late notification, which undermines the incentive for timely reporting.\n\nThe impact is reduced protocol security and fairness, as node operators face no penalty for late notification, increasing operational risk for the protocol.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L26",
                "RocketDAOProtocolSettingsMegapool.sol#L46-L47",
                "RocketMegapoolDelegate.sol#L560-L564"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Compromised oDAO can apply MEV theft penalty to arbitrary validators",
            "description": "The oDAO has the authority to apply MEV theft penalties without requiring cryptographic proof of theft, relying instead on trust and consensus.\n\nThe root cause is the lack of objective, verifiable criteria for determining MEV theft, combined with centralized control by a small group (13 members).\n\nIf the oDAO is compromised, members could collude to penalize innocent validators within the ETH cap, leading to unjust loss of funds.\n\nThe impact is significant financial risk to node operators and erosion of trust in the protocol's fairness, especially if penalties are applied maliciously.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L24",
                "RocketMegapoolPenalties.sol#L124-L147"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail on maximum.megapool.eth.penalty allows validators to be arbitrarily penalized for MEV theft",
            "description": "The maximum.megapool.eth.penalty parameter has a lower guardrail (>300 ETH) but no upper guardrail, allowing the pDAO to set it to an unbounded value.\n\nThe root cause is the absence of an upper limit in the parameter validation logic.\n\nA malicious or compromised pDAO could increase this value arbitrarily, enabling excessive penalties on validators even for minor or non-existent theft.\n\nThe impact is the potential for catastrophic financial loss to node operators and abuse of governance power.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L24",
                "RocketDAOProtocolSettingsMegapool.sol#L42-L43"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Outdated implementation of >= 2 days lower guardrail for megapool.time.before.dissolve deviates from specification",
            "description": "The implementation enforces a lower guardrail of >=2 days for megapool.time.before.dissolve, but RPIP-72 updated the specification to require \u226510 days.\n\nThe root cause is a failure to update the on-chain validation logic after the specification change.\n\nThis allows the pDAO to set the dissolve time lower than intended, enabling watchers to dissolve prestaked validators earlier than expected.\n\nThe impact is deviation from protocol specification and potential operational disruption, forcing validators to complete staking externally.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L23",
                "RocketDAOProtocolSettingsMegapool.sol#L40-L41",
                "RocketMegapoolDelegate.sol#L340-L344"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Outdated rationale for minipool.maximum.penalty.count may allow oDAO to disproportionately penalize untransitioned minipools",
            "description": "The minipool.maximum.penalty.count is set to 2,500 based on an older network size estimate. With the current number of minipools and the upcoming shift to Megapools, this cap may allow disproportionate penalties on the remaining minipools.\n\nThe root cause is outdated assumptions in the parameter's rationale that no longer reflect the current or future state of the network.\n\nAfter the Saturn 1 upgrade, the reduced number of minipools means that the same penalty cap could represent a much larger relative impact per minipool.\n\nThe impact is potential over-penalization of remaining minipools, leading to unfair financial consequences.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMinipool.sol#L24",
                "RocketDAOProtocolSettingsMinipool.sol#L42-L44"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMinipool.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail on minipool.maximum.penalty.count allows validators to be arbitrarily penalized for MEV theft",
            "description": "The minipool.maximum.penalty.count parameter currently lacks an upper guardrail, allowing the pDAO to increase it to an arbitrarily high value. This would permit an unlimited number of penalties to be applied within a week, even though the original rationale assumed a maximum of 2,500 based on network size and proposal probability.\n\nThe root cause is the absence of an upper bound in the parameter validation logic, which creates a governance risk. Without a cap, the pDAO could set the value so high that it enables disproportionate or punitive penalties against minipools, especially as their numbers decrease post-upgrade.\n\nA malicious or compromised pDAO could exploit this to set an extremely high penalty count, leading to potential over-penalization of a shrinking minipool population. This undermines the fairness and predictability of the penalty system.\n\nThe impact is the potential for arbitrary and excessive penalties on minipools, leading to unjust financial loss and reduced trust in governance.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMinipool.sol#L42-L44"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMinipool.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for minipool.maximum.penalty.count allows arbitrary MEV theft penalties",
            "description": "The parameter minipool.maximum.penalty.count, which limits how many times MEV theft penalties can be applied over a rolling 50400 block window (~1 week), lacks an upper guardrail. While RPIP-58 specifies a lower bound of >=2500, it fails to define an upper limit. This allows the pDAO to set the value to an unbounded large number, enabling oDAO members to arbitrarily penalize validators for MEV theft without constraints. The root cause is the absence of an upper bound enforcement in the specification and implementation. An attacker (or malicious majority in pDAO) could exploit this by voting to increase the penalty count limit, leading to excessive penalties against validators. The impact includes potential unfair slashing of validator rewards and reputational damage due to perceived governance abuse.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMinipool.sol::setMaximumPenaltyCount#(implied)"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMinipool.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for network.reth.collateral.target may affect redemptions and staking",
            "description": "The network.reth.collateral.target setting, initialized to 0.1 ether (10% collateralization), lacks both lower and upper guardrails. If set too low (e.g., 0), there will be insufficient ETH buffered in RocketTokenRETH for rETH redemptions, causing redemption failures when the deposit pool has no unborrowed ETH. Conversely, if set too high, less ETH is available for staking, reducing validator count and yield generation. The root cause is the lack of validation on parameter updates. A malicious or mistaken pDAO vote could exploit this by setting extreme values, disrupting protocol balance. The impact includes degraded user experience due to failed redemptions and reduced staking efficiency.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L33",
                "RocketDAOProtocolSettingsNetwork.sol#L49-L77",
                "RocketDepositPool.sol#L215-L224",
                "RocketDepositPool.sol#L232-L247",
                "RocketTokenRETH.sol#L106-L154"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for network.submit.balances.frequency may prevent timely network balance updates",
            "description": "The network.submit.balances.frequency parameter, which controls how often oDAO must update network balances, has a lower guardrail of >=1 hour per RPIP-33 but no upper guardrail. This allows the pDAO to set it to an arbitrarily large value, delaying balance updates. Combined with the max rETH delta enforcement (RPIP-61), this could lead to rETH-ETH depegging and accounting issues. The root cause is the omission of an upper bound in the specification. An attacker or misconfigured governance could exploit this by increasing the frequency interval, leading to stale balance data. The impact includes inaccurate protocol accounting and potential depegging of rETH.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L26",
                "RocketDAOProtocolSettingsNetwork.sol#L61-L62",
                "RocketNetworkBalances.sol#L134-L140"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "RPL price update frequency is never enforced on oDAO",
            "description": "Although network.submit.prices.frequency is set to 1 day, it is not enforced in RocketNetworkPrices.updatePrices(). This allows oDAO members to update RPL prices at any time, potentially affecting RPL staking and liquidation auctions. The root cause is the missing enforcement check in the updatePrices() function. An oDAO member could exploit this by submitting frequent price updates, possibly manipulating short-term staking rewards or auction dynamics. The impact is limited since price setting itself is already a powerful control, but lack of frequency enforcement reduces predictability.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L28",
                "RocketNetworkBalances.sol#L134-L140",
                "RocketNetworkPrices.sol#L118-L124"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for node.unstaking.period can cause unexpected withdrawal behaviors",
            "description": "The node.unstaking.period setting is initialized to 28 days as per RPIP-30, but no guardrails exist to limit its value. This allows the pDAO to set it to zero (allowing immediate withdrawals) or an extremely high value (indefinitely blocking withdrawals), both of which can disrupt staking incentives and reward gaming resistance. The root cause is the absence of upper and lower bounds in the specification. A malicious pDAO majority could exploit this to either encourage reward farming or lock user funds. The impact includes potential gaming of staking rewards and user fund accessibility issues.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNode.sol#L25",
                "RocketDAOProtocolSettingsNode.sol#L31-L44"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNode.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for node.voting.power.stake.maximum allows bypass of RPL clamping to increase voting power",
            "description": "The node.voting.power.stake.maximum parameter, which caps the effective RPL stake used in voting power calculations (default 1.5 ether), lacks an upper guardrail. This allows the pDAO to set it to an extremely high value, effectively bypassing the clamping mechanism in calculateVotingPower(). The root cause is the missing upper bound validation. A malicious pDAO could exploit this to allow large stakeholders to gain disproportionate voting power, undermining governance fairness. The impact is centralization of voting power and potential capture of pDAO governance.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsNode.sol#L35",
                "RocketNetworkSnapshots.sol#L20",
                "RocketNetworkVoting.sol#L77-L80",
                "RocketNetworkVoting.sol#L88-L96"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNode.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Security Council proposals will pass at 50% member quorum threshold",
            "description": "The members.quorum setting in RocketDAOProtocolSettingsSecurity is incorrectly initialized to 0.5 ether (50%) instead of 0.51 ether (51%) as intended. Despite guardrails requiring values between 51% and 75%, the default initialization allows proposals to pass at 50%. The root cause is a typo in the initialization value. An attacker or accidental vote could exploit this to pass proposals with less consensus than expected. The impact is reduced security margin for Security Council decisions, potentially allowing premature execution of critical actions.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L16",
                "RocketDAOProtocolSettingsSecurity.sol#L47-L49"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "A single compromised Security Council member can veto an upgrade proposal",
            "description": "The upgradeveto.quorum is set to 0.33 ether (1 out of 3 members), meaning a single compromised key can block any protocol upgrade. Given that SC members are team-controlled and replacement requires pDAO governance (which may take weeks), this creates a critical single point of failure. The root cause is insufficient quorum and small council size. An attacker with access to one SC key could exploit this to indefinitely block emergency upgrades. The impact includes prolonged exposure to known vulnerabilities and potential protocol freeze during attacks.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L21"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Upgrade delay of 7 days may be insufficient given the current validator exit queue wait times",
            "description": "The upgrade.delay is set to 7 days, but current validator exit queues can take up to ~15 days. This means users may not have enough time to exit safely before a potentially harmful upgrade is executed. The root cause is outdated parameter calibration based on historical assumptions. An attacker or malicious proposal could exploit this by timing upgrades to execute before users can exit. The impact is reduced user safety and potential loss of funds due to forced participation in risky upgrades.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L22"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Setting network.submit.prices.enabled is incorrectly implemented as SC changeable parameter without delay",
            "description": "According to RPIP-33, network.submit.prices.enabled should not be modifiable by the Security Council without delay (no * marker), but it is implemented as such. Conversely, network.submit.rewards.enabled has the * marker but is not enabled for SC changes. This inconsistency between specification and implementation could lead to confusion or unintended access control. The root cause is a mismatch in documentation and code. An attacker could exploit governance expectations to argue for or against change legitimacy. The impact is governance ambiguity and potential misconfiguration.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsSecurity.sol#L29"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsSecurity.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for members.rplbond allows current members to manipulate oDAO",
            "description": "The members.rplbond parameter, which sets the RPL bond required for oDAO membership (1750 RPL), has no guardrails. Current members can change it to an arbitrarily high value to deter new members or set it near zero to eliminate meaningful penalties. The root cause is lack of update validation. Malicious oDAO members could exploit this to entrench power or avoid accountability. The impact includes governance centralization and reduced deterrence against misbehavior.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L94-L103",
                "RocketDAONodeTrustedActions.sol#L139-L147",
                "RocketDAONodeTrustedActions.sol#L169-L172",
                "RocketDAONodeTrustedSettingsMembers.sol#L20"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails for oDAO challenge times may make the challenge process ineffective",
            "description": "The members.challenge.window and members.challenge.cooldown settings (both 7 days) lack guardrails, allowing oDAO members to set them to arbitrarily low or high values. This could render the challenge mechanism useless\u2014either too easy to spam or too slow to respond. The root cause is missing validation on parameter updates. A malicious majority could exploit this to disable the fallback mechanism for offline oDAO members. The impact is reduced resilience of the governance system during member outages.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedSettingsMembers.sol#L23-L24",
                "RocketDAONodeTrustedSettingsMembers.sol#L34-L40"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedSettingsMembers.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails on members.challenge.cost allow members to prevent non-member challenges or allow spamming",
            "description": "The members.challenge.cost (set to 1 ether) has no upper or lower guardrails. It can be set so high that non-members cannot afford to challenge, or so low (even zero) that spam attacks become feasible. The root cause is absence of bounds checking. Malicious oDAO members could exploit this to either block external oversight or enable denial-of-service via spam. The impact includes compromised governance integrity and potential abuse of the challenge system.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L187-L188",
                "RocketDAONodeTrustedSettingsMembers.sol#L25",
                "RocketDAONodeTrustedSettingsMembers.sol#L35-L40"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing guardrails on oDAO voting settings can make the proposal voting process ineffective",
            "description": "Key oDAO voting parameters\u2014proposal.cooldown.time, proposal.vote.time, proposal.vote.delay.time, proposal.execute.time, and proposal.action.time\u2014lack guardrails. This allows arbitrary changes that could break the voting process (e.g., extremely long delays or short execution windows). The root cause is missing validation logic. A malicious majority could exploit this to stall governance or force rushed decisions. The impact is potential paralysis or instability in oDAO decision-making.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedSettingsProposals.sol#L19-L23"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/settings/RocketDAONodeTrustedSettingsProposals.sol"
            ]
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing check allows challenged members to refute beyond the challenge window",
            "description": "The actionChallengeDecide() function does not verify that a challenged member responded within the challenge window. This allows members to refute challenges even after the deadline, violating the intended protocol behavior. The root cause is a missing timestamp check for the refuting party. A malicious or negligent member could exploit this to avoid removal despite being unresponsive. The impact is reduced reliability of the challenge mechanism as a fail-safe.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L207-L224"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Missing check allows a challenge proposer to also later remove the challenged member",
            "description": "The actionChallengeDecide() function does not prevent the original challenge proposer from being the one to remove the challenged member. This violates the requirement that a different node must perform the removal to provide oversight. The root cause is a missing address comparison check. A malicious actor could exploit this to self-police without external validation. The impact is reduced accountability in the challenge process, though mitigated by the ability of users to run multiple nodes.\n",
            "severity": "Low",
            "location": [
                "RocketDAONodeTrustedActions.sol#L180-L183",
                "RocketDAONodeTrustedActions.sol#L224-L231"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedActions.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1025"
                ]
            },
            "title": "getQueueTop() returns an incorrect validator",
            "description": "The getQueueTop() function uses an incorrect condition (queueIndex % (expressQueueRate + 1) != 0) to determine express queue usage, while the correct logic in _assignMegapools() uses != expressQueueRate. This discrepancy causes getQueueTop() to return the wrong validator, potentially leading to unexpected behavior in client software relying on this function. The root cause is a logic error in the conditional expression. An attacker could exploit this to predict or manipulate assignment order. The impact is inconsistency between expected and actual validator assignment.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol#L383-L406",
                "RocketDepositPool.sol#L595-L618"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing upper guardrail for megapool.time.before.dissolve can prevent validators from being dissolved",
            "description": "The megapool.time.before.dissolve parameter, used to control how long before a megapool validator can be dissolved, lacks an upper guardrail. While RPIP-59/RPIP-72 define lower bounds (2/10 days), no upper limit exists, allowing the pDAO to set it to an arbitrarily large value, effectively preventing dissolution. The root cause is incomplete specification. A malicious pDAO could exploit this to lock validators indefinitely. The impact includes reduced flexibility for node operators and potential fund immobilization.\n",
            "severity": "Low",
            "location": [
                "RocketDAOProtocolSettingsMegapool.sol#L23",
                "RocketDAOProtocolSettingsMegapool.sol#L40-L41",
                "RocketMegapoolDelegate.sol#L342-L343"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsMegapool.sol"
            ]
        },
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Unchecked state transition may lead to unexpected behavior in setUseLatestDelegate()",
            "description": "The setUseLatestDelegate() function in RocketMegapoolProxy does not validate the state transition, potentially leading to unexpected behavior if called in an invalid context. The root cause is missing preconditions or state checks. An attacker could exploit this by triggering the function at an inappropriate time, possibly disrupting megapool operations. The impact is potential instability in megapool delegation logic.\n",
            "severity": "Low",
            "location": [
                "RocketMegapoolProxy.sol#L102-L112"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolProxy.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Missing sanity check for _stakingEth <= _totalEth could cause unexpected behavior",
            "description": "A sanity check for _stakingEth <= _totalEth is implemented in executeUpdateBalances() but missing in submitBalances(). This inconsistency allows potentially invalid values of _stakingEth and _totalEth to be submitted directly via submitBalances(), which can trigger updateBalances() with incorrect data.\nThe root cause is the absence of a validation guard in submitBalances(), which is a trusted function called by oDAO members. An attacker (malicious or compromised oDAO member) could submit unbalanced values where _stakingEth exceeds _totalEth.\nThis could be exploited by submitting a vote with out-of-bounds values, leading to incorrect network balance calculations and potentially affecting reward distributions or system state integrity.\nThe impact is considered low risk as it relies on trusted actors to submit data, but incorrect values could still cause unexpected behavior or inconsistencies in the protocol's financial accounting.\n",
            "severity": "Low",
            "location": [
                "RocketNetworkBalances.sol#L82-L111",
                "RocketNetworkBalances.sol#L122"
            ],
            "files": [
                "rocketpool/contracts/contract/network/RocketNetworkBalances.sol"
            ]
        },
        {
            "id": 47,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Allowing pDAO to control voter share of revenue is risky",
            "description": "The pDAO has the ability to modify the voter share of protocol revenue via setVoterShare(), or indirectly by adjusting node or protocol DAO shares. This creates a conflict of interest, especially in the Saturn-1 phase, where short-term pDAO members might vote to increase their own share at the expense of long-term protocol health.\nThe root cause is the governance design that allows pDAO to control a parameter (voter share) that directly affects their own rewards, despite RPIP-46 specifying that this should no longer be a modifiable parameter post-Saturn-2.\nA malicious or self-interested pDAO member could propose and pass a vote to increase their share, leveraging their voting power.\nThe impact includes potential misalignment of incentives, reduced attractiveness of rETH yields compared to other LSTs, and erosion of trust in the protocol's fairness, though economic disincentives may limit exploitation.\n",
            "severity": "Low",
            "location": [
                "RocketNetworkRevenues.sol#L80-L96"
            ],
            "files": [
                "rocketpool/contracts/contract/network/RocketNetworkRevenues.sol"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ],
                "4": [
                    "CWE-638"
                ]
            },
            "title": "Nodes can withdraw ETH or credits even if they have outstanding protocol debt",
            "description": "Node operators with outstanding protocol debt (from slashing, fines, or penalties) can still withdraw ETH or credited rETH via withdrawEth() or withdrawCredit(). These functions do not check for existing debt, allowing nodes to extract value despite owing funds to the protocol.\nThe cause is the lack of a debt check in the withdrawal functions. While RocketPool partially fixed this by restricting credit withdrawals, they left ETH withdrawals unchanged, citing operational workarounds.\nAn attacker could incur debt (e.g., via slashing) and then withdraw deposited ETH or credited rETH, effectively stealing funds from the deposit pool.\nThe impact is a loss of proportional funds from the user deposit pool, undermining the protocol's solvency and fairness, though the risk is mitigated by the fact that ETH withdrawals are from third-party deposits.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol#L565-L588",
                "RocketMegapoolDelegate.sol#L181",
                "RocketMegapoolDelegate.sol#L249",
                "RocketMegapoolDelegate.sol#L562-L564",
                "RocketMegapoolDelegate.sol#L617-L629",
                "RocketMegapoolDelegate.sol#L672-L681",
                "RocketNodeDeposit.sol#L123-L139"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Missed deletion of pending withdrawal address allows a potentially untrusted one to set itself as withdrawal address",
            "description": "When setWithdrawalAddress() is called with _confirm == true, it performs a single-step update but fails to delete any previously set pending withdrawal address. This allows a previously set (and potentially malicious) pending address to later call confirmWithdrawalAddress() and become the active withdrawal address.\nThe root cause is the omission of a deletion step (e.g., deleting pendingWithdrawalAddresses[_nodeAddress]) before or after updating the withdrawal address in the confirmed path.\nAn attacker could exploit this by having a node operator mistakenly set them as a pending address, then later having the node operator correct the mistake with a confirmed change\u2014leaving the attacker's address still pending. The attacker can then claim control.\nThe impact is unauthorized control over a node's withdrawal address, leading to theft of ETH and RPL rewards, though the scenario requires a prior mistake by the node operator.\n",
            "severity": "Low",
            "location": [
                "RocketStorage.sol#L119-L134",
                "RocketStorage.sol#L136-L150"
            ],
            "files": [
                "rocketpool/contracts/contract/RocketStorage.sol"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect uint64 casts in RocketDepositPool.getQueueTop()",
            "description": "In RocketDepositPool.getQueueTop(), the function casts a 256-bit packed value using uint64, but the stored values (block numbers) are packed as uint128. This can lead to truncation and incorrect block number interpretation.\nThe cause is a type mismatch between the packing logic in setQueueMoved() (which uses uint128) and the unpacking logic in getQueueTop() (which uses uint64).\nAn attacker could manipulate queue behavior by causing incorrect block number reads, potentially affecting deposit prioritization or express queue logic.\nThe impact is incorrect state interpretation, leading to unexpected behavior in deposit processing, though it does not directly enable fund theft.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol#L637-L643",
                "RocketDepositPool.sol#L452-L454"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Missing onlyThisLatestContract modifier for functions in RocketDepositPool",
            "description": "Several functions in RocketDepositPool\u2014requestFunds, exitQueue, applyCredit, withdrawCredit, reduceBond, and fundsReturned\u2014lack the onlyThisLatestContract modifier. This means that if the contract is upgraded, old implementations could still be callable, potentially leading to state inconsistencies.\nThe root cause is the omission of a critical modifier that ensures only the latest contract version can execute state-changing functions.\nAn attacker could call deprecated functions on an old proxy implementation if the storage layout allows it, potentially manipulating state or causing reversion issues.\nThe impact is low risk because RocketPool noted that upgraded contracts revert on storage writes, but the lack of explicit protection increases attack surface and reduces clarity.\n",
            "severity": "Low",
            "location": [
                "RocketDepositPool.sol"
            ],
            "files": [
                "rocketpool/contracts/contract/deposit/RocketDepositPool.sol"
            ]
        },
        {
            "id": 52,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Improvements for BeaconStateVerifier and the SSZ library",
            "description": "Multiple low-risk issues were identified in the SSZ and BeaconStateVerifier components: (1) concat() may overflow if lenA + lenB > 248; (2) intoList() and intoVector() should use uint248 for index to prevent overflow; (3) effectiveBalance in Validator struct should be uint64 per Ethereum consensus specs; (4) isHistoricalProof() should enforce proofSlot > targetSlot for stricter validation.\nThe causes are minor type and logic oversights in low-level serialization and verification code.\nExploitation would require crafting inputs that trigger overflow or bypass validation, but no direct exploit path is evident.\nThe impact is potential runtime errors, incorrect deserialization, or non-compliance with Ethereum specs, which could affect beacon chain integration reliability.\n",
            "severity": "Low",
            "location": [
                "SSZ.sol#L41-L46",
                "SSZ.sol#L27-L35",
                "BeaconStateVerifierInterface.sol#L18-L22",
                "BeaconStateVerifier.sol#L85-L88"
            ],
            "files": [
                "rocketpool/contracts/contract/util/SSZ.sol",
                "rocketpool/contracts/contract/util/BeaconStateVerifier.sol"
            ]
        },
        {
            "id": 53,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "RocketMegapoolManager functions can make arbitrary external calls",
            "description": "Functions in RocketMegapoolManager (stake, dissolve, notifyExit, etc.) make external calls to provided megapool addresses without validating that they are registered megapools. This allows arbitrary contract interaction.\nThe root cause is the lack of a guard like onlyRegisteredMegapool() to restrict calls to known, valid contracts.\nAn attacker could pass a malicious contract address, leading to unexpected behavior or potential reentrancy or phishing attacks if context changes.\nThe impact is low, as no immediate exploit is possible, but it violates secure coding practices and increases risk in future upgrades.\n",
            "severity": "Informational",
            "location": [
                "RocketMegapoolManager.sol#L63",
                "RocketMegapoolManager.sol#L81",
                "RocketMegapoolManager.sol#L99",
                "RocketMegapoolManager.sol#L116",
                "RocketMegapoolManager.sol#L141"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolManager.sol"
            ]
        },
        {
            "id": 54,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "Hardcoding consensus threshold for Megapool penalty enforcement prevents any required modification",
            "description": "RocketMegapoolPenalties uses a hardcoded 0.5 ether threshold for penalty enforcement, unlike RocketNetworkPenalties which uses a configurable setting. This prevents the pDAO from adjusting the threshold if needed.\nThe cause is the use of a magic number instead of a protocol setting.\nGovernance cannot adapt to changing network conditions or attack vectors that may require a different threshold.\nThe impact is reduced governance flexibility and potential misalignment with network security needs, though the current value may be appropriate.\n",
            "severity": "Informational",
            "location": [
                "RocketDAOProtocolSettingsNetwork.sol#L34",
                "RocketMegapoolPenalties.sol#L108-L114",
                "RocketNetworkPenalties.sol#L113"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolPenalties.sol",
                "rocketpool/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsNetwork.sol"
            ]
        },
        {
            "id": 55,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Specification of lower guardrail for Megapool MEV theft penalty is contradicting",
            "description": "RPIP-42 specifies a lower guardrail for Megapool penalties as > 300 ETH, but the implementation and text elsewhere state >= 300 ETH, creating a contradiction.\nThe root cause is inconsistent documentation and specification.\nThis could lead to confusion during governance decisions or audits about the actual enforceable minimum.\nThe impact is primarily on clarity and trust in specifications, with no direct security impact since the implementation is correct.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolPenalties.sol"
            ]
        },
        {
            "id": 56,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-439"
                ]
            },
            "title": "Avoid hardcoding the gas amount passed to the sha256 precompile",
            "description": "The gas amount for sha256 precompile calls is hardcoded to 84, which may break if EVM gas costs change in future upgrades.\nThe cause is static gas specification instead of using gas() to forward all available gas.\nFuture hard forks that alter precompile costs could cause these calls to fail, breaking protocol functionality.\nThe impact is potential denial of service in the event of EVM changes, though currently no issue exists.\n",
            "severity": "Informational",
            "location": [
                "SSZ.sol#L72",
                "SSZ.sol#L87",
                "RocketMegapoolDelegate.sol#L753-L818"
            ],
            "files": [
                "rocketpool/contracts/contract/util/SSZ.sol"
            ]
        },
        {
            "id": 57,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "Unused code reduces readability",
            "description": "Several functions and variables (e.g., incrementMemberUnbondedValidatorCount, nodeRewards, penalties, onlyRPLWithdrawalAddressOrNode, \"node.megapool.minimum.stake\") are unused, likely legacy artifacts.\nThe cause is incomplete cleanup during development or upgrades.\nUnused code increases complexity, reduces readability, and risks accidental misuse in future changes.\nThe impact is maintenance burden and potential for bugs, though no direct security vulnerability exists.\n",
            "severity": "Informational",
            "location": [
                "RocketDAONodeTrusted.sol#L135-L142",
                "RocketMegapoolDelegateBase.sol#L72-L83",
                "RocketMegapoolStorageLayout.sol#L69",
                "RocketMegapoolStorageLayout.sol#L86",
                "RocketUpgradeOneDotFour.sol#L188"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrusted.sol"
            ]
        },
        {
            "id": 58,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-269"
                ],
                "3": [
                    "CWE-250"
                ]
            },
            "title": "Excess caller privileges provided in function access control is risky",
            "description": "Multiple functions grant more access than necessary, such as allowing rocketDAOProtocol or other contracts to call functions they don't need to. Examples include RocketDAOSecurityUpgrade, RocketDAOSecurityProposals, and various setters.\nThe root cause is overly permissive access modifiers that violate the principle of least privilege.\nIf trust assumptions change or contracts are repurposed, these excess privileges could be exploited.\nThe impact is increased attack surface and potential privilege escalation in future upgrades, though current risk is low.\n",
            "severity": "Informational",
            "location": [
                "RocketDAONodeTrustedProposals.sol#L100-L124",
                "RocketDAOSecurityProposals.sol#L29",
                "RocketDAOSecurityUpgrade.sol#L27",
                "RocketMegapoolFactory.sol#L61",
                "RocketMegapoolFactory.sol#L81",
                "RocketNetworkRevenues.sol#L92-L96",
                "RocketNodeDeposit.sol#L35-L36",
                "RocketNodeDeposit.sol#L94-L102",
                "RocketNodeManager.sol#L42-L45",
                "RocketNodeManager.sol#L520",
                "RocketMerkleDistributorMainnet.sol#L242-L243",
                "RocketRewardsPool.sol#L33-L34"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/node/RocketDAONodeTrustedProposals.sol"
            ]
        },
        {
            "id": 59,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing sanity checks could cause unexpected behavior",
            "description": "Several functions lack basic sanity checks, such as validating member existence, non-zero addresses, or sufficient balances. Examples include proposeVeto(), proposalReplace(), setDelegate(), and payOutContract().\nThe root cause is missing require() guards that would prevent invalid state transitions.\nAn attacker could trigger reverts, cause incorrect state updates, or drain funds if balance checks are missing (e.g., in payOutContract).\nThe impact is inconsistent state or operational failures, though most issues are low risk due to trusted caller assumptions.\n",
            "severity": "Informational",
            "location": [
                "RocketDAOSecurityProposals.sol#L157-L162",
                "RocketDAOSecurityProposals.sol#L166-L171",
                "RocketDAOSecurityProposals.sol#L177-L180",
                "RocketDAOSecurityUpgrade.sol#L44-L53",
                "RocketNetworkVoting.sol#L100-L105",
                "RocketNodeManager.sol#L250-L261",
                "RocketNodeStaking.sol#L332-L340",
                "RocketClaimDAO.sol#L182-L221"
            ],
            "files": [
                "rocketpool/contracts/contract/dao/security/RocketDAOSecurityProposals.sol"
            ]
        },
        {
            "id": 60,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Use of pragma abicoder v2 is unnecessary",
            "description": "The pragma abicoder v2 directive is used in some contracts but is redundant because Solidity 0.8.0+ defaults to ABI coder v2.\nThe cause is outdated boilerplate code.\nThis has no functional impact but may confuse developers or suggest intentional use where none is needed.\nThe impact is purely code cleanliness and maintainability.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "rocketpool/contracts/interface/minipool/RocketMinipoolBondReducerInterface.sol",
                "rocketpool/contracts/interface/minipool/RocketMinipoolManagerInterface.sol",
                "rocketpool/contracts/interface/util/LinkedListStorageInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsRelayInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketSmoothingPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/claims/RocketClaimDAOInterface.sol",
                "rocketpool/contracts/interface/network/RocketNetworkBalancesInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityProposalsInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityUpgradeInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeManagerInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeDepositInterface.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolManager.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolBondReducer.sol",
                "rocketpool/contracts/contract/util/LinkedListStorage.sol",
                "rocketpool/contracts/contract/util/LinkedListStorageHelper.sol",
                "rocketpool/contracts/contract/rewards/RocketClaimDAO.sol",
                "rocketpool/contracts/contract/rewards/RocketSmoothingPool.sol",
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol",
                "rocketpool/contracts/contract/network/RocketNetworkBalances.sol",
                "rocketpool/contracts/contract/dao/protocol/RocketDAOProtocol.sol",
                "rocketpool/contracts/contract/node/RocketNodeManager.sol"
            ]
        },
        {
            "id": 61,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Unnecessary pragma abicoder v2",
            "description": "The contracts use `pragma abicoder v2`, which is enabled by default in Solidity 0.8.0 and later versions. \nThe root cause is redundant compiler directive specification, which does not introduce a security risk but adds unnecessary code. \nThis can be exploited by increasing code complexity and potentially confusing developers into thinking special ABI encoding is required. \nThe impact is limited to code maintainability and readability, with no direct security consequences.\n",
            "severity": "Informational",
            "location": [
                "RocketDAOProtocol.sol#L3",
                "RocketNetworkBalances.sol#L3",
                "RocketClaimDAO.sol#L3",
                "RocketRewardsPool.sol#L3"
            ],
            "files": [
                "rocketpool/contracts/interface/minipool/RocketMinipoolBondReducerInterface.sol",
                "rocketpool/contracts/interface/minipool/RocketMinipoolManagerInterface.sol",
                "rocketpool/contracts/interface/util/LinkedListStorageInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketRewardsRelayInterface.sol",
                "rocketpool/contracts/interface/rewards/RocketSmoothingPoolInterface.sol",
                "rocketpool/contracts/interface/rewards/claims/RocketClaimDAOInterface.sol",
                "rocketpool/contracts/interface/network/RocketNetworkBalancesInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityProposalsInterface.sol",
                "rocketpool/contracts/interface/dao/security/RocketDAOSecurityUpgradeInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol",
                "rocketpool/contracts/interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeManagerInterface.sol",
                "rocketpool/contracts/interface/node/RocketNodeDepositInterface.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolManager.sol",
                "rocketpool/contracts/contract/minipool/RocketMinipoolBondReducer.sol",
                "rocketpool/contracts/contract/util/LinkedListStorage.sol",
                "rocketpool/contracts/contract/util/LinkedListStorageHelper.sol",
                "rocketpool/contracts/contract/rewards/RocketClaimDAO.sol",
                "rocketpool/contracts/contract/rewards/RocketSmoothingPool.sol",
                "rocketpool/contracts/contract/rewards/RocketRewardsPool.sol",
                "rocketpool/contracts/contract/network/RocketNetworkBalances.sol",
                "rocketpool/contracts/contract/dao/protocol/RocketDAOProtocol.sol",
                "rocketpool/contracts/contract/node/RocketNodeManager.sol"
            ]
        },
        {
            "id": 62,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Not using leading underscore for private/internal function names reduces readability",
            "description": "Several internal or private functions do not follow the Solidity naming convention of prefixing with an underscore, reducing code readability and maintainability. \nThe root cause is deviation from established naming conventions, likely due to inconsistent coding standards. \nWhile this cannot be directly exploited by an attacker, it may lead to confusion during code review or maintenance, increasing the risk of introducing bugs. \nThe impact is limited to developer experience and long-term codebase hygiene.\n",
            "severity": "Informational",
            "location": [
                "RocketMegapoolDelegate.sol#L690",
                "RocketMegapoolDelegate.sol#L699",
                "RocketMegapoolDelegate.sol#L707",
                "RocketMegapoolDelegate.sol#L718",
                "RocketStorage.sol#L145"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        },
        {
            "id": 63,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Resetting validator.expressUsed and validator.lastAssignmentTime will avoid stale values",
            "description": "The state variables `validator.expressUsed` in `dequeue()` and `validator.lastAssignmentTime` in `dissolveValidator()` are not reset, potentially leaving stale values in storage. \nThe root cause is incomplete state cleanup upon validator removal or dequeueing. \nAn attacker could potentially exploit this by reusing old validator data if the system relies on these fields for decision-making without proper initialization checks. \nThe impact is limited to potential logic errors or incorrect state assumptions in validator management, with low security risk.\n",
            "severity": "Informational",
            "location": [
                "RocketMegapoolDelegate.sol#L215-L242",
                "RocketMegapoolDelegate.sol#L334-L367"
            ],
            "files": [
                "rocketpool/contracts/contract/megapool/RocketMegapoolDelegate.sol"
            ]
        }
    ]
}