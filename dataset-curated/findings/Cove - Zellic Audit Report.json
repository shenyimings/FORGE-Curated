{
    "path": "dataset-curated/reports/Zellic/Cove - Zellic Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/Storm-Labs-Inc/cove-contracts-core",
            "https://github.com/Storm-Labs-Inc/token-plugins-upgradeable"
        ],
        "commit_id": [
            "fad59b375e8176a6753d33668af2216aee9a45ad",
            "fbeedec4e8f52182d4cf769e4a57755cb6d16074",
            "ae3f305029c503c6aa64d71f3cf89af08e69fdd3"
        ],
        "address": [],
        "chain": "EVM-compatible",
        "compiler_version": "n/a",
        "audit_date": "2024-11-27",
        "project_path": {
            "Cove - Zellic Audit Report.pdf-source": "dataset-curated/contracts/Cove - Zellic Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Lack of access control in requestDeposit",
            "description": "The BasketToken contract's requestDeposit function allows any caller to deposit assets on behalf of any user, provided the user has approved the contract to spend their tokens. This is due to the absence of access control checks ensuring that only the owner can initiate deposits for themselves. An attacker can exploit this by calling requestDeposit with a victim's address as the owner and themselves as the controller, thereby gaining control over the deposited assets. This leads to a complete loss of funds for users who have approved the contract, as their assets can be effectively stolen through unauthorized deposits.\n",
            "severity": "Critical",
            "location": [
                "BasketToken.sol::requestDeposit"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "Underflow when calculating basket balances",
            "description": "The _processInternalTrades function in BasketManagerUtils performs unchecked arithmetic when updating basket balances. Although it checks that the net buy amount does not exceed the current balance, it subtracts the larger initialBuyAmount (before fee deduction) from the balance within an unchecked block. This can result in an underflow, setting the balance to an extremely large value due to integer wraparound. Since the operation occurs in an unchecked context, Solidity's built-in overflow protection is bypassed. This could corrupt basket state, block further operations, and potentially lead to loss of funds by disrupting internal accounting and rebalancing mechanisms.\n",
            "severity": "Critical",
            "location": [
                "BasketManagerUtils.sol::_processInternalTrades"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "Missing rebalance-status check in updateBitFlag() leads to incorrect rebalancing",
            "description": "The updateBitFlag function in BasketToken allows administrative changes to the basket's asset configuration without verifying whether a rebalance operation is currently in progress. If called during an active rebalance, it updates the basketAssets array, which is used by the rebalancing logic to determine which assets to trade. This can result in the rebalancer using an inconsistent or outdated list of assets, leading to incorrect balance calculations, erroneous trade proposals, or failed rebalances. The root cause is the lack of a reentrancy-like guard or status check to prevent configuration changes during critical operations.\n",
            "severity": "High",
            "location": [
                "BasketToken.sol::updateBitFlag"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect swap-fee calculation on feeOnBuy",
            "description": "The swap fee is calculated based on initialBuyAmount, which is derived after deducting the sell-side fee. However, according to the protocol specification, the fee should be calculated on the buy amount before any fee deductions. This discrepancy causes the protocol to collect less fee revenue than intended, as the fee base is smaller than it should be. The cause is a misalignment between the documented fee model and the implementation logic. Over time, this leads to significant financial loss for the protocol due to undercollected fees.\n",
            "severity": "High",
            "location": [
                "BasketManagerUtils.sol::_processInternalTrades"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Management-fee calculation results in lower effective rate",
            "description": "The _harvestManagementFee function mints new shares as fees, but it calculates the fee amount based on the pre-mint total supply. After minting, the total supply increases, diluting the effective fee rate. For example, a 5% fee results in only ~4.76% effective rate due to the increased denominator. This flaw stems from not accounting for the dilutive effect of minting in the fee calculation. As a result, the protocol consistently collects less value than intended, leading to long-term revenue loss and misaligned incentives.\n",
            "severity": "High",
            "location": [
                "BasketToken.sol::_harvestManagementFee"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Missing mapping update in BasketToken.updateBitFlag() causes rebalancing failure",
            "description": "The updateBitFlag function updates the basketAssets array but fails to update the basketAssetToIndexPlusOne mapping, which is used during rebalancing to locate assets by index. When a new asset is added via bitFlag update, its index is not recorded in this mapping. Subsequently, during rebalancing, calls to basketTokenToRebalanceAssetToIndex fail with \"AssetNotFoundInBasket\" because the index lookup returns zero. This breaks the rebalancing process for baskets with updated assets, preventing proper portfolio adjustments and potentially freezing asset management operations.\n",
            "severity": "Medium",
            "location": [
                "BasketToken.sol::updateBitFlag"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Potential price manipulation via read-only reentrancy in BasketToken.proRataRedeem()",
            "description": "The proRataRedeem function in BasketToken burns shares before completing the redemption via BasketManager, creating a reentrancy window through ERC20PluginsUpgradeable's plugin system. If the 'from' address has a malicious plugin, it can reenter during the _updateBalances call after _burn but before assets are withdrawn. This allows manipulation of the basket's totalAssets during the redemption, temporarily inflating the LP token price. Third-party protocols relying on this price for collateral valuation could be tricked into allowing excessive borrowing. The impact is potential fund loss in integrated systems due to price oracle manipulation, even though the core contract has reentrancy guards.\n",
            "severity": "Medium",
            "location": [
                "BasketToken.sol::proRataRedeem"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ]
            },
            "title": "Denial-of-service risk where attackers can disrupt rebalance process with BasketManagerUtils.completeRebalance() functionality",
            "description": "The completeRebalance function can be called by anyone once 15 minutes have passed since the rebalance was proposed, even if the rebalance is not ready to complete. If the target weights are not met, the function resets the status to REBALANCE_PROPOSED instead of reverting, allowing an attacker to repeatedly call it and force the admin to re-propose token swaps. The root cause is the lack of access control on completeRebalance and the silent reset of state instead of reverting. An attacker can exploit this by monitoring the rebalance timeline and calling completeRebalance at the 15-minute mark to reset the process, preventing the admin from progressing to TOKEN_SWAP_EXECUTED. The impact is a denial-of-service on the rebalancing mechanism, delaying or disrupting basket maintenance, which could affect liquidity and user confidence. The team acknowledges the vector but considers it mitigated by completing rebalances within 15 minutes.\n",
            "severity": "Medium",
            "location": [
                "BasketManagerUtils.sol::completeRebalance#status reset"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Weights can pass unchecked",
            "description": "The completeRebalance function allows the rebalancing process to finalize even if the target weights are not met after the maximum number of retries (_MAX_RETRIES). Instead of reverting, the function proceeds with the current (potentially unfavorable) weights, leading to a basket that may be improperly balanced. The cause is the design decision to continue rather than revert when target weights are unmet. An attacker could exploit this by manipulating market conditions or delaying trades to ensure target weights are not met, forcing a rebalance with suboptimal allocations. The impact is a potential imbalance in basket composition, which could affect performance, valuation, and user trust. This is considered a design limitation rather than a critical flaw, but it introduces risk in volatile market conditions.\n",
            "severity": "Medium",
            "location": [
                "BasketManagerUtils.sol::completeRebalance#_isTargetWeightMet"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Potential asset manipulation via read-only reentrancy in BasketManagerUtils.proRataRedeem()",
            "description": "The proRataRedeem() function in BasketManagerUtils is vulnerable to read-only reentrancy when calling IERC20(asset).safeTransfer(to, amountToWithdraw), especially if the asset is an ERC-777 token or another token that allows receiver hooks. Although BasketManager has a reentrancy guard, the BasketToken.totalAssets() function can still be called during the transfer, allowing an attacker to manipulate the control flow. The root cause is the lack of adherence to the checks-effects-interactions pattern and the support for callback-enabled tokens. An attacker could exploit this by registering a malicious receiver that calls back into the system during the transfer, causing third parties relying on totalAssets() to observe inconsistent or incorrect asset values during redemption. The impact is limited to incorrect value calculations by third-party systems, potentially leading to financial losses for those parties, but not direct theft of funds from the contract.\n",
            "severity": "Low",
            "location": [
                "BasketManagerUtils.sol::proRataRedeem#loop"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Shares can round down to zero",
            "description": "The proRataRedeem function allows users to redeem shares in a basket, calculating the amount of each underlying asset based on the proportion of shares burned. However, due to integer division rounding down, if the calculated amountToWithdraw is very small, it may round down to zero, resulting in the user receiving no assets despite burning shares. The root cause is the use of integer arithmetic without safeguards for minimum withdrawal amounts. An attacker could exploit this by making small, repeated redemptions that yield zero assets, effectively destroying value without compensation. The impact is a poor user experience and potential loss of value for users redeeming small amounts, which could erode trust in the system. While not a critical vulnerability, it represents a design flaw that could be mitigated with proper checks or alternative rounding mechanisms.\n",
            "severity": "Low",
            "location": [
                "BasketManagerUtils.sol::proRataRedeem#amountToWithdraw"
            ],
            "files": [
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/libraries/BasketManagerUtils.sol",
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketManager.sol",
                "fad59b375e8176a6753d33668af2216aee9a45ad/cove-contracts-core/src/BasketToken.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Mismatch between CoW Swap adapter sequence diagram and implementation",
            "description": "The sequence diagram for the CoW Swap adapter in the project documentation does not match the actual implementation. Specifically, the diagram suggests a different order of operations compared to the code, where quote retrieval should occur before calling proposeTokenSwap(), and the loop should begin at proposeTokenSwap() because completeRebalance resets the status to REBALANCE_PROPOSED. The cause is a discrepancy between documentation and code evolution. This mismatch could lead to confusion for developers, auditors, or users trying to understand the system flow. An attacker could potentially exploit this confusion to mislead integrators or manipulate expectations about system behavior. The impact is primarily on usability and clarity rather than direct financial loss, but it could indirectly lead to incorrect integrations or flawed security assumptions.\n",
            "severity": "Informational",
            "location": [
                "Documentation::CoW Swap adapter sequence diagram"
            ],
            "files": []
        }
    ]
}