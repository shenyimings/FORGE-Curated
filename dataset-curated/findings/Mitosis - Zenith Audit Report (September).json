{
    "path": "dataset-curated/reports/Zenith/Mitosis - Zenith Audit Report (September).pdf",
    "project_info": {
        "url": [
            "https://github.com/mitosis-org/extensible-vaults",
            "https://github.com/mitosis-org/protocol"
        ],
        "commit_id": [
            "0a2bda5e4be799792dcaf30e662ecf6a5ce3f716",
            "93345425f74fc0277c236410f22d863dcfd10049"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-08-27",
        "project_path": {
            "protocol": "dataset-curated/contracts/Mitosis - Zenith Audit Report (September).pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Anyone can brick other users from performing claim in ReclaimQueue",
            "description": "This vulnerability allows any user to prevent other users from successfully claiming their assets in the ReclaimQueue. The root cause is that the `request` function allows zero-share requests for arbitrary receivers without validating that the computed assets are non-zero. As a result, an attacker can submit multiple zero-asset requests to a victim's claim queue. When the victim attempts to claim, the `claim` function reverts because it requires `res.totalAssetsClaimed > 0`, and if the first MAX_CLAIM_SIZE entries are zero-asset, the claim will always revert, permanently blocking the victim from progressing their claims. This leads to a denial-of-service condition for affected users.\n",
            "severity": "Critical",
            "location": [
                "ReclaimQueue.sol#L257",
                "ReclaimQueue.sol#L486"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Overclaim in ReclaimQueue due to incorrect share delta when first item is not equal to reqId 0",
            "description": "This vulnerability arises from incorrect calculation of share deltas in the `_execClaim` function of ReclaimQueue. The code uses the recipient-local index `i` instead of the global `reqId` to determine whether to use cumulative shares or compute a delta. This causes the first claimed entry to incorrectly use the full `sharesAcc` value when the user's first request is not at global `reqId 0`, leading to an overstatement of shares. As a result, the calculated assets during claim can exceed the intended amount, allowing users to withdraw more assets than they are entitled to. This can lead to a loss of funds for the protocol when users exploit this miscalculation during claim execution.\n",
            "severity": "High",
            "location": [
                "ReclaimQueue.sol#L400",
                "ReclaimQueue.sol#L447"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "ReclaimQueue._sync() may fail due to insufficient balance",
            "description": "The `_sync` function in ReclaimQueue may fail when transferring excess shares to the ReclaimQueueCollector due to an insufficient balance. The issue occurs because `previewWithdraw` rounds up the number of shares needed to withdraw a given amount of assets, but the actual balance of the contract may be less than this calculated amount after a prior withdrawal. For example, after withdrawing part of the assets, the remaining shares may be insufficient to cover the `sharesCollected` value computed via `previewWithdraw`, causing the transfer to revert. This can prevent the completion of sync operations and disrupt the normal functioning of the protocol, especially when asset prices fluctuate between request and sync.\n",
            "severity": "Medium",
            "location": [
                "ReclaimQueue.sol#L555-L562"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect integration of reserveVLF() and previewSync()",
            "description": "The `reserveVLF` function relies on `previewSync` to estimate the amount of assets that will be withdrawn during a sync operation. However, `previewSync` returns `min(totalAssetsOnRequest, totalAssetsOnReserve)`, while the actual `_sync` function withdraws up to `totalAssetsOnReserve` when there is excess. This discrepancy can cause `reserveVLF` to approve a withdrawal that exceeds the available idle funds in the VLF vault, leading to an underflow in `_vlfIdle` when `totalAssets` drops below `allocation`. This can permanently block `reserveVLF` and `allocateVLF` functions, disrupting liquidity management and potentially freezing funds.\n",
            "severity": "Medium",
            "location": [
                "AssetManager.sol#L217-L225",
                "ReclaimQueue.sol#L176-L180",
                "ReclaimQueue.sol#L545-L562"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/core/AssetManager.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "Interaction with entrypoints does not return excess native",
            "description": "Several functions that interact with the entrypoint, such as `deposit`, require users to send `msg.value` for cross-chain fees. However, the entrypoint does not return any excess native tokens after deducting the actual fee, causing the leftover ETH to remain stuck in the contract. This is particularly problematic for users of `MitosisVaultDepositProxy`, who expect unused funds to be refunded. The root cause is the direct use of `_Router_dispatch` without handling the difference between sent and used value. This leads to a loss of user funds and reduces trust in the system's reliability.\n",
            "severity": "Medium",
            "location": [
                "MitosisVault.sol#L123",
                "MitosisVaultDepositProxy.sol#L165",
                "MitosisVaultVLF.sol#L108"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/MitosisVault.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-636"
                ]
            },
            "title": "Vested tokens will be reduced when the balance is insufficient",
            "description": "The `_totalBalance` function in `LinearVestingManager` returns the contract's current balance when there are no pending rewards or time has passed since the last claim. This value is directly used in `configureVesting` and `withdraw` to update the `unclaimed` balance. If the contract's balance is lower than the vested amount, `unclaimed` is set to the lower value, effectively reducing the user's vested tokens. For example, a user with 600 vested tokens but a contract balance of 500 will lose 100 tokens upon withdrawal. This creates a risk of permanent token loss during periods of low contract liquidity.\n",
            "severity": "Medium",
            "location": [
                "LinearVestingManager.sol#L114-L122"
            ],
            "files": []
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-430"
                ]
            },
            "title": "MitosisVaultEntrypoint._dispatchToMitosis() should call _GasRouter_dispatch() instead of _Router_dispatch()",
            "description": "The `_dispatchToMitosis` function uses `_GasRouter_quoteDispatch` to calculate the fee but then calls `_Router_dispatch` directly, bypassing the `_GasRouter_dispatch` wrapper. This is problematic because `_GasRouter_dispatch` applies specific `_hookMetadata` (such as gas limit overrides) that are necessary for correct cross-chain message execution. Using mismatched dispatch mechanisms can lead to incorrect gas estimation, failed message relays, or inconsistent behavior across chains. The inconsistency between quoting and dispatching introduces a reliability risk in cross-chain operations.\n",
            "severity": "Medium",
            "location": [
                "MitosisVaultEntrypoint.sol#L172-L186"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/MitosisVaultEntrypoint.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Too large Cap in VLFVaultCapped will block mint()",
            "description": "The `VLFVaultCapped` contract uses `maxDeposit` and `maxMint` to enforce deposit limits. However, if `Cap` is set to `type(uint256).max` to indicate unlimited minting, the `convertToShares` function can overflow during the `fullMulDiv` calculation when converting assets to shares. Although `fullMulDiv` prevents overflow in multiplication, the division step can still overflow due to large intermediate values (e.g., when scaling with decimals). This causes `maxMint` to revert, effectively blocking all minting operations even when intended to be unlimited. This creates an unintended denial-of-service condition for legitimate users.\n",
            "severity": "Low",
            "location": [
                "VLFVaultCapped.sol#L97-L99"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/vlf/VLFVaultCapped.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "Flawed encoding with dynamic types allows potentially passing data with incorrect values",
            "description": "The `_leaf` function in `MerkleRewardDistributor` uses `abi.encodePacked` on dynamic arrays (`rewards` and `amounts`), which can lead to ambiguous encodings. Because `encodePacked` concatenates values without separators, different input combinations can produce the same output (e.g., [0x123, 0x456] vs [0x123456]). This enables second-preimage attacks where an invalid proof could be constructed to match a valid leaf hash. As a result, users might be able to claim rewards they are not entitled to, or valid claims could be disputed due to hash collisions.\n",
            "severity": "Low",
            "location": [
                "MerkleRewardDistributor.sol#L341-L349"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/reward/MerkleRewardDistributor.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "VLFStrategyExecutor cannot execute certain operations",
            "description": "The `execute` functions in `VLFStrategyExecutor` do not have the `payable` modifier, preventing them from receiving native tokens. Since these functions use `functionCallWithValue` to send value to targets, they must be able to forward native tokens. Without the `payable` modifier, any operation requiring value transfer will fail. This limits the functionality of the executor and prevents legitimate strategies that require sending ETH to external contracts, reducing the composability and utility of the system.\n",
            "severity": "Low",
            "location": [
                "VLFStrategyExecutor.sol#L174-L200"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/strategy/VLFStrategyExecutor.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-191"
                ]
            },
            "title": "MitosisVault._setCap() may underflow",
            "description": "The `_setCap` function in `MitosisVault` calculates `prevSpent` as `prevCap - assetInfo.availableCap`, which can underflow if `availableCap` exceeds `prevCap`. This can occur after a large withdrawal increases `availableCap` beyond the previous cap. When `setCap` is called afterward, the subtraction `prevCap - assetInfo.availableCap` will revert due to underflow. This prevents administrators from updating caps, disrupting liquidity management and potentially freezing deposit operations even when intended to be adjustable.\n",
            "severity": "Low",
            "location": [
                "MitosisVault.sol#L206-L216"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/MitosisVault.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Zero amount transfers in claim may revert",
            "description": "The vulnerability exists in the _claim function of MerkleRewardDistributor.sol, where zero-amount reward transfers are performed unconditionally. Some non-standard ERC20 tokens revert when a zero-value transfer is attempted, which would cause the entire claim transaction to revert, even if other rewards have non-zero amounts. This behavior stems from the lack of a check for zero amounts before executing transfers. An attacker or user attempting to claim multiple rewards, including zero-amount entries, could experience a failed transaction due to the reversion on zero transfers. The impact is limited to transaction failure for valid claims, potentially leading to user frustration or gas loss, but does not result in fund loss or critical system compromise.\n",
            "severity": "Informational",
            "location": [
                "MerkleRewardDistributor.sol#L331"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/reward/MerkleRewardDistributor.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ]
            },
            "title": "Unsafe approve pattern in VLFStrategyExecutor",
            "description": "The functions returnLiquidity and settleExtraRewards in VLFStrategyExecutor.sol use a direct approve call without first ensuring the allowance is reset to zero. Certain ERC20 tokens, such as those enforcing the \"safe approve\" rule (e.g., USDT), will revert if an approve is called when the current allowance is non-zero. This creates a risk that the approve call may fail unexpectedly, blocking critical functionality like returning liquidity. The root cause is the use of an unsafe approve pattern instead of a forceApprove mechanism that handles allowance resets. An attacker cannot directly exploit this for theft, but could potentially block operations by setting a non-zero allowance, leading to a denial of service for legitimate users. The impact is limited to operational disruption rather than fund loss.\n",
            "severity": "Informational",
            "location": [
                "VLFStrategyExecutor.sol#L138",
                "VLFStrategyExecutor.sol#L168"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/branch/strategy/VLFStrategyExecutor.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Minor issue in ReclaimQueue._convertToAssets()",
            "description": "The _convertToAssets function in ReclaimQueue.sol differs from the standard ERC4626 convertToAssets implementation by not adding 1 to totalAssets in the calculation. This deviation may lead to slight discrepancies in asset conversion calculations, particularly in edge cases involving small amounts or specific rounding behaviors. The cause is an inconsistency in the mathematical formula used, which omits the +1 adjustment present in the standard. While this does not lead to exploitable vulnerabilities or fund loss, it may result in minor inaccuracies in asset valuation during user claims. The impact is limited to potential deviation from expected behavior as defined by the ERC4626 standard, which could affect user trust or integration compatibility.\n",
            "severity": "Informational",
            "location": [
                "ReclaimQueue.sol#L311-L319"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/ReclaimQueue.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "0 amount check in AssetManager.withdraw() needs to be updated",
            "description": "The withdraw function in AssetManager.sol checks for zero input amount but does not validate the scaled output amount after calling _scaleToBranchDecimals. Due to precision loss during scaling between different decimal representations, a non-zero input amount could be scaled down to zero in the target branch's units. The current implementation does not check this resulting amount, which could lead to a user sending a valid amount and receiving zero assets on the destination chain. The root cause is the absence of a post-scaling validation check. An attacker could potentially exploit this by targeting specific amounts that round down to zero, effectively draining user funds by causing them to pay for a withdrawal that delivers nothing. However, since the original amount is still burned locally, the impact is loss of funds for the user, though the system itself remains consistent. This is classified as an informational issue due to low likelihood and reliance on specific edge cases.\n",
            "severity": "Informational",
            "location": [
                "AssetManager.sol#L405-L414"
            ],
            "files": [
                "93345425f74fc0277c236410f22d863dcfd10049/protocol/src/hub/core/AssetManager.sol"
            ]
        }
    ]
}