{
    "path": "dataset-curated/reports/Cantina/cantina_centrifuge_aug2025.pdf",
    "project_info": {
        "url": [
            "https://github.com/centrifuge/protocol-v3"
        ],
        "commit_id": [
            "547839243cd40530dd3e47e76e7ca694d5256849"
        ],
        "address": [
            null
        ],
        "chain": "n/a",
        "compiler_version": "n/a",
        "audit_date": null,
        "project_path": {
            "protocol-v3": "dataset-curated/contracts/cantina_centrifuge_aug2025.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "BalanceSheet::multicall() function can lose ETH in edge case scenario",
            "description": "The multicall() function in BalanceSheet implements batching functionality and is marked as payable, but it does not properly handle msg.value when processing empty data arrays. The root cause is the lack of validation or forwarding of msg.value to an appropriate handler, unlike Hub::multicall() and VaultRouter::multicall(), which do process msg.value. An attacker could call multicall() with a non-zero msg.value and an empty data array, causing the ETH to be lost since no operation is performed and no refund or deposit logic is triggered. This results in permanent loss of user funds in edge cases, especially when integrations assume safe handling of ETH payments during batched calls.\n",
            "severity": null,
            "location": [
                "BalanceSheet::multicall"
            ],
            "files": [
                "protocol-v3/src/spoke/BalanceSheet.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Reentrancy protection mechanism in _protected() is ineffective",
            "description": "The Hub contract uses an internal _protected() function intended to prevent reentrancy, but the implementation is flawed because the protected modifier is not directly applied to the function. Instead, _protected() is called internally, which does not enforce the modifier's logic as intended. The modifier relies on a transient _initiator variable to track the initial caller, but when _protected() is called as an internal function, the modifier's checks are bypassed. This allows reentrancy in functions like notifyDeposit() and notifyRedeem(), which depend on this protection. An attacker could exploit this during deposit or redemption callbacks to re-enter critical functions, potentially manipulating state or causing double-processing of transactions, leading to inconsistent accounting or fund loss.\n",
            "severity": null,
            "location": [
                "Hub::_protected",
                "Hub::notifyDeposit",
                "Hub::notifyRedeem"
            ],
            "files": [
                "protocol-v3/src/hub/Hub.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "refund address not always checked to be non zero",
            "description": "Several functions perform a check to ensure that subsidy[poolId].refund is not the zero address, but the _send() function omits this validation. The cause is an inconsistent application of input validation across related functions. If _send() is called with a zero refund address, it could lead to failed transfers or silent failures depending on the downstream logic. An attacker with control over the subsidy state could potentially set a zero address through a different code path or exploit a race condition, leading to loss of subsidy funds or denial of service for refund operations.\n",
            "severity": null,
            "location": [
                "_send"
            ],
            "files": [
                "protocol-v3/src/common/interfaces/IGateway.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "refund address and rely()",
            "description": "The _requestPoolFunding() function can retrieve funds from any contract that relies on the Gateway contract, which introduces a risk if the refund address is set to such a contract. This occurs because the function does not validate whether the refund address is a system contract that should not be drained. The risk is partially mitigated by the fact that setRefundAddress() is authorized and that key contracts like MultiAdapter and MessageProcessor do not inherit Recoverable. However, if refund == address(this), subsidy[GLOBAL_POT].value could be set to zero, though this is currently prevented because Gateway does not rely on itself. This finding appears to be cut off mid-explanation.\n",
            "severity": null,
            "location": [
                "Gateway::_requestPoolFunding",
                "Gateway::setRefundAddress"
            ],
            "files": [
                "protocol-v3/src/common/interfaces/IGateway.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "poolId shouldn't be 0",
            "description": "The poolId value should not be zero because 0 is a special identifier used for GLOBAL_POT. Functions such as guardian::createPool(), hub::createPool(), and hubRegistry.registerPool() do not explicitly validate that poolId != 0, relying instead on indirect checks. The root cause is the lack of an explicit guard. Although the risk is limited due to authorization controls, a misconfiguration or malicious admin could set poolId to 0, leading to confusion in routing logic or unintended interactions with the global subsidy pot. This could result in incorrect fund allocation or state corruption.\n",
            "severity": null,
            "location": [
                "guardian::createPool",
                "hub::createPool",
                "hubRegistry::registerPool"
            ],
            "files": [
                "protocol-v3/src/common/Guardian.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "CentrifugeId shouldn't be 0",
            "description": "CentrifugeId should not be zero, as it is a special value and is explicitly disallowed in MessageProcessor::handle(). However, there is no explicit validation in deployment scripts or constructors of MultiAdapter and MessageDispatcher to prevent zero values. The cause is missing input validation during configuration. A configuration error could result in a CentrifugeId being set to zero, which would be rejected downstream, causing transaction failures or inconsistent state. This could lead to denial of service or misrouting of cross-chain messages.\n",
            "severity": null,
            "location": [
                "MultiAdapter",
                "MessageDispatcher",
                "MessageProcessor::handle"
            ],
            "files": [
                "protocol-v3/src/common/MultiAdapter.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ]
            },
            "title": "Gas savings by conditionally updating shareQueue",
            "description": "The shareQueue is updated unconditionally in certain functions, even when the new value is identical to the current one. This leads to unnecessary storage writes, increasing gas costs. The root cause is the lack of a dirty-check before updating. By adding a condition to only update when the value has changed, gas can be saved on every transaction where no actual change occurs. While the impact per transaction is small, the cumulative cost over many operations can be significant. No security impact, but optimization is recommended.\n",
            "severity": null,
            "location": [
                "shareQueue"
            ],
            "files": [
                "protocol-v3/src/spoke/BalanceSheet.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "underpaid_[] entries stay forever",
            "description": "After a successful repay() call, the underpaid_[centrifugeId][batchHash] entry remains in storage and is never deleted. The root cause is the absence of a cleanup step post-repayment. This leads to permanent storage bloat, increasing gas costs for future operations that iterate or access this mapping. An attacker could potentially exploit this by triggering many small underpaid entries, leading to denial of service via excessive gas usage. While not a direct fund loss, it degrades system performance and increases operational costs.\n",
            "severity": null,
            "location": [
                "underpaid_",
                "repay"
            ],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Redundant check in newManager()",
            "description": "The newManager() function includes a check that the token address is not zero, but this is redundant because the Spoke::shareToken() function already performs the same validation. The cause is duplicated validation logic. This does not introduce a security risk but reduces code clarity and increases gas slightly due to an unnecessary check. The impact is minimal, but removing the redundant check would improve code maintainability and efficiency.\n",
            "severity": null,
            "location": [
                "newManager",
                "Spoke::shareToken"
            ],
            "files": [
                "protocol-v3/src/managers/OnOfframpManager.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Naming inconsistencies in OnOfframpManager",
            "description": "The OnOfframpManager constructor uses a parameter named spoke_ which is assigned to the state variable contractUpdater, creating a naming mismatch. This is inconsistent with the OnOfframpManagerFactory, which uses contractUpdater_ as the parameter name. Additionally, the error NotSpoke() in the update function is outdated and does not align with standard authorization error naming. The cause is inconsistent naming conventions. This can lead to confusion during audits or maintenance, increasing the risk of human error. While not a direct vulnerability, it affects code readability and long-term security.\n",
            "severity": null,
            "location": [
                "OnOfframpManager",
                "OnOfframpManagerFactory"
            ],
            "files": [
                "protocol-v3/src/managers/OnOfframpManager.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Missing TokenRecoverer contract registration",
            "description": "The TokenRecoverer contract is deployed in _preDeployCommon() but is not registered in the system registry. The cause is an omission in the deployment script. This leads to inconsistency in the contract registry, making it harder to discover or interact with the TokenRecoverer programmatically. While the contract functions correctly, the lack of registration could lead to operational issues or confusion during upgrades or integrations. It may also prevent automated tooling from recognizing the contract.\n",
            "severity": null,
            "location": [
                "_preDeployCommon"
            ],
            "files": [
                "protocol-v3/script/CommonDeployer.s.sol",
                "protocol-v3/src/common/TokenRecoverer.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-115"
                ]
            },
            "title": "Inconsistent setting of isIncrease when delta is zero",
            "description": "When net deposits are zero, the isIncrease flag is set to true, which is inconsistent with the logic in submitQueuedShares, where shareQueue.isPositive returns false for zero delta. The cause is divergent logic in flag setting. This inconsistency could lead to incorrect state interpretation in frontends or off-chain systems that rely on isIncrease to determine deposit trends. While not a critical security flaw, it may result in misleading analytics or incorrect business logic decisions based on the flag.\n",
            "severity": null,
            "location": [
                "isIncrease",
                "submitQueuedShares"
            ],
            "files": [
                "protocol-v3/src/spoke/BalanceSheet.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-669"
                ]
            },
            "title": "_requestPoolFunding() is suboptimal for shared refund addresses",
            "description": "If a refund address is shared among multiple pools, _requestPoolFunding() retrieves all funds from the refund address and applies them to a single poolId, which is inefficient. The cause is the lack of granular fund retrieval logic. This could lead to over-subsidization of one pool while starving others, especially in scenarios where refund addresses are reused. The recommendation is to either document that refund addresses should not be shared or modify the function to only retrieve the required amount, improving fund distribution efficiency.\n",
            "severity": null,
            "location": [
                "Gateway::_requestPoolFunding",
                "Gateway::setRefundAddress"
            ],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "uint96(...) truncates",
            "description": "The use of uint96() silently truncates values without validation or error checking. The root cause is unsafe type casting. While the likelihood of overflow is low due to expected input ranges, a malicious or erroneous high-value input could be truncated, leading to incorrect calculations or loss of precision. This could affect financial calculations if large values are ever passed, potentially resulting in incorrect subsidies or accounting. The impact is likely low but non-zero.\n",
            "severity": null,
            "location": [
                "uint96"
            ],
            "files": [
                "protocol-v3/src/common/Gateway.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Different patterns for file()",
            "description": "The file() function is used with inconsistent parameter ordering across adapters: wireWormholeAdapter uses (centrifugeId, wormholeId), while wireAxelarAdapter uses both (axelarId, centrifugeId) and (centrifugeId, axelarId). The cause is lack of standardization. This increases the risk of integration errors and developer confusion. Having multiple patterns requires more function overloads and increases code complexity. Standardizing on one pattern (e.g., always placing centrifugeId first) would simplify the interface and reduce error surface.\n",
            "severity": null,
            "location": [
                "wireWormholeAdapter::file",
                "wireAxelarAdapter::file"
            ],
            "files": [
                "protocol-v3/src/common/Guardian.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Could use abi.encodeCall()",
            "description": "Several functions use abi.encodeWithSignature() where abi.encodeCall() could be used instead. The latter provides compile-time type checking, reducing the risk of signature mismatches. The cause is use of a less safe ABI encoding method. While both produce the same output, abi.encodeCall() catches errors at compile time, such as incorrect function signatures or parameter types. This improves code safety and maintainability, preventing potential runtime failures due to typos or refactoring errors.\n",
            "severity": null,
            "location": [
                "_safeGetAssetDecimals"
            ],
            "files": [
                "protocol-v3/src/spoke/Spoke.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "_verifyAdmin() check isn't foolproof",
            "description": "The _verifyAdmin() function performs checks that can be bypassed by a malicious contract that implements isOwner() to always return true. The root cause is reliance on external contract behavior without additional safeguards. This could allow a fake admin contract to pass verification, leading to unauthorized access or configuration changes. The check should be strengthened with additional validation, such as verifying contract code or using a trusted registry.\n",
            "severity": null,
            "location": [
                "_verifyAdmin"
            ],
            "files": [
                "protocol-v3/script/FullDeployer.s.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "timestampedPath contains block.chainid twice",
            "description": "The timestampedPath function includes block.chainid twice in the constructed path, but according to the intended structure, the second instance should be block.number. The cause is a coding error in path construction. This leads to incorrect or misleading paths, potentially affecting data indexing or off-chain monitoring systems. While not a direct security vulnerability, it can result in data integrity issues or broken integrations that rely on predictable path formats.\n",
            "severity": null,
            "location": [
                "timestampedPath"
            ],
            "files": [
                "protocol-v3/script/utils/JsonRegistry.s.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Extra safeguard for rely() and endorse()",
            "description": "The deployment scripts perform multiple rely() and endorse() calls without checking that the target address is not zero. The root cause is missing input validation in deployment logic. If a zero address is accidentally passed, it could lead to loss of control or inability to revoke permissions. While the functions themselves may have checks, adding a safeguard in the scripts would prevent human error during deployment. The same issue applies to root::endorse().\n",
            "severity": null,
            "location": [
                "rely",
                "endorse"
            ],
            "files": [
                "protocol-v3/script/CommonDeployer.s.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "adminSafe not registered",
            "description": "The CommonDeployer script contains a comment stating that registering \"adminSafe\" is unnecessary, but due to refactoring (load_vars.sh \u2192 load_config.py), the registration is no longer handled elsewhere. The adminSafe is present in the JSON config but not registered in the system. The cause is outdated assumptions in deployment logic. This could lead to the adminSafe not being accessible via the registry, breaking tooling or governance workflows that depend on it. Registration should be explicitly added to ensure consistency.\n",
            "severity": null,
            "location": [
                "CommonDeployer",
                "load_config.py"
            ],
            "files": [
                "protocol-v3/script/CommonDeployer.s.sol"
            ]
        }
    ]
}