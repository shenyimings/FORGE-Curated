{
    "path": "dataset-curated/reports/ChainSecurity/ChainSecurity_Liquity_Bold_Audit (1).pdf",
    "project_info": {
        "url": [
            "https://github.com/liquity/bold"
        ],
        "commit_id": [
            "abe7cbfbd465fba3812282c51773455766a70e96"
        ],
        "address": [],
        "chain": "ethereum",
        "compiler_version": "n/a",
        "audit_date": "2025-05-14",
        "project_path": {
            "bold": "dataset-curated/contracts/ChainSecurity_Liquity_Bold_Audit (1).pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Unredeemable Troves Can Pay Minimum Interest Rate",
            "description": "Some troves with debt below MIN_DEBT are marked as unredeemable (zombie troves) and are excluded from the redemption list to prevent clogging. Because these troves cannot be redeemed, they have no incentive to pay more than the minimum interest rate. An attacker could exploit this by opening many small troves just below MIN_DEBT, avoiding higher interest rates that would otherwise be required to remain redeemable and avoid redemption.\n\nThe root cause lies in the economic design: unredeemable troves face no redemption risk, so they are incentivized to minimize interest payments. Attackers can create multiple such troves intentionally by opening with MIN_DEBT and self-redeeming a small amount. While mitigating factors exist\u2014such as gas costs, locked ETH_GAS_COMPENSATION, and adjustment limitations\u2014the strategy could still be profitable under certain gas and interest rate conditions.\n\nExploitation involves creating numerous small troves below MIN_DEBT to benefit from lower interest rates compared to larger, redeemable troves. The impact includes potential manipulation of the system's interest model, leading to unfair advantages and reduced protocol revenue. Although a partial fix was implemented\u2014allowing zombie troves to be redeemed during subsequent redemptions\u2014an edge case remains where troves receiving debt during redistribution while having no prior debt can still exploit the low-interest loophole.\n",
            "severity": "Medium",
            "location": [],
            "files": [
                "bold/contracts/src/Dependencies/Constants.sol",
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Discrepancy in swapFromBold Behavior",
            "description": "The UniV3Exchange and CurveExchange contracts both implement the swapFromBold function, but they behave differently despite being intended as interchangeable. UniV3Exchange uses an ExactOutput swap, which ensures the exact amount of collateral tokens is received and may leave excess BOLD tokens. In contrast, CurveExchange uses an ExactInput swap (via Curve's exchange function), which swaps the full BOLD input and may leave excess collateral tokens.\n\nThe root cause is inconsistent implementation across exchange adapters, violating the principle of uniform behavior when interfaces are meant to be substitutable. This discrepancy can lead to unexpected token balances and user confusion when different exchanges are used under the same expected behavior.\n\nAn attacker or user could exploit this by choosing the exchange that best suits their slippage or surplus token strategy, potentially leading to inefficient trades or unexpected leftover tokens in the calling contract. The impact is primarily on user experience and economic efficiency, with potential for minor fund loss due to mismanagement of excess tokens.\n\nLiquity acknowledged the issue and noted that while ExactOutput is more natural, they cannot guarantee all future exchanges will support it, leaving the inconsistency unresolved.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Rounding in Debt Shares Calculation Can Mint Unbacked Tokens",
            "description": "The TroveManager._updateBatchShares() function rounds down the debt shares when calculating batchDebtSharesDelta, using the formula: batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / batchDebt. Over time, this rounding error accumulates, especially as the batch debt grows relative to debt shares due to interest and fees.\n\nThe root cause is the use of integer division with truncation, which systematically undercounts debt shares for small debt increases. An attacker can exploit this by inflating the debt-to-shares ratio through repeated donation attacks\u2014opening a large trove, reducing it to minimal shares, then donating tiny amounts of debt that do not mint new shares due to rounding. This gradually increases the debt per share.\n\nOnce the ratio exceeds a critical threshold (~2000e18), the attacker can open a new trove with minimum debt and receive zero debt shares due to rounding, effectively minting BOLD tokens without backing. The attacker can repeat this to create unbacked tokens until the system's collateralization ratio is compromised.\n\nAdditionally, this vulnerability enables two other attack vectors: (1) redeeming a victim's trove without burning their debt shares (due to rounding down), allowing the attacker to seize collateral while returning minimal debt; and (2) accessing dirty memory in redeemCollateral when totalDebtShares is zero, leading to incorrect state reads and potential insolvency.\n\nThe issue was fixed by introducing _requireBelowMaxSharesRatio(), which reverts if the debt-to-shares ratio exceeds MAX_BATCH_SHARES_RATIO (1e9), except during redemptions. This prevents new troves from being opened or adjusted in inflated batches, though slow inflation via interest remains theoretically possible over decades.\n",
            "severity": "Critical",
            "location": [
                "TroveManager.sol::_updateBatchShares#"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-862"
                ],
                "4": [
                    "CWE-638"
                ],
                "5": [
                    "CWE-424"
                ]
            },
            "title": "BalancerFlashLoan Missing Access Control",
            "description": "The BalancerFlashLoan contract's makeFlashLoan() function lacks access control, allowing any address to trigger flashloans with arbitrary parameters. Although the intended flow requires the zapper to call makeFlashLoan(), the absence of authorization checks means attackers can bypass the zapper's access controls and directly manipulate troves.\n\nThe root cause is the missing validation that only authorized zapper contracts can initiate flashloans. Furthermore, the receiveFlashLoan callback only verifies that the call originates from the Balancer vault, not that it was part of a legitimate flashloan initiated by a zapper.\n\nAn attacker can exploit this by calling makeFlashLoan() directly or by invoking the Balancer vault with BalancerFlashLoan as the recipient. This allows unauthorized trove adjustments\u2014such as levering up close to liquidation or reducing leverage\u2014enabling profitable sandwich attacks through slippage manipulation.\n\nThe impact includes unauthorized modification of user troves, potential liquidation, and financial loss due to adverse trade execution. The fix involved setting a storage-based receiver variable during makeFlashLoan() (set to msg.sender, expected to be a zapper) and having receiveFlashLoan() call only that stored address. Direct callbacks to receiveFlashLoan with zero receiver are now reverted, closing the attack vector.\n",
            "severity": "High",
            "location": [
                "BalancerFlashLoan.sol::makeFlashLoan#",
                "BalancerFlashLoan.sol::receiveFlashLoan#"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Leverage Zappers Do Not Return Swap Excess",
            "description": "The leverage zapper contracts fail to return excess tokens to users after swap operations. When using UniV3Exchange.swapFromBold(), an ExactOutput swap may leave excess BOLD tokens in the exchange contract. Similarly, ExactInput swaps in UniV3Exchange.swapToBold(), CurveExchange.swapFromBold(), and CurveExchange.swapToBold() may result in excess output tokens being sent to the zapper but not forwarded to the user.\n\nThe root cause is the lack of post-swap balance checks and token return logic in the zapper functions. This oversight leads to user funds being stranded in the zapper or exchange contracts.\n\nAn attacker or any user could later claim these stranded tokens (as noted in the related finding \"Zappers Can Lose User Funds\"), but the primary impact is user fund loss due to poor handling of expected surplus from decentralized exchange trades. Market volatility between transaction submission and execution makes such surpluses common.\n\nThe issue was resolved in Version 2 by implementing _setInitialBalancesAndReceiver() to record token balances before swaps and _returnLeftovers() to transfer any excess back to the caller. This ensures all leftover tokens are returned, regardless of swap type.\n",
            "severity": "High",
            "location": [
                "UniV3Exchange.sol::swapFromBold#",
                "CurveExchange.sol::swapFromBold#",
                "UniV3Exchange.sol::swapToBold#",
                "CurveExchange.sol::swapToBold#"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-390"
                ]
            },
            "title": "Zappers Can Lose User Funds",
            "description": "The adjust, leverDown, and repay functions in the zapper contracts can cause user funds to become stuck. When a user requests a debt repayment that would bring a trove below MIN_DEBT, the system only repays the allowable amount (down to MIN_DEBT), but the full requested amount is already transferred to the zapper. The excess remains trapped in the contract.\n\nThe root cause is the mismatch between user fund transfer and actual debt reduction logic in _adjustTrove(), which silently reduces the repayment amount without refunding the difference. This is exacerbated by frontrunning: an attacker (e.g., a batch manager) can redeem a trove just before the repayment, reducing its debt close to MIN_DEBT, causing nearly the entire repayment to be lost.\n\nFor example, a user repaying 500,000 BOLD on a 1M BOLD trove could lose 499,999 BOLD if the trove is redeemed down to 2001 BOLD beforehand. The zapper repays only 1 BOLD but keeps the rest. These stuck funds can later be extracted by other users via trove creation and receiver manipulation.\n\nThe impact is direct financial loss for users due to poor fund handling. The fix involved inheriting from a LeftoversSweep contract that tracks initial balances and returns any surplus after operations, ensuring all excess funds are refunded to the caller.\n",
            "severity": "High",
            "location": [
                "BorrowerOperations.sol::_adjustTrove#"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Incorrect Scaling of P",
            "description": "In the StabilityPool.offset function, the variable P (a cumulative product used in deposit indexing) is assumed to stay within the range (1e27, 1e36]. However, due to integer arithmetic and scaling logic, P can exceed 1e36 under certain conditions.\n\nThe root cause is an incorrect loop condition in the scaling logic. The code uses while (newP <= P_PRECISION / SCALE_FACTOR) to trigger scaling up, but this can result in P values exceeding 1e36 after rescaling. For example, with P = 2e17 + 1, totalBoldDeposits = 1e20, and _debtToOffset = 5e19, the computed P after scaling becomes ~5e36, far above the expected upper bound.\n\nThis leads to incorrect calculations in functions like getDepositorCollGain, which assume P drops by exactly 1e9 per scale period. When P starts above 1e36, the drop can be much larger, breaking internal invariants and leading to incorrect reward distributions.\n\nThe impact is miscalculation of collateral gains and potential unfair distribution of rewards. The fix modified the loop condition to while (newP < P_PRECISION / SCALE_FACTOR), ensuring P is properly bounded within [1e27, 1e36] after scaling.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::offset#"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "Pool Deposit Are Compared to Precision",
            "description": "The _updateYieldRewardsSum function compares total deposits against DECIMAL_PRECISION (1e18) to determine if yield distribution should occur. However, other parts of the system use MIN_BOLD_IN_SP for the same purpose. Although both constants have the same value (1e18), using inconsistent constants can lead to confusion and future bugs if one is changed independently.\n\nThe root cause is code duplication and lack of constant unification. While no immediate impact occurs due to equal values, the inconsistency violates clean code practices and introduces technical debt.\n\nThere is no direct exploitation path, but the impact is reduced code maintainability and risk of future discrepancies if constants diverge. The fix updated the function to use MIN_BOLD_IN_SP instead of DECIMAL_PRECISION for consistency.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum#"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Total Deposit Are Compared to Wrong Constant",
            "description": "Similar to the previous issue, _updateYieldRewardsSum compares total deposits to DECIMAL_PRECISION when checking yield distribution thresholds, while other system components use MIN_BOLD_IN_SP. Despite both being 1e18, the use of different constants for the same logical threshold is inconsistent.\n\nThe root cause is redundant constant usage without centralized definition. The bug has no functional impact due to identical values, but it increases the risk of future divergence and logic errors.\n\nThe impact is purely on code clarity and maintainability. The fix involved replacing DECIMAL_PRECISION with MIN_BOLD_IN_SP in the comparison to ensure uniformity across the codebase.\n",
            "severity": "Low",
            "location": [
                "StabilityPool.sol::_updateYieldRewardsSum#"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Batches Can Be Used to Make Two Free Adjustments in a Row",
            "description": "The setBatchManagerAnnualInterestRate function only checks the last adjustment time of the batch, not individual troves. This allows a user to bypass the INTEREST_RATE_ADJ_COOLDOWN by joining a batch that was adjusted long ago, changing its interest rate, and then leaving\u2014effectively performing two interest rate adjustments in quick succession without paying the upfront fee.\n\nThe root cause is insufficient access control at the trove level; the cooldown is enforced per batch, not per user action. A user can exploit this by cycling through self-controlled batches to repeatedly adjust interest rates without penalty.\n\nFor example, a user can start with a high-interest trove, join a low-interest batch (adjusted long ago), immediately change the batch rate to even lower, and benefit from reduced interest without risk of redemption. After facing redemption pressure, they can repeat the process to raise the rate again\u2014twice every 6 days.\n\nThe impact is economic manipulation of interest rates, undermining the cooldown mechanism designed to prevent gaming. The fix modified setInterestBatchManager to charge an upfront fee whenever a user joins a batch, preventing free adjustments.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.sol::setInterestBatchManager#"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Delegation Specification",
            "description": "The documentation states that the receiver address set by a Remove Manager only receives collateral during removal operations. However, in Version 1, the receiver also received tokens during owner-initiated withdrawals, contradicting the specification.\n\nThe root cause is a mismatch between code implementation and documented behavior. This violates the principle of least surprise and could mislead users about fund flow control.\n\nThe impact is potential confusion and unintended fund routing, where owners expect to receive withdrawn collateral but it is instead sent to the receiver. This could lead to loss of funds if the receiver is untrusted.\n\nThe issue was resolved by updating the code so that the receiver only gets funds during Remove Manager operations. Owner withdrawals now send tokens directly to the owner, aligning implementation with documentation.\n",
            "severity": "Low",
            "location": [],
            "files": [
                "bold/contracts/src/TroveManager.sol",
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Incorrect Code Comments",
            "description": "The code contains several incorrect or outdated comments and natspec documentation, including references to deprecated concepts like \"composite debt\" and incorrect explanations of redemption order and arithmetic safety.\n\nThe root cause is that developers failed to update comments and documentation after logic changes, leading to misleading or inaccurate descriptions of function behavior and system invariants.\n\nWhile not directly exploitable for financial gain, incorrect comments can mislead auditors, developers, and users, potentially leading to incorrect assumptions during integration or further development.\n\nThe impact is misunderstanding of system behavior due to outdated documentation, which could result in incorrect off-chain tooling, flawed integrations, or future vulnerabilities introduced during maintenance.\n",
            "severity": "Low",
            "location": [
                "ActivePool._mintBatchManagementFeeAndAccountForChange",
                "BorrowerOperations._openTrove",
                "BorrowerOperations._applyUpfrontFee",
                "TroveManager.redeemCollateral",
                "LiquityMath._decPow",
                "StabilityPool.sortedTroves",
                "TroveManager.Batch",
                "MainnetPriceFeedBase.priceFeedDisabled",
                "TroveManager._urgentRedeemCollateralFromTrove",
                "BorrowerOperations.adjustUnredeemableTrove"
            ],
            "files": [
                "bold/contracts/src/ActivePool.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Interest Delegates Are More Trusted Than Needed",
            "description": "Interest rate delegates can update the interest rate without any time-based restriction, allowing them to repeatedly trigger the upfront fee and potentially grief users.\n\nThe root cause is the system lacking a minimum time interval enforcement for interest rate updates by delegates, unlike the protection available for batch managers.\n\nA malicious or misbehaving delegate could frequently adjust the interest rate, forcing users to pay the upfront fee multiple times in a short period, increasing their transaction costs.\n\nThe impact is that users may face unnecessary fees and degraded user experience due to frequent interest rate changes, undermining trust in the delegate system.\n",
            "severity": "Low",
            "location": [
                "Interest rate delegatees"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Missing Payable Modifier",
            "description": "The function `WETHZapper.adjustZombieTroveWithRawETH` lacks the `payable` modifier, causing transactions that send Ether to revert.\n\nThe root cause is that the function is intended to receive Ether for conversion to WETH but was not marked as `payable`, violating Solidity's requirement for functions that accept Ether.\n\nAny attempt to call this function with Ether attached will fail, preventing the adjustment of zombie troves via this method.\n\nThe impact is that users cannot use the zapper function to fix zombie troves unless the contract is redeployed with the correct modifier, limiting functionality and potentially leading to full redemption of affected troves.\n",
            "severity": "Low",
            "location": [
                "WETHZapper.adjustZombieTroveWithRawETH"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Missing Validation of Troves in Urgent Redemptions",
            "description": "The `TroveManager.urgentRedemption` function does not validate whether a trove exists, has debt, or is active before processing, leading to unnecessary gas consumption and storage writes.\n\nThe root cause is missing input validation for trove status and debt existence in the urgent redemption path.\n\nAn attacker could submit redemption requests for non-existent or closed troves, causing the system to waste gas and write to storage unnecessarily.\n\nThe impact is increased gas costs for transactions and potential for spamming the system with invalid redemption attempts, though no critical state corruption occurs.\n",
            "severity": "Low",
            "location": [
                "TroveManager.urgentRedemption",
                "_applySingleRedemption"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Opening Troves Can Be Blocked",
            "description": "The trove ID is derived from the owner and an index, allowing an attacker to frontrun a user's trove creation and take control of the trove ID, blocking the original user.\n\nThe root cause is that the trove ID does not include the caller (`msg.sender`), enabling an attacker to predict and pre-emptively claim a trove ID.\n\nAn attacker can monitor for pending transactions and create a trove with the same ID, setting themselves as manager and later withdrawing collateral.\n\nThe impact is that users, especially multisigs or governance systems with delayed execution, can be permanently prevented from opening troves, leading to denial of service.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations._openTrove"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-396"
                ]
            },
            "title": "Out-of-gas May Lead to Shutdown",
            "description": "The price feed contract may shut down the branch if a call to Chainlink runs out of gas, even if the oracle is functioning correctly, due to insufficient gas checks.\n\nThe root cause is that the fallback mechanism treats any revert (including out-of-gas) as an oracle failure, triggering shutdown logic without verifying the cause.\n\nAn attacker could call `fetchPrice` with limited gas to force an out-of-gas revert, potentially triggering an unintended shutdown if gas costs change in the future.\n\nThe impact is a false shutdown that could disrupt protocol operations, halt borrowing and redemption, and affect user confidence, though current gas costs make the attack infeasible.\n",
            "severity": "Low",
            "location": [
                "MainnetPriceFeedBase._getCurrentChainlinkResponse",
                "WSTETHPriceFeed._getCanonicalRate"
            ],
            "files": [
                "bold/contracts/src/PriceFeeds/MainnetPriceFeedBase.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Price Limit in UniV3Exchange Is Too Strict",
            "description": "The price limit in `UniV3Exchange.getBoldAmountToSwap` is based on a strict post-trade price check, which may prevent valid swaps even when the average price is acceptable.\n\nThe root cause is that the function uses a maximum price ratio that is too restrictive, not accounting for the difference between instantaneous and average trade price.\n\nUsers may be forced to use looser price bounds, increasing slippage and allowing MEV bots to extract more value during large swaps.\n\nThe impact is reduced swap efficiency and increased vulnerability to front-running and value extraction by bots, degrading user experience and economic fairness.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.getBoldAmountToSwap"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ],
                "3": [
                    "CWE-837"
                ]
            },
            "title": "Shutdown Can Be Triggered Twice",
            "description": "The `shutdown` function in `BorrowerOperations` may emit both `ShutDown` and `ShutDownFromOracleFailure` events if both conditions occur simultaneously, violating event exclusivity.\n\nThe root cause is that the function does not check whether the oracle failure has already triggered a shutdown before proceeding with the TCR-based shutdown.\n\nIf both the TCR drops below SCR and the oracle fails in the same block, two shutdown events may be emitted.\n\nThe impact is that off-chain systems relying on these events may misinterpret the shutdown reason, leading to incorrect monitoring or response actions, though no on-chain state corruption occurs.\n",
            "severity": "Low",
            "location": [
                "BorrowerOperations.shutdown",
                "priceFeed.fetchPrice"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "User-provided transferFrom Source Address",
            "description": "The `UniV3Exchange` and `CurveExchange` contracts use a user-provided `_zapper` address in `transferFrom`, allowing arbitrary token pulls from approved addresses.\n\nThe root cause is using a user-controlled address as the `from` parameter in `transferFrom`, violating secure token interaction patterns.\n\nAn attacker could trick a user into approving the exchange contract and then drain their tokens by specifying their address as `_zapper`.\n\nThe impact is risk of token theft from users who mistakenly approve the contract, though the actual impact is limited since zappers are not intended to hold balances.\n",
            "severity": "Low",
            "location": [
                "UniV3Exchange.swapFromBold",
                "UniV3Exchange.SwapToBold",
                "CurveExchange.swapFromBold",
                "CurveExchange.SwapToBold"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-284"
                ],
                "2": [
                    "CWE-285"
                ],
                "3": [
                    "CWE-863"
                ]
            },
            "title": "Zapper Delegation Is Not Reset When a Trove Is Closed",
            "description": "When a trove is closed, its delegation to a zapper is not reset, allowing reuse of old delegations if a new trove with the same ID is created.\n\nThe root cause is that the system does not clear zapper role assignments upon trove closure, creating a potential for unintended access.\n\nAn attacker could create and close a trove to set malicious delegations, which could later be reused if a user opens a trove with the same ID.\n\nThe impact is that users may unknowingly grant control to a zapper with outdated or malicious delegations, leading to loss of control over their trove.\n",
            "severity": "Low",
            "location": [
                "Zapper delegation system",
                "troveId reuse"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Gas Optimizations in StabilityPool",
            "description": "Several gas inefficiencies were identified in the `StabilityPool`, including unnecessary checks and redundant operations.\n\nThe root cause is suboptimal code structure leading to wasted gas on conditionals and arithmetic that have no effect.\n\nNot exploitable for financial gain, but increases transaction costs for users.\n\nThe impact is higher gas consumption for depositors and withdrawers, reducing efficiency and increasing user costs.\n",
            "severity": "Informational",
            "location": [
                "StabilityPool.getDepositorYieldGainWithPending",
                "StabilityPool.withdrawFromSP",
                "_updateYieldRewardsSum"
            ],
            "files": [
                "bold/contracts/src/StabilityPool.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Receiver Address in Balancer Flashloan Is Reset Late",
            "description": "The receiver address in `BalancerFlashLoan` is reset after the flash loan callback, rather than at the beginning of the callback, increasing risk in future code changes.\n\nThe root cause is that the reset pattern does not follow secure state-clearing best practices.\n\nIn a fork or modified version, this could allow reentrancy or unauthorized callbacks if the reset is skipped.\n\nThe impact is increased risk of vulnerabilities in future versions or forks, though no immediate exploit exists in the current design.\n",
            "severity": "Informational",
            "location": [
                "BalancerFlashLoan.makeFlashLoan",
                "BalancerFlashLoan.receiveFlashLoan"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Backed Tokens Can Be Redeemed Unproportionally",
            "description": "When redeeming collateral, the system may disproportionately redeem from a branch that is nearly fully backed, violating proportional distribution expectations.\n\nThe root cause is that the redemption logic does not cap the amount by unbacked debt when not all branches are fully backed.\n\nAn attacker could target a nearly backed branch to extract more collateral than fair share.\n\nThe impact is unfair distribution of collateral during redemptions, potentially leading to economic imbalance between branches.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry.redeemCollateral"
            ],
            "files": [
                "bold/contracts/src/CollateralRegistry.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "CEI Pattern Violated in Adjust Trove",
            "description": "The `WETHZapper._adjustTrovePost` function sends ETH before BOLD tokens, violating the Checks-Effects-Interactions (CEI) pattern.\n\nThe root cause is that the order of external calls places a non-reentrant token transfer after a potential reentrant call (ETH transfer).\n\nA malicious receiver could reenter the contract after receiving ETH but before BOLD is sent, potentially manipulating state.\n\nThe impact is risk of reentrancy-based manipulation, though BOLD is non-reentrant, reducing actual exploitability.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePost"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Comments From Development",
            "description": "The codebase contains leftover development comments, TODOs, and test imports that should be removed before production deployment.\n\nThe root cause is incomplete cleanup of debug and development artifacts.\n\nNot directly exploitable, but may expose internal logic or intent.\n\nThe impact is reduced code clarity and professionalism; potential for confusion or accidental activation of commented logic.\n",
            "severity": "Informational",
            "location": [
                "TroveManager._getLatestTroveDataFromBatch",
                "TroveManager (imports)",
                "Various functions with TODOs"
            ],
            "files": [
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1068"
                ]
            },
            "title": "Core Debt Invariant Incorrectly Documented",
            "description": "The documented core debt invariant omits `defaultPool.BoldDebt`, making it incorrect.\n\nThe root cause is that documentation was not updated to reflect the full accounting of debt across pools.\n\nMisleads developers and auditors about the true state of system debt.\n\nThe impact is potential for incorrect assumptions during audits or integrations, leading to flawed off-chain analysis.\n",
            "severity": "Informational",
            "location": [
                "Documentation",
                "Core debt invariant"
            ],
            "files": [
                "bold/contracts/src/DefaultPool.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Floating Pragma",
            "description": "Some contracts use a floating Solidity pragma, which can lead to compilation with untested compiler versions.\n\nThe root cause is lack of version pinning in Solidity source files.\n\nDeployment with a different compiler version could introduce unexpected behavior or bugs.\n\nThe impact is risk of compilation inconsistencies and potential vulnerabilities due to compiler-specific behaviors.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry.sol",
                "Other contracts with floating pragma"
            ],
            "files": [
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGPool.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveFactory.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGFactory.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/Curve/ICurvePool.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol",
                "bold/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3ExchangeHelpers.sol",
                "bold/contracts/src/Zappers/Interfaces/IFlashLoanReceiver.sol",
                "bold/contracts/src/Zappers/Interfaces/ILeverageZapper.sol",
                "bold/contracts/src/Zappers/Interfaces/IZapper.sol",
                "bold/contracts/src/Zappers/Interfaces/IExchangeHelpers.sol",
                "bold/contracts/src/Zappers/Interfaces/IFlashLoanProvider.sol",
                "bold/contracts/src/Zappers/Interfaces/IExchange.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Inconsistent Input Validation by Zappers",
            "description": "Zapper contracts have inconsistent validation for debt increase operations, with some missing checks for non-zero `_boldChange`.\n\nThe root cause is divergent implementation between `WETHZapper` and `GasCompZapper`.\n\nAllows no-op calls that pass validation but have no effect, potentially confusing users or interfaces.\n\nThe impact is reduced code consistency and reliability, though no critical security impact due to downstream checks.\n",
            "severity": "Informational",
            "location": [
                "WETHZapper._adjustTrovePre",
                "GasCompZapper._adjustTrovePre"
            ],
            "files": [
                "bold/contracts/src/Zappers/WETHZapper.sol",
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Indexed Parameters of Events",
            "description": "The `CollSent` event does not index the `_to` parameter, making it harder for off-chain systems to query withdrawals.\n\nThe root cause is event design oversight.\n\nNot exploitable, but reduces event usability.\n\nThe impact is inefficient event querying for wallets and analytics tools.\n",
            "severity": "Informational",
            "location": [
                "CollSurplusPool.CollSent"
            ],
            "files": [
                "bold/contracts/src/CollSurplusPool.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Minting Unbacked Tokens via Redistributions",
            "description": "A rounding issue in debt share calculations could allow attackers to mint unbacked tokens by manipulating redistribution logic in edge cases with empty StabilityPool.\n\nThe root cause is that debt redistribution does not properly account for rounding when redeeming troves with pending redistributions.\n\nAn attacker could open troves, manipulate exchange rates, and trigger redistributions to increase debt without minting shares, leading to unbacked collateral claims.\n\nThe impact is potential creation of bad debt and loss of collateral value, especially in newly deployed or unpopular branches.\n",
            "severity": "Informational",
            "location": [
                "Redistribution logic",
                "TroveManager",
                "Batch debt accounting"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol",
                "bold/contracts/src/TroveManager.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Misleading Function Names in Zapper",
            "description": "Functions in `GasCompZapper` use names like `adjustTroveWithRawETH` that imply ETH handling, even though no raw ETH is used.\n\nThe root cause is inconsistent naming across zapper implementations.\n\nMisleads developers and users about the actual behavior of the function.\n\nThe impact is confusion during integration and potential misuse of functions based on incorrect assumptions.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.adjustTroveWithRawETH",
                "LeverageLSTZapper"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing Events",
            "description": "The `AddRemoveManager._setAddManager` and `_setRemoveManager` functions do not emit events when manager roles are updated.\n\nThe root cause is lack of event emission for state changes in access control.\n\nMakes it difficult for off-chain systems and users to track changes in trove management permissions.\n\nThe impact is reduced transparency and auditability of role assignments, potentially leading to security incidents going unnoticed.\n",
            "severity": "Informational",
            "location": [
                "AddRemoveManager._setAddManager",
                "AddRemoveManager._setRemoveManager"
            ],
            "files": [
                "bold/contracts/src/Dependencies/AddRemoveManagers.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-1071"
                ]
            },
            "title": "Unimplemented Function Can Be Called",
            "description": "The contracts GasCompZapper and WETHZapper define functions `receiveFlashLoanOnOpenLeveragedTrove`, `receiveFlashLoanOnLeverUpTrove`, and `receiveFlashLoanOnLeverDownTrove` with empty function bodies, meaning they can be called but perform no operations. The root cause is that these contracts are not marked as abstract despite containing unimplemented logic. An attacker or user could call these functions expecting them to revert or perform actions, leading to confusion or misuse. The impact is low, as no state changes occur, but it may mislead integrators or users into believing functionality exists when it does not.\n",
            "severity": "Informational",
            "location": [
                "GasCompZapper.sol",
                "WETHZapper.sol"
            ],
            "files": [
                "bold/contracts/src/Zappers/GasCompZapper.sol",
                "bold/contracts/src/Zappers/WETHZapper.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Bypassing Collateral Adjustment Check",
            "description": "The function BorrowerOperations._requireValidAdjustmentInCurrentMode prevents reducing collateral in undercollateralized troves (ICR < MCR). However, this check can be bypassed through self-redemptions by first adjusting the interest rate of the trove to be the lowest in the branch and then redeeming from it. The root cause is a logic gap in the validation mechanism that does not account for redemption-based adjustments. An attacker could exploit this to manipulate an undercollateralized trove\u2019s state, although Liquity acknowledges that this does not allow converting a healthy trove into an undercollateralized one. The impact is minimal as it does not compromise system safety, but it reveals a nuance in collateral control logic.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations::_requireValidAdjustmentInCurrentMode"
            ],
            "files": [
                "bold/contracts/src/BorrowerOperations.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified across several contracts. These include: (1) A protected function ActivePool.mintBatchManagementFeeAndAccountForChange() being called only by one contract despite allowing two callers; (2) Interest calculation functions not short-circuiting early; (3) Reading full storage structures when only a single value is used; (4) Redundant balance checks already enforced by OpenZeppelin tokens; (5) Unnecessary calls when redistributing zero collateral; (6) Unused modifiers and functions; (7) Suboptimal price feed calls; and (8) Failure to mark constructor-set state variables as immutable. The root cause is suboptimal code design and lack of optimization passes. Exploitation is not applicable as these are efficiency issues, but their impact includes higher transaction costs and wasted computation. Some optimizations were partially addressed in later versions.\n",
            "severity": "Informational",
            "location": [
                "ActivePool::mintBatchManagementFeeAndAccountForChange",
                "ActivePool::calcPendingAggInterest",
                "ActivePool::calcPendingAggBatchManagementFee",
                "TroveManager::_getLatestTroveDataFromBatch",
                "CollateralRegistry::_requireBoldBalanceCoversRedemption",
                "TroveManager::_redistributeDebtAndColl",
                "UniV3Exchange::_requireCallerIsUniV3Router",
                "UniV3Exchange::uniswapV3SwapCallback",
                "BorrowerOperations::adjustTroveInterestRate",
                "StabilityPool::sortedTroves",
                "BorrowerOperations::_requireIsShutDown",
                "WSTETHPriceFeed::_fetchPrice",
                "TroveManager",
                "BorrowerOperations",
                "ActivePool",
                "UniV3Exchange::priceToSqrtPrice",
                "UniV3Exchange::_zeroForOne",
                "TroveManager::_requireBelowMaxSharesRatio"
            ],
            "files": []
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Insufficient Gas Compensation Could Mint Bad Debt",
            "description": "The system relies on gas compensation to incentivize liquidations. If gas costs exceed compensation, liquidations become unprofitable, potentially leading to bad debt accumulation through interest and batch fee accrual. The root cause is a mismatch between fixed compensation parameters and variable Ethereum gas prices. An attacker could create a high-fee batch or low-ICR trove and profit from unbacked token minting if liquidations remain unprofitable for extended periods. While such attacks are risky and likely unprofitable due to counter-liquidation incentives, they illustrate a theoretical path to system debt inflation. Liquity has accepted this risk based on historical data and prioritization of larger troves.\n",
            "severity": "Informational",
            "location": [
                "System-wide gas compensation mechanism"
            ],
            "files": []
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "Price Deviation in Composite Price Feed",
            "description": "The RETHPriceFeed calculates RETH/USD as the product of RETH/ETH and ETH/USD prices, each with independent deviation thresholds (2% and 0.5%), allowing up to ~2.5% combined deviation. During branch shutdown due to LST de-pegging, the 1% redemption bonus may be insufficient if oracle prices lag. Additionally, the canonical rate updates every 24 hours, potentially delaying urgent redemptions. The root cause is compositional price lag and infrequent updates. An attacker could exploit timing windows during volatility, though Liquity considers this a known and acceptable risk given historical accuracy and low likelihood of maximum deviation.\n",
            "severity": "Informational",
            "location": [
                "RETHPriceFeed::_fetchPrice",
                "TroveManager::urgentRedemption"
            ],
            "files": []
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Small Redemptions Do Not Increase Base Rate",
            "description": "The function CollateralRegistry._getUpdatedBaseRateFromRedemption calculates the base rate using `redeemedBoldFraction = _redeemAmount * DECIMAL_PRECISION / _totalBoldSupply`, which rounds down. For very small redemptions (e.g., less than totalSupply / 1e18), this fraction becomes zero, so the base rate does not increase. The root cause is integer division truncation. Attackers could split redemptions to avoid fee increases, though gas costs make this impractical for meaningful amounts. Liquity acknowledges this but deems it negligible due to economic infeasibility at such small scales.\n",
            "severity": "Informational",
            "location": [
                "CollateralRegistry::_getUpdatedBaseRateFromRedemption"
            ],
            "files": []
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Upfront Fee Is Zero for Small Borrows",
            "description": "The function BorrowerOperations._calcUpfrontFee calculates fees based on debt and interest rate, but due to precision limitations, the fee is rounded to zero for small borrows. For example, borrowing less than 10,400 wei at 0.5% average interest results in no fee. Similarly, interest accrual on small troves may round to zero. The root cause is fixed-point arithmetic with insufficient precision for micro-amounts. While exploitable in theory, Liquity acknowledges this and considers it negligible, as such amounts are economically irrelevant and typically associated with zombie troves.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations::_calcUpfrontFee",
                "_calcInterest"
            ],
            "files": []
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Upfrontfee Can Bring Troves Below MCR",
            "description": "The `_applyUpfrontFee` function includes a check `_requireICRisAboveMCR()` to prevent troves from falling below the Minimum Collateralization Ratio (MCR). However, `setBatchManagerAnnualInterestRate` lacks this check, allowing batch interest adjustments to push troves below MCR. The root cause is inconsistent validation across similar functions. An attacker could exploit this by charging an upfront fee on a borderline trove, making it liquidatable. A buffer collateralization ratio (10%) was later introduced to mitigate this, preventing single-transaction exploits. However, over time, a user can still create and liquidate a trove after waiting for natural ICR decline.\n",
            "severity": "Informational",
            "location": [
                "BorrowerOperations::_applyUpfrontFee",
                "BorrowerOperations::setBatchManagerAnnualInterestRate"
            ],
            "files": []
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-1329"
                ]
            },
            "title": "rETH Address Might Change",
            "description": "The rETH token address is set once in the AddressesRegistry and cannot be updated, despite Rocket Pool's recommendation to retrieve addresses dynamically from a registry. The root cause is a hardcoded dependency on a potentially mutable address. If Rocket Pool changes the rETH address (though deemed unlikely), the system would break. Liquity has acknowledged this and confirmed with Rocket Pool that the address is not expected to change, accepting the risk as low due to integration stability.\n",
            "severity": "Informational",
            "location": [
                "AddressesRegistry"
            ],
            "files": []
        }
    ]
}