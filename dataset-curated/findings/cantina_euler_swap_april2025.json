{
    "path": "dataset-curated/reports/Cantina/cantina_euler_swap_april2025.pdf",
    "project_info": {
        "url": [
            "https://github.com/euler-xyz/euler-swap"
        ],
        "commit_id": [
            "a8cf4966e1357e205b9fe4d16432d8a24b40ad56"
        ],
        "address": null,
        "chain": "n/a",
        "compiler_version": "n/a",
        "audit_date": null,
        "project_path": {
            "euler-swap": "dataset-curated/contracts/cantina_euler_swap_april2025.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "Unsafe Token Transfer",
            "description": "The FundsLib contract uses the standard ERC-20 transfer() function to send tokens to the protocol fee recipient. This is problematic because some non-compliant ERC-20 tokens do not return a boolean value, which can cause the transfer to revert unexpectedly. The root cause is the direct use of transfer() without handling tokens that do not strictly adhere to the ERC-20 standard. An attacker could potentially exploit this by using a token that does not return a value, causing the entire transaction to fail. This could lead to denial of service for fee collection and potentially block swaps if the fee transfer is part of a critical path. The impact is medium, as it affects functionality but does not directly lead to fund loss.\n",
            "severity": "Medium",
            "location": [
                "FundsLib.sol#L82"
            ],
            "files": []
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Incorrect Parameter Ordering in Curve Evaluation",
            "description": "In the EulerSwap contract, the call to CurveLib.f is made with incorrect parameter ordering in some branches of the logic, specifically inverting px and py and x0 and y0. This causes asymmetry in swap calculations, where an exact-out swap followed by an exact-in reversal does not restore the original reserves. The root cause is a logic error in parameter passing. An attacker could exploit this by performing a sequence of swaps that take advantage of the inconsistent state, potentially leading to unexpected slippage or loss of funds for users relying on symmetric reversibility. The impact is medium due to potential economic loss from incorrect swap outcomes.\n",
            "severity": "Medium",
            "location": [
                "QuoteLib.sol#L213"
            ],
            "files": []
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-372"
                ]
            },
            "title": "Removing pools with swapAndPop() in EulerSwapFactory.uninstall() corrupts stored indexes",
            "description": "When uninstalling a pool via EulerSwapFactory.uninstall(), the swapAndPop pattern is used to remove pool addresses from arrays, but the stored index in eulerAccountState for the last pool is not updated. This leads to incorrect indexing, causing out-of-bounds access when the last pool is uninstalled. The root cause is the failure to maintain index consistency after array mutation. An attacker could exploit this by triggering the uninstall of the last pool after another has been removed, causing the transaction to revert due to OOB access. This results in a denial of service, preventing legitimate pool uninstalls. The impact is medium due to disruption of contract functionality.\n",
            "severity": "Medium",
            "location": [
                "EulerSwapFactory.sol#L152-L156",
                "EulerSwapFactory.sol#L189-L192",
                "EulerSwapFactory.sol#L178-"
            ],
            "files": []
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Potential Re-Entrancy via uniswapV2Call Hook in _beforeSwap",
            "description": "The _beforeSwap function in UniswapHook accesses mutable state (s.reserve0 and s.reserve1) before external calls, and the main swap function does not follow the checks-effects-interactions pattern. Since the state is only updated after the callback, a malicious contract can re-enter swap() from within uniswapV2Call and trigger _beforeSwap again with stale state. The root cause is the lack of a reentrancy guard. An attacker could exploit this to manipulate reserve values and potentially drain funds or cause incorrect state transitions. The impact is low because the actual damage depends on downstream logic, but it introduces a critical anti-pattern in a DeFi primitive.\n",
            "severity": "Low",
            "location": [
                "UniswapHook.sol#L68"
            ],
            "files": []
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-431"
                ]
            },
            "title": "Unrestricted Donations via Uniswap V4 Integration with EulerSwap Hook",
            "description": "EulerSwap, acting as a Uniswap V4 hook, does not override or restrict the _beforeDonate function. While donations do not affect EulerSwap's internal reserves, they alter the underlying Uniswap V4 pool state, leading to potential inconsistencies. The root cause is the lack of explicit rejection of donation hooks. An attacker could donate tokens directly to the pool, affecting liquidity accounting and potentially breaking assumptions in EulerSwap's logic. The impact is low as it does not directly lead to fund loss but may cause unexpected behavior in pool state.\n",
            "severity": "Low",
            "location": [
                "UniswapHook.sol#L157"
            ],
            "files": []
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Fee collection in FundsLib.depositAssets() reverts when the protocol fee recipient is the zero address",
            "description": "The depositAssets function in FundsLib attempts to transfer fees to the protocol fee recipient without checking if it is the zero address. If the recipient is address(0) and the fee amount is non-zero, the transfer will revert for most ERC-20 tokens (e.g., OpenZeppelin's ERC20). The root cause is the absence of a zero-address check. An attacker could set the fee recipient to zero, causing all future swaps to revert, resulting in a denial of service. The impact is low as it does not lead to fund loss but disrupts protocol functionality.\n",
            "severity": "Low",
            "location": [
                "FundsLib.sol#L78-L86"
            ],
            "files": [
                "euler-swap/src/libraries/FundsLib.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Checks in EulerSwap.activate() prevent deploying pools with a one-sided curve",
            "description": "The activate function performs checks that make it impossible to deploy pools with one reserve set to zero, even when valid (e.g., x0 = 0). The checks call CurveLib.verify with modified reserves, but when reserve0 is 0, both calls use the same arguments, causing one to fail. The root cause is incorrect logic in the boundary checks. This prevents valid deployment configurations, limiting the protocol's flexibility. The impact is low as it is a usability limitation rather than a security flaw, but it restricts intended functionality.\n",
            "severity": "Low",
            "location": [
                "EulerSwap.sol#L87-L89"
            ],
            "files": [
                "euler-swap/src/EulerSwap.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-369"
                ]
            },
            "title": "Division by zero occurs for CurveLib.fInverse() due to c == 0 edge case",
            "description": "The fInverse function in CurveLib divides by 2*c without checking if c is zero. When c == 0 (e.g., cx = 0 and y == y0), this causes a division by zero and reverts. The root cause is missing edge case handling. An attacker could trigger this by creating a swap that moves to the f() curve when c == 0, causing the transaction to revert. This leads to denial of service for certain swap paths. The impact is low as it affects specific edge cases but can disrupt expected functionality.\n",
            "severity": "Low",
            "location": [
                "CurveLib.sol#L85-L88",
                "QuoteLib.sol#L181-L192"
            ],
            "files": [
                "euler-swap/src/libraries/CurveLib.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-190"
                ]
            },
            "title": "Calculation of term1 in CurveLib.fInverse() could overflow int256.max with extreme prices",
            "description": "The term1 calculation in fInverse uses Math.mulDiv with py, (y - y0), and px, which can result in a value exceeding int256.max when px is very small and py is very large. The root cause is insufficient bounds checking on input prices. An attacker could exploit this by setting extreme price values, causing the int256 cast to revert. This would prevent certain swaps from completing, leading to denial of service. The impact is low as it requires extreme and likely unrealistic price values, but it is still a potential failure point.\n",
            "severity": "Low",
            "location": [
                "CurveLib.sol#L55"
            ],
            "files": [
                "euler-swap/src/libraries/CurveLib.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-1099"
                ]
            },
            "title": "Missing Internal Function Naming Convention",
            "description": "Internal functions in contracts like EulerSwapFactory (e.g., uninstall, swapAndPop) do not use the underscore prefix convention, making it unclear which functions are internal. The root cause is inconsistent coding style. While this does not introduce a direct security vulnerability, it reduces code readability and increases the risk of accidental misuse or incorrect assumptions by developers and auditors. The impact is informational, as it pertains to code quality and maintainability rather than security.\n",
            "severity": "Informational",
            "location": [],
            "files": [
                "euler-swap/src/EulerSwapFactory.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "Incompatibility with uniswapV2Call Interface Expectations",
            "description": "EulerSwap does not implement token0() and token1() getters, which are expected by contracts using the uniswapV2Call flash swap pattern. Additionally, it is not deployed via a UniswapV2Factory, so factory-based address validation fails. The root cause is incomplete interface compatibility. This breaks integration with existing flash swap routers and arbitrage bots that expect standard Uniswap V2 behavior. The impact is informational, as it limits interoperability but does not introduce a security flaw.\n",
            "severity": "Informational",
            "location": [
                "EulerSwap.sol#L163"
            ],
            "files": [
                "euler-swap/src/EulerSwap.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1041"
                ]
            },
            "title": "maxWithdraw in QuoteLib.calcLimits() double-counts deposited assets",
            "description": "The calcLimits function adds deposited assets to maxWithdraw after already including them in cash, leading to double-counting. However, a subsequent check ensures maxWithdraw does not exceed cash, which mitigates the issue. The root cause is redundant logic. While the double-counting is incorrect, it does not result in incorrect final values due to the override. The impact is informational, as it represents a code inefficiency and potential confusion rather than a functional bug.\n",
            "severity": "Informational",
            "location": [
                "QuoteLib.sol#L98-L103"
            ],
            "files": [
                "euler-swap/src/libraries/QuoteLib.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ]
            },
            "title": "Minor improvements to code and comments",
            "description": "Several minor code improvements are suggested, including using OpenZeppelin's safe math functions (e.g., Math.sqrt with rounding, Math.ceilDiv), removing redundant checks, simplifying expressions, and improving naming. The root cause is suboptimal code style and readability. These changes improve gas efficiency, clarity, and safety but do not address critical vulnerabilities. The impact is informational, focusing on code quality and maintainability.\n",
            "severity": "Informational",
            "location": [],
            "files": []
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "UniswapHook._beforeInitialize() is never reached during normal initialization",
            "description": "The _beforeInitialize function in UniswapHook is intended to prevent re-initialization by checking _poolKey.tickSpacing == 0, but it is never called due to the noSelfCall modifier in Uniswap V4. The hook is activated before initialization, so the check is ineffective. The root cause is a misunderstanding of the hook call flow. This leads to dead code and incorrect assumptions about initialization safety. The impact is informational, as the functionality works as intended via other mechanisms, but the code is misleading.\n",
            "severity": "Informational",
            "location": [
                "UniswapHook.sol#L129-L136",
                "Hooks.sol#L170-L175"
            ],
            "files": [
                "euler-swap/src/UniswapHook.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Additional fuzz tests for CurveLib",
            "description": "The report suggests adding fuzz tests for f() and fInverse() to detect reverts and overflows, and differential tests against whitepaper equations. The root cause is insufficient test coverage for edge cases. While not a vulnerability, this recommendation improves confidence in the correctness of critical mathematical functions. The impact is informational, aimed at enhancing testing and reliability for future development.\n",
            "severity": "Informational",
            "location": [
                "CurveLib.sol"
            ],
            "files": [
                "euler-swap/src/libraries/CurveLib.sol"
            ]
        }
    ]
}