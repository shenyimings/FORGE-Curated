{
    "path": "dataset-curated/reports/TrailofBits/2025-01-beethovenx-sonicstaking-securityreview.pdf",
    "project_info": {
        "url": [
            "https://github.com/beethovenxfi/sonic-staking"
        ],
        "commit_id": [
            "4fde3014f287f2ba38d559a23317a892e92cd3e6"
        ],
        "address": [
            "0xE5DA20F15420aD15DE0fa650600aFc998bbE3955"
        ],
        "chain": "Sonic",
        "compiler_version": "n/a",
        "audit_date": "2025-01-16",
        "project_path": {
            "sonic-staking": "dataset-curated/contracts/2025-01-beethovenx-sonicstaking-securityreview.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Global pause method will fail if a subcomponent is already paused",
            "description": "The internal pause methods in the SonicStaking contract, such as _setUndelegatePaused, revert when attempting to set a pause flag to its current value due to a require statement that checks for a change in the pause state. This design causes the global pause function to fail if any of its targeted subcomponents (e.g., undelegate, withdraw) are already paused. The root cause is the placement of the require check inside internal functions that are called by the global pause method, which prevents idempotent behavior. An attacker or operational error could trigger a scenario where a partial pause is already in place, and a subsequent attempt to fully pause the system during an emergency fails. This could delay or prevent a proper incident response, leaving the system exposed during a critical period, thus undermining the reliability of the emergency pause mechanism.\n",
            "severity": "Low",
            "location": [
                "src/SonicStaking.sol::setUndelegatePaused",
                "src/SonicStaking.sol::pause"
            ],
            "files": [
                "sonic-staking/src/SonicStaking.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Risk of read-only reentrancy via Balancer pools",
            "description": "The internal _withdraw function transfers native tokens to a user-controlled address before emitting the Withdrawn event, and during the external call, the recipient can invoke a Balancer pool that reads the current rate via the getRate method. Although the contract has reentrancy guards for state-modifying functions, the getRate method is unprotected and can be called during the withdrawal, leading to out-of-order event emissions. The root cause is the lack of reentrancy protection on a read-only function that is indirectly exposed during a sensitive state transition. An attacker could exploit this by deploying a contract that withdraws funds and then calls a Balancer pool, causing the getRate call to emit events before the Withdrawn event. Off-chain monitoring tools that rely on event ordering may misinterpret the sequence, leading to incorrect state tracking or failed automated responses, potentially disrupting operational integrity and incident detection.\n",
            "severity": "Informational",
            "location": [
                "src/SonicStaking.sol::withdraw",
                "src/SonicStaking.sol::getRate"
            ],
            "files": [
                "sonic-staking/src/SonicStaking.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-311"
                ],
                "3": [
                    "CWE-312"
                ],
                "4": [
                    "CWE-313"
                ]
            },
            "title": "Credentials are persisted in the GitHub CI workflow",
            "description": "The GitHub Actions workflow file (.github/workflows/test.yml) uses the actions/checkout action without disabling the persist-credentials option, which by default stores Git credentials in the local config. This could lead to accidental exposure if a future CI step uploads build artifacts or logs that include the .git directory. The root cause is the omission of the persist-credentials: false configuration in the workflow, which is a known security anti-pattern in CI/CD pipelines. An attacker who gains access to artifact storage or logs could extract these credentials and gain unauthorized access to the repository. While the immediate risk is low, especially if no secrets are otherwise exposed, this represents a data exposure vulnerability that could be exploited in combination with other weaknesses, potentially leading to supply chain compromise or unauthorized code changes.\n",
            "severity": "Informational",
            "location": [
                ".github/workflows/test.yml"
            ],
            "files": [
                "sonic-staking/.github/workflows/test.yml"
            ]
        }
    ]
}