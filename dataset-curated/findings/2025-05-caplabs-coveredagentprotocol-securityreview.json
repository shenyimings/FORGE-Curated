{
    "path": "dataset-curated/reports/TrailofBits/2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "project_info": {
        "url": "https://github.com/cap-labs-dev/cap-contracts",
        "commit_id": [
            "56819219e935470271a03d4e3415fcbe810e6b0b"
        ],
        "address": "n/a",
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-03-03",
        "project_path": {
            "cap-contracts": "dataset-curated/contracts/2025-05-caplabs-coveredagentprotocol-securityreview.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing input validation in FeeAuction.buy allows payment without asset transfer",
            "description": "The FeeAuction.buy function does not validate the _assets parameter, allowing users to call the function with an empty array or token addresses that have zero balance in the contract. This causes the transaction to proceed without transferring any assets to the buyer. The root cause is the lack of input validation before processing the asset transfer and payment. An attacker or user could exploit this by calling buy with an empty _assets array or including tokens not held by the contract, resulting in a successful payment without receiving any assets. The impact is a loss of funds for the buyer, as they pay the full auction price but receive nothing in return.\n",
            "severity": "Medium",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::buy#64-80",
                "contracts/feeAuction/FeeAuction.sol::_transferOutAssets#113-124",
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Incorrect oracle staleness period leads to price feed DoS",
            "description": "The PriceOracle contract uses a single staleness period for all price feeds, despite different assets having different update frequencies (e.g., stablecoins updated every 24 hours vs. ETH/BTC every hour). This misconfiguration causes the oracle to either reject valid prices from slow-updating assets or accept stale prices from fast-updating ones. The root cause is the use of a global staleness threshold without per-asset customization. An attacker or system failure could exploit this by manipulating the timing of price updates, leading to denial of service in price retrieval. The impact is that critical functions relying on price feeds may revert or operate with incorrect data, disrupting lending, borrowing, and liquidation mechanisms.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/PriceOracle.sol::__PriceOracle_init_unchained#21-25",
                "contracts/deploy/service/DeployInfra.sol::_deployInfra#36-40",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol",
                "cap-contracts/contracts/deploy/service/DeployInfra.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The NetworkMiddleware.registerVault function does not check if a vault has already been registered for a given agent, allowing duplicate entries. This leads to the same vault's delegation being counted multiple times when calculating coverage. The root cause is the lack of deduplication or uniqueness checks during vault registration. An attacker or user could exploit this by re-registering the same vault multiple times, especially after a transaction failure and replacement. The impact is an inflated delegation value, which can cause incorrect risk assessment and lead to under-collateralized liquidations, resulting in potential loss of funds for the senior tranche.\n",
            "severity": "Medium",
            "location": [
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::registerVault#58-69",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::coverage#195-206",
                "Delegation.sol::addVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "StakedCap yield distribution DoS through timer manipulation",
            "description": "The StakedCap contract's notify function is permissionless and resets the lastNotify timestamp upon any token deposit, which affects the lockedProfit calculation. An attacker can repeatedly call notify with minimal token transfers to reset the timer, keeping the elapsed time small and preventing yield from unlocking. The root cause is the lack of rate-limiting or time-based protection on the notify function. This allows an attacker to indefinitely delay the vesting of rewards. The impact is a denial of service for legitimate stakers who cannot withdraw their earned yield, effectively locking their rewards permanently.\n",
            "severity": "Medium",
            "location": [
                "contracts/token/StakedCap.sol::notify#58-69",
                "contracts/token/StakedCap.sol::lockedProfit#73-85",
                "contracts/token/StakedCap.sol::totalAssets#L73-85",
                "StakedCap.sol"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "Inconsistent balance tracking in vault creates DoS for asset borrowing",
            "description": "The Vault contract uses inconsistent accounting methods: some functions rely on totalSupplies while others use direct balanceOf checks. The burn function reduces totalSupplies without validating against actual token balances, allowing totalSupplies to drop below totalBorrows. This violates the invariant that total supply must be >= total borrows. The root cause is the lack of synchronization between accounting variables and real token balances. An attacker can exploit this by transferring tokens directly to the vault and then burning more than the accounted supply, creating a negative available balance. The impact is a system-wide denial of service for borrowing that specific asset, even if physical tokens are available.\n",
            "severity": "High",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::burn#111-124",
                "contracts/vault/Vault.sol::availableBalance#206-209",
                "contracts/lendingPool/libraries/ViewLogic.sol::maxBorrowable#83-91",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/lendingPool/libraries/ViewLogic.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ]
            },
            "title": "Unsafe asset removal without borrow validation",
            "description": "The removeAsset function in VaultLogic allows removing an asset from the vault's list without checking if there are outstanding borrows. This can lead to a state where borrowers cannot repay loans because the asset is no longer recognized by the system. The root cause is the absence of a pre-removal validation check for totalBorrows. An admin or attacker with access could remove an asset with active loans, rendering repayment functions ineffective. The impact is that borrowers' funds become locked, they cannot clear their debt, and the system enters an inconsistent state.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::removeAsset#192-208",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Initial auction start price can be lower than minimum start price",
            "description": "The setStartPrice function in FeeAuction does not validate that the new start price is at least the minStartPrice. This allows an admin to set a start price below the intended minimum, potentially enabling users to acquire assets at negligible cost. The root cause is the lack of input validation in the function. An attacker with admin access or a compromised admin could exploit this to drain value from the protocol. The impact is economic loss due to unauthorized low-price asset acquisition, undermining the auction's intended price discovery mechanism.\n",
            "severity": "Low",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::setStartPrice#85-89",
                "FeeAuction.sol"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Immediate liquidation possible when reducing an agent\u2019s liquidation threshold",
            "description": "The modifyAgent function allows reducing an agent\u2019s liquidation threshold without checking if the agent is already below the new threshold. This could immediately trigger liquidation of the agent\u2019s position. The root cause is the lack of a safety check before updating the threshold. An admin could unknowingly or maliciously set a threshold that puts an agent into a liquidatable state. The impact is unfair liquidation of agents\u2019 positions, leading to loss of collateral and potential disputes or loss of trust in the system.\n",
            "severity": "Informational",
            "location": [
                "contracts/delegation/Delegation.sol::modifyAgent#227-244",
                "Lender.sol::setLiquidationThreshold"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "FeeAuction\u2019s buy function allows purchasing at sub-optimal prices by adding tokens during an active auction",
            "description": "The FeeAuction.buy function does not fix the asset amounts at the start of the auction. An attacker can call realizeInterest on FractionalReserve to add more tokens to the auction and then immediately buy all tokens at the current (low) price, effectively getting the added tokens for free. The root cause is the dynamic inclusion of newly added tokens in the auction without price adjustment. This behavior creates undefined and exploitable auction dynamics. The impact is unfair profit for the attacker and loss of revenue for the protocol, especially if MEV searchers are not active to arbitrage the opportunity.\n",
            "severity": "Low",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::buy",
                "contracts/feeAuction/FeeAuction.sol::_transferOutAssets#113-124",
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emissions for critical parameter changes in VaultAdapter",
            "description": "The setSlopes and setLimits functions in VaultAdapter do not emit events when critical parameters are changed. This makes it difficult to monitor or detect changes to interest rate models, which are essential for protocol transparency and security. The root cause is the omission of event emissions in admin-controlled functions. An attacker or compromised admin could change parameters without leaving an on-chain trace. The impact is reduced auditability and increased risk of undetected malicious or erroneous configuration changes.\n",
            "severity": "Informational",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::setSlopes#51-56",
                "contracts/oracle/libraries/VaultAdapter.sol::setLimits#60-70",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "VaultAdapter\u2019s setSlopes function permits zero or maximum kink values that cause division by zero",
            "description": "The setSlopes function allows setting the kink parameter to 0 or 1e27, which leads to division by zero in interest rate calculations. This would cause the rate calculation to revert, breaking core protocol functionality. The root cause is the lack of input validation on the kink value. An attacker with admin access or a misconfigured input could set these values, causing the system to fail on rate queries. The impact is a denial of service for any function relying on interest rate calculations, disrupting borrowing and lending.\n",
            "severity": "Informational",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::setSlopes#51-56",
                "contracts/oracle/libraries/VaultAdapter.sol::rate#104-105",
                "contracts/oracle/libraries/VaultAdapter.sol::utilizationMultiplier#87-88",
                "VaultAdapter.sol::setSlopes"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Unvalidated _vault address in VaultAdapter allows interest rate manipulation",
            "description": "The rate function in VaultAdapter accepts any _vault address without validation and makes external calls to it. An attacker can pass a malicious contract that returns manipulated utilization values, which are then stored and used in interest rate calculations. The root cause is the lack of access control or allowlist validation on the _vault parameter. This allows an attacker to inflate or deflate interest rates across the protocol. The impact is financial loss for borrowers or lenders due to incorrect interest accrual, and potential manipulation of the entire lending market.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::rate#26-49",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Fee auction allows buying zero assets, leading to front-running attacks",
            "description": "The FeeAuction.buy function does not validate that assets are actually transferred before accepting payment. A malicious actor can front-run a legitimate buy transaction, depleting the asset balance, and causing the victim's transaction to pay without receiving anything. The root cause is the lack of a check ensuring non-zero asset transfer before payment. This creates a race condition exploitable via MEV. The impact is financial loss for victims who pay double the price (due to price doubling after each successful buy) but receive no assets.\n",
            "severity": "High",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::buy",
                "contracts/feeAuction/FeeAuction.sol::_transferOutAssets#113-124",
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "The protocol exhibits a critical discrepancy between how an agent's health factor is calculated and how slashable collateral is determined. This inconsistency arises because the health factor evaluation uses all current collateral, including recent deposits, while the slashing mechanism only considers deposits made before the most recent epoch or the agent's last borrow time. The root cause is the misalignment in time bases used by the coverage and slashTimestamp functions. An attacker can exploit this by adding fresh collateral just before a liquidation event to improve their health factor, knowing that these new deposits will not be subject to slashing. As a result, during liquidation, the protocol cannot recover sufficient collateral from these recent deposits, leading to a shortfall that the protocol must absorb. This undermines the financial stability and security model of the system, potentially resulting in significant protocol losses, especially if all existing delegations are from the current epoch.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/Delegation.sol#L73-L76",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L195-L206",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Reward distribution enables front-running attacks and reward siphoning",
            "description": "The reward distribution mechanism allocates rewards to all vaults backing an agent at the time of loan repayment without considering the duration of their delegation. This creates a timing vulnerability where opportunistic actors can monitor pending repayment transactions in the mempool and front-run them by adding their own collateral just before repayment. The root cause is the lack of time-based eligibility criteria for reward distribution. By doing so, these actors can capture a disproportionate share of the accrued interest rewards despite having provided capital for only a minimal period. This allows them to systematically siphon rewards from long-term backers who actually bore the lending risk over time. The impact is an unfair redistribution of rewards that disincentivizes long-term participation and undermines the economic fairness of the protocol.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/NetworkMiddleware.sol",
                "contracts/delegation/Delegation.sol",
                "StakedCap.sol::distributeRewards"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol",
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Unaccounted external vault investment losses can create withdrawal shortfalls",
            "description": "The protocol invests idle assets in external vaults such as Yearn but fails to account for losses incurred during divestment. When the protocol changes the address of an external vault, it divests from the current vault regardless of any losses, and these losses are not tracked or reflected in the system's accounting. The root cause is the absence of loss tracking during divestment operations. This creates a \"first out\" advantage where early withdrawers can redeem their full amounts while later withdrawers may face shortfalls because the physical assets no longer exist to back their balances. The protocol continues to report the original total supply despite having fewer physical tokens, leading to an inability to fulfill withdrawal requests. This threatens the solvency of the system and creates an unfair distribution of losses among users.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol",
                "contracts/vault/FractionalReserve.sol",
                "FractionalReserve.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Wrong capTokenDecimals value used in StakedCapAdapter.price causes inaccurate prices",
            "description": "The StakedCapAdapter library incorrectly uses the decimal count (e.g., 18) instead of the corresponding scaling factor (10^18) in price calculations, leading to wildly inaccurate prices. The root cause is a fundamental misunderstanding of how decimal scaling works in the price function: it passes the decimal count to convertToAssets, which expects a share amount, and divides by the decimal count rather than the scaling factor. This results in price miscalculations by several orders of magnitude. An attacker can exploit this by observing the incorrect prices and executing trades that take advantage of the disparity between the reported and actual values. The impact includes potential manipulation of minting and burning operations, incorrect valuation of collateral, and possible insolvency due to erroneous price feeds being used in critical financial operations.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/libraries/StakedCapAdapter.sol#L15-L21",
                "StakedCapAdapter.sol::price"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/StakedCapAdapter.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Liquidation mechanism can be permanently disabled by misconfigured grace and expiry periods",
            "description": "The Lender contract does not validate that the grace period is less than the expiry period during initialization. If grace >= expiry, the liquidation mechanism becomes impossible to trigger because the validateLiquidation function requires block.timestamp to be both greater than start+grace and less than start+expiry, which cannot be satisfied simultaneously. The root cause is the lack of input validation for critical configuration parameters. Since these parameters cannot be reset after deployment, a misconfiguration would permanently disable liquidations. An attacker or negligent admin could deploy the contract with such invalid parameters, preventing any liquidation from occurring even when agents are severely undercollateralized. This leads to the accumulation of bad debt and potentially results in protocol insolvency as unhealthy positions remain outstanding indefinitely.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol#L98-L102",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Oracle update front-running allows extraction of value from vaults",
            "description": "The protocol's minting and burning functions are vulnerable to oracle sandwiching attacks due to the use of current oracle prices without protection against timing manipulation. The root cause is the lack of safeguards such as fees, TWAPs, or circuit breakers around oracle updates. An attacker can monitor pending Chainlink oracle updates and front-run them by depositing assets before the price update and withdrawing after, profiting from the price difference. For example, when the USDC price drops, the attacker deposits at the old price and withdraws at the new, higher effective rate, extracting value from the protocol. The impact is a direct loss of funds from the protocol treasury proportional to the size of the oracle update, exploiting natural market movements rather than oracle manipulation, which undermines the economic integrity of the system.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/Vault.sol",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/oracle/Oracle.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Asset removal does not reset isBorrowing flag for agents",
            "description": "When an asset is removed from the system, the validation logic only checks if the principal debt is repaid but does not clear the agent's isBorrowing flag for that asset. The root cause is incomplete state cleanup during asset removal. If the same reserve ID is later reused for a different asset, agents who previously borrowed the old asset will have their isBorrowing flag incorrectly set to true for the new asset, even though they never borrowed it. This leads to accounting inconsistencies that can affect health factor calculations, borrowing limits, and liquidation eligibility. The impact includes incorrect risk assessments for agents and potential denial of service for legitimate operations due to false borrowing status, undermining the reliability of the protocol's financial tracking mechanisms.\n",
            "severity": "Informational",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Invalid network registration in Delegation.registerNetwork can cause DoS",
            "description": "The registerNetwork function in the Delegation contract lacks validation for network addresses and provides no way to remove registered networks. The root cause is insufficient input validation and missing administrative functions for error correction. If an invalid address (e.g., address(0)) or a non-compliant contract is registered, key functions like coverage and slashableCollateral will permanently revert when attempting external calls to the invalid network. This results in a denial of service for the affected agent, locking them out of protocol functionality indefinitely. Since there is no mechanism to unregister networks or remove the agent, the issue cannot be resolved post-deployment, making it a permanent operational failure for the affected user.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L249-L258",
                "Delegation.sol::registerNetwork"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Lack of verification on ERC4626 vault withdrawal amounts",
            "description": "The divest function reduces the recorded loaned amount before the actual withdrawal occurs and does not verify the return value from the ERC4626 vault's withdraw call. The root cause is the failure to validate the actual amount received versus the expected divestAmount. If the vault returns fewer assets than requested (due to losses or other factors), the accounting system still assumes the full amount was withdrawn, creating a discrepancy between recorded and actual assets. While current integrations with Yearn vaults prevent losses by reverting, future integration with other ERC4626 vaults that allow losses could lead to systematic asset shortfalls. The impact is a gradual erosion of protocol solvency as unaccounted losses accumulate over time.\n",
            "severity": "Informational",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol#L63-L66",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Agent LTV can be configured equal to or higher than liquidation threshold",
            "description": "The addAgent and modifyAgent functions allow setting an agent's loan-to-value (LTV) ratio equal to or higher than its liquidation threshold. The root cause is missing validation that ensures LTV is strictly less than the liquidation threshold. This configuration leads to contradictory economic states: if LTV >= liquidation threshold, an agent could either be immediately liquidatable upon borrowing or never reach liquidation even when undercollateralized. The impact is a breakdown of the risk management system, exposing the protocol to uncontrolled borrowing and potential insolvency. Even if unintended, a simple administrative error could create such a dangerous configuration, undermining the core collateralization safeguards of the protocol.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L202-L209",
                "Lender.sol::setLTV"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol",
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "ZapOFTComposer._lzCompose may fail with USDT",
            "description": "The _lzCompose function uses the standard approve method for ERC20 tokens without handling the special case of tokens like USDT that do not allow changing a non-zero approval to another non-zero value. The root cause is the failure to use SafeERC20's forceApprove function, despite importing the library. This can cause transactions to fail when users attempt to create zaps with multiple USDT inputs, as the approve call will revert if an existing non-zero allowance is present. The impact is a denial of service for users trying to interact with USDT in zap operations, reducing the usability and reliability of the protocol for one of the most widely used stablecoins, despite a safe alternative being available in the codebase.\n",
            "severity": "Informational",
            "location": [
                "contracts/zap/ZapOFTComposer.sol#L39-L55",
                "ZapOFTComposer.sol::_lzCompose"
            ],
            "files": [
                "cap-contracts/contracts/zap/ZapOFTComposer.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Fee auction allows assets to be purchased for free",
            "description": "The Dutch auction mechanism in the FeeAuction contract allows the price to decay linearly to zero over time, enabling users to claim fee tokens for free when the auction expires without bids. The root cause is the lack of a minimum price floor in the currentPrice function. Although this behavior may be intentional (as suggested by code comments), it represents a value leakage risk for the protocol. Attackers can wait until the auction ends and then purchase valuable protocol fees at zero cost. The impact is a direct loss of revenue for the protocol, undermining the economic sustainability of the fee collection mechanism and potentially discouraging participation in earlier, higher-priced stages of the auction.\n",
            "severity": "Informational",
            "location": [
                "contracts/feeAuction/FeeAuction.sol#L52-L57",
                "FeeAuction.sol"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Small borrows can create economically unviable liquidatable positions leading to bad debt accumulation",
            "description": "The borrow function allows positions as small as 1 wei without a minimum borrow amount check. The root cause is the absence of economic viability safeguards in the borrowing logic. When such tiny positions become undercollateralized, the gas costs of liquidation exceed the liquidation value plus bonus, making it unprofitable for liquidators to act. This leads to the accumulation of bad debt in the system, as these positions remain outstanding indefinitely. While the impact is limited by the number of borrowable assets per agent, it still introduces a persistent solvency risk. The protocol effectively subsidizes spammy or malicious small borrowing behavior, weakening the overall health of the lending market.\n",
            "severity": "Low",
            "location": [
                "contracts/lendingPool/Lender.sol#L65-L69",
                "Lender.sol::borrow"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Interest rate manipulation through frequent mints and burns",
            "description": "The interest rate calculation depends on the elapsed time since the last update, but this timestamp is reset on every mint, burn, or borrow operation. The root cause is the vulnerability to timestamp manipulation via frequent zero-value or low-value transactions. An attacker can artificially reduce the elapsed time used in utilization multiplier calculations by performing repeated operations, thereby dampening interest rate increases during high utilization periods. This is especially severe when zero-value mints or burns are allowed, as they enable manipulation with minimal capital. The impact is distorted interest rates that fail to reflect true market conditions, allowing borrowers to avoid paying appropriate risk premiums and undermining the protocol's risk management and capital allocation mechanisms.\n",
            "severity": "Low",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol#L289-L293",
                "contracts/oracle/libraries/VaultAdapter.sol#L87-L88",
                "Minter.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol",
                "cap-contracts/contracts/vault/Minter.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Protocol lacks bad debt management mechanisms, risking permanent insolvency",
            "description": "The protocol has no mechanism to handle accumulated bad debt from failed or uneconomical liquidations. The root cause is the absence of insurance or loss-socialization mechanisms. When bad debt accumulates\u2014especially in conjunction with small, unviable borrowing positions\u2014the loss is not distributed fairly. Instead, it creates a \"last withdrawer\" problem where early withdrawers redeem their full amounts while later users face shortfalls as the protocol runs out of physical tokens. This leads to permanent insolvency and unfair loss distribution. The impact is a systemic risk to user funds, where the timing of withdrawal determines whether a user loses money, undermining trust in the protocol's solvency guarantees.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/Lender.sol",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Reward distribution can be tricked by front-running notify calls",
            "description": "The notify function in StakedCap updates the reward distribution state based on current balances without protecting against front-running. The root cause is the lack of time-based or anti-sybil mechanisms in reward allocation. An attacker can monitor mempool transactions and deposit a large amount of CAP tokens immediately before a notify call, thereby capturing a disproportionate share of the newly distributed rewards. After receiving the rewards, the attacker can withdraw, having gained value without long-term commitment. This undermines the incentive structure for genuine long-term stakers and enables sophisticated actors to exploit timing advantages for unfair profit extraction, reducing the fairness and effectiveness of the reward system.\n",
            "severity": "Informational",
            "location": [
                "contracts/token/StakedCap.sol#L58-L69",
                "StakedCap.sol::notifyReward"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        }
    ]
}