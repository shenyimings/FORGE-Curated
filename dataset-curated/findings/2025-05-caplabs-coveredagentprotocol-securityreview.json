{
    "path": "dataset-curated/reports/TrailofBits/2025-05-caplabs-coveredagentprotocol-securityreview.pdf",
    "project_info": {
        "url": "https://github.com/cap-labs-dev/cap-contracts",
        "commit_id": [
            "13a1b06cb4a008248e05527af1b189c58761b976",
            "56819219e935470271a03d4e3415fcbe810e6b0b"
        ],
        "address": "n/a",
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-03-03",
        "project_path": {
            "cap-contracts": "dataset-curated/contracts/2025-05-caplabs-coveredagentprotocol-securityreview.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing input validation in FeeAuction.buy allows payment without asset transfer",
            "description": "The FeeAuction.buy function does not validate the _assets parameter, allowing users to call the function with an empty array or token addresses that have zero balance in the contract. This causes the transaction to proceed without transferring any assets to the buyer. The root cause is the lack of input validation before processing the asset transfer and payment. An attacker or user could exploit this by calling buy with an empty _assets array or including tokens not held by the contract, resulting in a successful payment without receiving any assets. The impact is a loss of funds for the buyer, as they pay the full auction price but receive nothing in return.\n",
            "severity": "Medium",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::buy#64-80",
                "contracts/feeAuction/FeeAuction.sol::_transferOutAssets#113-124",
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Incorrect oracle staleness period leads to price feed DoS",
            "description": "The PriceOracle contract uses a single staleness period for all price feeds, despite different assets having different update frequencies (e.g., stablecoins updated every 24 hours vs. ETH/BTC every hour). This misconfiguration causes the oracle to either reject valid prices from slow-updating assets or accept stale prices from fast-updating ones. The root cause is the use of a global staleness threshold without per-asset customization. An attacker or system failure could exploit this by manipulating the timing of price updates, leading to denial of service in price retrieval. The impact is that critical functions relying on price feeds may revert or operate with incorrect data, disrupting lending, borrowing, and liquidation mechanisms.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/PriceOracle.sol::__PriceOracle_init_unchained#21-25",
                "contracts/deploy/service/DeployInfra.sol::_deployInfra#36-40",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The NetworkMiddleware.registerVault function does not check if a vault has already been registered for a given agent, allowing duplicate entries. This leads to the same vault's delegation being counted multiple times when calculating coverage. The root cause is the lack of deduplication or uniqueness checks during vault registration. An attacker or user could exploit this by re-registering the same vault multiple times, especially after a transaction failure and replacement. The impact is an inflated delegation value, which can cause incorrect risk assessment and lead to under-collateralized liquidations, resulting in potential loss of funds for the senior tranche.\n",
            "severity": "Medium",
            "location": [
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::registerVault#58-69",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol::coverage#195-206",
                "Delegation.sol::addVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "StakedCap yield distribution DoS through timer manipulation",
            "description": "The StakedCap contract's notify function is permissionless and resets the lastNotify timestamp upon any token deposit, which affects the lockedProfit calculation. An attacker can repeatedly call notify with minimal token transfers to reset the timer, keeping the elapsed time small and preventing yield from unlocking. The root cause is the lack of rate-limiting or time-based protection on the notify function. This allows an attacker to indefinitely delay the vesting of rewards. The impact is a denial of service for legitimate stakers who cannot withdraw their earned yield, effectively locking their rewards permanently.\n",
            "severity": "Medium",
            "location": [
                "contracts/token/StakedCap.sol::notify#58-69",
                "contracts/token/StakedCap.sol::lockedProfit#73-85",
                "contracts/token/StakedCap.sol::totalAssets#L73-85",
                "StakedCap.sol"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-240"
                ]
            },
            "title": "Inconsistent balance tracking in vault creates DoS for asset borrowing",
            "description": "The Vault contract uses inconsistent accounting methods: some functions rely on totalSupplies while others use direct balanceOf checks. The burn function reduces totalSupplies without validating against actual token balances, allowing totalSupplies to drop below totalBorrows. This violates the invariant that total supply must be >= total borrows. The root cause is the lack of synchronization between accounting variables and real token balances. An attacker can exploit this by transferring tokens directly to the vault and then burning more than the accounted supply, creating a negative available balance. The impact is a system-wide denial of service for borrowing that specific asset, even if physical tokens are available.\n",
            "severity": "High",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::burn#111-124",
                "contracts/vault/Vault.sol::availableBalance#206-209",
                "contracts/lendingPool/libraries/ViewLogic.sol::maxBorrowable#83-91",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ]
            },
            "title": "Unsafe asset removal without borrow validation",
            "description": "The removeAsset function in VaultLogic allows removing an asset from the vault's list without checking if there are outstanding borrows. This can lead to a state where borrowers cannot repay loans because the asset is no longer recognized by the system. The root cause is the absence of a pre-removal validation check for totalBorrows. An admin or attacker with access could remove an asset with active loans, rendering repayment functions ineffective. The impact is that borrowers' funds become locked, they cannot clear their debt, and the system enters an inconsistent state.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol::removeAsset#192-208",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Initial auction start price can be lower than minimum start price",
            "description": "The setStartPrice function in FeeAuction does not validate that the new start price is at least the minStartPrice. This allows an admin to set a start price below the intended minimum, potentially enabling users to acquire assets at negligible cost. The root cause is the lack of input validation in the function. An attacker with admin access or a compromised admin could exploit this to drain value from the protocol. The impact is economic loss due to unauthorized low-price asset acquisition, undermining the auction's intended price discovery mechanism.\n",
            "severity": "Low",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::setStartPrice#85-89",
                "FeeAuction.sol"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Immediate liquidation possible when reducing an agent\u2019s liquidation threshold",
            "description": "The modifyAgent function allows reducing an agent\u2019s liquidation threshold without checking if the agent is already below the new threshold. This could immediately trigger liquidation of the agent\u2019s position. The root cause is the lack of a safety check before updating the threshold. An admin could unknowingly or maliciously set a threshold that puts an agent into a liquidatable state. The impact is unfair liquidation of agents\u2019 positions, leading to loss of collateral and potential disputes or loss of trust in the system.\n",
            "severity": "Informational",
            "location": [
                "contracts/delegation/Delegation.sol::modifyAgent#227-244",
                "Lender.sol::setLiquidationThreshold"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-435"
                ]
            },
            "title": "FeeAuction\u2019s buy function allows purchasing at sub-optimal prices by adding tokens during an active auction",
            "description": "The FeeAuction.buy function does not fix the asset amounts at the start of the auction. An attacker can call realizeInterest on FractionalReserve to add more tokens to the auction and then immediately buy all tokens at the current (low) price, effectively getting the added tokens for free. The root cause is the dynamic inclusion of newly added tokens in the auction without price adjustment. This behavior creates undefined and exploitable auction dynamics. The impact is unfair profit for the attacker and loss of revenue for the protocol, especially if MEV searchers are not active to arbitrage the opportunity.\n",
            "severity": "Low",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::buy",
                "contracts/feeAuction/FeeAuction.sol::_transferOutAssets#113-124",
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emissions for critical parameter changes in VaultAdapter",
            "description": "The setSlopes and setLimits functions in VaultAdapter do not emit events when critical parameters are changed. This makes it difficult to monitor or detect changes to interest rate models, which are essential for protocol transparency and security. The root cause is the omission of event emissions in admin-controlled functions. An attacker or compromised admin could change parameters without leaving an on-chain trace. The impact is reduced auditability and increased risk of undetected malicious or erroneous configuration changes.\n",
            "severity": "Informational",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::setSlopes#51-56",
                "contracts/oracle/libraries/VaultAdapter.sol::setLimits#60-70",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "VaultAdapter\u2019s setSlopes function permits zero or maximum kink values that cause division by zero",
            "description": "The setSlopes function allows setting the kink parameter to 0 or 1e27, which leads to division by zero in interest rate calculations. This would cause the rate calculation to revert, breaking core protocol functionality. The root cause is the lack of input validation on the kink value. An attacker with admin access or a misconfigured input could set these values, causing the system to fail on rate queries. The impact is a denial of service for any function relying on interest rate calculations, disrupting borrowing and lending.\n",
            "severity": "Informational",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::setSlopes#51-56",
                "contracts/oracle/libraries/VaultAdapter.sol::rate#104-105",
                "contracts/oracle/libraries/VaultAdapter.sol::utilizationMultiplier#87-88",
                "VaultAdapter.sol::setSlopes"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Unvalidated _vault address in VaultAdapter allows interest rate manipulation",
            "description": "The rate function in VaultAdapter accepts any _vault address without validation and makes external calls to it. An attacker can pass a malicious contract that returns manipulated utilization values, which are then stored and used in interest rate calculations. The root cause is the lack of access control or allowlist validation on the _vault parameter. This allows an attacker to inflate or deflate interest rates across the protocol. The impact is financial loss for borrowers or lenders due to incorrect interest accrual, and potential manipulation of the entire lending market.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/libraries/VaultAdapter.sol::rate#26-49",
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Fee auction allows buying zero assets, leading to front-running attacks",
            "description": "The FeeAuction.buy function does not validate that assets are actually transferred before accepting payment. A malicious actor can front-run a legitimate buy transaction, depleting the asset balance, and causing the victim's transaction to pay without receiving anything. The root cause is the lack of a check ensuring non-zero asset transfer before payment. This creates a race condition exploitable via MEV. The impact is financial loss for victims who pay double the price (due to price doubling after each successful buy) but receive no assets.\n",
            "severity": "High",
            "location": [
                "contracts/feeAuction/FeeAuction.sol::buy",
                "contracts/feeAuction/FeeAuction.sol::_transferOutAssets#113-124",
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "The protocol exhibits a critical discrepancy between how an agent's health factor is calculated and how slashable collateral is determined. This inconsistency arises because the health factor evaluation uses all current collateral, including recent deposits, while the slashing mechanism only considers deposits made before the most recent epoch or the agent's last borrow time. The root cause is the misalignment in time bases used by the coverage and slashTimestamp functions. An attacker can exploit this by adding fresh collateral just before a liquidation event to improve their health factor, knowing that these new deposits will not be subject to slashing. As a result, during liquidation, the protocol cannot recover sufficient collateral from these recent deposits, leading to a shortfall that the protocol must absorb. This undermines the financial stability and security model of the system, potentially resulting in significant protocol losses, especially if all existing delegations are from the current epoch.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/Delegation.sol#L73-L76",
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L195-L206",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Reward distribution enables front-running attacks and reward siphoning",
            "description": "The reward distribution mechanism allocates rewards to all vaults backing an agent at the time of loan repayment without considering the duration of their delegation. This creates a timing vulnerability where opportunistic actors can monitor pending repayment transactions in the mempool and front-run them by adding their own collateral just before repayment. The root cause is the lack of time-based eligibility criteria for reward distribution. By doing so, these actors can capture a disproportionate share of the accrued interest rewards despite having provided capital for only a minimal period. This allows them to systematically siphon rewards from long-term backers who actually bore the lending risk over time. The impact is an unfair redistribution of rewards that disincentivizes long-term participation and undermines the economic fairness of the protocol.\n",
            "severity": "High",
            "location": [
                "contracts/delegation/NetworkMiddleware.sol",
                "contracts/delegation/Delegation.sol",
                "StakedCap.sol::distributeRewards"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Unaccounted external vault investment losses can create withdrawal shortfalls",
            "description": "The protocol invests idle assets in external vaults such as Yearn but fails to account for losses incurred during divestment. When the protocol changes the address of an external vault, it divests from the current vault regardless of any losses, and these losses are not tracked or reflected in the system's accounting. The root cause is the absence of loss tracking during divestment operations. This creates a \"first out\" advantage where early withdrawers can redeem their full amounts while later withdrawers may face shortfalls because the physical assets no longer exist to back their balances. The protocol continues to report the original total supply despite having fewer physical tokens, leading to an inability to fulfill withdrawal requests. This threatens the solvency of the system and creates an unfair distribution of losses among users.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol",
                "contracts/vault/FractionalReserve.sol",
                "FractionalReserve.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Wrong capTokenDecimals value used in StakedCapAdapter.price causes inaccurate prices",
            "description": "The StakedCapAdapter library incorrectly uses the decimal count (e.g., 18) instead of the corresponding scaling factor (10^18) in price calculations, leading to wildly inaccurate prices. The root cause is a fundamental misunderstanding of how decimal scaling works in the price function: it passes the decimal count to convertToAssets, which expects a share amount, and divides by the decimal count rather than the scaling factor. This results in price miscalculations by several orders of magnitude. An attacker can exploit this by observing the incorrect prices and executing trades that take advantage of the disparity between the reported and actual values. The impact includes potential manipulation of minting and burning operations, incorrect valuation of collateral, and possible insolvency due to erroneous price feeds being used in critical financial operations.\n",
            "severity": "High",
            "location": [
                "contracts/oracle/libraries/StakedCapAdapter.sol#L15-L21",
                "StakedCapAdapter.sol::price"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/StakedCapAdapter.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Liquidation mechanism can be permanently disabled by misconfigured grace and expiry periods",
            "description": "The Lender contract does not validate that the grace period is less than the expiry period during initialization. If grace >= expiry, the liquidation mechanism becomes impossible to trigger because the validateLiquidation function requires block.timestamp to be both greater than start+grace and less than start+expiry, which cannot be satisfied simultaneously. The root cause is the lack of input validation for critical configuration parameters. Since these parameters cannot be reset after deployment, a misconfiguration would permanently disable liquidations. An attacker or negligent admin could deploy the contract with such invalid parameters, preventing any liquidation from occurring even when agents are severely undercollateralized. This leads to the accumulation of bad debt and potentially results in protocol insolvency as unhealthy positions remain outstanding indefinitely.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol#L98-L102",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Oracle update front-running allows extraction of value from vaults",
            "description": "The protocol's minting and burning functions are vulnerable to oracle sandwiching attacks due to the use of current oracle prices without protection against timing manipulation. The root cause is the lack of safeguards such as fees, TWAPs, or circuit breakers around oracle updates. An attacker can monitor pending Chainlink oracle updates and front-run them by depositing assets before the price update and withdrawing after, profiting from the price difference. For example, when the USDC price drops, the attacker deposits at the old price and withdraws at the new, higher effective rate, extracting value from the protocol. The impact is a direct loss of funds from the protocol treasury proportional to the size of the oracle update, exploiting natural market movements rather than oracle manipulation, which undermines the economic integrity of the system.\n",
            "severity": "Medium",
            "location": [
                "contracts/vault/Vault.sol",
                "Oracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Asset removal does not reset isBorrowing flag for agents",
            "description": "When an asset is removed from the system, the validation logic only checks if the principal debt is repaid but does not clear the agent's isBorrowing flag for that asset. The root cause is incomplete state cleanup during asset removal. If the same reserve ID is later reused for a different asset, agents who previously borrowed the old asset will have their isBorrowing flag incorrectly set to true for the new asset, even though they never borrowed it. This leads to accounting inconsistencies that can affect health factor calculations, borrowing limits, and liquidation eligibility. The impact includes incorrect risk assessments for agents and potential denial of service for legitimate operations due to false borrowing status, undermining the reliability of the protocol's financial tracking mechanisms.\n",
            "severity": "Informational",
            "location": [
                "contracts/lendingPool/libraries/ValidationLogic.sol",
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Invalid network registration in Delegation.registerNetwork can cause DoS",
            "description": "The registerNetwork function in the Delegation contract lacks validation for network addresses and provides no way to remove registered networks. The root cause is insufficient input validation and missing administrative functions for error correction. If an invalid address (e.g., address(0)) or a non-compliant contract is registered, key functions like coverage and slashableCollateral will permanently revert when attempting external calls to the invalid network. This results in a denial of service for the affected agent, locking them out of protocol functionality indefinitely. Since there is no mechanism to unregister networks or remove the agent, the issue cannot be resolved post-deployment, making it a permanent operational failure for the affected user.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L249-L258",
                "Delegation.sol::registerNetwork"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-252"
                ]
            },
            "title": "Lack of verification on ERC4626 vault withdrawal amounts",
            "description": "The divest function reduces the recorded loaned amount before the actual withdrawal occurs and does not verify the return value from the ERC4626 vault's withdraw call. The root cause is the failure to validate the actual amount received versus the expected divestAmount. If the vault returns fewer assets than requested (due to losses or other factors), the accounting system still assumes the full amount was withdrawn, creating a discrepancy between recorded and actual assets. While current integrations with Yearn vaults prevent losses by reverting, future integration with other ERC4626 vaults that allow losses could lead to systematic asset shortfalls. The impact is a gradual erosion of protocol solvency as unaccounted losses accumulate over time.\n",
            "severity": "Informational",
            "location": [
                "contracts/vault/libraries/FractionalReserveLogic.sol#L63-L66",
                "Vault.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/FractionalReserveLogic.sol"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Agent LTV can be configured equal to or higher than liquidation threshold",
            "description": "The addAgent and modifyAgent functions allow setting an agent's loan-to-value (LTV) ratio equal to or higher than its liquidation threshold. The root cause is missing validation that ensures LTV is strictly less than the liquidation threshold. This configuration leads to contradictory economic states: if LTV >= liquidation threshold, an agent could either be immediately liquidatable upon borrowing or never reach liquidation even when undercollateralized. The impact is a breakdown of the risk management system, exposing the protocol to uncontrolled borrowing and potential insolvency. Even if unintended, a simple administrative error could create such a dangerous configuration, undermining the core collateralization safeguards of the protocol.\n",
            "severity": "Low",
            "location": [
                "contracts/delegation/Delegation.sol#L202-L209",
                "Lender.sol::setLTV"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-755"
                ],
                "3": [
                    "CWE-248"
                ]
            },
            "title": "ZapOFTComposer._lzCompose may fail with USDT",
            "description": "The _lzCompose function uses the standard approve method for ERC20 tokens without handling the special case of tokens like USDT that do not allow changing a non-zero approval to another non-zero value. The root cause is the failure to use SafeERC20's forceApprove function, despite importing the library. This can cause transactions to fail when users attempt to create zaps with multiple USDT inputs, as the approve call will revert if an existing non-zero allowance is present. The impact is a denial of service for users trying to interact with USDT in zap operations, reducing the usability and reliability of the protocol for one of the most widely used stablecoins, despite a safe alternative being available in the codebase.\n",
            "severity": "Informational",
            "location": [
                "contracts/zap/ZapOFTComposer.sol#L39-L55",
                "ZapOFTComposer.sol::_lzCompose"
            ],
            "files": [
                "cap-contracts/contracts/zap/ZapOFTComposer.sol"
            ]
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Fee auction allows assets to be purchased for free",
            "description": "The Dutch auction mechanism in the FeeAuction contract allows the price to decay linearly to zero over time, enabling users to claim fee tokens for free when the auction expires without bids. The root cause is the lack of a minimum price floor in the currentPrice function. Although this behavior may be intentional (as suggested by code comments), it represents a value leakage risk for the protocol. Attackers can wait until the auction ends and then purchase valuable protocol fees at zero cost. The impact is a direct loss of revenue for the protocol, undermining the economic sustainability of the fee collection mechanism and potentially discouraging participation in earlier, higher-priced stages of the auction.\n",
            "severity": "Informational",
            "location": [
                "contracts/feeAuction/FeeAuction.sol#L52-L57",
                "FeeAuction.sol"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Small borrows can create economically unviable liquidatable positions leading to bad debt accumulation",
            "description": "The borrow function allows positions as small as 1 wei without a minimum borrow amount check. The root cause is the absence of economic viability safeguards in the borrowing logic. When such tiny positions become undercollateralized, the gas costs of liquidation exceed the liquidation value plus bonus, making it unprofitable for liquidators to act. This leads to the accumulation of bad debt in the system, as these positions remain outstanding indefinitely. While the impact is limited by the number of borrowable assets per agent, it still introduces a persistent solvency risk. The protocol effectively subsidizes spammy or malicious small borrowing behavior, weakening the overall health of the lending market.\n",
            "severity": "Low",
            "location": [
                "contracts/lendingPool/Lender.sol#L65-L69",
                "Lender.sol::borrow"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Interest rate manipulation through frequent mints and burns",
            "description": "The interest rate calculation depends on the elapsed time since the last update, but this timestamp is reset on every mint, burn, or borrow operation. The root cause is the vulnerability to timestamp manipulation via frequent zero-value or low-value transactions. An attacker can artificially reduce the elapsed time used in utilization multiplier calculations by performing repeated operations, thereby dampening interest rate increases during high utilization periods. This is especially severe when zero-value mints or burns are allowed, as they enable manipulation with minimal capital. The impact is distorted interest rates that fail to reflect true market conditions, allowing borrowers to avoid paying appropriate risk premiums and undermining the protocol's risk management and capital allocation mechanisms.\n",
            "severity": "Low",
            "location": [
                "contracts/vault/libraries/VaultLogic.sol#L289-L293",
                "contracts/oracle/libraries/VaultAdapter.sol#L87-L88",
                "Minter.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Protocol lacks bad debt management mechanisms, risking permanent insolvency",
            "description": "The protocol has no mechanism to handle accumulated bad debt from failed or uneconomical liquidations. The root cause is the absence of insurance or loss-socialization mechanisms. When bad debt accumulates\u2014especially in conjunction with small, unviable borrowing positions\u2014the loss is not distributed fairly. Instead, it creates a \"last withdrawer\" problem where early withdrawers redeem their full amounts while later users face shortfalls as the protocol runs out of physical tokens. This leads to permanent insolvency and unfair loss distribution. The impact is a systemic risk to user funds, where the timing of withdrawal determines whether a user loses money, undermining trust in the protocol's solvency guarantees.\n",
            "severity": "Medium",
            "location": [
                "contracts/lendingPool/Lender.sol",
                "Lender.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Reward distribution can be tricked by front-running notify calls",
            "description": "The notify function in StakedCap updates the reward distribution state based on current balances without protecting against front-running. The root cause is the lack of time-based or anti-sybil mechanisms in reward allocation. An attacker can monitor mempool transactions and deposit a large amount of CAP tokens immediately before a notify call, thereby capturing a disproportionate share of the newly distributed rewards. After receiving the rewards, the attacker can withdraw, having gained value without long-term commitment. This undermines the incentive structure for genuine long-term stakers and enables sophisticated actors to exploit timing advantages for unfair profit extraction, reducing the fairness and effectiveness of the reward system.\n",
            "severity": "Informational",
            "location": [
                "contracts/token/StakedCap.sol#L58-L69",
                "StakedCap.sol::notifyReward"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ],
                "3": [
                    "CWE-1078"
                ],
                "4": [
                    "CWE-546"
                ]
            },
            "title": "Remove TODOs from the code",
            "description": "The codebase contains multiple \"// TODO:\" comments that indicate incomplete or pending work. Leaving such comments in production code can lead to confusion, overlooked issues, or accidental deployment of unfinished logic. These comments may signal areas where assumptions were made or where security checks were intended but not implemented. While not directly exploitable, they increase technical debt and risk. Their presence violates secure development best practices, which recommend that all TODOs be resolved or removed before deployment. The impact is reduced code clarity and potential introduction of vulnerabilities if TODOs are ignored during future maintenance.\n",
            "severity": null,
            "location": [
                "Multiple files"
            ],
            "files": [
                "cap-contracts/test/deploy/TestDeployer.sol",
                "cap-contracts/test/vault/Vault.invariants.t.sol",
                "cap-contracts/contracts/deploy/service/DeployLibs.sol"
            ]
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Checks-effects-interactions pattern violation in FeeAuction.buy",
            "description": "The buy function in the FeeAuction contract violates the checks-effects-interactions pattern, a critical security practice in smart contract development. This violation occurs because the function performs external calls before updating the internal state, creating a window for reentrancy attacks. The root cause is improper ordering of operations, where interactions with untrusted external contracts happen too early. An attacker could exploit this by crafting a malicious contract that reenters the buy function during execution, potentially manipulating state or draining funds. The impact could include loss of funds or unintended state changes if combined with other vulnerabilities, though no direct exploit is demonstrated here.\n",
            "severity": null,
            "location": [
                "contracts/feeAuction/FeeAuction.sol#L75-L79"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "PriceOracle and RateOracle could be abstract contracts",
            "description": "The PriceOracle and RateOracle contracts implement functionality intended for inheritance rather than direct deployment. The root cause is that these contracts serve as base implementations but are not marked as abstract, allowing them to be instantiated directly. This could lead to accidental deployment of incomplete or non-functional oracle instances, which might return incorrect or uninitialized data. An attacker could potentially exploit misconfigured or uninitialized oracle instances if they are used by other components expecting valid price feeds. The impact includes potential manipulation of price data, leading to incorrect valuations in lending or auction mechanisms, which could result in financial loss.\n",
            "severity": null,
            "location": [],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol",
                "cap-contracts/contracts/oracle/RateOracle.sol"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1076"
                ]
            },
            "title": "Function state mutability can be restricted to view",
            "description": "Several functions in the RateOracle contract are not marked as `view` despite not modifying state, including specific lines in the contract. The root cause is incorrect or missing state mutability specifiers. This affects code readability, gas efficiency, and tooling interpretation (e.g., static analyzers or frontends may assume state changes). While not directly exploitable, it increases the risk of misinterpretation by developers or users who assume a function is non-view and thus safe to call without transaction cost or risk. The impact is reduced code clarity and potential for unnecessary transactions or incorrect integration assumptions.\n",
            "severity": null,
            "location": [
                "contracts/oracle/RateOracle.sol#L110",
                "contracts/oracle/RateOracle.sol#L109-L112",
                "contracts/oracle/RateOracle.sol#L26-L29",
                "contracts/oracle/RateOracle.sol#L34-L37"
            ],
            "files": [
                "cap-contracts/contracts/oracle/RateOracle.sol"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "The buy function does an unnecessary callback",
            "description": "The buy function in FeeAuction.sol performs an unnecessary callback, which introduces a potential reentrancy risk. The root cause is the inclusion of a callback mechanism that is not essential for the function's core logic. If this callback is not required, it should be removed; otherwise, it must be protected. The current implementation lacks a `nonReentrant` modifier, leaving it vulnerable if the callback targets a malicious contract. An attacker could exploit this to reenter the function and manipulate state or drain funds. The recommendation to use flashloans instead suggests a design flaw in the current approach. The impact is potential loss of funds due to reentrancy.\n",
            "severity": null,
            "location": [
                "contracts/feeAuction/FeeAuction.sol#L64-L79"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1059"
                ],
                "3": [
                    "CWE-1111"
                ]
            },
            "title": "Missing parameters in ZapOFTComposer.constructor NatSpecs",
            "description": "The NatSpec documentation for the constructor of ZapOFTComposer is incomplete, failing to document all input parameters. The root cause is incomplete or neglected documentation. While this does not introduce a direct security vulnerability, it reduces code maintainability and increases the risk of integration errors by developers who rely on documentation. Incorrect assumptions based on incomplete docs could lead to improper usage of the contract, potentially triggering unintended behaviors or security issues in dependent systems. The impact is reduced code clarity and increased risk of integration bugs.\n",
            "severity": null,
            "location": [
                "contracts/zap/ZapOFTComposer.sol#L27-L31"
            ],
            "files": [
                "cap-contracts/contracts/zap/ZapOFTComposer.sol"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ],
                "3": [
                    "CWE-561"
                ]
            },
            "title": "The Minter.__Minter_init and FractionalReserve.__FractionalReserve_init functions are never called",
            "description": "The initialization functions __Minter_init and __FractionalReserve_init are defined but never invoked in the codebase. The root cause is dead code that serves no functional purpose. This could mislead developers into thinking these initializers are used, potentially leading to incorrect assumptions about contract state. If these functions were intended to be called but are not, critical initialization logic may be missing. The impact is confusion, increased code complexity, and potential for undiscovered initialization flaws if similar patterns exist elsewhere.\n",
            "severity": null,
            "location": [],
            "files": [
                "cap-contracts/contracts/vault/Minter.sol",
                "cap-contracts/contracts/vault/FractionalReserve.sol",
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Incorrect debt repayment order in BorrowLogic",
            "description": "The repay function in BorrowLogic.sol pays principal first, then restaker debt, and interest last, which contradicts its own documentation stating that interest should be paid first. The root cause is a logic inconsistency between implementation and documentation. This could lead to incorrect debt accounting, especially in edge cases like liquidations or partial repayments. Users or external systems relying on the documented behavior may experience unexpected outcomes. The impact includes financial discrepancies, reduced trust in the protocol, and potential for disputes or exploits if attackers can manipulate repayment sequences.\n",
            "severity": null,
            "location": [
                "contracts/lendingPool/libraries/BorrowLogic.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/BorrowLogic.sol"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-1164"
                ]
            },
            "title": "Multiple unused imports",
            "description": "The codebase contains numerous unused imports, which increase compilation size and gas costs for deployment. The root cause is lack of cleanup during development. While not a direct security risk, excessive unused code reduces readability and maintainability. In extreme cases, unused imports from untrusted sources could introduce hidden vulnerabilities. The impact is bloated bytecode and reduced code clarity, making audits and reviews more difficult.\n",
            "severity": null,
            "location": [],
            "files": [
                "cap-contracts/contracts"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-435"
                ],
                "2": [
                    "CWE-436"
                ],
                "3": [
                    "CWE-437"
                ]
            },
            "title": "ICapToken.initialize and CapToken.initialize mismatch",
            "description": "There is a mismatch between the ICapToken interface and the CapToken implementation regarding the initialize function signature. The root cause is an inconsistency between interface and implementation, which can lead to silent failures during deployment or upgrades if the proxy system relies on correct function selectors. If a contract calls initialize through the interface, it may fail or behave unexpectedly. The impact includes potential initialization failures, broken upgrades, or incorrect state setup, which could render the contract unusable or insecure.\n",
            "severity": null,
            "location": [
                "contracts/interfaces/ICapToken.sol#L7-L8",
                "contracts/token/CapToken.sol#L23-L30"
            ],
            "files": [
                "cap-contracts/contracts/interfaces/ICapToken.sol",
                "cap-contracts/contracts/token/CapToken.sol"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-657"
                ]
            },
            "title": "Some contracts are not using the _disableInitializers pattern",
            "description": "Contracts such as AccessControl, Network, and NetworkMiddleware do not use the _disableInitializers function in their constructors. The root cause is failure to follow OpenZeppelin's recommended pattern for upgradable contracts. Without this, initializers can be re-called, potentially allowing malicious actors to reinitialize contract state, such as transferring ownership or resetting critical parameters. The impact is high, as it could lead to full contract takeover if an initializer function is exposed and callable after deployment.\n",
            "severity": null,
            "location": [],
            "files": [
                "cap-contracts/contracts/access/AccessControl.sol",
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Recommend sanity checking the fee",
            "description": "In NetworkMiddleware.sol, the fee value is used without any sanity checks, such as upper or lower bounds. The root cause is lack of input validation. An attacker or misconfigured frontend could set an extremely high or zero fee, leading to excessive user charges or loss of revenue for the protocol. The impact includes financial loss, user exploitation, or denial of service if fees make operations prohibitively expensive. Sanity checks are essential to ensure the fee remains within expected ranges.\n",
            "severity": null,
            "location": [
                "contracts/delegation/providers/symbiotic/NetworkMiddleware.sol#L71-L75"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-657"
                ]
            },
            "title": "Vault, FractionalReserve, and Minter should be abstract contracts",
            "description": "The Vault, FractionalReserve, and Minter contracts are meant to be inherited but are not declared as abstract. The root cause is incorrect contract design, allowing direct instantiation of base contracts. If deployed directly, these contracts may lack critical initialization or contain incomplete logic, leading to undefined behavior. An attacker could deploy and manipulate such instances to simulate valid components or exploit missing access controls. The impact includes potential for protocol manipulation or integration errors if external systems interact with invalid instances.\n",
            "severity": null,
            "location": [
                "contracts/vault/Vault.sol#L19"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/vault/FractionalReserve.sol",
                "cap-contracts/contracts/vault/Minter.sol"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-424"
                ]
            },
            "title": "Like the main oracle, the backup oracle should check for staleness and zero prices",
            "description": "The backup oracle in PriceOracle.sol does not validate price staleness or zero prices, unlike the main oracle. The root cause is inconsistent security practices between primary and backup components. If the main oracle fails and the backup is used, stale or zero prices could be accepted, leading to incorrect valuations. An attacker could manipulate or freeze price feeds to trigger liquidations or unfair trades. The impact includes financial loss due to incorrect pricing during oracle fallback scenarios.\n",
            "severity": null,
            "location": [
                "contracts/oracle/PriceOracle.sol#L42"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "revokeAccess should not allow the admin to revoke himself",
            "description": "The revokeAccess function allows the admin to revoke their own access, which could result in permanent loss of administrative control. The root cause is lack of a self-revocation guard. If the admin accidentally or maliciously revokes their own access, there may be no way to recover control, especially if no other admins exist. The impact is potential permanent lockout of critical administrative functions, leading to governance paralysis or inability to respond to emergencies.\n",
            "severity": null,
            "location": [],
            "files": [
                "cap-contracts/contracts/access/AccessControl.sol"
            ]
        },
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Unbounded array iterations risk out-of-gas failures",
            "description": "Several functions iterate over arrays without size limits, creating a risk of out-of-gas failures as the arrays grow. The root cause is unbounded loops that may exceed block gas limits over time. An attacker could force such a failure by growing the array to a critical size, preventing legitimate users from calling key functions. This constitutes a denial-of-service vector. The impact includes disruption of protocol operations, such as withdrawals or updates, especially in time-sensitive contexts.\n",
            "severity": null,
            "location": [],
            "files": [
                "cap-contracts/contracts/deploy/service/DeployVault.sol",
                "cap-contracts/contracts/oracle/libraries/CapTokenAdapter.sol",
                "cap-contracts/contracts/vault/libraries/VaultLogic.sol",
                "cap-contracts/contracts/vault/FractionalReserve.sol",
                "cap-contracts/contracts/feeAuction/FeeAuction.sol",
                "cap-contracts/contracts/lendingPool/libraries/ViewLogic.sol",
                "cap-contracts/contracts/lendingPool/libraries/ReserveLogic.sol",
                "cap-contracts/contracts/vault/libraries/MinterLogic.sol",
                "cap-contracts/contracts/vault/Vault.sol",
                "cap-contracts/contracts/zap/ZapOFTComposer.sol"
            ]
        },
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing input validation in FeeAuction.buy allows payment without asset transfer",
            "description": "This vulnerability arises from the lack of input validation in the FeeAuction.buy function, which allows users to make a payment without transferring any assets. The root cause is the absence of a check for zero-length asset arrays. An attacker could exploit this by calling the buy function with an empty assets array, leading to unintended state changes without actual asset transfer. This could disrupt auction mechanics and potentially allow manipulation of auction outcomes or gas griefing.\n",
            "severity": "Medium",
            "location": [
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-654"
                ]
            },
            "title": "Incorrect oracle staleness period leads to price feed DoS",
            "description": "The price oracle used a single global staleness period, which could lead to a denial-of-service (DoS) condition if the global setting was too strict or too lenient for certain assets. The cause was a lack of per-asset configurability for staleness checks. An attacker could exploit this by manipulating or delaying price updates for specific assets, causing the system to reject valid prices or accept stale ones. This could halt operations that depend on fresh price data, such as liquidations or borrowing.\n",
            "severity": "High",
            "location": [
                "PriceOracle.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        },
        {
            "id": 47,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Vaults can be added to the middleware multiple times, leading to double-counted delegations",
            "description": "The vulnerability allows the same vault to be registered multiple times in the middleware, resulting in inflated delegation counts. This is caused by the absence of a check to prevent duplicate vault registrations. An attacker could exploit this by repeatedly adding the same vault to artificially increase its delegation weight. This would distort yield distribution and governance voting power, leading to unfair advantages and potential economic imbalance.\n",
            "severity": "Medium",
            "location": [
                "Middleware.sol::_verifyVault"
            ],
            "files": [
                "cap-contracts/contracts/delegation/providers/symbiotic/NetworkMiddleware.sol"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-841"
                ]
            },
            "title": "StakedCap yield distribution DoS through timer manipulation",
            "description": "The StakedCap contract's yield distribution mechanism could be disrupted by manipulating the notification timer. The root cause is the ability to call the notify function during a lock period, which could reset or interfere with yield distribution timing. An attacker could exploit this by repeatedly calling notify during the lock period to prevent legitimate yield distribution. This would result in a denial of service for yield claimants, disrupting the reward system.\n",
            "severity": "Medium",
            "location": [
                "StakedCap.sol::notify"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Inconsistent balance tracking in vault creates DoS for asset borrowing",
            "description": "The vault contract does not properly validate available balances before allowing withdrawals or borrows, leading to inconsistent balance tracking. This is caused by the lack of a pre-check on vault liquidity. An attacker could exploit this by initiating a borrow or withdrawal when the vault has insufficient funds, causing the transaction to fail and potentially locking users out of their assets. This creates a denial-of-service condition for legitimate borrowing and withdrawal operations.\n",
            "severity": "High",
            "location": [
                "Vault.sol::_verifyBalance"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-826"
                ]
            },
            "title": "Unsafe asset removal without borrow validation",
            "description": "The removeAsset function allows removal of an asset even when there are outstanding borrows, which could lead to accounting inconsistencies. The cause is the lack of validation that the asset's total supply is zero before removal. An attacker could exploit this by removing an asset while borrows are still active, potentially breaking the accounting model and leading to incorrect balance calculations. This could result in loss of funds or inability to repay debt.\n",
            "severity": "Medium",
            "location": [
                "Vault.sol::removeAsset"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Initial auction start price can be lower than minimum start price",
            "description": "The setStartPrice function allows setting a start price below the defined minimum, undermining auction fairness. This is caused by missing validation in the setStartPrice function. An attacker could exploit this by setting an unreasonably low start price, enabling asset acquisition at a fraction of their value. This could lead to significant financial loss for the protocol and unfair advantages for early bidders.\n",
            "severity": "Low",
            "location": [
                "FeeAuction.sol::setStartPrice"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 52,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Immediate liquidation possible when reducing an agent's liquidation threshold",
            "description": "Reducing an agent's liquidation threshold can immediately trigger liquidation if the agent's health factor drops below the new threshold. This is an intentional design choice, but it introduces risk because the change takes effect instantly without a grace period. An attacker with control over the threshold parameter could exploit this to liquidate an agent arbitrarily. The impact includes potential loss of collateral and user funds due to abrupt liquidation.\n",
            "severity": "Informational",
            "location": [
                "AgentManager.sol::setLiquidationThreshold"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 53,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "FeeAuction\u2019s buy function allows purchasing at sub-optimal prices by adding tokens during an active auction",
            "description": "The buy function allows users to add tokens during an active auction, which can lead to purchases at prices worse than the current market rate. The cause is the lack of price protection during active auctions. An attacker could exploit this by manipulating the auction dynamics to buy assets at sub-optimal prices, potentially leading to financial loss for bidders. While not directly exploitable for profit, it degrades user experience and economic efficiency.\n",
            "severity": "Low",
            "location": [
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 54,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ],
                "4": [
                    "CWE-778"
                ]
            },
            "title": "Missing event emissions for critical parameter changes in VaultAdapter",
            "description": "The VaultAdapter contract does not emit events when critical parameters like slopes and limits are changed. The cause is the absence of event emissions in the corresponding setter functions. This makes it difficult for external systems and users to track important configuration changes, leading to reduced transparency and auditability. While not directly exploitable, it hampers monitoring and can delay detection of malicious or erroneous changes.\n",
            "severity": "Informational",
            "location": [
                "VaultAdapter.sol::setSlopes",
                "VaultAdapter.sol::setLimits"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 55,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-369"
                ]
            },
            "title": "VaultAdapter\u2019s setSlopes function permits zero or maximum kink values that cause division by zero",
            "description": "The setSlopes function allows setting kink values to zero or maximum, which can lead to division by zero errors during interest rate calculations. The cause is the lack of input validation for kink parameters. An attacker could exploit this by setting extreme kink values, causing transactions to revert and disrupting lending operations. This results in a denial-of-service condition for interest rate updates and related financial functions.\n",
            "severity": "Informational",
            "location": [
                "VaultAdapter.sol::setSlopes"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 56,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Unvalidated _vault address in VaultAdapter allows interest rate manipulation",
            "description": "The VaultAdapter does not validate the _vault address input, allowing malicious or incorrect addresses to be registered. This can lead to incorrect utilization data mapping and subsequent interest rate manipulation. The root cause is the lack of address validation. An attacker could register a fake vault to skew utilization metrics, leading to incorrect interest rate calculations. This distorts the lending market and can cause financial losses for lenders and borrowers.\n",
            "severity": "High",
            "location": [
                "VaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/VaultAdapter.sol"
            ]
        },
        {
            "id": 57,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Fee auction allows buying zero assets, leading to front-running attacks",
            "description": "The buy function allows purchasing zero assets, which can be exploited in front-running attacks. The cause is the lack of a slippage protection mechanism and validation for non-zero asset amounts. An attacker could exploit this by front-running legitimate bids with zero-asset transactions to manipulate auction state or extract value. This undermines auction fairness and can lead to loss of user funds.\n",
            "severity": "High",
            "location": [
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 58,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Discrepancy between health calculation and slashable collateral computation",
            "description": "There is a mismatch between how an agent's health factor is calculated and how slashable collateral is computed, potentially leading to incorrect liquidation decisions. The cause is inconsistent logic in the two calculations. An attacker could exploit this by structuring their position to appear healthy while holding non-slashable collateral, avoiding liquidation. This increases protocol risk and can lead to bad debt accumulation.\n",
            "severity": "High",
            "location": [
                "LiquidationEngine.sol",
                "HealthCalculator.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 59,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Reward distribution enables front-running attacks and reward siphoning",
            "description": "The reward distribution mechanism is vulnerable to front-running, where attackers can observe pending transactions and submit higher-gas transactions to claim rewards first. The cause is the lack of anti-front-running measures in the notify and claim functions. An attacker could exploit this to siphon rewards from legitimate users. This leads to unfair distribution of rewards and reduced user trust in the system.\n",
            "severity": "High",
            "location": [
                "RewardDistributor.sol::notify",
                "RewardDistributor.sol::claim"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        },
        {
            "id": 60,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "Unaccounted external vault investment losses can create withdrawal shortfalls",
            "description": "Losses from external vault investments are not accounted for in the protocol's accounting model, which can lead to insufficient funds when users attempt to withdraw. The cause is the lack of loss tracking from external strategies. An attacker could exploit market downturns or failed strategies to trigger withdrawals that exceed available funds. This results in withdrawal shortfalls and potential insolvency for the vault.\n",
            "severity": "Medium",
            "location": [
                "ExternalVaultAdapter.sol"
            ],
            "files": [
                "cap-contracts/contracts/vault/FractionalReserve.sol"
            ]
        },
        {
            "id": 61,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "Wrong capTokenDecimals value used in StakedCapAdapter.price causes inaccurate prices",
            "description": "The StakedCapAdapter.price function uses an incorrect decimals value for scaling, leading to inaccurate price calculations. The cause is a hardcoded or incorrect capTokenDecimals value. An attacker could exploit this by trading at incorrect prices, leading to arbitrage losses for the protocol. This undermines price reliability and can cause financial losses in trading and liquidation scenarios.\n",
            "severity": "High",
            "location": [
                "StakedCapAdapter.sol::price"
            ],
            "files": [
                "cap-contracts/contracts/oracle/libraries/StakedCapAdapter.sol"
            ]
        },
        {
            "id": 62,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Liquidation mechanism can be permanently disabled by misconfigured grace and expiry periods",
            "description": "If the grace period is set greater than the expiry period, the liquidation mechanism can be permanently disabled. The cause is the lack of validation in the Lender contract's initialize function. An attacker with configuration rights could set invalid periods to disable liquidations. This would prevent the protocol from recovering bad debt, leading to increased risk of insolvency.\n",
            "severity": "Medium",
            "location": [
                "Lender.sol::initialize"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 63,
            "category": {
                "1": [
                    "CWE-693"
                ]
            },
            "title": "Oracle update front-running allows extraction of value from vaults",
            "description": "Oracle updates can be front-run by attackers who anticipate price changes and trade ahead of the update. The cause is the lack of commit-reveal schemes or time locks in oracle updates. An attacker could exploit this by monitoring mempool transactions and submitting trades just before an update to extract value from vaults. This leads to wealth transfer from the protocol to malicious actors.\n",
            "severity": "Medium",
            "location": [
                "PriceOracle.sol::update"
            ],
            "files": [
                "cap-contracts/contracts/oracle/PriceOracle.sol"
            ]
        },
        {
            "id": 64,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-459"
                ]
            },
            "title": "Asset removal does not reset isBorrowing flag for agents",
            "description": "When an asset is removed, the isBorrowing flag is not reset even if all debt tokens are zero. The cause is incomplete state cleanup in the removeAsset function. This can lead to incorrect state tracking, where agents are marked as borrowing even when they have no debt. While not directly exploitable, it can cause logic errors in future operations that depend on the isBorrowing flag.\n",
            "severity": "Informational",
            "location": [
                "Agent.sol::validateRemoveAsset"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/libraries/ValidationLogic.sol"
            ]
        },
        {
            "id": 65,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Invalid network registration in Delegation.registerNetwork can cause DoS",
            "description": "The registerNetwork function allows registration of the zero address as a network, which can lead to a denial-of-service condition. The cause is the lack of zero-address validation. An attacker could register a null network, causing subsequent operations to revert when interacting with it. This disrupts network registration and delegation functionality.\n",
            "severity": "Low",
            "location": [
                "Delegation.sol::registerNetwork"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 66,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Lack of verification on ERC4626 vault withdrawal amounts",
            "description": "The divest function does not verify that the ERC4626 vault returns the expected amount of assets upon withdrawal. The cause is missing post-withdrawal balance checks. An attacker could exploit a malicious or compromised ERC4626 vault to return fewer assets than expected, leading to fund loss. This undermines the integrity of the withdrawal process.\n",
            "severity": "Informational",
            "location": [
                "FractionalReserve.sol::divest"
            ],
            "files": [
                "cap-contracts/contracts/vault/FractionalReserve.sol"
            ]
        },
        {
            "id": 67,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Agent LTV can be configured equal to or higher than liquidation threshold",
            "description": "The protocol allows setting an agent's Loan-to-Value (LTV) ratio equal to or higher than its liquidation threshold, which makes liquidation impossible. The cause is insufficient validation in the configuration logic. An attacker with configuration rights could set such parameters to create unliquidatable positions. This increases credit risk and can lead to bad debt accumulation.\n",
            "severity": "Low",
            "location": [
                "Delegation.sol"
            ],
            "files": [
                "cap-contracts/contracts/delegation/Delegation.sol"
            ]
        },
        {
            "id": 68,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ],
                "3": [
                    "CWE-394"
                ]
            },
            "title": "ZapOFTComposer._lzCompose may fail with USDT",
            "description": "The _lzCompose function may fail when interacting with USDT due to its non-standard approval mechanism. The cause is the use of regular approve instead of forceApprove for tokens like USDT. An attacker could exploit this by triggering compositions with USDT, causing transaction failures. This disrupts cross-chain operations and reduces user experience.\n",
            "severity": "Informational",
            "location": [
                "ZapOFTComposer.sol::_lzCompose"
            ],
            "files": [
                "cap-contracts/contracts/zap/ZapOFTComposer.sol"
            ]
        },
        {
            "id": 69,
            "category": {
                "1": [
                    "CWE-682"
                ]
            },
            "title": "Fee auction allows assets to be purchased for free",
            "description": "The fee auction mechanism allows the price to decay to zero, enabling users to purchase assets without paying. The cause is the price decay function not having a floor above zero. An attacker could wait for the price to decay fully and then acquire assets at no cost. This leads to direct financial loss for the protocol.\n",
            "severity": "Informational",
            "location": [
                "FeeAuction.sol::buy"
            ],
            "files": [
                "cap-contracts/contracts/feeAuction/FeeAuction.sol"
            ]
        },
        {
            "id": 70,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Small borrows can create economically unviable liquidatable positions leading to bad debt accumulation",
            "description": "The protocol allows very small borrow amounts, which may not be worth liquidating due to gas costs. The cause is the absence of a minimum borrow threshold. An attacker could create numerous tiny borrow positions that become undercollateralized but are never liquidated. This results in accumulated bad debt and increased protocol risk.\n",
            "severity": "Low",
            "location": [
                "Lender.sol::borrow"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 71,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-799"
                ]
            },
            "title": "Interest rate manipulation through frequent mints and burns",
            "description": "Users can manipulate interest rates by rapidly minting and burning tokens, which affects utilization-based rate calculations. The cause is the lack of time-averaged or smoothed utilization metrics. An attacker could exploit this to artificially inflate or deflate interest rates for profit. This distorts the lending market and can lead to unfair rate adjustments.\n",
            "severity": "Low",
            "location": [
                "Vault.sol::mint",
                "Vault.sol::burn"
            ],
            "files": [
                "cap-contracts/contracts/vault/Vault.sol"
            ]
        },
        {
            "id": 72,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-754"
                ]
            },
            "title": "Protocol lacks bad debt management mechanisms, risking permanent insolvency",
            "description": "The protocol does not have mechanisms to handle bad debt, such as an insurance fund or protocol-owned liquidity. The cause is the absence of risk mitigation infrastructure. In the event of large-scale defaults or oracle failures, the protocol could become insolvent. This poses a systemic risk to the entire system's financial health.\n",
            "severity": "Medium",
            "location": [
                "Lender.sol",
                "InsuranceFund.sol"
            ],
            "files": [
                "cap-contracts/contracts/lendingPool/Lender.sol"
            ]
        },
        {
            "id": 73,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-362"
                ]
            },
            "title": "Reward distribution can be tricked by front-running notify calls",
            "description": "The reward distribution system can be manipulated by front-running the notify function, which updates reward indices. The cause is the lack of access control or timing constraints on notify. An attacker could front-run legitimate updates to claim disproportionate rewards. This leads to unfair distribution and potential loss of rewards for honest participants.\n",
            "severity": "Informational",
            "location": [
                "RewardDistributor.sol::notify"
            ],
            "files": [
                "cap-contracts/contracts/token/StakedCap.sol"
            ]
        }
    ]
}