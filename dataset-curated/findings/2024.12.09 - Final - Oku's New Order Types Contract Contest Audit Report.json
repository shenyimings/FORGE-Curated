{
    "path": "dataset-curated/reports/Sherlock/2024.12.09 - Final - Oku's New Order Types Contract Contest Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/gfx-labs/oku-custom-order-types",
            "https://github.com/sherlock-audit/2024-11-ku"
        ],
        "commit_id": [
            "b84e5725f4d1e0a1ee9048baf44e68d2e53ec971",
            "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6"
        ],
        "address": [
            null
        ],
        "chain": "evm/optimism",
        "compiler_version": "n/a",
        "audit_date": "2024-11-01",
        "project_path": {
            "2024.12.09 - Final - Oku's New Order Types Contract Contest Audit Report.pdf-source": "dataset-curated/contracts/2024.12.09 - Final - Oku's New Order Types Contract Contest Audit Report.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-182"
                ]
            },
            "title": "Unsafe Type Casting in Token Amount Handling",
            "description": "The contracts in the Oku protocol perform unsafe downcasting from uint256 to uint160 when handling token amounts in Permit2 transfers. This occurs in functions such as StopLimit::createOrder(), modifyOrder(), and others in Bracket.sol and OracleLess.sol. The root cause is that Solidity 0.8.x does not protect against data loss during type casting, only during arithmetic operations. As a result, if a user provides an amount greater than type(uint160).max, the value will overflow and wrap around to a much smaller number. An attacker can exploit this by creating an order with a very large amount (above uint160 limit) but only transferring a minimal amount due to the overflow. The contract records the large amount but receives only the small amount, allowing the attacker to manipulate the system and potentially drain funds by modifying or canceling the order. This leads to a mismatch between expected and actual token balances, resulting in financial loss for the protocol.\n",
            "severity": "High",
            "location": [
                "StopLimit.sol::createOrder",
                "StopLimit.sol::modifyOrder",
                "Bracket.sol::procureTokens",
                "Bracket.sol::modifyOrder",
                "OracleLess.sol::procureTokens"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Attackers can drain the OracleLess contract by creating an order with a malicious tokenIn and executing it with a malicious target",
            "description": "The OracleLess contract's createOrder() function does not validate whether the provided tokenIn is a legitimate ERC20 token, allowing attackers to use a malicious token. Additionally, the fillOrder() function does not validate the target address or txData, enabling arbitrary execution. The root cause is the lack of input validation and trust assumptions on external inputs. An attacker can create a malicious token that, when approved, transfers a small amount of a valuable token (e.g., WETH) to the contract. Then, by calling fillOrder() with a target set to a valuable token contract (e.g., USDT) and txData that encodes a transfer of all funds to the attacker, the execute() function will carry out the call. Due to the malicious approve logic, the contract receives 1 wei of WETH, satisfying the minAmountOut check (if set to 0), while the attacker drains all USDT from the contract. This results in a complete loss of funds held by the OracleLess contract for certain tokens.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::createOrder",
                "OracleLess.sol::fillOrder",
                "OracleLess.sol::execute"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-1265"
                ]
            },
            "title": "Lack of nonReentrant modifier in fillOrder() and modifyOrder() allows attacker to steal funds",
            "description": "The fillOrder() and modifyOrder() functions in OracleLess.sol are vulnerable to reentrancy attacks because they lack a nonReentrant modifier. The root cause is the absence of reentrancy protection despite performing external calls (via target.call(txData)) before state changes are fully secured. An attacker can create two orders and use a malicious contract as the recipient. When fillOrder() is called on the first order, the attacker's contract is triggered via the external call, allowing it to re-enter the OracleLess contract and call modifyOrder() to reduce the first order's size (receiving funds back) and increase the second order's size (parking the stolen funds). This manipulation allows the attacker to bypass the final balance checks because the net token balance appears unchanged. After the reentrancy, the attacker cancels the second order and withdraws all stolen funds. The impact is high, as attackers can steal user and protocol funds at minimal cost, undermining the financial integrity of the system.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::fillOrder",
                "OracleLess.sol::modifyOrder"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-666"
                ],
                "3": [
                    "CWE-672"
                ]
            },
            "title": "Double Withdrawal via Canceled Order Modification",
            "description": "Users can withdraw tokens from a canceled order and then modify the same order to withdraw the tokens a second time. This occurs because the contracts (Bracket, OracleLess, and StopLimit) do not validate whether an order has already been canceled before allowing modification. An attacker can cancel an order to withdraw the full amount of tokens, then modify the order (e.g., reducing amountIn to 1), triggering another withdrawal of nearly the full original amount. This flaw allows repeated exploitation, enabling an attacker to drain the contract of all its tokens.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::modifyOrder#171-225",
                "Bracket.sol",
                "StopLimit.sol"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-668"
                ],
                "3": [
                    "CWE-402"
                ]
            },
            "title": "Excessive Allowance Granting Leading to Fund Drain",
            "description": "The StopLimit contract grants the Bracket contract an allowance of type(uint256).max for the input token during the performUpkeep function. This excessive approval allows the Bracket contract to transfer tokens from the StopLimit contract without sufficient restriction. An attacker can exploit this by creating a malicious order in the Bracket contract where the tokenOut is one for which the Bracket contract already has a high allowance. By calling performUpkeep with crafted calldata that triggers a transferFrom from the StopLimit contract, the attacker can drain nearly all funds. The root cause is the use of safeIncreaseAllowance to set allowances to maximum values instead of the exact required amount.\n",
            "severity": "High",
            "location": [
                "StopLimit.sol::performUpkeep#100-104",
                "StopLimit.sol::updateApproval#397-411",
                "Bracket.sol::fillStopLimitOrder#147-165",
                "Bracket.sol::performUpkeep#85-101",
                "Bracket.sol::execute#526-568"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-404"
                ],
                "3": [
                    "CWE-772"
                ]
            },
            "title": "Failure to Reset Unspent Approval Leading to Contract Balance Theft",
            "description": "When filling orders, the contract grants arbitrary approvals to untrusted target contracts but fails to reset the allowance to zero after the external call. If the target contract does not use the full approved amount, the remaining allowance persists, allowing the target to later withdraw the unspent tokens. This is particularly dangerous because the order creator is refunded the full amountIn regardless of actual usage, enabling an attacker to create a malicious target contract that reuses leftover approvals to steal funds repeatedly. The root cause is the absence of a post-call approval reset (e.g., setting allowance to 0) after the interaction with the target.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::procureTokens#240",
                "Bracket.sol"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-340"
                ],
                "4": [
                    "CWE-341"
                ]
            },
            "title": "OrderId Collision Between StopLimit and Bracket Contracts Enabling Double Refund",
            "description": "The orderId generation function lacks contract-specific entropy, relying only on block.number and user address, which makes it deterministic and prone to collisions across different contracts (StopLimit and Bracket) within the same block. An attacker can exploit this by creating orders in both contracts in the same block, resulting in identical orderIds. After the StopLimit order is filled (which internally uses Bracket), the attacker can cancel the same orderId twice on the Bracket contract, receiving double refunds. This leads to direct financial loss, order state corruption, and compromise of the accounting system due to shared orderId space without isolation.\n",
            "severity": "High",
            "location": [
                "AutomationMaster.sol::generateOrderId",
                "Bracket.sol::createOrder",
                "StopLimit.sol::createOrder"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-807"
                ]
            },
            "title": "Insecure Use of Recipient in safeTransferFrom Leading to Unauthorized Token Transfers",
            "description": "The contracts (OracleLess, StopLimit, Bracket) use the order.recipient as the from address in safeTransferFrom calls when creating or modifying orders. This allows an attacker to create an order with a victim as the recipient, provided the victim has previously approved more tokens than used in a prior trade (leaving residual allowance). The protocol then transfers tokens from the victim to fulfill the order, which the attacker can immediately fill for profit. The root cause is the use of order.recipient instead of msg.sender in the transfer logic, enabling unauthorized token movement from users who have leftover allowances. This issue affects multiple functions across contracts and enables unfair order exploitation.\n",
            "severity": "High",
            "location": [
                "OracleLess.sol::procureTokens#280",
                "StopLimit.sol::createOrder#171",
                "StopLimit.sol::modifyOrder#226-230",
                "Bracket.sol::modifyOrder#250-254"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "DoS via Uncancellable Orders with Zero Address Recipient",
            "description": "Users can create orders with recipient set to address(0), which makes the order impossible to cancel due to USDT's (and other similar tokens) restriction on transfers to the zero address. When such an order is canceled, the safeTransfer call reverts, preventing cancellation. Since the pendingOrderIds array has a maximum size enforced by AutomationMaster, an attacker can fill it with uncancellable orders, blocking legitimate orders. Admins cannot cancel these orders, only increase the limit, which can be exploited again. This leads to a complete denial of service for the Bracket and StopLimit contracts.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::_cancelOrder#501-520",
                "StopLimit.sol",
                "USDT::_transfer"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-697"
                ]
            },
            "title": "Incorrect Price Freshness Validation in PythOracle",
            "description": "The contract incorrectly validates the freshness of price data from the Pyth Oracle by using a flawed comparison logic in the `checkInRange` function. The root cause is a reversed comparison operator in the require statement, where it checks `price.publishTime < block.timestamp - noOlderThan` instead of `price.publishTime >= block.timestamp - noOlderThan`. This causes valid and fresh prices to be rejected as stale. An attacker cannot directly exploit this, but users placing stop-limit orders will experience failed executions when valid price updates are misinterpreted as stale. This leads to missed trading opportunities, financial losses, and erosion of trust in the protocol's reliability.\n",
            "severity": "Medium",
            "location": [
                "PythOracle.sol::checkInRange#29",
                "PythOracle.sol::getPriceUnsafe#28-31"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/oracle/External/PythOracle.sol"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "Order Executed with Wrong Slippage Due to Dynamic Direction Logic",
            "description": "The order's execution direction is determined dynamically at creation time based on the current exchange rate relative to the takeProfit price. The root cause is the logic in the `createOrder` function that sets the direction using `MASTER.getExchangeRate(tokenIn, tokenOut) > takeProfit`, which is evaluated only once during order creation. If the market price moves beyond the takeProfit level by the time the order is executed, the order may be executed as a stop instead of a take-profit, due to both stopPrice and takeProfit being on the same side of the current price. This results in the use of stopSlippage (e.g., 15%) instead of the intended takeProfitSlippage (e.g., 5%), exposing the user to significantly worse execution prices and unexpected losses. The impact is incorrect slippage application leading to user fund loss.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::createOrder#492"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "User Can Brick Bracket Contract via Malicious txData and safeApprove Revert",
            "description": "Users can render the Bracket contract unusable for specific tokens by providing malicious `txData` during order creation that leaves a non-zero, non-full allowance (e.g., 1 wei) after a swap. The root cause is the use of an outdated `safeApprove` function from an old OpenZeppelin version, which reverts when attempting to approve a non-zero amount if the current allowance is also non-zero. This behavior is triggered when a malicious user crafts a swap that consumes `amountIn - 1` tokens, leaving a 1 wei allowance. Subsequent attempts to use `safeApprove` for that token will fail, blocking all future swaps involving that token. The impact is a denial-of-service (DoS) condition where the contract's swapping functionality is bricked for affected tokens, potentially locking user funds.\n",
            "severity": "Medium",
            "location": [
                "SafeERC20.sol::safeApprove#45-54",
                "Bracket.sol::execute"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/interfaces/openzeppelin/SafeERC20.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Missing feeBips Validation in OracleLess.createOrder",
            "description": "The `createOrder` function in the OracleLess contract does not validate the `feeBips` parameter, allowing users to set values greater than 10000 (which represents 100%). The root cause is the absence of a validation check such as `require(feeBips <= 10000)`. While orders with `feeBips > 10000` will eventually revert during execution, a malicious user can create numerous such orders. If the user also uses a blacklisted token or manipulates their recipient address, these orders can become non-cancelable. This allows an attacker to fill the `pendingOrderIds` queue, leading to a denial-of-service (DoS) for other users who cannot create new orders once `maxPendingOrders` is reached.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::createOrder#38-67"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Creation of Uncancelable Orders Using Malicious Token Contracts",
            "description": "The OracleLess contract does not restrict the `tokenIn` parameter in the `createOrder` function, allowing users to specify any contract that implements the IERC20 interface. The root cause is the lack of a token whitelist or sanity checks on the token contract. A malicious actor can deploy a token contract that reverts on transfer and use it as `tokenIn` to create an order. When the admin or another user attempts to cancel this order, the `_cancelOrder` function will try to refund the `tokenIn` to the user, causing a revert due to the malicious token's behavior. This results in uncancelable orders that permanently occupy space in the order queue, enabling a griefing attack.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::createOrder#38",
                "OracleLess.sol::_cancelOrder#160"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Malicious User Can Poison Bracket.sol with Blacklisted Recipient",
            "description": "Users can create orders in the Bracket contract with a recipient address that is blacklisted in the underlying token contract. The root cause is the lack of validation during order creation to check whether the recipient can receive tokens. While the order creator (a non-blacklisted address) can pay for and create the order, cancellation becomes impossible because the `_cancelOrder` function attempts to send tokens back to the blacklisted recipient, causing a revert. An attacker can flood the system with such orders, filling the `pendingOrderIds` array and causing a denial-of-service when `maxPendingOrders` is reached. This also increases gas costs for array operations.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::createOrder#362-368",
                "Bracket.sol::_cancelOrder#510-511"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-400"
                ],
                "3": [
                    "CWE-770"
                ]
            },
            "title": "DoS on Order Creation Due to Lack of Anti-Spam Fees",
            "description": "The protocol does not charge any fees for creating or canceling orders, making it economically viable for an attacker to spam the system. The root cause is the absence of a mandatory fee mechanism. A malicious user can create the maximum number of pending orders (e.g., 25) with conditions that will never be met (e.g., prices set to uint256.max). When the admin cancels these orders, the funds are refunded, allowing the attacker to reuse them to recreate orders. On low-cost chains like Optimism, this loop can be repeated indefinitely, preventing legitimate users from creating orders due to the \"Max Order Count Reached\" error. The impact is a persistent denial-of-service with low attack cost.\n",
            "severity": "Medium",
            "location": [
                "Bracket.sol::_createOrder#444-465",
                "StopLimit.sol::_createOrder#300-323"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "StopLimit Order Fails to Execute Due to Repeated Minimum Size Check",
            "description": "A StopLimit order may fail to execute even when in range because the system performs a minimum order size check twice: once at creation and again when converting to a Bracket order. The root cause is the lack of a bypass mechanism for internal order creations initiated by the StopLimit contract. For example, an order created with 100 USDC at $1.10 (value $110) passes the initial check, but if the USDC price drops to $0.90, the value becomes $90, below the $100 minimum. When `fillStopLimitOrder` tries to create a Bracket order, the second size check reverts the transaction. This breaks core functionality, preventing valid StopLimit orders from being filled under price volatility.\n",
            "severity": "Medium",
            "location": [
                "StopLimit.sol::performUpkeep#126",
                "Bracket.sol::_createOrder#473"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/StopLimit.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/Bracket.sol"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "cancelOrder Vulnerable to DoS from Unbounded Loop",
            "description": "The `cancelOrder` function contains an unbounded loop or array operation that can consume excessive gas as the number of pending orders increases. The root cause is inefficient data structure management, likely involving linear search or removal in an array without gas cost mitigation. An attacker can exploit this by filling the `pendingOrderIds` array to its maximum, causing the `cancelOrder` function to hit gas limits when attempting to remove an order. This renders order cancellation impossible, contributing to a denial-of-service condition and preventing cleanup of invalid or stale orders.\n",
            "severity": "Medium",
            "location": [
                "ArrayMutation::removeFromArray"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol",
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/libraries/ArrayMutation.sol"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-834"
                ]
            },
            "title": "Unbounded Iteration in _cancelOrder Leading to DoS",
            "description": "The _cancelOrder function iterates through the pendingOrderIds array to locate and remove an order, but this array has no upper bound on its size. The root cause is the lack of a mechanism to limit or efficiently manage the size of pendingOrderIds, combined with the O(n) removal operation. An attacker can exploit this by creating a large number of pending orders, forcing the loop to consume excessive gas. This results in a denial-of-service condition where legitimate users and even admins cannot cancel orders due to hitting the block gas limit, effectively paralyzing order management functionality.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::pendingOrderIds#L151",
                "OracleLess.sol::_cancelOrder"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Malicious users can createOrder with 0 amount and make DOS for all",
            "description": "Malicious users can repeatedly call createOrder with a zero amountIn, creating a large number of invalid orders. The root cause is the absence of input validation to prevent zero-amount orders in the createOrder function. This leads to an ever-growing pendingOrderIds array, which is iterated during fillOrder and cancelOrder via the removeFromArray function. When the array becomes sufficiently large, legitimate users will run out of gas when attempting to fill or cancel orders, resulting in a denial-of-service for all users relying on these functions.\n",
            "severity": "Medium",
            "location": [
                "OracleLess.sol::createOrder#L38C1-L67C6"
            ],
            "files": [
                "ee3f781a73d65e33fb452c9a44eb1337c5cfdbd6/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol"
            ]
        }
    ]
}