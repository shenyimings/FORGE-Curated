// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import { MandateOutput } from "../../src/input/types/MandateOutputType.sol";
import { LibAddress } from "../../src/libs/LibAddress.sol";
import { MandateOutputEncodingLib } from "../../src/libs/MandateOutputEncodingLib.sol";
import { OutputSettlerSimple } from "../../src/output/simple/OutputSettlerSimple.sol";
import { Test } from "forge-std/Test.sol";

import { MockCallbackExecutor } from "../mocks/MockCallbackExecutor.sol";
import { MockERC20 } from "../mocks/MockERC20.sol";

/**
 * @notice The purse of this test is to ensure that outputs can't be filled twice.
 */
contract FillOutputsTwiceTest is Test {
    using LibAddress for address;

    OutputSettlerSimple outputSettlerCoin;

    MockERC20 outputToken;
    MockCallbackExecutor mockCallbackExecutor;

    function setUp() public {
        outputSettlerCoin = new OutputSettlerSimple();
        outputToken = new MockERC20("TEST", "TEST", 18);
    }

    /// @dev This test specifically tests if we can ask whether an output has been filled.
    function test_fill_different_oracles() external {
        bytes32 orderId = bytes32(uint256(1));

        uint256 amount = 10 ** 18;
        address sender = makeAddr("sender");
        outputToken.mint(sender, amount * 2);
        vm.prank(sender);
        outputToken.approve(address(outputSettlerCoin), amount * 2);

        // This is the assumed "valid" output.
        MandateOutput memory output = MandateOutput({
            oracle: bytes32(uint256(uint160(address(this)))),
            settler: bytes32(uint256(uint160(address(outputSettlerCoin)))),
            chainId: block.chainid,
            token: bytes32(abi.encode(address(outputToken))),
            amount: amount,
            recipient: bytes32(abi.encode(makeAddr("recipient"))),
            callbackData: bytes(""),
            context: bytes("")
        });
        bytes memory fillerData = abi.encodePacked(sender.toIdentifier());

        {
            vm.prank(sender);
            bytes32 fillRecord = outputSettlerCoin.fill(orderId, output, type(uint48).max, fillerData);
            // Fill should succeed and return a valid fill record hash
            assertNotEq(fillRecord, bytes32(0));
            // Verify it matches the expected hash format
            bytes32 expectedFillRecord = keccak256(abi.encodePacked(sender.toIdentifier(), uint32(block.timestamp)));
            assertEq(fillRecord, expectedFillRecord);
        }

        // Validate that we can get the fill record:
        bytes memory fillDescription = MandateOutputEncodingLib.encodeFillDescriptionMemory(
            sender.toIdentifier(),
            orderId,
            uint32(block.timestamp),
            bytes32(uint256(uint160(address(outputToken)))),
            amount,
            bytes32(abi.encode(makeAddr("recipient"))),
            bytes(""),
            bytes("")
        );
        bytes[] memory payloads = new bytes[](1);
        payloads[0] = fillDescription;
        bool outputValid = outputSettlerCoin.hasAttested(payloads);
        assertEq(outputValid, true);

        // Fill the duplicate order with the intention to overwrite the solver.
        // This is the assumed "invalid" output.

        MandateOutput memory duplicateOutput = MandateOutput({
            oracle: bytes32(uint256(uint160(address(this)) + 1)),
            settler: bytes32(uint256(uint160(address(outputSettlerCoin)))),
            chainId: block.chainid,
            token: bytes32(abi.encode(address(outputToken))),
            amount: amount,
            recipient: bytes32(abi.encode(makeAddr("recipient"))),
            callbackData: bytes(""),
            context: bytes("")
        });
        bytes32 duplicateSolver = bytes32(uint256(123));
        bytes memory duplicateFillerData = abi.encodePacked(duplicateSolver);
        {
            vm.prank(sender);
            bytes32 duplicateFillRecord =
                outputSettlerCoin.fill(orderId, duplicateOutput, type(uint48).max, duplicateFillerData);
            // This is a different output (different oracle), so fill should succeed and return a different hash
            assertNotEq(duplicateFillRecord, bytes32(0));
            bytes32 expectedDuplicateFillRecord = keccak256(abi.encodePacked(duplicateSolver, uint32(block.timestamp)));
            assertEq(duplicateFillRecord, expectedDuplicateFillRecord);
        }
        bytes memory duplicateFillDescription = MandateOutputEncodingLib.encodeFillDescriptionMemory(
            duplicateSolver,
            orderId,
            uint32(block.timestamp),
            bytes32(uint256(uint160(address(outputToken)))),
            amount,
            bytes32(abi.encode(makeAddr("recipient"))),
            bytes(""),
            bytes("")
        );
        // Check that these would end up filling the same MandateOutput
        assertEq(this.getCommonPayload(fillDescription), this.getCommonPayload(duplicateFillDescription));

        bytes[] memory duplicatePayloads = new bytes[](1);
        duplicatePayloads[0] = duplicateFillDescription;
        outputValid = outputSettlerCoin.hasAttested(duplicatePayloads);
        assertEq(outputValid, false); // Ensure that this is not claimed as valid.
    }

    function getCommonPayload(
        bytes calldata fd
    ) external pure returns (bytes calldata commonPayload) {
        commonPayload = fd[68:];
    }
}
