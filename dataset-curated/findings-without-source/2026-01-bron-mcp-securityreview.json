{
    "path": "dataset-curated/reports/TrailofBits/2026-01-bron-mcp-securityreview.pdf",
    "project_info": {
        "url": "https://github.com/bronlabs/bron-crypto",
        "commit_id": "e01154cb34bda067fb4b1365b964afbcc554e6d5",
        "address": "n/a",
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-10-20",
        "project_path": {
            "bron-crypto": "dataset-curated/contracts/2026-01-bron-mcp-securityreview.pdf-source"
        }
    },
    "findings": [
        {
            "id": 0,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1286"
                ]
            },
            "title": "Signature aggregation rejects valid recovery IDs",
            "description": "The NewSignature function in the ECDSA signature implementation rejects recovery IDs that are not 0 or 1, despite the fact that ECDSA recovery IDs can validly be 2 or 3 when the x-coordinate of the public key exceeds the group modulus. The root cause is an overly restrictive validation check that fails to account for the full two-bit range of valid recovery values. This discrepancy arises because the recovery ID computation in ComputeRecoveryId can produce values from 0 to 3 by adding 2 when the x-coordinate rx is larger than the subgroup order. An attacker could potentially craft signatures with valid recovery IDs of 2 or 3 that would be incorrectly rejected by the system, leading to interoperability issues or denial of service for valid signatures. The impact is limited to rejection of otherwise valid signatures, which may affect system reliability and compatibility with other ECDSA implementations.\n",
            "severity": "Informational",
            "location": [
                "pkg/signatures/ecdsa/signature.go#L21-L23",
                "pkg/signatures/ecdsa/ecdsa.go#L50-L59",
                "SignatureAggregation.sol::aggregate#120"
            ],
            "files": [
                "bron-crypto/pkg/signatures/ecdsa/signature.go"
            ]
        },
        {
            "id": 1,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The base OT receivers use the same choice bits for all senders in DKLs23",
            "description": "In the DKLs23 threshold signature protocol, the base Oblivious Transfer (OT) receivers use identical choice bits across multiple senders, violating the fundamental security assumption of OT that choice bits must be independent and secret. This occurs due to improper generation or reuse of choice bits in the OT setup phase. Specifically, the choice bit generation is placed outside the loop over senders, leading to reuse across all senders. Although domain separation is used in OT extensions, which may mitigate some risks, this deviation from standard cryptographic practice undermines the security proofs of the underlying primitives. An attacker who observes or influences the OT execution could exploit this to learn secret inputs from the sender, undermining the confidentiality guarantees of the protocol. The impact could include full compromise of secret shares or signing keys if combined with other attacks, though the exact exploitability is undetermined.\n",
            "severity": "Informational",
            "location": [
                "BaseOTReceiver.go::Process#88",
                "pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/rounds.go#L50-L71",
                "pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/rounds.go#L63-L96"
            ],
            "files": [
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/rounds.go",
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/participant.go"
            ]
        },
        {
            "id": 2,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-351"
                ]
            },
            "title": "VSOT with naive batching does not provide endemic security",
            "description": "The Verifiable Secret Oblivious Transfer (VSOT) implementation uses naive batching techniques that do not preserve endemic security properties, meaning that security does not scale appropriately with batch size. The root cause lies in the lack of proper cross-checks or binding between batched elements, allowing an adversary to manipulate individual transfers without detection. Specifically, the implementation fails to include the index of each OT instance in the hash function used to derive pads, allowing a malicious receiver to send the same public key A across multiple batches, causing the resulting OT output pairs to be identical regardless of the batch index. This violates the endemic security notion, which requires that unselected outputs remain uniformly random and independent across batches. An attacker could selectively corrupt specific OT instances within a batch, leading to unauthorized disclosure of secret data. The impact depends on the protocol context but may result in partial or full leakage of sensitive information, though the precise exploit path remains undetermined.\n",
            "severity": "Informational",
            "location": [
                "VSOT.go::BatchTransfer#155",
                "pkg/ot/base/vsot/rounds.go#L103-L123"
            ],
            "files": [
                "bron-crypto/pkg/ot/base/vsot/vsot.go"
            ]
        },
        {
            "id": 3,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "VSOT sender inconsistently rejects identity point",
            "description": "The VSOT sender implementation applies inconsistent validation rules when rejecting the elliptic curve identity point in incoming messages. In some cases, the identity point is accepted while in others it is rejected, leading to undefined behavior and potential state divergence between parties. This inconsistency arises from fragmented validation logic across different code paths. Specifically, the sender checks whether the received public key A is the identity point (O) but fails to check whether A equals the sender's own public key B, which would result in A - B = O during computation. A malicious receiver can exploit this by sending A = B, which is equivalent to choosing a zero random scalar and a specific choice bit, potentially leaking their choice bit to the sender. Although the underlying math handles the point at infinity correctly, the inconsistency weakens the protocol's robustness and could be exploited in adversarial settings. The impact is primarily on protocol correctness and robustness, classified as informational due to lack of direct exploit.\n",
            "severity": "Informational",
            "location": [
                "VSOTSender.go::ValidateInput#201",
                "pkg/ot/base/vsot/rounds.go#L152-L171"
            ],
            "files": [
                "bron-crypto/pkg/ot/base/vsot/vsot.go"
            ]
        },
        {
            "id": 4,
            "category": {
                "1": [
                    "CWE-664"
                ],
                "2": [
                    "CWE-221"
                ],
                "3": [
                    "CWE-223"
                ]
            },
            "title": "SoftSpokenOT does not include all row indices in the final hash",
            "description": "The SoftSpokenOT protocol fails to incorporate all relevant row indices into the final transcript hash, breaking the binding property of the protocol. This omission occurs during the hash computation phase where certain indices are excluded due to a logic error. Specifically, the implementation includes the batch index j in the hash used to generate OT messages but omits the row index l within each batch, failing to uniquely identify each row. This deviates from the academic specifications of SoftSpokenOT and KOS15, where each row index is included to ensure independence. An attacker could exploit this to perform index substitution attacks, where one set of rows is replaced with another without detection. This weakens the integrity guarantees of the OT protocol and could enable selective manipulation of transferred data. Although no practical attack was identified, the omission invalidates the security proofs that rely on per-row uniqueness. The security impact is considered undetermined due to dependency on higher-level protocol assumptions.\n",
            "severity": "Informational",
            "location": [
                "SoftSpokenOT.go::FinalizeHash#302",
                "pkg/ot/extension/softspoken/rounds.go#L185-L200"
            ],
            "files": [
                "bron-crypto/pkg/ot/extension/softspoken/softspoken.go"
            ]
        },
        {
            "id": 5,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-335"
                ]
            },
            "title": "OT extension PRG is not necessarily unique due to potential seed collision",
            "description": "The Pseudorandom Generator (PRG) used in OT extension may produce non-unique outputs due to the possibility of seed collisions. This happens because the seed generation mechanism does not guarantee global uniqueness across sessions or participants. Specifically, the SoftSpokenOT extension uses ChaCha8 as a PRG with a seed derived by XORing the session ID and the base OT message. The use of a simple XOR operation can lead to seed collisions across different sessions if different base OT messages and session IDs combine to the same value. An attacker who can influence or predict seeds could cause collisions, leading to repeated PRG outputs and loss of secrecy in the OT channel. This compromises the semantic security of the OT extension and may allow an adversary to recover secret inputs. While no practical exploit was found, this violates the ideal PRG assumption and could allow an attacker to predict or correlate pseudorandom outputs. The impact is limited to degradation of cryptographic strength, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "OTExtension.go::GeneratePRG#410",
                "pkg/ot/extension/softspoken/rounds.go#L50-L60"
            ],
            "files": [
                "bron-crypto/pkg/ot/extension/softspoken/rounds.go"
            ]
        },
        {
            "id": 6,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "BBOT output conversion can include additional domain separation",
            "description": "The BBOT (Batched Oblivious Transfer) output conversion step lacks sufficient domain separation, increasing the risk of cross-protocol or cross-session confusion. The current implementation does not bind the output to the specific protocol context, sender, or receiver identities. Specifically, the BBOT output conversion uses an unkeyed Blake2b hash to convert field elements to byte arrays, without incorporating session-specific data like the session ID. Although domain separation is applied elsewhere in the protocol, adding a keyed hash would provide defense-in-depth by ensuring output uniqueness per session. An attacker could potentially replay or redirect outputs in a different context where the same PRG or derivation is used. While no immediate exploit is evident, this weakens the overall security argument and could lead to key confusion in composite protocols. The issue is classified as informational due to lack of direct impact.\n",
            "severity": "Informational",
            "location": [
                "BBOT.go::ConvertOutput#520",
                "pkg/ot/base/ecbbot/bbot.go#L111-L139"
            ],
            "files": [
                "bron-crypto/pkg/threshold/rvole/bbot/participant.go"
            ]
        },
        {
            "id": 7,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-393"
                ]
            },
            "title": "DKLs23 consistency check failures have wrong error type",
            "description": "When consistency checks fail in the DKLs23 protocol, the system returns an incorrect error type, which can mislead callers about the nature of the failure. This is caused by improper error mapping in the verification routines. Specifically, the implementation returns a generic Failed error instead of the protocol-specified TotalAbort or IdentifiableAbort. According to the protocol, such failures should trigger a complete abort and future exclusion of the misbehaving party. Using the wrong error type may prevent proper accountability and error handling in higher-level protocols. An attacker could exploit this by triggering specific failures and observing the erroneous responses to infer internal states or distinguish between different types of faults. This side-channel could aid in mounting more sophisticated attacks, though the direct impact is limited. The severity is undetermined due to potential for protocol-level exploitation.\n",
            "severity": "Informational",
            "location": [
                "DKLs23Verifier.go::CheckConsistency#601",
                "pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/rounds.go#L242-L247"
            ],
            "files": [
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot/participant.go"
            ]
        },
        {
            "id": 8,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-346"
                ]
            },
            "title": "Fischlin proofs are not bound to the prover",
            "description": "Fischlin zero-knowledge proofs in the implementation are not bound to the identity of the prover, allowing them to be replayed by other parties. This occurs because the proof transcript does not include the prover's public key or identifier. Specifically, Fischlin proofs include the session ID in the common hash (common-h) but do not bind the proof to the prover ID in the hash input. An attacker can capture a valid proof from one participant and replay it as their own, potentially gaining unauthorized access or bypassing authentication. This breaks the soundness of the proof system and enables impersonation attacks. Although no direct exploit was found in higher-level protocols, this breaks the simulatability requirement for Lindell22 and invalidates its security proof. The impact is moderate but limited to specific protocol flows, hence classified as low severity.\n",
            "severity": "Low",
            "location": [
                "FischlinProof.go::Prove#705",
                "FischlinProof.go::Verify#730",
                "pkg/proofs/sigma/compiler/fischlin/prover.go#L30-L121"
            ],
            "files": [
                "bron-crypto/pkg/proofs/fischlin/proof.go"
            ]
        },
        {
            "id": 9,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "The Fischlin verifier panics on malicious inputs",
            "description": "The Fischlin proof verifier contains unhandled edge cases that cause it to panic when processing specially crafted malicious inputs. This is due to missing input validation and improper error handling in the parsing and verification logic. Specifically, the verifier copies the challenge E[i] into a fixed-size byte array eBytes without first checking its length, allowing a malicious prover to send a challenge longer than expected, causing a negative offset in the copy operation and triggering a runtime panic. An attacker can send malformed proofs to trigger a panic, resulting in a denial of service condition that crashes the process or halts protocol execution. Since the library is intended for use in distributed systems, this could disrupt key generation or signing operations. The impact is limited to availability, hence classified as low severity.\n",
            "severity": "Low",
            "location": [
                "FischlinProof.go::Verify#730",
                "pkg/proofs/sigma/compiler/fischlin/verifier.go#L71-L90"
            ],
            "files": [
                "bron-crypto/pkg/proofs/fischlin/proof.go"
            ]
        },
        {
            "id": 10,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1289"
                ]
            },
            "title": "The library does not reject zero sharing IDs",
            "description": "The library allows the use of zero as a valid sharing ID, which can lead to ambiguity and potential key exposure. This occurs because there is no validation to reject zero-valued participant identifiers during initialization. A unit test demonstrates that the DKLs23 DKG protocol accepts zero IDs without rejection. An attacker could register with a zero ID and exploit this to manipulate secret sharing calculations or impersonate a default party. In combination with other vulnerabilities, this could lead to full key recovery. The impact includes potential key exposure and incorrect access control, especially if developers are unaware of the need for manual validation. The standalone impact is limited to misuse resistance, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "SharingManager.go::RegisterParticipant#801",
                "pkg/proofs/sigma/compiler/fischlin/verifier.go"
            ],
            "files": [
                "bron-crypto/pkg/threshold/sharing/sharing.go"
            ]
        },
        {
            "id": 11,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Malicious participant can increase sharing threshold for Feldman and Pedersen VSS",
            "description": "A malicious participant can manipulate the Verifiable Secret Sharing (VSS) setup in Feldman and Pedersen schemes to artificially increase the required sharing threshold, preventing honest parties from reconstructing the secret. This is caused by insufficient validation of public parameters submitted by participants. Specifically, the Gennaro DKG and HJKY key refresh protocols do not verify the length of the Feldman or Pedersen verification vectors, allowing a malicious participant to submit a longer vector and effectively increase the sharing threshold. The attacker can submit invalid commitments that inflate the threshold beyond the intended value. This results in a denial of service where the group cannot recover the shared secret, even if enough honest shares are present. The impact on protocol availability is significant, warranting a medium severity rating.\n",
            "severity": "Medium",
            "location": [
                "VSS.go::ProcessCommitments#910",
                "pkg/threshold/dkg/gennaro/rounds.go",
                "pkg/threshold/sharing/feldman/scheme.go",
                "pkg/base/polynomials/polynomial_module.go",
                "pkg/threshold/sharing/zero/hjky/rounds.go"
            ],
            "files": [
                "bron-crypto/pkg/threshold/dkg/gennaro/rounds.go"
            ]
        },
        {
            "id": 12,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Feldman verification does not check length of verification vector",
            "description": "The Feldman verification process in the DKG implementation does not validate the length of the received verification vector. This allows an attacker to provide a vector with more coefficients than expected, leading to incorrect polynomial evaluations. The root cause is the absence of a length check against the expected threshold during verification. An attacker can exploit this by sending an oversized verification vector during key generation or refresh, causing honest participants to accept shares derived from a higher-degree polynomial. This can result in a denial-of-service condition where honest parties cannot sign without the malicious party, or enable more sophisticated attacks such as rogue key constructions.\n",
            "severity": "Medium",
            "location": [
                "pkg/threshold/dkg/gennaro/rounds.go#L69\u2013L87",
                "pkg/threshold/sharing/feldman/scheme.go#L116\u2013L127",
                "pkg/base/polynomials/polynomial_module.go#L234\u2013L240",
                "pkg/threshold/sharing/zero/hjky/rounds.go#L73\u2013L78"
            ],
            "files": [
                "bron-crypto/pkg/threshold/dkg/gennaro/rounds.go"
            ]
        },
        {
            "id": 13,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-1293"
                ]
            },
            "title": "Gennaro DKG is vulnerable to rogue-key attacks by a malicious participant",
            "description": "The Gennaro Distributed Key Generation (DKG) protocol implementation is susceptible to rogue-key attacks, where a malicious participant can bias the resulting group public key. This occurs because the protocol does not properly enforce accountability or binding of individual contributions. Specifically, the implementation does not enforce that the same polynomial is used in both the Pedersen and Feldman commitment phases, nor does it bind the Feldman polynomial to the Pedersen commitment in a way that prevents manipulation. In a dishonest majority setting, or even in an honest majority if the vector length is not enforced (as in TOB-BRON-12), an attacker can construct polynomials that agree on honest participants' shares but differ elsewhere. This allows the attacker to control the final public key, as demonstrated in a 2-out-of-2 scenario where the attacker forces the public key to be one they control. This completely breaks the security of the DKG, allowing the attacker to sign arbitrarily on behalf of the group. The impact is severe, leading to full key compromise, justifying a high severity rating.\n",
            "severity": "High",
            "location": [
                "GennaroDKG.go::SubmitKeyShare#1020",
                "pkg/threshold/dkg/gennaro/rounds.go"
            ],
            "files": [
                "bron-crypto/pkg/threshold/dkg/gennaro/rounds.go"
            ]
        },
        {
            "id": 14,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Paillier nonces are sampled from the wrong space",
            "description": "Nonces used in the Paillier encryption scheme are sampled from an incorrect mathematical space, violating the cryptographic assumptions of the cryptosystem. This happens due to a flawed sampling function that does not ensure the required coprimality or range constraints. Specifically, the implementation samples nonces from the group (\u2124 / n\u00b2\u2124) instead of the correct group (\u2124 / n\u2124)*, which is required for semantic security. Additionally, there is no check that the sampled nonce r is coprime with n, which is necessary for r to be a valid element in the multiplicative group. Although the implicit reduction modulo n during encryption preserves uniformity, the lack of coprimality check becomes a risk if the modulus n is maliciously chosen. While no direct exploit is known, this deviation from the standard could lead to vulnerabilities in protocols like Lindell17 where the modulus is provided by another party. The impact is on long-term security assurance, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "Paillier.go::GenerateNonce#1130",
                "pkg/encryption/paillier/nonces.go#L28\u2013L34",
                "pkg/base/nt/znstar/paillier.go#L57\u2013L80"
            ],
            "files": [
                "bron-crypto/pkg/encryption/paillier/keys.go"
            ]
        },
        {
            "id": 15,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-1339"
                ]
            },
            "title": "The LPDL verifier accepts forged proofs",
            "description": "The LPDL (Linear Proof of Discrete Log) verifier accepts proofs that do not satisfy the required mathematical relationships, enabling proof forgery. This is caused by incorrect verification equations or missing checks in the validation logic. Specifically, the LPDL verifier samples the random value b from \u2124/q\u2124 instead of \u2124/q\u00b2\u2124, which is required to mask the product ax in the zero-knowledge proof. This allows a malicious prover to recover the verifier's random values a and b by analyzing the high bits of the response ay + b, since ay has 2n bits and b has only n bits. The prover can then forge a valid proof for an incorrect encryption. This undermines the integrity of any protocol relying on these proofs. The impact includes protocol failure during signing and potential false accusations of misbehavior. The severity is low due to limited exploit scope.\n",
            "severity": "Low",
            "location": [
                "LPDLProof.go::Verify#1240",
                "pkg/proofs/paillier/lpdl/rounds.go#L16\u2013L24"
            ],
            "files": [
                "bron-crypto/pkg/proofs/dlog/dlog.go"
            ]
        },
        {
            "id": 16,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "The library generates zero-sharing IDs",
            "description": "The library contains a convenience function that generates zero-valued sharing IDs, which should be prohibited. This contradicts security best practices where zero IDs can lead to ambiguity or exploitation in secret sharing schemes. The function likely exists for testing or default initialization but is accessible in production code. Specifically, the NewOrdinalShareholderSet function generates shareholder IDs starting from 0, which violates the security of Shamir's Secret Sharing. In this scheme, the secret is f(0), so a participant with ID 0 receives f(0) directly, learning the entire secret instead of a share. This breaks the threshold security model and allows the ID 0 participant to act alone. Although this was patched in a later commit (4dfa2c), the audited version (e01154) is vulnerable. An attacker could exploit this to inject a zero ID participant and manipulate the sharing logic. Combined with other issues like TOB-BRON-11, this increases the risk of key exposure. The impact is primarily on misuse resistance, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "SharingID.go::GenerateZeroID#1350",
                "pkg/threshold/sharing/utils.go#L11\u2013L17"
            ],
            "files": [
                "bron-crypto/pkg/threshold/sharing/shamir/shamir.go"
            ]
        },
        {
            "id": 17,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-684"
                ],
                "3": [
                    "CWE-440"
                ]
            },
            "title": "BLS key generation does not match standard recommendations",
            "description": "The BLS key generation process deviates from established cryptographic standards, such as those defined in IETF drafts or academic references. Specifically, it may use non-standard hashing to curve or key derivation methods. The generateWithSeed function appends an additional 0 byte in each iteration of the HKDF loop, whereas the standard appends exactly one 0 byte per iteration; and it reverses only the first 48 bytes of the output, while the standard uses OS2IP in big-endian mode. Although the resulting keys are still secure and standard-compliant, these deviations are likely unintentional and could lead to interoperability issues. While no immediate exploit is known, it increases the attack surface and reduces confidence in the implementation. The impact is on long-term security assurance and auditability, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "BLS.go::GenerateKeyPair#1460",
                "pkg/signatures/bls/core.go#L37\u2013L51"
            ],
            "files": [
                "bron-crypto/pkg/signatures/bls/bls.go"
            ]
        },
        {
            "id": 18,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "The pailliern proof does not incorporate statement",
            "description": "The Paillier zero-knowledge proof (likely referring to a range or knowledge proof) does not bind the proof to the specific statement being proven, allowing potential replay or substitution attacks. This occurs because the statement (e.g., ciphertext or plaintext) is not included in the challenge computation. Specifically, the Fiat-Shamir transcript in the pailliern proof does not include the Paillier modulus N, meaning the challenge generation is independent of the statement being proven. This allows an attacker with knowledge of the session ID to predict or manipulate challenge values before choosing N. Although extractRhos uses rejection sampling, which loosely depends on N, the probability of rejection between N and N+1 is negligible, making the challenge effectively independent. This breaks the random oracle assumption and weakens the zero-knowledge property. The impact is on proof soundness and integrity, classified as informational. The severity is informational as the pailliern module is currently unused.\n",
            "severity": "Informational",
            "location": [
                "PaillierProof.go::Prove#1570",
                "pkg/proofs/paillier/pailliern/pailliern.go"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/pailliern/pailliern.go"
            ]
        },
        {
            "id": 19,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-228"
                ],
                "3": [
                    "CWE-237"
                ],
                "4": [
                    "CWE-240"
                ]
            },
            "title": "Paillier range proof serialization problems",
            "description": "The serialization and deserialization of Paillier range proofs are inconsistent, potentially leading to parsing errors or malleability. This may result from missing canonicalization, incorrect field ordering, or lack of validation upon deserialization. Specifically, the serialization methods for Paillier range proofs (SerializeStatement, SerializeCommitment, SerializeResponse) use byte concatenation with fixed separators, while other methods (Bytes) omit separators entirely. Both approaches are vulnerable to ambiguous deserialization, allowing different inputs to produce identical serialized outputs. For example, {0x10000000, 0x1000, 0x50} can serialize to the same output as {0x10000, 0x00, 0x100050}. An attacker could exploit this to craft malformed serialized proofs that are accepted and interpreted incorrectly, possibly leading to acceptance of invalid proofs. This could be exploited in distributed settings where proofs are transmitted over the network. The impact includes proof malleability and potential framing of honest parties. The severity is low.\n",
            "severity": "Low",
            "location": [
                "PaillierRangeProof.go::Serialize#1680",
                "PaillierRangeProof.go::Deserialize#1700",
                "pkg/proofs/paillier/range/range.go"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/range/range.go"
            ]
        },
        {
            "id": 20,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Public key material equality test does not ensure equality",
            "description": "The function used to compare public key material does not correctly verify equality, potentially returning true for non-identical keys. This is likely due to shallow comparison, missing field checks, or incorrect handling of encoding formats. Specifically, the Equal method for BasePublicMaterial only checks that the partial public keys in the left-hand side are a subset of those in the right-hand side, but does not verify the reverse. This means that a smaller set can be considered equal to a larger one if all its elements are present. The root cause is the absence of a size check or bidirectional comparison. This flaw also exists in PublicMaterial.Equal and AuxiliaryInfo.Equal. An attacker could exploit this by presenting a maliciously crafted key that passes the equality check but behaves differently in cryptographic operations. This could lead to key substitution or impersonation attacks. The impact is mitigated by other checks, so it is classified as informational.\n",
            "severity": "Informational",
            "location": [
                "PublicKey.go::Equals#1810",
                "pkg/threshold/tsig/tschnorr/tschnorr.go",
                "pkg/threshold/tsig/base_shard.go#L53\u2013L65",
                "pkg/threshold/tsig/tbls/tbls.go#L55\u2013L67",
                "pkg/threshold/tsig/tecdsa/lindell17/shard.go#L39\u2013L56"
            ],
            "files": [
                "bron-crypto/pkg/encryption/elgamal/elements.go",
                "bron-crypto/pkg/threshold/tsig/tschnorr/tschnorr.go",
                "bron-crypto/pkg/threshold/tsig/tbls/tbls.go"
            ]
        },
        {
            "id": 21,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1288"
                ]
            },
            "title": "Inconsistent Paillier plaintext representations",
            "description": "The library uses multiple, inconsistent representations for Paillier plaintext values across different functions, increasing the risk of logic errors. For example, some functions expect signed integers while others use unsigned or modular representations. Specifically, there are three conflicting definitions of valid Paillier plaintexts: (1) values in the symmetric interval [-(n-1)/2, (n-1)/2), (2) any integer within explicit bounds from sample calls, and (3) values in (-n, n) accepted by isValid. The isValid method only checks |x| < n, not |x| < (n-1)/2, allowing out-of-range values to be considered valid. Although inputs are normalized in Add and Sub, this inconsistency can lead to incorrect encryption or decryption results when values cross function boundaries. An attacker could exploit this by feeding edge-case values that are misinterpreted, potentially leading to information leakage or protocol failure. The impact is on correctness and robustness, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "Paillier.go::Encrypt#1920",
                "Paillier.go::Decrypt#1950",
                "pkg/encryption/paillier/plaintexts.go#L34\u2013L60",
                "pkg/encryption/paillier/plaintexts.go#L124\u2013L134",
                "pkg/base/nt/num/z.go#L372\u2013L377"
            ],
            "files": [
                "bron-crypto/pkg/encryption/paillier_ct/paillier.go"
            ]
        },
        {
            "id": 22,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1286"
                ]
            },
            "title": "Ineffective input validation in LPDL verifier",
            "description": "The LPDL verifier performs insufficient input validation, allowing malformed or out-of-range elements to be processed. This includes missing checks for group membership, correct encoding, or expected length. An attacker could exploit this by submitting invalid inputs that trigger edge cases or bypass verification logic. This could lead to crashes, incorrect outputs, or potential bypass of the proof system. The impact is primarily on robustness, classified as informational.\n",
            "severity": "Informational",
            "location": [
                "LPDLProof.go::Verify#1240",
                "pkg/base/nt/crt/crt_multi.go"
            ],
            "files": []
        },
        {
            "id": 23,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ]
            },
            "title": "Malicious Alice can use invalid Paillier ciphertext to recover Lindell17 key",
            "description": "In the Lindell17 threshold ECDSA protocol, a malicious party (Alice) can submit an invalid Paillier ciphertext during the signing phase to recover the victim's private key share. This occurs due to inadequate validation of ciphertexts before use in homomorphic operations. The attacker crafts a special ciphertext that, when processed, leaks information about the secret through side channels or mathematical relationships. This leads to full private key recovery, compromising the entire threshold system. The impact is catastrophic, warranting a high severity rating.\n",
            "severity": "High",
            "location": [
                "Lindell17Sign.go::ProcessCiphertext#2050"
            ],
            "files": []
        },
        {
            "id": 24,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Paillier range proof verifier fails to check input lengths",
            "description": "The Paillier range proof verifier does not validate the length of incoming proof data before processing, making it vulnerable to buffer overflow or denial of service. This lack of bounds checking allows an attacker to send truncated or excessively long inputs that can crash the verifier or cause memory corruption. Even if memory safety is guaranteed by the language, this can still lead to panics or infinite loops. The impact is on availability and robustness, classified as low severity.\n",
            "severity": "Low",
            "location": [
                "PaillierRangeProof.go::Verify#2160"
            ],
            "files": []
        },
        {
            "id": 25,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Insufficient test coverage",
            "description": "The codebase lacks sufficient unit and integration test coverage, particularly for edge cases, error handling, and malicious inputs. This was confirmed through automated coverage analysis using the Go cover tool. Critical protocol components have untested code paths that could harbor undiscovered bugs. An attacker could exploit untested functionality that behaves incorrectly under rare conditions. The absence of negative tests for known failure modes increases the risk of undetected vulnerabilities. The impact is on long-term maintainability and security assurance, classified as low.\n",
            "severity": "Low",
            "location": [
                "coverage-report.txt"
            ],
            "files": []
        },
        {
            "id": 26,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Verifier incorrectly checks Enc(x) is both zero and one simultaneously",
            "description": "The function validateVerifierInputs incorrectly validates the encrypted key share Enc(x) by checking if it is both zero and one at the same time using a logical AND operation, which will never be true. This is due to a flawed conditional statement: `v.IsZero()&v.Equal(numct.NatOne()) == ct.True`, which combines two mutually exclusive conditions. As a result, invalid ciphertexts with value zero are not properly rejected. Since zero is not a valid element in (\u2124 / n\u00b2\u2124)*, it should be rejected to prevent potential attacks. A malicious prover sending Enc(x) = 0 cannot learn secret values a and b and cannot complete the proof, but the incorrect validation logic undermines the security assumptions of the protocol.\n",
            "severity": null,
            "location": [
                "bron-crypto/pkg/proofs/paillier/lpdl/participants.go#L178\u2013L180"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/lpdl/participants.go"
            ]
        },
        {
            "id": 27,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Malicious Alice can use invalid Paillier ciphertext to recover Lindell17 key",
            "description": "During the Lindell17 DKG protocol, Bob fails to verify that nonces, received ciphertexts, or generated ciphertexts are coprime with Alice\u2019s Paillier modulus. This allows a malicious Alice to craft a malformed Paillier key (e.g., N = p\u2080\u00b7p\u2081\u00b7p\u2082) and submit zero or non-coprime values that bypass validation. The root cause is the absence of cryptographic checks on input validity, particularly coprimality with N. An attacker can exploit this by submitting crafted ciphertexts and nonces that result in zero when combined, enabling decryption of exponents used in homomorphic operations. This allows Alice to recover Bob\u2019s private key share and ultimately the full private key, breaking the threshold security model.\n",
            "severity": "High",
            "location": [
                "pkg/threshold/tsig/tecdsa/lindell17/keygen/dkg/round.go",
                "https://github.com/bronlabs/bron-crypto/pull/88/commits/c2a6aadfc13f4234f2b85949b0b9f5017fa1d38c"
            ],
            "files": [
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/rounds.go"
            ]
        },
        {
            "id": 28,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "Paillier range proof verifier fails to check input lengths",
            "description": "The Verify method in the Paillier range proof implementation does not validate the lengths of critical arrays such as response.W1, response.W2, response.R1, response.R2, response.Wj, response.J, commitment.C1, and commitment.C2. The root cause is missing input validation for untrusted data. An attacker can exploit this by submitting a malformed proof with shortened arrays, causing the method to panic due to out-of-bounds array access. This leads to a denial-of-service condition, disrupting protocol execution and potentially crashing the service, especially in a production environment where robustness is critical.\n",
            "severity": "Low",
            "location": [
                "pkg/proofs/paillier/range/range.go",
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/06dbf8744e7ffec3a51df0d32289f3fd2a4444cb"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/range/range.go"
            ]
        },
        {
            "id": 29,
            "category": {
                "1": [
                    "CWE-710"
                ]
            },
            "title": "Insufficient test coverage",
            "description": "The codebase lacks sufficient unit and negative testing, particularly for critical components such as the Fiat-Shamir compiler and polynomial operations used in secret sharing. While many components have basic tests, coverage is inadequate, leaving key functions untested. The root cause is incomplete testing practices and lack of automated enforcement. An attacker or developer could introduce a vulnerability during refactoring that goes undetected due to missing test cases. This increases the risk of deploying insecure or incorrect code into production, especially in cryptographic protocols where subtle bugs can have severe consequences.\n",
            "severity": "Low",
            "location": [
                "pkg/*",
                "https://github.com/bronlabs/bron-crypto/commit/afbba54e5b6db926adc0118928c6addc8f386e6e"
            ],
            "files": []
        },
        {
            "id": 30,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Signature aggregation rejects valid recovery IDs",
            "description": "The signature aggregation logic previously rejected certain valid recovery IDs, which are used to reconstruct the public key during ECDSA signature verification. This was caused by overly restrictive validation logic that did not conform to the standard. An attacker could potentially exploit this by crafting signatures with valid but non-standard recovery IDs, leading to denial of service by causing valid signatures to be rejected. The impact is limited to availability and interoperability, not fund loss or privilege escalation.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/7d2addc706b78c2dfc9739fed259dd365b1b5c33"
            ],
            "files": [
                "bron-crypto/pkg/signatures/ecdsa/ecdsa.go"
            ]
        },
        {
            "id": 31,
            "category": {
                "1": [
                    "CWE-691"
                ],
                "2": [
                    "CWE-670"
                ]
            },
            "title": "The base OT receivers use the same choice bits for all senders in DKLs23",
            "description": "The base oblivious transfer (OT) receivers used identical choice bits across all senders in the DKLs23 protocol, undermining the security assumptions of the OT extension. This was caused by the choice bit generation being placed outside the sender loop. A malicious sender could exploit this to correlate choices across OT instances, potentially recovering the receiver's secret inputs. This breaks the privacy guarantees of the protocol and could lead to full secret exposure in multi-party computation contexts.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/e89f75f8f05302f5d994e81123dfe870c36cf748"
            ],
            "files": [
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot/participant.go"
            ]
        },
        {
            "id": 32,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "VSOT with naive batching does not provide endemic security",
            "description": "The VSOT (Vector-Single OT) implementation with naive batching failed to provide endemic security due to the lack of batch indexing in the hash input. This caused correlations between input points across batches, allowing an attacker to detect when the same input was used in different batches. The root cause was the absence of unique contextual data in the hash computation. This could be exploited to link operations and infer secret values, weakening the overall security of the protocol.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/00dc08206daa7b566d63870c88c49f4de15b8c84"
            ],
            "files": [
                "bron-crypto/pkg/ot/base/vsot/vsot.go",
                "bron-crypto/pkg/ot/base/vsot/participant.go"
            ]
        },
        {
            "id": 33,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "VSOT sender inconsistently rejects identity point",
            "description": "The VSOT sender had inconsistent behavior when handling the identity point on the elliptic curve, sometimes rejecting it and sometimes not. This was due to incomplete input validation logic. An attacker could exploit this inconsistency to trigger undefined behavior or bypass certain checks, potentially leading to protocol failures or side-channel leaks. The impact is primarily on robustness and predictability of the system.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/f3cfdb04f1b5e47b5e64ea97767afe023576c086"
            ],
            "files": [
                "bron-crypto/pkg/ot/base/vsot/vsot.go",
                "bron-crypto/pkg/ot/base/vsot/participant.go"
            ]
        },
        {
            "id": 34,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "SoftSpokenOT does not include all row indices in the final hash",
            "description": "The SoftSpokenOT protocol did not include all relevant row indices in the final hash, which is used for integrity verification. This omission was due to incomplete transcript construction. An attacker could exploit this by manipulating row indices without detection, potentially leading to desynchronization between parties or undetected tampering. This weakens the authenticity and integrity guarantees of the protocol.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/fc573d300476fd2fe4924db59b279c1c966a9b2a",
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/9ae6ef945cce6210a8f2bbf5e699662e7f178dab"
            ],
            "files": [
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_softspoken/participant.go"
            ]
        },
        {
            "id": 35,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-330"
                ],
                "3": [
                    "CWE-335"
                ],
                "4": [
                    "CWE-336"
                ]
            },
            "title": "OT extension PRG is not necessarily unique due to potential seed collision",
            "description": "The PRG (Pseudorandom Generator) used in OT extension was vulnerable to seed collisions, meaning different sessions could produce identical keystreams. This was caused by using a non-keyed hash function without session-specific context. An attacker could exploit this to correlate outputs across sessions, breaking the independence of OT instances and potentially recovering secret data. The impact includes loss of confidentiality in multi-session scenarios.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/9ae6ef945cce6210a8f2bbf5e699662e7f178dab"
            ],
            "files": [
                "bron-crypto/pkg/ot/extension/softspoken/rounds.go"
            ]
        },
        {
            "id": 36,
            "category": {
                "1": [
                    "CWE-707"
                ]
            },
            "title": "BBOT output conversion can include additional domain separation",
            "description": "The BBOT (Batched Oblivious Transfer) output conversion lacked sufficient domain separation, increasing the risk of hash collisions across different contexts. This was due to using the same hash function without unique labels. An attacker could exploit this to forge outputs or link different operations. The fix added domain separation using transcript-derived keys and indices, ensuring uniqueness across contexts.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/24d523521bbb72570f505a9d8bdd6d604bab1108"
            ],
            "files": [
                "bron-crypto/pkg/ot/extension/softspoken/rounds.go"
            ]
        },
        {
            "id": 37,
            "category": {
                "1": [
                    "CWE-703"
                ],
                "2": [
                    "CWE-393"
                ]
            },
            "title": "DKLs23 consistency check failures have wrong error type",
            "description": "The DKLs23 protocol returned incorrect error types during consistency check failures, which could lead to improper error handling by higher-level protocols. This was caused by using generic error types instead of specific abort types. An attacker could exploit this to mask malicious behavior as benign errors, potentially bypassing detection mechanisms. The fix introduced proper error typing to distinguish between identifiable and total aborts.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/06dbf8744e7ffec3a51df0d32289f3fd2a4444cb",
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/ada9502",
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/fdb6108"
            ],
            "files": [
                "bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/rounds.go"
            ]
        },
        {
            "id": 38,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-345"
                ],
                "3": [
                    "CWE-346"
                ]
            },
            "title": "Fischlin proofs are not bound to the prover",
            "description": "Fischlin proofs were not bound to the identity of the prover, allowing potential replay attacks where a proof from one party could be reused by another. This was caused by missing prover identity in the transcript. An attacker could exploit this to impersonate another party or bypass authentication checks. The fix required including the prover identity in the transcript, ensuring proofs are unique to each prover.\n",
            "severity": "Low",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/9f5593ddfe24e35dd463e9d375b6dc5ee07ac1ef",
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/fc04249"
            ],
            "files": [
                "bron-crypto/pkg/proofs/sigma/compiler/fischlin/fischlin.go"
            ]
        },
        {
            "id": 39,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1284"
                ]
            },
            "title": "The Fischlin verifier panics on malicious inputs",
            "description": "The Fischlin verifier could panic when processing maliciously crafted inputs, leading to denial of service. This was caused by missing input length validation. An attacker could exploit this by sending malformed challenges to crash the verifier. The fix added proper input validation to return an error instead of panicking, improving system robustness.\n",
            "severity": "Low",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/6c40f93896f4e2bf54df6b1cbd9462abf1c13ece"
            ],
            "files": [
                "bron-crypto/pkg/proofs/sigma/compiler/fischlin/fischlin.go"
            ]
        },
        {
            "id": 40,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "The library does not reject zero sharing IDs",
            "description": "The library allowed zero as a valid sharing ID in secret sharing schemes, which could lead to ambiguity or collisions in share identification. This was caused by missing input validation. An attacker could exploit this to create conflicting shares or bypass access controls. The fix added validation to reject zero sharing IDs.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/commit/82ce433d0f70648d609ca08ac36b1baeb025fb77"
            ],
            "files": [
                "bron-crypto/pkg/threshold/sharing/sharing.go"
            ]
        },
        {
            "id": 41,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Malicious participant can increase sharing threshold for Feldman and Pedersen VSS",
            "description": "A malicious participant could manipulate the degree of their polynomial in Feldman and Pedersen VSS to effectively increase the sharing threshold, preventing reconstruction by honest parties. This was caused by missing degree validation in the verifier. An attacker could exploit this to disrupt the protocol and cause denial of service. The fix added explicit degree checks against the expected threshold.\n",
            "severity": "Medium",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/92856610bc7f3efc58d75725207df5d3bc0a33b5",
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/06dbf8744e7ffec3a51df0d32289f3fd2a4444cb"
            ],
            "files": [
                "bron-crypto/pkg/threshold/sharing/feldman/scheme.go",
                "bron-crypto/pkg/threshold/sharing/pedersen/scheme.go"
            ]
        },
        {
            "id": 42,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Gennaro DKG is vulnerable to rogue-key attacks by a malicious participant",
            "description": "The Gennaro DKG protocol was vulnerable to rogue-key attacks, where a malicious participant could manipulate the final group public key to a value of their choosing. This was caused by the lack of proof of possession of the secret key during key generation. An attacker could exploit this to gain full control over the shared key, enabling them to sign arbitrarily. The fix required participants to provide a Schnorr proof on their verification vector coefficients.\n",
            "severity": "High",
            "location": [
                "https://github.com/bronlabs/bron-crypto/commit/4a6a161e3cfa2f42962e3aa770e4da0c39e9e841"
            ],
            "files": [
                "bron-crypto/pkg/threshold/dkg/gennaro/rounds.go",
                "bron-crypto/pkg/threshold/dkg/gennaro/participant.go"
            ]
        },
        {
            "id": 43,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "Paillier nonces are sampled from the wrong space",
            "description": "Paillier nonces were sampled from the Paillier group instead of the RSA group, and were not verified to be coprime to the modulus. This could lead to decryption failures or security degradation. The root cause was incorrect group selection and missing validation. The fix redefined nonce generation within the RSA group and added coprimality checks.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/d6799e76d47bc0bf82d8704bfe2165914029960e"
            ],
            "files": [
                "bron-crypto/pkg/encryption/paillier/nonces.go"
            ]
        },
        {
            "id": 44,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "The LPDL verifier accepts forged proofs",
            "description": "The LPDL verifier accepted forged proofs because it did not properly generate the required parameter b from the correct algebraic structure. This allowed attackers to construct invalid proofs that would be accepted as valid. The fix ensured the parameter is correctly generated from \u2124 / q[2]\u2124.\n",
            "severity": "Low",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/29e50fa7986ce53af3c34b5c61175aeb74f545ef"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/lpdl/rounds.go",
                "bron-crypto/pkg/proofs/paillier/lpdl/participants.go"
            ]
        },
        {
            "id": 45,
            "category": {
                "1": [
                    "CWE-682"
                ],
                "2": [
                    "CWE-193"
                ]
            },
            "title": "The library generates zero-sharing IDs",
            "description": "The library generated zero as a sharing ID during share distribution, which could conflict with reserved values or cause logical errors. This was due to using zero-based indexing without offset. The fix adjusted indexing to use i+1, ensuring no share ID is zero.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/commit/4dfa2c76a4d7661372add12511de202e4c19c9e4"
            ],
            "files": [
                "bron-crypto/pkg/threshold/sharing/shamir/shamir.go"
            ]
        },
        {
            "id": 46,
            "category": {
                "1": [
                    "CWE-710"
                ],
                "2": [
                    "CWE-573"
                ],
                "3": [
                    "CWE-358"
                ]
            },
            "title": "BLS key generation does not match standard recommendations",
            "description": "The BLS key generation process deviated from established standards, potentially affecting interoperability and security assumptions. This was due to non-standard implementation choices. The fix aligned the process with the recommended specification.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/60/commits/1319424ebc67f2218eaa35d3821a0bd71213c856"
            ],
            "files": [
                "bron-crypto/pkg/signatures/bls/bls.go"
            ]
        },
        {
            "id": 47,
            "category": {
                "1": [
                    "CWE-693"
                ],
                "2": [
                    "CWE-358"
                ]
            },
            "title": "The pailliern proof does not incorporate statement",
            "description": "The Paillier proof did not bind to the statement being proven, allowing potential replay or substitution attacks. This was caused by omitting the modulus from the proof context. The fix included the modulus in the proof to ensure it is statement-specific.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/06dbf8744e7ffec3a51df0d32289f3fd2a4444cb"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/lp/rounds.go",
                "bron-crypto/pkg/proofs/paillier/lp/participants.go"
            ]
        },
        {
            "id": 48,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-228"
                ],
                "3": [
                    "CWE-166"
                ]
            },
            "title": "Paillier range proof serialization problems",
            "description": "The Paillier range proof serialization methods had issues due to missing length prefixes, leading to ambiguous parsing. This could cause deserialization failures or potential memory issues. The fix added 64-bit length prefixes to each component and removed unsafe serialization functions.\n",
            "severity": "Low",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/06dbf8744e7ffec3a51df0d32289f3fd2a4444cb"
            ],
            "files": [
                "bron-crypto/pkg/encryption/paillier/cbor.go"
            ]
        },
        {
            "id": 49,
            "category": {
                "1": [
                    "CWE-697"
                ],
                "2": [
                    "CWE-1023"
                ]
            },
            "title": "Public key material equality test does not ensure equality",
            "description": "The equality check for public key material structures did not fully verify equality, as it did not compare the sizes of contained structures. This allowed unequal structures to pass as equal if one was a subset of the other. The fix added size comparison to ensure true equality.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/06dbf8744e7ffec3a51df0d32289f3fd2a4444cb",
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/ada9502"
            ],
            "files": [
                "bron-crypto/pkg/encryption/paillier/keys.go"
            ]
        },
        {
            "id": 50,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ]
            },
            "title": "Inconsistent Paillier plaintext representations",
            "description": "The system used inconsistent representations for Paillier plaintexts, potentially leading to validation bypasses or incorrect decryption. This was due to missing range checks. The fix added validation to ensure plaintexts are within the correct symmetric range.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/40c2d9d84229eb6547671be40a7f23bc0a6e47c9"
            ],
            "files": [
                "bron-crypto/pkg/encryption/paillier/plaintexts.go"
            ]
        },
        {
            "id": 51,
            "category": {
                "1": [
                    "CWE-707"
                ],
                "2": [
                    "CWE-20"
                ],
                "3": [
                    "CWE-1287"
                ]
            },
            "title": "Ineffective input validation in LPDL verifier",
            "description": "The LPDL verifier performed ineffective input validation, particularly on encrypted values, which could allow malformed inputs to proceed. This was due to overly permissive checks. The fix simplified validation to only ensure non-nil inputs, removing incorrect checks.\n",
            "severity": "Informational",
            "location": [
                "https://github.com/bronlabs/bron-crypto/pull/72/commits/5b58a46e61869a484fb1d62708b7eec8f560ce98"
            ],
            "files": [
                "bron-crypto/pkg/proofs/paillier/lpdl/participants.go",
                "bron-crypto/pkg/proofs/paillier/lpdl/rounds.go",
                "bron-crypto/pkg/proofs/paillier/lpdl/messages.go"
            ]
        }
    ]
}