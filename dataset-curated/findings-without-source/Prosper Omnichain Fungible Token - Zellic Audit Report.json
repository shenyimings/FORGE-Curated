{
    "path": "dataset-curated/reports/Zellic/Prosper Omnichain Fungible Token - Zellic Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/hyplabs/prosper-hash-token"
        ],
        "commit_id": [
            "e43be0e1802669b7716c406806f0b8f47b5f3587"
        ],
        "address": [
            "0x915424Ac489433130d92B04096F3b96c82e92a9D"
        ],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-01-14",
        "project_path": "n/a"
    },
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Burn request emitted on identical amounts",
            "description": "The requestBurn function allows a user to request burning their tokens and updates the burnRequests mapping. However, it emits a BurnRequested event even when the user calls the function with the same amount as their previous request, resulting in duplicate events being emitted without any actual change in state.\nThe root cause is the lack of a check to prevent redundant event emissions when the requested burn amount has not changed.\nAn attacker or user could exploit this by repeatedly calling requestBurn with the same amount, leading to redundant events.\nThe impact is low but could mislead off-chain services or front-ends that rely on these events for state updates, potentially causing incorrect display of data such as token prices or burn metrics.\n",
            "severity": "Low",
            "location": [
                "Token.sol::requestBurn"
            ],
            "files": []
        },
        {
            "id": 1,
            "category": {},
            "title": "Denial of service on pending requests",
            "description": "The getPendingBurnRequests function retrieves all pending burn requests by iterating over the entire burnRequests mapping. An attacker can perform many small burn requests, increasing the size of the mapping until the gas cost of calling this function exceeds the block limit, causing the call to fail.\nThe root cause is the unbounded loop in the function, which does not paginate or limit the number of returned results.\nAn attacker could exploit this by submitting a large number of small burn requests, effectively causing a denial of service for any system component or user relying on this function.\nThe impact is a potential disruption of services that depend on querying pending burn requests, especially in decentralized applications or monitoring tools, though it does not directly lead to fund loss.\n",
            "severity": "Low",
            "location": [
                "Token.sol::getPendingBurnRequests"
            ],
            "files": []
        }
    ]
}