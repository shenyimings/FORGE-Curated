{
    "path": "dataset-curated/reports/BlockSec/blocksec_astherus_ApxExchange_202506-signed.pdf",
    "project_info": {
        "url": [
            "https://github.com/asterdex/apx-exchange-contract/tree/AP-2631"
        ],
        "commit_id": [
            "f5993b7a90283f5dab7eed3f036a593c3dc08e3c"
        ],
        "address": [],
        "chain": null,
        "compiler_version": "n/a",
        "audit_date": "2025-06-25",
        "project_path": "n/a"
    },
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Lack of invoking function _disableInitializers()",
            "description": "The contract ApxExchange does not invoke the _disableInitializers() function in its constructor. This function is part of the OpenZeppelin Initializable pattern and is critical for permanently locking the initialization mechanism after deployment. Without calling this function, the contract remains vulnerable to re-initialization attacks, where a malicious actor could re-initialize the contract and potentially take control of critical state variables or roles. This could occur if the initializer guard is not properly disabled, allowing unauthorized reconfiguration of the contract. The impact includes potential privilege escalation and loss of contract integrity.\n",
            "severity": null,
            "location": [
                "ApxExchange.sol"
            ],
            "files": []
        },
        {
            "id": 1,
            "category": {},
            "title": "Add non-zero address checks",
            "description": "The initialize() function in ApxExchange.sol accepts multiple address parameters (_vaultAddress and _admin) without validating that they are non-zero. This lack of input validation could lead to accidental misconfiguration if a zero address is passed during initialization. Setting critical contract addresses (like vault or admin) to the zero address would render the contract inoperable or insecure, as token transfers or administrative functions would fail or be unmanageable. An attacker could potentially exploit this during deployment or proxy upgrades if initialization is re-invoked improperly. The impact includes operational failure and potential loss of funds due to misrouted transfers.\n",
            "severity": null,
            "location": [
                "ApxExchange.sol::initialize#85-99"
            ],
            "files": []
        },
        {
            "id": 2,
            "category": {},
            "title": "Unify the type for exchange rates",
            "description": "The contract uses inconsistent data types for exchange rate variables: exchangeRate is declared as uint56, while ExchangeInfo.exchangeRate is uint256. This inconsistency can lead to type conversion issues, potential truncation, or unexpected arithmetic behavior during calculations. It may also introduce confusion during code review or future maintenance, increasing the risk of logic errors. Although no direct exploit path is evident, such discrepancies can mask deeper bugs, especially in precision-sensitive financial calculations. The impact includes potential miscalculations in token exchange amounts, leading to incorrect user payouts or economic imbalance.\n",
            "severity": null,
            "location": [
                "ApxExchange.sol"
            ],
            "files": []
        },
        {
            "id": 3,
            "category": {},
            "title": "Add non-zero value checks for the variable exchangeAmount",
            "description": "The variable exchangeAmount, calculated in both exchange() and lockFor() functions, is derived from multiplication and division operations that could result in zero due to precision loss, especially when input amounts or exchange rates are small. Although the input amount is checked for zero, the resulting exchangeAmount is not validated before use. If exchangeAmount becomes zero, users may perform transactions that effectively receive no value, leading to user fund loss or confusion. This could be exploited in edge cases involving low amounts or specific exchange rates. The impact includes potential loss of user funds due to incorrect or zero-value token transfers.\n",
            "severity": null,
            "location": [
                "ApxExchange.sol::exchange#114-126",
                "ApxExchange.sol::lockFor#187-193"
            ],
            "files": []
        },
        {
            "id": 4,
            "category": {},
            "title": "Follow the CEI pattern when transferring tokens",
            "description": "Several functions, including exchange() and claim(), violate the Checks-Effects-Interactions (CEI) pattern by performing external token transfers (interactions) before updating the contract's internal state (effects). Specifically, AST tokens are transferred to the user before updating totalExchangedAmount. This creates a potential reentrancy window, although the contract uses nonReentrant guard. However, relying solely on reentrancy guards is riskier than following CEI as a defense-in-depth. If the guard were ever bypassed or disabled, the contract would be vulnerable. The impact includes potential reentrancy-based fund draining if external calls are exploited during state updates.\n",
            "severity": null,
            "location": [
                "ApxExchange.sol::exchange#114-126"
            ],
            "files": []
        },
        {
            "id": 5,
            "category": {},
            "title": "Users can claim AST tokens when the project is paused",
            "description": "The document states that users can claim AST tokens even when the project is paused. However, the description is brief and lacks details on which function enables this, whether it's intentional, and what the implications are. The finding appears to be a note rather than a confirmed vulnerability, but it suggests a potential inconsistency in access control during paused states. Further context is needed to determine if this behavior violates the intended security model. The impact could range from benign to critical depending on whether paused state is meant to halt all token movements.\n",
            "severity": null,
            "location": [],
            "files": []
        }
    ]
}