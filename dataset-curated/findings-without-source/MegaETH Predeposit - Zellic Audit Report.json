{
    "path": "dataset-curated/reports/Zellic/MegaETH Predeposit - Zellic Audit Report.pdf",
    "project_info": {
        "url": [
            "https://github.com/megaeth-labs/pre-deposit-vault"
        ],
        "commit_id": [
            "346955cb7236255f876de7b0faa4954229b9649e"
        ],
        "address": null,
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-11-14",
        "project_path": "n/a"
    },
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Centralization risks",
            "description": "The contract relies entirely on an owner-only access control model for critical functions such as pausing deposits, modifying caps, rotating signers, and withdrawing any ERC-20 token balance to the treasury. This centralization means that all fund custody and configuration changes depend solely on the owner's key. The lack of safeguards such as multi-signature requirements or timelock mechanisms creates a single point of failure. If the owner's private key is compromised or the owner acts maliciously, they can withdraw all deposited USDC to an arbitrary treasury address without user consent. This undermines the trust-minimized nature of smart contracts and introduces significant protocol risk, especially in a custodial context where users have no withdrawal mechanism.\n",
            "severity": "Medium",
            "location": [
                "MegaUSDCDepositVault.sol::withdrawToTreasury#"
            ],
            "files": []
        },
        {
            "id": 1,
            "category": {},
            "title": "Zero-value entityID allows wallet rebinding",
            "description": "The deposit function in MegaUSDCDepositVault uses a mapping from wallet to entityID (walletToEntityID) to enforce a one-to-one binding between a wallet and an entity. However, the logic checks for an existing binding by comparing the stored entityID against bytes16(0), treating zero as unbound. Since entityID = 0 is a valid permit, a user can first deposit with entityID 0, which gets stored as zero. Later, the same wallet can pass the binding check because the condition treats zero as unbound, allowing it to bind to a different, nonzero entityID. This flaw breaks the intended one-wallet-per-entity guarantee. An attacker can exploit this by reusing a single wallet to deposit under multiple entity IDs, thereby circumventing allocation limits and undermining the KYC-based eligibility system. This enables unfair advantage and potential abuse of the pre-deposit mechanism.\n",
            "severity": "Low",
            "location": [
                "MegaUSDCDepositVault.sol::deposit#"
            ],
            "files": []
        }
    ]
}