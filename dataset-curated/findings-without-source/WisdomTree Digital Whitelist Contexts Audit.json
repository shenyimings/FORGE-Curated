{
    "path": "dataset-curated/reports/OpenZeppelin/WisdomTree Digital Whitelist Contexts Audit.md",
    "project_info": {
        "url": [
            "https://bitbucket.org/wisdomtreeam/whitelist-contexts"
        ],
        "commit_id": [
            "44760785af1696704cdfcc56c2ba4a17ff603fb5"
        ],
        "address": [],
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-01-27",
        "project_path": "n/a"
    },
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Lack of Granular Permission Control in `WhitelistComplianceOracle`",
            "description": "The `WhitelistComplianceOracle` contract relies solely on the `DEFAULT_ADMIN_ROLE` for all administrative functions, including upgrading the beacon, managing address contexts, enabling/disabling the oracle, and setting configuration limits. This concentration of power in a single role increases the risk associated with its compromise, as no separation of duties is enforced. The root cause is the lack of role specialization in the access control design. An attacker who gains access to an account with `DEFAULT_ADMIN_ROLE` could reconfigure the entire oracle system, potentially disabling compliance checks or redirecting to a malicious beacon. This could lead to unauthorized transfers bypassing whitelist checks, undermining the entire security model of dependent token contracts.\n",
            "severity": "Low",
            "location": [
                "WhitelistComplianceOracle.sol::WhitelistComplianceOracle"
            ],
            "files": []
        },
        {
            "id": 1,
            "category": {},
            "title": "Missing Event Emission",
            "description": "The `setBaseURI` and `setTokenURI` functions in the `ERC721SoulboundToken` contract do not emit events when modifying URI-related state variables. This omission makes it difficult for off-chain applications, indexers, and monitoring tools to detect and react to changes in token metadata. The root cause is the absence of explicit event emissions in these setter functions. An attacker or malicious admin could change the token URI without triggering any on-chain notification, leading to potential misinformation or undetected manipulation of token data. While the direct financial impact is low, it affects transparency and trust in the system.\n",
            "severity": "Low",
            "location": [
                "ERC721SoulboundToken.sol::setBaseURI#219-221",
                "ERC721SoulboundToken.sol::setTokenURI#226-229"
            ],
            "files": []
        },
        {
            "id": 2,
            "category": {},
            "title": "Floating Pragma",
            "description": "The codebase uses floating pragma directives (`^0.8.19`), which allow compilation with any minor version of Solidity greater than or equal to 0.8.19. This introduces non-deterministic compilation risks, as different compiler versions may produce different bytecode due to changes in the compiler itself. The root cause is the use of the caret (`^`) operator in the pragma statement. An attacker could potentially exploit subtle compiler bugs present in a newer patch version that was not considered during audit or testing. Additionally, it complicates verification and reproducibility of the deployed bytecode, increasing the risk of deployment mismatches.\n",
            "severity": "Low",
            "location": [],
            "files": []
        },
        {
            "id": 3,
            "category": {},
            "title": "Inconsistent Access Control When Granting The Delegated Admin Role",
            "description": "The `grantDelegateAdminRole` function allows both `DEFAULT_ADMIN_ROLE` and `DELEGATED_ADMIN_ROLE` to grant the role, but the batch version `batchGrantDelegateAdminRole` restricts access to only `DEFAULT_ADMIN_ROLE`. This inconsistency creates confusion in the access control model and may lead to unexpected privilege escalation paths or operational limitations. The root cause is an intentional design decision to restrict batch operations, but it breaks the expected symmetry in role management. A `DELEGATED_ADMIN_ROLE` holder might expect to be able to batch-grant roles they can individually grant, leading to potential misconfigurations or denial of expected functionality. This reduces the usability and clarity of the access control system.\n",
            "severity": "Informational",
            "location": [
                "AccessControl.sol::grantDelegateAdminRole#175-177",
                "AccessControl.sol::batchGrantDelegateAdminRole#203-206"
            ],
            "files": []
        },
        {
            "id": 4,
            "category": {},
            "title": "Redundant Code",
            "description": "Multiple instances of redundant code were identified. First, the `upgradeBeaconToAndCall` function in several contracts contains a `require(newBeacon != address(0))` check, which is already performed in the internal `_setBeacon` function, making the check redundant. Second, the `supportsInterface` function in several contracts unconditionally returns `false`, ignoring the interface ID check, which defeats the purpose of the function. The root cause is oversight in code optimization and logic implementation. While the impact is minimal, redundant checks increase gas costs slightly, and incorrect `supportsInterface` behavior may cause integration issues with tools or contracts expecting standard ERC-165 compliance. This affects code maintainability and efficiency.\n",
            "severity": "Informational",
            "location": [
                "WhitelistComplianceOracle.sol::upgradeBeaconToAndCall#151",
                "ERC721BasicToken.sol::upgradeBeaconToAndCall#162",
                "ERC721SoulboundToken.sol::upgradeBeaconToAndCall#156",
                "WhitelistComplianceOracle.sol::supportsInterface#338",
                "ERC721BasicToken.sol::supportsInterface#457",
                "ERC721SoulboundToken.sol::supportsInterface#403"
            ],
            "files": []
        },
        {
            "id": 5,
            "category": {},
            "title": "Using `int/uint` Instead of `int256/uint256`",
            "description": "The codebase uses `int` and `uint` instead of the explicit `int256` and `uint256` types in several locations, particularly in interface definitions and internal functions. While `uint` is an alias for `uint256`, using the explicit form improves code clarity and consistency. The root cause is a lack of strict type naming convention. Although there is no functional or security impact, this reduces code readability and may lead to confusion for developers unfamiliar with Solidity's type aliases. It also deviates from best practices that favor explicit type declarations for maintainability and auditability.\n",
            "severity": "Informational",
            "location": [
                "IWhitelistComplianceOracle.sol::line-23",
                "IWhitelistComplianceOracle.sol::line-31",
                "IWhitelistComplianceOracle.sol::line-50",
                "IWhitelistComplianceOracle.sol::line-60",
                "StorageSlot.sol::line-101",
                "WhitelistComplianceOracle.sol::line-44",
                "WhitelistComplianceOracle.sol::line-170",
                "WhitelistComplianceOracle.sol::line-213",
                "WhitelistComplianceOracle.sol::line-221",
                "WhitelistComplianceOracle.sol::line-297",
                "WhitelistComplianceOracle.sol::line-299",
                "WhitelistComplianceOracle.sol::line-303",
                "WhitelistComplianceOracle.sol::line-317",
                "WhitelistComplianceOracle.sol::line-369"
            ],
            "files": []
        },
        {
            "id": 6,
            "category": {},
            "title": "Lack of Security Contact",
            "description": "The contracts do not include a NatSpec `@custom:security-contact` comment, making it difficult for security researchers or external parties to report vulnerabilities. The root cause is the absence of a standardized security disclosure mechanism in the code. This increases the risk that a discovered vulnerability may not be reported to the correct team, potentially leading to public exploitation before mitigation. While not a direct code vulnerability, it weakens the project's overall security posture and incident response readiness.\n",
            "severity": "Informational",
            "location": [],
            "files": []
        },
        {
            "id": 7,
            "category": {},
            "title": "Duplicate Imports",
            "description": "Some interface files contain duplicate imports. For example, `IERC721SoulboundToken.sol` imports `IERC721SoulboundEvents.sol` even though it is already imported via `IERC721Soulbound.sol`. Similarly, `IERC721Token.sol` redundantly imports `IERC721Events.sol`. The root cause is oversight in dependency management. While Solidity compilers handle this gracefully, it reduces code clarity and increases compilation time slightly. It may also confuse developers about the actual dependency graph, leading to maintenance difficulties.\n",
            "severity": "Informational",
            "location": [
                "IERC721SoulboundToken.sol::line-10",
                "IERC721Token.sol::line-10"
            ],
            "files": []
        },
        {
            "id": 8,
            "category": {},
            "title": "Use Custom Errors",
            "description": "Solidity's custom errors (introduced in 0.8.4) offer a more gas-efficient and cleaner way to handle revert conditions compared to string-based require/revert messages. The codebase currently uses numerous string literals in require and revert statements across multiple files including Beacon.sol, ERC721BasicToken.sol, ERC721SoulboundToken.sol, and WhitelistComplianceOracle.sol. The root cause is the use of legacy error handling patterns instead of modern custom errors. While this does not lead to direct fund loss, it increases gas costs for users during failure conditions. An attacker cannot directly exploit this, but the inefficiency impacts all users and increases transaction costs. The impact is ongoing gas overconsumption and reduced user experience.\n",
            "severity": "Low",
            "location": [
                "Beacon.sol::#20",
                "Beacon.sol::#30",
                "ERC721BasicToken.sol::#97",
                "ERC721BasicToken.sol::#119",
                "ERC721BasicToken.sol::#120",
                "ERC721BasicToken.sol::#121",
                "ERC721BasicToken.sol::#122",
                "ERC721BasicToken.sol::#124",
                "ERC721BasicToken.sol::#129",
                "ERC721BasicToken.sol::#162",
                "ERC721BasicToken.sol::#170",
                "ERC721BasicToken.sol::#199",
                "ERC721BasicToken.sol::#229",
                "ERC721BasicToken.sol::#764",
                "ERC721BasicToken.sol::#889",
                "ERC721SoulboundToken.sol::#91",
                "ERC721SoulboundToken.sol::#113",
                "ERC721SoulboundToken.sol::#114",
                "ERC721SoulboundToken.sol::#115",
                "ERC721SoulboundToken.sol::#116",
                "ERC721SoulboundToken.sol::#118",
                "ERC721SoulboundToken.sol::#123",
                "ERC721SoulboundToken.sol::#156",
                "ERC721SoulboundToken.sol::#164",
                "ERC721SoulboundToken.sol::#227",
                "ERC721SoulboundToken.sol::#235",
                "ERC721SoulboundToken.sol::#304",
                "ERC721SoulboundToken.sol::#316",
                "ERC721SoulboundToken.sol::#329",
                "ERC721SoulboundToken.sol::#341",
                "ERC721SoulboundToken.sol::#353",
                "ERC721SoulboundToken.sol::#366",
                "ERC721SoulboundToken.sol::#380",
                "ERC721SoulboundToken.sol::#563",
                "ERC721SoulboundToken.sol::#713",
                "WhitelistComplianceOracle.sol::#87",
                "WhitelistComplianceOracle.sol::#100",
                "WhitelistComplianceOracle.sol::#115",
                "WhitelistComplianceOracle.sol::#116",
                "WhitelistComplianceOracle.sol::#118",
                "WhitelistComplianceOracle.sol::#119",
                "WhitelistComplianceOracle.sol::#151",
                "WhitelistComplianceOracle.sol::#159",
                "WhitelistComplianceOracle.sol::#172",
                "WhitelistComplianceOracle.sol::#173",
                "WhitelistComplianceOracle.sol::#174",
                "WhitelistComplianceOracle.sol::#179",
                "WhitelistComplianceOracle.sol::#185",
                "WhitelistComplianceOracle.sol::#191",
                "WhitelistComplianceOracle.sol::#198",
                "WhitelistComplianceOracle.sol::#215",
                "WhitelistComplianceOracle.sol::#236",
                "WhitelistComplianceOracle.sol::#253",
                "WhitelistComplianceOracle.sol::#257",
                "WhitelistComplianceOracle.sol::#286",
                "WhitelistComplianceOracle.sol::#359"
            ],
            "files": []
        },
        {
            "id": 9,
            "category": {},
            "title": "Missing Docstrings",
            "description": "The codebase lacks NatSpec documentation (docstrings) for several public and external functions and events, including the Upgraded event and upgradeTo function in Beacon.sol, safeMint and burn in ERC721SoulboundToken.sol, and various elements in IOracle.sol and IOracleBeaconUpgrade.sol. The root cause is insufficient code documentation practices. While this does not directly lead to security vulnerabilities, it reduces code readability, increases the risk of incorrect usage by developers, and complicates auditing and maintenance. An attacker could potentially exploit ambiguity in function behavior, especially in complex logic, due to lack of clear specifications. The impact is reduced code maintainability and increased risk of integration errors or misinterpretation of intended behavior.\n",
            "severity": "Low",
            "location": [
                "Beacon.sol::Upgraded#17",
                "Beacon.sol::implementation#35",
                "Beacon.sol::upgradeTo#39",
                "ERC721SoulboundToken.sol::safeMint#182",
                "ERC721SoulboundToken.sol::burn#187",
                "IOracle.sol::OracleDisabled#10",
                "IOracle.sol::OracleEnabled#11",
                "IOracleBeaconUpgrade.sol::IOracleBeaconUpgrade#4",
                "IOracleBeaconUpgrade.sol::upgradeBeaconToAndCall#5"
            ],
            "files": []
        },
        {
            "id": 10,
            "category": {},
            "title": "Incorrect Docstrings",
            "description": "Several docstrings in the codebase are incorrect or misleading. The IERC721Soulbound interface contains comments that describe a standard ERC-721 token instead of a soulbound token. Additionally, the initializeWithRoles function in IERC721TokenInit and IERC721SoulboundTokenInit incorrectly states that ISSUER_ROLE is for token issuance, which is not accurate. The root cause is outdated or copy-pasted documentation. This can lead to incorrect assumptions by developers integrating with the contracts or maintaining the code. An attacker could exploit misunderstandings in access control roles or token behavior, potentially leading to unauthorized actions if developers rely on incorrect documentation. The impact includes integration bugs, incorrect access control assumptions, and potential logic errors in dependent systems.\n",
            "severity": "Low",
            "location": [
                "IERC721Soulbound.sol::IERC721Soulbound#12",
                "IERC721TokenInit.sol::initializeWithRoles#9",
                "IERC721SoulboundTokenInit.sol::initializeWithRoles#9"
            ],
            "files": []
        },
        {
            "id": 11,
            "category": {},
            "title": "Predictable Storage Slot Preimage",
            "description": "The contracts use the StorageSlot library to store state variables in deterministic storage slots derived via keccak256 hashing. However, the preimage of these slots is predictable, meaning the storage location can be reverse-engineered. If future contract upgrades introduce vulnerabilities that allow arbitrary storage writes, an attacker could target specific storage slots. The root cause is the use of unobfuscated keccak256 hashes for storage slot calculation. An attacker could exploit this by crafting transactions that manipulate critical state variables if write access is ever exposed through a logic flaw. The impact could be severe, including loss of control over contract state or theft of funds, though the current risk is mitigated by the absence of such write primitives in the existing logic.\n",
            "severity": "Low",
            "location": [],
            "files": []
        },
        {
            "id": 12,
            "category": {},
            "title": "Token URL Cannot Be Set for Non-Existing Tokens",
            "description": "The setTokenURI functions in ERC721BasicToken and ERC721SoulboundToken do not allow setting metadata URIs for token IDs that do not yet exist. This restricts the contract's flexibility and prevents common use cases where token metadata is pre-configured before minting. The root cause is a design decision to enforce token existence before URI assignment. While not a direct security vulnerability, this limitation reduces composability and usability. An attacker cannot exploit this directly, but it may force developers into suboptimal workflows or external metadata management. The impact is reduced functionality and potential workarounds that could introduce additional complexity or risk.\n",
            "severity": "Low",
            "location": [
                "ERC721BasicToken.sol::setTokenURI#229",
                "ERC721SoulboundToken.sol::setTokenURI#227"
            ],
            "files": []
        },
        {
            "id": 13,
            "category": {},
            "title": "Discrepancies Between Interfaces and Contracts",
            "description": "There are naming discrepancies between function parameters in interfaces and their implementations. For example, IERC721 uses 'tokenURI' while the implementation uses 'tokenURI_', and similar mismatches exist for baseURI and interfaceID parameters. The root cause is inconsistent naming conventions across interface definitions and concrete contracts. This can lead to confusion during development and integration, and while Solidity does not enforce parameter name consistency, it can cause errors in tooling, documentation generation, or manual interface adherence. An attacker could potentially exploit misunderstandings in interface compliance, especially in systems that rely on reflection or automated analysis. The impact includes integration errors and potential logic flaws due to incorrect assumptions about parameter usage.\n",
            "severity": "Low",
            "location": [
                "IERC721.sol::setTokenURI#110",
                "ERC721BasicToken.sol::setTokenURI#228",
                "IERC721.sol::setBaseURI#117",
                "ERC721BasicToken.sol::setBaseURI#219",
                "IERC721Soulbound.sol::setTokenURI#61",
                "ERC721SoulboundToken.sol::setTokenURI#226",
                "IERC721Soulbound.sol::setBaseURI#68",
                "ERC721SoulboundToken.sol::setBaseURI#219",
                "IERC165.sol::supportsInterface#13",
                "WhitelistComplianceOracle.sol::supportsInterface#331",
                "ERC721BasicToken.sol::supportsInterface#442",
                "ERC721SoulboundToken.sol::supportsInterface#390"
            ],
            "files": []
        },
        {
            "id": 14,
            "category": {},
            "title": "Non-Explicit Imports Are Used",
            "description": "The codebase uses non-explicit Solidity imports (e.g., 'import \"X.sol\";') instead of named imports (e.g., 'import {A} from \"X.sol\";'). This practice reduces code clarity and increases the risk of naming conflicts, especially in files with multiple contracts or complex inheritance. The root cause is the use of legacy import syntax. While this does not directly introduce security vulnerabilities, it can lead to subtle bugs if symbol collisions occur or if imported symbols are misunderstood. An attacker could potentially exploit ambiguity in symbol resolution, especially in cases of shadowing or unexpected overrides. The impact is reduced code maintainability and increased risk of integration errors or logic flaws due to symbol confusion.\n",
            "severity": "Low",
            "location": [
                "Beacon.sol::#4",
                "ERC721BasicToken.sol::#4",
                "ERC721SoulboundToken.sol::#4",
                "WhitelistComplianceOracle.sol::#4",
                "IERC721Token.sol::#4",
                "IERC721SoulboundToken.sol::#4",
                "IWhitelistComplianceOracle.sol::#4",
                "IERC1155.sol::#6",
                "IERC721.sol::#6",
                "IERC721Enumerable.sol::#6",
                "IERC721Metadata.sol::#6",
                "IERC721Soulbound.sol::#6",
                "IERC721SoulboundEnumerable.sol::#6",
                "IERC721SoulboundMetadata.sol::#6",
                "IWhitelistOracle.sol::#4"
            ],
            "files": []
        },
        {
            "id": 15,
            "category": {},
            "title": "Unused internal Functions",
            "description": "Several internal functions, such as `_increaseBalance` and `_increaseBalanceVanila` in both `ERC721BasicToken.sol` and `ERC721SoulboundToken.sol`, are defined but not directly called within the current codebase. \nThe cause is the presence of utility functions intended for future extensibility or indirect use through other internal paths, but they are not actively invoked in the current implementation. \nWhile these functions are not directly exploitable, their presence can mislead developers and increase code complexity. \nThe impact is reduced code clarity and maintainability, though the team acknowledges their role as extension points and has added NatSpec comments to clarify intent.\n",
            "severity": "Informational",
            "location": [
                "ERC721BasicToken.sol::463-468",
                "ERC721BasicToken.sol::480-484",
                "ERC721SoulboundToken.sol::463-468",
                "ERC721SoulboundToken.sol::480-484"
            ],
            "files": []
        },
        {
            "id": 16,
            "category": {},
            "title": "Inconsistent Order Within Contracts",
            "description": "Multiple contracts, including `Beacon.sol` and `WhitelistComplianceOracle.sol`, do not follow the recommended function ordering as per the Solidity Style Guide. \nThe cause is a deviation from established coding standards, leading to reduced readability and maintainability. \nThis inconsistency does not present a direct attack vector but affects code navigation and developer onboarding. \nThe impact is a decrease in code legibility and potential for human error during future development or audits.\n",
            "severity": "Informational",
            "location": [
                "Beacon.sol",
                "WhitelistComplianceOracle.sol"
            ],
            "files": []
        },
        {
            "id": 17,
            "category": {},
            "title": "Function Visibility Overly Permissive",
            "description": "Numerous functions across multiple contracts are declared as `public` when they should be `external`, including `implementation` in `Beacon.sol`, and various token-related functions in `ERC721BasicToken.sol`, `ERC721SoulboundToken.sol`, and `WhitelistComplianceOracle.sol`. \nThe cause is unnecessarily broad function visibility, which allows internal calls even when not intended. \nWhile this does not lead to direct security breaches, it increases gas costs slightly for external calls and obscures the intended access pattern. \nThe impact includes minor inefficiencies and reduced code clarity, though the issue has been resolved by updating visibility in a subsequent commit.\n",
            "severity": "Informational",
            "location": [
                "Beacon.sol::implementation#35-37",
                "ERC721BasicToken.sol::setBaseURI#219-222",
                "ERC721BasicToken.sol::setTokenURI#228-232",
                "ERC721BasicToken.sol::approve#238-240",
                "ERC721BasicToken.sol::setApprovalForAll#247-249",
                "ERC721BasicToken.sol::safeTransferFrom#284-290",
                "ERC721BasicToken.sol::safeMint#330-333",
                "ERC721BasicToken.sol::batchSafeMint#339-345",
                "ERC721BasicToken.sol::batchBurn#367-372",
                "ERC721BasicToken.sol::ownerOf#387-389",
                "ERC721BasicToken.sol::tokenOfOwnerByIndex#394-399",
                "ERC721BasicToken.sol::tokenByIndex#411-416",
                "ERC721BasicToken.sol::getApproved#422-425",
                "ERC721BasicToken.sol::supportsInterface#442-458",
                "ERC721SoulboundToken.sol::safeMint#182-185",
                "ERC721SoulboundToken.sol::burn#187-189",
                "ERC721SoulboundToken.sol::batchSafeMint#195-201",
                "ERC721SoulboundToken.sol::batchBurn#207-212",
                "ERC721SoulboundToken.sol::setBaseURI#219-221",
                "ERC721SoulboundToken.sol::setTokenURI#226-229",
                "ERC721SoulboundToken.sol::tokenURI#234-243",
                "ERC721SoulboundToken.sol::ownerOf#258-260",
                "ERC721SoulboundToken.sol::tokenOfOwnerByIndex#265-270",
                "ERC721SoulboundToken.sol::tokenByIndex#282-287",
                "ERC721SoulboundToken.sol::safeTransferFrom#298-305",
                "ERC721SoulboundToken.sol::approve#312-317",
                "ERC721SoulboundToken.sol::setApprovalForAll#325-330",
                "ERC721SoulboundToken.sol::getApproved#338-342",
                "ERC721SoulboundToken.sol::isApprovedForAll#349-354",
                "ERC721SoulboundToken.sol::transferFrom#361-367",
                "ERC721SoulboundToken.sol::safeTransferFrom#375-381",
                "ERC721SoulboundToken.sol::supportsInterface#390-404",
                "WhitelistComplianceOracle.sol::supportsInterface#331-339"
            ],
            "files": []
        },
        {
            "id": 18,
            "category": {},
            "title": "Incomplete Docstrings",
            "description": "Several functions and events across multiple contracts lack complete NatSpec documentation, including missing parameter and return value descriptions. This reduces code readability and increases the risk of misinterpretation during integration or review. The root cause is inconsistent or absent use of documentation comments in the source code. While this does not directly enable exploitation, it can lead to incorrect usage of the contract API by developers or frontends, potentially resulting in unintended behavior or security issues in dependent systems. The impact is primarily on maintainability, auditability, and integration safety.\n",
            "severity": "Low",
            "location": [
                "ERC721BasicToken.sol::name#177-179",
                "ERC721BasicToken.sol::symbol#184-186",
                "ERC721BasicToken.sol::baseURI#191-193",
                "ERC721BasicToken.sol::tokenURI#198-211",
                "ERC721BasicToken.sol::totalSupply#404-406",
                "ERC721BasicToken.sol::getApproved#422-425",
                "ERC721BasicToken.sol::isApprovedForAll#431-433",
                "ERC721BasicToken.sol::setTokenURI#228-232",
                "ERC721BasicToken.sol::approve#238-240",
                "ERC721BasicToken.sol::transferFrom#255-269",
                "ERC721BasicToken.sol::setApprovalForAll#247-249",
                "ERC721BasicToken.sol::batchSafeMint#339-345",
                "ERC721BasicToken.sol::batchBurn#367-372",
                "ERC721SoulboundToken.sol::name#171-173",
                "ERC721SoulboundToken.sol::symbol#178-180",
                "ERC721SoulboundToken.sol::batchSafeMint#195-201",
                "ERC721SoulboundToken.sol::batchBurn#207-212",
                "ERC721SoulboundToken.sol::setBaseURI#219-221",
                "ERC721SoulboundToken.sol::setTokenURI#226-229",
                "ERC721SoulboundToken.sol::tokenURI#234-243",
                "WhitelistComplianceOracle.sol::canTransfer#278-288",
                "WhitelistComplianceOracle.sol::addContractAddress#167-207",
                "WhitelistComplianceOracle.sol::removeContractAddress#213-230",
                "IERC1155.sol::setApprovalForAll#22",
                "IERC1155.sol::safeTransferFrom#42-48",
                "IERC1155.sol::safeBatchTransferFrom#66-72",
                "IERC1155.sol::balanceOf#81",
                "IERC1155.sol::balanceOfBatch#90-93",
                "IERC1155.sol::isApprovedForAll#100",
                "IERC721.sol::balanceOf#122",
                "IERC721.sol::ownerOf#131",
                "IERC721.sol::getApproved#140",
                "IERC721.sol::isApprovedForAll#147",
                "IERC721.sol::safeTransferFrom#27-32",
                "IERC721.sol::safeTransferFrom#50-54",
                "IERC721.sol::transferFrom#72-76",
                "IERC721.sol::approve#91",
                "IERC721.sol::setApprovalForAll#103",
                "IERC721Enumerable.sol::totalSupply#16",
                "IERC721Enumerable.sol::tokenOfOwnerByIndex#22",
                "IERC721Enumerable.sol::tokenByIndex#28",
                "IERC721Events.sol::Transfer#13",
                "IERC721Events.sol::Approval#18",
                "IERC721Events.sol::ApprovalForAll#23",
                "IERC721Events.sol::BaseURIUpdated#28",
                "IERC721Events.sol::TokenURIUpdated#33",
                "IERC721Metadata.sol::name#16",
                "IERC721Metadata.sol::symbol#21",
                "IERC721Metadata.sol::baseURI#26",
                "IERC721Metadata.sol::tokenURI#31",
                "IERC721Soulbound.sol::balanceOf#73",
                "IERC721Soulbound.sol::ownerOf#82",
                "IERC721Soulbound.sol::safeTransferFrom#27-32",
                "IERC721Soulbound.sol::safeTransferFrom#50-54",
                "IERC721Soulbound.sol::transferFrom#100-104",
                "IERC721Soulbound.sol::approve#119",
                "IERC721Soulbound.sol::getApproved#140",
                "IERC721Soulbound.sol::setApprovalForAll#131",
                "IERC721Soulbound.sol::isApprovedForAll#147",
                "IERC721SoulboundEnumerable.sol::totalSupply#16",
                "IERC721SoulboundEnumerable.sol::tokenOfOwnerByIndex#22",
                "IERC721SoulboundEnumerable.sol::tokenByIndex#28",
                "IERC721SoulboundEvents.sol::Transfer#13",
                "IERC721SoulboundEvents.sol::Approval#18",
                "IERC721SoulboundEvents.sol::ApprovalForAll#23",
                "IERC721SoulboundMetadata.sol::name#16",
                "IERC721SoulboundMetadata.sol::symbol#21",
                "IERC721SoulboundMetadata.sol::tokenURI#26",
                "IERC721SoulboundReceiver.sol::onERC721Received#22-27"
            ],
            "files": []
        },
        {
            "id": 19,
            "category": {},
            "title": "Gas Optimizations",
            "description": "Multiple gas inefficiencies were identified in the codebase. First, the `upgradeBeaconToAndCall` functions in `ERC721BasicToken`, `ERC721SoulboundToken`, and `WhitelistComplianceOracle` read the beacon address from storage after updating it, resulting in an unnecessary `SLOAD` operation. This can be optimized by using the `newBeacon` value directly. Second, the use of postfix increment (`i++`) in loops across several functions causes higher gas usage compared to prefix increment (`++i`), as the former creates a temporary copy. The root cause is suboptimal coding practices. While these do not pose direct security risks, they increase transaction costs for users and reduce efficiency. The impact is financial inefficiency and reduced scalability due to higher gas consumption.\n",
            "severity": "Low",
            "location": [
                "ERC721BasicToken.sol::upgradeBeaconToAndCall#168",
                "ERC721SoulboundToken.sol::upgradeBeaconToAndCall#162",
                "WhitelistComplianceOracle.sol::upgradeBeaconToAndCall#157",
                "ERC721BasicToken.sol::batchSafeMint#341",
                "ERC721BasicToken.sol::batchBurn#369",
                "ERC721SoulboundToken.sol::batchSafeMint#197",
                "ERC721SoulboundToken.sol::batchBurn#209",
                "WhitelistComplianceOracle.sol::removeContractAddress#221",
                "WhitelistComplianceOracle.sol::isAddressWhitelisted#369",
                "WhitelistComplianceOracle.sol::getContractAddresses#317"
            ],
            "files": []
        }
    ]
}