{
    "path": "dataset-curated/reports/TrailofBits/2025-09-shapenetwork-buybackcontract-securityreview.pdf",
    "project_info": {
        "url": [
            "https://github.com/shape-network/shape-buyback"
        ],
        "commit_id": [
            "e90ce7f771ec910532b9d7b7359c3a17765eb20a"
        ],
        "address": null,
        "chain": "evm",
        "compiler_version": "n/a",
        "audit_date": "2025-08-18",
        "project_path": "n/a"
    },
    "findings": [
        {
            "id": 0,
            "category": {},
            "title": "Incorrect fee logic in getCurrentFee function",
            "description": "The getCurrentFee function in the ShapeBuyback contract returns incorrect fee values due to flawed conditional logic. Specifically, when no fee change is scheduled (nextFeeTimestamp == 0), the function incorrectly returns nextFee (which is 0) instead of the current fee, leading to a mismatch between the displayed fee and the actual fee charged during a claim.\n\nThe root cause is that the getCurrentFee function uses conditional logic that contradicts the logic in the _checkFee function, which is responsible for enforcing the actual fee during state changes. This inconsistency arises because getCurrentFee uses (nextFeeTimestamp - 0 && block.timestamp < nextFeeTimestamp) to decide between fee and nextFee, while _checkFee updates the current fee only when block.timestamp >= nextFeeTimestamp.\n\nAn attacker or regular user could be misled by the incorrect fee information. For example, a user calling getCurrentFee when nextFeeTimestamp is 0 would see a fee of 0 and may not approve any tokens. When they call claim(), the transaction would revert due to insufficient allowance, as the actual fee (stored in 'fee') is non-zero.\n\nThe impact is user confusion, failed transactions, and potential reputational damage. While funds are not directly at risk, the incorrect behavior undermines user trust and usability, classifying this as a low-severity issue.\n",
            "severity": "Low",
            "location": [
                "src/ShapeBuyback.sol::getCurrentFee",
                "src/ShapeBuyback.sol::_checkFee"
            ],
            "files": []
        },
        {
            "id": 1,
            "category": {},
            "title": "Missing zero address validation",
            "description": "The ShapeBuyback contract does not validate the _buybackRecipient parameter against the zero address in either the initialize function or the setBuybackRecipient function. This omission allows the buyback recipient to be set to the zero address, which would result in permanent loss of $SHAPE tokens during claim operations, as tokens are transferred to the zero address and become irrecoverable.\n\nThe root cause is the absence of input validation checks in both functions. While other critical parameters like _owner are validated, _buybackRecipient is not, creating a configuration risk. The setBuybackRecipient function, in particular, allows the owner to set the recipient to address(0) without any guardrails.\n\nAn attacker with access to the owner role could maliciously set the buyback recipient to the zero address. Alternatively, an honest owner could make a mistake during configuration, leading to accidental token loss. The exploit does not require sophisticated techniques and can be performed via a standard transaction.\n\nThe impact is permanent loss of $SHAPE tokens for all users during claim operations. While the contract's core functionality remains intact and no funds are stolen, the misconfiguration leads to irreversible asset destruction. This is classified as an informational issue due to the lack of direct financial theft, but it represents a significant operational risk.\n",
            "severity": "Informational",
            "location": [
                "src/ShapeBuyback.sol::initialize",
                "src/ShapeBuyback.sol::setBuybackRecipient"
            ],
            "files": []
        }
    ]
}