// SPDX-License-Identifier: Apache-2.0 OR MIT
pragma solidity ^0.8.27;

import {Test, console} from "forge-std/Test.sol";
import {Payments} from "../src/Payments.sol";
import {MockFeeOnTransferTokenWithPermit} from "./mocks/MockFeeOnTransferTokenWithPermit.sol";
import {PaymentsTestHelpers} from "./helpers/PaymentsTestHelpers.sol";
import {BaseTestHelper} from "./helpers/BaseTestHelper.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

contract FeeOnTransferVulnerabilityTest is Test, BaseTestHelper {
    PaymentsTestHelpers helper;
    Payments payments;
    MockFeeOnTransferTokenWithPermit feeToken;

    uint256 internal constant INITIAL_BALANCE = 10000 ether;
    uint256 internal constant DEPOSIT_AMOUNT = 1000 ether;
    uint256 internal constant FEE_PERCENTAGE = 200; // 2% fee

    function setUp() public {
        // Create test helpers and setup environment
        helper = new PaymentsTestHelpers();
        helper.setupStandardTestEnvironment();
        payments = helper.payments();

        // Create fee-on-transfer token with 2% fee
        feeToken = new MockFeeOnTransferTokenWithPermit("PermitFeeToken", "PFEE", FEE_PERCENTAGE);

        // Mint tokens to users
        feeToken.mint(USER1, INITIAL_BALANCE);
        feeToken.mint(USER2, INITIAL_BALANCE);

        // Approve payments contract
        vm.prank(USER1);
        feeToken.approve(address(payments), type(uint256).max);

        vm.prank(USER2);
        feeToken.approve(address(payments), type(uint256).max);
    }

    function testFeeOnTransferVulnerabilityBasic() public {
        // Record initial balances
        uint256 contractBalanceBefore = feeToken.balanceOf(address(payments));

        // User1 deposits 1000 tokens, but due to 2% fee, only 980 actually reach the contract
        vm.prank(USER1);
        payments.deposit(address(feeToken), USER1, DEPOSIT_AMOUNT);

        // Check actual token balance vs recorded balance
        uint256 contractBalanceAfter = feeToken.balanceOf(address(payments));
        uint256 actualTokensReceived = contractBalanceAfter - contractBalanceBefore;
        uint256 expectedTokensReceived = DEPOSIT_AMOUNT - (DEPOSIT_AMOUNT * FEE_PERCENTAGE / 10000);

        // The contract actually received less due to fee
        assertEq(actualTokensReceived, expectedTokensReceived, "Contract received expected amount after fee");
        assertLt(actualTokensReceived, DEPOSIT_AMOUNT, "Contract received less than deposit amount");

        // The payments contract also knows it does not have the full amount
        (, uint256 recordedFunds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER1);
        assertEq(recordedFunds, expectedTokensReceived, "Contract recorded full deposit amount");
    }

    function testFeeOnTransferWithDepositWithPermit() public {
        // Record initial balances
        uint256 contractBalanceBefore = feeToken.balanceOf(address(payments));

        // Prepare permit parameters
        uint256 deadline = block.timestamp + 1 hours;

        // Get permit signature
        (uint8 v, bytes32 r, bytes32 s) =
            getPermitSignature(feeToken, user1Sk, USER1, address(payments), DEPOSIT_AMOUNT, deadline);

        // User1 deposits 1000 tokens using permit, but due to 2% fee, only 980 actually reach the contract
        vm.prank(USER1);
        payments.depositWithPermit(address(feeToken), USER1, DEPOSIT_AMOUNT, deadline, v, r, s);

        // Check actual token balance vs recorded balance
        uint256 contractBalanceAfter = feeToken.balanceOf(address(payments));
        uint256 actualTokensReceived = contractBalanceAfter - contractBalanceBefore;
        uint256 expectedTokensReceived = DEPOSIT_AMOUNT - (DEPOSIT_AMOUNT * FEE_PERCENTAGE / 10000);

        // The contract actually received less due to fee
        assertEq(actualTokensReceived, expectedTokensReceived, "Contract received expected amount after fee");
        assertLt(actualTokensReceived, DEPOSIT_AMOUNT, "Contract received less than deposit amount");

        // With the fix, the payments contract should record the actual amount received
        (, uint256 recordedFunds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER1);
        assertEq(recordedFunds, expectedTokensReceived, "Contract recorded actual received amount");

        console.log("Deposit amount:", DEPOSIT_AMOUNT);
        console.log("Actual tokens received:", actualTokensReceived);
        console.log("Recorded balance:", recordedFunds);
        console.log("Discrepancy:", recordedFunds > actualTokensReceived ? recordedFunds - actualTokensReceived : 0);
    }

    function getPermitSignature(
        MockFeeOnTransferTokenWithPermit token,
        uint256 privateKey,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline
    ) internal view returns (uint8 v, bytes32 r, bytes32 s) {
        uint256 nonce = token.nonces(owner);
        bytes32 DOMAIN_SEPARATOR = token.DOMAIN_SEPARATOR();

        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"),
                owner,
                spender,
                value,
                nonce,
                deadline
            )
        );

        bytes32 digest = MessageHashUtils.toTypedDataHash(DOMAIN_SEPARATOR, structHash);

        (v, r, s) = vm.sign(privateKey, digest);
    }

    function testFeeOnTransferWithDepositWithPermitAndApproveOperator() public {
        // Record initial balances
        uint256 contractBalanceBefore = feeToken.balanceOf(address(payments));

        // Prepare permit and operator approval parameters
        uint256 deadline = block.timestamp + 1 hours;
        uint256 rateAllowance = 10 ether;
        uint256 lockupAllowance = 100 ether;
        uint256 maxLockupPeriod = 100;

        // Get permit signature
        (uint8 v, bytes32 r, bytes32 s) =
            getPermitSignature(feeToken, user1Sk, USER1, address(payments), DEPOSIT_AMOUNT, deadline);

        // User1 deposits 1000 tokens using permit and approves operator, but due to 2% fee, only 980 actually reach the contract
        vm.prank(USER1);
        payments.depositWithPermitAndApproveOperator(
            address(feeToken),
            USER1,
            DEPOSIT_AMOUNT,
            deadline,
            v,
            r,
            s,
            OPERATOR,
            rateAllowance,
            lockupAllowance,
            maxLockupPeriod
        );

        // Check actual token balance vs recorded balance
        uint256 contractBalanceAfter = feeToken.balanceOf(address(payments));
        uint256 actualTokensReceived = contractBalanceAfter - contractBalanceBefore;
        uint256 expectedTokensReceived = DEPOSIT_AMOUNT - (DEPOSIT_AMOUNT * FEE_PERCENTAGE / 10000);

        // The contract actually received less due to fee
        assertEq(actualTokensReceived, expectedTokensReceived, "Contract received expected amount after fee");
        assertLt(actualTokensReceived, DEPOSIT_AMOUNT, "Contract received less than deposit amount");

        // With the fix, the payments contract should record the actual amount received
        (, uint256 recordedFunds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER1);
        assertEq(recordedFunds, expectedTokensReceived, "Contract recorded actual received amount");

        // Verify operator approval was set correctly
        (bool isApproved, uint256 actualRateAllowance, uint256 actualLockupAllowance,,, uint256 actualMaxLockupPeriod) =
            payments.operatorApprovals(address(feeToken), USER1, OPERATOR);
        assertEq(isApproved, true, "Operator should be approved");
        assertEq(actualRateAllowance, rateAllowance, "Rate allowance should be set");
        assertEq(actualLockupAllowance, lockupAllowance, "Lockup allowance should be set");
        assertEq(actualMaxLockupPeriod, maxLockupPeriod, "Max lockup period should be set");

        console.log("Deposit amount:", DEPOSIT_AMOUNT);
        console.log("Actual tokens received:", actualTokensReceived);
        console.log("Recorded balance:", recordedFunds);
        console.log("Operator approved:", isApproved);
    }
}
