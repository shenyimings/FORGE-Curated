// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.26;

import "./BaseTest.sol";
import {EulerEarnFactory} from "../../src/EulerEarnFactory.sol";
import {EulerEarn} from "../../src/EulerEarn.sol";

uint256 constant TIMELOCK = 1 weeks;

contract IntegrationTest is BaseTest {
    IEulerEarnFactory eeFactory;
    IEulerEarn internal vault;

    function setUp() public virtual override {
        super.setUp();

        eeFactory = new EulerEarnFactory(admin, address(evc), address(permit2), address(perspective));
        vault = eeFactory.createEulerEarn(
            OWNER, TIMELOCK, address(loanToken), "EulerEarn Vault", "EEV", bytes32(uint256(1))
        );

        vm.startPrank(OWNER);
        vault.setCurator(CURATOR);
        vault.setIsAllocator(ALLOCATOR, true);
        vault.setFeeRecipient(FEE_RECIPIENT);

        vm.stopPrank();

        _setCap(idleVault, type(uint136).max);

        loanToken.approve(address(vault), type(uint256).max);
        collateralToken.approve(address(vault), type(uint256).max);

        vm.startPrank(SUPPLIER);
        loanToken.approve(address(vault), type(uint256).max);
        collateralToken.approve(address(vault), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(ONBEHALF);
        loanToken.approve(address(vault), type(uint256).max);
        collateralToken.approve(address(vault), type(uint256).max);
        vm.stopPrank();
    }

    // Deploy EulerEarn from artifacts
    // Replaces using `new EulerEarn` which would force 0.8.26 on all tests
    // (since EulerEarn has pragma solidity ^0.8.26)
    function createEulerEarn(
        address owner,
        address evc,
        address permit2,
        uint256 initialTimelock,
        address asset,
        string memory name,
        string memory symbol
    ) public returns (IEulerEarn) {
        return IEulerEarn(
            deployCode("EulerEarn.sol", abi.encode(owner, evc, permit2, initialTimelock, asset, name, symbol))
        );
    }

    function _idle() internal view returns (uint256) {
        return idleVault.balanceOf(address(vault)); // escrow vault doesn't accrue interest so shares == assets
    }

    /// @dev Bounds the timelock to be smaller and in the acceptable range after deployment.
    function _boundTimelock(uint256 timelock) internal pure returns (uint256) {
        return bound(timelock, ConstantsLib.POST_INITIALIZATION_MIN_TIMELOCK, TIMELOCK - 1);
    }

    /// @dev Bounds the initial timelock to be in the acceptable range at deployment.
    function _boundInitialTimelock(uint256 initialTimelock) internal pure returns (uint256 boundedTimelock) {
        boundedTimelock = bound(initialTimelock, 0 days, ConstantsLib.MAX_TIMELOCK);
        if (boundedTimelock < ConstantsLib.POST_INITIALIZATION_MIN_TIMELOCK) boundedTimelock = 0;
    }

    function _setTimelock(uint256 newTimelock) internal {
        uint256 timelock = vault.timelock();
        if (newTimelock == timelock) return;

        // block.timestamp defaults to 1 which may lead to an unrealistic state: block.timestamp < timelock.
        if (block.timestamp < timelock) vm.warp(block.timestamp + timelock);

        PendingUint136 memory pendingTimelock = vault.pendingTimelock();
        if (pendingTimelock.validAt == 0 || newTimelock != pendingTimelock.value) {
            vm.prank(OWNER);
            vault.submitTimelock(newTimelock);
        }

        if (newTimelock > timelock) return;

        vm.warp(block.timestamp + timelock);

        vault.acceptTimelock();

        assertEq(vault.timelock(), newTimelock, "_setTimelock");
    }

    function _setGuardian(address newGuardian) internal {
        address guardian = vault.guardian();
        if (newGuardian == guardian) return;

        PendingAddress memory pendingGuardian = vault.pendingGuardian();
        if (pendingGuardian.validAt == 0 || newGuardian != pendingGuardian.value) {
            vm.prank(OWNER);
            vault.submitGuardian(newGuardian);
        }

        if (guardian == address(0)) return;

        vm.warp(block.timestamp + vault.timelock());

        vault.acceptGuardian();

        assertEq(vault.guardian(), newGuardian, "_setGuardian");
    }

    function _setFee(uint256 newFee) internal {
        uint256 fee = vault.fee();
        if (newFee == fee) return;

        vm.prank(OWNER);
        vault.setFee(newFee);

        assertEq(vault.fee(), newFee, "_setFee");
    }

    function _setCap(IEulerEarn _vault, IERC4626 id, uint256 newCap) internal {
        uint256 cap = _vault.config(id).cap;
        bool isEnabled = _vault.config(id).enabled;
        if (newCap == cap) return;

        PendingUint136 memory pendingCap = _vault.pendingCap(id);
        if (pendingCap.validAt == 0 || newCap != pendingCap.value) {
            vm.prank(CURATOR);
            _vault.submitCap(id, newCap);
        }

        if (newCap < cap) return;

        vm.warp(block.timestamp + _vault.timelock());

        _vault.acceptCap(id);

        assertEq(_vault.config(id).cap, newCap, "_setCap");

        if (newCap > 0) {
            if (!isEnabled) {
                IERC4626[] memory newSupplyQueue = new IERC4626[](_vault.supplyQueueLength() + 1);
                for (uint256 k; k < _vault.supplyQueueLength(); k++) {
                    newSupplyQueue[k] = _vault.supplyQueue(k);
                }
                newSupplyQueue[_vault.supplyQueueLength()] = id;
                vm.prank(ALLOCATOR);
                _vault.setSupplyQueue(newSupplyQueue);
            }
        }
    }

    function _setCap(IERC4626 id, uint256 newCap) internal {
        _setCap(vault, id, newCap);
    }

    function _sortSupplyQueueIdleLast() internal {
        IERC4626[] memory supplyQueue = new IERC4626[](vault.supplyQueueLength());

        uint256 supplyIndex;
        for (uint256 i; i < supplyQueue.length; ++i) {
            IERC4626 id = vault.supplyQueue(i);
            if (id == idleVault) continue;

            supplyQueue[supplyIndex] = id;
            ++supplyIndex;
        }

        supplyQueue[supplyIndex] = idleVault;
        ++supplyIndex;

        assembly {
            mstore(supplyQueue, supplyIndex)
        }

        vm.prank(ALLOCATOR);
        vault.setSupplyQueue(supplyQueue);
    }
}
