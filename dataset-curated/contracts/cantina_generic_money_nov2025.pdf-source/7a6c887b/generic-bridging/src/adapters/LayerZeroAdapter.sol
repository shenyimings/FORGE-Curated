// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.29;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { Ownable2Step } from "@openzeppelin/contracts/access/Ownable2Step.sol";

import { OApp, Origin, MessagingFee } from "@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol";
import { OAppOptionsType3 } from "@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol";

import { BaseAdapter, IBridgeCoordinator } from "./BaseAdapter.sol";
import { IBridgeAdapter } from "../interfaces/IBridgeAdapter.sol";
import { BridgeTypes } from "./BridgeTypes.sol";

/**
 * @title LayerZeroAdapter
 * @notice Bridge adapter using LayerZero's OApp for cross-chain messaging
 * @dev Handles message passing only - does NOT hold or manage tokens
 */
contract LayerZeroAdapter is BaseAdapter, OApp, OAppOptionsType3 {
    /**
     * @notice Emitted whenever a LayerZero endpoint identifier is configured for a given chain id.
     * @param chainId The canonical chain id managed by the bridge coordinator.
     * @param endpointId The LayerZero endpoint id representing that chain within the messaging network.
     */
    event EndpointIdConfigured(uint256 indexed chainId, uint32 indexed endpointId);
    /**
     * @notice Emitted after dispatching a LayerZero message so off-chain services can correlate internal ids.
     * @param messageId Internal message identifier generated by the adapter.
     * @param guid LayerZero GUID returned by the endpoint for the dispatched packet.
     * @param chainId Destination chain id recognised by the bridge coordinator.
     * @param endpointId Destination LayerZero endpoint id.
     */
    event MessageGuidRecorded(
        bytes32 indexed messageId, bytes32 indexed guid, uint256 indexed chainId, uint32 endpointId
    );

    /// @notice Thrown when the coordinator-provided remote adapter does not match the LayerZero peer configuration.
    /// @param configuredPeer The peer address registered in LayerZero's endpoint for the destination.
    /// @param coordinatorAdapter The adapter identifier supplied by the BridgeCoordinator call.
    error PeersMismatch(bytes32 configuredPeer, bytes32 coordinatorAdapter);

    /// @notice Msg type for sending a string, for use in OAppOptionsType3 as an enforced option
    uint16 public constant SEND = 1;

    /**
     * @notice Maps canonical EVM chain identifiers to the corresponding LayerZero endpoint ids.
     * @dev Used during outbound dispatch to resolve the destination endpoint for a given chain.
     */
    mapping(uint256 chainId => uint32 eid) public chainIdToEndpointId;
    /**
     * @notice Reverse lookup from LayerZero endpoint id back to the configured EVM chain identifier.
     * @dev Consumed within `_lzReceive` to recover the coordinator chain id from the inbound origin metadata.
     */
    mapping(uint32 eid => uint256 chainId) public endpointIdToChainId;

    constructor(
        IBridgeCoordinator _coordinator,
        address owner,
        address endpoint
    )
        BaseAdapter(_coordinator, owner)
        OApp(endpoint, owner)
    { }

    /// @inheritdoc BaseAdapter
    function _dispatchBridge(
        uint256 chainId,
        bytes32 remoteAdapter,
        bytes calldata message,
        address refundAddress,
        bytes calldata bridgeParams,
        bytes32 messageId
    )
        internal
        override
    {
        uint32 dstEid = chainIdToEndpointId[chainId];
        require(dstEid != 0, InvalidZeroAddress());

        bytes32 configuredPeer = _getPeerOrRevert(dstEid);
        require(configuredPeer == remoteAdapter, PeersMismatch(configuredPeer, remoteAdapter));

        bytes memory payload = abi.encode(message, messageId);
        bytes memory options = combineOptions(dstEid, SEND, bridgeParams);

        _lzSend(dstEid, payload, options, MessagingFee({ nativeFee: msg.value, lzTokenFee: 0 }), refundAddress);
    }

    /// @notice Invoked by OAppReceiver when EndpointV2.lzReceive is called
    /// @dev   _origin    Metadata (source chain, sender address, nonce)
    /// @dev   _guid      Global unique ID for tracking this message
    /// @param payload    ABI-encoded bridge payload forwarded from the remote adapter.
    /// @dev   executor   Executor address that delivered the message (unused here).
    /// @dev   extraData  Additional data from the executor (unused here).
    function _lzReceive(
        Origin calldata origin,
        bytes32 guid,
        bytes calldata payload,
        address,
        bytes calldata
    )
        internal
        override
    {
        uint256 chainId = endpointIdToChainId[origin.srcEid];
        require(chainId != 0, InvalidZeroAddress());

        (bytes memory messageData, bytes32 messageId) = abi.decode(payload, (bytes, bytes32));

        coordinator.settleInboundMessage(bridgeType(), chainId, origin.sender, messageData, messageId);

        emit MessageGuidRecorded(messageId, guid, chainId, origin.srcEid);
    }

    /// @inheritdoc IBridgeAdapter
    function estimateBridgeFee(
        uint256 chainId,
        bytes calldata message,
        bytes calldata bridgeParams
    )
        external
        view
        returns (uint256 nativeFee)
    {
        require(chainId != 0, InvalidZeroAddress());
        uint32 dstEid = chainIdToEndpointId[chainId];

        bytes memory messagePayload = abi.encode(message, getMessageId(chainId));

        // If bridgeParams is 0x, combineOptions will set whatever is defined in OAppOptionsType3 for this specific
        // dstEid This allows us to define custom gas for each chain we want to call
        return _quote(dstEid, messagePayload, combineOptions(dstEid, SEND, bridgeParams), false).nativeFee;
    }

    /// @inheritdoc BaseAdapter
    function bridgeType() public pure override returns (uint16) {
        return BridgeTypes.LAYER_ZERO;
    }

    /**
     * @notice Convenience helper to configure the endpoint id and LayerZero peer in a single call.
     * @param chainId Canonical chain identifier managed by the coordinator.
     * @param endpointId LayerZero endpoint id used to reach the remote chain.
     * @param remoteAdapter Adapter identifier registered in the coordinator on the remote chain.
     */
    function setRemoteEndpointConfig(
        uint256 chainId,
        uint32 endpointId,
        bytes32 remoteAdapter
    )
        external
        onlyOwner
    {
        require(chainId != 0, InvalidZeroAddress());
        require(endpointId != 0, InvalidZeroAddress());
        require(remoteAdapter != bytes32(0), InvalidZeroAddress());

        uint32 previousEndpointId = chainIdToEndpointId[chainId];
        if (previousEndpointId != 0 && previousEndpointId != endpointId) {
            delete endpointIdToChainId[previousEndpointId];
        }

        uint256 previousChainId = endpointIdToChainId[endpointId];
        if (previousChainId != 0 && previousChainId != chainId) {
            delete chainIdToEndpointId[previousChainId];
        }

        chainIdToEndpointId[chainId] = endpointId;
        endpointIdToChainId[endpointId] = chainId;
        emit EndpointIdConfigured(chainId, endpointId);

        setPeer(endpointId, remoteAdapter);
    }

    /// @notice Resolves the ownership diamond created by inheriting both Ownable2Step (via BaseAdapter)
    ///         and Ownable (via OAppOptionsType3). The overrides forward control to Ownable2Step so the
    ///         coordinator keeps its two-step ownership semantics while remaining compatible with OApp.
    function transferOwnership(address newOwner) public override(Ownable2Step, Ownable) {
        Ownable2Step.transferOwnership(newOwner);
    }

    /// @notice Resolves the ownership diamond created by inheriting both Ownable2Step (via BaseAdapter)
    ///         and Ownable (via OAppOptionsType3). The overrides forward control to Ownable2Step so the
    ///         coordinator keeps its two-step ownership semantics while remaining compatible with OApp.
    function _transferOwnership(address newOwner) internal override(Ownable2Step, Ownable) {
        Ownable2Step._transferOwnership(newOwner);
    }
}
